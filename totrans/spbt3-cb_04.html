<html><head></head><body>
		<div id="_idContainer075">
			<h1 class="chapter-number" id="_idParaDest-139"><a id="_idTextAnchor145"/>4</h1>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor146"/>Spring Cloud</h1>
			<p>In modern systems, you may find several microservices interacting with each other. Spring Cloud offers easy-to-deploy components that simplify the interaction and coordination of distributed systems to tackle large-scale application challenges such as scalability, availability, observability, <span class="No-Break">and resilience.</span></p>
			<p>In this chapter, you will learn how to use Spring Cloud components to develop a scalable and resilient distributed system. You will build upon the learnings of the previous chapters and configure security and observability in this Spring Cloud setup. This will help you effectively monitor and troubleshoot your distributed architecture. By the end of this journey, you will know how to design and develop <span class="No-Break">cloud-native applications.</span></p>
			<p>Finally, you will be taught how to deploy Spring Boot Admin, a widely used open source project in the Spring ecosystem. This project offers a user-friendly web interface that enables you to monitor and manage multiple Spring Boot applications centrally. Additionally, it can be effortlessly integrated with other Spring <span class="No-Break">Cloud components.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main recipes:</span></p>
			<ul>
				<li>Setting up <span class="No-Break">Eureka Server</span></li>
				<li>Integrating an application in <span class="No-Break">Eureka Server</span></li>
				<li>Scaling out the <span class="No-Break">RESTful API</span></li>
				<li>Setting up Spring <span class="No-Break">Cloud Gateway</span></li>
				<li>Testing Spring <span class="No-Break">Cloud Gateway</span></li>
				<li>Setting up Spring <span class="No-Break">Cloud Config</span></li>
				<li>Protecting Spring <span class="No-Break">Cloud Gateway</span></li>
				<li>Integrating distributed tracing with <span class="No-Break">Spring Cloud</span></li>
				<li>Deploying Spring <span class="No-Break">Boot Admin</span></li>
			</ul>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor147"/>Technical requirements</h1>
			<p>This chapter requires some services to be running on your computer, such as OpenZipkin. As usual, the easiest way to run them on your computer is by using Docker. You can get Docker<a id="_idIndexMarker384"/> from the Docket product page at https://www.docker.com/products/docker-desktop/. I will explain how to deploy each tool in its <span class="No-Break">corresponding recipe.</span></p>
			<p>The <em class="italic">Setting up Spring Cloud Config</em> recipe requires a git repository. You can create a GitHub account for <span class="No-Break">free (</span><a href="https://github.com/join"><span class="No-Break">https://github.com/join</span></a><span class="No-Break">).</span></p>
			<p>You can find the code for all the recipes in this chapter <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter4"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter4</span></a><span class="No-Break">.</span><a id="_idTextAnchor148"/><a id="_idTextAnchor149"/><a id="_idTextAnchor150"/><a id="_idTextAnchor151"/><a id="_idTextAnchor152"/></p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor153"/>Setting up Eureka Server</h1>
			<p>Eureka Server is a service registry<a id="_idIndexMarker385"/> that’s used in microservices architectures to register instances that other applications can discover. It’s a valuable service that allows services to locate and communicate with each other dynamically. This service registry performs health checks on the registered services’ instances, automatically removing the unhealthy or unresponsive ones. When a service needs to communicate with another service, Eureka Server provides the available instances, allowing <span class="No-Break">load balancing.</span></p>
			<p>In this recipe, you will learn how to create an application that implements <span class="No-Break">Eureka Server.</span></p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor154"/>Getting ready</h2>
			<p>This recipe doesn’t have any <span class="No-Break">additional requirements.</span></p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor155"/>How to do it...</h2>
			<p>In this recipe, we’ll create a new Eureka Server that we’ll reuse in the rest of the recipes. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>First, we’ll create a new application for Eureka Server. For that, open <a href="https://start.spring.io">https://start.spring.io</a> and use the same parameters that you did in the <em class="italic">Creating a RESTful API</em> recipe of <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, except change the <span class="No-Break">following options:</span><ul><li>For <strong class="bold">Artifact</strong>, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">registry</strong></span></li><li>For <strong class="bold">Dependencies</strong>, select <span class="No-Break"><strong class="bold">Eureka Server</strong></span></li></ul></li>
				<li>Then, in the generated<a id="_idIndexMarker386"/> project, in the <strong class="source-inline">resources</strong> folder, create a file named <strong class="source-inline">application.yml</strong> and set the <span class="No-Break">following configuration:</span><pre class="source-code">
server:
    port: 8761
eureka:
    client:
        registerWithEureka: false
        fetchRegistry: false</pre></li>				<li>Next, open the <strong class="source-inline">RegistryApplication</strong> class and annotate it <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@EnableEurekaServer</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">@EnableEurekaServer</strong>
@SpringBootApplication
public class RegistryApplication</pre></li>				<li>Now, you can start <span class="No-Break">the application.</span></li>
				<li>Let’s verify that Eureka Server is running. Open <strong class="source-inline">http://locahost:8761</strong> in <span class="No-Break">your browser:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer063">
					<img alt="Figure 4.1: Eureka Server" src="image/B21646_04_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1: Eureka Server</p>
			<p class="list-inset">On the Eureka Server page, you can see general information<a id="_idIndexMarker387"/> about the server and, most importantly, the applications registered on the server. Now, we don’t have any applications registered yet. Once we connect the applications in the following recipes, we will see them under <strong class="bold">Instances currently registered </strong><span class="No-Break"><strong class="bold">with Eureka</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor156"/>How it works...</h2>
			<p>The Eureka Server dependency in a Spring Boot application allows you to set up and run a service registry. When you use the <strong class="source-inline">@EnableEurekaServer</strong> annotation, the Eureka Server autoconfiguration is activated. The Eureka Server application must be configured so that it can stop itself from being registered as a service, which is why the <strong class="source-inline">eureka.client.registerWithEureka</strong> and <strong class="source-inline">eureka.client.fetchRegistry</strong> settings are both set to <strong class="source-inline">false</strong>. The other required Eureka Server configuration<a id="_idIndexMarker388"/> is the port. We configured Eureka Server to listen on <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">87<a id="_idTextAnchor157"/>61</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor158"/>Integrating an application in Eureka Server</h1>
			<p>In this recipe, we’ll integrate two applications<a id="_idIndexMarker389"/> into Eureka Server, which we deployed<a id="_idIndexMarker390"/> in the previous recipe. One application provides football data, which the other application consumes. We’ll use Eureka Server to register both applications, at which point the consumer will use Eureka Server to discover the <span class="No-Break">provider application.</span></p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor159"/>Getting ready</h2>
			<p>In addition to Eureka Server, which we deployed in the previous recipe, we’ll reuse the applications we created in the <em class="italic">Defining responses and data model exposed by the API</em> and <em class="italic">Consuming a RESTful API from another Spring Boot application</em> recipes in <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></p>
			<p>As a starting point, you can use the applications that I’ve prepared in this book’s repository: <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>. You can find the code in the <span class="No-Break"><strong class="source-inline">chapter4/recipe4-2/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor160"/>How to do it...</h2>
			<p>We’ll integrate the <strong class="source-inline">football</strong> and <strong class="source-inline">albums</strong> applications from the <em class="italic">Consuming a RESTful API from another Spring application using RestClient</em> recipe in <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, into Eureka Server, which we deployed in the previous recipe. Let’s make the <span class="No-Break">required adjustments:</span></p>
			<ol>
				<li>First, we will modify the applications so that they connect to the Eureka Server instance. We will start with the <strong class="source-inline">football</strong> application. Make the <span class="No-Break">following changes:</span><ul><li>Add the following dependencies to the <span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break"> file:</span><pre class="source-code">
&lt;dependency&gt;
     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
     &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
     &lt;artifactId&gt;spring-cloud-starter-netflix-eureka- client&lt;/artifactId&gt;
&lt;/dependency&gt;</pre></li><li>Ensure the <strong class="source-inline">pom.xml</strong> file has configured<a id="_idIndexMarker391"/> dependency management<a id="_idIndexMarker392"/> for <span class="No-Break">Spring Cloud:</span><pre class="source-code">&lt;dependencyManagement&gt;
     &lt;dependencies&gt;
          &lt;dependency&gt;
               &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
               &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
               &lt;version&gt;${spring-cloud.version}&lt;/version&gt;
               &lt;type&gt;pom&lt;/type&gt;
               &lt;scope&gt;import&lt;/scope&gt;
          &lt;/dependency&gt;
     &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</pre></li><li>Ensure that the <strong class="source-inline">spring-cloud.version</strong> property<a id="_idIndexMarker393"/> is defined<a id="_idIndexMarker394"/> in the <span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break"> file:</span><pre class="source-code">&lt;properties&gt;
    &lt;java.version&gt;21&lt;/java.version&gt;
    &lt;spring-cloud.version&gt;2022.0.4&lt;/spring-cloud.version&gt;
&lt;/properties&gt;</pre></li><li>In the <strong class="source-inline">resources</strong> folder, add a file named <strong class="source-inline">application.yml</strong> with the <span class="No-Break">following content:</span><pre class="source-code">server:
  port: 0
spring:
  application:
    name: FootballServer
eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/</pre></li></ul></li>				<li>Start the <span class="No-Break"><strong class="source-inline">football</strong></span><span class="No-Break"> application.</span></li>
				<li>At this point, you’ll be able to see the application registered in <span class="No-Break">Eureka Server:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer064">
					<img alt="Figure 4.2: The RESTful application registered in Eureka Server" src="image/B21646_04_2.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2: The RESTful application registered in Eureka Server</p>
			<ol>
				<li value="4">Next, modify <a id="_idIndexMarker395"/>the RESTful API <strong class="source-inline">albums</strong> consumer <a id="_idIndexMarker396"/>application by making the <span class="No-Break">following changes:</span><ul><li>Add the <strong class="source-inline">org.springframework.cloud:spring-cloud- starter-netflix-eureka-client</strong> and <strong class="source-inline">org.springframework.cloud:spring-cloud-starter-openfeign</strong> dependencies to the <span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break"> file:</span><pre class="source-code">
&lt;dependency&gt;
     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
     &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
     &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
&lt;/dependency&gt;</pre></li><li>In the <strong class="source-inline">AlbumsApplication.</strong> class, add the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">EnableDiscoveryClient</strong></span><span class="No-Break"> annotation:</span><pre class="source-code"><strong class="bold">@EnableDiscoveryClient</strong>
@EnableFeignClients
@SpringBootApplication
public class AlbumsApplication {</pre></li><li>In the <strong class="source-inline">resources</strong> folder, add<a id="_idIndexMarker397"/> an <strong class="source-inline">application.yml</strong> file with the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker398"/></span><span class="No-Break"> configuration:</span><pre class="source-code">spring:
  application:
    name: AlbumsServer
<strong class="bold">eureka:</strong>
<strong class="bold">  client:</strong>
<strong class="bold">    serviceUrl:</strong>
<strong class="bold">      defaultZone: http://localhost:8761/eureka/</strong></pre></li><li>Modify the <strong class="source-inline">FootballClient</strong> class, changing <strong class="source-inline">@FeignClient</strong> by setting just the target <span class="No-Break">application name:</span><pre class="source-code"><strong class="bold">@FeignClient("FootballServer")</strong>
public interface FootballClient {
     @RequestMapping(method = RequestMethod.GET, value = "/players")
     List&lt;Player&gt; getPlayers();
}</pre></li></ul><p class="list-inset">Note that we no longer<a id="_idIndexMarker399"/> use the remote RESTful API server<a id="_idIndexMarker400"/> address, just the <span class="No-Break">application name.</span></p></li>				<li>Now, you can run the <span class="No-Break"><strong class="source-inline">albums</strong></span><span class="No-Break"> application.</span></li>
				<li>Finally, you can test the entire deployment. For that, execute the following <span class="No-Break"><strong class="source-inline">curl</strong></span><span class="No-Break"> request:</span><pre class="source-code">
curl http://localhost:8080/albums/players</pre><p class="list-inset">The consumer application will discover which instances of the server application are available by asking Eureka Server, after which point it will call the server application and return <span class="No-Break">the result.</span></p></li>			</ol>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor161"/>How it works...</h2>
			<p>To set up the client connection to Eureka Server, it is necessary to add the <strong class="source-inline">org.springframework.cloud:spring-cloud-starter-openfeign</strong> and <strong class="source-inline">org.springframework.cloud:spring-cloud-starter-netflix-eureka-client</strong> dependencies and configure the connection to Eureka Server. The configuration on the client side consists of <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">eureka.client.serviceUrl.defaultZone</strong>: This is the address of Eureka Server. In our case, this <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">http://localhost:8761/eureka</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">spring.appication.name</strong>: This is the name that can be used to discover <span class="No-Break">the service.</span></li>
			</ul>
			<p>OpenFeign and Eureka clients use Eureka Server to discover instances of a service. Remember that in the <strong class="source-inline">@OpenFeignClient</strong> configuration, we used the server application name instead of a server address. The OpenFeign client connects to Eureka Server, requests the instances that have been registered for that service, and <span class="No-Break">returns one.</span></p>
			<p>For clients, this is more straightforward as knowing the address where the server instances will be hosted in advance <span class="No-Break">is unnecessary.</span></p>
			<p>The discovery mechanism is also very convenient for server applications as they don’t need to be hosted in a predefined server and port. You probably noticed that the RESTful API server was configured with <strong class="source-inline">server.port=0</strong>, which means it will start in a random port. The server address and port are stored when it’s registered in Eureka Server. When the consumer application asks for Eureka Server, it returns information about the registered instance – that is, the server address and port. This feature is helpful as we run our applications locally and we don’t need to care about which port we are running each instance on. In previous recipes, we started<a id="_idIndexMarker401"/> one application on port <strong class="source-inline">8080</strong> and another<a id="_idIndexMarker402"/> on <strong class="source-inline">8081</strong>. In the <em class="italic">Scaling out the RESTful API service</em> recipe, we will see that it is possible to have more than one instance of a <span class="No-Break">given service.</span></p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor162"/>There’s more...</h2>
			<p>A key feature of Eureka Server is detecting unhealthy or unresponsive application instances and removing them from the registry. This feature requires<a id="_idIndexMarker403"/> that registered services use <strong class="bold">Actuator</strong>. Spring Actuator provides production-ready features that help you monitor and manage your Spring applications. It’s particularly useful for microservices and other distributed systems, where operational visibility and management are critical. You can include the Actuator dependency in your projects by applying the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
&lt;dependency&gt;
     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
     &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>			<p>You can find more information<a id="_idIndexMarker404"/> about Actuator on the project <span class="No-Break">page: </span><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html"><span class="No-Break">https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor163"/>Scaling out the RESTful API</h1>
			<p>Scaling out is a technique<a id="_idIndexMarker405"/> that improves the availability and capacity of a system by adding multiple instances for a <span class="No-Break">given service.</span></p>
			<p>In modern application platforms, such as container orchestrators such as Kubernetes or cloud providers hosting platforms such as Azure App Services or AWS Elastic Beanstalk, the systems may scale out and scale in automatically. For instance, in Kubernetes, you can configure an autoscale rule that increases the number of instances of your service when the average CPU has been over 70% for the last 5 minutes. You can also configure it in another way – when the usage of your application is low, you can scale in your application. This means you can decrease the number of instances of <span class="No-Break">the application.</span></p>
			<p>Scaling out an application shouldn’t necessarily be automated; you can scale it manually, as we’ll do in <span class="No-Break">this recipe.</span></p>
			<p>Scaling out involves distributing incoming requests across multiple instances of a service. In this recipe, we will learn how to use Eureka Server capabilities to register and discover instances to distribute the requests across available <span class="No-Break">service instances.</span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor164"/>Getting ready</h2>
			<p>In this recipe, we will use the services we utilized in the <span class="No-Break">previous recipe:</span></p>
			<ul>
				<li><strong class="bold">Eureka Server</strong>: This service will act as a service registry and provide <span class="No-Break">service discovery</span></li>
				<li><strong class="bold">RESTful API</strong>: This will provide a service to be consumed by the <span class="No-Break">client application</span></li>
				<li><strong class="bold">Client application</strong>: This will consume the <span class="No-Break">RESTful API</span></li>
			</ul>
			<p>If you haven’t completed the previous recipe, you can find the completed exercise in this book’s GitHub repository <span class="No-Break">at </span><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</span><span class="No-Break">.</span></p>
			<p>You can find the code to start this recipe in the <span class="No-Break"><strong class="source-inline">chapter4/recipe4-3/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor165"/>How to do it...</h2>
			<p>We will modify the RESTful API <a id="_idIndexMarker406"/>so that it returns the service instance’s information. That way, we can validate that the requests are balanced among available instances. Then, we will execute more than one instance of the RESTful API. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>In the RESTful API project, modify the <strong class="source-inline">application.yml</strong> file in the <strong class="source-inline">resources</strong> folder by adding the following property at the beginning of <span class="No-Break">the file:</span><pre class="source-code">
  instance:
    instance-id: ${spring.application.name}:${random.int}</pre><p class="list-inset">The file should look <span class="No-Break">like this:</span></p><pre class="source-code"><strong class="bold">football:</strong>
  <strong class="bold">instanceId: ${random.uuid}</strong>
server:
  port: 0
spring:
  application:
    name: FootballServer
eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
  <strong class="bold">instance:</strong>
    <strong class="bold">instance-id: ${spring.application.name}:${random.int}</strong></pre></li>				<li>Create a new controller named <strong class="source-inline">ServiceInformationController</strong> and write the <span class="No-Break">following code:</span><pre class="source-code">
@RequestMapping("/serviceinfo")
@RestController
public class ServiceInformationController {
    <strong class="bold">@Value("${football.instanceId}")</strong>
<strong class="bold">    private String instanceId;</strong>
    @GetMapping
    public String getInstanceId() {
        return instanceId;
    }
}</pre></li>				<li>Execute three instances<a id="_idIndexMarker407"/> of the RESTful API. Instead of using <strong class="source-inline">mvnw spring-boot:run</strong>, we will build the JAR file and execute it using the Java runtime. To do this, follow <span class="No-Break">these steps:</span><ol><li class="upper-roman">In the root folder of the project, build the application using the <span class="No-Break">following command:</span></li></ol><pre class="source-code">
./mvnw package</pre><ol><li class="upper-roman" value="2">Then, open three Terminals and execute the following command in all <span class="No-Break">of them:</span></li></ol><pre class="source-code">java -jar ./target/football-0.0.1-SNAPSHOT.jar</pre><ol><li class="upper-roman" value="3">Open Eureka Server at <strong class="source-inline">localhost:8761</strong>. You’ll see three instances of the RESTful <span class="No-Break">API service:</span></li></ol></li>			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer065">
					<img alt="Figure 4.3: Eureka Server with three instances of FootballServer running" src="image/B21646_04_3.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3: Eureka Server with three instances of FootballServer running</p>
			<ol>
				<li value="4">In the client application<a id="_idIndexMarker408"/> project, make the <span class="No-Break">following changes:</span><ul><li>In the <strong class="source-inline">FootballClient</strong> class, add the <span class="No-Break">following method:</span><pre class="source-code">
@RequestMapping(method = RequestMethod.GET, value="/serviceinfo")
String getServiceInfo();</pre></li><li>In the <strong class="source-inline">AlbumsController</strong> controller, add the <span class="No-Break">following method:</span><pre class="source-code">@GetMapping("/serviceinfo")
public String getServiceInfo(){
    return footballClient.getServiceInfo();
}</pre></li></ul></li>				<li>Now, start the client<a id="_idIndexMarker409"/> application and test the application multiple times. You can do that by executing the following <strong class="source-inline">curl</strong> request <span class="No-Break">several times:</span><pre class="source-code">
curl http://localhost:8080/albums/serviceinfo</pre><p class="list-inset">You will see that the results change when you execute the previous command <span class="No-Break">multiple times:</span></p></li>			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer066">
					<img alt="Figure 4.4: Results of executing the RESTful API from the client application" src="image/B21646_04_4.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4: Results of executing the RESTful API from the client application</p>
			<p class="list-inset">The client application distributes requests across Eureka Server’s registered service instances, resulting in <span class="No-Break">different outcomes.</span></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor166"/>How it works...</h2>
			<p>When the Eureka client starts, it registers itself in Eureka Server. The registration details include the service name and network location. After the registration process, the client sends heartbeats to inform the server that it is still alive. In this exercise, we initiated three instances of the RESTful API server with the same service name; each of the instances had a separate <span class="No-Break">network location.</span></p>
			<p>The Feign client in the consumer application uses Eureka Server to discover the available instances of the RESTful API server application. In that way, it can balance the request across the <span class="No-Break">service instances.</span></p>
			<p>Just for demonstration purposes, we added a configuration setting, <strong class="source-inline">football.InstanceId</strong>, with a unique random value to distinguish the service instance. To retrieve that configuration, we used the <strong class="source-inline">@Value</strong> annotation. Spring Boot injected the value when the app<a id="_idTextAnchor167"/>lication<a id="_idIndexMarker410"/> <span class="No-Break">was started.</span></p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor168"/>Setting up Spring Cloud Gateway</h1>
			<p>When creating complex applications<a id="_idIndexMarker411"/> with different services, we don’t want to expose all those services to consumer applications so that we can avoid unnecessary complexity exposure. To address this scenario, we can use <strong class="bold">Spring Cloud Gateway</strong>. Spring Cloud Gateway can be deployed in such a way that it’s the only component that’s accessible to consumer applications, while the rest of the services will be accessed either internally or just from Spring Cloud Gateway. This is illustrated in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer067">
					<img alt="Figure 4.5: A typical Spring Cloud Gateway deployment" src="image/B21646_04_5.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5: A typical Spring Cloud Gateway deployment</p>
			<p class="callout-heading">A note on deployment</p>
			<p class="callout">Depending on the complexity and requirements of the solution, I recommend using additional networking<a id="_idIndexMarker412"/> protections, such as Layer 7 load balancers, <strong class="bold">web application firewalls</strong> (<strong class="bold">WAFs</strong>), or other protection mechanisms. For learning purposes, I will not describe them in this book and focus on Spring and Spring Cloud <span class="No-Break">mechanisms instead.</span></p>
			<p>In addition to the role of an API gateway offering a unique entry point for the application, Spring Cloud Gateway<a id="_idIndexMarker413"/> has <span class="No-Break">interesting benefits:</span></p>
			<ul>
				<li><strong class="bold">Load balancing</strong>: It can balance requests across the available <span class="No-Break">service instances.</span></li>
				<li><strong class="bold">Dynamic routing</strong>: Spring Cloud Gateway can be integrated with a service registry, such as Eureka Server, and dynamically <span class="No-Break">route requests.</span></li>
				<li><strong class="bold">Security</strong>: It can apply authentication and authorization using authentication providers, such as Spring Security and OAuth2, and propagate to downstream services. You can do this in a single place if you need to configure CORS for your <span class="No-Break">consumer application.</span></li>
				<li><strong class="bold">SSL termination</strong>: You can configure Spring Cloud Gateway to terminal SSL/TLS connections and pass unencrypted traffic to the services. With this feature, you can offload the SSL/TLS decryption from <span class="No-Break">the services.</span></li>
				<li><strong class="bold">Rate limiting</strong>: You can implement rate limiting to prevent your services from <span class="No-Break">being abused.</span></li>
				<li><strong class="bold">Request/response transformation</strong>: You can use Spring Cloud Gateway to transform requests and responses – for instance, by adding requests or response headers. You can also convert payload formats, such as XML, into JSON. These transformations can be applied at the gateway level; hence, it is not necessary to modify your <span class="No-Break">downstream services.</span></li>
				<li><strong class="bold">Circuit breaking</strong>: You can use Spring Cloud Gateway to implement circuit breakers to handle failures gracefully. For instance, you can prevent requests from being sent to an <span class="No-Break">unhealthy service.</span></li>
			</ul>
			<p>Some added benefits are <em class="italic">request filtering</em>, <em class="italic">global exception handling</em>, <em class="italic">logging and monitoring</em>, and <span class="No-Break"><em class="italic">path Rewriting</em></span><span class="No-Break">.</span></p>
			<p>I recommend visiting<a id="_idIndexMarker414"/> the project page at https://spring.io/projects/spring-cloud-gateway for <span class="No-Break">more details.</span></p>
			<p>In this recipe, we will deploy<a id="_idIndexMarker415"/> an instance of Spring Cloud Gateway and integrate it with Eureka Server, which we deployed in previous recipes, to route requests to <span class="No-Break">registered services.</span></p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor169"/>Getting ready</h2>
			<p>In this recipe, we will use the projects we implemented in <span class="No-Break">previous recipes:</span></p>
			<ul>
				<li><strong class="bold">Eureka Server</strong>: This service will act as a service registry and provide <span class="No-Break">service discovery.</span></li>
				<li><strong class="bold">RESTful API</strong>: This will provide a service to be consumed by the client application – that is, the <span class="No-Break"><strong class="source-inline">football</strong></span><span class="No-Break"> application.</span></li>
				<li><strong class="bold">Consumer API</strong>: This application will consume the RESTful API service. We will modify the application so that it provides an additional endpoint in this recipe. This is the <span class="No-Break"><strong class="source-inline">album</strong></span><span class="No-Break"> application.</span></li>
			</ul>
			<p>If you haven’t completed<a id="_idIndexMarker416"/> the previous recipe, you can find the completed exercise in this <a id="_idTextAnchor170"/>book’s GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook. The code to start this recipe can be found in the <span class="No-Break"><strong class="source-inline">chapter4/recipe4-4/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor171"/>How to do it...</h2>
			<p>Let’s deploy a Spring Cloud Gateway. We will configure Gateway so that it exposes some functionality of the <span class="No-Break">RESTful API:</span></p>
			<ol>
				<li>Open <a href="https://start.spring.io">https://start.spring.io</a> and use the same parameters that you did in the <em class="italic">Creating a RESTful API</em> recipe, except change the <span class="No-Break">following options:</span><ul><li>For <strong class="bold">Artifact</strong>, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">gateway</strong></span></li><li>For <strong class="bold">Dependencies</strong>, select <strong class="bold">Gateway</strong> and <strong class="bold">Eureka </strong><span class="No-Break"><strong class="bold">Discovery Client</strong></span></li></ul></li>
				<li>In the project you’ve downloaded, create a file in the <strong class="source-inline">resources</strong> folder named <strong class="source-inline">application.yml</strong> with the <span class="No-Break">following content:</span><pre class="source-code">
spring:
  application:
    name: GatewayServer
  cloud:
    gateway:
      routes:
        - id: players
          uri: lb://footballserver
          predicates:
            - Path=/api/players/**
          filters:
            - StripPrefix=1
eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/</pre></li>				<li>Now, you can run the gateway<a id="_idIndexMarker417"/> application. One important thing to note is that the other application should be running <span class="No-Break">as well.</span></li>
				<li>Test the gateway by executing the <span class="No-Break">following request:</span><pre class="source-code">
curl http://localhost:8080/api/players</pre><p class="list-inset">You should see the RESTful <span class="No-Break">API’s results.</span></p></li>				<li>Now, let’s add a new method in the other RESTful API applications in <strong class="source-inline">Albums</strong> and then add it as a new route in Spring Cloud Gateway. So, open the <strong class="source-inline">AlbumsController</strong> controller and add the <span class="No-Break">following method:</span><pre class="source-code">
@GetMapping
public List&lt;String&gt; getAlbums(){
     return List.of("Album 1", "Album 2", "Album 3");
}</pre></li>				<li>In the same project, open the <strong class="source-inline">application.yml</strong> file and add the <span class="No-Break">following property:</span><pre class="source-code">
server:
  port: 0</pre><p class="list-inset">Now, add a new route in the Spring Cloud Gateway<a id="_idIndexMarker418"/> configuration. For that, open the <strong class="source-inline">application.yml</strong> file of the Spring Cloud Gateway project and add the following highlighted text. I’ve added the entire configuration file <span class="No-Break">for clarity:</span></p><pre class="source-code">spring:
  application:
    name: GatewayServer
  cloud:
    gateway:
      routes:
        - id: players
          uri: lb://footballserver
          predicates:
            - Path=/api/players/**
          filters:
            - StripPrefix=1
<strong class="bold">        - id: albums</strong>
<strong class="bold">          uri: lb://albumsserver</strong>
<strong class="bold">          predicates:</strong>
<strong class="bold">            - Path=/api/albums/**</strong>
<strong class="bold">          filters:</strong>
<strong class="bold">            - StripPrefix=1</strong>
eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/</pre></li>				<li>Restart Spring Cloud Gateway <a id="_idIndexMarker419"/>and test the new route by executing the following <span class="No-Break"><strong class="source-inline">curl</strong></span><span class="No-Break"> request:</span><pre class="source-code">
curl <strong class="source-inline">http://localhost:8080/api/albums</strong></pre><p class="list-inset">Now, you should see the response of the second <span class="No-Break">RESTful API.</span></p></li>			</ol>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor172"/>How it works...</h2>
			<p>In this recipe, we connected Spring Cloud Gateway to Eureka Server. For that, we only needed to include the Eureka discovery client and its configuration – that is, <strong class="source-inline">eureka.client.serviceUrl.defaultZone property</strong> in the <span class="No-Break"><strong class="source-inline">application.yml</strong></span><span class="No-Break"> file.</span></p>
			<p>Once connected to Eureka Server, we configured a couple of routings. A routing definition specifies a combination of criteria and actions to be taken when a request matches <span class="No-Break">the criteria.</span></p>
			<p>We established the criteria for route definition by employing predicates. Specifically, we configured two routes: one using the <strong class="source-inline">/api/players/**</strong> path pattern and the other using <strong class="source-inline">/api/albums/**</strong>. This configuration dictates that the first route will match requests starting with <strong class="source-inline">/api/player</strong>, while the second route will match requests commencing with <strong class="source-inline">/api/albums</strong>. For example, a request such as <strong class="source-inline">http://localhost:8080/api/player</strong> would match the first route. Beyond the request path, you can utilize other request properties, such as headers, query parameters, or the <span class="No-Break">request host.</span></p>
			<p>Since the target services expect the requests as <strong class="source-inline">/players</strong> in one case and <strong class="source-inline">/albums</strong> in the other, without <strong class="source-inline">/api</strong> in both cases, removing this part of the path is necessary. We configured this using the <strong class="source-inline">StripPrefix=1</strong> filter, which removed the first part of <span class="No-Break">the path.</span></p>
			<p>Finally, those routes needed to hit a target service, so we configured this using the <strong class="source-inline">uri</strong> property. We could have used the DNS host and port, something like <strong class="source-inline">http://server:8081</strong>, but instead, we used <strong class="source-inline">lb://servicename</strong>. Using this approach, we configured Spring Cloud Gateway to discover the target service using Eureka and leverage client-side load balancing. We deployed all our services locally, and the only way to distinguish each instance is by dynamically assigning each service <span class="No-Break">a port.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">To assign a port dynamically, we set the <span class="No-Break"><strong class="source-inline">server.port=0</strong></span><span class="No-Break"> property.</span></p>
			<p>If the hosting environment provides an alternative balancing method, it is acceptable to use it. For instance, in a Kubernetes environment, you can create a deployment for your service with multiple running instances. By doing this, your service<a id="_idIndexMarker420"/> can be discovered through Kubernetes DNS, and the underlying infrastructure will <span class="No-Break">balance requests.</span></p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor173"/>See also</h2>
			<p>I recommend reading Spring Cloud Gateway<a id="_idIndexMarker421"/> documentation, which you can find here: <a href="https://spring.io/projects/spring-cloud-gateway">https://spring.io/projects/spring-cloud-gateway</a>. Familiarize yourself with routing capabilities and understand how to configure your routes using all the properties that are available in <span class="No-Break">the requests.</span></p>
			<p>Circuit Breaker is also an interesting design pattern that can be very useful for handling failures gracefully. If you are unfamiliar<a id="_idIndexMarker422"/> with this pattern, I recommend looking at this <em class="italic">Azure Cloud Design Patterns</em> article: <a href="https://learn.microsoft.com/azure/architecture/patterns/circuit-breaker">https://learn.microsoft.com/azure/architecture/patterns/circuit-breaker</a>. The good news is that this pattern<a id="_idIndexMarker423"/> is relatively easy to implement using Spring Cloud Gateway – see <a href="https://spring.io/guides/gs/gateway/">https://spring.io/guides/gs/gateway/</a> for <span class="No-Break">more details.</span></p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor174"/>Testing Spring Cloud Gateway</h1>
			<p>As the Spring Cloud Gateway<a id="_idIndexMarker424"/> rules are processed at runtime, they can sometimes be difficult to test. In addition to the rules themselves, the target applications must be up <span class="No-Break">and running.</span></p>
			<p>In this recipe, we’ll learn how to test Spring Cloud Gateway using the <em class="italic">Spring Cloud Contract Stub Runner</em> starter, which emulates the target services using the <span class="No-Break">Wiremock library.</span></p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor175"/>Getting ready</h2>
			<p>In this recipe, we’ll create tests for the Spring Cloud Gateway project we set up in the previous recipe. I’ve prepared a working version of Spring Cloud Gateway in case you haven’t set it up yet. You can find it in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>. The code to start this recipe can be found in the <strong class="source-inline">chapter4/recipe4-5/start</strong> folder. I’ve added all the projects that were used in the previous recipe – that is, the <strong class="source-inline">football</strong>, the <strong class="source-inline">albums</strong>, and the <strong class="source-inline">gateway</strong> projects – but we’ll only be using <span class="No-Break"><strong class="source-inline">gateway</strong></span><span class="No-Break"> here.</span></p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor176"/>How to do it...</h2>
			<p>In this recipe, we’ll adjust the gateway<a id="_idIndexMarker425"/> project to allow for test execution. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>First, we’ll add the <em class="italic">Spring Cloud Contract Stub Runner</em> starter. For that, add the following dependency in the <strong class="source-inline">gateway</strong> project’s <span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break"> file:</span><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-contract-stub-runner&lt;/artifactId&gt;
    <strong class="bold">&lt;scope&gt;test&lt;/scope&gt;</strong>
&lt;/dependency&gt;</pre><p class="list-inset">Note that this dependency is used for testing <span class="No-Break">purposes only.</span></p></li>				<li>Next, modify the <strong class="source-inline">application.yml</strong> configuration<a id="_idIndexMarker426"/> to parameterize the destination URIs. Replace the addresses in <strong class="source-inline">spring.cloud.gateway.routes.uri</strong> so that they use a <span class="No-Break">configuration parameter:</span><pre class="source-code">
spring:
  application:
    name: GatewayServer
  cloud:
    gateway:
      routes:
        - id: players
          <strong class="bold">uri: ${PLAYERS_URI:lb://footballserver}</strong>
          predicates:
            - Path=/api/players/**
          filters:
            - StripPrefix=1
        - id: albums
          <strong class="bold">uri: ${ALBUMS_URI:lb://albumsserver}</strong>
          predicates:
            - Path=/api/albums/**
          filters:
            - StripPrefix=1
eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/</pre></li>				<li>Before creating our first test, we need to set up the test class. Let’s create a new class named <strong class="source-inline">RoutesTests</strong> in the <strong class="source-inline">test</strong> folder. To set it up, you must do <span class="No-Break">the following:</span><ul><li>Annotate the class with <strong class="source-inline">@AutoConfigureWireMock(port = </strong><span class="No-Break"><strong class="source-inline">0)</strong></span></li><li>Annotate the class with <strong class="source-inline">@SpringBootTest</strong> using the <strong class="source-inline">properties</strong> field to pass the <span class="No-Break">destination URIs</span></li><li>Add the <strong class="source-inline">WebTestClient</strong> field that the Spring Boot tests<a id="_idIndexMarker427"/> context <span class="No-Break">will inject</span></li></ul><p class="list-inset">The skeleton of this class should look <span class="No-Break">like this:</span></p><pre class="source-code">
@AutoConfigureWireMock(port = 0)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, properties = {
        "<strong class="bold">PLAYERS_URI</strong>=http://localhost:${wiremock.server.port}",
        "<strong class="bold">ALBUMS_URI</strong>=http://localhost:${wiremock.server.port}",
})
public class RoutesTester {
    @Autowired
    private WebTestClient webClient;
}</pre></li>				<li>Now, we can create our first test. We’ll add a new method annotated with <strong class="source-inline">@Test</strong> to check the <span class="No-Break"><strong class="source-inline">players</strong></span><span class="No-Break"> route:</span><ol><li class="upper-roman">Name the <span class="No-Break">method </span><span class="No-Break"><strong class="source-inline">playersRouteTest</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code">
<strong class="bold">@Test</strong>
public void playersRouteTest() throws Exception</pre><ol><li class="upper-roman" value="2">First, arrange the response of the target server when calling the <strong class="source-inline">/players</strong> path. We’ll use<a id="_idIndexMarker428"/> the <span class="No-Break">Wiremock library:</span></li></ol><pre class="source-code">stubFor(get(urlEqualTo("/players"))
        .willReturn(aResponse()
                .withHeader("Content-Type", "application/json")
                .withBody("""
                        [
                            {
                                "id": "325636",
                                "jerseyNumber": 11,
                                "name": "Alexia PUTELLAS",
                                "position": "Midfielder",
                                "dateOfBirth": "1994-02-04"
                            },
                            {
                                 "id": "396930",
                                 "jerseyNumber": 2,
                                 "name": "Ona BATLLE",
                                 "position": "Defender",
                                 "dateOfBirth": "1999-06-10"
                             }
                          ]""")));</pre><ol><li class="upper-roman" value="3">Now, we can call Spring Cloud Gateway by using <strong class="source-inline">WebTestClient</strong> and assert that it’s working <span class="No-Break">as expected:</span></li></ol><pre class="source-code">webClient.get().uri("<strong class="bold">/api/players</strong>").exchange()
        .expectStatus().isOk()
        .expectBody()
        .jsonPath("$[0].name").isEqualTo("Alexia PUTELLAS")
        .jsonPath("$[1].name").isEqualTo("Ona BATLLE");</pre></li>				<li>Now, you can test the <strong class="source-inline">albums</strong> route using the same approach. This book’s GitHub repository contains more tests for Spring Cloud <span class="No-Break">Gateway: </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</span></a><span class="No-Break">.</span></li>
			</ol>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor177"/>How it works...</h2>
			<p>When configuring the Spring Cloud Gateway<a id="_idIndexMarker429"/> project, two dependencies need to be considered: Eureka Server and the target RESTful API. However, the main purpose is to verify the Gateway routes during testing. To achieve this, we removed the dependency on Eureka Server and allowed the target RESTful API URI to be configured. By using the <strong class="source-inline">${key:default}</strong> notation in <em class="italic">Step 2</em>, we created a fallback mechanism that uses the configured value for the load balancer address. If no value is provided, then it defaults to the original URI. This notation specifies that if the key is provided, then it uses that key; otherwise, it uses the default value specified after the <span class="No-Break">colon symbol.</span></p>
			<p>Using the configuration mechanism described previously and the Wiremock provided by the <em class="italic">Spring Cloud Contract Stub Runner</em> starter, we configured the address of the remote RESTful APIs, considering that the Wiremock server is running on localhost and the port is provided by the Wiremock server. In the <strong class="source-inline">@AutoConfigureWireMock</strong> annotation, we used port <strong class="source-inline">0</strong> to ensure the port is assigned randomly. Then, using <strong class="source-inline">${wiremock.server.port}</strong>, we retrieved the <span class="No-Break">assigned port.</span></p>
			<p>The rest of the test follows the same mocking mechanism that we explained in the <em class="italic">Mocking a RESTful API</em> recipe in <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>. Note that the mocked RESTful API responds to <strong class="source-inline">/players</strong>, while the test requests <strong class="source-inline">/api/players</strong>. In this test, we want to validate that the Spring Cloud Gateway configuration is correct, so when making a request to <strong class="source-inline">/api/players</strong>, it redirects the call to the target API on the <strong class="source-inline">/players</strong> path. So long as the test is implemented correctly and Spring Cloud Gateway is configured properly, <a id="_idTextAnchor178"/>the test<a id="_idIndexMarker430"/> should pass without <span class="No-Break">any issues.</span></p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor179"/>Setting up Spring Cloud Config</h1>
			<p>Spring Cloud Config enables centralized configuration<a id="_idIndexMarker431"/> management for applications, allowing you to store configuration properties in a central repository and distribute them to <span class="No-Break">connected services.</span></p>
			<p>It provides the following features, <span class="No-Break">among others:</span></p>
			<ul>
				<li>It allows version control configurations – for instance, using git as a backend to store the configuration. With this feature, you can track changes and audit configurations, and facilitate performing rollbacks to previous versions <span class="No-Break">when needed.</span></li>
				<li>It enables dynamic configuration updates with no need to <span class="No-Break">restart services.</span></li>
				<li>It externalizes the configuration; hence, it is possible to make configuration changes without modifying or redeploying <span class="No-Break">the services.</span></li>
			</ul>
			<p>In this recipe, we will deploy a configuration server and connect our existing<a id="_idTextAnchor180"/> RESTful APIs to the <span class="No-Break">configuration service.</span></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor181"/>Getting ready</h2>
			<p>For this recipe, you will need a Git repository. I recommend using GitHub as this recipe has been tested and validated with this service, but I don’t foresee any issue if you use another git provider. If you want to use GitHub and don’t have an account yet, visit <a href="https://github.com">https://github.com</a>. You will also need a <span class="No-Break">git client.</span></p>
			<p>I will reuse the RESTful APIs that we configured in the previous recipe. These are the services we <span class="No-Break">must configure:</span></p>
			<ul>
				<li><strong class="source-inline">football</strong> (<span class="No-Break">RESTful API)</span></li>
				<li><strong class="source-inline">albums</strong> (<span class="No-Break">RESTful API)</span></li>
				<li><span class="No-Break"><strong class="source-inline">gateway</strong></span></li>
			</ul>
			<p>If you haven’t completed the previous recipe yet, you can use the completed recipe in this book’s GitHub <span class="No-Break">repository: </span><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook.</span></p>
			<p>The code to start this recipe can be fou<a id="_idTextAnchor182"/>nd in the <span class="No-Break"><strong class="source-inline">chapter4/recipe4-6/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor183"/>How to do it...</h2>
			<p>In this recipe, we’ll create a new service<a id="_idIndexMarker432"/> using Spring Initializr to host Spring Cloud Config. Next, we’ll configure the service to use a GitHub repository as a backend. Finally, we’ll connect existing services to the Config server. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Open <a href="https://start.spring.io">https://start.spring.io</a> and use the same parameters that you did in the <em class="italic">Creating a RESTful API</em> recipe in <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, except changing the <span class="No-Break">following options:</span><ul><li>For <strong class="bold">Artifact</strong>, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">config</strong></span></li><li>For <strong class="bold">Dependencies</strong>, select <span class="No-Break"><strong class="bold">Config Server</strong></span></li></ul></li>
				<li>Create a GitHub repository in your GitHub account. Since we won’t be managing anything secretive, the repository can be public. Name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">spring3-recipes-config</strong></span><span class="No-Break">.</span></li>
				<li>Clone the repository on your computer. To do that, open a Terminal and execute the following command, replacing <strong class="source-inline">felipmiguel</strong> with your GitHub <span class="No-Break">account’s name:</span><pre class="source-code">
git clone https://github.com/felipmiguel/spring3-recipes-config</pre><p class="list-inset">This will create <strong class="source-inline">spring3-recipes-config</strong> as the root folder for <span class="No-Break">that repository.</span></p><p class="list-inset">In the following steps, we will create files in that folder that will later be pushed to GitHub’s <span class="No-Break">central repository.</span></p></li>				<li>In the root folder of the configuration<a id="_idIndexMarker433"/> repository, create the <span class="No-Break">following files:</span><ul><li><strong class="source-inline">application.yml</strong>, with the <span class="No-Break">following content:</span><pre class="source-code">
server:
    port: 0
eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
  instance:
    instance-id: ${spring.application.name}:${random.int}</pre></li><li><strong class="source-inline">gatewayserver.yml</strong>, with the <span class="No-Break">following content:</span><pre class="source-code">server:
  port: 8080
spring:
  cloud:
    gateway:
      routes:
        - id: players
          uri: ${PLAYERS_URI:lb://footballserver}
          predicates:
            - Path=/api/players/**
          filters:
            - StripPrefix=1
        - id: albums
          uri: ${ALBUMS_URI:lb://albumsserver}
          predicates:
            - Path=/api/albums/**
          filters:
            - StripPrefix=1</pre></li></ul></li>				<li>Next, push the files to <strong class="source-inline">github.com</strong>. To do this, execute<a id="_idIndexMarker434"/> the following commands in your Terminal in the repository <span class="No-Break">root folder:</span><pre class="source-code">
git commit -m "Initial configuration" .
git push</pre></li>				<li>Configure your repository as the backend of the Config service. For this, go to the Config Service project and add a file<a id="_idIndexMarker435"/> named <strong class="source-inline">application.yml</strong> in the <strong class="source-inline">resources</strong> folder with the following content (make sure you replace <strong class="source-inline">[your account]</strong> with your GitHub <span class="No-Break">account’s name):</span><pre class="source-code">
server.port: 8888
spring:
  cloud:
    config:
      server:
        git:
          <strong class="bold">uri: https://github.com/[your account]/spring3-recipes-config</strong></pre></li>				<li>Open the application’s <strong class="source-inline">ConfigApplication</strong> class and add the <strong class="source-inline">@EnableConfigServer</strong> annotation. It should look <span class="No-Break">like this:</span><pre class="source-code">
<strong class="bold">@EnableConfigServer</strong>
@SpringBootApplication
public class ConfigApplication</pre></li>				<li>Now, you can start the <span class="No-Break">Config server.</span></li>
				<li>Next, modify the projects so that you can connect to the Config server. To do so, follow <span class="No-Break">these steps:</span><ul><li>Add dependencies to the <strong class="source-inline">pom.xml</strong> file for all the applications we want to connect to the Config server. These applications are <strong class="source-inline">football</strong>, <strong class="source-inline">album</strong>, <strong class="source-inline">registry</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">gateway</strong></span><span class="No-Break">:</span><pre class="source-code">
&lt;dependency&gt;
     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
     &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
&lt;/dependency&gt;</pre></li><li>Configure the <strong class="source-inline">application.yml</strong> file for all the applications<a id="_idIndexMarker436"/> we want to connect to the Config server. All of them will contain the Config server configuration and the respective application’s name. For instance, the <strong class="source-inline">album</strong> service will look <span class="No-Break">like this:</span><pre class="source-code"><strong class="bold">spring:</strong>
<strong class="bold">  config:</strong>
<strong class="bold">    import: optional:configserver:http://localhost:8888</strong>
  application:
    name: AlbumsServer</pre></li><li>For the <strong class="source-inline">football</strong> service (the RESTful API service), set the <span class="No-Break">following content:</span><pre class="source-code">football:
  instanceId: ${random.uuid}
<strong class="bold">spring:</strong>
<strong class="bold">  config:</strong>
<strong class="bold">    import: optional:configserver:http://localhost:8888</strong>
  application:
    name: FootballServer</pre></li><li>For the <strong class="source-inline">gateway</strong> service, set the <span class="No-Break">following content:</span><pre class="source-code"><strong class="bold">spring:</strong>
<strong class="bold">  config:</strong>
<strong class="bold">    import: optional:configserver:http://localhost:8888</strong>
  application:
    name: gatewayserver</pre></li></ul></li>				<li>Now, it’s time to verify that everything is working. Let’s start <span class="No-Break">all services.</span></li>
				<li>Test the services by executing a request to Spring <span class="No-Break">Cloud Gateway:</span><pre class="source-code">
curl http://localhost:8080/api/players</pre></li>				<li>Validate that it re<a id="_idTextAnchor184"/>turns a JSON file<a id="_idIndexMarker437"/> containing a list <span class="No-Break">of players.</span></li>
			</ol>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor185"/>How it works...</h2>
			<p>Spring Boot provides an extensible mechanism to load the configuration from external sources using the <strong class="source-inline">spring.config.import</strong> setting. Adding the <strong class="source-inline">org.springframework.cloud:spring-cloud-starter-config</strong> dependency registers an extension that can retrieve the configuration from a <span class="No-Break">config server.</span></p>
			<p>To set up the configuration server, the only requirement is adding the <strong class="source-inline">org.springframework.cloud:spring-cloud-config-server</strong> dependency and enabling the configuration server using the <strong class="source-inline">@EnableConfigServer</strong> annotation. Enabling the configuration server exposes an endpoint that allows consumer applications to query for their configuration. The configuration endpoint exposes the <span class="No-Break">following paths:</span></p>
			<pre class="source-code">
/{application}/{profile}[/{label}]
/{application}-{profile}.yml
/{label}/{application}-{profile}.yml
/{application}-{profile}.properties
/{label}/{application}-{profile}.properties</pre>			<p>Let’s take a look at each <span class="No-Break">path fragment:</span></p>
			<ul>
				<li><strong class="source-inline">application</strong> is the application name that’s configured by the <span class="No-Break"><strong class="source-inline">spring.application.name</strong></span><span class="No-Break"> property.</span></li>
				<li><strong class="source-inline">profile</strong> is the currently active profile. By default, the profile’s name <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">default</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">label</strong> refers to a git branch; if not specified, it applies to the <span class="No-Break">default branch.</span></li>
			</ul>
			<p>Our applications provide the following queries for the <span class="No-Break">Config server:</span></p>
			<ul>
				<li><strong class="source-inline">football</strong>: As it contains the <strong class="source-inline">spring.application.name=FootballServer</strong> property, it <span class="No-Break">requests </span><span class="No-Break"><strong class="source-inline">http://localhost:8888/FootballServer-default.yml</strong></span></li>
				<li><strong class="source-inline">albums</strong>: Its application name is <strong class="source-inline">AlbumsServer</strong>, so it <span class="No-Break">requests </span><span class="No-Break"><strong class="source-inline">http://localhost:8888/AlbumsServer-default.yml</strong></span></li>
				<li><strong class="source-inline">gateway</strong>: Its application name is <strong class="source-inline">GatewayServer</strong>, so it <span class="No-Break">requests </span><span class="No-Break"><strong class="source-inline">http://localhost:8888/GatewayServer-default.yml</strong></span></li>
			</ul>
			<p>You can see the results by executing<a id="_idIndexMarker438"/> a request. For instance, for <strong class="source-inline">GatewayServer</strong>, you can run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
curl http://localhost:8888/GatewayServer-default.yml</pre>			<p>The result should look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
server:
  port: 8080
eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
spring:
  cloud:
    gateway:
      routes:
      - id: players
        uri: ${PLAYERS_URI:lb://footballserver}
        predicates:
        - Path=/api/players/**
        filters:
        - StripPrefix=1
      - id: albums
        uri: ${ALBUMS_URI:lb://albumsserver}
        predicates:
        - Path=/api/albums/**
        filters:
        - StripPrefix=1</pre>			<p>Let’s analyze what the Config server <a id="_idIndexMarker439"/>did. The Config server resolves the configuration by merging the configurations it found in the <span class="No-Break">git repository:</span></p>
			<ul>
				<li>The base configuration starts with the <span class="No-Break"><strong class="source-inline">application.yml</strong></span><span class="No-Break"> file.</span></li>
				<li>It merges the base configuration with a more specific configuration for the requested application. The more specific configuration is defined using a <strong class="source-inline">[application name].yml</strong> file, where <strong class="source-inline">[application name]</strong> is defined in the <strong class="source-inline">spring.application.name</strong> property. In our scenario, we haven’t defined specific configuration files for the <strong class="source-inline">football</strong> and <strong class="source-inline">albums</strong> applications, but we did define the <strong class="source-inline">gatewayserver.yml</strong> file for the <strong class="source-inline">gateway</strong> service. By doing this, <strong class="source-inline">gateway</strong> will merge the content of <strong class="source-inline">application.yml</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">gatewayserver.yml</strong></span><span class="No-Break">.</span></li>
				<li>If settings are defined in multiple files, the most specific one is used. In this case, the settings defined by <strong class="source-inline">gatewayserver.yml</strong> will take precedence over the settings defined in <strong class="source-inline">application.yml</strong>. You can see this behavior for the <strong class="source-inline">server.port</strong> setting, which is specif<a id="_idTextAnchor186"/>ied in both files<a id="_idIndexMarker440"/> and takes the most <span class="No-Break">specific one.</span></li>
			</ul>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor187"/>There’s more...</h2>
			<p>In production environments, you probably want to protect your applications’ configurations. For that reason, you must use a private git repository, your configuration service will require authentication, and your secrets, such as connection strings, will be encrypted. You can do all that using Spring Cloud Config. I recommend<a id="_idIndexMarker441"/> visiting the project page at <a href="https://spring.io/projects/spring-cloud-gateway">https://spring.io/projects/spring-cloud-gateway</a> for details on <span class="No-Break">the configuration.</span></p>
			<p>Another exciting feature related to configuration is the possibility to dynamically refresh the configuration without restarting the application. You can achieve this by using Spring Actuator. We will revisit this topic in <span class="No-Break">later chapters.</span></p>
			<p>We just used non-sensitive information in this recipe, but applications usually manage configurations we don’t want to disclose, such as database connection strings or credentials to access <span class="No-Break">other systems.</span></p>
			<p>The first measure we should apply is removing public access to the configuration repository. We can use private repositories and configure the git credentials in the Config server <span class="No-Break">like so:</span></p>
			<pre class="source-code">
spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/PacktPublishing/Spring-Boot-3.0- Cookbook-Config
          <strong class="bold">username: theuser</strong>
          <strong class="bold">password: strongpassword</strong></pre>			<p>To avoid storing sensitive information in a git repository, Spring Cloud Config has an extension to integrate with Vault services, such as Hashicorp Vault and Azure Key Vault. The configuration file that’s stored in the git repository contains references to secrets stored in the Vault service. The applications resolve the configuration, retri<a id="_idTextAnchor188"/>eving the referenced secrets from the <span class="No-Break">Vault service.</span></p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor189"/>See also</h2>
			<p>See the Spring Cloud Config<a id="_idIndexMarker442"/> quickstart guide at <a href="https://docs.spring.io/spring-cloud-config/docs/current/reference/html/">https://docs.spring.io/spring-cloud-config/docs/current/reference/html/</a> for more <span class="No-Break">advanced scenarios.</span></p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor190"/>Integrating distributed tracing with Spring Cloud</h1>
			<p>As the number of services<a id="_idIndexMarker443"/> composing the <strong class="source-inline">football</strong> application suite<a id="_idIndexMarker444"/> grew, you deployed the following Spring Cloud components: Spring Cloud Gateway, Eureka Server (a registry and discovery service), and Spring Cloud Configuration. You want to configure distributed tracing to monitor the transactions <span class="No-Break">across microservices.</span></p>
			<p>In this recipe, you will integrate distributed tracing with Actuator and OpenZipkin into a system composed of different application microservices and Spring <span class="No-Break">Cloud components.</span></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor191"/>Getting ready</h2>
			<p>You will monitor distributed transactions using OpenZipkin. As explained in the <em class="italic">Implementing distributed tracing</em> recipe in <a href="B21646_03.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, you can deploy an OpenZipkin server on your computer using Docker. For that, you can run the following command in <span class="No-Break">your Terminal:</span></p>
			<pre class="console">
docker run -d -p 9411:9411 openzipkin/zipkin</pre>			<p>You will reuse the outcome of the <em class="italic">Setting up Spring Cloud Config</em> recipe. I’ve prepared a working version in case you haven’t completed that recipe yet. You can find it in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>, in the <strong class="source-inline">chapter4/recipe4-7/start</strong> folder. It includes the <span class="No-Break">following projects:</span></p>
			<ul>
				<li><strong class="source-inline">config</strong>: The Spring Cloud <span class="No-Break">Config service.</span></li>
				<li><strong class="source-inline">registry</strong>: The Spring Cloud registry and <span class="No-Break">discovery service.</span></li>
				<li><strong class="source-inline">gateway</strong>: Spring Cloud Gateway. It exposes the <strong class="source-inline">football</strong> and <span class="No-Break"><strong class="source-inline">albums</strong></span><span class="No-Break"> services.</span></li>
				<li><strong class="source-inline">football</strong>: The <strong class="source-inline">football</strong> service, which provides information about teams <span class="No-Break">and players.</span></li>
				<li><strong class="source-inline">albums</strong>: The <strong class="source-inline">albums</strong> service, which manages sticker albums. It uses the <span class="No-Break"><strong class="source-inline">football</strong></span><span class="No-Break"> service.</span></li>
			</ul>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor192"/>How to do it...</h2>
			<p>Let’s configure our Spring Cloud<a id="_idIndexMarker445"/> solution so that we can integrate<a id="_idIndexMarker446"/> distributed tracing <span class="No-Break">with OpenZipkin.</span></p>
			<ol>
				<li>You must add a dependency to Actuator, the Micrometer bridge to OpenTelemetry, and the exporter from OpenTelemetry to OpenZipkin to all projects. For that, add the following dependencies to all <strong class="source-inline">pom.xml</strong> project files, - that is, the <strong class="source-inline">config</strong>, <strong class="source-inline">registry</strong>, <strong class="source-inline">gateway</strong>, <strong class="source-inline">football</strong>, and <span class="No-Break"><strong class="source-inline">albums</strong></span><span class="No-Break"> projects:</span><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;
    &lt;artifactId&gt;micrometer-tracing-bridge-otel&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.opentelemetry&lt;/groupId&gt;
    &lt;artifactId&gt;opentelemetry-exporter-zipkin&lt;/artifactId&gt;
&lt;/dependency&gt;</pre></li>				<li>The <strong class="source-inline">albums</strong> project also makes<a id="_idIndexMarker447"/> some calls to the <strong class="source-inline">football</strong> project<a id="_idIndexMarker448"/> using the <strong class="source-inline">OpenFeign</strong> client. For that reason, you should also add the following dependencies to <span class="No-Break">that project:</span><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;
    &lt;artifactId&gt;micrometer-tracing&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;
    &lt;artifactId&gt;feign-micrometer&lt;/artifactId&gt;
&lt;/dependency&gt;</pre></li>				<li>Now, let’s change the configuration to enable 100% sampling. Since we’re using a central config server, we can change the configuration in the repository that contains the configuration for all applications. In my case, that repository is hosted at <a href="https://github.com/felipmiguel/spring3-recipes-config">https://github.com/felipmiguel/spring3-recipes-config</a>. As the <em class="italic">Setting up Spring Cloud Config</em> recipe explains, you should replace <strong class="source-inline">felipmiguel</strong> with your GitHub account. In my repository, I added the following configuration to the <span class="No-Break"><strong class="source-inline">application.yml</strong></span><span class="No-Break"> file:</span><pre class="source-code">
management:
    tracing:
        sampling:
            probability: 1.0</pre><p class="list-inset">You can create a branch for this feature in the configuration repository. Once you’ve done this, you will need to modify the configuration in the client applications by adding the following setting in the client <span class="No-Break"><strong class="source-inline">application.yml</strong></span><span class="No-Break"> file:</span></p><pre class="source-code">spring
  cloud:
    config:
      label: &lt;your branch name&gt;</pre><p class="list-inset">Then, you should replace <strong class="source-inline">&lt;your branch name&gt;</strong> with the branch name you created <span class="No-Break">in GitHub.</span></p></li>				<li>You can now run<a id="_idIndexMarker449"/> the applications. You should<a id="_idIndexMarker450"/> start the <strong class="source-inline">config</strong> service first, then <strong class="source-inline">registry</strong>, at which point you can start all the rest in no <span class="No-Break">specific order.</span></li>
				<li>Let’s test the solution. You can run the following requests <span class="No-Break">for testing:</span><pre class="source-code">
curl http://localhost:8080/api/players</pre><p class="list-inset">This request, which is initially handled by the gateway, will be served by the <span class="No-Break"><strong class="source-inline">football</strong></span><span class="No-Break"> service:</span></p><pre class="source-code">curl http://localhost:8080/api/albums</pre><p class="list-inset">Again, this request is initially handled by <strong class="source-inline">gateway</strong> but is served by the <span class="No-Break"><strong class="source-inline">albums</strong></span><span class="No-Break"> service:</span></p><pre class="source-code">curl http://localhost:8080/api/albums/players</pre><p class="list-inset">In this case, the request is initially handled by <strong class="source-inline">gateway</strong> and served by the <strong class="source-inline">albums</strong> service, which simultaneously calls the <span class="No-Break"><strong class="source-inline">football</strong></span><span class="No-Break"> service.</span></p></li>				<li>Finally, you can see the traces in OpenZipkin. For that, open <strong class="source-inline">http://localhost:9411</strong> in your browser. Go to <strong class="bold">Find a trace</strong> to view the traces. You will see some traces that were initiated in the gateway. These are the ones you executed in <span class="No-Break"><em class="italic">Step 5</em></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer068">
					<img alt="Figure 4.6: Distributed traces for Spring Cloud" src="image/B21646_04_6.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6: Distributed traces for Spring Cloud</p>
			<p class="list-inset">The other traces<a id="_idIndexMarker451"/> are from the applications<a id="_idIndexMarker452"/> synchronizing with <span class="No-Break">Eureka Server.</span></p>
			<p class="list-inset">If you open the traces for <strong class="source-inline">gatewayserver</strong> with five spans – that is, the one corresponding to <strong class="source-inline">/api/albums/players</strong> – you will see that the <strong class="source-inline">gateway</strong> server called the <strong class="source-inline">albums</strong> server, which called the <span class="No-Break"><strong class="source-inline">football</strong></span><span class="No-Break"> server:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer069">
					<img alt="Figure 4.7: Distributed tracing starting in the gateway server, which calls the albums service, which, in turn, calls the football service" src="image/B21646_04_7.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7: Distributed tracing starting in the gateway server, which calls the albums service, which, in turn, calls the football service</p>
			<p class="list-inset">If you open<a id="_idIndexMarker453"/> the <strong class="bold">Dependencies</strong> section, you will see the dependencies<a id="_idIndexMarker454"/> between <span class="No-Break">the microservices:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer070">
					<img alt="Figure 4.8: The dependencies between Spring Cloud microservices" src="image/B21646_04_8.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8: The dependencies between Spring Cloud microservices</p>
			<p class="list-inset">This view is interesting<a id="_idIndexMarker455"/> in complex scenarios with different microservices<a id="_idIndexMarker456"/> calling each other when you need to understand the relationship <span class="No-Break">between them.</span></p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor193"/>How it works...</h2>
			<p>As explained in the <em class="italic">Implementing distributed tracing</em> recipe in <a href="B21646_03.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, just by adding Actuator and Micrometer dependencies, the applications send traces to the OpenZipkin server using the default configuration. The default configuration is <strong class="source-inline">http://localhost:9411</strong> for the OpenZipkin server and 10% of sampling. Sampling means that only a percentage of the traces is processed, so only 10% is processed by default. For demonstration purposes, we wanted to send 100% of the traces; for that reason, we took advantage of having a centralized configuration and only changed the <strong class="source-inline">application.yml</strong> file in the <span class="No-Break">configuration repository.</span></p>
			<p>The <strong class="source-inline">albums</strong> application uses an <strong class="source-inline">OpenFeign</strong> client, which, by default, does not propagate the distributed traces as <strong class="source-inline">WebClient.Builder</strong> and <strong class="source-inline">RestTemplateBuilder</strong> do. Therefore, we needed to add two additional dependencies to <strong class="source-inline">io.micrometer:micrometer-tracing</strong> and <strong class="source-inline">io.github.openfeign:feign-micrometer</strong>. On the other hand, Spring Cloud Gateway uses <strong class="source-inline">WebClient.Builder</strong> to make requests to the downstream services. For that reason, the traces are created and propagated <a id="_idIndexMarker457"/>correctly from Spring Cloud Gateway with no additional<a id="_idIndexMarker458"/> <span class="No-Break">configurations required.</span></p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor194"/>Deploying Spring Boot Admin</h1>
			<p>After deploying several<a id="_idIndexMarker459"/> microservices, you will appreciate having a single dashboard to monitor and manage all of them in one place. Spring Boot Admin is an open source community project that provides a web interface where you can manage and monitor Spring <span class="No-Break">Boot applications.</span></p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor195"/>Getting ready</h2>
			<p>You will reuse the applications from the <em class="italic">Integrating distributed tracing with Spring Cloud</em> recipe. I’ve prepared a working version in case you haven’t completed that recipe yet. You can find it in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>, in the <span class="No-Break"><strong class="source-inline">chapter4/recipe4-8/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor196"/>How to do it...</h2>
			<p>We need to deploy a Spring Boot Admin server and ensure it connects to the discovery service to monitor and manage all applications. Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>First, create a new application for Spring Boot Admin using the <em class="italic">Spring Initializr</em> tool. Open <a href="https://start.spring.io">https://start.spring.io</a> and use the same parameters that you did in the <em class="italic">Creating a RESTful API</em> recipe of <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, except change the <span class="No-Break">following options:</span><ul><li>For <strong class="bold">Artifact</strong>, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">fooballadmin</strong></span></li><li>For <strong class="bold">Dependencies</strong>, select <strong class="bold">Spring Web</strong>, <strong class="bold">Codecentric’s Spring Boot Admin (Server)</strong>, <strong class="bold">Config Client</strong>, and <strong class="bold">Eureka </strong><span class="No-Break"><strong class="bold">Discovery Client</strong></span></li></ul></li>
				<li>Next, you must configure<a id="_idIndexMarker460"/> Spring Boot Admin. For that, add an <strong class="source-inline">application.yml</strong> file to the <strong class="source-inline">resources</strong> folder with the <span class="No-Break">following content:</span><pre class="source-code">
spring:
  application:
    name: admin-server
  config:
    import: optional:configserver:http://localhost:8888
  cloud:
    config:
      label: distributed-tracing</pre><p class="list-inset">I’m using <strong class="source-inline">spring.cloud.config.label</strong> in this configuration. As I don’t want to mix the configuration from different recipes, I’ve created a new branch for the recipes in this chapter, the name of which is <strong class="source-inline">distributed-tracing</strong>. However, if you made all configurations in the same GitHub repository and the same branch, this setting is <span class="No-Break">not necessary.</span></p></li>				<li>There is a required additional configuration, but it should be done in the central repository this time since we are using the Spring Cloud Config service. In my case, the configuration is saved at <a href="https://github.com/felipmiguel/spring3-recipes-config">https://github.com/felipmiguel/spring3-recipes-config</a>; you should replace <strong class="source-inline">felipmiguel</strong> with your GitHub account, as explained in the <em class="italic">Setting up Spring Cloud Config</em> recipe. As mentioned in the previous step, I prepared the changes in the <span class="No-Break"><strong class="source-inline">distributed-tracing</strong></span><span class="No-Break"> branch:</span><ol><li class="upper-roman">First, expose Spring Boot Admin through Spring Cloud Gateway. To do so, create a new route in the <strong class="source-inline">gatewayserver.yml</strong> file, <span class="No-Break">as follows:</span></li></ol><pre class="source-code">
spring:
  cloud:
    gateway:
      routes:
        - id: players
          uri: lb://footballserver
          predicates:
            - Path=/api/players/**
          filters:
            - StripPrefix=1
        - id: albums
          uri: lb://albumsserver
          predicates:
            - Path=/api/albums/**
          filters:
            - StripPrefix=1
        <strong class="bold">- id: admin</strong>
<strong class="bold">          uri: lb://admin-server</strong>
<strong class="bold">          predicates:</strong>
<strong class="bold">            - Path=/admin/**</strong>
<strong class="bold">          filters:</strong>
<strong class="bold">            - StripPrefix=1</strong></pre><p class="list-inset">Note that the rest<a id="_idIndexMarker461"/> of the routes were already in <span class="No-Break">the configuration.</span></p><ol><li class="upper-roman" value="2">Next, configure Spring Boot Admin behind Spring Cloud Gateway. To do so, create a file named <strong class="source-inline">admin-server.yml</strong> in your GitHub repository with the <span class="No-Break">following content:</span></li></ol><pre class="source-code">spring:
  boot:
    admin:
      ui:
        <strong class="bold">public-url: </strong>http://localhost:8080/admin</pre><ol><li class="upper-roman" value="3">Finally, enable some actuator<a id="_idIndexMarker462"/> endpoints for all microservices. Since you are using a centralized configuration, you only need to add the following to the <strong class="source-inline">application.yml</strong> file in your <span class="No-Break">GitHub repository:</span></li></ol><pre class="source-code">management:
    endpoints:
        web:
            exposure:
                include: health,env,metrics,beans,loggers,prometheus
    tracing:
        sampling:
            probability: 1.0</pre></li>				<li>The last step before we run the application is configuring the Spring Boot Admin application to enable Admin Server and the Spring Cloud Discovery client. For that, open the <strong class="source-inline">FootballAdminApplication</strong> class and add the <span class="No-Break">following annotations:</span><pre class="source-code">
@SpringBootApplication
<strong class="bold">@EnableAdminServer</strong>
<strong class="bold">@EnableDiscoveryClient</strong>
public class FootballadminApplication</pre></li>				<li>Now, you can run the Spring Boot Admin<a id="_idIndexMarker463"/> application. Remember that you will need to run the rest of the applications that were reused from the <em class="italic">Integrating distributed tracing with Spring Cloud</em> recipe and that the <strong class="source-inline">config</strong> and <strong class="source-inline">registry</strong> services should start before the other services. As the Spring Boot Admin service is exposed through Spring Cloud Gateway, you can open <strong class="source-inline">http://locahost:8080/admin</strong> to access Spring <span class="No-Break">Boot Admin:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer071">
					<img alt="Figure 4.9: The initial Spring Boot Admin page. It defaults to the Applications view" src="image/B21646_04_9.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9: The initial Spring Boot Admin page. It defaults to the Applications view</p>
			<p class="list-inset">When you access Spring Boot Admin, it redirects you to the <strong class="bold">Applications</strong> view. It retrieves the list from Eureka Server. On the application, if you click on the green check on the left-hand side, you will be redirected to the application <span class="No-Break">details page:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer072">
					<img alt="Figure 4.10: Application details in Spring Boot Admin" src="image/B21646_04_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10: Application details in Spring Boot Admin</p>
			<p class="list-inset">Depending on how many Actuator <a id="_idIndexMarker464"/>endpoints are enabled in that application, you will see either more or fewer options in the left pane. As you activate the <strong class="source-inline">health</strong>, <strong class="source-inline">env</strong>, <strong class="source-inline">metrics</strong>, <strong class="source-inline">beans</strong>, and <strong class="source-inline">loggers</strong> endpoints, you will see <strong class="bold">Details</strong>, <strong class="bold">Metrics</strong>, <strong class="bold">Environment</strong>, <strong class="bold">Beans</strong>, and <strong class="bold">Loggers</strong>. If you open <strong class="bold">Loggers</strong>, you will see all loggers defined by the application. As you did in the <em class="italic">Changing settings in a running application</em> recipe in <a href="B21646_03.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, you can change the log level, but this time from a <span class="No-Break">nice UI:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer073">
					<img alt="Figure 4.11: Loggers in Spring Boot Admin" src="image/B21646_04_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11: Loggers in Spring Boot Admin</p>
			<p class="list-inset">There are two more views on the <span class="No-Break">top bar:</span></p>
			<ul>
				<li><strong class="bold">Wallboard</strong>: This shows the applications running in the <span class="No-Break">wallboard view</span></li>
				<li><strong class="bold">Journal</strong>: This shows the events that are happening in the <span class="No-Break">Discovery service</span></li>
			</ul>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor197"/>How it works...</h2>
			<p>Spring Boot Admin may work<a id="_idIndexMarker465"/> without Eureka Server, but you would need to configure each application as a client of Spring Boot Admin. Instead, we configured Spring Boot Admin to discover the applications using Eureka Server. Connecting to Eureka Server requires Eureka Client. The Config service centralizes the configuration, which is why we used the <span class="No-Break">Config Client.</span></p>
			<p>Spring Boot Admin gets the list of applications and their instances from Eureka Server. Then, using the Actuator endpoint of each instance, it can get all the details of the application. The more Actuator endpoints are enabled, the more details can be shown. We used the central configuration to allow the desired endpoints in one <span class="No-Break">single place.</span></p>
			<p>Spring Boot Admin<a id="_idIndexMarker466"/> can run out of Spring Cloud Gateway; however, it makes sense to centralize the access through Spring Cloud Gateway in this example. Keep in mind that some Actuator endpoints may expose sensitive information. With this design, you only need to expose Spring Cloud Gateway while you keep the rest of the services with no public exposure. Then, you can set up OAuth2, as explained in the <em class="italic">Protecting Spring Cloud Gateway</em> recipe. When configuring Spring Boot Admin behind a reverse proxy, setting the <strong class="source-inline">spring.boot.admin.ui.public-url</strong> property <span class="No-Break">is necessary.</span></p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor198"/>Protecting Spring Cloud Gateway</h1>
			<p>When implementing Spring Cloud Gateway, it can serve<a id="_idIndexMarker467"/> as a system’s single entry point. For this reason, protecting Spring Cloud Gateway with OAuth2 is a good idea. This allows for centralizing authentication and authorization in Spring Cloud Gateway, eliminating the need for your client to reauthenticate with each service <span class="No-Break">behind it.</span></p>
			<p>You want to place your <strong class="source-inline">football</strong> RESTful API, which is protected with OAuth2, behind Spring Cloud Gateway. So, you’ll also need to protect Spring Cloud Gateway <span class="No-Break">with OAuth2.</span></p>
			<p>In this recipe, you’ll learn how to configure Spring Cloud Gateway as a resource server and pass the token that you receive to the <span class="No-Break">downstream service.</span></p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor199"/>Getting ready</h2>
			<p>In this exercise, you will need <span class="No-Break">the following:</span></p>
			<ul>
				<li>An authorization server. You can reuse Spring Authorization Server, which you created in the <em class="italic">Setting up Spring Authorization Server</em> recipe in <a href="B21646_02.xhtml#_idTextAnchor066"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, for <span class="No-Break">this purpose.</span></li>
				<li>A resource server. The RESTful API you created in the <em class="italic">Protecting a RESTful API using OAuth2</em> recipe in <a href="B21646_02.xhtml#_idTextAnchor066"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, can be <span class="No-Break">reused here.</span></li>
				<li>A Spring Cloud Gateway server. You can reuse the Spring Cloud Gateway server you created in the <em class="italic">Setting up Spring Cloud Gateway</em> recipe. You can always reuse the latest version of the Spring Cloud Gateway server in later recipes. I’m using the initial setup <span class="No-Break">for simplicity.</span></li>
				<li>Eureka Server. You can reuse the Eureka Server application you created in the <em class="italic">Setting up Eureka </em><span class="No-Break"><em class="italic">Server</em></span><span class="No-Break"> recipe.</span></li>
			</ul>
			<p>If you haven’t completed<a id="_idIndexMarker468"/> the previous recipes yet, I’ve prepared a working version for all of them in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>, in the <span class="No-Break"><strong class="source-inline">chapter4/recipe4-9/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor200"/>How to do it...</h2>
			<p>In this recipe, we’ll set our RESTful API behind Spring Cloud Gateway and then protect Spring Cloud Gateway with OAuth2. <span class="No-Break">Let’s begin:</span></p>
			<ol>
				<li>First, configure the RESTful API so that it’s registered in Eureka Server. For that, add the Eureka Client dependency to the RESTful API’s <span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break"> file:</span><pre class="source-code">
&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
   &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;</pre><p class="list-inset">As it is part of Spring Cloud, you should also include the corresponding dependency management in the <strong class="source-inline">pom.xml</strong> file, <span class="No-Break">as follows:</span></p><pre class="source-code">&lt;dependencyManagement&gt;
   &lt;dependencies&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
          &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
          &lt;version&gt;<strong class="bold">${spring-cloud.version}&lt;/</strong>version&gt;
          &lt;type&gt;pom&lt;/type&gt;
          &lt;scope&gt;import&lt;/scope&gt;
       &lt;/dependency&gt;
   &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</pre><p class="list-inset">Add a project-level property<a id="_idIndexMarker469"/> to configure the Spring <span class="No-Break">Cloud version:</span></p><pre class="source-code">&lt;properties&gt;
   &lt;spring-cloud.version&gt;2022.0.4&lt;/spring-cloud.version&gt;
&lt;/properties&gt;</pre><p class="list-inset">Now, you can add the Eureka Server configuration to the <span class="No-Break"><strong class="source-inline">application.yml</strong></span><span class="No-Break"> file:</span></p><pre class="source-code">eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/</pre><p class="list-inset">Though not required, I recommend configuring the application port randomly and assigning a name to the Spring Boot application. With this configuration, you won’t need to care about port conflicts, and you’ll make the application discoverable by name. For that, in the <strong class="source-inline">application.yml</strong> file, add the <span class="No-Break">following lines:</span></p><pre class="source-code">spring:
  application:
    name: football-api
server:
  port: 0</pre><p class="list-inset">I’ve added the <strong class="source-inline">spring</strong> label for clarity, but the <strong class="source-inline">application.yml</strong> file should have <span class="No-Break">it defined.</span></p></li>				<li>Next, configure Spring Cloud Gateway<a id="_idIndexMarker470"/> as a resource server. For that, you will need to add the Spring OAuth2 Resource Server dependency to your <span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break"> file:</span><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-oauth2-resource-server&lt;/artifactId&gt;
&lt;/dependency&gt;</pre><p class="list-inset">Then, configure <strong class="source-inline">application.yml</strong> with the application registration settings. We’ll use the same configuration that we did for the <span class="No-Break">RESTful API:</span></p><pre class="source-code">spring
  security:
    oauth2:
      resourceserver:
        jwt:
          audiences:
          - football
          - football-ui
          issuer-uri: http://localhost:9000</pre></li>				<li>Now, configure Spring Cloud Gateway with the route to the <span class="No-Break">RESTful API:</span><pre class="source-code">
spring:
  <strong class="bold">cloud</strong>:
    gateway:
      routes:
        - id: teams
          uri: lb://football-api
          predicates:
            - Path=/football/**</pre><p class="list-inset">I’ve included the <strong class="source-inline">spring</strong> field in this code snippet for clarity, but it’s already defined for the security configuration, so you don’t need to include it again; only copy the configuration that belongs to the <span class="No-Break"><strong class="source-inline">cloud</strong></span><span class="No-Break"> label.</span></p></li>				<li>Now that the application<a id="_idIndexMarker471"/> is behind Spring Cloud Gateway, which is protected using OAuth2, you can test the application. Remember to run the Eureka and Authorization projects before running the Spring Cloud Gateway and RESTful <span class="No-Break">API projects.</span><p class="list-inset">First, you’ll need to obtain an access token from the authorization server to test the application. For that, execute the following command in <span class="No-Break">your Terminal:</span></p><pre class="source-code">
curl --location 'http://localhost:9000/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'grant_type=client_credentials' --data-urlencode 'client_id=football' \
--data-urlencode 'client_secret=SuperSecret' --data-urlencode 'scope=football:read'</pre><p class="list-inset">Get the access token value and include and pass it in the authorization header to get the results through the application gateway. Spring Cloud Gateway listens on port <strong class="source-inline">8080</strong>, so you need to execute the <span class="No-Break">following request:</span></p><pre class="source-code">curl --location http://localhost:8080/football/teams -H "Authorization: Bearer <strong class="bold">&lt;access token&gt;</strong>"</pre><p class="list-inset">Replace <strong class="source-inline">&lt;access token&gt;</strong> with the access token you obtained from the <span class="No-Break">authorization server.</span></p><p class="list-inset">You will see the result that’s returned by the <span class="No-Break">RESTful API:</span></p></li>			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer074">
					<img alt="Figure 4.12: Using the RESTful API through Spring Cloud Gateway, which is protected with OAuth2" src="image/B21646_04_12.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12: Using the RESTful API through Spring Cloud Gateway, which is protected with OAuth2</p>
			<p>The result contains a list <span class="No-Break">of teams.</span></p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor201"/>How it works...</h2>
			<p>Spring Cloud Gateway acts as a resource<a id="_idIndexMarker472"/> server. This means it will require a valid access token to be issued by our <span class="No-Break">authorization server.</span></p>
			<p>Spring Cloud Gateway will relay the access token to the downstream RESTful API. Both will validate the access token. You can configure Spring Cloud Gateway with the first level of OAuth2 validation. For example, you can validate the token issuer and the token scopes. Then, if you need more fine-grained validation, you can do so on the <span class="No-Break">RESTful API.</span></p>
		</div>
	

		<div class="Content" id="_idContainer076">
			<h1 id="_idParaDest-182" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor202"/>Part 2: Database Technologies</h1>
			<p>Almost all applications need to persist and access data efficiently, and for that, Spring Boot offers many choices, from relational and NoSQL databases to repositories, templates, <strong class="bold">Java Persistence Query Language</strong> (<strong class="bold">JPQL</strong>), and <span class="No-Break">native SQL.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B21646_05.xhtml#_idTextAnchor203"><em class="italic">Chapter 5</em></a>, <em class="italic">Data Persistence and Relational Database Integration with Spring Data</em></li>
				<li><a href="B21646_06.xhtml#_idTextAnchor266"><em class="italic">Chapter 6</em></a>, <em class="italic">Data Persistence and NoSQL Database Integration with Spring Data</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer077">
			</div>
		</div>
		<div>
			<div class="Basic-Graphics-Frame" id="_idContainer078">
			</div>
		</div>
	</body></html>