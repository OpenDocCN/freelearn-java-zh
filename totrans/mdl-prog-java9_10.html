<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Preparing Your Code for Java 9</h1>
                
            
            <article>
                
<p class="calibre2">In the last chapter, we looked at several patterns and best practices to use when building Java 9 modular applications. They are an extremely handy set of rules to remember when building new applications. But it's not always that developers have the opportunity to work on greenfield projects where they have the freedom to think about and build application architecture from scratch. What if there's already a lot of code built using Java 8 or earlier? How do we migrate such code to Java 9?</p>
<p class="calibre2">In this chapter, we'll be covering:</p>
<ul class="calibre14">
<li class="calibre15">Working on legacy code and getting it ready to be run in Java 9</li>
<li class="calibre15">Compiling legacy code in Java 9 and executing pre-Java 9 compiled code in the Java 9 runtime</li>
<li class="calibre15">Classpath behaviors in Java 9 and the unnamed module</li>
<li class="calibre15">Handling errors and non-standard API access and using the jdeps tool</li>
<li class="calibre15">Using override switches to work around tricky code and APIs</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Beginning Java 9 migration</h1>
                
            
            <article>
                
<p class="calibre2">You probably have some Java 8 (or earlier) code on your hands. And you are probably wondering what you'll need to do to get this to work with Java 9. When the Java 9 specification was going through the <strong class="calibre1">Java Community Process</strong> (<strong class="calibre1">JCP</strong>), there was some concerns in the developer community about just this. Will the legacy Java code work as-is in Java 9? If there are changes to be made, how much time and effort would they consume? Fortunately, Java has a great track record of maintaining backward compatibility, and that continues even with such major changes that have been brought into the language with the new modularity features. However, since Java 9 is one of the biggest overhauls to the Java internals, there might be some work that needs to be done. The amount of work depends primarily on two factors--the nature of migration you are trying to perform and the way the code itself is written.</p>
<p class="calibre2">Now what do I mean by <em class="calibre22">nature of migration</em>? When tackling Java 9 migration, it's useful to think about the effort in stages. At a high level, you could move your existing pre-Java 9 code through the following two stages:</p>
<ol class="calibre17">
<li value="1" class="calibre15">Getting your code to compile and execute in Java 9 as-is.</li>
<li value="2" class="calibre15">Refactoring the structure of your code to use the modularity features.</li>
</ol>
<p class="calibre2"><strong class="calibre1">Step 1</strong> involves using the <kbd class="calibre12">javac</kbd> and the <kbd class="calibre12">java</kbd> commands on your existing code base just like you have done all along, but with the new Java 9 version of the compiler and runtime. In this phase you'd like to make as little changes to the code as possible! <strong class="calibre1">Step 2</strong> involves refactoring or rewriting your code to use modularity features, including the things we've learned so far in this book--breaking down the code base into modular units, creating <kbd class="calibre12">module-info.java</kbd> for each of those modules and then establishing relationships between the modules.</p>
<p class="calibre2">Are both these steps necessary for migrating to Java 9? Well, <strong class="calibre1">Step 1</strong> is. For any application that you plan to run and use in the foreseeable future, it's worth getting it to at least work with the new Java 9 runtime. That way, you are ready for whenever Java 8 becomes <em class="calibre22">end-of-lifed</em> in the future. This type of migration should be relatively easy, except for a few things to look out for that we'll cover in this chapter.</p>
<p class="calibre2">After you've done that, and your applications now work with Java 9 compiler and runtime, you do have an option of refactoring your code to use all the cool new modular features you've learned. But that may not always be valuable. If you have code that you don't plan to modify or enhance over time, and you just need to <em class="calibre22">maintain</em> it to run the business, you aren't going to get a lot of value by refactoring it to use Java 9 modules.</p>
<p class="calibre2">However, if you anticipate making changes and actively working on the code base, there is benefit to refactoring the code to use modules. The next chapter deals with migrating code that involves using the rich JPMS features we now get with Java 9.</p>
<div class="packt_infobox">We'll be covering <strong class="calibre26">Step 1</strong> in this chapter. <strong class="calibre26">Step 2</strong> is covered in <a target="_blank" href="part0172.html#5410O0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre27">Chapter 11</a>, <em class="calibre29">Migrating Your Code to Java 9</em>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introducing the sample Java 8 application</h1>
                
            
            <article>
                
<p class="calibre2">We will be using a sample Java 8 code base to try migrating to Java 9. It's a command-line <kbd class="calibre12">shopping bag</kbd> utility. When you run the application, it prompts you to add items to your shopping bag. Once you've added all the items and you are done, you type <kbd class="calibre12">end</kbd>. The application then displays a consolidated shopping list of items that you've added. The application is intentionally simple, but it gives us a good starting point to work through the migration.</p>
<p class="calibre2">Here's a screenshot of the application in action:</p>
<div class="packt_figure"><img class="image-border77" src="../images/00084.jpeg"/></div>
<p class="calibre2">The application consists of three classes in three different packages:</p>
<ul class="calibre14">
<li class="calibre15">The <kbd class="calibre12">ShoppingBag</kbd> class: It contains a method to add items to a shopping bag, and one to pretty print the contents of the bag. The class uses the <kbd class="calibre12">Bag</kbd> data structure from the Apache Commons Collections library. Think of this data structure as something similar to a <kbd class="calibre12">Set</kbd>, but with duplicates allowed:</li>
</ul>
<pre class="calibre23">        public class ShoppingBag  { 
     
          public static String END_TOKEN = "end"; 
          private Bag&lt;String&gt; bag = new HashBag&lt;&gt;(); 
     
          public boolean addToBag(String itemName) { 
            return (END_TOKEN.equals(itemName)) ||<br class="title-page-name"/>             this.bag.add(itemName);  
          } 
     
          public void prettyPrintBag() { 
            ... 
          } 
 
        } </pre>
<ul class="calibre14">
<li class="calibre15">The <kbd class="calibre12">UserInputUtil</kbd> class: It contains a method to prompt the user for an input. It also contains a public <kbd class="calibre12">close</kbd> method to close the input stream when done:</li>
</ul>
<pre class="calibre23">        public class UserInputUtil { 
          Scanner scanner = new Scanner(System.in); 
    
          public String getUserInput(String prompt) { 
            System.out.print(prompt); 
            return scanner.nextLine(); 
          } 
    
          public void close() { 
            scanner.close(); 
          } 
 
        } </pre>
<ul class="calibre14">
<li class="calibre15">The <kbd class="calibre12">App</kbd> class: Putting it all together. This class has the <kbd class="calibre12">main</kbd> method. It uses the <kbd class="calibre12">UserInputUtil</kbd> to prompt the user to enter items into the shopping bag. It adds each item to a <kbd class="calibre12">ShoppingBag</kbd> instance, and it then prints the bag when done:</li>
</ul>
<pre class="calibre23">        public class App { 
 
          private static final Logger logger = 
            Logger.getLogger(App.class.getName()); 
 
          public static void main(String[] args) { 
 
            logger.info("Shopping Bag application: Started"); 
 
            ShoppingBag shoppingBag = new ShoppingBag(); 
            UserInputUtil userInputUtil = new UserInputUtil(); 
            String itemName; 
            do { 
             
              itemName = userInputUtil.getUserInput("Enter item (<br class="title-page-name"/>                Type '" + ShoppingBag.END_TOKEN + "' when done): "); 
              shoppingBag.addToBag(itemName); 
             
            } while (!ShoppingBag.END_TOKEN.equals(itemName)); 
            userInputUtil.close(); 
            shoppingBag.prettyPrintBag(); 
            logger.info("Shopping Bag application: Completed"); 
          } 
        } </pre>
<p class="calibre2">In addition to the application code, there's a <kbd class="calibre12">lib</kbd> folder with the Apache Commons Collection library JAR file--<kbd class="calibre12">commons-collections4-4.1.jar</kbd>. The code depends on this library JAR file. We'll need to add this JAR file to the classpath when compiling and running the code.</p>
<div class="packt_tip">I recommend looking at the included source code at the location -<kbd class="calibre28">10-migrating-application/01-legacy-app</kbd>and getting familiar with it. We'll be using this application as we work through the migration process.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the Java 9 compiler and runtime</h1>
                
            
            <article>
                
<p class="calibre2">Let's get started with the first step--compiling and running an old code base using the Java 9 compiler and runtime. It'll be great if things work as-is. If changes are required, we'd like to make as few of them as possible.</p>
<p class="calibre2">First, make sure you are using Java 9 using the following command. If you have a different version, you'll need to switch, as covered in <a target="_blank" href="part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 2</a>, <em class="calibre22">Creating Your First Java Module</em>:</p>
<pre class="calibre23"><strong class="calibre1">$ java --version</strong>  </pre>
<p class="calibre2">From the project folder, create a new out directory for our compiled classes and run the following Java compiler command to compile all the <kbd class="calibre12">.java</kbd> files:</p>
<pre class="calibre23"><strong class="calibre1">$ mkdir out</strong>
<strong class="calibre1">$ javac -cp lib/commons-collections4-4.1.jar  -d out $(find . -name <br class="title-page-name"/>  '*.java')</strong>  </pre>
<p class="calibre2">In the preceding <kbd class="calibre12">javac</kbd> command, we are adding the commons collections JAR file to the classpath using the <kbd class="calibre12">-cp</kbd> option, specifying the output directory for the compiled classes using the <kbd class="calibre12">-d</kbd> option and then specifying all the <kbd class="calibre12">.java</kbd> files in the following directories recursively using <kbd class="calibre12">$(find . -name '*.java')</kbd>.</p>
<p class="calibre2">The compilation step should go through fine without any errors. Great! Let's try to run it:</p>
<pre class="calibre23"><strong class="calibre1">$ java -cp out:lib/commons-collections4-4.1.jar  <br class="title-page-name"/>  com.packt.sortstrings.app.App</strong>  </pre>
<p class="calibre2">In the preceding <kbd class="calibre12">java</kbd> command, we are specifying two paths in the classpath <kbd class="calibre12">-cp</kbd> option--the <kbd class="calibre12">out</kbd> directory that contains the compiled classes and the common collections JAR file. Following that is the fully qualified class name of the class with the <kbd class="calibre12">main</kbd> method.</p>
<div class="packt_infobox">Notice that we are still using classpath and not the concept of module path. Java 9 still works with classpath, and with the same <span class="packt_screen"><kbd class="calibre28">-cp</kbd> </span>option as did the previous Java versions. More on that shortly.</div>
<p class="calibre2">Running the command should result in success, with the prompt being displayed as expected. And there you have it! A Java 8 application has compiled and executed using Java 9, and not a single line of code needed to be changed! As much as I'd love to tell you that all legacy code will work just as easily as this, it is unfortunately not true. There are some cases that need more effort. However, the good thing is that in the majority of the cases, this process <em class="calibre22">should</em> be this effortless. We'll look at some of the cases where you might run into problems, and how to address them in the next section. But first, knowing what we now know about Java 9, isn't it surprising that everything worked well? If you think about it, both the compilation and execution should have failed! Why? Here are a couple of reasons:</p>
<ul class="calibre14">
<li class="calibre15">We learned that Java 9 is moving to a module system and that <em class="calibre22">everything</em>, be it the application code or the platform, should be in a module! Our Java 8 code is obviously not in a predefined module. That's fine in Java 8, but shouldn't that have caused an error in Java 9?</li>
<li class="calibre15">
<p class="calibre2">Notice that <kbd class="calibre12">App.java</kbd> is using the Java logging API. We've learned in <a target="_blank" href="part0058.html#1NA0K0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 4</a>, <em class="calibre22">Introducing the Modular JDK</em> that the logging APIs have been bundled into a separate platform module called <kbd class="calibre12">java.logging</kbd> <span>. And all code that accesses any module that's not </span><kbd class="calibre12">java.base</kbd> <span>should </span>require <span>it explicitly. That's clearly not happening in the code here, because this is Java 8 code, and there's no <kbd class="calibre12">module-info.java</kbd> module definition to begin with.</span></p>
</li>
</ul>
<p class="calibre2">This begs the question--how did compiling and executing this code in Java 9 still work? It all works thanks to some special features introduced in the language to support this very process--executing legacy code in Java 9. The specific feature that's working for us here is called the <strong class="calibre1">unnamed module</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The unnamed module</h1>
                
            
            <article>
                
<p class="calibre2">Well, we weren't wrong. All code in Java 9 <em class="calibre22">needs</em> to be in modules. And all modules need to have the right readability and accessibility relationships for applications to work. But that might be problematic! Because, as with every new Java release, there are thousands of developers trying to run their legacy Java code bases using the new Java version. If we were to expect each legacy Java code base to be wrapped into modules before it can even run in Java 9, which would introduce a significant cost of effort in the developer community. Thankfully, there's a way out. When you are using Java 9 to compile or run legacy module-less Java code in the classpath, you <em class="calibre22">don't</em> have to manually create module wrappers yourself. The platform automatically creates a single module that comprises of everything you have in your classpath. This module doesn't have a name and so, is referred to as the <em class="calibre22">unnamed module</em>.</p>
<p class="calibre2">With all the Java 9 code we've compiled and executed so far, we've not been using the classpath at all. Here's a schematic of the modules in our Java 9 application as we've been running it so far:</p>
<div class="packt_figure"><img class="image-border78" src="../images/00085.jpeg"/><br class="title-page-name"/></div>
<p class="calibre2">We've so far had the whole runtime work with built-in platform modules in the JRE along with your application modules from the module path. These together form the complete set of observable modules. Now what happens if you throw in the classpath in there? When running with the classpath option, here's how the picture looks like:</p>
<div class="packt_figure"><img class="image-border79" src="../images/00086.jpeg"/><br class="title-page-name"/></div>
<p class="calibre2">And here's where we would have violated the <em class="calibre22">all-code-needs-to-be-in-modules</em> rule. Thanks to the automatic module feature, we haven't. The Java 9 platform automatically wraps all the classes and JARs in the classpath into one unnamed module:</p>
<div class="packt_figure"><img class="image-border80" src="../images/00087.jpeg"/><br class="title-page-name"/></div>
<p class="calibre2">This is exactly what's happening to the shopping bag application. All the application code, including the common collections jar is a part of the single unnamed module. OK, that addresses one of the concerns. How about the second one? How did the code get access to the Java logging API? Shouldn't the unnamed module declare requires <kbd class="calibre12">java.logging</kbd>? But how could it? The unnamed module doesn't have a <kbd class="calibre12">module-info.java</kbd> file anyway! Because the platform cannot really tell for sure what the classpath code needs, the unnamed module is automatically given readability access to <em class="calibre22">all</em> observable modules. In other words, it mimics the <em class="calibre22">free-for-all</em> behavior of code in the classpath pre-Java 9--it <kbd class="calibre12">requires</kbd> everything, because that's the only way the platform can maximize the chances of any legacy code working as-is in Java 9. If you were to draw a module graph, it would look like the unnamed module has readability relationship to every module in the set of observable modules, as represented in the following diagram:</p>
<div class="packt_figure"><img class="image-border81" src="../images/00088.jpeg"/></div>
<p class="calibre2">This diagram is very messy, so we'll not draw this again. From now on, we'll just simplify all the readability edges coming out of the automatic module into a single arrow to keep things legible.</p>
<p class="calibre2">The automatic module feature was built into the platform specifically for migration purposes, and as you can see, it's the reason why our Java 8 code was able to compile and run in Java 9 without any errors. To summarize:</p>
<ul class="calibre14">
<li class="calibre15">Every time you supply the <kbd class="calibre12">-classpath</kbd> option to compile or execute code in Java 9, the platform creates an unnamed module. All classes and jars in the supplied classpath are bundled into this unnamed module.</li>
<li class="calibre15">The unnamed module automatically <em class="calibre22">reads</em> every observable module. Thus, not only does it read all the Java 9 platform modules, it also reads all your application and library modules in the module path (if you've supplied the module path argument to the command, in addition to the classpath.</li>
</ul>
<div class="packt_infobox">Every time you use the Java compiler without any module path options, you runs the compiler in what's referred to as a <em class="calibre29">single module mode</em>. In this mode, like we've seen, we are dealing with the single unnamed module. The code is expected to be organized into the traditional package-based directory structure, and there are no module folders.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Handling non-standard access</h1>
                
            
            <article>
                
<p class="calibre2">Wait! There's a catch! The unnamed module reads all Java platform modules and because of that, I mentioned it mimics the <em class="calibre22">free-for-all</em> behavior of the pre-Java 9 platform. But that's not exactly true. Pre-Java 9, the entire platform, and all the classes in it were accessible to your application code. With Java 9 platform modularization, there are several internal types in platform modules that are not exported, thus making them encapsulated. It's a good thing that the unnamed module automatically reads all platform modules by default, but is that enough? Not really, because it just enables the code in the classpath to access only the types <em class="calibre22">exported</em> from the modules. But what if your legacy code uses a type that is now encapsulated in a platform module in Java 9? Just having the unnamed module read all the platform modules is not enough, because the encapsulated types would still not be available. The same problem exists for code that accesses types that are removed. Yes, there are certain types in JDK 8 and earlier that are no longer available in Java 9. And any legacy code that uses such types will fail to compile and run in Java 9.</p>
<p class="calibre2">The code at <kbd class="calibre12">10-migrating-application/02-non-standard-api</kbd> is an example of a code with such access of internal types. The class <kbd class="calibre12">App.java</kbd> uses two types:</p>
<ul class="calibre14">
<li class="calibre15">
<div class="title-page-name"><kbd class="calibre12">Base64Encoder</kbd> <span>that was available in previous versions of Java, but now with Java 9, has been completely removed</span></div>
</li>
<li class="calibre15">
<div class="title-page-name"><kbd class="calibre12">CalendarUtils</kbd><span>, which is encapsulated as an internal type in the</span></div>
<div class="title-page-name"><kbd class="calibre12">java.base</kbd> <span>module in Java 9</span></div>
</li>
</ul>
<p class="calibre2">Even if you were creating a new Java 9 module, there's no platform module that your code can require to access it. The type is not exported from the module and so is effectively sealed. Thus, even the unnamed module would not be able to access them.</p>
<p class="calibre2">Here's the sample code. The code itself is completely non-functional as it is just an attempt to try using these two types:</p>
<pre class="calibre23">    package com.packt.app; 
    import sun.misc.BASE64Encoder; 
    import sun.util.calendar.CalendarUtils; 
 
    public class App { 
      public static void main(String[] args) { 
        BASE64Encoder enc = new BASE64Encoder(); 
        CalendarUtils.isGregorianLeapYear(2018); 
      } 
    } </pre>
<p class="calibre2">Switch to Java 8 compiler and compile the code:</p>
<pre class="calibre23"><strong class="calibre1">$ export JAVA_HOME=$(/usr/libexec/java_home -v 1.8)</strong></pre>
<p class="calibre2">Notice that while the compilation goes through, you do see warnings!</p>
<div class="packt_figure"><img class="image-border82" src="../images/00089.jpeg"/></div>
<p class="calibre2">For quite a while now, developers have been warned about such usages of internal types! For someone working on such code, it should not come as a surprise that these APIs don't work in Java 9.</p>
<p class="calibre2">Let's switch to Java 9 and compile this code. Use the following command on macOS or Linux:</p>
<pre class="calibre23"><strong class="calibre1">$ export JAVA_HOME=$(/usr/libexec/java_home -v 1.9)</strong> </pre>
<p class="calibre2">On Windows, follow the steps outlined in <a target="_blank" href="part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 2</a>, <em class="calibre22">Creating Your First Java Module</em>.</p>
<p class="calibre2">After switching the Java version to 9, run the compile command on this code. This time, you don't get warnings. You get errors and the code doesn't compile:</p>
<div class="packt_figure"><img class="image-border83" src="../images/00090.jpeg"/></div>
<p class="calibre2">Notice that there are two different errors, one for each type:</p>
<ul class="calibre14">
<li class="calibre15">The error for <kbd class="calibre12">CalendarUtils</kbd> indicates that the type is now encapsulated (that is, not exported) from <kbd class="calibre12">java.base</kbd>.</li>
<li class="calibre15">The error for <kbd class="calibre12">BASE64Encoder</kbd> mentions that the compiler just doesn't find it. The type has been removed from Java 9.</li>
</ul>
<p class="calibre2">When compiling and running legacy code in Java 9, these are two of the most likely errors you could get because of the modularity changes. Fixing either of these errors requires changing your code. You'll have to either find an equivalent class or API in the new platform that does what you need. Or find an external library that has the APIs you need. What's tricky is that the problematic code may not necessarily be in your application code. It could be in a library or a framework that you use. Even in that case, your application won't compile or run in Java 9, until you remove the dependency or the library is updated.</p>
<p class="calibre2">There is some help that the platform provides to help you identify such problems with your application and its dependencies. It's a tool called <kbd class="calibre12">jdeps</kbd>.</p>
<p class="calibre2"><kbd class="calibre12">jdeps</kbd> was first shipped with Java 8 to help developers identify and fix internal API access. With Java 9, it's much more helpful and detailed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The jdeps tool</h1>
                
            
            <article>
                
<p class="calibre2">The <strong class="calibre1">Java Dependency Analysis Tool</strong> (<strong class="calibre1">jdeps</strong>) is a utility that can statically examine your application and library classes to identify if there are any uses of the JDK internal APIs that no longer work with Java 9. You can run <kbd class="calibre12">jdeps</kbd> on your compiled class files or JARs, and have it list out all such references. For each reference, <kbd class="calibre12">jdeps</kbd> will highlight usages of internal types that are no longer available for your code to use. It even suggests replacement APIs if they are available.</p>
<p class="calibre2">The command syntax looks like this:</p>
<pre class="calibre23"><strong class="calibre1">$ jdeps -jdkinternals &lt;jar-files&gt;</strong>  </pre>
<p class="calibre2">If you have a bunch of classes compiled and you want to run <kbd class="calibre12">jdeps</kbd> on them, you can even provide a classpath parameter:</p>
<pre class="calibre23"><strong class="calibre1">$ jdeps -jdkinternals -cp &lt;class-paths&gt;</strong>  </pre>
<p class="calibre2">Let's try this with the <kbd class="calibre12">02-non-standard-api</kbd> project. We've already compiled the project (albeit with warnings) with the Java 8 compiler, and the classes now exist in the out directory. Running <kbd class="calibre12">jdeps</kbd> on them yields the following output:</p>
<div class="packt_figure"><img class="image-border84" src="../images/00091.jpeg"/></div>
<p class="calibre2"><kbd class="calibre12">sun.misc.BASE64Encoder</kbd> is indicated as a <em class="calibre22">JDK removed internal API</em> while <kbd class="calibre12">sun.util.calendar.CalendarUtils</kbd> is indicated as a JDK internal API from <kbd class="calibre12">java.base</kbd>. In the case of <kbd class="calibre12">BASE64Encoder</kbd>, the tool provides a helpful suggestion to use an alternative API (<kbd class="calibre12">java.util.Base64</kbd>) that has been available in Java since version 1.8.</p>
<p class="calibre2"><kbd class="calibre12">jdeps</kbd> can also be run on JARs as previously mentioned. If we were to run the tool on the included <kbd class="calibre12">01-app-migration</kbd> project for example, we'll get no output. Which is a good thing because that means there are no JDK internals being used, and the JAR is good to use for Java 9:</p>
<pre class="calibre23"><strong class="calibre1">$ jdeps -jdkinternals commons-collections4-4.1.jar</strong>  </pre>
<div class="packt_infobox">
<div class="calibre25"><kbd class="calibre28">jdeps</kbd> <span class="packt_screen">is a</span> <em class="calibre29">static</em> <span class="packt_screen">code analysis tool, with emphasis on the word</span> <em class="calibre29">static</em><span class="packt_screen">. It looks at the code to identify illegal API use. It cannot identify dynamic runtime use through reflection, for example. Thus, there is a chance that </span><kbd class="calibre28">jdeps</kbd> gives you the all-clear for a code base, but when you run it, you might still end up with an <span class="packt_screen"><kbd class="calibre28">IllegalAccessException</kbd> </span>because the code uses reflection to access an internal type that's no longer available.</div>
</div>
<p class="calibre2">To summarize, <kbd class="calibre12">jdeps -jdkinternals</kbd> is a great tool to use to check your pre-compiled application and library classes and verify any incompatibilities with Java 9. It is especially helpful that the tool recommends alternative options to use when possible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Overriding module behavior</h1>
                
            
            <article>
                
<p class="calibre2"><kbd class="calibre12">jdeps</kbd> is great at identifying internal API access and suggesting fixes. They come in handy when fixing your own application code that contains such problems. But what if <kbd class="calibre12">jdeps</kbd> reports problems with some code in a library or a framework you are using? In such cases, you have lesser control over the code. Even if the framework itself is open source, the scale and complexity of the library may not make it feasible for you to implement the fix yourself. This does present a very clear risk for applications moving to Java 9--your app won't run in Java 9 until all your libraries are updated to work in Java 9. It's very likely that most library developers have either already heeded to the scores of warnings in Java 8 and fixed their code, or they will soon, because of their code breaking in Java 9. But if they don't, this could mean that your migration plans are at the mercy of the library authors.</p>
<p class="calibre2">Thankfully, the platform comes with some override features to get around this problem. The override features we'll look at here apply not just to legacy Java code being compiled in Java 9, they also work on Java 9 modules. But since they are primarily designed to assist migration, they should be used in the context of migration only, and other uses should ideally be avoided.</p>
<p class="calibre2">What are these override features? Remember that a Java 9 module has a <em class="calibre22">module definition</em> that specifies what it <kbd class="calibre12">requires</kbd> and what it <kbd class="calibre12">exports</kbd>. These individual module definitions that are specified in the <kbd class="calibre12">module-info.java</kbd> file at development time essentially control the accessibility relationship between modules during compilation and runtime. However, it turns out, both the compiler and runtime has override options for these module relationships that allow you to change what any given module <kbd class="calibre12">requires</kbd> or <kbd class="calibre12">exports</kbd> by specifying command-line arguments.</p>
<p class="calibre2">There are three command line flags to <kbd class="calibre12">javac</kbd> and <kbd class="calibre12">java</kbd> to override specific module configurations:</p>
<ul class="calibre14">
<li class="calibre15">
<p class="calibre2"><kbd class="calibre12">add-reads</kbd><span>: The </span><kbd class="calibre12">--add-reads</kbd> <span>option allows you to specify additional readability relationships that may not already be available for a module as per the module configuration. The syntax is:</span></p>
</li>
</ul>
<pre class="calibre23">      <strong class="calibre1">--add-reads &lt;source-module&gt;=&lt;target-module&gt;</strong></pre>
<p class="calibre2">Adding this option to the <kbd class="calibre12">javac</kbd> and <kbd class="calibre12">java</kbd> command line creates a new readability relationship only for that command execution you use the argument for. For example, let's say you have modules <kbd class="calibre12">moduleA</kbd> and <kbd class="calibre12">moduleB</kbd>, and you want to have <kbd class="calibre12">moduleA</kbd> read <kbd class="calibre12">moduleB</kbd>. You can either edit the <kbd class="calibre12">module-info.java</kbd> file in <kbd class="calibre12">moduleA</kbd> and add the line requires <kbd class="calibre12">moduleB;</kbd>, or add the following argument to the compiler and runtime, as shown in this following truncated command:</p>
<pre class="calibre23"><strong class="calibre1">      $ java ... --add-reads moduleA=moduleB</strong></pre>
<ul class="calibre14">
<li class="calibre15">
<p class="calibre2"><kbd class="calibre12">add-exports</kbd><span>: The </span><kbd class="calibre12">--add-exports</kbd> <span>option allows you to add additional exported packages from a module, thereby breaking or overriding encapsulation. The syntax is:</span></p>
</li>
</ul>
<pre class="calibre23">      <strong class="calibre1">--add-exports &lt;source-module&gt;/&lt;package-name&gt;=&lt;target-module&gt;</strong></pre>
<ul class="calibre14">
<li class="calibre15">
<p class="calibre2">For example, if <kbd class="calibre12">moduleA</kbd> needs package <kbd class="calibre12">pack.internal</kbd> from <kbd class="calibre12">moduleB</kbd>, but <kbd class="calibre12">moduleB</kbd> <span>does not export the package, you can add the following override to have <kbd class="calibre12">moduleB</kbd></span> <span>export the required package for <kbd class="calibre12">moduleA</kbd>, as shown in this truncated command</span><span>:</span></p>
</li>
</ul>
<pre class="calibre23"><strong class="calibre1">      $ java ... --add-exports moduleB/pack.internal=moduleA</strong></pre>
<ul class="calibre14">
<li class="calibre15">
<p class="calibre2"><kbd class="calibre12">add-opens</kbd><span>: The </span><kbd class="calibre12">--add-opens</kbd> <span>option lets you override the </span><kbd class="calibre12">opens</kbd> <span>relationship between modules to allow reflective access. This is an override that simulates the </span><kbd class="calibre12">opens</kbd> <span>keyword configuration in the module definition. The syntax is:</span></p>
</li>
</ul>
<pre class="calibre23">      <strong class="calibre1">--add-opens &lt;source-module&gt;/&lt;package-name&gt;=&lt;target-module&gt;</strong></pre>
<ul class="calibre14">
<li class="calibre15">Following the same example, if <kbd class="calibre12">moduleA</kbd> needs runtime-only reflective access to the package <kbd class="calibre12">pack.internal</kbd> in <kbd class="calibre12">moduleB</kbd>, you would run the <kbd class="calibre12">javac</kbd> or <kbd class="calibre12">java</kbd> command with the following option:</li>
</ul>
<pre class="calibre23"><strong class="calibre1">     $ java ... --add-opens moduleB/pack.internal=moduleA</strong></pre>
<div class="packt_infobox">Note that the overrides are always <em class="calibre29">qualified</em>, that is, you specify them for a specific target module. For example, you don't use the <span class="packt_screen"><kbd class="calibre28">--add-exports</kbd> </span>flag to export a package to every other module. You explicitly specify one or more target modules that the override applies to from the source module. That's a good thing because every override is made consciously and it's easy to track what is needed to get the application to work.</div>
<p class="calibre2">There is another way to provide these overrides in addition to command line arguments. You can specify them inside JAR file manifests. Let's say you have an executable JAR file that needs some overrides to work with platform modules in Java 9. To avoid having to specify these overrides everytime as command line arguments, you could just specify these as manifest attributes in the <kbd class="calibre12">MANIFEST.MF</kbd> file in your JAR file. As with all manifest attributes, the value should be specified following a space after the attribute name in the <kbd class="calibre12">MANIFEST.MF</kbd> file. The manifest attribute <kbd class="calibre12">Add-Exports</kbd> corresponds to the  <kbd class="calibre12">--add-exports</kbd> argument. The attribute  <kbd class="calibre12">Add-Opens</kbd> corresponds to <kbd class="calibre12">--add-opens</kbd>. There's no manifest attribute equivalent for <kbd class="calibre12">--add-reads</kbd>.</p>
<p class="calibre2">In addition to these overrides, there's a master <em class="calibre22">kill switch</em> for any modularity related encapsulation for classes in the classpath--the <kbd class="calibre12">--permit-illegal-access</kbd> flag. Unlike the previous three options, this option works only on code in the classpath. This flag, when passed to <kbd class="calibre12">javac</kbd> or <kbd class="calibre12">java</kbd> effectively disables <em class="calibre22">all</em> readability and accessibility restrictions, thus making any type accessible to any other type in the classpath. It's almost as if there are no Java modularity features, and everything in the classpath works as if you are running in Java 8 or earlier. As you'd expect, it's not a good idea to use this flag, especially if you are running code in production. This is provided to help developers migrate their classpath applications, and could very well be removed in the future. Think of this as a <em class="calibre22">last resort</em> option to get things to work as you work on migration.</p>
<p class="calibre2">Now that you've learned these override options, how can you apply them to solve the problem we started discussing this section with libraries or classes in your Java 8 code that use encapsulated APIs, and thus no longer work in Java 9? If the code is not in your control and you cannot fix it to <em class="calibre22">avoid</em> using the encapsulated types, you could use the override switch to manually add the required <kbd class="calibre12">exports</kbd>! For example, our code in the <kbd class="calibre12">02-non-standard-api</kbd> used an internal non-exported type <kbd class="calibre12">CalendarUtils</kbd> from <kbd class="calibre12">java.base</kbd>. Since we obviously cannot change the module descriptor for the  <kbd class="calibre12">java.base</kbd> module, what we could instead do is pass the <kbd class="calibre12">--add-exports</kbd> option to the module and have it export the required packages.</p>
<p class="calibre2">But here's a problem. Note that the syntax needs the source and target module names. The source module name is <kbd class="calibre12">java.base</kbd> of course. What is the target module? It's the unnamed module, because it's the classes in the classpath that needs this package. This brings up an interesting question--what is the name of the unnamed module? The unnamed module doesn't have a name (or indeed it wouldn't be called that!), but there's a special token called <kbd class="calibre12">ALL-UNNAMED</kbd> that you can pass to the override arguments that let the platform know that you are referring to the unnamed module:</p>
<div class="packt_figure"><img class="image-border85" src="../images/00092.jpeg"/></div>
<p class="calibre2">This command should solve the problem of the <kbd class="calibre12">CalendarUtils</kbd> access in our code. There's still the missing <kbd class="calibre12">BASE64Encoder</kbd> type. There's no command-line argument to fix that one. Like we've seen, the type simply doesn't exist in Java 9. We'll have to replace it with something that does. Taking the suggestion provided by <kbd class="calibre12">jdeps</kbd>, the class <kbd class="calibre12">AppFixed.java</kbd> has the updated code that uses the <kbd class="calibre12">Base64class</kbd> instead:</p>
<div class="packt_figure"><img class="image-border86" src="../images/00093.jpeg"/></div>
<p class="calibre2">This time, you don't get errors and the compilation goes through. You still see the warning about using an internal type. The compiler still reminds you that it's not an ideal situation, but since you've added the override, it trusts that you know what you are doing.</p>
<p class="calibre2">If the code was complied in a previous version of Java and you were running it in Java 9 <em class="calibre22">and</em> the problem was only with accessing encapsulated types, you can add the same override arguments to the <kbd class="calibre12">java</kbd> command and have it run. However, if the compiled classes are referring to unavailable types, like the <kbd class="calibre12">BASE64Encoder</kbd> type we just looked at, you have no choice but to edit the code and recompile first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding the impact</h1>
                
            
            <article>
                
<p class="calibre2">Now that you know what are the possible problems you could face when compiling or running legacy code in Java 9, as well as how to solve those problems when they occur, let's spend some time understanding the scope of these problems. How worried should you be about having to encounter and fix these issues in your legacy Java code?</p>
<p class="calibre2">We can classify backward-incompatible APIs into the following broad categories:</p>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">APIs with replacements</strong>: This link (also the link provided in the output of <kbd class="calibre12">jdeps --jdk-internals</kbd><span>) provides a complete list of APIs that need replacements in Java 9: </span><a href="https://wiki.openjdk.java.net/display/JDK8/Java+Dependency+Analysis+Tool" class="calibre4">https://wiki.openjdk.java.net/display/JDK8/Java+Dependency+Analysis+Tool</a>.</li>
</ul>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">Encapsulated APIs</strong>: When you run <kbd class="calibre12">jdeps</kbd>, you might see errors about usage of internal JDK types that do not have replacement suggestions. They could just be types that were formerly available pre-Java 9 but are now encapsulated in a platform module. These are fixable by using the right command line overrides to the <kbd class="calibre12">javac</kbd> and <kbd class="calibre12">java</kbd> invocations.</li>
</ul>
<p class="calibre2">On the other hand, there are certain APIs that were originally meant for removal, but they still happen to be available. While the intent has been to encapsulate all the internal JDK APIs, there have been a few APIs that have been so widely used in the Java developer community and for which there are no suitable replacements that encapsulating them would add so much more difficulty to the migration process. Remember the widely used <kbd class="calibre12">sun.misc.Unsafe</kbd> API we discussed in <a target="_blank" href="part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 1</a>, <em class="calibre22">Introducing Java 9 Modularity</em>? Such APIs continue to be accessible in Java 9. But in order to make these APIs easier to deprecate later, they have been moved into a separate module called <kbd class="calibre12">jdk.unsupported</kbd>, from which these types can be accessed.</p>
<p class="calibre2">Running <kbd class="calibre12">java -d</kbd> on the <kbd class="calibre12">jdk.unsupported</kbd> module shows us the <em class="calibre22">unsupported</em> APIs that are still accessible for now:</p>
<pre class="calibre23"><strong class="calibre1">$ java -d jdk.unsupported</strong>
  <strong class="calibre1">jdk.unsupported@9</strong>
  <strong class="calibre1">exports com.sun.nio.file</strong>
  <strong class="calibre1">exports sun.misc</strong>
  <strong class="calibre1">exports sun.reflect</strong>
  <strong class="calibre1">requires java.base mandated</strong>
  <strong class="calibre1">opens sun.reflect</strong>
  <strong class="calibre1">opens sun.misc</strong></pre>
<p class="calibre2">A word of caution. The <kbd class="calibre12">jdk.unsupported</kbd> module and the APIs are very likely to be removed from the next versions of Java, so don't plan on relying on this module for too long.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Recommended strategy</h1>
                
            
            <article>
                
<p class="calibre2">Let's wrap up by outlining the recommended strategy for compiling and running your legacy code in Java 9. Here are the steps you'd ideally follow:</p>
<ol start="1" class="calibre17">
<li value="1" class="calibre15">Run <kbd class="calibre12">jdeps --jdk-internals</kbd> to verify if your code has any internal API access. If there are no errors, just try compiling and running your code in Java 9. For the vast majority of cases, where there are no accesses to internal JDK APIs, the code should simply just work.</li>
<li value="2" class="calibre15">If there are errors and they are caused by your application code that you can change, follow the <kbd class="calibre12">jdeps</kbd> recommendation and fix those errors.</li>
<li value="3" class="calibre15">If the errors are caused by libraries that are not in your control, check if there are updates published by the library authors and get the latest versions. Many libraries that use internal APIs are being updated to work with Java 9, and the fix for your libraries might have already been done and published.</li>
<li value="4" class="calibre15">If none of the previous steps work, consider using the override options  <kbd class="calibre12">--add-exports</kbd> or  <kbd class="calibre12">--add-opens</kbd> <span>to the platform APIs that you need internal access to. This is a short-term stop-gap arrangement until the offending code or library is fixed.</span></li>
</ol>
<ol start="5" class="calibre17">
<li value="5" class="calibre15">If none of these work, as a last resort, turn off all modularity features with the <kbd class="calibre12">--permit-illegal-access</kbd> kill switch. While it is not recommended (and you certainly don't want to deploy an app with this switch in production), it's a handy way to get started if you are being overwhelmed with compatibility issues. A cool feature of this switch is that when you run your code that makes any <em class="calibre22">illegal access</em>, it prints out a warning message. It can be very helpful to consolidate this information and plan to fix them later.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">This chapter covered the first of the two phases of code migration to Java 9-- the process of compiling or running your pre-Java 9 code in Java 9. We used a sample Java 8 project (without any internal API access) in order to compile and execute it in Java 9. We then looked at a class with a couple of deliberate internal API access instances and saw what the error we'll encounter looks like. We learned about the <kbd class="calibre12">jdeps</kbd> tool and how to use it to statically scan your code base and identify such instances.</p>
<p class="calibre2">Once the instances have been identified, we covered a couple of ways to solve the problem--using the suggested replacement APIs or using command-line flags to temporarily overcome the problem. We used both these options to get the previously failing code to compile and execute fine in Java 9. We then looked at a high level strategy to follow in order to complete the process of getting your legacy code to run in Java 9.</p>
<p class="calibre2">If you are working on code that you just need to maintain and are not likely to build on, this is where you could stop your migration journey. But, if you need to actively evolve the code, it's a good idea to go further than that. In the next chapter, we'll learn how to get it through the second phase of the Java 9 migration--to refactor it to use the Java 9 modularity features.</p>


            </article>

            
        </section>
    </body></html>