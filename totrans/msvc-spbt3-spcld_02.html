<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer057" class="Basic-Text-Frame">
    <h1 class="chapterNumber">2</h1>
    <h1 id="_idParaDest-64" class="chapterTitle">Introduction to Spring Boot</h1>
    <p class="normal">In this chapter, we will be introduced to how to build a set of cooperating microservices using Spring Boot, focusing on how to develop functionality that delivers business value. The challenges with microservices that we pointed out in the previous chapter will be considered only to some degree, but they will be addressed to their full extent in later chapters.</p>
    <p class="normal">We will develop microservices that contain business logic based on plain <strong class="keyWord">Spring Beans</strong> and expose REST <a id="_idIndexMarker111"/>APIs using <strong class="keyWord">Spring WebFlux</strong>. The APIs will be documented based on the OpenAPI Specification using <code class="inlineCode">springdoc-openapi</code>. To make the data processed by the microservices persistent, we will use <strong class="keyWord">Spring Data</strong> to store data in both SQL and NoSQL databases.</p>
    <p class="normal">Since Spring Boot v2.0 was released in March 2018, it has become much easier to develop reactive microservices, including non-blocking synchronous REST APIs. To develop message-based asynchronous services, we will use <strong class="keyWord">Spring Cloud Stream</strong>. Refer to <em class="chapterRef">Chapter 1</em>, <em class="italic">Introduction to Microservices</em>, the <em class="italic">Reactive microservices</em> section, for more information.</p>
    <p class="normal">In November 2022, Spring Boot 3.0 was released. It is based on Spring Framework 6.0 and Jakarta EE 9, also being compatible with Jakarta EE 10. Java 17, the current <strong class="keyWord">long-term support </strong>(<strong class="keyWord">LTS</strong>) release, is<a id="_idIndexMarker112"/> required as the minimum Java version.</p>
    <p class="normal">Finally, we will use <strong class="keyWord">Docker</strong> to run our microservices as containers. This will allow us to start and stop our microservice landscape, including database servers and a message broker, with a single command.</p>
    <p class="normal">That’s a lot of technologies and frameworks, so let’s go through each of them briefly to see what they are about!</p>
    <p class="normal">In this chapter, we will introduce the following open source projects:</p>
    <ul>
      <li class="bulletList">Spring Boot</li>
    </ul>
    <p class="normal">(This section also includes an overview of what’s new in v3.0 and on how to migrate v2 applications.)</p>
    <ul>
      <li class="bulletList">Spring WebFlux</li>
      <li class="bulletList"><code class="inlineCode">springdoc-openapi</code></li>
      <li class="bulletList">Spring Data</li>
      <li class="bulletList">Spring Cloud Stream</li>
      <li class="bulletList">Docker</li>
    </ul>
    <div class="packt_tip">
      <p class="normal">More details about each product will be provided in upcoming chapters.</p>
    </div>
    <h1 id="_idParaDest-65" class="heading-1">Technical requirements</h1>
    <p class="normal">This chapter does not contain any source code that can be downloaded, nor does it require any tools to be installed.</p>
    <h1 id="_idParaDest-66" class="heading-1">Spring Boot</h1>
    <p class="normal">Spring Boot, and the<a id="_idIndexMarker113"/> Spring Framework that Spring Boot is based on, is a great framework for developing microservices in Java.</p>
    <p class="normal">When the Spring Framework v1.0 was released back in 2004, one of its main goals was to address the overly complex <strong class="keyWord">J2EE</strong> standard (short for <strong class="keyWord">Java 2 Platform, Enterprise Edition</strong>) with its <a id="_idIndexMarker114"/>infamous and heavyweight deployment descriptors. The Spring Framework provided a much more lightweight development model based on the concept of <strong class="keyWord">dependency injection</strong>. The <a id="_idIndexMarker115"/>Spring Framework also used far more lightweight XML configuration files compared to the deployment descriptors in J2EE.</p>
    <div class="note">
      <p class="normal">To make things even worse with the J2EE standard, the heavyweight deployment descriptors actually came in two types:</p>
      <ul>
        <li class="bulletList">Standard deployment descriptors, describing the configuration in a standardized way</li>
        <li class="bulletList">Vendor-specific deployment descriptors, mapping the configuration to vendor-specific features in the vendor’s application server</li>
      </ul>
    </div>
    <p class="normal">In 2006, J2EE was renamed <strong class="keyWord">Java EE,</strong> short for<strong class="keyWord"> Java Platform, Enterprise Edition</strong>. In 2017, Oracle<a id="_idIndexMarker116"/> submitted Java EE to the Eclipse Foundation. In February 2018, Java EE was renamed Jakarta EE. The new name, Jakarta EE, also affects the names of the Java packages defined by the standard, requiring developers to perform package renaming when upgrading to Jakarta EE, as described in the <em class="italic">Migrating a Spring Boot 2 application</em> section. Over the years, while the Spring Framework gained increasing popularity, the functionality in the Spring Framework grew significantly. Slowly, the burden of setting up a Spring application using the no-longer-so-lightweight XML configuration file became a problem.</p>
    <p class="normal">In 2014, Spring Boot v1.0 was released, addressing these problems!</p>
    <h2 id="_idParaDest-67" class="heading-2">Convention over configuration and fat JAR files</h2>
    <p class="normal">Spring Boot<a id="_idIndexMarker117"/> targets the fast development of production-ready Spring applications by being strongly opinionated about how to set up both core modules from the Spring Framework and third-party products, such as libraries that are used for logging or connecting to a database. Spring Boot does that by applying a number of conventions by default, minimizing the need for<a id="_idIndexMarker118"/> configuration. Whenever required, each convention can be overridden by writing some configuration, case by case. This design pattern is known as <strong class="keyWord">convention over configuration</strong> and minimizes the need for initial configuration.</p>
    <div class="note">
      <p class="normal">Configuration, when required, is, in my opinion, written best using Java and annotations. The good old XML-based configuration files can still be used, although they are significantly smaller than before Spring Boot was introduced.</p>
    </div>
    <p class="normal">Added to the usage of <a id="_idIndexMarker119"/>convention over configuration, Spring Boot also favors a runtime model based on a standalone JAR file, also known as a <strong class="keyWord">fat JAR file</strong>. Before Spring Boot, the most common way to run a Spring application was to deploy it as a WAR file on a Java EE web server, such as Apache Tomcat. WAR file deployment is still supported by Spring Boot.</p>
    <div class="note">
      <p class="normal">A fat JAR file contains not only the classes and resource files of the application itself but also all the JAR files the application depends on. This means that the fat JAR file is the only JAR file required to run the application; that is, we only need to transfer one JAR file to an environment where we want to run the application instead of transferring the application’s JAR file along with all the JAR files the application depends on.</p>
    </div>
    <p class="normal">Starting a fat JAR<a id="_idIndexMarker120"/> requires no separately installed Java EE web server, such as Apache Tomcat. Instead, it can be started with a simple command such as <code class="inlineCode">java -jar app.jar</code>, making it a perfect choice for running in a Docker container! If the Spring Boot application, for example, uses HTTP to expose a REST API, it will also contain an embedded web server.</p>
    <h2 id="_idParaDest-68" class="heading-2">Code examples for setting up a Spring Boot application</h2>
    <p class="normal">To better<a id="_idIndexMarker121"/> understand what this means, let’s look<a id="_idIndexMarker122"/> at some source code examples.</p>
    <div class="packt_tip">
      <p class="normal">We will only look at some small fragments of code here to point out the main features. For a fully working example, you’ll have to wait until the next chapter!</p>
    </div>
    <h3 id="_idParaDest-69" class="heading-3">The magic @SpringBootApplication annotation</h3>
    <p class="normal">The convention-based autoconfiguration mechanism can be initiated by annotating the<a id="_idIndexMarker123"/> application class (that is, the class that contains the static <code class="inlineCode">main</code> method) with the <code class="inlineCode">@SpringBootApplication</code> annotation. The following code shows this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-meta-slc">@SpringBootApplication</strong></span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyApplication</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title">main</span>(<span class="hljs-built_in">String</span><span class="hljs-params">[] args</span>) {
    <span class="hljs-title">SpringApplication</span>.<span class="hljs-title">run</span>(<span class="hljs-title">MyApplication</span>.<span class="hljs-property">class</span>, args);
  }
}
</code></pre>
    <p class="normal">The following functionality will be provided by this annotation:</p>
    <ul>
      <li class="bulletList">It enables component scanning, that is, looking for Spring components and configuration classes in the package of the application class and all its sub-packages.</li>
      <li class="bulletList">The application class itself becomes a configuration class.</li>
      <li class="bulletList">It enables autoconfiguration, where Spring Boot looks for JAR files in the classpath that it can configure automatically. For example, if you have Tomcat in the classpath, Spring Boot will automatically configure Tomcat as an<a id="_idIndexMarker124"/> embedded web server.</li>
    </ul>
    <h3 id="_idParaDest-70" class="heading-3">Component scanning</h3>
    <p class="normal">Let’s assume we<a id="_idIndexMarker125"/> have the following Spring component in the package of the application class (or in one of its sub-packages):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyComponentImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyComponent</span> { ...
</code></pre>
    <p class="normal">Another component in the application can get this component automatically injected, also known as <strong class="keyWord">auto-wired</strong>, using the <code class="inlineCode">@Autowired</code> annotation:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AnotherComponent</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MyComponent myComponent;
  <span class="code-highlight"><strong class="hljs-meta-slc">@Autowired</strong></span>
  <span class="hljs-keyword">public</span> <span class="hljs-title">AnotherComponent</span><span class="hljs-params">(MyComponent myComponent)</span> {
    <span class="hljs-built_in">this</span>.myComponent = myComponent;
  }
</code></pre>
    <div class="packt_tip">
      <p class="normal">I prefer using constructor injection (over field and setter injection) to keep the state in my components immutable. An immutable state is important if you want to be able to run the component in a multithreaded runtime environment.</p>
    </div>
    <p class="normal">If we want to use components that are declared in a package outside the application’s package, for example, a utility component shared by multiple Spring Boot applications, we can complement the <code class="inlineCode">@SpringBootApplication</code> annotation in the<a id="_idIndexMarker126"/> application class with a <code class="inlineCode">@ComponentScan</code> annotation:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> se.magnus.myapp;
<span class="hljs-meta">@SpringBootApplication</span>
<span class="code-highlight"><strong class="hljs-meta-slc">@ComponentScan</strong></span><span class="hljs-meta">({"se.magnus.myapp",</span><span class="code-highlight"><strong class="hljs-meta-slc">"se.magnus.util" </strong></span><span class="hljs-meta">})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyApplication</span> {
</code></pre>
    <p class="normal">We can now auto-wire components from the <code class="inlineCode">se.magnus.util</code> package in the application code, for example, a utility component named <code class="inlineCode">MyUtility</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> se.magnus.util;
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="code-highlight"><strong class="hljs-title-slc">MyUtility</strong></span> { ...
</code></pre>
    <p class="normal">This utility component can be auto-wired in an application component like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">package</span> se.magnus.myapp.services;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AnotherComponent</span> {
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MyUtility myUtility;
 <span class="hljs-meta">@Autowired</span>
 <span class="hljs-keyword">public</span> <span class="hljs-title">AnotherComponent</span><span class="hljs-params">(</span><span class="code-highlight"><strong class="hljs-params-slc">MyUtility</strong></span><span class="hljs-params"> myUtility)</span> {
   <span class="hljs-built_in">this</span>.myUtility = myUtility;
 }
</code></pre>
    <h3 id="_idParaDest-71" class="heading-3">Java-based configuration</h3>
    <p class="normal">If we want to override Spring Boot’s default configuration or we want to add our own configuration, we can simply annotate a class with <code class="inlineCode">@Configuration</code> and it will be picked up by <a id="_idIndexMarker127"/>the component scanning mechanism we described previously.</p>
    <p class="normal">For example, if we want to set up a filter in the processing of HTTP requests (handled by Spring WebFlux, which is described in the following section) that writes a log message at the beginning and the end of the processing, we can configure a log filter, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-meta-slc">@Configuration</strong></span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberApplication</span> {
  <span class="hljs-meta">@Bean</span>
  <span class="hljs-keyword">public</span> <span class="code-highlight"><strong class="hljs-slc">Filter </strong><strong class="hljs-title-slc">logFilter</strong><strong class="hljs-params-slc">()</strong></span> {
    <span class="hljs-type">CommonsRequestLoggingFilter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> 
        <span class="hljs-title">CommonsRequestLoggingFilter</span>();
    filter.setIncludeQueryString(<span class="hljs-literal">true</span>);
    filter.setIncludePayload(<span class="hljs-literal">true</span>);
    filter.setMaxPayloadLength(<span class="hljs-number">5120</span>);
    <span class="hljs-keyword">return</span> filter;
  }
</code></pre>
    <div class="packt_tip">
      <p class="normal">We can also place the configuration directly in the application class since the <code class="inlineCode">@SpringBootApplication</code> annotation implies the <code class="inlineCode">@Configuration</code> annotation.</p>
    </div>
    <p class="normal">That’s all for now <a id="_idIndexMarker128"/>about Spring Boot, but before moving to the next component, let’s see what is new in Spring Boot 3.0 and how to migrate a Spring Boot 2 application.</p>
    <h2 id="_idParaDest-72" class="heading-2">What’s new in Spring Boot 3.0</h2>
    <p class="normal">For the scope of this<a id="_idIndexMarker129"/> book, the most important new items in Spring Boot 3.0 are the following:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Observability</strong>
        <p class="normal">Spring Boot 3.0 comes<a id="_idIndexMarker130"/> with improved support for observability, adding built-in support for distributed tracing to the already existing support for metrics and logging in previous Spring Boot releases. The new distributed tracing support is based on a new Observability API in Spring Framework v6.0 and a new module named Micrometer Tracing. Micrometer Tracing is based on Spring Cloud Sleuth, which is now deprecated. <em class="chapterRef">Chapter 14</em>, <em class="italic">Understand Distributed Tracing</em>, covers how to use the new support for observability and distributed tracing.</p>
      </li>
    </ul>
    <ul>
      <li class="bulletList"><strong class="keyWord">Native compilation</strong>
        <p class="normal">Spring Boot 3.0 also comes<a id="_idIndexMarker131"/> with support for compiling Spring Boot applications to native images, which are standalone executable files. A native-compiled Spring<a id="_idIndexMarker132"/> Boot application starts significantly faster and consumes less memory. <em class="chapterRef">Chapter 23</em>, <em class="italic">Native-Compiled Java Microservices</em>, describes how to native compile microservices based on Spring Boot.</p>
      </li>
    </ul>
    <ul>
      <li class="bulletList"><strong class="keyWord">Virtual threads</strong>
        <p class="normal">Finally, Spring Boot 3.0 comes with support for lightweight threads called virtual threads from<a id="_idIndexMarker133"/> the OpenJDK Project Loom. Virtual threads are expected <a id="_idIndexMarker134"/>to simplify the programming model for developing reactive non-blocking microservices, for example, compared to the programming model used in Project Reactor and various Spring components. Virtual threads are currently only available as a preview in Java 19. They also currently lack support for composability features, for example, required to build microservices that concurrently aggregate information from other microservices. Therefore, virtual threads will not be covered in this book. <em class="chapterRef">Chapter 7</em>, <em class="italic">Developing Reactive Microservices</em>,<em class="italic"> </em>covers how virtual threads can be implemented using Project Reactor and Spring WebFlux.</p>
      </li>
    </ul>
    <h2 id="_idParaDest-73" class="heading-2">Migrating a Spring Boot 2 application</h2>
    <p class="normal">If you already have applications based on Spring Boot 2, you might be interested in understanding <a id="_idIndexMarker135"/>what it takes to migrate to Spring Boot 3.0. Here is a list of actions you need to take:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Pivotal recommends first upgrading Spring Boot 2 applications to the latest v2.7.x release since their migration guide assumes you are on v2.7.</li>
      <li class="numberedList">Ensure you have Java 17 or later installed, both in your development and runtime environments. If your Spring Boot applications are deployed as Docker containers, you need to ensure that your company approves the usage of Docker images based on Java 17 or newer releases.</li>
      <li class="numberedList">Remove calls to deprecated methods in Spring Boot 2.x. All deprecated methods are removed in Spring Boot 3.0, so you must ensure that your application does not call any of these methods. To see exactly where calls are being made in your application, you can enable the <code class="inlineCode">lint:deprecation</code> flag in the Java compiler using (assuming the use of Gradle):
        <pre class="programlisting code"><code class="hljs-code">tasks<span class="hljs-selector-class">.withType</span>(JavaCompile) {
    options<span class="hljs-selector-class">.compilerArgs</span> += <span class="hljs-selector-attr">[</span><span class="hljs-string">'-Xlint:deprecation'</span><span class="hljs-selector-attr">]</span>
}
</code></pre>
      </li>
      <li class="numberedList">Rename all imports of <code class="inlineCode">javax</code> packages that are now part of Jakarta EE to <code class="inlineCode">jakarta</code>. </li>
      <li class="numberedList">For libraries that are not managed by Spring, you need to ensure that you are using <a id="_idIndexMarker136"/>versions that are Jakarta compliant, that is, using <code class="inlineCode">jakarta</code> packages.</li>
      <li class="numberedList">For breaking changes and other important migration information, read through: <p class="normal"><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide"><span class="url">https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide</span></a></p>
        <p class="normal"><a href="https://docs.spring.io/spring-security/reference/migration/index.html"><span class="url">https://docs.spring.io/spring-security/reference/migration/index.html</span></a></p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Ensure that you have end-to-end black-box tests that verify the functionality of your application. Run these tests before and after the migration to ensure that the application’s functionality has not been affected by the migration.</li>
    </ol>
    <p class="normal">When migrating the source code of the previous edition of this book to Spring Boot 3.0, the most time-consuming part was figuring out how to handle breaking changes in the Spring Security configuration; see <em class="chapterRef">Chapter 11</em>, <em class="italic">Securing Access to APIs</em>, for details. As an example, the following configuration of the authorization server in the previous edition needed to be updated:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Bean</span>
SecurityFilterChain <span class="hljs-title">defaultSecurityFilterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception {
  http
    .authorizeRequests(authorizeRequests -&gt; authorizeRequests
      .antMatchers(<span class="hljs-string">"</span><span class="hljs-string">/actuator/**"</span>).permitAll()
</code></pre>
    <p class="normal">This configuration looks like the following with Spring Boot 3.0:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Bean</span>
SecurityFilterChain <span class="hljs-title">defaultSecurityFilterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception {
  http
    .authorizeHttpRequests(authorizeRequests -&gt; authorizeRequests
      .requestMatchers(<span class="hljs-string">"/actuator/**"</span>).permitAll()
</code></pre>
    <p class="normal">The end-to-end test script, <code class="inlineCode">test-em-all.bash</code>, that comes with each chapter turned out to be indispensable in verifying that the functionality was unaffected after the migration <a id="_idIndexMarker137"/>of each chapter.</p>
    <p class="normal">Now that we have learned about Spring Boot, let’s talk about Spring WebFlux.</p>
    <h1 id="_idParaDest-74" class="heading-1">Spring WebFlux</h1>
    <p class="normal">Spring Boot 3.0 is based<a id="_idIndexMarker138"/> on the Spring Framework 6.0, which has built-in support for developing reactive applications. The Spring Framework <a id="_idIndexMarker139"/>uses <strong class="keyWord">Project Reactor</strong> as the base implementation of its reactive support and also comes with a new web framework, <strong class="keyWord">Spring WebFlux</strong>, which <a id="_idIndexMarker140"/>supports the development of reactive, that is, non-blocking, HTTP clients and services.</p>
    <p class="normal">Spring WebFlux supports two different programming models:</p>
    <ul>
      <li class="bulletList">An annotation-based imperative style, similar to the already existing web framework, Spring Web MVC, but with support for reactive services</li>
      <li class="bulletList">A new function-oriented model based on routers and handlers</li>
    </ul>
    <p class="normal">In this book, we will use the annotation-based imperative style to demonstrate how easy it is to move REST services from Spring Web MVC to Spring WebFlux and then start to refactor the services so that they become fully reactive.</p>
    <p class="normal">Spring WebFlux also provides a fully reactive HTTP client, <code class="inlineCode">WebClient</code>, as a complement to the existing <code class="inlineCode">RestTemplate</code> client.</p>
    <p class="normal">Spring WebFlux supports running on a servlet container based on the Jakarta Servlet specification v5.0 or higher, such as Apache Tomcat, but also supports reactive non-servlet-based <a id="_idIndexMarker141"/>embedded web servers such as Netty (<a href="https://netty.io/"><span class="url">https://netty.io/</span></a>).</p>
    <div class="packt_tip">
      <p class="normal">The Servlet specification is a specification in the Java EE platform that standardizes how to develop Java applications that communicate using web protocols such as HTTP.</p>
    </div>
    <h2 id="_idParaDest-75" class="heading-2">Code examples of setting up a REST service</h2>
    <p class="normal">Before we can<a id="_idIndexMarker142"/> create a REST service based on Spring WebFlux, we need to add Spring WebFlux (and the dependencies that<a id="_idIndexMarker143"/> Spring WebFlux requires) to the classpath for Spring Boot to be detected and configured during startup. Spring Boot provides a large number of convenient <strong class="keyWord">starter dependencies</strong> that<a id="_idIndexMarker144"/> bring in a specific feature, together with the dependencies each feature normally requires. So, let’s use the starter dependency for Spring WebFlux and then see what a simple REST service looks like!</p>
    <h3 id="_idParaDest-76" class="heading-3">Starter dependencies</h3>
    <p class="normal">In this book, we will use Gradle as our build tool, so the Spring WebFlux starter dependency will be<a id="_idIndexMarker145"/> added to the <code class="inlineCode">build.gradle</code> file. It looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">implementation</span><span class="hljs-params">(</span><span class="hljs-string">'org.springframework.boot:spring-boot-starter-webflux'</span><span class="hljs-params">)</span>
</code></pre>
    <div class="packt_tip">
      <p class="normal">You might be wondering why we don’t specify a version number. We will talk about that when we look at a complete example in <em class="chapterRef">Chapter 3</em>, <em class="italic">Creating a Set of Cooperating Microservices</em>!</p>
    </div>
    <p class="normal">When the microservice is started up, Spring Boot will detect Spring WebFlux on the classpath and configure it, as well as other things such as starting up an embedded web server. Spring WebFlux uses Netty by default, which we can see from the log output:</p>
    <pre class="programlisting con"><code class="hljs-con">2023-03-09 15:23:43.592 INFO 17429 --- [ main] o.s.b.web.embedded.netty.NettyWebServer : Netty started on port(s): 8080
</code></pre>
    <p class="normal">If we want to switch from Netty to Tomcat as our embedded web server, we can override the default configuration by excluding Netty from the starter dependency and adding the starter dependency for Tomcat:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">implementation</span><span class="hljs-params">('org.springframework.boot:spring-boot-starter-webflux')</span> 
{
 <span class="code-highlight"><strong class="hljs-slc">exclude</strong></span> group: 'org<span class="hljs-selector-class">.springframework</span>.boot', module: <span class="code-highlight"><strong class="hljs-slc">'spring-boot-</strong></span>
<span class="code-highlight"><strong class="hljs-slc"> starter-reactor-netty'</strong></span>
}
<span class="code-highlight"><strong class="hljs-title-slc">implementation</strong></span><span class="hljs-params">('org.springframework.boot:</span><span class="code-highlight"><strong class="hljs-params-slc">spring-boot-starter-tomcat'</strong></span><span class="hljs-params">)</span>
</code></pre>
    <p class="normal">After restarting the<a id="_idIndexMarker146"/> microservice, we can see that Spring Boot picked Tomcat instead:</p>
    <pre class="programlisting con"><code class="hljs-con">2023-03-09 18:23:44.182 INFO 17648 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http)
</code></pre>
    <h3 id="_idParaDest-77" class="heading-3">Property files</h3>
    <p class="normal">As you can see from the preceding examples, the web server is started up using port <code class="inlineCode">8080</code>. If you want to change the port, you can override the default value using a property file. Spring Boot application property files can either be a <code class="inlineCode">.properties</code> file or a YAML file. By default, they are named <code class="inlineCode">application.properties</code> and <code class="inlineCode">application.yml</code>, respectively.</p>
    <p class="normal">In this book, we will use <a id="_idIndexMarker147"/>YAML files so that the HTTP port used by the embedded web server can be changed to, for example, <code class="inlineCode">7001</code>. By doing this, we can avoid port collisions with other microservices running on the same server. To do this, we can add the following line to the <code class="inlineCode">application.yml</code> file:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">server.port:</span> <span class="hljs-number">7001</span>
</code></pre>
    <div class="packt_tip">
      <p class="normal">When we begin to develop our microservices as containers in <em class="chapterRef">Chapter 4</em>, <em class="italic">Deploying Our Microservices Using Docker</em>, port collisions will no longer be a problem. Each container has its own hostname and port range, so all microservices can use, for example, port <code class="inlineCode">8080</code> without colliding with each other.</p>
    </div>
    <h3 id="_idParaDest-78" class="heading-3">Sample RestController</h3>
    <p class="normal">Now, with Spring WebFlux and an embedded web server of our choice in place, we can write a <a id="_idIndexMarker148"/>REST service in the same way as when using Spring MVC, that is, as a <code class="inlineCode">RestController</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-meta-slc">@RestController</strong></span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyRestService</span> {
  <span class="code-highlight"><strong class="hljs-meta-slc">@GetMapping</strong></span><span class="hljs-meta">(value = "/my-resource", produces = "application/json")</span>
  List&lt;Resource&gt; <span class="hljs-title">listResources</span><span class="hljs-params">()</span> {
    …
  }
</code></pre>
    <p class="normal">The <code class="inlineCode">@GetMapping</code> annotation on the <code class="inlineCode">listResources()</code> method will map the Java method to an HTTP <code class="inlineCode">GET</code> API on the <code class="inlineCode">host:8080/myResource</code> URL. The return value of the <code class="inlineCode">List&lt;Resource&gt;</code> type will be converted into JSON.</p>
    <p class="normal">Now that we’ve talked about Spring WebFlux, let’s see how we can document the APIs we develop using Spring WebFlux.</p>
    <h1 id="_idParaDest-79" class="heading-1">springdoc-openapi</h1>
    <p class="normal">One very important <a id="_idIndexMarker149"/>aspect of developing APIs, for example, RESTful services, is how to document them so that they are easy to use. The Swagger specification from SmartBear Software is one of the most widely used ways of documenting RESTful services. Many leading API gateways have native support for exposing the documentation of RESTful services using the Swagger specification.</p>
    <p class="normal">In 2015, SmartBear Software donated the Swagger specification to the Linux Foundation under the <strong class="keyWord">OpenAPI Initiative</strong> and created the <strong class="keyWord">OpenAPI Specification</strong>. The name Swagger is still used for the tooling provided by SmartBear Software.</p>
    <p class="normal"><code class="inlineCode">springdoc-openapi</code> is an open source project, separate from the Spring Framework, that can create OpenAPI-based API documentation at runtime. It does so by examining the application, for example, inspecting WebFlux and Swagger-based annotations.</p>
    <p class="normal">We will look at full source code examples in upcoming chapters, but for now, the following condensed <a id="_idIndexMarker150"/>screenshot (removed parts are marked with “<strong class="keyWord">…</strong>”) of a sample API documentation will do:</p>
    <figure class="mediaobject"><img src="../Images/B19825_02_01.png" alt="Graphical user interface, application, Teams  Description automatically generated" width="872" height="674"/></figure>
    <p class="packt_figref">Figure 2.1: Sample API documentation visualized using Swagger UI</p>
    <div class="note">
      <p class="normal">Note the big <strong class="screenText">Execute</strong> button, which can be used to actually try out the API, not just read its documentation!</p>
    </div>
    <p class="normal"><code class="inlineCode">springdoc-openapi</code> helps us to document the APIs exposed by our microservices. Now, let’s move on to Spring Data.</p>
    <h1 id="_idParaDest-80" class="heading-1">Spring Data</h1>
    <p class="normal">Spring Data comes with a common programming model for persisting data in various types <a id="_idIndexMarker151"/>of database engines, ranging from traditional relational databases (SQL databases) to various types of NoSQL database engines, such as document databases (for example, MongoDB), key-value databases (for example, Redis), and graph databases (for example, Neo4j).</p>
    <p class="normal">The Spring Data project is divided into several subprojects, and in this book, we will use Spring Data subprojects for MongoDB and JPA that have been mapped to a MySQL database.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">JPA</strong> stands for <strong class="keyWord">Jakarta Persistence API</strong> and is a Java specification about how to handle<a id="_idIndexMarker152"/> relational data. Please go to <a href="https://jakarta.ee/specifications/persistence/"><span class="url">https://jakarta.ee/specifications/persistence/</span></a> for the latest specifications. Jakarta EE 9 is based on Jakarta Persistence 3.0.</p>
    </div>
    <p class="normal">The two core concepts of the programming model in Spring Data are <strong class="keyWord">entities</strong> and <strong class="keyWord">repositories</strong>. Entities and repositories generalize how data is stored and accessed from the various types of databases. They provide a common abstraction but still support adding database-specific behavior to the entities and repositories. These two core concepts are briefly explained together with some illustrative code examples as we proceed through this chapter. Remember that more details will be provided in the upcoming chapters!</p>
    <div class="note">
      <p class="normal">Even though Spring Data provides a common programming model for different types of databases, this doesn’t mean that you will be able to write portable source code. For example, switching the database technology from a SQL database to a NoSQL database will, in general, not be possible without some changes in the source code!</p>
    </div>
    <h2 id="_idParaDest-81" class="heading-2">Entity</h2>
    <p class="normal">An entity describes the<a id="_idIndexMarker153"/> data that will be stored by Spring Data. Entity classes are, in general, annotated<a id="_idIndexMarker154"/> with a mix of generic Spring Data annotations and annotations that are specific to each database technology.</p>
    <p class="normal">For example, an entity that will be stored in a relational database can be annotated with JPA annotations such as the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> jakarta.persistence.Entity;
<span class="hljs-keyword">import</span> jakarta.persistence.Id;
<span class="hljs-keyword">import</span> jakarta.persistence.IdClass;
<span class="hljs-keyword">import</span> jakarta.persistence.Table;
<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@IdClass(ReviewEntityPK.class)</span>
<span class="hljs-meta">@Table(name = "review")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ReviewEntity</span> {
 <span class="hljs-meta">@Id</span> <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> productId;
 <span class="hljs-meta">@Id</span> <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> reviewId;
 <span class="hljs-keyword">private</span> String author;
 <span class="hljs-keyword">private</span> String subject;
 <span class="hljs-keyword">private</span> String content;
</code></pre>
    <p class="normal">If an entity is to be <a id="_idIndexMarker155"/>stored in a MongoDB database, annotations from the Spring Data MongoDB subproject can be used together with generic Spring Data annotations. For example, consider the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> org.springframework.data.annotation.Id;
<span class="hljs-keyword">import</span> org.springframework.data.annotation.Version;
<span class="hljs-keyword">import</span> org.springframework.data.mongodb.core.mapping.Document;
<span class="hljs-meta">@Document</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RecommendationEntity</span> {
    <span class="hljs-meta">@Id</span>
    <span class="hljs-keyword">private</span> String id;
    <span class="hljs-meta">@Version</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> version;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> productId;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> recommendationId;
    <span class="hljs-keyword">private</span> String author;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> rate;
    <span class="hljs-keyword">private</span> String content;
</code></pre>
    <p class="normal">The <code class="inlineCode">@Id</code> and <code class="inlineCode">@Version</code> annotations are generic annotations, while the <code class="inlineCode">@Document</code> annotation is specific<a id="_idIndexMarker156"/> to the Spring Data MongoDB subproject.</p>
    <div class="packt_tip">
      <p class="normal">This can be revealed by studying the <code class="inlineCode">import</code> statements; the <code class="inlineCode">import</code> statements that contain <code class="inlineCode">mongodb</code> come from the Spring Data MongoDB subproject.</p>
    </div>
    <h2 id="_idParaDest-82" class="heading-2">Repositories</h2>
    <p class="normal">Repositories are used to <a id="_idIndexMarker157"/>store and access data from different types <a id="_idIndexMarker158"/>of databases. In its most basic form, a repository can be declared as a Java interface, and Spring Data will generate its implementation on the fly using opinionated conventions. These conventions can be overridden and/or complemented by additional configuration and, if required, some Java code. </p>
    <p class="normal">Spring Data also comes with some base Java interfaces, for example, <code class="inlineCode">CrudRepository</code>, to make the definition of a repository even simpler. The base interface, <code class="inlineCode">CrudRepository</code>, provides us with standard methods for <code class="inlineCode">create</code>, <code class="inlineCode">read</code>, <code class="inlineCode">update</code>, and <code class="inlineCode">delete</code> operations.</p>
    <p class="normal">To specify a repository for handling the JPA entity <code class="inlineCode">ReviewEntity</code>, we only need to declare the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> org.springframework.data.repository.CrudRepository;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ReviewRepository</span> <span class="hljs-keyword">extends</span> 
  <span class="hljs-title">CrudRepository</span>&lt;<span class="code-highlight"><strong class="hljs-slc">ReviewEntity</strong></span>, <span class="code-highlight"><strong class="hljs-slc">ReviewEntityPK</strong></span>&gt; {
  
  Collection&lt;ReviewEntity&gt; <span class="code-highlight"><strong class="hljs-title-slc">findByProductId</strong></span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId)</span>;
}
</code></pre>
    <p class="normal">In this example we use a class, <code class="inlineCode">ReviewEntityPK</code>, to describe a composite primary key. It looks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="code-highlight"><strong class="hljs-title-slc">ReviewEntityPK</strong></span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> productId;
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> reviewId;
}
</code></pre>
    <p class="normal">We have also added an extra method, <code class="inlineCode">findByProductId</code>, which allows us to look up <code class="inlineCode">Review</code> entities based on <code class="inlineCode">productid</code> – a field that is part of the primary key. The naming of the method follows a naming convention defined by Spring Data that allows Spring Data to<a id="_idIndexMarker159"/> generate the implementation of this method on the fly as well.</p>
    <p class="normal">If we want to use the repository, we can simply inject it and then start to use it, for example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReviewRepository repository;
<span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">public</span> <span class="hljs-title">ReviewService</span><span class="hljs-params">(ReviewRepository repository)</span> {
 <span class="hljs-built_in">this</span>.repository = repository;
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">someMethod</span><span class="hljs-params">()</span> {
  repository.save(entity);
  repository.delete(entity);
  repository.findByProductId(productId);
</code></pre>
    <p class="normal">Added to the <code class="inlineCode">CrudRepository</code> interface, Spring Data also provides a reactive base interface, <code class="inlineCode">ReactiveCrudRepository</code>, which enables reactive repositories. The methods in this interface <a id="_idIndexMarker160"/>do not return objects or collections of objects; instead, they return <strong class="keyWord">Mono</strong> and <strong class="keyWord">Flux</strong> objects. <code class="inlineCode">Mono</code> and <code class="inlineCode">Flux</code> objects are, as we will see in <em class="chapterRef">Chapter 7</em>, <em class="italic">Developing Reactive Microservices</em>, reactive streams that are capable of returning either <code class="inlineCode">0...1</code> or <code class="inlineCode">0...m</code> entities as they become available on the stream. </p>
    <p class="normal">The reactive-based interface can only be used by Spring Data subprojects that support reactive database drivers; that is, they are based on non-blocking I/O. The Spring Data MongoDB subproject supports reactive repositories, while Spring Data JPA does not.</p>
    <p class="normal">Specifying a reactive repository for handling the MongoDB entity, <code class="inlineCode">RecommendationEntity</code>, as described previously, might look something like the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> org.springframework.data.repository.reactive.ReactiveCrudRepository;
<span class="hljs-keyword">import</span> reactor.core.publisher.Flux;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">RecommendationRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReactiveCrudRepository</span>&lt;<span class="code-highlight"><strong class="hljs-slc">RecommendationEntity</strong></span>, String&gt; {
    Flux&lt;RecommendationEntity&gt; <span class="hljs-title">findByProductId</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> productId)</span>;
}
</code></pre>
    <p class="normal">This concludes the section on Spring Data. Now let’s see how we can use Spring Cloud Stream to<a id="_idIndexMarker161"/> develop message-based asynchronous services.</p>
    <h1 id="_idParaDest-83" class="heading-1">Spring Cloud Stream</h1>
    <p class="normal">We will not focus on<a id="_idIndexMarker162"/> Spring Cloud in this part; we will do that in <em class="italic">Part 2</em> of the book, from <em class="italic">Chapter 8</em>, <em class="italic">Introduction to Spring Cloud,</em> to <em class="italic">Chapter 14</em>, <em class="italic">Understanding Distributed Tracing</em>. However, we will bring in one of the modules that’s part of Spring Cloud: <strong class="keyWord">Spring Cloud Stream</strong>. Spring Cloud Stream provides a streaming abstraction over messaging, based on the <strong class="keyWord">publish and subscribe</strong> integration pattern. Spring Cloud Stream currently comes with built-in support for Apache Kafka and RabbitMQ. A number of separate projects exist that provide integration with other popular messaging systems. See <a href="https://github.com/spring-cloud?q=binder"><span class="url">https://github.com/spring-cloud?q=binder</span></a> for more details.</p>
    <p class="normal">The core concepts in Spring Cloud Stream are as follows:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Message</strong>: A data <a id="_idIndexMarker163"/>structure that’s used to describe data sent to and received from a messaging system.</li>
      <li class="bulletList"><strong class="keyWord">Publisher</strong>: Sends <a id="_idIndexMarker164"/>messages to the messaging<a id="_idIndexMarker165"/> system, also known as a <strong class="keyWord">Supplier</strong>.</li>
      <li class="bulletList"><strong class="keyWord">Subscriber</strong>: Receives<a id="_idIndexMarker166"/> messages from the messaging<a id="_idIndexMarker167"/> system, also known as a <strong class="keyWord">Consumer</strong>.</li>
      <li class="bulletList"><strong class="keyWord">Destination</strong>: Used to communicate with the messaging system. Publishers use output <a id="_idIndexMarker168"/>destinations and subscribers use input destinations. Destinations are mapped by the specific binders to queues and topics in the underlying messaging system.</li>
      <li class="bulletList"><strong class="keyWord">Binder</strong>: A binder<a id="_idIndexMarker169"/> provides the actual integration with a specific messaging system, similar to what a JDBC driver does for a specific type of database.</li>
    </ul>
    <p class="normal">The actual messaging system to be used is determined at runtime, depending on what is found on the classpath. Spring Cloud Stream comes with opinionated conventions on how to handle messaging. These conventions can be overridden by specifying a configuration for messaging features such as consumer groups, partitioning, persistence, durability, and error handling; for example, retries and dead letter queue handling.</p>
    <h2 id="_idParaDest-84" class="heading-2">Code examples for sending and receiving messages</h2>
    <p class="normal">To better <a id="_idIndexMarker170"/>understand how all this fits together, let’s look at some source code examples.</p>
    <p class="normal">Spring Cloud Stream comes with two programming models: one older and nowadays deprecated model based on the use of annotations (for example, <code class="inlineCode">@EnableBinding</code>, <code class="inlineCode">@Output</code>, and <code class="inlineCode">@StreamListener</code>) and one newer model based on writing functions. In this book, we will use functional implementations.</p>
    <p class="normal">To implement a publisher, we only need to implement the <code class="inlineCode">java.util.function.Supplier</code> functional interface as a Spring Bean. For example, the following is a publisher that publishes messages as a String:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> <span class="code-highlight"><strong class="hljs-slc">Supplier</strong></span>&lt;String&gt; <span class="hljs-title">myPublisher</span><span class="hljs-params">()</span> {
   <span class="hljs-keyword">return</span> () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title">Date</span>().toString();
}
</code></pre>
    <p class="normal">A subscriber is implemented as a Spring Bean implementing the <code class="inlineCode">java.util.function.Consumer</code> functional interface. For example, the following is a subscriber that consumes messages as Strings:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> <span class="code-highlight"><strong class="hljs-slc">Consumer</strong></span>&lt;String&gt; <span class="hljs-title">mySubscriber</span><span class="hljs-params">()</span> {
   <span class="hljs-keyword">return</span> s -&gt; System.out.println(<span class="hljs-string">"ML RECEIVED: "</span> + s);
}
</code></pre>
    <p class="normal">It is also possible to define a Spring Bean that processes messages, meaning that it both consumes and publishes messages. This can be done by implementing the <code class="inlineCode">java.util.function.Function</code> functional interface. For example, a Spring Bean that consumes incoming messages and publishes a new message after some processing (both messages are Strings in this example):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> <span class="code-highlight"><strong class="hljs-slc">Function</strong></span>&lt;String, String&gt; <span class="hljs-title">myProcessor</span><span class="hljs-params">()</span> {
   <span class="hljs-keyword">return</span> s -&gt; <span class="hljs-string">"ML PROCESSED: "</span> + s;
}
</code></pre>
    <p class="normal">To make Spring Cloud Stream aware of these functions, we need to declare them using the <code class="inlineCode">spring.cloud.function.definition</code> configuration property. For example, for the three functions defined previously, this would look as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">spring.cloud.function:</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  definition</strong></span>: myPublisher;myProcessor;mySubscriber
</code></pre>
    <p class="normal">Finally, we need to tell Spring Cloud Stream what destination to use for each function. To connect <a id="_idIndexMarker171"/>our three functions so that our processor consumes messages from our publisher and our subscriber consumes messages from the processor, we can supply the following configuration:</p>
    <pre class="programlisting code"><code class="hljs-code">spring.cloud.stream.bindings:
  myPublisher-out-<span class="hljs-number">0</span>:
    destination: myProcessor-in
  myProcessor-in-<span class="hljs-number">0</span>:
    destination: myProcessor-in
  myProcessor-out-<span class="hljs-number">0</span>:
    destination: myProcessor-out
  mySubscriber-in-<span class="hljs-number">0</span>:
    destination: myProcessor-out
</code></pre>
    <p class="normal">This will result in the following message flow:</p>
    <pre class="programlisting code"><code class="hljs-code">myPublisher → myProcessor → mySubscriber
</code></pre>
    <p class="normal">A supplier is triggered by Spring Cloud Stream by default every second, so we could expect output like the following if we start a Spring Boot application including the functions and configuration described previously:</p>
    <pre class="programlisting con"><code class="hljs-con">ML RECEIVED: ML PROCESSED: Wed Mar 09 16:28:30 CET 2021
ML RECEIVED: ML PROCESSED: Wed Mar 09 16:28:31 CET 2021
ML RECEIVED: ML PROCESSED: Wed Mar 09 16:28:32 CET 2021
ML RECEIVED: ML PROCESSED: Wed Mar 09 16:28:33 CET 2021
</code></pre>
    <p class="normal">In cases where the supplier should be triggered by an external event instead of using a timer, the <code class="inlineCode">StreamBridge</code> helper class can be used. For example, if a message should be published to the processor when a REST API, <code class="inlineCode">sampleCreateAPI</code>, is called, the code could look like the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Autowired</span>
<span class="hljs-keyword">private</span> StreamBridge streamBridge;
<span class="hljs-meta">@PostMapping</span>
<span class="hljs-keyword">void</span> <span class="code-highlight"><strong class="hljs-title-slc">sampleCreateAPI</strong></span><span class="hljs-params">(</span><span class="hljs-meta">@RequestBody</span><span class="hljs-params"> String body)</span> {
  <span class="code-highlight"><strong class="hljs-slc">streamBridge</strong></span>.send(<span class="hljs-string">"myProcessor-in-0"</span>, body);
}
</code></pre>
    <p class="normal">Now that we understand the various Spring APIs, let’s learn a bit about Docker and containers in the<a id="_idIndexMarker172"/> next section.</p>
    <h1 id="_idParaDest-85" class="heading-1">Docker</h1>
    <p class="normal">I assume that Docker and the concept of containers need no in-depth introduction. Docker made the concept of containers as a lightweight alternative to virtual machines<a id="_idIndexMarker173"/> very popular in 2013. A container is actually a process in a Linux host that uses Linux <strong class="keyWord">namespaces</strong> to provide isolation between different containers, in terms of their use of global system resources such as users, processes, filesystems, and networking. Linux <strong class="keyWord">control groups</strong> (also known as <strong class="keyWord">cgroups</strong>) are used to<a id="_idIndexMarker174"/> limit the amount of CPU and memory that a container is allowed to consume.</p>
    <p class="normal">Compared to a virtual machine that uses a hypervisor to run a complete copy of an operating system in each virtual machine, the overhead in a container is a fraction of the overhead in a traditional virtual machine. </p>
    <p class="normal">This leads to much faster startup times and significantly lower overhead in terms of CPU and memory usage.</p>
    <p class="normal">The isolation that’s provided for a container is, however, not considered to be as secure as the isolation that’s provided for a virtual machine. With the release of Windows Server 2016, Microsoft supports the use of Docker in Windows servers.</p>
    <div class="packt_tip">
      <p class="normal">During the last few years, a lightweight form of virtual machines has evolved. It mixes the best of traditional virtual machines and containers, providing virtual machines with a footprint and startup time similar to containers and with the same level of secure isolation provided by traditional virtual machines. Some examples are <strong class="keyWord">Amazon Firecracker</strong> and <strong class="keyWord">Microsoft Windows Subsystem for Linux v2</strong> (<strong class="keyWord">WSL2</strong>). For more information, see <a href="https://firecracker-microvm.github.io"><span class="url">https://firecracker-microvm.github.io</span></a> and <a href="https://docs.microsoft.com/en-us/windows/wsl/"><span class="url">https://docs.microsoft.com/en-us/windows/wsl/</span></a>.</p>
    </div>
    <p class="normal">Containers are very useful during both development and testing. Being able to start up a complete system landscape of cooperating microservices and resource managers (for example, database servers, messaging brokers, and so on) with a single command for testing is simply amazing.</p>
    <p class="normal">For example, we can write scripts in order to automate end-to-end tests of our microservice landscape. A test script can start up the microservice landscape, run tests using the exposed APIs, and tear down the landscape. This type of automated test script is very useful, both for running locally on a developer PC before pushing code to a source code repository, and to be executed as a step in a delivery pipeline. A <a id="_idIndexMarker175"/>build server can run these types of tests in its continuous integration and deployment process whenever a developer pushes code to the source repository.</p>
    <div class="note">
      <p class="normal">For production usage, we need a container orchestrator such as Kubernetes. We will come back to container orchestrators and Kubernetes later in this book.</p>
    </div>
    <p class="normal">For most of the microservices we will look at<a id="_idIndexMarker176"/> in this book, a <strong class="keyWord">Dockerfile</strong> such as the following is all that is required to run the microservice as a Docker container:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">17</span>
<span class="hljs-keyword">MAINTAINER</span> Magnus Larsson &lt;magnus.larsson.ml@gmail.com&gt;
<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span>
<span class="hljs-keyword">ADD</span> ./build/libs/*.jar app.jar
<span class="hljs-keyword">ENTRYPOINT</span> [<span class="hljs-string">"java"</span>,<span class="hljs-string">"-jar"</span>,<span class="hljs-string">"/app.jar"</span>]
</code></pre>
    <p class="normal">If we want to start and stop many<a id="_idIndexMarker177"/> containers with one command, <strong class="keyWord">Docker Compose</strong> is the perfect tool. Docker Compose uses a YAML file to describe the containers to be managed. </p>
    <p class="normal">For our microservices, it might look something like the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">product:</span>
 <span class="code-highlight"><strong class="hljs-attr-slc">build</strong></span><span class="hljs-attr">:</span> <span class="hljs-string">microservices/product-service</span>
<span class="hljs-attr">recommendation:</span>
 <span class="code-highlight"><strong class="hljs-attr-slc">build</strong></span><span class="hljs-attr">:</span> <span class="hljs-string">microservices/recommendation-service</span>
<span class="hljs-attr">review:</span>
  <span class="code-highlight"><strong class="hljs-attr-slc">build</strong></span><span class="hljs-attr">:</span> <span class="hljs-string">microservices/review-service</span>
<span class="hljs-attr">composite:</span>
  <span class="code-highlight"><strong class="hljs-attr-slc">build</strong></span><span class="hljs-attr">:</span> <span class="hljs-string">microservices/product-composite-service</span>
  <span class="code-highlight"><strong class="hljs-attr-slc">ports</strong></span><span class="hljs-attr">:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">"</span><span class="code-highlight"><strong class="hljs-string-slc">8080:8080</strong></span><span class="hljs-string">"</span>
</code></pre>
    <p class="normal">Let me explain the preceding source code a little:</p>
    <ul>
      <li class="bulletList">The <code class="inlineCode">build</code> directive is used to specify which Dockerfile to use for each microservice. Docker Compose will use it to build a Docker image and then launch a Docker container based on that Docker image.</li>
      <li class="bulletList">The <code class="inlineCode">ports</code> directive for the composite service is used to expose port <code class="inlineCode">8080</code> on the server where Docker runs. On a developer’s machine, this means that the port of the composite service can be reached simply by using <code class="inlineCode">localhost:8080!</code></li>
    </ul>
    <p class="normal">All the containers in<a id="_idIndexMarker178"/> the YAML files can be managed with simple commands such as the following:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">docker-compose up -d</code>: Starts all containers. <code class="inlineCode">-d</code> means that the containers run in the background, not locking the terminal from where the command was executed.</li>
      <li class="bulletList"><code class="inlineCode">docker-compose down</code>: Stops and removes all containers.</li>
      <li class="bulletList"><code class="inlineCode">docker-compose logs -f --tail=0</code>: Prints out log messages from all containers. <code class="inlineCode">-f</code> means that the command will not complete, and instead waits for new log messages. <code class="inlineCode">--tail=0</code> means that we don’t want to see any previous log messages, only new ones.</li>
    </ul>
    <div class="packt_tip">
      <p class="normal">For a full list of Docker Compose commands, see <a href="https://docs.docker.com/compose/reference/"><span class="url">https://docs.docker.com/compose/reference/</span></a>.</p>
    </div>
    <p class="normal">This was a brief introduction to Docker. We will go into more detail about Docker starting with <em class="chapterRef">Chapter 4</em>, <em class="italic">Deploying Our Microservices Using Docker</em>.</p>
    <h1 id="_idParaDest-86" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we have been introduced to Spring Boot and complementary open source tools that can be used to build cooperating microservices.</p>
    <p class="normal">Spring Boot is used to simplify the development of Spring-based, production-ready applications, such as microservices. It is strongly opinionated in terms of how to set up both core modules from the Spring Framework and third-party tools. Using Spring WebFlux, we can develop microservices that expose reactive, that is, non-blocking, REST services. To document these REST services, we can use<code class="inlineCode"> springdoc-openapi</code> to create OpenAPI-based documentation for the APIs. If we need to persist data used by the microservices, we can use Spring Data, which provides an elegant abstraction for accessing and manipulating persistent data using entities and repositories. Spring Data’s programming model is similar, but not fully portable between different types of databases, for example, relational, document, key-value, and graph databases.</p>
    <p class="normal">If we prefer sending messages asynchronously between our microservices, we can use Spring Cloud Stream, which provides a streaming abstraction over messaging. Spring Cloud Stream comes with out-of-the-box support for Apache Kafka and RabbitMQ but can be extended to support other messaging brokers using custom binders. Finally, Docker makes the concept of containers as a lightweight alternative to virtual machines easy to use. Based on Linux namespaces and control groups, containers provide isolation similar to what traditional virtual machines provide, but with a significantly lower overhead in terms of CPU and memory usage.</p>
    <p class="normal">In the next chapter, we will take our first small steps, creating microservices with minimalistic functionality using Spring Boot and Spring WebFlux.</p>
    <h1 id="_idParaDest-87" class="heading-1">Questions</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">What is the purpose of the <code class="inlineCode">@SpringBootApplication</code> annotation?</li>
      <li class="numberedList">What are the main differences between the older Spring component for developing REST services, Spring Web MVC, and the new Spring WebFlux?</li>
      <li class="numberedList">How does <code class="inlineCode">springdoc-openapi</code> help a developer document REST APIs?</li>
      <li class="numberedList">What is the function of a repository in Spring Data and what is the simplest possible implementation of a repository?</li>
      <li class="numberedList">What is the purpose of a binder in Spring Cloud Stream?</li>
      <li class="numberedList">What is the purpose of Docker Compose?</li>
    </ol>
  </div>
</div>
</div>
</body></html>