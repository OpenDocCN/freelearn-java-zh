<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Local Variable Syntax for Lambda Parameters</h1>
                </header>
            
            <article>
                
<p>Java is enhancing its language by extending the use of the reserved type <kbd>var</kbd> for lambda parameters. The sole purpose of this enhancement is to align the syntax of lambda parameters with the syntax of declaring local variables with <kbd>var</kbd>. The parameters of implicitly-typed lambda expressions have been inferred by the compiler since lambdas were introduced, in Java 8.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>Implicitly and explicitly-typed lambda parameters</li>
<li>How to use <kbd>var</kbd> with lambda parameters</li>
<li>Using annotations with lambda parameters</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To execute the code in this chapter, you must install JDK 11 (or a later version) on your system. All of the code in this chapter can be accessed at <a href="https://github.com/PacktPublishing/Java-11-and-12-New-Features">https://github.com/PacktPublishing/Java-11-and-12-New-Features</a><a href="https://github.com/PacktPublishing/Java-11-and-12-New-Features"><span class="MsoHyperlink">.</span></a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lambda expressions</h1>
                </header>
            
            <article>
                
<p>A <strong>lambda expression</strong> is an anonymous function that can accept input parameters and return a value. A lambda expression can specify the types of all (or none) of its input parameters; lambda expressions can be explicitly-typed or implicitly-typed.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Explicitly-typed lambda expressions</h1>
                </header>
            
            <article>
                
<p>A lambda expression that explicitly specifies the type of all of its input parameters is referred to as an explicitly-typed lambda expression. The following code illustrates a few examples (with the input parameters in bold):</p>
<pre>(<strong>Integer age</strong>) -&gt; age &gt; 10;                      // input Integer, <br/>                                                // return Boolean 
(<strong>Integer age</strong>) -&gt; age &gt; 10? "Kid" : "Not a Kid"; // input Integer, <br/>                                                // return String 
(<strong>Integer age</strong>) -&gt; {System.out.println();};       // input Integer, <br/>                                                // return void 
() -&gt; {return Math.random() + "Number";};       // input none,<br/>                                                // return String 
(<strong>String name, List&lt;Person&gt; list</strong>) -&gt; { 
                               return ( 
                                   list.stream() 
                                       .filter(e -&gt;             <br/>                                        e.getName().startsWith(name)) 
                                       .map(Person::getAge) 
                                       .findFirst() 
                                   ); 
                               };               // input name, <br/>                                                // List&lt;person&gt; <br/>                                                // return <br/>                                                // Optional&lt;Integer&gt; </pre>
<p>The code in all of the preceding examples explicitly defines the types of all of the parameters that are being passed to it. If a lambda expression doesn't accept any parameter, it uses a pair of empty round braces (<kbd>()</kbd>).</p>
<p>If this makes you wonder the types of the variables to which the lambda expressions will be assigned, here's the complete code for your reference:</p>
<pre>Predicate&lt;Integer&gt; predicate = (Integer age) -&gt; age &gt; 10; 
Function&lt;Integer, String&gt; function = (Integer age) -&gt; age &gt; 10? "Kid" : <br/>                                    "Not a Kid"; <br/>Consumer&lt;Integer&gt; consumer =   (Integer age) -&gt; {  <br/>                                                System.out.println();<br/>                                                }; 
Supplier&lt;String&gt; supplier =    () -&gt; {<br/>                                         return Math.random() + <br/>                                         "Number";<br/>                                     }; 
 
BiFunction&lt;String, List&lt;Person&gt;,<br/> Optional&lt;Integer&gt;&gt; firstElement = (String name, List&lt;Person&gt; list) -&gt;                                                                 { 
                                   return ( 
                                       list.stream() 
                                           .filter(e -&gt; <br/>                                            e.getName().<br/>                                            startsWith(name)) 
                                           .map(Person::getAge) 
                                          .findFirst() 
                                       ); 
                                   }; 
class Person { 
    int age; 
    String name; 
    String getName() { 
        return name; 
    } 
    Integer getAge() { 
        return age; 
    } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implicitly-typed lambda expressions</h1>
                </header>
            
            <article>
                
<p>A lambda expression that doesn't specify the types of any of its input parameters is referred to as an <strong>implicitly-typed</strong> lambda expression. In this case, the compiler infers the type of the method parameters and adds it to the bytecode.</p>
<p>Let's modify the lambda expression from the preceding section, dropping the types of the input parameters (the modified code is in bold):</p>
<pre>(<strong>age</strong>) -&gt; age &gt; 10; 
(<strong>age</strong>) -&gt; age &gt; 10? "Kid" : "Not a Kid"; 
<strong>age</strong> -&gt; {System.out.println();}; 
() -&gt; {return Math.random() + "Number";}; 
 
(name, list) -&gt; { 
                    return ( 
                        list.stream() 
                            .filter(e -&gt; e.getName().startsWith(name)) 
                            .map(Person::getAge) 
                            .findFirst() 
                    ); 
                }; </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>You can't mix implicitly-typed and explicitly-typed parameters in lambda expressions. For instance, the following code won't compile because it explicitly specifies type of <kbd>x</kbd>, but not for <kbd>y</kbd>:</p>
<pre>(Integer x, y) -&gt; x + y;                 // won't compile</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lambda parameters and type inference with var</h1>
                </header>
            
            <article>
                
<p>In JDK 11, you'll be able to use <kbd>var</kbd> with lambda parameters. However, this is just syntactic sugar. The reserved type name, <kbd>var</kbd>, was introduced in JDK 10, to enable developers to declare local variables without using an explicit data type (to let the compiler infer the data type during compilation). But implicitly-typed lambda expressions were already doing this by using only the variable name for their parameters, without their types (examples are included in the preceding section).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding var to lambda parameters</h1>
                </header>
            
            <article>
                
<p>Java allows for the use of the reserved word <kbd>var</kbd> with lambda parameters, to align its syntax with the declaration of local variables, which can now use <kbd>var</kbd>.</p>
<p>Let's modify the examples from the preceding section, adding <kbd>var</kbd> to the lambda parameters:</p>
<pre>(var age) -&gt; age &gt; 10; 
(var age) -&gt; age &gt; 10? "Kid" : "Not a Kid"; 
(var age) -&gt; {System.out.println();}; <br/>() -&gt; {return Math.random() + "Number";}; 
 
(var name, var list) -&gt; { 
                             return ( 
                                 list.stream() 
                                     .filter(e -&gt; <br/>                                      e.getName().startsWith(name)) 
                                     .map(Person::getAge) 
                                     .findFirst() 
                                 ); 
                             }; </pre>
<div class="packt_infobox">The main reason for allowing the addition of <kbd>var</kbd> to lambda parameters is to align the usage with the syntax of the local parameters declared using <kbd>var</kbd>.</div>
<p>If you are using <kbd>var</kbd> with lambda parameters, you must use it with all of the lambda parameters. You can't mix implicitly-typed or explicitly-typed parameters with the parameters that use <kbd>var</kbd>. The following code example won't compile:</p>
<pre>(var x, y) -&gt; x + y;                         // won't compile 
(var x, Integer y) -&gt; x + y;                 // won't compile </pre>
<p>You cannot enclose the parameters of a lambda expression using round brackets (<kbd>()</kbd>) if you are using just one method parameter. But, you can't drop <kbd>()</kbd> if you are using <kbd>var</kbd> with your lambda parameters. Here is some sample code to illustrate this further:</p>
<pre>(int x) -&gt; x &gt; 10;                         // compiles 
(x) -&gt; x &gt; 10;                             // compiles 
x -&gt; x &gt; 10;                               // compiles 
(var x) -&gt; x &gt; 10;                         // compiles 
var x -&gt; x &gt; 10;                           // Won't compile </pre>
<div class="packt_infobox">You can't mix implicitly-typed or explicitly-typed lambda parameters with the parameters that use <kbd>var</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding annotations to lambda parameters</h1>
                </header>
            
            <article>
                
<p>You can use annotations with lambda parameters if you define them with either explicit data types or by using the reserved type <kbd>var</kbd>. Annotations could be used to mark null or non-null lambda parameters. Here's an example:</p>
<pre>(@Nullable var x, @Nonnull Integer y) -&gt; x + y;</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered using the reserved type <kbd>var</kbd> with implicitly-typed lambda expressions. We started by identifying the syntax differences in explicitly-typed and implicitly-typed lambda expressions.</p>
<p>Through examples, you saw how adding <kbd>var</kbd> to lambda parameters is just syntactic sugar, since you have been able to use type inference with implicitly-typed lambda parameters ever since they were introduced in Java 8. Using <kbd>var</kbd> with lambda parameters aligns their syntax with the local variables defined using <kbd>var</kbd>. Using <kbd>var</kbd> also enables developers to use annotations with lambda parameters.</p>
<p>In the next chapter, we'll work with the HTTP Client API, which will be added to Java 11 as one of its core APIs.</p>


            </article>

            
        </section>
    </body></html>