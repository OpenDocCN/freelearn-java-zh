- en: Adding Reporting Capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many business applications require the generation of reports as part of their
    functionality. A *report* is the representation of data in a certain format for
    a particular audience. A *R**eport Generator* (or *R**eport Viewer*) is an application
    or an application module that allows end users to visualize and download reports.
    Very often, a report generator takes data from a database and produces a document
    in a format suitable for printing on paper. We will focus on this type of report
    generator in this chapter. There are many ready-to-use report generators with
    advanced features, such as business intelligence and analytics, but these systems
    are out of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll learn how to render `JasperReports` in a Vaadin application
    without having to deal with report designers or XML design formats. Instead, we'll
    use a Java API to design the reports, similarly to how you use Java to design
    a web UI using Vaadin Framework. We'll also discuss background report generation
    and Server Push, a mechanism that allows us to update the client from a separate
    thread running on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating `JasperReports` with Vaadin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering runtime-generated HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long-running background tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server Push
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have Java SE Development Kit and Java EE SDK version
    8 or later. You also need Maven version 3 or later. A Java IDE with Maven support,
    such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the
    Git repository of this book, you need to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-08](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-08)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://goo.gl/9sdD5q](https://goo.gl/9sdD5q)'
  prefs: []
  type: TYPE_NORMAL
- en: The example application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout the chapter, we''ll develop a Report Viewer. The following is a
    screenshot of the finished application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87b75f20-24db-4db6-8cc1-817384e4ad7d.png)'
  prefs: []
  type: TYPE_IMG
- en: The data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The data model is based on a simple SQL table, `Call`, that contains columns
    for the ID, client name, phone number, city, start time, duration, and status.
    The following is a JPA Entity representing this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`Status` and `City` are simple Java `enums` that define some test values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `@Enumerated` annotations in the `city` and `status` fields of the
    `Call` class. This is used to persist the value as a string in the database instead
    of an integer representing the value, which allows us to use simpler SQL queries
    for the reports.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use two persistence frameworks in this application. For parts of the application
    that require saving data or running business logic, we'll use JPA. For reports
    data, we'll use MyBatis. In your applications you can, of course, use only one
    framework. The reason behind choosing MyBatis for report generation is that it's
    a great fit for constructing and maintaining complex SQL queries. SQL, in turn,
    is a powerful language and a perfect fit for reporting. The ability to copy an
    SQL query from your code and run it directly on a SQL client eases implementation
    and maintenance as you can quickly see the data you'd get in a report without
    having to compile or execute the application. Each report has its own **data transfer
    model** (**DTO**), a class that encapsulates the data to be rendered in a report
    in a convenient format. The advantage of this is that we don't have to query extra
    data not used in the report and so free the web server from data processing to
    some extent.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration of both frameworks is implemented in the `JPAService` and
    `MyBatisService` classes and the `persistence.xml` and `mybatis-config.xml` files.
    A file-based H2 database is used by default, but you'll find configuration examples
    for MySQL and PostgreSQL as comments in the configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete source code of this chapter's example in the `Data-centric-Applications-with-Vaadin-8\chapter-08`
    Maven project of the source code that accompanies this book.
  prefs: []
  type: TYPE_NORMAL
- en: Since a report viewer doesn't make sense without data, the example application
    includes a random data generator that populates the `Call` table with random data.
    When the table is empty, the generator will fill it with initial data representing
    phone calls made in the past 6 months at a rate of one million calls per year.
    If the table is not empty, the generator will "fill" the time span between the
    time of the last call in the table and the current time using the same rate. Additionally,
    the generator runs a background thread that inserts random data at runtime. This
    generator is meant to simulate a real-life situation in which data is constantly
    inserted into the database, sometimes even when the application is not running.
    You can find the implementation in the `DataGenerator` class. The `DataGenerator`
    functionality is invoked from a `ServletContextListener` that is defined in the
    `WebConfig` class. The initial time span and the rate used in the generator is
    configurable via parameters, in case you want to use different values.
  prefs: []
  type: TYPE_NORMAL
- en: The Vaadin UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `VaadinServlet` is configured in the `WebConfig` class. The `UI` implementation
    is realized in the `VaadinUI` class. For reference, the following snippet of code
    shows the implementation of the layout of the example application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are going to develop three different reports. The `showLastHourCallReport`,
    `showMonthlyCapacityReport`, and `generateAnnualLegalReport` methods include the
    logic to modify the UI in order to show the respective report inside the `panel`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating JasperReports with Vaadin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`JasperReports` is an open-source reporting engine to produce reports that
    can be rendered in a variety of formats, such as HTML, PDF, Microsoft Excel, ODT
    (OpenOffice), and others. Typically, reports are designed in a visual editor (iReport
    Designer) or XML files (JRXML). The design is compiled into a Jasper file (`*.jasper`),
    filled with data, and exported to the desired format.'
  prefs: []
  type: TYPE_NORMAL
- en: '`DynamicJasper` and `DynamicReports` are two open-source libraries that abstract
    away the JRXML format and provide APIs to design reports in Java. This is a good
    match for the philosophy of the Vaadin Framework which allows you to implement
    HTML-based web applications in Java. In this chapter, we''ll use `DynamicJasper`,
    but the concepts are similar if you prefer `DynamicReports`. Some of the concepts
    can be also used if you plan to design reports in JRXML files directly or through
    the iReport Designer tool.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can include `DynamicJasper` by adding the following dependency to your
    `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to export to Microsoft Office formats, you need to add Apache POI
    as a dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Getting the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A crucial part of report generation is data gathering. Data is arguably the
    most important input in a report. Having good "infrastructure code" for data gathering
    will highly improve maintainability in report modules. In this chapter, we'll
    use an SQL database, since it's probably the most common kind of data store in
    use. This means reports are filled with data queried using SQL. Reporting doesn't
    require saving data, only reading. SQL queries in reports tend to have multiple
    lines and are sometimes generated dynamically. MyBatis seems to be an excellent
    choice for reporting modules. MyBatis allows query definition in XML files, which,
    unlike Java Strings, help with long multi-line SQL queries and dynamic query definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use XML-based mappers with MyBatis, specify the name of the XML file using
    the `resource` attribute of the `mapper` element in the MyBatis configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ReportsMapper.xml` file is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This file defines the mapper Java interface to use. All queries defined inside
    the `mapper` element are mapped to the corresponding methods in the `ReportsMapper`
    class. For example, we can define a method to get all the calls before a given
    time as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we are not using the JPA Entity as a result type. Instead, we are
    using a DTO with, and only with, the required Java fields to store the data from
    the SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can map an SQL query to the `findCallsBefore` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The UI doesn''t consume the mapper interface directly. Instead, we can define
    more high-level methods in a service class. For example, the *Worldwide Calls
    in the Last Hour* report, the data from which the previous query comes, uses the
    `lastHourCalls` method in the `ReportsService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This allows for reusing queries when the data is the same but different processing
    (such as formatting, or computation of input parameters) is required.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the report
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the implementation of a simple report, the *Worldwide Calls
    in the Last Hour* report, shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4767d103-c821-450a-af22-404e3574a55c.png)'
  prefs: []
  type: TYPE_IMG
- en: To create a report using `DynamicJasper`, you have to create an object of type
    `DynamicReport`. This is done by using the `DynamicReportBuilder` class, which
    provides methods to add the title, header, columns, and other elements that form
    the report. The `DynamicReportBuilder` class implements the *builder pattern*
    to allow creating the report step by step and a method to build the `DynamicReport`
    instance. There are several subclasses of `DynamicReportBuilder`; we'll follow
    the examples given in the official documentation and use the `FastReportBuilder`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by configuring the title and header information, enabling full
    page width, setting the text to show when there''s no data, and enabling a background
    color for odd rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice how, after configuring the report, we end the sentence by calling the
    `build` method, which returns an instance of `DynamicReport`. All configuration
    calls happen between the instantiation (`new FastReportBuilder()`) and the call
    to `build()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The report data is defined by columns. Columns are configured with the `addColumn`
    method. The `addColumn` method accepts an instance of type `AbstractColumn` that
    we can create by using `ColumnBuilder`, also a builder class. The following snippet
    of code demonstrates how to create the seven columns that make up the report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For each column, we have to specify the name of the corresponding Java property
    in the `CallDto` class and its type. We can also specify the title and *text formatters*
    when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DynamicReport` instance defines the visual structure of the report. With
    this in place, we can create a `JasperPrint` object, which represents a page-oriented
    document that can be later exported to multiple formats. We first need to get
    the data from the service class, and then pass the `DynamicReport` instance and
    the data to the `generateJasperPrint` method of the `DynamicJasperHelper` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Rendering a report as HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `JasperPrint` instance can be exported to several formats. Since we are
    interested in rendering the report in a Vaadin web application, we can export
    the report to HTML and use a `Label` configured with `ContentMode.HTML` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HtmlExporter` class sends its output to an `OutputStream`, which we can
    convert to `String` and set as a `Label` value. This `Label` can be added to any
    Vaadin layout, as shown in this snippet of code, which also takes into account
    exception handling and resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Adding charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding charts with `DynamicJasper` is done through the `addChart` method of
    the `FastReportBuilder` class. The following snippet of code shows the full configuration
    of the *Monthly Capacity Report*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we need a reference to the columns containing the data we want to
    use in the chart. The `setCategory` and `addSeries` methods accept these references.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to render charts, we must configure an `ImageServlet`, which is provided
    by the `JasperReports` library. This servlet serves the images that make up the
    charts. In the example application for this chapter, the servlet is declared in
    the `WebConfig` class as a static inner class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use any suitable URL. This needs to be configured in the output used
    by the exporter class (for example, `HTMLExporter`). Additionally, the `JasperPrint`
    instance has to be set in the HTTP session. The following snippet of code shows
    the extra configuration needed when rendering charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `WebHtmlResourceHandler` constructor accepts a string with the URL pattern
    to use by the internal image handler in the exporter. Notice how the pattern starts
    with `image`. This is the same value used in the `ImageServlet` mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a report in a background task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Report generation may involve expensive computation due to large amounts of
    data, connections to external systems, and data processing. In many situations,
    report data is gathered directly from the original source, typically an SQL database.
    This has two clear drawbacks. The first problem is that as the application runs,
    more and more data is added into the database, making reports run slower with
    time. The second problem is that report generation may heavily use the database
    at certain times, interfering with the usage of other parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'One step toward improving this situation is to progressively and continuously
    generate the data required for reporting. For example, consider the following
    query that calculates the average on a column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using this query, you can use the following formula to continuously
    calculate the average (*an*) from the previous average value (*a[n-1]*) every
    time a new value (*x[n]*) is persisted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60ffbf40-b3f8-49ab-9fda-9919bf948027.png)'
  prefs: []
  type: TYPE_IMG
- en: This, of course, doesn't take into account *delete* operations, and requires
    calculating the average any time a new value is persisted in the database, but
    the key idea of this simple example is to try to *help* the application to pre-generate
    data for reporting, as data is added, modified, or deleted in order to minimize
    the amount of computational power required at report generation time.
  prefs: []
  type: TYPE_NORMAL
- en: 'When pre-processing data, or when there are computations that depend on time
    or external data sources, report generation may take longer than a normal request
    to the application. In these cases, you can use background threads to generate
    the report and notify the user when the report is ready. In the example application,
    you can see an Annual legal report option in the Reports menu. Generating this
    report is expensive in terms of application time, so instead of locking the application''s
    usage until the report is ready, the application shows a notification saying that
    the report is being generated and starts the process in a background thread, letting
    users visualize other reports in the meantime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90ca15da-48ba-4d88-8ec1-c13cec185d20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the report is ready, the application notifies you again and shows a button
    that allows you to download the report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8567025-ebb9-4d95-9c83-5de508691eb4.png)'
  prefs: []
  type: TYPE_IMG
- en: The next sections explain how to implement this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting a report to a PDF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML is the best option to render a report in a browser. However, `JasperReports`
    and `DynamicJasper` support many other formats. These formats are available as
    implementations of the `JRExporter` interface. One of them is the `JRPdfExporter`
    class. The example application includes the `LastHourCallReport` class, which,
    in contrast to previous report implementations, is not a Vaadin UI component.
    Since we want to allow users to download this report, we don't really need a UI
    component for it. Instead, `LastHourCallReport` is a helper class that configures
    the report, exports it as a PDF, and exposes the content of the file through an
    `OutputStream` suitable for the `FileDownloader` class, part of Vaadin Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Omitting the details about the report configuration, which we already covered
    in previous sections, the following is the implementation of the `LastHourCallReport`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We need to call the `getOutputStream` method from a new thread and modify the
    UI, also from this new thread, to add a button that downloads the PDF file. In
    order to modify the UI from a separate thread, we need to enable and use Server
    Push.
  prefs: []
  type: TYPE_NORMAL
- en: Server Push
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s examine what happens if we modify the UI from a separate thread without
    using Server Push:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When the user clicks the corresponding option in the menu, the `generateAnnualLegalReport`
    method is called. The method starts a new thread, so we end up with two threads;
    the one that started when the HTTP request happened (the menu option is clicked)
    and the one started by the `generateAnnualLegalReport` method. When the HTTP request
    finishes, the user is able to continue using the application in the browser. At
    some point later, the `AnnualLegalReport.getOutputStream()` method finishes and
    the application tries to modify the UI. However, this is happening in a separate
    background thread in the server. All changes to the UI are lost or may fail, since
    the thread is not associated with the UI instance, and `NullPointerExceptions`
    may be thrown by the framework (this is the case with the `Notification.show`
    method).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get a lock on the session in order to guarantee a UI instance is available
    and avoid `NullPointerExceptions` by wrapping any code that modifies the UI from
    outside a request-handling thread with the `UI.access(Runnable)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s still one problem; the server needs to send the changes to the browser,
    something we can achieve by enabling **Server Push**. Server Push is a technique
    that starts a communication process from the server to the client, in opposition
    to a typical HTTP request where the communication is initiated by the client (web
    browser). In order to use Server Push, you need to add the `vaadin-push` dependency
    in your `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable Server Push, you can annotate the UI implementation class with `@Push`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Push` annotation accepts two optional parameters: `value` and `transport`.The
    first one, `value`, configures the *push mode* to use. There are two main options:
    `PushMode.AUTOMATIC` and `PushMode.MANUAL`. `AUTOMATIC` means all changes to the
    UI are automatically sent to the client once the `UI.access` method finishes (technically,
    once the session lock is released). `MANUAL` means you have to call `UI.push`
    to make the UI changes available in the browser. The second parameter, `transport`,
    configures the *transport type* to use. There are three options: `Transport.WEBSOCKET`
    (which uses the standard *WebSockets* protocol, a different protocol than HTTP,
    for all communications between the server and the client), `Transport.WEBSOCKET_XHR`
    (which uses WebSockets for server-to-client communication and XHR for client-to-server
    communication), and `Transport.LONG_POLLING` (a technique that uses the standard
    HTTP protocol where the client requests the server for data, the server holds
    the request until new data is available, and the process is repeated again).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You also have to enable the asynchronous operation mode for the `VaadinServlet`
    in order to optimize resources and allow XHR as a fallback mechanism when WebSockets
    is not available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to render `JasperReports` in Vaadin applications.
    We used `DynamicJasper`, which allowed us to use the Java Programming Language
    to design the reports. We also learned how to generate a report in a background
    thread running on the server and notify the client once the report is ready by
    using Server Push.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about how to handle large volumes of data
    in UIs by using lazy loading.
  prefs: []
  type: TYPE_NORMAL
