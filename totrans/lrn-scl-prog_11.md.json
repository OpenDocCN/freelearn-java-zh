["```java\nlibraryDependencies +=  \"com.typesafe.akka\" %% \"akka-actor\" % akkaVersion\n```", "```java\nimport akka.actor._\nval bakery = ActorSystem(\"Bakery\")\n```", "```java\nclass Cook extends Actor {  \n  override def receive = {      \n    case _ =>   \n  }\n}\n```", "```java\nobject Cook {\n  final case class Dough(weight: Int)\n  final case class RawCookies(number: Int)\n}\n```", "```java\nclass Cook extends Actor {\n  override def receive = {\n    case Dough(weight) => \n      val numberOfCookies = makeCookies(weight)\n      sender() ! RawCookies(numberOfCookies)\n  }\n\n  private val cookieWeight = 30\n  private def makeCookies(weight: Int):Int = weight / cookieWeight\n}\n```", "```java\nval cookProps: ActorRef = Props[Cook]\n```", "```java\nobject Bakery extends App {\n  val bakery = ActorSystem(\"Bakery\")\n  val cook: ActorRef = bakery.actorOf(Props[Cook], \"Cook\")\n  cook ! Dough(1000)\n}\n```", "```java\nobject Oven {\n  final case object Extract\n  final case class Cookies(count: Int)\n  def props(size: Int) = Props(classOf[Oven], size)\n}\n\nclass Oven(size: Int) extends Actor {\n  private var cookiesInside = 0\n  override def receive = LoggingReceive {\n    case RawCookies(count) => insert(count).foreach(sender().!)\n    case Extract => sender() ! Cookies(extract())\n  }\n\n  def insert(count: Int): Option[RawCookies] =\n    if (cookiesInside > 0) {\n      Some(RawCookies(count))\n    } else {\n      val tooMany = math.max(0, count - size)\n      cookiesInside = math.min(size, count)\n      Some(tooMany).filter(_ > 0).map(RawCookies)\n    }\n\n  def extract(): Int = {\n    val cookies = cookiesInside\n    cookiesInside = 0\n    cookies\n  }\n}\n```", "```java\nval prop = Props(classOf[Oven], size)\n```", "```java\nobject Baker {\n  import scala.concurrent.duration._\n  private val defaultBakingTime = 2.seconds\n  def props(oven: ActorRef) = Props(new Baker(oven))\n}\nclass Baker(oven: ActorRef,\n            bakingTime: FiniteDuration = Baker.defaultBakingTime)\n    extends Actor {\n  private var queue = 0\n  private var timer: Option[Cancellable] = None\n  override def receive: Receive = {\n    case RawCookies(count) =>\n      queue += count\n      if (sender() != oven && timer.isEmpty) timer = sendToOven()\n    case c: Cookies =>\n      context.actorSelection(\"../Manager\") ! c\n      assert(timer.isEmpty)\n      if (queue > 0) timer = sendToOven() else timer = None\n  }\n  private def sendToOven() = {\n    oven ! RawCookies(queue)\n    queue = 0\n    import context.dispatcher\n    Option(context.system.scheduler.scheduleOnce(bakingTime, oven, Extract))\n  }\n  override def postStop(): Unit = {\n    timer.foreach(_.cancel())\n    super.postStop()\n  }\n}\n```", "```java\nobject Mixer {\n  final case class Groceries(eggs: Int, flour: Int, sugar: Int, chocolate: Int)\n  def props: Props = Props[Mixer].withDispatcher(\"mixers-dispatcher\")\n}\n\nclass Mixer extends Actor {\n  override def receive: Receive = {\n    case Groceries(eggs, flour, sugar, chocolate) =>\n      Thread.sleep(3000)\n      sender() ! Dough(eggs * 50 + flour + sugar + chocolate)\n  }\n}\n```", "```java\nmixers-dispatcher {\n  executor = \"thread-pool-executor\"\n  type = PinnedDispatcher\n}\n```", "```java\ndef props: Props = Props[Mixer].withDispatcher(\"mixer-dispatcher\")\n```", "```java\ncontext stop child\ncontext.stop(self)\n```", "```java\nclass Chef extends Actor with ActorLogging with Stash {\n  import scala.concurrent.duration._\n  private implicit val timeout = Timeout(5 seconds)\n\n  override def receive = {\n    case Groceries(eggs, flour, sugar, chocolate) =>\n      for (i <- 1 to eggs) {\n        val mixer = context.watch(context.actorOf(Mixer.props, s\"Mixer_$i\"))\n        val message = Groceries(1, flour / eggs, sugar / eggs, chocolate / eggs)\n        import akka.pattern.ask\n        val job = (mixer ? message).mapTo[Dough]\n        import context.dispatcher\n        import akka.pattern.pipe\n        job.pipeTo(sender())\n      }\n      log.info(\"Sent jobs to {} mixers\", eggs)\n      context.become(waitingForResults, discardOld = false)\n  }\n  def waitingForResults: Receive = {\n    case g: Groceries => stash()\n    case Terminated(child) =>\n      if (context.children.isEmpty) {\n        unstashAll()\n        context.unbecome()\n        log.info(\"Ready to accept new mixing jobs\")\n      }\n  }\n}\n```", "```java\nсlass Chef extends Actor with ActorLogging with Stash\n```", "```java\nval log = akka.event.Logging(this)\n```", "```java\n  import scala.concurrent.duration._\n  private implicit val timeout = Timeout(5 seconds)\n```", "```java\noverride def receive = {\n  case Groceries(eggs, flour, sugar, chocolate) =>\n```", "```java\nfor (i <- 1 to eggs) {\n  val message = Groceries(1, flour / eggs, sugar / eggs, chocolate / eggs)\n\n```", "```java\nval mixer = context.watch(context.actorOf(Mixer.props, s\"Mixer_$i\"))\n```", "```java\nimport akka.pattern.ask\nval job: Future[Dough] = mixer ? message\n```", "```java\nimport akka.pattern.pipe\nimport context.dispatcher\njob.pipeTo(sender())\n```", "```java\nlog.info(\"Sent jobs to {} mixers\", eggs)\ncontext.become(waitingForResults, discardOld = false)\n```", "```java\ncase g: Groceries => stash()\n```", "```java\ncase Terminated(child) =>\n```", "```java\nclass Manager(chef: ActorRef, cook: ActorRef, baker: ActorRef) extends FSM[State, Data]\n```", "```java\ntrait State\ncase object Idle extends State\ncase object Shopping extends State\ncase object Mixing extends State\ncase object Forming extends State\ncase object Baking extends State\n```", "```java\nsealed trait Data\ncase object Uninitialized extends Data\nfinal case class ShoppingList(...) extends Data\nfinal case class Groceries(...) extends Data\nfinal case class Dough(weight: Int) extends Data\nfinal case class RawCookies(count: Int) extends Data\n```", "```java\nwhen(Idle) {\n  case Event(s: ShoppingList, Uninitialized) ⇒\n    goto(Shopping) forMax (5 seconds) using s\n  case _ =>\n    stay replying \"Get back to work!\"\n}\n```", "```java\nwhen(Shopping) {\n  case Event(g: Groceries, s: ShoppingList)\n      if g.productIterator sameElements s.productIterator ⇒\n    goto(Mixing) using g\n  case Event(_: Groceries, _: ShoppingList) ⇒\n    goto(Idle) using Uninitialized\n}\n```", "```java\nwhen(Mixing) {\n    case Event(p: Dough, _) ⇒\n      goto(Forming) using p\n  }\n\n  when(Forming) {\n    case Event(c: RawCookies, _) ⇒\n      goto(Baking) using c\n  }\n\n  when(Baking, stateTimeout = idleTimeout * 20) {\n    case Event(c: Cookies, _) ⇒\n      log.info(\"Cookies are ready: {}\", c)\n      stay() replying \"Thank you!\"\n    case Event(StateTimeout, _) =>\n      goto(Idle) using Uninitialized\n  }\n```", "```java\nonTransition {\n  case Idle -> Shopping ⇒\n    val boy = sendBoy\n    boy ! stateData\n  case Shopping -> Idle =>\n    self ! stateData\n  case Shopping -> Mixing ⇒\n    chef ! nextStateData\n  case Mixing -> Forming =>\n    cook ! nextStateData\n  case Forming -> Baking =>\n    baker ! nextStateData\n}\n```", "```java\nlibraryDependencies += \"com.typesafe.akka\" %% \"akka-remote\" % akkaVersion\n```", "```java\nakka {\n  actor.provider = remote\n  remote {\n    enabled-transports = [\"akka.remote.netty.tcp\"]\n    netty.tcp {\n      hostname = \"127.0.0.1\"\n      port = 2552\n    }\n }\n}\n```", "```java\ninclude \"application\"\nakka.remote.netty.tcp.port = 2553\n```", "```java\nimport akka.actor._\nimport com.example.Manager.ShoppingList\nimport com.example.Mixer.Groceries\nimport com.typesafe.config.ConfigFactory\n\nobject Store extends App {\n  val store = ActorSystem(\"Store\", ConfigFactory.load(\"grocery.conf\"))\n\n  val seller = store.actorOf(Props(new Actor {\n    override def receive: Receive = {\n      case s: ShoppingList =>\n        ShoppingList.unapply(s).map(Groceries.tupled).foreach(sender() ! _)\n    }\n  }), \"Seller\")\n}\n```", "```java\nprivate def sendBoy: ActorRef = {\n  val store = \"akka.tcp://Store@127.0.0.1:2553\"\n  val seller = context.actorSelection(s\"$store/user/Seller\")\n  context.actorOf(Boy.props(seller))\n}\n```", "```java\nakka.<protocol>://<actor system name>@<hostname>:<port>/<actor path>\n```", "```java\nakka.actor.deployment {\n  /Manager/Boy {\n     remote = \"akka.tcp://Store@127.0.0.1:2553\"\n  }\n}\n```", "```java\nval storeAddress = AddressFromURIString(s\"$store\")\nval boyProps = Boy.props(seller).withDeploy(Deploy(scope = RemoteScope(storeAddress)))\ncontext.actorOf(boyProps)\n```", "```java\nobject Boy {\n  def props(seller: ActorSelection): Props = Props(classOf[Boy], seller)\n}\n\nclass Boy(seller: ActorSelection) extends Actor {\n  override def receive = {\n    case s: ShoppingList =>\n      seller forward s\n      self ! PoisonPill\n  }\n}\n```", "```java\nobject Bakery extends App {\n  val bakery = ActorSystem(\"Bakery\")\n  val cook: ActorRef = bakery.actorOf(Props[Cook], \"Cook\")\n  val chef: ActorRef = bakery.actorOf(Props[Chef], \"Chef\")\n  val oven: ActorRef = bakery.actorOf(Oven.props(12), \"Oven\")\n  val baker: ActorRef = bakery.actorOf(Baker.props(oven), \"Baker\")\n  val manager: ActorRef = bakery.actorOf(Manager.props(chef, cook, baker), \"Manager\")\n}\n```", "```java\n...\n[INFO] Remoting now listens on addresses: [akka.tcp://Bakery@127.0.0.1:2552]\n[INFO] [akka.tcp://Bakery@127.0.0.1:2552/user/Chef] Sent jobs to 24 mixers\n[INFO] [akka.tcp://Bakery@127.0.0.1:2552/user/Chef] Ready to accept new mixing jobs\n[INFO] [akka.tcp://Bakery@127.0.0.1:2552/user/Manager] Cookies are ready: Cookies(12)\n[ERROR] [akka.actor.LocalActorRefProvider(akka://Bakery)] guardian failed, shutting down system\njava.lang.AssertionError: assertion failed\n at scala.Predef$.assert(Predef.scala:204)\n ...\n...\n[akka.tcp://Bakery@127.0.0.1:2552/system/remoting-terminator] Remoting shut down.\n```", "```java\noverride def receive: Receive = {\n  ...\n  case c: Cookies =>\n    context.actorSelection(\"../Manager\") ! c\n    assert(timer.isEmpty)\n    if (queue > 0) timer = sendToOven() else timer = None\n}\n```", "```java\nclass MotorOverheatException extends Exception\nclass SlowRotationSpeedException extends Exception\nclass StrongVibrationException extends Exception\n```", "```java\nclass Mixer extends Actor with ActorLogging {\n  override def receive: Receive = {\n    case Groceries(eggs, flour, sugar, chocolate) =>\n      val rnd = Random.nextInt(10)\n      if (rnd == 0) {\n        log.info(\"Motor Overheat\")\n        throw new MotorOverheatException\n      }\n      if (rnd < 3) {\n        log.info(\"Slow Speed\")\n        throw new SlowRotationSpeedException\n      }\n      ...\n  }\n}\n```", "```java\noverride val supervisorStrategy: OneForOneStrategy =\n  OneForOneStrategy(maxNrOfRetries = 10, withinTimeRange = 1 minute) {\n    case _: MotorOverheatException ⇒\n      self ! Dough(0)\n      Stop\n    case _: SlowRotationSpeedException ⇒\n      sender() ! message\n      Restart\n    case _: StrongVibrationException =>\n      sender() ! message\n      Resume\n    case _: Exception ⇒ Escalate\n  }\n```", "```java\nakka {\n actor {\n  guardian-supervisor-strategy = ch11.GuardianSupervisorStrategyConfigurator\n }\n}\n```", "```java\nclass GuardianSupervisorStrategyConfigurator\n    extends SupervisorStrategyConfigurator {\n  override def create(): SupervisorStrategy = AllForOneStrategy() {\n    case _: LazyWorkerException ⇒\n      println(\"Lazy workers. Let's try again with another crew!\")\n      Restart\n  }\n}\n```", "```java\nlibraryDependencies += \"com.typesafe.akka\" %% \"akka-testkit\" % akkaVersion % Test\n```", "```java\nclass BakerySpec(_system: ActorSystem) extends TestKit(_system)\n    with Matchers with WordSpecLike with BeforeAndAfterAll \n    with ImplicitSender {\n\n  def this() = this(ActorSystem(\"BakerySpec\"))\n\n  override def afterAll: Unit = shutdown(system)\n```", "```java\n\"The boy should\" should {\n  val boyProps = Boy.props(system.actorSelection(testActor.path))\n  val boy = system.actorOf(boyProps)\n\n  \"forward given ShoppingList to the seller\" in {\n    val list = ShoppingList(0, 0, 0, 0)\n    boy ! list\n    within(3 millis, 20 millis) {\n      expectMsg(list)\n      lastSender shouldBe testActor\n    }\n  }\n  \"ignore other message types\" in {\n    boy ! 'GoHome\n    expectNoMessage(500 millis)\n  }\n}\n```", "```java\n\"The baker should\" should {\n  val parent = TestProbe()\n  val baker = parent.childActorOf(Props(classOf[Baker], 0 millis))\n  \"bake cookies in batches\" in {\n    val count = Random.nextInt(100)\n    baker ! RawCookies(Oven.size * count)\n    parent.expectMsgAllOf(List.fill(count)(Cookies(Oven.size)):_*)\n  }\n}\n```", "```java\nclass StoreSpec(store: Store) extends TestKit(store.store)\n    with Matchers with WordSpecLike with BeforeAndAfterAll {\n\n  def this() = this(new Store {})\n\n  override def afterAll: Unit = shutdown(system)\n\n  \"A seller in store\" should {\n    \"do nothing for all unexpected message types\" in {\n      store.seller ! 'UnexpectedMessage\n      expectNoMessage()\n    }\n    \"return groceries if given a shopping list\" in {\n      store.seller.tell(ShoppingList(1, 1, 1, 1), testActor)\n      expectMsg(Groceries(1,1,1,1))\n    }\n  }\n}\n```"]