["```java\n(0 until 100000).filter(x => x.toString == x.toString.reverse) \n\n```", "```java\n(0 until 100000).par.filter(x => x.toString == x.toString.reverse) \n\n```", "```java\n@volatile var dummy: Any = _ \ndef timed[T](body: =>T): Double = { \n  val start = System.nanoTime \n  dummy = body \n  val end = System.nanoTime \n  ((end - start) / 1000) / 1000.0 \n} \n\n```", "```java\nimport scala.collection._ \nimport scala.util.Random \nobject ParBasic extends App { \n  val numbers = Random.shuffle(Vector.tabulate(5000000)(i => i)) \n  val seqtime = timed { numbers.max } \n  log(s\"Sequential time $seqtime ms\") \n  val partime = timed { numbers.par.max } \n  log(s\"Parallel time $partime ms\") \n} \n\n```", "```java\nimport java.util.concurrent.atomic._ \nobject ParUid extends App { \n  private val uid = new AtomicLong(0L) \n  val seqtime = timed { \n    for (i <- 0 until 10000000) uid.incrementAndGet() \n  } \n  log(s\"Sequential time $seqtime ms\") \n  val partime = timed { \n    for (i <- (0 until 10000000).par) uid.incrementAndGet() \n  } \n  log(s\"Parallel time $partime ms\") \n} \n\n```", "```java\n(0 until 10000000).par.foreach(i => uid.incrementAndGet()) \n\n```", "```java\ndef nonNull(xs: Seq[T]): Seq[T] = xs.filter(_ != null) \n\n```", "```java\ndef nonNull(xs: ParSeq[T]): ParSeq[T] = xs.filter(_ != null) \n\n```", "```java\ndef nonNull(xs: GenSeq[T]): GenSeq[T] = xs.filter(_ != null) \n\n```", "```java\nimport scala.concurrent.forkjoin.ForkJoinPool \nobject ParConfig extends App { \n  val fjpool = new ForkJoinPool(2) \n  val customTaskSupport = new parallel.ForkJoinTaskSupport(fjpool) \n  val numbers = Random.shuffle(Vector.tabulate(5000000)(i => i)) \n  val partime = timed { \n    val parnumbers = numbers.par \n    parnumbers.tasksupport = customTaskSupport \n    val n = parnumbers.max \n    println(s\"largest number $n\") \n  } \n  log(s\"Parallel time $partime ms\") \n} \n\n```", "```java\nobject ParHtmlSearch extends App { \n  def getHtmlSpec() = Future { \n    val url = \"http://www.w3.org/MarkUp/html-spec/html-spec.txt\" \n    val specSrc = Source.fromURL(url) \n    try specSrc.getLines.toArray finally specSrc.close() \n  } \n  getHtmlSpec() foreach { case specDoc => \n    def search(d: GenSeq[String]): Double = \n      timed { d.indexWhere(line => line.matches(\".*TEXTAREA.*\")) } \n    val seqtime = search(specDoc) \n    log(s\"Sequential time $seqtime ms\") \n    val partime = search(specDoc.par) \n    log(s\"Parallel time $partime ms\") \n  } \n} \n\n```", "```java\ndef warmedTimed[T](n: Int = 200)(body: =>T): Double = { \n  for (_ <- 0 until n) body \n  timed(body) \n} \n\n```", "```java\ndef search(d: GenSeq[String]) = warmedTimed() { \n  d.indexWhere(line => line.matches(\".*TEXTAREA.*\")) \n} \n\n```", "```java\ndef split: Seq[Splitter[T]] \n\n```", "```java\nobject ParNonParallelizableCollections extends App { \n  val list = List.fill(1000000)(\"\") \n  val vector = Vector.fill(1000000)(\"\") \n  log(s\"list conversion time: ${timed(list.par)} ms\") \n  log(s\"vector conversion time: ${timed(vector.par)} ms\") \n} \n\n```", "```java\ndef foldLeft[S](z: S)(f: (S, T) => S): S \n\n```", "```java\nList(1, 2, 3).foldLeft(0)((acc, x) => acc + x) \n\n```", "```java\nobject ParNonParallelizableOperations extends App { \n  ParHtmlSearch.getHtmlSpec() foreach { case specDoc => \n    def allMatches(d: GenSeq[String]) = warmedTimed() { \n      val results = d.foldLeft(\"\") { (acc, line) => \n        if (line.matches(\".*TEXTAREA.*\")) s\"$acc\\n$line\" else acc \n      } \n    } \n    val seqtime = allMatches(specDoc) \n    log(s\"Sequential time - $seqtime ms\") \n    val partime = allMatches(specDoc.par) \n    log(s\"Parallel time   - $partime ms\") \n  } \n  Thread.sleep(2000) \n} \n\n```", "```java\nd.aggregate(\"\")( \n  (acc, line) => \n  if (line.matches(\".*TEXTAREA.*\")) s\"$acc\\n$line\" else acc, \n  (acc1, acc2) => acc1 + acc2 \n) \n\n```", "```java\nobject ParSideEffectsIncorrect extends App { \n  def intersectionSize(a: GenSet[Int], b: GenSet[Int]): Int = { \n    var total = 0 \n    for (x <- a) if (b contains x) total += 1 \n    total \n  } \n  val a = (0 until 1000).toSet \n  val b = (0 until 1000 by 4).toSet \n  val seqres = intersectionSize(a, b) \n  val parres = intersectionSize(a.par, b.par) \n  log(s\"Sequential result - $seqres\") \n  log(s\"Parallel result   - $parres\") \n} \n\n```", "```java\nrun-main-32: Sequential result - 250\nrun-main-32: Parallel result   - 244\n\n```", "```java\na.count(x => b contains x) \n\n```", "```java\nobject ParNonDeterministicOperation extends App { \n  ParHtmlSearch.getHtmlSpec() foreach { case specDoc => \n    val patt = \".*TEXTAREA.*\" \n    val seqresult = specDoc.find(_.matches(patt)) \n    val parresult = specDoc.par.find(_.matches(patt)) \n    log(s\"Sequential result - $seqresult\") \n    log(s\"Parallel result   - $parresult\") \n  } \n  Thread.sleep(3000) \n} \n\n```", "```java\nval index = specDoc.par.indexWhere(_.matches(patt)) \nval parresult = if (index != -1) Some(specDoc(index)) else None \n\n```", "```java\nval uid = new AtomicInteger(0) \nval f = (x: Int) => (x, uid.incrementAndGet()) \n\n```", "```java\nval g = (x: Int) => (x, uid.get) \n\n```", "```java\nval uids: GenSeq[(Int, Int)] = (0 until 10000).par.map(f) \n\n```", "```java\nobject ParNonCommutativeOperator extends App { \n  val doc = mutable.ArrayBuffer.tabulate(20)(i => s\"Page $i, \") \n  def test(doc: GenIterable[String]) { \n    val seqtext = doc.seq.reduceLeft(_ + _) \n    val partext = doc.par.reduce(_ + _) \n    log(s\"Sequential result - $seqtext\\n\") \n    log(s\"Parallel result   - $partext\\n\") \n  } \n  test(doc) \n  test(doc.toSet) \n} \n\n```", "```java\nobject ParNonAssociativeOperator extends App { \n  def test(doc: GenIterable[Int]) { \n    val seqtext = doc.seq.reduceLeft(_ - _) \n    val partext = doc.par.reduce(_ - _) \n    log(s\"Sequential result - $seqtext\\n\") \n    log(s\"Parallel result   - $partext\\n\") \n  } \n  test(0 until 30) \n} \n\n```", "```java\ndef aggregate[S](z: S)(sop: (S, T) => S, cop: (S, S) => S): S \n\n```", "```java\nobject ConcurrentWrong extends App { \n  import ParHtmlSearch.getHtmlSpec \n  import ch4.FuturesCallbacks.getUrlSpec \n  def intersection(a: GenSet[String], b: GenSet[String]) = { \n    val result = new mutable.HashSet[String] \n    for (x <- a.par) if (b contains x) result.add(x) \n    result \n  } \n  val ifut = for { \n    htmlSpec <- getHtmlSpec() \n    urlSpec <- getUrlSpec() \n  } yield { \n    val htmlWords = htmlSpec.mkString.split(\"\\\\s+\").toSet \n    val urlWords = urlSpec.mkString.split(\"\\\\s+\").toSet \n    intersection(htmlWords, urlWords) \n  } \n  ifut onComplete { case t => log(s\"Result: $t\") } \n  Thread.sleep(3000) \n} \n\n```", "```java\nimport java.util.concurrent.ConcurrentSkipListSet \nimport scala.collection.convert.decorateAsScala._ \ndef intersection(a: GenSet[String], b: GenSet[String]) = { \n  val skiplist = new ConcurrentSkipListSet[String] \n  for (x <- a.par) if (b contains x) skiplist.add(x) \n  val result: Set[String] = skiplist.asScala \n  result \n} \n\n```", "```java\nobject ConcurrentTrieMap extends App { \n  val cache = new concurrent.TrieMap[Int, String]() \n  for (i <- 0 until 100) cache(i) = i.toString \n  for ((number, string) <- cache.par) cache(-number) = s\"-$string\" \n  log(s\"cache - ${cache.keys.toList.sorted}\") \n} \n\n```", "```java\nclass ParString(val str: String) extends immutable.ParSeq[Char] { \n  def apply(i: Int) = str.charAt(i) \n  def length = str.length \n  def splitter = new ParStringSplitter(str, 0, str.length) \n  def seq = new collection.immutable.WrappedString(str) \n} \n\n```", "```java\ntrait IterableSplitter[T] extends Iterator[T] { \n  def dup: IterableSplitter[T] \n  def remaining: Int \n  def split: Seq[IterableSplitter[T]] \n} \n\n```", "```java\ntrait SeqSplitter[T] extends IterableSplitter[T] { \n  def psplit(sizes: Int*): Seq[SeqSplitter[T]] \n} \n\n```", "```java\nclass ParStringSplitter \n  (val s: String, var i: Int, val limit: Int) \nextends SeqSplitter[Char] { \n\n```", "```java\n  final def hasNext = i < limit \n  final def next = { \n    val r = s.charAt(i) \n    i += 1 \n    r \n  } \n\n```", "```java\n  def dup = new ParStringSplitter(s, i, limit) \n  def remaining = limit - i \n\n```", "```java\n  def split = { \n    val rem = remaining \n    if (rem >= 2) psplit(rem / 2, rem - rem / 2) \n    else Seq(this) \n  } \n\n```", "```java\n  def psplit(sizes: Int*): Seq[ParStringSplitter] = { \n    val ss = for (sz <- sizes) yield { \n      val nlimit = (i + sz) min limit \n      val ps = new ParStringSplitter(s, i, nlimit) \n      i = nlimit \n      ps \n    } \n    if (i == limit) ss \n    else ss :+ new ParStringSplitter(s, i, limit) \n  } \n} \n\n```", "```java\nobject CustomCharCount extends App { \n  val txt = \"A custom text \" * 250000 \n  val partxt = new ParString(txt) \n  val seqtime = warmedTimed(50) { \n    txt.foldLeft(0) { (n, c) => \n      if (Character.isUpperCase(c)) n + 1 else n \n    } \n  } \n  log(s\"Sequential time - $seqtime ms\") \n  val partime = warmedTimed(50) { \n    partxt.aggregate(0)( \n      (n, c) => if (Character.isUpperCase(c)) n + 1 else n, \n      _ + _) \n  } \n  log(s\"Parallel time   - $partime ms\") \n} \n\n```", "```java\ntrait Builder[T, Repr] { // simplified interface \n  def +=(x: T): Builder[T, Repr] \n  def result: Repr \n  def clear(): Unit \n} \n\n```", "```java\ndef newBuilder: Builder[T, Traversable[T]] \ndef filter(p: T => Boolean): Traversable[T] = { \n  val b = newBuilder \n  for (x <- this) if (p(x)) b += x \n  b.result \n} \n\n```", "```java\ntrait Combiner[T, Repr] extends Builder[T, Repr] { \n  def size: Int \n  def combine[N <: T, NewRepr >: Repr] \n    (that: Combiner[N, NewRepr]): Combiner[N, NewRepr] \n} \n\n```", "```java\nclass ParStringCombiner extends Combiner[Char, ParString] { \n  private val chunks = new ArrayBuffer += new StringBuilder \n  private var lastc = chunks.last \n  var size = 0 \n  def +=(elem: Char) = { \n    lastc += elem \n    size += 1 \n    this \n  } \n\n```", "```java\n  def combine[N <: Char, NewRepr >: ParString] \n    (that: Combiner[U, NewTo]) = { \n    if (this eq that) this else that match { \n      case that: ParStringCombiner => \n        size += that.size \n        chunks ++= that.chunks \n        lastc = chunks.last \n        this \n  } \n\n```", "```java\n  def result: ParString = { \n    val rsb = new StringBuilder \n    for (sb <- chunks) rsb.append(sb) \n    new ParString(rsb.toString) \n  } \n} \n\n```", "```java\nval txt = \"A custom txt\" * 25000 \nval partxt = new ParString(txt) \nval seqtime = warmedTimed(250) { txt.filter(_ != ' ') } \nval partime = warmedTimed(250) { partxt.filter(_ != ' ') } \n\n```", "```java\n                class BinomialHeap[T] extends Iterable[T] { \n                  def insert(x: T): BinomialHeap[T] \n                  def remove: (T, BinomialHeap[T]) \n                  def smallest: T \n                  def merge(that: BinomialHeap[T]): BinomialHeap[T] \n                } \n\n    ```"]