<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Future Directions</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">In the last chapter, we focused on best practices with some exciting utilities provided by the Java 9 platform. Specifically, we covered</span> <span class="calibre7">UTF-8 Property Files,</span> <span class="calibre7">Unicode 7.0.0,</span> <span class="calibre7">Linux/AArch64 port,</span> m<span class="calibre7">ulti-resolution images, and</span> c<span class="calibre7">ommon locale data repository.</span></p>
<p class="mce-root">This chapter provides an overview of the future development of the Java platform, beyond Java 9. We will look at what is planned for Java 10 and what further changes we are likely to see in the future. Each potential change to the Java platform will be characterized as targeted, submitted, or drafted. Targeted refers to changes that have been earmarked for Java 10. Submitted refers to a change that has been submitted but does not target a specific version of the Java platform. Changes that are drafted are still on the drawing board and are not ready to be submitted or designated as targeted.</p>
<p class="mce-root"/>
<p class="mce-root">Specifically, this chapter covers future changes to the Java platform grouped in the following categories:</p>
<ul class="calibre13">
<li class="calibre14">JDK changes</li>
<li class="calibre14">Java Compiler</li>
<li class="calibre14">Java Virtual Machine</li>
<li class="calibre14">JavaX</li>
<li class="calibre14">Special projects</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Future Changes to the JDK</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Java Development Kit is at core of the Java platform and is continually being updated with new capabilities and efficiencies realized with each release. Looking beyond Java 9, we see a multitude of possible changes to the JDK. Many of these changes will be implemented in Java 10 and others might be saved for later releases.</p>
<p class="mce-root">The changes to the JDK in Java 10 and beyond are presented in the following proposal categories:</p>
<ul class="calibre13">
<li class="calibre14">Targeted for Java 10</li>
<li class="calibre14">Submitted Proposals</li>
<li class="calibre14">Drafted Proposals</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">JDK changes targeted for Java 10</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">At the time of this book's publication, the following listed <strong class="calibre8">Java Development Kit</strong> (<strong class="calibre8">JDK</strong>)-related changes were slated for inclusion in the Java 10 platform:</p>
<ul class="calibre13">
<li class="calibre14">Repository consolidation</li>
<li class="calibre14">Native-Header Tool Removal</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Repository consolidation</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Java 9 platform consists of eight distinct repositories as depicted in the following diagram. In Java 10, we should see all of these repositories combined into a single repository:</p>
<div class="mce-root1"><img src="Images/3c694ace-8226-444c-9b43-eacaa4f87bf6.png" width="1124" height="816" class="calibre161"/></div>
<p class="mce-root">Repository consolidation should help streamline development. Moreover, it should increase the ease of maintaining and updating the Java platform.</p>
<div class="packt_infobox">You can get an early look at this repository at <a href="http://hg.openjdk.java.net/jdk10/consol-proto/" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1">http://hg.openjdk.java.net/jdk10/consol-proto/</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Native-header tool removal</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The javah tool is used to generate C header files and C source files from Java classes. C programs can reference the generated header files and source files.</p>
<p class="mce-root">Here is a look at the life and death of t<span class="calibre7">he</span> javah <span class="calibre7">tool:</span></p>
<div class="mce-root1"><img src="Images/5be7c7bf-069b-4886-93b6-d6a957d43195.png" width="1330" height="1062" class="calibre162"/></div>
<p class="mce-root">As illustrated earlier, the javah tool was introduced with Java 7 and its functionality was included in the javac that came with JDK8. This functionality was reportedly superior compared to that of the original tool. In JDK 9, developers received warnings each time the javah tool was used, informing them of its pending removal from the JDK. The tool is slated for removal in JDK 10.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">JDK-related submitted proposals</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The following Java Enhancement Proposals have been submitted, but have not yet been committed for delivery as part of the Java 10 platform. Oracle has set a two-year release plan, so it is safe to assume that, many if not all, of the proposals listed in this section and beyond have a chance of being part of the Java 10 platform:</p>
<ul class="calibre13">
<li class="calibre14"><span class="calibre5">Parallelize the Full GC Phase in CMS</span></li>
<li class="calibre14"><span class="calibre5">REST APIs for JMX</span></li>
<li class="calibre14"><span class="calibre5">Support Heap Allocation</span></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Parallelize the Full GC Phase in CMS</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In <a href="" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 7</a>, <em class="calibre20">Leveraging the New Default G1 Garbage Collector</em>, we reviewed the changes to the <strong class="calibre8">Concurrent Mark Sweep</strong> (<strong class="calibre8">CMS</strong>) garbage collector. CMS garbage collection involves scanning <span class="calibre7">heap memory, marking objects for removal and then making a sweep to actually remove those objects. The CMS method of garbage collection is essentially an upgraded "Mark and Sweep" method; which you can refer to <a href="" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 7</a>, <em class="calibre20">Leveraging the New Default G1 Garbage Collector</em></span>, <span class="calibre7">for additional</span> information.</p>
<p class="mce-root">The current downside to CMS garbage collection is that the serial mark and sweep is implemented using a single thread. This results in unwanted pause times. Currently, full garbage collection takes place in four phases:</p>
<ul class="calibre13">
<li class="calibre14"><strong class="calibre3">Marking phase</strong>: Mark objects for collection</li>
<li class="calibre14"><strong class="calibre3">Forwarding phase</strong>: Determine where live objects will be relocated</li>
<li class="calibre14"><strong class="calibre3">Adjust pointer phase</strong>: Updates points based on new locations of live objects</li>
<li class="calibre14"><strong class="calibre3">Compaction phase</strong>: Moves objects to designated locations</li>
</ul>
<p class="mce-root">The future plan for CMS is to implement the mark and sweep so they can be performed in parallel. The change is not to the garbage collection algorithm. Instead, each of the above listed phases will be parallelized. This will result in greater efficiencies for CMS garbage collection and hopefully eliminate, or significantly reduce, pause times.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">REST APIs for JMX</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre8">Representational State Transfer</strong> (<strong class="calibre8">REST</strong>), RESTful programming, and RESTful API use a client/server cacheable communications protocol, usually HTTP. REST is a common software architecture for developing networked applications.</p>
<p class="mce-root">One of the future changes to the Java platform is to provide RESTful web interfaces to MBeans.</p>
<div class="packt_infobox"><strong class="calibre3">Managed Bean</strong> (<strong class="calibre3">MBean</strong>) is an object in Java that represents a resource to be managed. These resources could include a specific hardware device, an application, a service, or other component.</div>
<p class="mce-root"><span class="calibre7">The interfaces will permit MBeans to use the following HTTP methods:</span></p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">CONNECT</kbd></li>
<li class="calibre14"><kbd class="calibre16">DELETE</kbd></li>
<li class="calibre14"><kbd class="calibre16">GET</kbd></li>
<li class="calibre14"><kbd class="calibre16">HEAD</kbd></li>
<li class="calibre14"><kbd class="calibre16">OPTIONS</kbd></li>
<li class="calibre14"><kbd class="calibre16">POST</kbd></li>
<li class="calibre14"><kbd class="calibre16">PUT</kbd></li>
<li class="calibre14"><kbd class="calibre16">TRACE</kbd></li>
</ul>
<p class="mce-root">MBeans are managed using <strong class="calibre8">Java Management Extensions</strong> (<strong class="calibre8">JMX</strong>). The JMX architecture has three levels, as depicted in the following diagram:</p>
<div class="mce-root1"><img src="Images/217c6d35-3906-4960-8d05-9975e27ce9d1.png" width="1428" height="1108" class="calibre163"/></div>
<p class="mce-root">As you can see, the REST adapter is part of the <strong class="calibre8">Distributed Services</strong> level. That level contains both connectors and adapters. The connectors provide mirroring of agent level interfaces to remote clients. The adapters, on the other hand, convert the interfaces using a different protocol. The future change will be to transform the services at the <strong class="calibre8">Agent</strong> level to REST APIs.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Support heap allocation</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A proposed future change is to allow developers to designate alternate memory devices for the Java heap. Specifically, the proposal is to permit developers to designate non-DRAM memory for the Java heap. This change takes advantage of the decreasing cost of memory and memory devices.</p>
<p class="mce-root">Implementation is likely to use an <kbd class="calibre16">AllocateHeapAt</kbd> flag.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">JDK-related drafted proposals</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This section covers several JDK-related proposals that, at the time of this book's publication, were in the draft phase. That suggests they might not be fully analyzed or might even be cancelled. That being said, it is likely that each of these will move from drafted, to submitted, and then to targeted for the Java 10 platform.</p>
<p class="mce-root">Draft proposals covered in this section are as follows:</p>
<ul class="calibre13">
<li class="calibre14">Finalization promptness</li>
<li class="calibre14"><span class="calibre5">Java memory model</span></li>
<li class="calibre14">Foreign function interface</li>
<li class="calibre14">Isolated methods</li>
<li class="calibre14">Reduce metaspace waste</li>
<li class="calibre14"><span class="calibre5">Improve IPv6 support</span></li>
<li class="calibre14"><span class="calibre5">Unboxed argument lists for method handles</span></li>
<li class="calibre14"><span class="calibre5">Enhanced MandelblotSet Demo Using Value Types</span></li>
<li class="calibre14"><span class="calibre5">Efficient Array Comparison Intrinsics</span></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Finalization promptness</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Java language includes finalization to clean up objects that were unreachable by garbage collection. The proposed change is to make this process quicker and will require modifications to the following:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">ReferenceHandleThread</kbd></li>
<li class="calibre14"><kbd class="calibre16">FinalizerThread</kbd></li>
<li class="calibre14"><kbd class="calibre16">java.lang.ref.Reference</kbd></li>
</ul>
<p class="mce-root">Additional changes related to increasing the promptness of finalization includes the creation of a new API. The following graphic details how the API will be able to implement GC and runtime actions, and then inform that finalization needs to take place. This certainly should result in faster processing:</p>
<div class="mce-root1"><img src="Images/5117550c-69cb-4f63-bdd4-d4b186274a98.png" width="1782" height="654" class="calibre164"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Java memory model</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There is a continuing effort to keep <strong class="calibre8">Java's memory model</strong> (<strong class="calibre8">JMM</strong>) updated. Current efforts are focused on several areas to include:</p>
<ul class="calibre13">
<li class="calibre14">Shared memory concurrency</li>
<li class="calibre14">JVM concurrency support</li>
<li class="calibre14">JDK components</li>
<li class="calibre14">Tools</li>
</ul>
<p class="mce-root">Expected results of JMM-related engineering efforts are as follows:</p>
<ul class="calibre13">
<li class="calibre14">Improved formalization</li>
<li class="calibre14">JVM voverage</li>
<li class="calibre14">Extended scope</li>
<li class="calibre14">C11/C++11 compatibility</li>
<li class="calibre14">Implementation guidance</li>
<li class="calibre14">Testing support</li>
<li class="calibre14">Tool support</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Foreign Function Interfaces</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre8">Foreign Function Interfaces</strong> (<strong class="calibre8">FFI</strong>) are software APIs that permits programs to call methods/functions from a program written in a different language. In an upcoming version of the JDK, we are apt to see an FFI that allows developers to call upon shared libraries and operating-system kernels directly from java methods. The proposed FFI will reportedly also enable developers to manage native memory blocks.</p>
<p class="mce-root">The new FFI will be similar to <strong class="calibre8">Java Native Access</strong> (<strong class="calibre8">JNA</strong>) and <strong class="calibre8">Java Native Runtime</strong> (<strong class="calibre8">JNR</strong>). JNA is a library that permits access to native shared libraries without having to use the <strong class="calibre8">Java Native Interface</strong> (<strong class="calibre8">JNI</strong>). JNR is a Java API that is used for calling native code. The proposed FFI will permit and optimize native method calls as well as optimized native memory management.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Isolated methods</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">MethodHandles.Lookup</kbd> class is part of the <kbd class="calibre16">java.lang.invoke</kbd> package. We use lookup objects to create method handles and a lookup class to access them. Here is the header for the lookup class:</p>
<pre class="calibre21">    public static final class MethodHandles.Lookup extends Object</pre>
<p class="mce-root">Future changes to the <kbd class="calibre16">MethodHandles.Lookup</kbd> <span class="calibre7">class will support the loading of method</span> byte codes without the need for an attached class. Furthermore, these methods will be referenced using method handles. The class will have a new <kbd class="calibre16">loadCode</kbd> method.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Reducing metaspace waste</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Currently, when metaspace chunks are freed, they cannot be used as different sized chunks. So, if metaspace chunk A was freed and was of size X, that space cannot be reused for a metaspace chunk greater than or less than size X. This results in a tremendous amount of unusable metaspace waste. This can also lead to out-of-memory errors.</p>
<p class="mce-root">A future change to the JDK will resolve this issue by increasing the reuse of metaspace chunks. The change will support the following cases:</p>
<ul class="calibre13">
<li class="calibre14">Allow neighboring chunks to form a larger chunk</li>
<li class="calibre14">Allow larger chunks to be divided into smaller chunks</li>
</ul>
<p class="mce-root">This proposed change resolves the issue by ensuring smaller chunks can be reused and that larger chunks are not wasted as they can be split to support the reuse of smaller chunks.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Improving IPv6 support</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre8">Internet Protocol version 6</strong> (<strong class="calibre8">IPv6</strong>) is the current version of the Internet Protocol. The Internet Protocol provides the identification and location schema that enables Internet traffic routing. IPv6 is considered an Internet layer protocol that is sued by packet-switched networking.</p>
<p class="mce-root">The following diagram shows the history of the Internet Protocol:</p>
<div class="mce-root1"><img src="Images/6692a822-c0aa-4b91-8ca9-d73e492166dc.png" width="1926" height="1018" class="calibre165"/></div>
<p class="mce-root">IPv6 is the replacement for IPv4 and has several changes that the Java platform should support. Key IPv6 changes from IPv4 are categorized as follows:</p>
<ul class="calibre13">
<li class="calibre14">Jumbograms</li>
<li class="calibre14">Larger address space</li>
<li class="calibre14">Mobility</li>
<li class="calibre14">Multicasting</li>
<li class="calibre14">Network-layer security</li>
<li class="calibre14">Options extensibility</li>
<li class="calibre14">Privacy</li>
<li class="calibre14">Simplified router processing</li>
<li class="calibre14">Stateless address auto-configuration</li>
</ul>
<p class="mce-root">As the Internet continues to transition from IPv4 to IPv6, the following cases are possible and should all be supported in the Java 10 platform:</p>
<ul class="calibre13">
<li class="calibre14">Multiple versions of IPv4 exist</li>
<li class="calibre14">One version of IPv6 exists</li>
<li class="calibre14">Multiple versions of IPv6 exist</li>
<li class="calibre14">Multiple versions of IPv4 and one version of IPv6 exist</li>
<li class="calibre14">Multiple versions of IPv4 and IPv6 exist</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Unboxed argument lists for method handles</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The way in which unboxed argument lists are currently handled can lead to processing inefficiencies. This is especially true when we use <kbd class="calibre16">Object[]</kbd> or <kbd class="calibre16">List&lt;object&gt;</kbd> as variable-length argument lists. Java uses <kbd class="calibre16">java.lang.invoke</kbd> to transform the method calls using boxing. In Java, autoboxing is when the compiler automatically converts primitive types and their corresponding object wrapper classes. Here is the list of wrapper classes along with the corresponding primitive type:</p>
<table class="calibre30">
<tbody class="calibre31">
<tr class="calibre32">
<td class="calibre33"><strong class="calibre3">Wrapper class</strong></td>
<td class="calibre33"><strong class="calibre3">Primitive type</strong></td>
</tr>
<tr class="calibre34">
<td class="calibre33">Boolean</td>
<td class="calibre33">boolean</td>
</tr>
<tr class="calibre32">
<td class="calibre33">Byte</td>
<td class="calibre33">byte</td>
</tr>
<tr class="calibre34">
<td class="calibre33">Character</td>
<td class="calibre33">char</td>
</tr>
<tr class="calibre32">
<td class="calibre33">Double</td>
<td class="calibre33">double</td>
</tr>
<tr class="calibre34">
<td class="calibre33">Float</td>
<td class="calibre33">float</td>
</tr>
<tr class="calibre32">
<td class="calibre33">Integer</td>
<td class="calibre33">int</td>
</tr>
<tr class="calibre34">
<td class="calibre33">Long</td>
<td class="calibre33">long</td>
</tr>
<tr class="calibre41">
<td class="calibre33">Short</td>
<td class="calibre33">short</td>
</tr>
</tbody>
</table>
<p class="mce-root"> </p>
<p class="mce-root">As you can see from the following illustration autoboxing occurs when we go from primitive values to an object of the associated wrapper class and, when we go from an object of a wrapper class to primitive values it is called unboxing:</p>
<div class="mce-root1"><img src="Images/03f1f047-e14b-4bc4-bd1c-e6d75f2530ab.png" width="1200" height="1048" class="calibre166"/></div>
<p class="mce-root">The inefficiencies are due to mismatches between the argument's list actual types and the array or list encasing them. In a future Java release, these inefficiencies will be removed. A new <kbd class="calibre16">ArgumentList</kbd> class will be added to the Java platform that polymorphically boxes valid arguments lists into a heap node.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Enhanced MandelblotSet demo using value types</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This low priority Java Enhancement Proposal is likely to be implemented in Java 10 as its scope is limited. The plan is to develop a sample Java application that demonstrates improvements in memory and performance specific to using Valhalla project components, value types, and generics instead of primitive types.</p>
<div class="packt_infobox">Valhalla project components refer to user-defined custom immutable primitive types as value types.</div>
<p class="mce-root">You can read more about value types in the Java Virtual Machine section of this chapter.</p>
<p class="mce-root">A Mandelbrot set is a specific example of fractal mathematics used in chaos theory. The sample MandelbrotSet that accompanied JDK 8 provides a comparison of parallel and sequential data streams. In Java 10 or beyond, the sample MandelbrotSet will be updated to show performance and memory efficiencies between using Valhalla project components, value types and generics as opposed to primitive types.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Efficient array comparison intrinsics</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A future change to the Java platform will be to include a method for comparing arrays. Currently, this is something developers have to code on their own. The change will be incorporated by adding something similar to the <kbd class="calibre16">compareTo</kbd> method in <kbd class="calibre16">java.util.Arrays</kbd>.</p>
<p class="mce-root">Although specifics are not available, the prospect of being able to compare arrays using native functionality is exciting. This is a component that will save many developers time. This is likely to be realized in the Java 10 platform release.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Future changes to the Java Compiler</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There are two notable draft changes to the Java platform, specifically the Java Compiler. These Java Enhancement Proposals are listed as follows and detailed in this section:</p>
<ul class="calibre13">
<li class="calibre14">Policy for retiring javac <kbd class="calibre16">-source</kbd> and <kbd class="calibre16">-target</kbd> options</li>
<li class="calibre14">Pluggable static analyzers</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Policy for retiring javac -source and -target options</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A formal draft proposal has been submitted to define a policy for retiring <kbd class="calibre16">-source</kbd> and <kbd class="calibre16">-target</kbd> options. This effort is to help reduce maintenance costs of the compiler. The <kbd class="calibre16">-source</kbd> and <kbd class="calibre16">-target</kbd> options were provided to ease development efforts, but not formally required by any standards. Starting with the Java 9 platform, these target options are not recognized.</p>
<p class="mce-root">The new policy is called "one plus three back" which means that the current version will be supported as well as the three previous releases. This policy will persist with JDK 10.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Pluggable static analyzers</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">An ongoing research Java Enhancement Proposal was initiated in the summer of 2013 as an exploratory measure and future support for a full Java Enhancement Proposal to empower developers to define extensions that can, at compile time, conduct the arbitrary static analysis. The research is to see how <span class="calibre7">a pluggable static type analyzer framework can be</span> implemented for the Java Compiler.</p>
<p class="mce-root">The goals of the research are as follows:</p>
<ul class="calibre13">
<li class="calibre14">Collect static analyzer requirements</li>
<li class="calibre14">Analyze static analyzers</li>
<li class="calibre14">Determine the requirements for a framework that supports static analyzers</li>
<li class="calibre14">Implement and test</li>
</ul>
<p class="mce-root">The final outcome of the ongoing research will be either to submit a feature Java Enhancement Proposal or to make the recommendation that pursuit of the feature cease.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Future Changes to the Java Virtual Machine</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Several new features and enhancements to the Java Virtual Machine (JVM) and core libraries have been submitted and drafted. It is likely that at least some of these features and enhancements will be realized in the Java 10 platform, and others will be saved for later releases.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">JVM-related submitted proposals</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There are three Java Enhancement Proposals that have been submitted. While, not currently earmarked for Java 10, it is likely that we will see the changes when Java 10 is released. The three proposals are listed as follows:</p>
<ul class="calibre13">
<li class="calibre14"><span class="calibre5">Container aware Java</span></li>
<li class="calibre14"><span class="calibre5">Enable execution of Java methods on GPU</span></li>
<li class="calibre14"><span class="calibre5">Epsilon GC: The arbitrarily low overhead gGarbage (non-) collector</span></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Container aware Java</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">An effort is being made so the JVM and core libraries are aware when they are running in a container. Moreover, to be adaptive in the use of available system resources. This feature is especially relevant with the ubiquitous nature of cloud computing.</p>
<p class="mce-root">There are two major components of the proposed feature:</p>
<ul class="calibre13">
<li class="calibre14">Detection:
<ul class="calibre13">
<li class="calibre14">Determine if Java is running inside a container</li>
</ul>
</li>
<li class="calibre14">Container resource exposure:
<ul class="calibre13">
<li class="calibre14">Expose container resources limits</li>
<li class="calibre14">Expose container resource configuration</li>
</ul>
</li>
</ul>
<p class="mce-root">Several configuration status points have been initially identified:</p>
<table class="calibre30">
<tbody class="calibre31">
<tr class="calibre32">
<td class="calibre33"><strong class="calibre3">General</strong></td>
<td class="calibre33"><strong class="calibre3">CPU-related</strong></td>
<td class="calibre33"><strong class="calibre3">Memory-related</strong></td>
</tr>
<tr class="calibre34">
<td class="calibre33"><kbd class="calibre16">isContainerized</kbd></td>
<td class="calibre33">CPU Period</td>
<td class="calibre33">Block I/O Device Weight</td>
</tr>
<tr class="calibre32">
<td class="calibre33"/>
<td class="calibre33">CPU <span class="calibre5">Quota</span></td>
<td class="calibre33">Block I/O Weight</td>
</tr>
<tr class="calibre34">
<td class="calibre33"/>
<td class="calibre33">CPU Set Memory Nodes</td>
<td class="calibre33">Current Memory Usage</td>
</tr>
<tr class="calibre32">
<td class="calibre33"/>
<td class="calibre33">CPU Sets</td>
<td class="calibre33"><span class="calibre5">Device I/O Read Rate</span></td>
</tr>
<tr class="calibre34">
<td class="calibre33"/>
<td class="calibre33">CPU Usage</td>
<td class="calibre33"><span class="calibre5">Device I/O Write Rate</span></td>
</tr>
<tr class="calibre32">
<td class="calibre33"/>
<td class="calibre33">CPU Usage Per CPU</td>
<td class="calibre33">Max Memory Usage</td>
</tr>
<tr class="calibre34">
<td class="calibre33"/>
<td class="calibre33">Number of CPUs</td>
<td class="calibre33">Maximum Kernal Memory</td>
</tr>
<tr class="calibre32">
<td class="calibre33"/>
<td class="calibre33"/>
<td class="calibre33">Memory Swappiness</td>
</tr>
<tr class="calibre34">
<td class="calibre33"/>
<td class="calibre33"/>
<td class="calibre33">OOM Kill Enabled</td>
</tr>
<tr class="calibre32">
<td class="calibre33"/>
<td class="calibre33"/>
<td class="calibre33">OOM Score Adjustment</td>
</tr>
<tr class="calibre34">
<td class="calibre33"/>
<td class="calibre33"/>
<td class="calibre33">Shared Memory Size</td>
</tr>
<tr class="calibre32">
<td class="calibre33"/>
<td class="calibre33"/>
<td class="calibre33">Soft Memory Limit</td>
</tr>
<tr class="calibre35">
<td class="calibre33"/>
<td class="calibre33"/>
<td class="calibre33">Total Memory Limit</td>
</tr>
</tbody>
</table>
<p class="mce-root"> </p>
<p class="mce-root">Initially, this feature is scheduled to support Docker on Linux-64. A likely scenario is that this feature be released with Java 10 with sole support for Docker on Linux-64. Then, feature support will be expanded in subsequent releases of the Java platform.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Enable execution of Java methods on GPU</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Enabling the seamless ability for Java applications to take advantage of GPUs is the subject of project Sumatra. The goal is to use Java's Stream API in parallel and the lambda programming model. It makes great sense for us to exploit the processing power and efficiency of GPUs.</p>
<p class="mce-root">The overarching goal is to make this feature easy to use for developers. The feature will be implemented with the following characteristics:</p>
<ul class="calibre13">
<li class="calibre14">Do not change the syntax of the Java parallel stream API</li>
<li class="calibre14">Hardware and software stacks should be automatically detected</li>
<li class="calibre14">Automatic detection and analysis to determine if using the GPU makes sense from a performance standard</li>
<li class="calibre14">Provide CPU execution when offloading processing to a GPU fails</li>
<li class="calibre14">There will be no performance degradation</li>
<li class="calibre14">There will be no new security risks introduced by this feature</li>
<li class="calibre14">There will be memory persistence between the CPU and GPU</li>
</ul>
<p class="mce-root">The key benefit of this Java Enhancement Proposal will be performance improvements for our Java applications.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Epsilon GC - The arbitrarily low overhead garbage (non-) collector</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In <a href="" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 7</a>, <em class="calibre20">Leveraging the New Default G1 Garbage Collector</em>, we detailed the enhancements to Java's Garbage Collection with the release of the Java 9 platform. In the spirit of continuous improvement, a Java Enhancement Proposal has been submitted to develop a garbage collection to specifically handle memory allocation. This garbage collector will signal the JVM to shutdown when no more memory is available on the Java heap.</p>
<p class="mce-root">The goal is for this garbage collector to be passive and use very limited overhead. The introduction of this garbage collection is not intended to degrade performance.</p>
<p class="mce-root">This change will not impact current garbage collectors.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">JVM-related drafted proposals</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The following Java Enhancement Proposals have been drafted for a future version of the Java platform and are detailed in this section:</p>
<ul class="calibre13">
<li class="calibre14"><span class="calibre5">Provide stable USDT probe points on JVM compiled methods</span></li>
<li class="calibre14">Concurrent Monitor Deflation</li>
<li class="calibre14">Low-overhead way of sampling Java heap allocations</li>
<li class="calibre14">Diagnostic Command Framework</li>
<li class="calibre14">Enhanced Class Redefinition</li>
<li class="calibre14">Enable NUMA mode by default when appropriate</li>
<li class="calibre14">Value objects</li>
<li class="calibre14">Align JVM Access Checks</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Provide stable USDT probe points on JVM compiled methods</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre8">User-level Statistically Defined Tracing</strong> (<strong class="calibre8">USDT</strong>) is used to insert probe points to mark the entry and exit of methods. Compilers then permit a handshake with tracing tools so that those tools can discover the probe points and manipulate them.</p>
<div class="packt_tip">Common tracing tools are Dtrace and <strong class="calibre3">Berkeley Packet Filters</strong> (<strong class="calibre3">BPF</strong>).</div>
<p class="mce-root">The Java Virtual Machine, even with JVM 9, does not support this technology set. The current lack of support stems from how the JVM generates compiled code; it does this dynamically without any static <strong class="calibre8">Executable Linkable Files</strong> (<strong class="calibre8">ELFs</strong>). Tracing tools need the ELFs to work. An additional mitigating factor is that the JVM dynamically patches its own generated code which does not support external patching.</p>
<p class="mce-root">In a future Java release, likely Java 10, the <strong class="calibre8">JVMTI</strong> (<strong class="calibre8">JVM Tools Interface</strong>) will be modified to support probe tools to perform their standard operations on the JVM's dynamically compiled code. Provisionally identified changes to JVMTI APIs include:</p>
<ul class="calibre13">
<li class="calibre14">Adding patch points or method entry and exit</li>
<li class="calibre14">The enumeration of the compiled methods</li>
<li class="calibre14">State change notifications on compiled method load</li>
<li class="calibre14">Query support</li>
<li class="calibre14">Toggle trace points on/off</li>
<li class="calibre14">Making chunks of compiled methods inspectable</li>
</ul>
<p class="mce-root">The good news is that there will not need to be any changes to how Java code is compiled. It can already be patched, so the required functionality will be created by modifying the USDT API as well as a few changes to the JVM.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Concurrent monitor deflation</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A monitor, in our context, is a synchronized mechanism that controls concurrent access to an object. Monitors help prevent multiple threads from accessing a monitored object at the same time. The JVM automatically switches between three monitor implementation methods. The three implementation methods are illustrated as follows:</p>
<div class="mce-root1"><img src="Images/6b8f06da-86a0-4a04-95c8-fbb2a419f68c.png" width="1312" height="1080" class="calibre167"/></div>
<p class="mce-root">The initial lock of a Java object uses biased locking. That method ensures only the locking thread can lock the object. With this approach, the JVM installs a thread pointer in the Java object. When a second thread attempts to lock the Java object, the JVM switches to the basic locking monitor implementation method. This second method uses <strong class="calibre8">compare-and-swap</strong> (<strong class="calibre8">CAS</strong>) operations. When a CAS operation fails, such as when a second thread attempt to lock the Java object, the JVM switches to the third monitor implementation method. That method is a full-blown monitor. This method requires native heap storage which is referred to as the monitor being inflated.</p>
<p class="mce-root">The purpose of the Concurrent Monitor Deflation Java Enhancement Proposal is to perform monitor deflation while the threads are running. This will decrease the JVM-induced pause times.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Provide a low-overhead way of sampling Java heap allocations</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Mismanagement of Java heaps can result in heap exhaustion, and insufficient memory due to memory fragmentation (GC thrashing). In a future release of Java, most likely Java 10, we will have a means of sampling Java heap allocations. This will be implemented by enhancing the <strong class="calibre8">Java Virtual Machine Tools Interface</strong> (<strong class="calibre8">JVMTI</strong>). The resulting functionality will provide an extremely low-overhead solution.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Diagnostic Command Framework</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Java Enhancement Proposal 137, Diagnostic Command Framework, proposes a framework be created for sending diagnostic commands to the Java Virtual Machine.</p>
<p class="mce-root">The framework will include a <strong class="calibre8">Java Management Extension</strong> (JMX) interface, which will permit remote issuing of diagnostic commands via a JMX connection.</p>
<p class="mce-root">The JRocket Mission Control tools already have this feature successfully implemented. This served as proof of concept and it is therefore extremely likely that this enhancement will be part of the Java 10 platform.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Enhanced Class Redefinition</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">Java Enhancement Proposal 159, Enhanced Class Redefinition, calls for enhanced JVM capabilities in regards to class redefinition at runtime. Specifically the proposal includes the following class redefinition operations:</span></p>
<ul class="calibre13">
<li class="calibre14">Adding super types</li>
<li class="calibre14">Adding methods</li>
<li class="calibre14">Adding static fields</li>
<li class="calibre14">Adding instance fields</li>
<li class="calibre14">Removing methods</li>
<li class="calibre14">Removing static fields</li>
<li class="calibre14">Removing instance fields</li>
</ul>
<p class="mce-root">Current JVM class redefinition capabilities are limited to method swapping. This is viewed as extremely restrictive. With the new proposed enhancement, developers will not have to restart their applications after changes. This is especially beneficial when dealing with large and distributed systems.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Enable NUMA mode by default when appropriate</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">Java Enhancement Proposal 163, enable NUMA mode by default when appropriate. This proposal is only applicable to NUMA hardware. The intent is to have the JVM enable the following flag when it detects NUMA hardware:</span></p>
<pre class="calibre21">    XX:+UseNUMA</pre>
<p class="mce-root">This flag can currently be evoked manually. With the proposed enhancement, it will be evoked automatically by the JVM when it has detected that it is running on a NUMA piece of hardware.</p>
<div class="packt_infobox"><strong class="calibre3">Non-Uniform Memory Access</strong> (<strong class="calibre3">NUMA</strong>) is a memory model used in computer multiprocessing. With this memory model, access time is dependent on the memory location relative to that of the processor.</div>
<p class="mce-root">This will be an easy enhancement to implement and is likely to be part of the Java 10 platform release.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Value objects</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">Java Enhancement Proposal 169, value objects, intended to provide the necessary JVM infrastructure to permit working with objects that are immutable as well as objects that are without reference. This new infrastructure will allow for the efficient by-value computation with non-primitive data types.</span></p>
<p class="mce-root"><span class="calibre7">The set of goals for this proposal include the following:</span></p>
<ul class="calibre13">
<li class="calibre14"><span class="calibre5">More closely align <kbd class="calibre16">java.lang.Integer</kbd> and <kbd class="calibre16">int</kbd> semantics.</span></li>
<li class="calibre14"><span class="calibre5">Make Java data structures more portable</span></li>
<li class="calibre14">Support abstract data types with a performance similar to that of Java primitive data types:
<ul class="calibre13">
<li class="calibre14">User-defined</li>
<li class="calibre14">Library-defined</li>
</ul>
</li>
<li class="calibre14">Optimize parallel computations by enabling function-style computation with pure data</li>
<li class="calibre14">Improve support for:
<ul class="calibre13">
<li class="calibre14">Complex numbers</li>
<li class="calibre14">Vector values</li>
<li class="calibre14">Tuples</li>
</ul>
</li>
<li class="calibre14">Increase safety and security</li>
<li class="calibre14">Decrease "defensive copying"</li>
</ul>
<p class="mce-root">One of the stated implementation strategies is to add a <kbd class="calibre16">lockPermanently</kbd> operation. It will get passed an Object and then mark that Object as both immutable and unaliasable. The concept of a permanently locked object stipulates that:</p>
<ul class="calibre13">
<li class="calibre14">Fields cannot be changed</li>
<li class="calibre14">Elements of an array cannot be changed</li>
<li class="calibre14">No synchronization is possible</li>
<li class="calibre14">'Waiting' methods cannot be evoked</li>
<li class="calibre14">'Notifying' methods cannot be evoked</li>
<li class="calibre14">Identity hash codes inquiries are not permitted</li>
<li class="calibre14">Pointer equality checks cannot be performed</li>
</ul>
<p class="mce-root">This is likely to be one of the more popular additions to the Java 10 platform.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Align JVM Access Checks</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre7">Java Enhancement Proposal 181, Align JVM Checks with Java Language Rules for Nested Classes, focuses on the need to align JVM access checking rules with Java language rules, specifically for constructors, fields, and methods in nested classes. This will be accomplished by partitioning related classes in nests. Class files will be able to access private names of other class files in the same nest.</span></p>
<p class="mce-root">Nests will share an access control context. With the advent of nests, access bridges will not be required. The bulk of the change will be to the JVM's access rules.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Future Changes to JavaX</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The <kbd class="calibre16">Javax.*</kbd> packages are the subject of two specific Java Enhancement Proposals that have been submitted for a future Java platform release. Those proposals are as follows:</p>
<ul class="calibre13">
<li class="calibre14">JMX specific annotations for registration of managed resources</li>
<li class="calibre14">Modernize the GTK3 Look and Feel implementation</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">JMX specific annotations for registration of managed resources</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The draft Java Enhancement Proposal titled, JMX specific annotations for registration of managed resources, will provide a set of annotations for registration and configuration of <strong class="calibre8">MBeans</strong> <span class="calibre7">(<strong class="calibre8">Managed Bean</strong>)</span>.</p>
<div class="packt_tip">An MBean is a Java Object representing a manageable resource (app, service, component, or device).</div>
<p class="mce-root">The goal of this proposal is to lessen the burden on developers in the registration and configuring of MBeans. In addition, the source code readability will increase by ensuring all MBean declaration components are co-located.</p>
<p class="mce-root">The JMX specific annotations will be located in the <kbd class="calibre16">javax.management.annotations</kbd> package.</p>
<p class="mce-root">This Java Enhancement Proposal has been specifically planned for Java 11. Although, there is a possibility that it could be redesigned for Java 10.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Modernize the GTK3 Look and Feel Implementation</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">GTK3 is a widget toolkit used for creating graphical user interfaces, formally known as the GIMP toolkit. The draft Java Enhancement Proposal titled, Modernize the GTK3 Look and Feel implementation, calls for the rewriting of the current GTK2 Look and Feel so that it uses GTK3 instead.</p>
<p class="mce-root">GTK3 implementation will not replace GTK2. It is important to note that one or the other, not both of these can be used at runtime.</p>
<div class="packt_infobox">You can access the GTK3 reference manual at <a href="https://developer.gnome.org/gtk3/stable/" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1">https://developer.gnome.org/gtk3/stable/</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Ongoing Special Projects</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Java Enhancement Proposals present design and implementation changes to the Java platform. The criteria for a JEP being drafted is that the work must meet at least one of the following:</p>
<ul class="calibre13">
<li class="calibre14">At least two weeks of engineering work</li>
<li class="calibre14">Signifies a significant change to the JDK</li>
<li class="calibre14">Represents a high demand issue for developers or customers</li>
</ul>
<p class="mce-root">Projects, on the other hand, represent collaborative efforts that are sponsored by one of the following groups:</p>
<ul class="calibre13">
<li class="calibre14">2D Graphics</li>
<li class="calibre14">Adoption</li>
<li class="calibre14">AWT</li>
<li class="calibre14">Build</li>
<li class="calibre14">Compatibility and specification review</li>
<li class="calibre14">Compiler</li>
<li class="calibre14">Conformance</li>
<li class="calibre14">Core Libraries</li>
<li class="calibre14">Governing Board</li>
<li class="calibre14">HotSpot</li>
<li class="calibre14">Internationalization</li>
<li class="calibre14">JMX</li>
<li class="calibre14">Members</li>
<li class="calibre14">Networking</li>
<li class="calibre14">NetBeans Projects</li>
<li class="calibre14">Porters</li>
<li class="calibre14">Quality</li>
<li class="calibre14">Security</li>
<li class="calibre14">Serviceability</li>
<li class="calibre14">Sound</li>
<li class="calibre14">Swing</li>
<li class="calibre14">Web</li>
</ul>
<p class="mce-root">Groups are formal and new ones can be proposed.</p>
<p class="mce-root">The following listed active projects represent possible future enhancement areas to the Java platform. Brief information about each project is provided later in this section and provides insight into general areas of future changes:</p>
<ul class="calibre13">
<li class="calibre14">Annotations pipeline 2.0</li>
<li class="calibre14">Audio Synthesis Engine</li>
<li class="calibre14">Caciocavallo</li>
<li class="calibre14"><span class="calibre5"><span class="calibre5">Common VM Interface</span></span></li>
<li class="calibre14">Compiler Grammar</li>
<li class="calibre14">Da Vinci Machine</li>
<li class="calibre14"><span class="calibre5">Device I/O</span></li>
<li class="calibre14"><span class="calibre5">Graal</span></li>
<li class="calibre14">HarfBuzz Integration</li>
<li class="calibre14">Kona</li>
<li class="calibre14">OpenJFX</li>
<li class="calibre14">Panama</li>
<li class="calibre14">Shenandoah</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Annotations pipeline 2.0</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This project explores improvements to how annotations are handled within the Java compiler pipeline. There is no intention to propose changing specifications; rather, the focus is on performance enhancements.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Audio Synthesis Engine</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This project is looking at the creation of a new midi synthesizer for the JDK. The current midi synthesizer belongs to a licensed library. The working group would like to see the new midi synthesizer as an open source JDK asset.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Caciocavallo</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Caciocavallo project aims to improve the OpenJDK <strong class="calibre8">Abstract Windows Toolkit</strong> (<strong class="calibre8">AWT</strong>) internal interfaces. This extends to 2D subsystems. The proposed improvement stands to ease the way AWT is ported to new platforms.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Common VM Interface</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Common VM Interface project has the goal of documenting the VM interface for OpenJDK. This should make it easier for Classpath VMs and other VMs to use OpenJDK.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Compiler Grammar</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Compiler Grammar project is working on an experimental Java Compiler that is based on ANTLR grammar. <strong class="calibre8">ANTLR</strong>, <strong class="calibre8">Another Tool for Language Recognition</strong>, is a parser that reads, processes, and executes structured text or binary files. The project team hopes this Java Compiler will replace the current one as it uses a hand-written parser, <strong class="calibre8">LALR</strong> (<strong class="calibre8">Look-Ahead Left to Right</strong>). The LALR parser has been identified by the project group as fragile and difficult to extend.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Da Vinci Machine</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Da Vinci Machine Project, represents the effort to extend the JVM with support for non-Java languages. Current efforts are focused on allowing the new languages to e<span class="calibre7">xist alongside Java in</span> the <span class="calibre7">JVM. Performance and efficiency are key characteristics of the effort.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Device I/O</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This project intends to provide access to generic peripheral devices via a Java-level API. The initial list of peripheral devices the project team wants to support include:</p>
<ul class="calibre13">
<li class="calibre14"><strong class="calibre3">GPIO</strong> (<strong class="calibre3">General Purpose Input/Output</strong>)</li>
<li class="calibre14"><strong class="calibre3">I2C</strong> (<strong class="calibre3">Inter-Integrated Circuit Bus</strong>)</li>
<li class="calibre14"><strong class="calibre3">SPI</strong> (<strong class="calibre3">Serial Peripheral Interface</strong>)</li>
<li class="calibre14"><strong class="calibre3">UART</strong> (<strong class="calibre3">Universal Asynchronous Receiver/Transmitter</strong>)</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Graal</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Graal project has the goal of exposing VM functionality via Java APIs. This exposure will permit developers to write, in Java, dynamic compilers for a given language runtime. This effort includes the development of a multi-language interpreter framework.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">HarfBuzz Integration</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The HarfBuzz Integration project hopes to integrate the HarfBuzz layout engine into the Java Development Kit. This is intended to replace the ICU layout engine with the HarfBuzz layout engine. The ICU layout engine has been deprecated, solidifying the importance of this project's future success.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Kona</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Kona project, is working to define and implement Java APIs to support the <strong class="calibre8">Internet of Things</strong> (<strong class="calibre8">IoT</strong>) domain. This includes networking technologies and protocols. Although not stated, safety and security will be paramount to this effort's implementation success.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">OpenJFX</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There are not many details available regarding the OpenJFX project. The stated goal of this project is to create the next-generation Java client toolkit. Based on the project title, it can be assumed that the group wants to create an OpenJFX version of JavaFX, which is a set of packages used to create rich internet applications.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Panama</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Project panama is focused on enhancing the connections between JVM and non-Java APIs. The project includes the following selected components:</p>
<ul class="calibre13">
<li class="calibre14">Native function calls</li>
<li class="calibre14">Native data access from JVM</li>
<li class="calibre14">Native data access inside JVM heap</li>
<li class="calibre14">New data layouts in JVM heap</li>
<li class="calibre14">API extraction tools for header files</li>
</ul>
<p class="mce-root">The project team has generated a repository tree that matches JDK 9's structure. This significantly increases the likelihood of the project's success.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Shenandoah</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Project Shenandoah has the goal of significantly reducing the pause times with garbage collection operations. The approach is to have more garbage collection operations run concurrently with the Java application. In <a href="" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 7</a>, <em class="calibre20">Leveraging the New Default G1 Garbage Collector</em> you read about CMS and G1. The Shenandoah project intends to add concurrent compaction to the possible garbage collection approaches.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter we provided an overview of the future developments of the Java platform, beyond Java 9. We looked at what is planned for Java 10 and what further changes we are likely to see beyond Java 10. Each potential change to the Java platform was characterized as targeted, submitted, or drafted. Specifically, we covered future changes to the Java platform grouped in the following categories: <span class="calibre7">JDK Changes,</span> <span class="calibre7">Java Compiler,</span> <span class="calibre7">Java Virtual Machine,</span> <span class="calibre7">JavaX, and</span> s<span class="calibre7">pecial projects.</span></p>


            </article>

            
        </section>
    </div>



  </body></html>