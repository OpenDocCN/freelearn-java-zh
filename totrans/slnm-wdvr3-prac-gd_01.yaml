- en: Introducing WebDriver and WebElements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look briefly into Selenium, its various components,
    such as Appium, and proceed to the basic components of a web page, including the
    various types of WebElements. We will learn different ways to locate WebElements
    on a web page and execute various user actions on them. We will cover the following
    topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Various components of Selenium Testing Tools
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a project in Eclipse with Maven and TestNG
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locating WebElements on a Web Page
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions that can be taken on the WebElements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selenium is a set of widely popular tools used to automate browsers. It is largely
    used to test applications, but its usages are not limited to testing. It can also
    be used to perform screen scraping and automate repetitive tasks in a browser
    window. Selenium supports automation on all the major browsers, including Google
    Chrome, Mozilla Firefox, Microsoft Internet Explorer and Edge, Apple Safari, and
    Opera. Selenium 3.0 is now a part of W3C standards and is supported by major browser
    vendors.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Selenium Testing Tools
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selenium 3.0 offers three important tools, Selenium WebDriver, Selenium Server,
    and Selenium IDE. Each of these tools provides features to create, debug, and
    run tests on supported browsers and operating systems. Let's explore each of them
    in detail.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Selenium WebDriver
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Selenium WebDriver is the successor of Selenium RC (Remote Control), which
    has been officially deprecated. Selenium WebDriver accepts commands using the
    JSON-Wire protocol (also called Client API) and sends them to a browser launched
    by the specific driver class (such as ChromeDriver, FirefoxDriver, or IEDriver).
    This is implemented through a browser-specific browser driver. It works with the
    following sequence:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The driver listens to the commands from Selenium
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It converts these commands into the browser's native API
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The driver takes the result of native commands and sends the result back to
    Selenium:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bf64b2d5-cd1c-4c5a-a08d-a08dc873aa4d.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: 'We can use Selenium WebDriver to do the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Create robust, browser-based regression automation
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scale and distribute scripts across many browsers and platforms
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create scripts in your favourite programming language
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selenium WebDriver offers a collection of language-specific bindings (client
    libraries) to drive a browser. WebDriver comes with a better set of APIs that
    meet the expectations of most developers by being similar to object-oriented programming
    in its implementation. WebDriver is being actively developed over a period of
    time, and you can see many advanced interactions with the web as well as mobile
    applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The Selenium Client API is a language-specific Selenium library that provides
    a consistent Selenium API in programming languages such as Java, C#, Python, Ruby,
    and JavaScript. These languages bindings let tests to launch a WebDriver session
    and communicate with the browser or Selenium Server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Selenium Server
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selenium Server allows us to run tests on browser instances running on remote
    machines and in parallel, thus spreading a load of testing across several machines.
    We can create a Selenium Grid, where one server runs as the Hub, managing a pool
    of Nodes. We can configure our tests to connect to the Hub, which then obtains
    a node that is free and matches the browser we need to run the tests. The hub
    has a list of nodes that provide access to browser instances, and lets tests use
    these instances similarly to a load balancer. Selenium Grid enables us to execute
    tests in parallel on multiple machines by managing different types of browsers,
    their versions, and operating system configurations centrally.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium Server 允许我们在远程机器上运行的浏览器实例以及并行运行测试，从而将测试负载分散到多台机器上。我们可以创建一个 Selenium
    Grid，其中一个服务器作为 Hub 运行，管理节点池。我们可以配置我们的测试以连接到 Hub，然后 Hub 获取一个空闲节点，该节点与我们需要运行测试的浏览器相匹配。Hub
    有一个节点列表，提供对浏览器实例的访问，并允许测试像负载均衡器一样使用这些实例。Selenium Grid 通过集中管理不同类型的浏览器、它们的版本和操作系统配置，使我们能够在多台机器上并行执行测试。
- en: Selenium IDE
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Selenium IDE
- en: 'Selenium IDE is a Firefox add-on that allows users to record, edit, debug,
    and play back tests captured in the *Selenese* format, which was introduced in
    the Selenium Core version. It also provides us with the ability to convert these
    tests into the Selenium RC or Selenium WebDriver format. We can use Selenium IDE
    to do the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium IDE 是一个 Firefox 插件，允许用户记录、编辑、调试和回放以 *Selenese* 格式捕获的测试，该格式是在 Selenium
    核心版本中引入的。它还为我们提供了将这些测试转换为 Selenium RC 或 Selenium WebDriver 格式的功能。我们可以使用 Selenium
    IDE 执行以下操作：
- en: Create quick and simple scripts using record and replay, or use them in exploratory
    testing
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用记录和回放创建快速简单的脚本，或者将它们用于探索性测试
- en: Create scripts to aid in automation-aided exploratory testing
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建脚本以辅助自动化辅助的探索性测试
- en: Create macros to perform repetitive tasks on Web pages
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建宏以在 Web 页面上执行重复性任务
- en: The Selenium IDE for Firefox stopped working after the Firefox 55 moved to the
    WebExtension format from XPI format and it is currently no longer maintained.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Firefox 55 从 XPI 格式迁移到 WebExtension 格式后，Selenium IDE for Firefox 停止了工作，并且目前不再维护。
- en: Differences between Selenium 2 and Selenium 3
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Selenium 2 和 Selenium 3 之间的差异
- en: Before we dive further into Selenium 3, let's understand the differences between
    Selenium 2 and Selenium.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步深入了解 Selenium 3 之前，让我们了解 Selenium 2 和 Selenium 之间的差异。
- en: Handling the browser
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理浏览器
- en: As the Selenium WebDriver has been accepted as the W3C Standard, Selenium 3
    brings a number of changes to the browser implementations. All of the major browser
    vendors now support WebDriver specification and provide the necessary features
    along with the browser. For example, Microsoft came with EdgeDriver, and Apple
    supports the SafariDriver implementation. We will see some of these changes later
    in this book.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Selenium WebDriver 已被接受为 W3C 标准，Selenium 3 对浏览器实现带来了一系列变化。现在，所有主要的浏览器厂商都支持
    WebDriver 规范，并提供了必要的功能，包括浏览器。例如，微软推出了 EdgeDriver，苹果支持 SafariDriver 实现。我们将在本书的后面看到一些这些变化。
- en: Having better APIs
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥有更好的 API
- en: As W3C-standard WebDriver comes with a better set of APIs, which meet the expectations
    of most developers by being similar to the implementation of object-oriented programming.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 W3C 标准的 WebDriver 携带了一套更好的 API，这些 API 通过类似于面向对象编程的实现来满足大多数开发者的期望。
- en: Having developer support and advanced functionalities
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥有开发者支持和高级功能
- en: WebDriver is being actively developed and is now supported by Browser vendors
    per W3C specification; you can see many advanced interactions with the web as
    well as mobile applications, such as File-Handling and Touch APIs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: WebDriver 正在积极开发中，并且现在根据 W3C 规范由浏览器厂商支持；您可以看到许多与 Web 以及移动应用程序的先进交互，例如文件处理和触摸
    API。
- en: Testing Mobile Apps with Appium
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Appium 测试移动应用程序
- en: One of the major differences introduced in Selenium 3 was the introduction of
    the `Appium` project. The mobile-testing features that were part of Selenium 2
    are now moved into a separate project named Appium.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Selenium 3 中引入的主要差异之一是引入了 `Appium` 项目。Selenium 2 中作为其一部分的移动测试功能现在已移动到名为 Appium
    的独立项目中。
- en: '`Appium` is an open source mobile-automation framework for testing native,
    hybrid, and web mobile apps on iOS and Android platforms using the JSON-Wire protocol
    with Selenium WebDriver. `Appium` replaces the iPhoneDriver and AndroidDriver
    APIs in Selenium 2 that were used to test mobile web applications.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '`Appium` enables the use and extension of the existing Selenium WebDriver framework
    to build mobile tests. As it uses Selenium WebDriver to drive the tests, we can
    use any programming language to create tests for a Selenium client library.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a project in Eclipse with Maven and TestNG using Java
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selenium WebDriver is a library that helps you automate browsers. However, much
    more is needed when using it for testing and building a test framework or automating
    browsers for non-testing purposes. You will need an Integrated Development Environment
    (**IDE**) or a code editor to create a new Java project and add Selenium WebDriver
    and other dependencies in order to build a testing framework.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: In the Java development community, Eclipse is a widely-used IDE, as well as
    IntelliJ IDEA and NetBeans. Eclipse provides a feature-rich environment for Selenium
    WebDriver test-development.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Along with Eclipse, Apache Maven provides support for managing the life cycle
    of a test project. Maven is used to define the project structure, dependencies,
    build, and test-management.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: We can use Eclipse and Maven to build our Selenium WebDriver test framework
    from a single window. Another important benefit of using Maven is that we can
    get all the Selenium library files and their dependencies by configuring the pom.xml
    file. Maven automatically downloads the necessary files from the repository while
    building the project.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn how to configure Eclipse and Maven for the Selenium
    WebDriver test development. Most of the code in this book has been developed in
    Eclipse and Maven.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: You will need Eclipse and Maven to set up the test-development environment.
    Download and set up Maven from [http://maven.apache.org/download.html](http://maven.apache.org/download.html).
    Follow the instructions on the Maven download page (see the Installation Instructions
    section of the page).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Download and set up Eclipse IDE for Java Developers from [https://eclipse.org/downloads/](https://eclipse.org/downloads/)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Along with Eclipse and Maven, we will also use TestNG as a testing framework
    for our project. The TestNG library will help us define test cases, test fixtures,
    and assertions. We need to install the TestNG plugin for Eclipse via Eclipse Marketplace.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s configure Eclipse with Maven to develop Selenium WebDriver tests using
    the following steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Launch the Eclipse IDE.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new project by selecting File | New | Other from the Eclipse Main Menu.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the New dialog, select Maven | Maven Project, as shown in the following
    screenshot, and click Next:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/84b40e3b-fe30-4866-a448-47dec065c1ef.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: 'The New Maven Project dialog will be displayed. Select the Create a simple
    project (skip archetype selection) checkbox and click on the Next button, as shown
    in the following screenshot:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8abd601e-4710-48fb-aa46-8bd4d9648eb6.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: 'On the New Maven Project dialog box, enter ***com.example*** in the Group Id:
    textbox and ***chapter1*** in the Artifact Id: textbox. You can also add a name
    and description. Click on the Finish button, as shown in the following screenshot:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aaaed783-5ef5-4e1e-b32b-dd1a4c704d52.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: 'Eclipse will create the ***chapter1*** project with a structure (in Package
    Explorer) similar to the one shown in the following screenshot:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/59e3dbc7-75cc-4827-8cc6-8728ffe6551e.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: 'Select pom.xml from Package Explorer. This will open the pom.xml file in the
    editor area with the **Overview** tab open. Select the **pom.xml** tab next to
    the Overview tab, as shown in the following screenshot:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/febf79fa-3b4c-4f59-9314-393375c11bc8.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'Add the Selenium WebDriver and TestNG dependencies highlighted in the following
    code snippet to pom.xml in the between `project` node:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Select ***src/test/java*** in Package Explorer and right-click on it to show
    the menu. Select New | Other, as shown in the following screenshot:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4dfc74b9-5e7a-4bc8-9464-462c1f3ee2eb.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: 'Select the TestNG | TestNG class from the Select a wizard dialog, as shown
    in the following screenshot:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/686fa9e7-cbef-45ac-8626-24e569aac808.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: 'On the New TestNG class dialog box, enter ***/chapter1/src/test/java*** in
    the Source folder: field. Enter com.example in the Package name: field. Enter
    NavigationTest in the Class name: field. Select the @BeforeMethod and @AfterMethod
    checkboxes and add `src/test/resources/suites/testng.xml` in the XML suite file:
    field. Click on the Finish button:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5548a321-387e-4b67-8c87-9431b4c8b168.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: 'This will create the ***NavigationTest.java*** class in the com.example package
    with TestNG annotations such as `@Test`, `@BeforeMethod`, and `@AfterMethod`,
    and the `beforeMethod` and `afterMethod` methods:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6c71fcdc-148a-494f-8f12-47723f3bd1fc.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: 'Modify the `NavigationTest` class with following code:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, three methods are added as part of the `NavigationTest`
    class. We also declared a `WebDriver driver;` instance variable, which we will
    use later in the test to launch a browser and navigate to the site.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '`beforeMethod()`, which is annotated with the `@BeforeMethod` TestNG annotation,
    will execute before the test method. It will set the path of the *chromedriver*
    executable required by Google Chrome. It will then instantiate the driver variable
    using the `ChromeDriver()` class. This will launch a new Google Chrome window
    on the screen.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The next method, `navigateToAUrl()`, annotated with the `@Test` annotation is
    the test method. We will call the `get()` method of the WebDriver interface passing
    the URL of the application. This will navigate to the site in the browser. We
    will check the title of the page by calling TestNG's `Assert.assertEquals` method
    and the `getTitle()` method of the WebDriver interface.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, `afterMethod()` is annotated with the `@AfterMethod` TestNG annotation
    will close the browser window.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: We need to download and copy the chromedriver executable from [https://sites.google.com/a/chromium.org/chromedriver/downloads](https://sites.google.com/a/chromium.org/chromedriver/downloads).
    Download the appropriate version based on the Google Chrome browser version installed
    on your computer as well as the operating system. Copy the executable file in
    the `/src/test/resources/ drivers` folder.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the tests, right-click in the code editor and select Run As | TestNG
    Test, as shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6a4dc78-ebbf-4123-807b-4434c06a8991.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: 'This will launch a new Google Chrome browser window and navigate to the site.
    The test will validate the page title and the browser window will be closed at
    the end of the test. The TestNG Plugin will display results in Eclipse:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32793ec0-2892-40f0-bd7e-4506701ddc11.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: You can download the example code files for all the Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    have purchased this book elsewhere, you can visit http://www.packtpub. com/support
    and register to have the files emailed directly to you. The example code is also
    hosted at [https://github.com/PacktPublishing/Selenium-WebDriver-3-Practical-Guide-Second-Edition](https://github.com/PacktPublishing/Selenium-WebDriver-3-Practical-Guide-Second-Edition)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: WebElements
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A web page is composed of many different types of HTML elements, such as links,
    textboxes, dropdown buttons, a body, labels, and forms. These are called WebElements
    in the context of WebDriver. Together, these elements on a web page will achieve
    the user functionality. For example, let''s look at the HTML code of the login
    page of a website:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding HTML code, there are different types of WebElements, such
    as `<html>`, `<body>`, `<form>`, `<label>`, `<input>`, and `<a>`, which together
    make a web page provide the Login feature for the user. Let''s analyze the following
    WebElement:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `<label>` is the start tag of the WebElement label. `Enter Username:`
    is the text present on the `label` element. Finally, `</label>` is the end tag,
    which indicates the end of a WebElement.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, take another WebElement:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, `type` and `name` are the attributes of the WebElement
    `input` with the `text` and `Username` values, respectively.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: UI-automation using Selenium is mostly about locating these WebElements on a
    web page and executing user actions on them. In the rest of the chapter, we will
    use various methods to locate WebElements and execute relevant user actions on
    them.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Selenium进行UI自动化主要涉及在网页上定位这些Web元素并对其执行用户操作。在本章的剩余部分，我们将使用各种方法来定位Web元素并在其上执行相关的用户操作。
- en: Locating WebElements using WebDriver
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WebDriver定位Web元素
- en: 'Let''s start this section by automating the Search feature from the Homepage
    of the demo application, [http://demo-store.seleniumacademy.com/](http://demo-store.seleniumacademy.com/),
    which involves navigating to the homepage, typing the search text in the textbox,
    and executing the search. The code is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从自动化演示应用程序首页的搜索功能开始这一节，[http://demo-store.seleniumacademy.com/](http://demo-store.seleniumacademy.com/)，这涉及到导航到首页，在文本框中输入搜索文本，并执行搜索。代码如下：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, there are three new things that are highlighted, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有三个新的内容被突出显示，如下所示：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: They are the `findElement()` method, the `By.name()` method, and the `WebElement`
    interface. The `findElement()` and `By()` methods instruct WebDriver to locate
    a `WebElement` on a web page, and once found, the `findElement()` method returns
    the `WebElement` instance of that element. Actions, such as click and type, are
    performed on a returned `WebElement` using the methods declared in the `WebElement`
    interface, which will be discussed in detail in the next section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是`findElement()`方法、`By.name()`方法和`WebElement`接口。`findElement()`和`By()`方法指示WebDriver在网页上定位一个`WebElement`，一旦找到，`findElement()`方法就返回该元素的`WebElement`实例。使用`WebElement`接口中声明的方
    法在返回的`WebElement`上执行操作，如点击和输入，这些将在下一节详细讨论。
- en: The findElement method
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`findElement`方法'
- en: 'In UI automation, locating an element is the first step before executing any
    user actions on it. WebDriver''s `findElement()` method is a convenient way to
    locate an element on the web page. According to WebDriver''s Javadoc ([http://selenium.googlecode.com/git/docs/api/java/index.html](http://seleniumhq.github.io/selenium/docs/api/java/index.html)),
    the method declaration is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在UI自动化中，在执行任何用户操作之前，定位元素是第一步。WebDriver的`findElement()`方法是在网页上定位元素的一种便捷方式。根据WebDriver的Javadoc（[http://selenium.googlecode.com/git/docs/api/java/index.html](http://seleniumhq.github.io/selenium/docs/api/java/index.html)），方法的声明如下：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, the input parameter for the `findElement()` method is the `By` instance.
    The `By` instance is a WebElement-locating mechanism. There are eight different
    ways to locate a WebElement on a web page. We will see each of these eight methods
    later in the chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`findElement()`方法的输入参数是`By`实例。`By`实例是一个定位`WebElement`的机制。有八种不同的方式可以在网页上定位一个`WebElement`。我们将在本章后面看到这八种方法。
- en: The return type of the `findElement()` method is the WebElement instance that
    represents the actual HTML element or component of the web page. The method returns
    the first WebElement that the driver comes across that satisfies the locating-mechanism
    condition. This WebElement instance will act as a handle to that component from
    then on. Appropriate actions can be taken on that component by the test-script
    developer using this returned WebElement instance.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`findElement()`方法的返回类型是表示网页实际HTML元素或组件的`WebElement`实例。该方法返回第一个满足定位机制条件的`WebElement`。从那时起，此`WebElement`实例将作为该组件的句柄。测试脚本开发者可以通过使用返回的`WebElement`实例来对该组件采取适当的操作。'
- en: If WebDriver doesn't find the element, it throws a runtime exception named `NoSuchElementException`,
    which the invoking class or method should handle.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果WebDriver找不到元素，它将抛出一个名为`NoSuchElementException`的运行时异常，调用类或方法应该处理它。
- en: The findElements method
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`findElements`方法'
- en: 'For finding multiple elements matching the same locator criteria on a web page,
    the `findElements()` method can be used. It returns a list of WebElements found
    for a given locating mechanism. The method declaration of the `findElements()`
    method is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在网页上查找符合相同定位条件的多元素，可以使用`findElements()`方法。它返回一个包含给定定位机制找到的Web元素的列表。`findElements()`方法的声明如下：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The input parameter is the same as the `findElement()` method, which is an instance
    of the `By` class. The difference lies in the return type. Here, if no element
    is found, an empty list is returned and if there are multiple WebElements present
    that satisfy the locating mechanism, all of them are returned to the caller in
    a list.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting Elements with Developer Tools
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start exploring how to find elements on a page and what locator mechanism
    to use, we need to look at the HTML code of the page to understand the Document
    Object Model (**DOM**) tree, what properties or attributes are defined for the
    elements displayed on the page, and how JavaScript or AJAX calls are made from
    the application. browsers use the HTML code written for the page to render visual
    elements in the browser window. It uses other resources, including JavaScript,
    CSS, and images, to decide on the look, feel, and behavior of these elements.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a login page of the demo application and the HTML code
    written to render this page in a browser, as displayed in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abf78c19-fab7-46a2-9ad3-51fe0ffa8758.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: We need tools that can display the HTML code of the page in a structured and
    easy-to-understand format. Almost all browsers now offer Developer tools to inspect
    the structure of the page and associated resources.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting pages and elements with Mozilla Firefox
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The newer versions of Mozilla Firefox provide built-in ways to inspect the
    page and elements. To inspect an element from the page, move the mouse over the
    desired element and right-click to open the pop-up menu. Select the **Inspect
    Element** option, as shown in the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f81e2d68-fb90-4d4f-b186-2fa8594c3543.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 'This will display the Inspector tab with the HTML code in a tree format with
    the selected element highlighted, as shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4058e793-e9b3-407f-8918-7a0b90aaf34b.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: 'Using Inspector, we can also validate the XPath or CSS Selectors using the
    search box shown in the Inspector section. Just enter the XPath or CSS Selector
    and Inspector will highlight the elements that match the expression, as shown
    in the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a408ea7-82f2-4d2e-b169-75b78bc32142.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: 'The Developer tools provide various other debugging features. It also generates
    XPath and CSS selectors for elements. For this, select the desired element in
    the tree, right-click, and select the Copy > XPath or Copy > CSS Path option from
    the pop-up menu, as shown in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71a679b3-2ce1-4546-9e1e-cf63a696088f.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: This will paste the suggested XPath or CSS selector value to the clipboard to
    be used later with the `findElement()` method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting pages and elements in Google Chrome with Developer Tools
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to Mozilla Firefox, Google Chrome also provides a built-in feature
    to inspect pages and elements. We can move the mouse over a desired element on
    the page, right-click to open the pop-up menu, and then select the Inspect element
    option. This will open Developer tools in the browser, which displays information
    similar to that of Firefox, as shown in the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与Mozilla Firefox类似，Google Chrome也提供了一个内置功能来检查页面和元素。我们可以将鼠标移至页面上的所需元素上，右键单击以打开弹出菜单，然后选择“检查元素”选项。这将打开浏览器中的开发者工具，显示类似于Firefox的信息，如下面的截图所示：
- en: '![](img/da72f733-a2ee-4bff-a6b8-be04dcff9d01.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da72f733-a2ee-4bff-a6b8-be04dcff9d01.png)'
- en: 'Similar to Firefox, we can also test XPath and CSS Selectors in Google Chrome
    Developer tools. Press *Ctrl + F* (on Mac, use *Command + F*) in the Elements
    tab. This will display a search box. Just enter *XPath* or *CSS Selector*, and
    matching elements will be highlighted in the tree, as shown in the following screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与Firefox类似，我们也可以在Google Chrome开发者工具中测试XPath和CSS选择器。在“元素”选项卡中按*Ctrl + F*（在Mac上使用*Command
    + F*）。这将显示一个搜索框。只需输入*XPath*或*CSS Selector*，匹配的元素将在树中突出显示，如下面的截图所示：
- en: '![](img/67ecbaf8-2338-47da-b959-8c993e44ecce.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67ecbaf8-2338-47da-b959-8c993e44ecce.png)'
- en: Chrome Developer Tools also provides a feature where you can get the XPath for
    an element by right-clicking on the desired element in the tree and selecting
    the Copy XPath option from the pop-up menu.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome开发者工具还提供了一个功能，您可以通过在树中右键单击所需的元素并从弹出菜单中选择“复制XPath”选项来获取元素的XPath。
- en: Similar to Mozilla Firefox and Google Chrome, you will find similar Developer
    tools in any major browser, including Microsoft Internet Explorer and Edge.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与Mozilla Firefox和Google Chrome类似，您将在任何主要浏览器中找到类似的开发者工具，包括Microsoft Internet
    Explorer和Edge。
- en: Browser developer tools come in really handy during the test-script development.
    These tools will help you to find the locator details for the elements with which
    you need to interact as part of the test. These tools parse the code for a page
    and display the information in a hierarchal tree.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器开发者工具在测试脚本开发过程中非常有用。这些工具将帮助您找到需要交互的元素的定位细节。这些工具解析页面代码，并以分层树的形式显示信息。
- en: WebElements on a web page may not have all the attributes declared. It is up
    to the developer of the test script to select the attribute that uniquely identifies
    the WebElement on the web page for the automation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 网页上的WebElements可能不具有所有声明的属性。选择用于在网页上唯一标识WebElements的属性是测试脚本开发者的责任，以便进行自动化。
- en: Using the By locating mechanism
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用By定位机制
- en: By is the locating mechanism passed to the `findElement()` method or the `findElements()`
    method to fetch the respective WebElement(s) on a web page. There are eight different
    locating mechanisms; that is, eight different ways to identify
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: By是传递给`findElement()`方法或`findElements()`方法以获取网页上的相应WebElement（s）的定位机制。有八种不同的定位机制；也就是说，有八种不同的方式来识别
- en: an HTML element on a web page. They are located by ID, Name, ClassName, TagName,
    LinkText, PartialLinkText, XPath, and CSS Selector.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 网页上的一个HTML元素。它们可以通过ID、Name、ClassName、TagName、LinkText、PartialLinkText、XPath和CSS
    Selector来定位。
- en: The By.id() method
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: By.id()方法
- en: 'On a web page, each element is uniquely identified by an ID attribute, which
    is optionally provided. An ID can be assigned manually by the developer of the
    web application or left to be dynamically generated by the application. Dynamically-generated
    IDs can be changed on every page refresh or over a period of time. Now, consider
    the HTML code of the Search box:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页上，每个元素都通过一个ID属性来唯一标识，这个属性是可选的。ID可以由网络应用的开发者手动分配，或者由应用动态生成。动态生成的ID可以在每次页面刷新或一段时间内更改。现在，考虑搜索框的HTML代码：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, the `id` attribute value of the search box is `search`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，搜索框的`id`属性值是`search`。
- en: 'Let''s see how to use the ID attribute as a locating mechanism to find the
    Search box:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用ID属性作为定位机制来找到搜索框：
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In preceding code, we used the `By.id()` method and the search box's `id` attribute
    value to find the element.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了`By.id()`方法和搜索框的`id`属性值来找到元素。
- en: 'Here, try to use the `By.id` identifier, and use the name value (that is, `q`)
    instead of the `id` value (that is, `search`). Modify line three as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，尝试使用`By.id`标识符，并使用名称值（即`q`）而不是`id`值（即`search`）。将第三行修改如下：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The test script will fail to throw an exception, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本将无法抛出异常，如下所示：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: WebDriver couldn't find an element by `id` whose value is `q`. Thus, it throws
    an exception saying `NoSuchElementException`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The By.name() method
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As seen earlier, every element on a web page has many attributes. Name is one
    of them. For instance, the HTML code for the Search box is:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, `name` is one of the many attributes of the search box, and its value
    is `q`. If we want to identify this search box and set a value in it in your test
    script, the code will look as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you observe line four, the locating mechanism used here is `By.name` and
    the name is `q`. So, where did we get this name from? As discussed in the previous
    section, it is the browser developer tools that helped us get the name of the
    button. Launch Developer tools and use the inspect elements widget to get the
    attributes of an element.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The By.className() method
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we discuss the `className()` method, we have to talk a little about style
    and CSS. Every HTML element on a web page, generally, is styled by the web page
    developer or designer. It is not mandatory that each element should be styled,
    but they generally are to make the page appealing to the end user.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in order to apply styles to an element, they can be declared directly in
    the element tag, or placed in a separate file called the CSS file and can be referenced
    in the element using the `class` attribute. For instance, a style attribute for
    a button can be declared in a CSS file as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, this style can be applied to the button element in a web page as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, `buttonStyle` is used as the value for the `class` attribute of the button
    element, and it inherits all the styles declared in the CSS file. Now, let's try
    this on our Homepage. We will try to make WebDriver identify the search button
    using its class name and click on it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in order to get the class name of the search button, as we know, we
    will use Developers tools to fetch it. After getting it, change the location mechanism
    to `By.className` and specify the class attribute value in it. The code for that
    is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we have used the `By.className` locating mechanism by
    passing the class attribute value to it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, an element might have multiple values given for the `class` attribute.
    For example, the Search button has *button* and *search-button* values specified
    in the `class` attribute in the following HTML snippet:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have to use one of the values of the `class` attribute with the `By.className`
    method. In this case, we can either use *button* or *search-button*, whichever
    uniquely identifies the element.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The By.linkText() method
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, the `By.linkText` locating mechanism can only be used
    to identify the HTML links. Before we start discussing how WebDriver can be commanded
    to identify a link element using link text, let''s see what an HTML link element
    looks like. The HTML link elements are represented on a web page using the `<a>`
    tag, an abbreviation for the anchor tag. A typical anchor tag looks like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, `href` is the link to a different page where your web browser will take
    you when you click on the link. So, the preceding HTML code when rendered by the
    browser looks like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b54093b6-14c6-4354-b0b7-cd34a68d245e.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: 'This **MY ACCOUNT** is the link text. So the `By.linkText` locating mechanism
    uses this text on an anchor tag to identify the WebElement. The code would look
    like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the `By.linkText` locating mechanism is used to identify the **MY ACCOUNT**
    link.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The `linkText` and `partialLinkText` methods are case-sensitive.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The By.partialLinkText() method
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `By.partialLinkText` locating mechanism is an extension of the `By.linkText`
    locator. If you are not sure of the entire link text or want to use only part
    of the link text, you can use this locator to identify the link element. So, let''s
    modify the previous example to use only partial text on the link; in this case,
    we will use Privacy from the Privacy Policy link in the site footer:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1dcdff51-63dc-4c09-9b1c-4c85b3a9777a.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: 'The code would look like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What happens if there are multiple links whose text has *Privacy* in it? That
    is a question for the `findElement()` method rather than the locator. Remember
    when we discussed the `findElement()` method earlier, it will return only the
    first WebElement that it comes across. If you want all the WebElements that contain
    *Privacy* in its link text, use the `findElements()` method, which will return
    a list of all those elements.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Use WebDriver's `findElements()` method if you think you need all the WebElements
    that satisfy a locating-mechanism condition.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The By.tagName() method
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Locating an element by tag name is slightly different from the locating mechanisms
    we saw earlier. For example, on a  Homepage, if you search for an element with
    the `button` tag name, it will result in multiple WebElements because there are
    nine buttons present on the Homepage. So, it is always advisable to use the `findElements()`
    method rather than the `findElement()` method when trying to locate elements using
    tag names.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how the code looks when a search for the number of links present
    on a  Homepage is made:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, we have used the `By.tagName` locating mechanism and
    the `findElements()` method, which return a list of all the links, that is, the `a` anchor
    tags defined on the page. On line five,  we printed the size of the list, and
    then printed text of only links where the text has been provided. We use the Java
    8 Stream API to filter the element list and output the text value by calling the
    `getText()` method. This will generate the following output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The By.xpath() method
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WebDriver uses **XPath** to identify a WebElement on the web page. Before we
    see how it does that, let''s quickly look at the syntax for XPath. XPath is a
    short name for the XML path, the query language used for searching XML documents.
    The HTML for our web page is also one form of the XML document. So, in order to
    identify an element on an HTML page, we need to use a specific XPath syntax:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The root element is identified as `//`.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To identify all the div elements, the syntax will be `//div`.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To identify the link tags that are within the div element, the syntax will be
    `//div/a`.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To identify all the elements with a tag, we use *. The syntax will be `//div/*`.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To identify all the div elements that are at three levels down from the root,
    we can use `//*/*/div`.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To identify specific elements, we use attribute values of those elements, such
    as `//*/div/a[@id='attrValue']`, which will return the anchor element. This element
    is at the third level from the root within a `div` element and has an `id` value
    of `attrValue`.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we need to pass the XPath expression to the `By.xpath` locating mechanism
    to make it identify our target element.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the code example and how WebDriver uses this XPath to identify
    the element:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, we are using the `By.xpath` locating mechanism and passing
    the XPath of the WebElement to it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: One disadvantage of using XPath is that it is costly in terms of time. For every
    element to be identified, WebDriver actually scans through the entire page, which
    is very time consuming, and too much usage of XPath in your test script will actually
    make it too slow to execute.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The By.cssSelector() method
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `By.cssSelector()` method is similar to the `By.xpath()` method in its
    usage, but the difference is that it is slightly faster than the `By.xpath` locating
    mechanism. The following are the commonly used syntaxes to identify elements:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: To identify an element using the div element with the `#flrs` ID, we use the
    `#flrs` syntax
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To identify the child anchor element, we use the `#flrs > a` syntax, which will
    return the link element
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To identify the anchor element with its attribute, we use the `#flrs > a[a[href="/intl/en/about.html"]]`
    syntax
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try to modify the previous code, which uses the XPath locating mechanism
    to use the `cssSelector` mechanism:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding code uses the `By.cssSelector` locating mechanism, which uses
    the css selector `ID` of the Search box.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a slightly complex example. We will try to identify the About
    Us on the Homepage:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding code uses the `cssSelector()` method to find the anchor element
    identified by its `href` attribute.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with WebElements
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw how to locate WebElements on a web page by using
    different locator methods. Here, we will see all the different user actions that
    can be performed on a WebElement. Different WebElements will have different actions
    that can be taken on them. For example, in a textbox element, we can type in some
    text or clear the text that is already typed in it. Similarly, for a button, we
    can click on it, get the dimensions of it, and so on, but we cannot type into
    a button, and for a link, we cannot type into it. So, though all the actions are
    listed in one WebElement interface, it is the test script developer's responsibility
    to use the actions that are supported by the target element. In case we try to
    execute the wrong action on a WebElement, we don't see any exception or error
    thrown and we don't see any action get executed; WebDriver ignores such actions
    silently.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's get into each of the actions individually by looking at their Javadocs
    and a code example.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Getting element properties and attributes
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn the various methods to retrieve value and properties
    from the WebElement interface.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: The getAttribute() method
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `getAttribute` method can be executed on all the WebElements. Remember,
    we have seen attributes of WebElement in the WebElements section. The HTML attributes
    are modifiers of HTML elements. They are generally key-value pairs that appear
    in the start tag of an element. For example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, `name` and `id` are the attributes or attribute keys
    and `Username` and `uname` are the attribute values.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'The API syntax of the `getAttribute()` method is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, the input parameter is `String`, which is the name of
    the attribute. The return type is again `String`, which is the value of the attribute.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how we can get all the attributes of a WebElement using WebDriver.
    Here, we will make use of the Search box from the example application. This is
    what the element looks like:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will list all the attributes of this WebElement using WebDriver. The code
    for that is as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding code, the last four lines of code use the `getAttribute()`
    method to fetch the attribute values of the `name`, `id`, `class`, and `placeholder`
    attributes of the WebElement search box. The output of the preceding code will
    be following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Going back to the `By.tagName()` method of the previous section, if the search
    by a locating mechanism, `By.tagName`, results in more than one result, you can
    use the `getAttribute()` method to further filter the results and get to your
    exact intended element.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The getText() method
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `getText` method can be called from all the WebElements. It will return
    visible text if the element contains any text on it, otherwise it will return
    nothing.  The API syntax for the `getText()` method is as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There is no input parameter for the preceding method, but it returns the visible `innerText` string
    of the WebElement if anything is available, otherwise it will return an empty
    string.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code to get the text present on the Site notice element
    present on the example application Homepage:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding code uses the `getText()` method to fetch the text present on
    the Site notice element, which returns the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The getCssValue() method
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `getCssValue` method can be called on all the WebElements. This method
    is used to fetch a CSS property value from a WebElement. CSS properties can be
    `font-family`, `background-color`, `color`, and so on. This is useful when you
    want to validate the CSS styles that are applied to your WebElements through your
    test scripts. The API syntax for the `getCssValue()` method is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code, the input parameter is the String value of the CSS property
    name, and the return type is the value assigned to that property name.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code example to retrieve `font-family` of the text from
    the Search box:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding code uses the `getCssValue()` method to find `font-family` of
    the text visible in the Search box. The output of the method is shown here:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The getLocation() method
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `getLocation` method can be executed on all the WebElements. This is used
    to get the relative position of an element where it is rendered on the web page.
    This position is calculated relative to the top-left corner of the web page of
    which the (x, y) coordinates are assumed to be (0, 0). This method will be of
    use if your test script tries to validate the layout of your web page.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'The API syntax of the `getLocation()` method is as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding method obviously doesn't take any input parameters, but the return
    type is a `Point` class that contains the (x, y) coordinates of the element.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code to retrieve the location of the Search box:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output for the preceding code is the (x, y) location of the Search box,
    as shown in the following screenshot:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The getSize() method
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `getSize` method can also be called on all the visible components of HTML.
    It will return the width and height of the rendered WebElement. The API syntax
    of the `getSize()` method is as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding method doesn''t take any input parameters, and the return type
    is a class instance named `Dimension`. This class contains the width and height
    of the target WebElement. The following is the code to get the width and height
    of the Search box:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output for the preceding code is the width and height of the Search box,
    as shown in the following screenshot:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The getTagName() method
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `getTagName` method can be called from all the WebElements. This will return
    the HTML tag name of the WebElement. For example, in the following HTML code,
    the button is the tag name of the HTML element:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding code, the button is the tag name of the HTML element.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'The API syntax for the `getTagName()` method is as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The return type of the preceding method is `String`, and it returns the tag
    name of the target element.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code that returns the tag name of the Search button:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding code uses the `getTagName()` method to get the tag name of the
    Search button element. The output of the code is as expected:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Performing actions on WebElements
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw how to retrieve values or properties of WebElements.
    In this section, we will see how to perform actions on WebElements, which is the
    most crucial part of automation. Let's explore the various methods available in
    the WebElement interface.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: The sendKeys() method
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The`sendKeys`  action is applicable for `textbox` or `textarea` HTML elements.
    This is used to type text into the textbox. This will simulate the user keyboard
    and types text into WebElements exactly as a user would. The API syntax for the
    `sendKeys()` method is as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The input parameter for the preceding method is `CharSequence` of text that
    has to be entered into the element. This method doesn''t return anything. Now,
    let''s see a code example of how to type a search text into the Search box using
    the `sendKeys()` method:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding code, the `sendKeys()` method is used to type the required
    text in the textbox element of the web page. This is how we deal with normal keys,
    but if you want to type in some special keys, such as *Backspace, Enter, Tab,* or* Shift*,
    we need to use a special enum class of WebDriver, named `Keys`. Using the `Keys`
    enumeration, you can simulate many special keys while typing into a WebElement.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see some code example, which uses the *Shift* key to type the text
    in uppercase in the Search Box:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding code, the `chord()` method from the `Keys` enum is used to
    type the key, while the text specified is being given as an input to be the textbox.
    Try this in your environment to see all the text being typed in uppercase.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: The clear() method
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The clear action is similar to the `sendKeys()` method, which is applicable
    for the `textbox` and `textarea` elements. This is used to erase the text entered
    in a WebElement using the `sendKeys()` method. This can be achieved using the
    `Keys.BACK_SPACE` enum, but WebDriver has given us an explicit method to clear
    the text easily. The API syntax for the `clear()` method is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This method doesn't take any input and doesn't return any output. It is simply
    executed on the target text-entry element.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how we can clear text that is entered in the Search box. The
    code example for it is as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We have used the WebElement's `clear()` method to clear the text after typing
    `phones` into the Search box.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: The submit() method
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `submit()` action can be taken on a `Form` or on an element, which is inside
    a `Form` element. This is used to submit a form of a web page to the server hosting
    the web application. The API syntax for the `submit()` method is as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The preceding method doesn't take any input parameters and doesn't return anything.
    But a `NoSuchElementException` is thrown when this method is executed on a WebElement
    that is not present within the form.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see a code example to submit the form on a Search page:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding code, toward the end is where the Search form is submitted
    to the application servers using the `submit()` method. Now, try to execute the
    `submit()` method on an element, let's say the About link, which is not a part
    of any form. We should see `NoSuchElementException` is thrown. So, when you use
    the `submit()` method on a WebElement, make sure it is part of the `Form` element.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Checking the WebElement state
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we saw how to retrieve values and perform actions
    on WebElements. Now, we will see how to check the state of a WebElement. We will
    explore methods to check whether the WebElement is displayed in the Browser window,
    whether it is editable, and if the WebElement is Radio Button of Checkbox, we
    can determine whether it's selected or unselected. Let's see how we can use the
    methods available in the WebElement interface.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: The isDisplayed() method
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `isDisplayed` action verifies whether an element is displayed on the web
    page and can be executed on all the WebElements. The API syntax for the `isDisplayed()`
    method is as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding method returns a `Boolean` value specifying whether the target
    element is displayed on the web page. The following is the code to verify whether
    the Search box is displayed, which obviously should return true in this case:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The preceding code uses the `isDisplayed()` method to determine whether the
    element is displayed on a web page. The preceding code returns `true` for the
    Search box:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The isEnabled() method
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `isEnabled` action verifies whether an element is enabled on the web page
    and can be executed on all the WebElements. The API syntax for the `isEnabled()`
    method is as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The preceding method returns a `Boolean` value specifying whether the target
    element is enabled on the web page. The following is the code to verify whether
    the Search box is enabled, which obviously should return true in this case:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The preceding code uses the `isEnabled()` method to determine whether the element
    is enabled on a web page. The preceding code returns true for the Search box:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The isSelected() method
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `isSelected` method returns a `boolean` value if an element is selected
    on the web page and can be executed only on a radio button, options in select,
    and checkbox WebElements. When executed on other elements, it will return false.
    The API syntax for the `isSelected()` method is as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The preceding method returns a `Boolean` value specifying whether the target
    element is selected on the web page. The following is the code to verify whether
    the Search box is selected on a search page:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The preceding code uses the `isSelected()` method. It returns false for the
    Search box, because this is not a radio button, options in select, or a checkbox. The
    preceding code returns `false` for the Search box:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: To select a Checkbox or Radio button, we need to call the `WebElement.click()`
    method, which toggles the state of the element. We can use the `isSelected()`
    method to see whether it's selected.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a brief overview of the Selenium testing tools,
    and the architecture of WebDriver, WebElements. We learned how to set up a test-development
    environment using Eclipse, Maven, and TestNG. This will provide us with the foundation
    to build a testing framework using Selenium. Then, we saw how to locate elements,
    and the actions that can be taken on them. This is the most important aspect when
    automating Web Applications. In this chapter, we used ChromeDriver to run our
    tests. In the next chapter, we will learn how to configure and run tests on Mozilla
    Firefox, Microsoft IE and Edge, and Apple Safari.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'True or false: Selenium is a browser automation library.'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the different types of locator mechanisms provided by Selenium?
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: With the `getAttribute()` method, we can read CSS attributes
    as well?'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What actions can be performed on a WebElement?
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we determine whether the checkbox is checked or unchecked?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further information
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can check out the following links for more information on the topics covered
    in this chapter:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Read the WebDriver Specification at [https://www.w3.org/TR/webdriver/](https://www.w3.org/TR/webdriver/)
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read more about using TestNG and Maven in *[Chapter 1](9f647c33-1720-4d7b-973b-7d2ef9dad924.xhtml),
    Creating a Faster Feedback Loop* from *Mastering Selenium WebDriver* By Mark Collin,
    Packt Publishing
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read more about element interaction in *Chapter 2, Finding Elements* and *Chapter
    3, Working with Elements* from *Selenium Testing Tools Cookbook*, 2nd Edition,
    by Unmesh Gundecha, Packt Publishing
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
