- en: Chapter 6. Practical Module Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating a Play application with message queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating a Play application with ElasticSearch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing token authentication using JWT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look further into integrating a Play application with
    other essential services and tools for the modern web application. Specifically,
    we will look into how we can integrate an external message queue service with
    a Play plugin. We will use the popular cloud service **IronMQ** for this.
  prefs: []
  type: TYPE_NORMAL
- en: We will also look into integrating a full text search engine service with a
    Play application using **ElasticSearch** and **Docker**.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will implement our own Play wrappers for the integration of token
    authentication using **JSON Web Tokens** (**JWT**).
  prefs: []
  type: TYPE_NORMAL
- en: Integrating a Play application with message queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will explore how to use Play 2.0 to integrate with IronMQ,
    a popular cloud message queue service. We will use IronMQ''s Java libraries, which
    can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/iron-io/iron_mq_java](https://github.com/iron-io/iron_mq_java)'
  prefs: []
  type: TYPE_NORMAL
- en: We will use a Play plugin to initialize our IronMQ client and queue objects,
    and will expose helper methods to send and retrieve messages. We will then use
    this plugin in a Play controller that will allow clients to post messages and
    retrieve messages using the HTTP method, `GET`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Java, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create an IronMQ account on [http://www.iron.io/](http://www.iron.io/) and create
    an IronMQ project; make a note of your project ID and token
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the official IronMQ java libraries as app dependencies in `build.sbt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the plugins package inside `foo_java/app`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create our plugin class, MQPlugin, in the `foo_java/app/plugins` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify `conf/application.conf` and add your IronMQ project ID and token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the MQPlugin by declaring it in the `conf/play.plugins` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Messenger` controller class in `app/controllers`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add new routes for the `Messenger` controller actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using `curl`, let''s send and retrieve messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the IronMQ Web Console, you can also confirm the queue message size to confirm
    that we were able to post a message:![](img/CiOxgcxa.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Scala, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create an IronMQ account on [http://www.iron.io/](http://www.iron.io/) and create
    an IronMQ project; make a note of your project ID and token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the official IronMQ java libraries as app dependencies in `build.sbt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the plugins package in `foo_scala/app`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create our plugin class, MQPlugin, in the `foo_scala/app/plugins` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify `conf/application.conf` and add your IronMQ project ID and token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the MQPlugin by declaring it in the `conf/play.plugins` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Messenger` controller class in `app/controllers`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add new routes for the `Messenger` controller actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using `curl`, let''s send and retrieve messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the IronMQ Web Console, you can also check the queue message size to confirm
    that we were able to post a message:![](img/CZSpoQpf.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we set up the message queue plugin by first importing the official
    IronMQ Java library to `build.sbt`. We will also need to log in to IronMQ to create
    our IronMQ project and to retrieve our project tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/RBXJtXDJ.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We configured the Play application by adding our IronMQ credentials to `conf/application.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We then implemented the `MQPlugin` class by retrieving the project ID and token
    from the config file and passing that to an instance of `io.iron.ironmq.Client`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We created our dynamic message queue in the `onStart` method as well, passing
    a `UUID` parameter as the default queue name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We then declared the two methods that will facilitate message sending and retrieval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We wanted to be able to remove read messages from the queue and run an asynchronous
    function to delete them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For Java, deleting the message will happen synchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we implement the endpoints by creating the controller class, `Messenger`,
    which exposes two actions; one for message retrieval and another for messaging
    posting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, add the respective routes to `conf/routes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Integrating a Play application with ElasticSearch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a very common web application functionality to
    create, index, and search, in our case, products. We will use ElasticSearch as
    our search service. We will use Docker to create our local ElasticSearch container
    and to run all search operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'A prerequisite for this recipe is having access to an ElasticSearch instance,
    either local or remote, in our recipe, as well as having Docker installed in the
    local development machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We used Docker to deploy our local ElasticSearch instance using the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command instructs `docker` to run the `elasticsearch` container
    as a detached service and that ports `9200` and `9300` in the container should
    be accessible from the corresponding ports in the host.
  prefs: []
  type: TYPE_NORMAL
- en: We will use an open source Play module, **play2-elasticsearch**, to wrap our
    calls to the ElasticSearch instance. This recipe assumes some familiarity in Docker
    and full-text searching services. More information about play2-elasticsearch can
    be found at [https://github.com/cleverage/play2-elasticsearch](https://github.com/cleverage/play2-elasticsearch).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information regarding Docker and how to install it, please refer to
    their online documentation at [https://docs.docker.com/installation/](https://docs.docker.com/installation/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Java, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s fire up a local ElasticSearch container using Docker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the play2-elasticsearch dependency in `build.sbt`. It is important to note
    that as of writing this, support for Play 2.3.x has not been released for play2-elasticsearch,
    hence, the need to exclude dependencies to older Play libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the play2-elasticsearch plugin in `conf/play.plugins`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add play2-elasticsearch configuration parameters to `conf/application.conf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the product model in `app/models/Product.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create the products endpoint that will serve the creation and searching
    of products in `app/controllers/Products.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s also add the `Search` class from the helper class to `app/controllers/Search.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s add the routes to the product controller actions to `conf/routes`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using `curl`, we can test product creation and indexing as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also use `curl` to execute product searches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For Scala, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s fire up a local ElasticSearch container using Docker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the play2-elasticsearch dependency in `build.sbt`. It is important to note
    that as of writing this, support for Play 2.3.x has not been released for play2-elasticsearch,
    hence the need to exclude dependencies from older Play libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the play2-elasticsearch plugin in `conf/play.plugins`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add play2-elasticsearch configuration parameters to `conf/application.conf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create our product model and the `ProductManager` class in `app/models/Product.scala`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create the products endpoint that will serve the creation and searching
    of products in `app/controllers/Products.scala`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s add the routes to the product controller actions to `conf/routes`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using `curl`, we can test product creation and indexing as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also use `curl` to execute product searches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we created endpoints for product creation and product search
    utilizing ElasticSearch as the underlying search service. A prerequisite for this
    recipe is having access to an ElasticSearch instance, either local or remote,
    in our recipe, as well as having Docker installed in the local development machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We used Docker to deploy our local ElasticSearch instance using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command instructs `docker` to run the `elasticsearch` container
    as a detached service and that ports `9200` and `9300` in the container should
    be accessible from the corresponding ports in the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by importing an open source play module, play2-elasticsearch, by declaring
    it in the `build.sbt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We activate the plugin in `conf/play.plugins` and specify the configuration
    parameters in `conf/application.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We then created our product model, extending the play2-elasticsearch class,
    Indexable, and a search manager class, which extends the play2-elasticsearch IndexableManager
    class. We wrote a helper method to execute a multifield query to search the title
    and description fields by keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in our controller class, `Products`, we invoked the appropriate product
    manager methods for the creation and search actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon the web application''s start up or reload, you will be able to see logging
    information regarding the initialization of the play2-elasticsearch plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Implementing token authentication using JWT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we integrate the widely-used user authentication strategy, Token
    authentication, with authenticate requests to protected Play actions and endpoints.
    We will use the open source library, **nimbus-jose-jwt**, by Connect2Id to sign-in
    and verify JWT for successful user logins.
  prefs: []
  type: TYPE_NORMAL
- en: Subsequent requests to other protected endpoints and actions will now only require
    the JWT to be added to the request header using the authorization header. Signed
    JWTs will, however, have a prescribed expiration date and we will ensure that
    we validate this for each JWT signed request.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More information about Connect2id and nimbus-jose-jwt can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://connect2id.com/products/nimbus-jose-jwt](http://connect2id.com/products/nimbus-jose-jwt)'
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about JWT is available here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html](http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Java, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `nimbus-jose-jwt` dependency in `build.sbt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using `activator`, generate a new application secret, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the required configuration parameters to `conf/application.conf` using
    the generated secret from the previous step as the value for `jwt.sharedSecret`.
    As for issuer and audience, based on the JWT spec, the issuer is the principal
    issuing the token and the audience is the intended recipient of the token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the JWT Plugin class in `app/plugins/JWTPlugin.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the JWT Plugin in `conf/play.plugins`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an action class inheriting from the `Simple Action` class that we will
    use to secure actions with JWT in `app/controllers/JWTSigned.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create our test actions for logging in and token signing, and another action
    to be secured with `JWTSigned` in `app/controllers/Application.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to create the `Login` model used during user authentication in
    `app/controllers/Login.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the necessary entries to `conf/routes` for our new actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using `curl`, let''s verify that the `/admin` route is gated and secured by
    `JWTSigned`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s sign in and make a note of the returned token in the response
    body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s request the `/admin` route again, but this time, by adding
    the signed token using the authorization header, prefixed with `Bearer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also verify that the JWTPlugin handles token expiration correctly by
    running the previous request again after the expiration is set in the token, and
    it should result in something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For Scala, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `nimbus-jose-jwt` dependency to `build.sbt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using `activator`, generate a new application secret as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the required configuration parameters to `conf/application.conf` using
    the generated secret from the previous step as the value for `jwt.sharedSecret`.
    As for the issuer and audience, based on the JWT spec, the issuer is the principal
    issuing the token and audience is the intended recipient of the token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the JWT Plugin class in `app/plugins/JWTPlugin.scala`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the JWTPlugin in `conf/play.plugins`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `ActionBuilder` class that we will use to secure actions with JWT
    in `app/controllers/JWTSigned.scala`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create test actions for logging in and token signing, and another action to
    be secured with `JWTSigned` in `app/controllers/Application.scala`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the necessary entries to `conf/routes` for our new actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using `curl`, let''s verify that the `/admin` route is gated and secured by
    `JWTSigned`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s sign in and make a note of the returned token in the response
    body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s request the `/admin` route again, but this time, adding the
    signed token using the authorization header, prefixed with `Bearer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also verify that the JWTPlugin handles token expiration correctly by
    running the previous request again after the expiration set in the token, and
    should result in something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we implemented the signing and verification of JWT for the purpose
    of securing Play actions with token authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created a Play plugin, `JWTPlugin`, which will load the configurations from
    the `conf/application.conf` file and also contain method definitions for signing,
    decoding, and verifying JWTs using Connect2id''s nimbus-jose-jwt library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you will notice that we are utilizing HMAC using SHA-256
    as the default hash algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Java, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'For Scala, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'For signing, we build the Claim Set, which is the standard set of token metadata
    according to the JWT spec: you can refer to the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html#Claims](http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html#Claims)'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the appropriate parameter values and adding the user information as the
    claim subject, we then sign and serialize it to a `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify, we get the passed token decoded and verified and then proceed to
    verifying parts of the Claim Set. It returns the Boolean value `true` only when
    the token has passed all verification tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'We then created a `Simple Action` / `Action Builder` class that will do the
    actual JWT verification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will only invoke the next request block if the token passes
    the verification test. It will return an **Http Status Forbidden** error for unsuccessful
    verifications and an **Http Status Unauthorized** error for requests that do not
    have the authorization header set.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now able to secure Play controller actions using the JWTSigned `ActionBuilder`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, what we have is a Play action returning serialized, signed JWTs, and
    an action utilizing the JWTSigned `ActionBuilder` class that secures the action
    from unauthenticated and unauthorized requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
