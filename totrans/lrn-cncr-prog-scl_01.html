<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 1. Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/><span class="koboSpan" id="kobo.1.1">Chapter 1. Introduction</span></h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"><span class="koboSpan" id="kobo.2.1"> </span></td><td valign="top"><p><span class="emphasis"><em><span class="koboSpan" id="kobo.3.1">"For over a decade prophets have voiced the contention that the organization of a single computer has reached its limits and that truly significant advances can be made only by interconnection of a multiplicity of computers."</span></em></span></p></td><td valign="top"><span class="koboSpan" id="kobo.4.1"> </span></td></tr><tr><td valign="top"><span class="koboSpan" id="kobo.5.1"> </span></td><td colspan="2" align="right" valign="top" style="text-align: center"><span class="koboSpan" id="kobo.6.1">--</span><span class="attribution"><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">Gene Amdahl, 1967</span></em></span></span></td></tr></table></div><p><span class="koboSpan" id="kobo.8.1">Although the discipline of concurrent programming has a long history, it has gained a lot of traction in recent years with the arrival of multi core processors. </span><span class="koboSpan" id="kobo.8.2">The recent development in computer hardware not only revived some classical concurrency techniques but also started a major paradigm shift in concurrent programming. </span><span class="koboSpan" id="kobo.8.3">At a time when concurrency is becoming so important, an understanding of concurrent programming is an essential skill for every software developer.</span></p><p><span class="koboSpan" id="kobo.9.1">This chapter explains the basics of concurrent computing and presents some Scala preliminaries required for this book. </span><span class="koboSpan" id="kobo.9.2">Specifically, it does the following:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.10.1">Shows a brief overview of concurrent programming</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.11.1">Studies the advantages of using Scala when it comes to concurrency</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.12.1">Covers the Scala preliminaries required for reading this book</span></li></ul></div><p><span class="koboSpan" id="kobo.13.1">We will start by examining what concurrent programming is and why it is important.</span></p><div class="section" title="Concurrent programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec7"/><span class="koboSpan" id="kobo.14.1">Concurrent programming</span></h1></div></div></div><p><span class="koboSpan" id="kobo.15.1">In </span><span class="strong"><strong><span class="koboSpan" id="kobo.16.1">concurrent programming</span></strong></span><span class="koboSpan" id="kobo.17.1">, we express a program as a set of concurrent computations that execute during overlapping time intervals and coordinate in some way. </span><span class="koboSpan" id="kobo.17.2">Implementing a concurrent program that functions correctly is usually much harder than implementing a sequential one. </span><span class="koboSpan" id="kobo.17.3">All the pitfalls present in sequential programming lurk in every concurrent program, but there are many other things that can go wrong, as we will learn in this book. </span><span class="koboSpan" id="kobo.17.4">A natural question arises: why bother? </span><span class="koboSpan" id="kobo.17.5">Can't we just keep writing sequential programs?</span></p><p><span class="koboSpan" id="kobo.18.1">Concurrent programming has multiple advantages. </span><span class="koboSpan" id="kobo.18.2">First, increased concurrency can improve </span><span class="strong"><strong><span class="koboSpan" id="kobo.19.1">program performance</span></strong></span><span class="koboSpan" id="kobo.20.1">. </span><span class="koboSpan" id="kobo.20.2">Instead of executing the entire program on a single processor, different subcomputations can be performed on separate processors, making the program run faster. </span><span class="koboSpan" id="kobo.20.3">With the spread of multicore processors, this is the primary reason why concurrent programming is nowadays getting so much attention.</span></p><p><span class="koboSpan" id="kobo.21.1">A concurrent programming model can result in faster I/O operations. </span><span class="koboSpan" id="kobo.21.2">A purely sequential program must periodically poll I/O to check if there is any data input available from the keyboard, the network interface, or some other device. </span><span class="koboSpan" id="kobo.21.3">A concurrent program, on the other hand, can react to I/O requests immediately. </span><span class="koboSpan" id="kobo.21.4">For I/O-intensive operations, this results in improved throughput, and is one of the reasons why concurrent programming support existed in programming languages even before the appearance of multiprocessors. </span><span class="koboSpan" id="kobo.21.5">Thus, concurrency can ensure the improved </span><span class="strong"><strong><span class="koboSpan" id="kobo.22.1">responsiveness</span></strong></span><span class="koboSpan" id="kobo.23.1"> of a program that interacts with the environment.</span></p><p><span class="koboSpan" id="kobo.24.1">Finally, concurrency can simplify the </span><span class="strong"><strong><span class="koboSpan" id="kobo.25.1">implementation</span></strong></span><span class="koboSpan" id="kobo.26.1"> and </span><span class="strong"><strong><span class="koboSpan" id="kobo.27.1">maintainability</span></strong></span><span class="koboSpan" id="kobo.28.1"> of computer programs. </span><span class="koboSpan" id="kobo.28.2">Some programs can be represented more concisely using concurrency. </span><span class="koboSpan" id="kobo.28.3">It can be more convenient to divide the program into smaller, independent computations than to incorporate everything into one large program. </span><span class="koboSpan" id="kobo.28.4">User interfaces, web servers, and game engines are typical examples of such systems.</span></p><p><span class="koboSpan" id="kobo.29.1">In this book, we adopt the convention that concurrent programs communicate through the use of shared memory, and execute on a single computer. </span><span class="koboSpan" id="kobo.29.2">By contrast, a computer program that executes on multiple computers, each with its own memory, is called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.30.1">distributed program</span></strong></span><span class="koboSpan" id="kobo.31.1">, and the discipline of writing such programs is called </span><span class="strong"><strong><span class="koboSpan" id="kobo.32.1">distributed programming</span></strong></span><span class="koboSpan" id="kobo.33.1">. </span><span class="koboSpan" id="kobo.33.2">Typically, a distributed program must assume that each of the computers can fail at any point, and provide some safety guarantees if this happens. </span><span class="koboSpan" id="kobo.33.3">We will mostly focus on concurrent programs, but we will also look at examples of distributed programs.</span></p><div class="section" title="A brief overview of traditional concurrency"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/><span class="koboSpan" id="kobo.34.1">A brief overview of traditional concurrency</span></h2></div></div></div><p><span class="koboSpan" id="kobo.35.1">In a computer system, concurrency can manifest itself in the computer hardware, at the operating system level, or at the programming language level. </span><span class="koboSpan" id="kobo.35.2">We will focus mainly on programming-language-level concurrency.</span></p><p><span class="koboSpan" id="kobo.36.1">The coordination of multiple executions in a concurrent system is called </span><span class="strong"><strong><span class="koboSpan" id="kobo.37.1">synchronization</span></strong></span><span class="koboSpan" id="kobo.38.1">, and it is a key part in successfully implementing concurrency. </span><span class="koboSpan" id="kobo.38.2">Synchronization includes mechanisms used to order concurrent executions in time. </span><span class="koboSpan" id="kobo.38.3">Furthermore, synchronization specifies how concurrent executions communicate, that is, how they exchange information. </span><span class="koboSpan" id="kobo.38.4">In concurrent programs, different executions interact by modifying the shared memory subsystem of the computer. </span><span class="koboSpan" id="kobo.38.5">This type of synchronization is called </span><span class="strong"><strong><span class="koboSpan" id="kobo.39.1">shared memory communication</span></strong></span><span class="koboSpan" id="kobo.40.1">. </span><span class="koboSpan" id="kobo.40.2">In distributed programs, executions interact by exchanging messages, so this type of synchronization is called </span><span class="strong"><strong><span class="koboSpan" id="kobo.41.1">message-passing communication</span></strong></span><span class="koboSpan" id="kobo.42.1">.</span></p><p><span class="koboSpan" id="kobo.43.1">At the lowest level, concurrent executions are represented by entities called processes and threads, covered in </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.44.1">Chapter 2</span></a><span class="koboSpan" id="kobo.45.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.46.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.47.1">. </span><span class="koboSpan" id="kobo.47.2">Processes and threads traditionally use entities such as locks and monitors to order parts of their execution. </span><span class="koboSpan" id="kobo.47.3">Establishing an order between the threads ensures that the memory modifications done by one thread are visible to a thread that executes later.</span></p><p><span class="koboSpan" id="kobo.48.1">Often, expressing concurrent programs using threads and locks is cumbersome. </span><span class="koboSpan" id="kobo.48.2">More complex concurrent facilities have been developed to address this, such as communication channels, concurrent collections, barriers, countdown latches, and thread pools. </span><span class="koboSpan" id="kobo.48.3">These facilities are designed to more easily express specific concurrent programming patterns, and some of them are covered in </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.49.1">Chapter 3</span></a><span class="koboSpan" id="kobo.50.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.51.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.52.1">.</span></p><p><span class="koboSpan" id="kobo.53.1">Traditional concurrency is relatively low-level and prone to various kinds of errors, such as deadlocks, starvations, data races, and race conditions. </span><span class="koboSpan" id="kobo.53.2">You will usually not use low-level concurrency primitives when writing concurrent Scala programs. </span><span class="koboSpan" id="kobo.53.3">Still, a basic knowledge of low-level concurrent programming will prove invaluable in understanding high-level concurrency concepts later.</span></p></div><div class="section" title="Modern concurrency paradigms"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/><span class="koboSpan" id="kobo.54.1">Modern concurrency paradigms</span></h2></div></div></div><p><span class="koboSpan" id="kobo.55.1">Modern concurrency paradigms are more advanced than traditional approaches to concurrency. </span><span class="koboSpan" id="kobo.55.2">Here, the crucial difference lies in the fact that a high-level concurrency framework expresses </span><span class="emphasis"><em><span class="koboSpan" id="kobo.56.1">which</span></em></span><span class="koboSpan" id="kobo.57.1"> goal to achieve, rather than </span><span class="emphasis"><em><span class="koboSpan" id="kobo.58.1">how to achieve</span></em></span><span class="koboSpan" id="kobo.59.1"> that goal.</span></p><p><span class="koboSpan" id="kobo.60.1">In practice, the difference between low-level and high-level concurrency is less clear, and different concurrency frameworks form a continuum rather than two distinct groups. </span><span class="koboSpan" id="kobo.60.2">Still, recent developments in concurrent programming show a bias towards declarative and functional programming styles.</span></p><p><span class="koboSpan" id="kobo.61.1">As we will see in </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.62.1">Chapter 2</span></a><span class="koboSpan" id="kobo.63.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.64.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.65.1">, computing a value concurrently requires creating a thread with a custom </span><code class="literal"><span class="koboSpan" id="kobo.66.1">run</span></code><span class="koboSpan" id="kobo.67.1"> method, invoking the </span><code class="literal"><span class="koboSpan" id="kobo.68.1">start</span></code><span class="koboSpan" id="kobo.69.1"> method, waiting until the thread completes, and then inspecting specific memory locations to read the result. </span><span class="koboSpan" id="kobo.69.2">Here, what we really want to say is </span><span class="emphasis"><em><span class="koboSpan" id="kobo.70.1">compute some value concurrently, and inform me when you are done</span></em></span><span class="koboSpan" id="kobo.71.1">. </span><span class="koboSpan" id="kobo.71.2">Furthermore, we would prefer to use a programming model that abstracts over the coordination details of the concurrent computation, to treat the result of the computation as if we already have it, rather than having to wait for it and then reading it from the memory. </span><span class="strong"><strong><span class="koboSpan" id="kobo.72.1">Asynchronous programming using futures</span></strong></span><span class="koboSpan" id="kobo.73.1"> is a paradigm designed to specifically support these kinds of statements, as we will learn in </span><a class="link" href="ch04.html" title="Chapter 4.  Asynchronous Programming with Futures and Promises"><span class="koboSpan" id="kobo.74.1">Chapter 4</span></a><span class="koboSpan" id="kobo.75.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.76.1">Asynchronous Programming with Futures and Promises</span></em></span><span class="koboSpan" id="kobo.77.1">. </span><span class="koboSpan" id="kobo.77.2">Similarly, </span><span class="strong"><strong><span class="koboSpan" id="kobo.78.1">reactive programming using event streams</span></strong></span><span class="koboSpan" id="kobo.79.1"> aims to declaratively express concurrent computations that produce many values, as we will see in </span><a class="link" href="ch06.html" title="Chapter 6. Concurrent Programming with Reactive Extensions"><span class="koboSpan" id="kobo.80.1">Chapter 6</span></a><span class="koboSpan" id="kobo.81.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.82.1">Concurrent Programming with Reactive Extensions</span></em></span><span class="koboSpan" id="kobo.83.1">.</span></p><p><span class="koboSpan" id="kobo.84.1">The declarative programming style is increasingly common in sequential programming too. </span><span class="koboSpan" id="kobo.84.2">Languages such as Python, Haskell, Ruby, and Scala express operations on their collections in terms of functional operators and allow statements such as </span><span class="emphasis"><em><span class="koboSpan" id="kobo.85.1">filter all negative integers from this collection</span></em></span><span class="koboSpan" id="kobo.86.1">. </span><span class="koboSpan" id="kobo.86.2">This statement expresses a goal rather than the underlying implementation, allowing to it easy to parallelize such an operation behind the scene. </span><a class="link" href="ch05.html" title="Chapter 5. Data-Parallel Collections"><span class="koboSpan" id="kobo.87.1">Chapter 5</span></a><span class="koboSpan" id="kobo.88.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.89.1">Data-Parallel Collections</span></em></span><span class="koboSpan" id="kobo.90.1">, describes the </span><span class="strong"><strong><span class="koboSpan" id="kobo.91.1">data-parallel</span></strong></span><span class="koboSpan" id="kobo.92.1"> collections framework available in Scala, which is designed to accelerate collection operations using multicores.</span></p><p><span class="koboSpan" id="kobo.93.1">Another trend seen in high-level concurrency frameworks is specialization towards specific tasks. </span><span class="koboSpan" id="kobo.93.2">Software transactional memory technology is specifically designed to express memory transactions and does not deal with how to start concurrent executions at all. </span><span class="koboSpan" id="kobo.93.3">A </span><span class="strong"><strong><span class="koboSpan" id="kobo.94.1">memory transaction</span></strong></span><span class="koboSpan" id="kobo.95.1"> is a sequence of memory operations that appear as if they either execute all at once or do not execute at all. </span><span class="koboSpan" id="kobo.95.2">This is similar to the concept of database transactions. </span><span class="koboSpan" id="kobo.95.3">The advantage of using memory transactions is that this avoids a lot of errors typically associated with low-level concurrency. </span><a class="link" href="ch07.html" title="Chapter 7. Software Transactional Memory"><span class="koboSpan" id="kobo.96.1">Chapter 7</span></a><span class="koboSpan" id="kobo.97.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.98.1">Software Transactional Memory</span></em></span><span class="koboSpan" id="kobo.99.1">, explains software transactional memory in detail.</span></p><p><span class="koboSpan" id="kobo.100.1">Finally, some high-level concurrency frameworks aim to transparently provide distributed programming support as well. </span><span class="koboSpan" id="kobo.100.2">This is especially true for data-parallel frameworks and message-passing concurrency frameworks, such as the </span><span class="strong"><strong><span class="koboSpan" id="kobo.101.1">actors</span></strong></span><span class="koboSpan" id="kobo.102.1"> described in Chapter 8, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.103.1">Actors</span></em></span><span class="koboSpan" id="kobo.104.1">.</span></p></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="The advantages of Scala"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec8"/><span class="koboSpan" id="kobo.1.1">The advantages of Scala</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Although Scala is still a language on the rise, it has yet to receive the wide-scale adoption of a language such as Java; nonetheless its support for concurrent programming is rich and powerful. </span><span class="koboSpan" id="kobo.2.2">Concurrency frameworks for nearly all the different styles of concurrent programming exist in the Scala ecosystem and are being actively developed. </span><span class="koboSpan" id="kobo.2.3">Throughout its development, Scala has pushed the boundaries when it comes to providing modern, high-level application programming interfaces or APIs for concurrent programming. </span><span class="koboSpan" id="kobo.2.4">There are many reasons for this.</span></p><p><span class="koboSpan" id="kobo.3.1">The primary reason that so many modern concurrency frameworks have found their way into Scala is its inherent syntactic flexibility. </span><span class="koboSpan" id="kobo.3.2">Thanks to features such as first-class functions, byname parameters, type inference, and pattern matching explained in the following sections, it is possible to define APIs that look as if they are built-in language features.</span></p><p><span class="koboSpan" id="kobo.4.1">Such APIs emulate various programming models as embedded domain-specific languages, with Scala serving as a host language: actors, software transactional memory, and futures are examples of APIs that look like they are basic language features when they are in fact implemented as libraries. </span><span class="koboSpan" id="kobo.4.2">On one hand, Scala avoids the need for developing a new language for each new concurrent programming model and serves as a rich nesting ground for modern concurrency frameworks. </span><span class="koboSpan" id="kobo.4.3">On the other hand, lifting the syntactic burden present in many other languages attracts more users.</span></p><p><span class="koboSpan" id="kobo.5.1">The second reason Scala has pushed ahead lies in the fact that it is a safe language. </span><span class="koboSpan" id="kobo.5.2">Automatic garbage collection, automatic bound checks, and the lack of pointer arithmetic helps to avoid problems such as memory leaks, buffer overflows, and other memory errors. </span><span class="koboSpan" id="kobo.5.3">Similarly, static type safety eliminates a lot of programming errors at an early stage. </span><span class="koboSpan" id="kobo.5.4">When it comes to concurrent programming, which is in itself prone to various kinds of concurrency errors, having one less thing to worry about can make a world of difference.</span></p><p><span class="koboSpan" id="kobo.6.1">The third important reason is interoperability. </span><span class="koboSpan" id="kobo.6.2">Scala programs are compiled into Java bytecode, so the resulting executable code runs on top of the </span><span class="strong"><strong><span class="koboSpan" id="kobo.7.1">Java Virtual Machine</span></strong></span><span class="koboSpan" id="kobo.8.1"> (</span><span class="strong"><strong><span class="koboSpan" id="kobo.9.1">JVM</span></strong></span><span class="koboSpan" id="kobo.10.1">). </span><span class="koboSpan" id="kobo.10.2">This means that Scala programs can seamlessly use existing Java libraries, and interact with Java's rich ecosystem. </span><span class="koboSpan" id="kobo.10.3">Often, transitioning to a different language is a painful process. </span><span class="koboSpan" id="kobo.10.4">In the case of Scala, a transition from a language such as Java can proceed gradually and is much easier. </span><span class="koboSpan" id="kobo.10.5">This is one of the reasons for its growing adoption, and also a reason why some Java-compatible frameworks choose Scala as their implementation language.</span></p><p><span class="koboSpan" id="kobo.11.1">Importantly, the fact that Scala runs on the JVM implies that Scala programs are portable across a range of different platforms. </span><span class="koboSpan" id="kobo.11.2">Not only that, but the JVM has well-defined threading and memory models, which are guaranteed to work in the same way on different computers. </span><span class="koboSpan" id="kobo.11.3">While portability is important for the consistent semantics of sequential programs, it is even more important when it comes to concurrent computing.</span></p><p><span class="koboSpan" id="kobo.12.1">Having seen some of Scala's advantages for concurrent programming, we are now ready to study the language features relevant for this book.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Preliminaries"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec9"/><span class="koboSpan" id="kobo.1.1">Preliminaries</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">This book assumes a basic familiarity with sequential programming. </span><span class="koboSpan" id="kobo.2.2">While we advise readers to get acquainted with the Scala programming language, an understanding of a similar language, such as Java or C#, should be sufficient for this book. </span><span class="koboSpan" id="kobo.2.3">A basic familiarity with concepts in object-oriented programming, such as classes, objects, and interfaces, is helpful. </span><span class="koboSpan" id="kobo.2.4">Similarly, a basic understanding of functional programming principles, such as first-class functions, purity, and type-polymorphism are beneficial in understanding this book but are not a strict prerequisite.</span></p><div class="section" title="Execution of a Scala program"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/><span class="koboSpan" id="kobo.3.1">Execution of a Scala program</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">To better understand the execution model of Scala programs, let's consider a simple program that uses the </span><code class="literal"><span class="koboSpan" id="kobo.5.1">square</span></code><span class="koboSpan" id="kobo.6.1"> method to compute the square value of the number </span><code class="literal"><span class="koboSpan" id="kobo.7.1">5</span></code><span class="koboSpan" id="kobo.8.1">, and then prints the result to the standard output:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">object SquareOf5 extends App { 
  def square(x: Int): Int = x * x 
  val s = square(5) 
  println(s"Result: $s") 
} 
</span></pre><p><span class="koboSpan" id="kobo.10.1">We can run this program using the </span><span class="strong"><strong><span class="koboSpan" id="kobo.11.1">Simple Build Tool</span></strong></span><span class="koboSpan" id="kobo.12.1"> (</span><span class="strong"><strong><span class="koboSpan" id="kobo.13.1">SBT</span></strong></span><span class="koboSpan" id="kobo.14.1">), as described in the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.15.1">Preface</span></em></span><span class="koboSpan" id="kobo.16.1">. </span><span class="koboSpan" id="kobo.16.2">When a Scala program runs, the JVM runtime allocates the memory required for the program. </span><span class="koboSpan" id="kobo.16.3">Here, we consider two important memory regions--the </span><span class="strong"><strong><span class="koboSpan" id="kobo.17.1">call stack</span></strong></span><span class="koboSpan" id="kobo.18.1"> and the </span><span class="strong"><strong><span class="koboSpan" id="kobo.19.1">object heap</span></strong></span><span class="koboSpan" id="kobo.20.1">. </span><span class="koboSpan" id="kobo.20.2">The call stack is a region of memory in which the program stores information about the local variables and parameters of the currently executed methods. </span><span class="koboSpan" id="kobo.20.3">The object heap is a region of memory in which objects are allocated by the program. </span><span class="koboSpan" id="kobo.20.4">To understand the difference between the two regions, we consider a simplified scenario of this program's execution.</span></p><p><span class="koboSpan" id="kobo.21.1">First, in figure </span><span class="strong"><strong><span class="koboSpan" id="kobo.22.1">1</span></strong></span><span class="koboSpan" id="kobo.23.1">, the program allocates an entry to the call stack for the local variable </span><code class="literal"><span class="koboSpan" id="kobo.24.1">s</span></code><span class="koboSpan" id="kobo.25.1">. </span><span class="koboSpan" id="kobo.25.2">Then, it calls the </span><code class="literal"><span class="koboSpan" id="kobo.26.1">square</span></code><span class="koboSpan" id="kobo.27.1"> method in figure </span><span class="strong"><strong><span class="koboSpan" id="kobo.28.1">2</span></strong></span><span class="koboSpan" id="kobo.29.1"> to compute the value for the local variable </span><code class="literal"><span class="koboSpan" id="kobo.30.1">s</span></code><span class="koboSpan" id="kobo.31.1">. </span><span class="koboSpan" id="kobo.31.2">The program places the value </span><code class="literal"><span class="koboSpan" id="kobo.32.1">5</span></code><span class="koboSpan" id="kobo.33.1"> on the call stack, which serves as the value for the </span><code class="literal"><span class="koboSpan" id="kobo.34.1">x</span></code><span class="koboSpan" id="kobo.35.1"> parameter. </span><span class="koboSpan" id="kobo.35.2">It also reserves a stack entry for the return value of the method. </span><span class="koboSpan" id="kobo.35.3">At this point, the program can execute the </span><code class="literal"><span class="koboSpan" id="kobo.36.1">square</span></code><span class="koboSpan" id="kobo.37.1"> method, so it multiplies the </span><code class="literal"><span class="koboSpan" id="kobo.38.1">x</span></code><span class="koboSpan" id="kobo.39.1"> parameter by itself, and places the return value </span><code class="literal"><span class="koboSpan" id="kobo.40.1">25</span></code><span class="koboSpan" id="kobo.41.1"> on the stack in figure </span><span class="strong"><strong><span class="koboSpan" id="kobo.42.1">3</span></strong></span><span class="koboSpan" id="kobo.43.1">. </span><span class="koboSpan" id="kobo.43.2">This is shown in the first row in the following illustration:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.44.1"><img src="graphics/B05779_01_01.jpg" alt="Execution of a Scala program"/></span></div><p><span class="koboSpan" id="kobo.45.1">After the </span><code class="literal"><span class="koboSpan" id="kobo.46.1">square</span></code><span class="koboSpan" id="kobo.47.1"> method returns the result, the result </span><code class="literal"><span class="koboSpan" id="kobo.48.1">25</span></code><span class="koboSpan" id="kobo.49.1"> is copied into the stack entry for the local variable </span><code class="literal"><span class="koboSpan" id="kobo.50.1">s</span></code><span class="koboSpan" id="kobo.51.1">, as shown in figure </span><span class="strong"><strong><span class="koboSpan" id="kobo.52.1">4</span></strong></span><span class="koboSpan" id="kobo.53.1">. </span><span class="koboSpan" id="kobo.53.2">Now, the program must create the string for the </span><code class="literal"><span class="koboSpan" id="kobo.54.1">println</span></code><span class="koboSpan" id="kobo.55.1"> statement. </span><span class="koboSpan" id="kobo.55.2">In Scala, strings are represented as object instances of the </span><code class="literal"><span class="koboSpan" id="kobo.56.1">String</span></code><span class="koboSpan" id="kobo.57.1"> class, so the program allocates a new </span><code class="literal"><span class="koboSpan" id="kobo.58.1">String</span></code><span class="koboSpan" id="kobo.59.1"> object to the object heap, as illustrated in figure </span><span class="strong"><strong><span class="koboSpan" id="kobo.60.1">5</span></strong></span><span class="koboSpan" id="kobo.61.1">. </span><span class="koboSpan" id="kobo.61.2">Finally, in figure </span><span class="strong"><strong><span class="koboSpan" id="kobo.62.1">6</span></strong></span><span class="koboSpan" id="kobo.63.1">, the program stores the reference to the newly allocated object into the stack entry </span><code class="literal"><span class="koboSpan" id="kobo.64.1">x</span></code><span class="koboSpan" id="kobo.65.1">, and calls the </span><code class="literal"><span class="koboSpan" id="kobo.66.1">println</span></code><span class="koboSpan" id="kobo.67.1"> method.</span></p><p><span class="koboSpan" id="kobo.68.1">Although this demonstration is greatly simplified, it shows the basic execution model for Scala programs. </span><span class="koboSpan" id="kobo.68.2">In </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.69.1">Chapter 2</span></a><span class="koboSpan" id="kobo.70.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.71.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.72.1">, we will learn that each thread of execution maintains a separate call stack, and that threads mainly communicate by modifying the object heap. </span><span class="koboSpan" id="kobo.72.2">We will learn that the disparity between the state of the heap and the local call stack is frequently responsible for certain kinds of error in concurrent programs.</span></p><p><span class="koboSpan" id="kobo.73.1">Having seen an example of how Scala programs are typically executed, we now proceed to an overview of Scala features that are essential to understand the contents of this book.</span></p></div><div class="section" title="A Scala primer"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/><span class="koboSpan" id="kobo.74.1">A Scala primer</span></h2></div></div></div><p><span class="koboSpan" id="kobo.75.1">In this section, we present a short overview of the Scala programming language features that are used in the examples in this book. </span><span class="koboSpan" id="kobo.75.2">This is a quick and cursory glance through the basics of Scala. </span><span class="koboSpan" id="kobo.75.3">Note that this section is not meant to be a complete introduction to Scala. </span><span class="koboSpan" id="kobo.75.4">This is to remind you about some of the language's features, and contrast them with similar languages that might be familiar to you. </span><span class="koboSpan" id="kobo.75.5">If you would like to learn more about Scala, refer to some of the books referred to in the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.76.1">Summary</span></em></span><span class="koboSpan" id="kobo.77.1"> of this chapter.</span></p><p><span class="koboSpan" id="kobo.78.1">A </span><code class="literal"><span class="koboSpan" id="kobo.79.1">Printer</span></code><span class="koboSpan" id="kobo.80.1"> class, which takes a </span><code class="literal"><span class="koboSpan" id="kobo.81.1">greeting</span></code><span class="koboSpan" id="kobo.82.1"> parameter and has two methods named </span><code class="literal"><span class="koboSpan" id="kobo.83.1">printMessage</span></code><span class="koboSpan" id="kobo.84.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.85.1">printNumber</span></code><span class="koboSpan" id="kobo.86.1">, is declared as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.87.1">class Printer(val greeting: String) { 
  def printMessage(): Unit = println(greeting + "!") 
  def printNumber(x: Int): Unit = { 
    println("Number: " + x) 
  } 
}
</span></pre><p><span class="koboSpan" id="kobo.88.1">In the preceding code, the </span><code class="literal"><span class="koboSpan" id="kobo.89.1">printMessage</span></code><span class="koboSpan" id="kobo.90.1"> method does not take any arguments and contains a single </span><code class="literal"><span class="koboSpan" id="kobo.91.1">println</span></code><span class="koboSpan" id="kobo.92.1"> statement. </span><span class="koboSpan" id="kobo.92.2">The </span><code class="literal"><span class="koboSpan" id="kobo.93.1">printNumber</span></code><span class="koboSpan" id="kobo.94.1"> method takes a single argument </span><code class="literal"><span class="koboSpan" id="kobo.95.1">x</span></code><span class="koboSpan" id="kobo.96.1"> of the </span><code class="literal"><span class="koboSpan" id="kobo.97.1">Int</span></code><span class="koboSpan" id="kobo.98.1"> type. </span><span class="koboSpan" id="kobo.98.2">Neither method returns a value, which is denoted by the </span><code class="literal"><span class="koboSpan" id="kobo.99.1">Unit</span></code><span class="koboSpan" id="kobo.100.1"> type.</span></p><p><span class="koboSpan" id="kobo.101.1">We instantiate the class and call its methods as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.102.1">val printy = new Printer("Hi") 
printy.printMessage() 
printy.printNumber(5) 
</span></pre><p><span class="koboSpan" id="kobo.103.1">Scala allows the declaration of </span><span class="strong"><strong><span class="koboSpan" id="kobo.104.1">singleton objects</span></strong></span><span class="koboSpan" id="kobo.105.1">. </span><span class="koboSpan" id="kobo.105.2">This is like declaring a class and instantiating its single instance at the same time. </span><span class="koboSpan" id="kobo.105.3">We saw the </span><code class="literal"><span class="koboSpan" id="kobo.106.1">SquareOf5</span></code><span class="koboSpan" id="kobo.107.1"> singleton object earlier, which was used to declare a simple Scala program. </span><span class="koboSpan" id="kobo.107.2">The following singleton object, named </span><code class="literal"><span class="koboSpan" id="kobo.108.1">Test</span></code><span class="koboSpan" id="kobo.109.1">, declares a single </span><code class="literal"><span class="koboSpan" id="kobo.110.1">Pi</span></code><span class="koboSpan" id="kobo.111.1"> field and initializes it with the value </span><code class="literal"><span class="koboSpan" id="kobo.112.1">3.14</span></code><span class="koboSpan" id="kobo.113.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.114.1">object Test { 
  val Pi = 3.14 
} 
</span></pre><p><span class="koboSpan" id="kobo.115.1">While classes in similar languages extend entities that are called interfaces, Scala classes can extend </span><span class="strong"><strong><span class="koboSpan" id="kobo.116.1">traits</span></strong></span><span class="koboSpan" id="kobo.117.1">. </span><span class="koboSpan" id="kobo.117.2">Scala's traits allow declaring both concrete fields and method implementations. </span><span class="koboSpan" id="kobo.117.3">In the following example, we declare the </span><code class="literal"><span class="koboSpan" id="kobo.118.1">Logging</span></code><span class="koboSpan" id="kobo.119.1"> trait, which outputs a custom error and warning messages using the abstract </span><code class="literal"><span class="koboSpan" id="kobo.120.1">log</span></code><span class="koboSpan" id="kobo.121.1"> method, and then mix the trait into the </span><code class="literal"><span class="koboSpan" id="kobo.122.1">PrintLogging</span></code><span class="koboSpan" id="kobo.123.1"> class:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.124.1">trait Logging { 
  def log(s: String): Unit 
  def warn(s: String) = log("WARN: " + s) 
  def error(s: String) = log("ERROR: " + s) 
} 
class PrintLogging extends Logging { 
  def log(s: String) = println(s) 
} 
</span></pre><p><span class="koboSpan" id="kobo.125.1">Classes can have </span><span class="strong"><strong><span class="koboSpan" id="kobo.126.1">type parameters</span></strong></span><span class="koboSpan" id="kobo.127.1">. </span><span class="koboSpan" id="kobo.127.2">The following generic </span><code class="literal"><span class="koboSpan" id="kobo.128.1">Pair</span></code><span class="koboSpan" id="kobo.129.1"> class takes two type parameters, </span><code class="literal"><span class="koboSpan" id="kobo.130.1">P</span></code><span class="koboSpan" id="kobo.131.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.132.1">Q</span></code><span class="koboSpan" id="kobo.133.1">, which determines the types of its arguments, named </span><code class="literal"><span class="koboSpan" id="kobo.134.1">first</span></code><span class="koboSpan" id="kobo.135.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.136.1">second</span></code><span class="koboSpan" id="kobo.137.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.138.1">class Pair[P, Q](val first: P, val second: Q) 
</span></pre><p><span class="koboSpan" id="kobo.139.1">Scala has support for first-class function objects, also called </span><span class="strong"><strong><span class="koboSpan" id="kobo.140.1">lambdas</span></strong></span><span class="koboSpan" id="kobo.141.1">. </span><span class="koboSpan" id="kobo.141.2">In the following code snippet, we declare a </span><code class="literal"><span class="koboSpan" id="kobo.142.1">twice</span></code><span class="koboSpan" id="kobo.143.1"> lambda, which multiplies its argument by two:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.144.1">val twice: Int =&gt; Int = (x: Int) =&gt; x * 2 
</span></pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip3"/><span class="koboSpan" id="kobo.145.1">Tip</span></h3><p><span class="strong"><strong><span class="koboSpan" id="kobo.146.1">Downloading the example code:</span></strong></span></p><p><span class="koboSpan" id="kobo.147.1">You can download the example code files for all Packt books you have purchased from your account at </span><a class="ulink" href="http://www.packtpub.com"><span class="koboSpan" id="kobo.148.1">http://www.packtpub.com</span></a><span class="koboSpan" id="kobo.149.1">. </span><span class="koboSpan" id="kobo.149.2">If you purchased this book elsewhere, you can visit </span><a class="ulink" href="http://www.packtpub.com/support"><span class="koboSpan" id="kobo.150.1">http://www.packtpub.com/support</span></a><span class="koboSpan" id="kobo.151.1"> and register to have the files e-mailed directly to you.</span></p></div></div><p><span class="koboSpan" id="kobo.152.1">In the preceding code, the </span><code class="literal"><span class="koboSpan" id="kobo.153.1">(x: Int)</span></code><span class="koboSpan" id="kobo.154.1"> part is the argument to the lambda, and </span><code class="literal"><span class="koboSpan" id="kobo.155.1">x * 2</span></code><span class="koboSpan" id="kobo.156.1"> is its body. </span><span class="koboSpan" id="kobo.156.2">The </span><code class="literal"><span class="koboSpan" id="kobo.157.1">=&gt;</span></code><span class="koboSpan" id="kobo.158.1"> symbol must be placed between the arguments and the body of the lambda. </span><span class="koboSpan" id="kobo.158.2">The same </span><code class="literal"><span class="koboSpan" id="kobo.159.1">=&gt;</span></code><span class="koboSpan" id="kobo.160.1"> symbol is also used to express the type of the lambda, which is </span><code class="literal"><span class="koboSpan" id="kobo.161.1">Int =&gt; Int</span></code><span class="koboSpan" id="kobo.162.1">, pronounced as </span><code class="literal"><span class="koboSpan" id="kobo.163.1">Int</span></code><span class="koboSpan" id="kobo.164.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.165.1">Int</span></code><span class="koboSpan" id="kobo.166.1">. </span><span class="koboSpan" id="kobo.166.2">In the preceding example, we can omit the type annotation </span><code class="literal"><span class="koboSpan" id="kobo.167.1">Int =&gt; Int</span></code><span class="koboSpan" id="kobo.168.1">, and the compiler will infer the type of the </span><code class="literal"><span class="koboSpan" id="kobo.169.1">twice</span></code><span class="koboSpan" id="kobo.170.1"> lambda automatically, as shown in the following code:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.171.1">val twice = (x: Int) =&gt; x * 2 
</span></pre><p><span class="koboSpan" id="kobo.172.1">Alternatively, we can omit the type annotation in the lambda declaration and arrive at a more convenient syntax, as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.173.1">val twice: Int =&gt; Int = x =&gt; x * 2 
</span></pre><p><span class="koboSpan" id="kobo.174.1">Finally, whenever the argument to the lambda appears only once in the body of the lambda, Scala allows a more convenient syntax, as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.175.1">val twice: Int =&gt; Int = _ * 2 
</span></pre><p><span class="koboSpan" id="kobo.176.1">First-class functions allow manipulating blocks of code as if they were first-class values. </span><span class="koboSpan" id="kobo.176.2">They allow a more lightweight and concise syntax. </span><span class="koboSpan" id="kobo.176.3">In the following example, we use </span><span class="strong"><strong><span class="koboSpan" id="kobo.177.1">byname parameters</span></strong></span><span class="koboSpan" id="kobo.178.1"> to declare a </span><code class="literal"><span class="koboSpan" id="kobo.179.1">runTwice</span></code><span class="koboSpan" id="kobo.180.1"> method, which runs the specified block of code </span><code class="literal"><span class="koboSpan" id="kobo.181.1">body</span></code><span class="koboSpan" id="kobo.182.1"> twice:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.183.1">def runTwice(body: =&gt;Unit) = { 
  body 
  body 
} 
</span></pre><p><span class="koboSpan" id="kobo.184.1">A byname parameter is formed by putting the </span><code class="literal"><span class="koboSpan" id="kobo.185.1">=&gt;</span></code><span class="koboSpan" id="kobo.186.1"> annotation before the type. </span><span class="koboSpan" id="kobo.186.2">Whenever the </span><code class="literal"><span class="koboSpan" id="kobo.187.1">runTwice</span></code><span class="koboSpan" id="kobo.188.1"> method references the </span><code class="literal"><span class="koboSpan" id="kobo.189.1">body</span></code><span class="koboSpan" id="kobo.190.1"> argument, the expression is re-evaluated, as shown in the following snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.191.1">runTwice { // this will print Hello twice 
  println("Hello") 
} 
</span></pre><p><span class="koboSpan" id="kobo.192.1">Scala </span><code class="literal"><span class="koboSpan" id="kobo.193.1">for</span></code><span class="koboSpan" id="kobo.194.1"> expressions are a convenient way to traverse and transform collections. </span><span class="koboSpan" id="kobo.194.2">The following </span><code class="literal"><span class="koboSpan" id="kobo.195.1">for</span></code><span class="koboSpan" id="kobo.196.1"> loop prints the numbers in the range from </span><code class="literal"><span class="koboSpan" id="kobo.197.1">0 until 10</span></code><span class="koboSpan" id="kobo.198.1">; where </span><code class="literal"><span class="koboSpan" id="kobo.199.1">10</span></code><span class="koboSpan" id="kobo.200.1"> is not included in the range:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.201.1">for (i &lt;- 0 until 10) println(i) 
</span></pre><p><span class="koboSpan" id="kobo.202.1">In the preceding code, the range is created with the expression </span><code class="literal"><span class="koboSpan" id="kobo.203.1">0 until 10</span></code><span class="koboSpan" id="kobo.204.1">; this is equivalent to the expression </span><code class="literal"><span class="koboSpan" id="kobo.205.1">0.until(10)</span></code><span class="koboSpan" id="kobo.206.1">, which calls the method </span><code class="literal"><span class="koboSpan" id="kobo.207.1">until</span></code><span class="koboSpan" id="kobo.208.1"> on the value </span><code class="literal"><span class="koboSpan" id="kobo.209.1">0</span></code><span class="koboSpan" id="kobo.210.1">. </span><span class="koboSpan" id="kobo.210.2">In Scala, the dot notation can sometimes be dropped when invoking methods on objects.</span></p><p><span class="koboSpan" id="kobo.211.1">Every </span><code class="literal"><span class="koboSpan" id="kobo.212.1">for</span></code><span class="koboSpan" id="kobo.213.1"> loop is equivalent to a </span><code class="literal"><span class="koboSpan" id="kobo.214.1">foreach</span></code><span class="koboSpan" id="kobo.215.1"> call. </span><span class="koboSpan" id="kobo.215.2">The preceding </span><code class="literal"><span class="koboSpan" id="kobo.216.1">for</span></code><span class="koboSpan" id="kobo.217.1"> loop is translated by the Scala compiler to the following expression:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.218.1">(0 until 10).foreach(i =&gt; println(i)) 
</span></pre><p><span class="koboSpan" id="kobo.219.1"> 
 For-comprehensions are used to transform data. </span><span class="koboSpan" id="kobo.219.2">The following for-comprehension transforms all the numbers from </span><code class="literal"><span class="koboSpan" id="kobo.220.1">0 until 10</span></code><span class="koboSpan" id="kobo.221.1"> by multiplying them by </span><code class="literal"><span class="koboSpan" id="kobo.222.1">-1</span></code><span class="koboSpan" id="kobo.223.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.224.1">val negatives = for (i &lt;- 0 until 10) yield -i 
</span></pre><p><span class="koboSpan" id="kobo.225.1">The </span><code class="literal"><span class="koboSpan" id="kobo.226.1">negatives</span></code><span class="koboSpan" id="kobo.227.1"> value contains negative numbers from </span><code class="literal"><span class="koboSpan" id="kobo.228.1">0</span></code><span class="koboSpan" id="kobo.229.1"> until </span><code class="literal"><span class="koboSpan" id="kobo.230.1">-10</span></code><span class="koboSpan" id="kobo.231.1">. </span><span class="koboSpan" id="kobo.231.2">This for-comprehension is equivalent to the following </span><code class="literal"><span class="koboSpan" id="kobo.232.1">map</span></code><span class="koboSpan" id="kobo.233.1"> call:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.234.1">val negatives = (0 until 10).map(i =&gt; -1 * i) 
</span></pre><p><span class="koboSpan" id="kobo.235.1">It is also possible to transform data from multiple inputs. </span><span class="koboSpan" id="kobo.235.2">The following for-comprehension creates all pairs of integers between </span><code class="literal"><span class="koboSpan" id="kobo.236.1">0</span></code><span class="koboSpan" id="kobo.237.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.238.1">4</span></code><span class="koboSpan" id="kobo.239.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.240.1">val pairs = for (x &lt;- 0 until 4; y &lt;- 0 until 4) yield (x, y) 
</span></pre><p><span class="koboSpan" id="kobo.241.1">The preceding for-comprehension is equivalent to the following expression:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.242.1">val pairs = (0 until 4).flatMap(x =&gt; (0 until 4).map(y =&gt; (x, y))) 
</span></pre><p><span class="koboSpan" id="kobo.243.1">We can nest an arbitrary number of generator expressions in a for-comprehension. </span><span class="koboSpan" id="kobo.243.2">The Scala compiler will transform them into a sequence of nested </span><code class="literal"><span class="koboSpan" id="kobo.244.1">flatMap</span></code><span class="koboSpan" id="kobo.245.1"> calls, followed by a </span><code class="literal"><span class="koboSpan" id="kobo.246.1">map</span></code><span class="koboSpan" id="kobo.247.1"> call at the deepest level.</span></p><p><span class="koboSpan" id="kobo.248.1">Commonly used Scala collections include sequences, denoted by the </span><code class="literal"><span class="koboSpan" id="kobo.249.1">Seq[T]</span></code><span class="koboSpan" id="kobo.250.1"> type; maps, denoted by the </span><code class="literal"><span class="koboSpan" id="kobo.251.1">Map[K, V]</span></code><span class="koboSpan" id="kobo.252.1"> type; and sets, denoted by the </span><code class="literal"><span class="koboSpan" id="kobo.253.1">Set[T]</span></code><span class="koboSpan" id="kobo.254.1"> type. </span><span class="koboSpan" id="kobo.254.2">In the following code, we create a sequence of strings:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.255.1">val messages: Seq[String] = Seq("Hello", "World.", "!") 
</span></pre><p><span class="koboSpan" id="kobo.256.1">Throughout this book, we rely heavily on the </span><span class="strong"><strong><span class="koboSpan" id="kobo.257.1">string interpolation</span></strong></span><span class="koboSpan" id="kobo.258.1"> feature. </span><span class="koboSpan" id="kobo.258.2">Normally, Scala strings are formed with double quotation marks. </span><span class="koboSpan" id="kobo.258.3">Interpolated strings are preceded with an </span><code class="literal"><span class="koboSpan" id="kobo.259.1">s</span></code><span class="koboSpan" id="kobo.260.1"> character, and can contain </span><code class="literal"><span class="koboSpan" id="kobo.261.1">$</span></code><span class="koboSpan" id="kobo.262.1"> symbols with arbitrary identifiers resolved from the enclosing scope, as shown in the following example:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.263.1">val magic = 7 
val myMagicNumber = s"My magic number is $magic" 
</span></pre><p><span class="strong"><strong><span class="koboSpan" id="kobo.264.1">Pattern matching</span></strong></span><span class="koboSpan" id="kobo.265.1"> is another important Scala feature. </span><span class="koboSpan" id="kobo.265.2">For readers with Java, C#, or C background, a good way to describe it is to say that Scala's </span><code class="literal"><span class="koboSpan" id="kobo.266.1">match</span></code><span class="koboSpan" id="kobo.267.1"> statement is like the </span><code class="literal"><span class="koboSpan" id="kobo.268.1">switch</span></code><span class="koboSpan" id="kobo.269.1"> statement on steroids. </span><span class="koboSpan" id="kobo.269.2">The </span><code class="literal"><span class="koboSpan" id="kobo.270.1">match</span></code><span class="koboSpan" id="kobo.271.1"> statement can decompose arbitrary datatypes and allows you to express different cases in the program concisely.</span></p><p><span class="koboSpan" id="kobo.272.1">In the following example, we declare a </span><code class="literal"><span class="koboSpan" id="kobo.273.1">Map</span></code><span class="koboSpan" id="kobo.274.1"> collection, named </span><code class="literal"><span class="koboSpan" id="kobo.275.1">successors</span></code><span class="koboSpan" id="kobo.276.1">, used to map integers to their immediate successors. </span><span class="koboSpan" id="kobo.276.2">We then call the </span><code class="literal"><span class="koboSpan" id="kobo.277.1">get</span></code><span class="koboSpan" id="kobo.278.1"> method to obtain the successor of the number 5. </span><span class="koboSpan" id="kobo.278.2">The </span><code class="literal"><span class="koboSpan" id="kobo.279.1">get</span></code><span class="koboSpan" id="kobo.280.1"> method returns an object with the </span><code class="literal"><span class="koboSpan" id="kobo.281.1">Option[Int]</span></code><span class="koboSpan" id="kobo.282.1"> type, which may be implemented either with the </span><code class="literal"><span class="koboSpan" id="kobo.283.1">Some</span></code><span class="koboSpan" id="kobo.284.1"> class, indicating that the number 5 exists in the map, or the </span><code class="literal"><span class="koboSpan" id="kobo.285.1">None</span></code><span class="koboSpan" id="kobo.286.1"> class, indicating that the number 5 is not a key in the map. </span><span class="koboSpan" id="kobo.286.2">Pattern matching on the </span><code class="literal"><span class="koboSpan" id="kobo.287.1">Option</span></code><span class="koboSpan" id="kobo.288.1"> object allows proceeding casewise, as shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.289.1">val successors = Map(1 -&gt; 2, 2 -&gt; 3, 3 -&gt; 4) 
successors.get(5) match { 
  case Some(n) =&gt; println(s"Successor is: $n") 
  case None    =&gt; println("Could not find successor.") 
} 
</span></pre><p><span class="koboSpan" id="kobo.290.1">In Scala, most operators can be overloaded. </span><span class="strong"><strong><span class="koboSpan" id="kobo.291.1">Operator overloading</span></strong></span><span class="koboSpan" id="kobo.292.1"> is no different from declaring a method. </span><span class="koboSpan" id="kobo.292.2">In the following code snippet, we declare a </span><code class="literal"><span class="koboSpan" id="kobo.293.1">Position</span></code><span class="koboSpan" id="kobo.294.1"> class with a </span><code class="literal"><span class="koboSpan" id="kobo.295.1">+</span></code><span class="koboSpan" id="kobo.296.1"> operator:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.297.1">class Position(val x: Int, val y: Int) { 
  def +(that: Position) = new Position(x + that.x, y + that.y) 
} 
</span></pre><p><span class="koboSpan" id="kobo.298.1">Finally, Scala allows defining </span><span class="strong"><strong><span class="koboSpan" id="kobo.299.1">package objects</span></strong></span><span class="koboSpan" id="kobo.300.1"> to store top-level method and value definitions for a given package. </span><span class="koboSpan" id="kobo.300.2">In the following code snippet, we declare the package object for the </span><code class="literal"><span class="koboSpan" id="kobo.301.1">org.learningconcurrency</span></code><span class="koboSpan" id="kobo.302.1"> package. </span><span class="koboSpan" id="kobo.302.2">We implement the top level </span><code class="literal"><span class="koboSpan" id="kobo.303.1">log</span></code><span class="koboSpan" id="kobo.304.1"> method, which outputs a given string and the current thread name:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.305.1">package org 
package object learningconcurrency { 
  def log(msg: String): Unit = 
    println(s"${Thread.currentThread.getName}: $msg") 
} 
</span></pre><p><span class="koboSpan" id="kobo.306.1">We will use the </span><code class="literal"><span class="koboSpan" id="kobo.307.1">log</span></code><span class="koboSpan" id="kobo.308.1"> method in the examples throughout this book to trace how concurrent programs are executed.</span></p><p><span class="koboSpan" id="kobo.309.1">This concludes our quick overview of important Scala features. </span><span class="koboSpan" id="kobo.309.2">If you would like to obtain a deeper knowledge about any of these language constructs, we suggest that you check out one of the introductory books on sequential programming in Scala.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Overview of new features in Scala 2.12"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/><span class="koboSpan" id="kobo.1.1">Overview of new features in Scala 2.12</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">At the time of writing, the next planned release of the language is Scala 2.12. </span><span class="koboSpan" id="kobo.2.2">From the user and API perspective, Scala 2.12 does not introduce new ground-breaking features. </span><span class="koboSpan" id="kobo.2.3">The goal of the 2.12 release is to improve code optimization and make Scala compliant with the Java 8 runtime. </span><span class="koboSpan" id="kobo.2.4">Since Scala's primary target is the Java runtime, making Scala compliant with Java 8 runtime will reduce the size of compiled programs and JAR files, better performance and faster compilation. </span><span class="koboSpan" id="kobo.2.5">From the user perspective, the major change is that you will have to install the JDK 8 framework instead of JDK 7.</span></p><p><span class="koboSpan" id="kobo.3.1">The particular changes in Scala 2.12 worth mentioning are the following:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.4.1">In previous versions, traits compiled to a single interface if all of their methods were abstract. </span><span class="koboSpan" id="kobo.4.2">If the trait had a concrete method implementation, the compiler generated two class files--one containing the JVM interface, and another class file containing the implementations of the concrete methods. </span><span class="koboSpan" id="kobo.4.3">In Scala 2.12, the compiler will generate a single interface file containing the Java 8 </span><span class="strong"><strong><span class="koboSpan" id="kobo.5.1">default methods</span></strong></span><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">The net effect is reduced code size.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.7.1">Previously, each Scala closure was compiled into a separate class. </span><span class="koboSpan" id="kobo.7.2">Starting with 2.12, Scala closures are compiled into Java 8-style lambdas. </span><span class="koboSpan" id="kobo.7.3">The consequence is reduced code size and potentially better optimizations by the Java 8 runtime.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.8.1">Scala compiles into Java bytecodes, which are then interpreted on the Java Virtual Machine. </span><span class="koboSpan" id="kobo.8.2">In Scala 2.12, the old compiler backend is replaced with a new implementation that generates bytecode more quickly with a positive impact on compilation speed.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.9.1">Scala 2.12 comes with a new optimizer, which is enabled with the </span><code class="literal"><span class="koboSpan" id="kobo.10.1">-opt</span></code><span class="koboSpan" id="kobo.11.1"> compiler flag. </span><span class="koboSpan" id="kobo.11.2">The new optimizer is more aggressive at inlining final methods, does better escape analysis for objects and functions that are created and used in a single method, and does dead code elimination. </span><span class="koboSpan" id="kobo.11.3">All this has a positive impact on the performance of Scala programs.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.12.1">Scala 2.12 allows using lambdas for Single Abstract Method (SAM) types. </span><span class="koboSpan" id="kobo.12.2">SAM types are classes or traits that have exactly one abstract method, which is normally implemented by extending the class. </span><span class="koboSpan" id="kobo.12.3">Assume that we have a method invocation with an argument whose expected type is a SAM type. </span><span class="koboSpan" id="kobo.12.4">If the user passes a lambda, that is, a function literal, instead of a SAM type instance, the 2.12 compiler will automatically convert the function object into an instance of the SAM type.</span></li></ul></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/><span class="koboSpan" id="kobo.1.1">Summary</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In this chapter, we studied what concurrent programming is and why Scala is a good language for concurrency. </span><span class="koboSpan" id="kobo.2.2">We gave a brief overview of what you will learn in this book, and how the book is organized. </span><span class="koboSpan" id="kobo.2.3">Finally, we stated some Scala preliminaries necessary for understanding the various concurrency topics in the subsequent chapters. </span><span class="koboSpan" id="kobo.2.4">If you would like to learn more about sequential Scala programming, we suggest that you read the book, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.3.1">Programming in Scala</span></em></span><span class="koboSpan" id="kobo.4.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.5.1">Martin Odersky, Lex Spoon, and Bill Venners</span></em></span><span class="koboSpan" id="kobo.6.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">Artima Inc</span></em></span><span class="koboSpan" id="kobo.8.1">.</span></p><p><span class="koboSpan" id="kobo.9.1">In the next chapter, we will start with the fundamentals of concurrent programming on the JVM. </span><span class="koboSpan" id="kobo.9.2">We will introduce the basic concepts in concurrent programming, present the low-level concurrency utilities available on the JVM, and learn about the Java Memory Model.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/><span class="koboSpan" id="kobo.1.1">Exercises</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">The following exercises are designed to test your knowledge of the Scala programming language. </span><span class="koboSpan" id="kobo.2.2">They cover the content presented in this chapter, along with some additional Scala features. </span><span class="koboSpan" id="kobo.2.3">The last two exercises contrast the difference between concurrent and distributed programming, as defined in this chapter. </span><span class="koboSpan" id="kobo.2.4">You should solve them by sketching out a pseudocode solution, rather than a complete Scala program.</span></p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="koboSpan" id="kobo.3.1">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.4.1">compose </span></code><span class="koboSpan" id="kobo.5.1"> method with the following signature:</span><pre class="programlisting"><span class="koboSpan" id="kobo.6.1">            def compose[A, B, C]
            (g: B =&gt; C, f: A =&gt; B): A =&gt; C = ??? 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.7.1">This method must return a function </span><code class="literal"><span class="koboSpan" id="kobo.8.1">h</span></code><span class="koboSpan" id="kobo.9.1">, which is the composition of the functions </span><code class="literal"><span class="koboSpan" id="kobo.10.1">f</span></code><span class="koboSpan" id="kobo.11.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.12.1">g</span></code></p></li><li class="listitem"><span class="koboSpan" id="kobo.13.1">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.14.1">fuse </span></code><span class="koboSpan" id="kobo.15.1">method with the following signature:</span><pre class="programlisting"><span class="koboSpan" id="kobo.16.1">            def fuse[A, B] 
            (a: Option[A], b: Option[B]): Option[(A, B)] = ??? 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.17.1">The resulting </span><code class="literal"><span class="koboSpan" id="kobo.18.1">Option</span></code><span class="koboSpan" id="kobo.19.1"> object should contain a tuple of values from the </span><code class="literal"><span class="koboSpan" id="kobo.20.1">Option</span></code><span class="koboSpan" id="kobo.21.1"> objects </span><code class="literal"><span class="koboSpan" id="kobo.22.1">a</span></code><span class="koboSpan" id="kobo.23.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.24.1">b</span></code><span class="koboSpan" id="kobo.25.1">, given that both </span><code class="literal"><span class="koboSpan" id="kobo.26.1">a</span></code><span class="koboSpan" id="kobo.27.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.28.1">b</span></code><span class="koboSpan" id="kobo.29.1"> are non-empty. </span><span class="koboSpan" id="kobo.29.2">Use for-comprehensions</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.30.1">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.31.1">check</span></code><span class="koboSpan" id="kobo.32.1"> method, which takes a set of values of type </span><code class="literal"><span class="koboSpan" id="kobo.33.1">T</span></code><span class="koboSpan" id="kobo.34.1"> and a function of type </span><code class="literal"><span class="koboSpan" id="kobo.35.1">T =&gt; Boolean</span></code><span class="koboSpan" id="kobo.36.1">:</span><pre class="programlisting"><span class="koboSpan" id="kobo.37.1">            def check[T](xs: Seq[T])(pred: T =&gt; Boolean): Boolean = ??? 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.38.1">The method must return </span><code class="literal"><span class="koboSpan" id="kobo.39.1">true</span></code><span class="koboSpan" id="kobo.40.1"> if and only if the </span><code class="literal"><span class="koboSpan" id="kobo.41.1">pred</span></code><span class="koboSpan" id="kobo.42.1"> function returns </span><code class="literal"><span class="koboSpan" id="kobo.43.1">true</span></code><span class="koboSpan" id="kobo.44.1"> for all the values in </span><code class="literal"><span class="koboSpan" id="kobo.45.1">xs</span></code><span class="koboSpan" id="kobo.46.1"> without throwing an exception. </span><span class="koboSpan" id="kobo.46.2">Use the </span><code class="literal"><span class="koboSpan" id="kobo.47.1">check</span></code><span class="koboSpan" id="kobo.48.1"> method as follows:</span></p><p>
</p><pre class="programlisting"><span class="koboSpan" id="kobo.49.1">            check(0 until 10)(40 / _ &gt; 0) 
</span></pre><p>
</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip4"/><span class="koboSpan" id="kobo.50.1">Tip</span></h3><p><span class="koboSpan" id="kobo.51.1">The </span><code class="literal"><span class="koboSpan" id="kobo.52.1">check</span></code><span class="koboSpan" id="kobo.53.1"> method has a curried definition: instead of just one parameter list, it has two of them. </span><span class="koboSpan" id="kobo.53.2">Curried definitions allow a nicer syntax when calling the function, but are otherwise semantically equivalent to single-parameter list definitions.</span></p></div></div></li><li class="listitem"><span class="koboSpan" id="kobo.54.1">Modify the </span><code class="literal"><span class="koboSpan" id="kobo.55.1">Pair</span></code><span class="koboSpan" id="kobo.56.1"> class from this chapter so that it can be used in a pattern match.</span><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip5"/><span class="koboSpan" id="kobo.57.1">Tip</span></h3><p><span class="koboSpan" id="kobo.58.1">If you haven't already done so, familiarize yourself with pattern matching in Scala.</span></p></div></div></li><li class="listitem"><span class="koboSpan" id="kobo.59.1">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.60.1">permutations</span></code><span class="koboSpan" id="kobo.61.1"> function, which, given a string, returns a sequence of strings that are lexicographic permutations of the input string:</span><pre class="programlisting"><span class="koboSpan" id="kobo.62.1">            def permutations(x: String): Seq[String]  
</span></pre></li><li class="listitem"><span class="koboSpan" id="kobo.63.1">Implement a </span><code class="literal"><span class="koboSpan" id="kobo.64.1">combinations</span></code><span class="koboSpan" id="kobo.65.1"> function that, given a sequence of elements, produces an iterator over all possible combinations of length </span><code class="literal"><span class="koboSpan" id="kobo.66.1">n</span></code><span class="koboSpan" id="kobo.67.1">. </span><span class="koboSpan" id="kobo.67.2">A combination is a way of selecting elements from the collection so that every element is selected once, and the order of elements does not matter. </span><span class="koboSpan" id="kobo.67.3">For example, given a collection </span><code class="literal"><span class="koboSpan" id="kobo.68.1">Seq(1, 4, 9, 16)</span></code><span class="koboSpan" id="kobo.69.1">, combinations of length 2 are </span><code class="literal"><span class="koboSpan" id="kobo.70.1">Seq(1, 4)</span></code><span class="koboSpan" id="kobo.71.1">, </span><code class="literal"><span class="koboSpan" id="kobo.72.1">Seq(1, 9)</span></code><span class="koboSpan" id="kobo.73.1">, </span><code class="literal"><span class="koboSpan" id="kobo.74.1">Seq(1, 16)</span></code><span class="koboSpan" id="kobo.75.1">, </span><code class="literal"><span class="koboSpan" id="kobo.76.1">Seq(4, 9)</span></code><span class="koboSpan" id="kobo.77.1">, </span><code class="literal"><span class="koboSpan" id="kobo.78.1">Seq(4, 16)</span></code><span class="koboSpan" id="kobo.79.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.80.1">Seq(9, 16)</span></code><span class="koboSpan" id="kobo.81.1">. </span><span class="koboSpan" id="kobo.81.2">The combinations function has the following signature:</span><pre class="programlisting"><span class="koboSpan" id="kobo.82.1">            def combinations(n: Int, xs: Seq[Int]): Iterator[Seq[Int]] 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.83.1">See the </span><code class="literal"><span class="koboSpan" id="kobo.84.1">Iterator</span></code><span class="koboSpan" id="kobo.85.1"> API in the standard library documentation</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.86.1">Implement a method that takes a regular expression, and returns a partial function from a string to lists of matches within that string:</span><pre class="programlisting"><span class="koboSpan" id="kobo.87.1">            def matcher   (regex: String): PartialFunction[String,   
            List[String]] 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.88.1">The partial function should not be defined if there are no matches within the argument strings. </span><span class="koboSpan" id="kobo.88.2">Otherwise, it should use the regular expression to output the list of matches.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.89.1">Consider that you and three of your colleagues working in an office divided into cubicles. </span><span class="koboSpan" id="kobo.89.2">You cannot see each other, and you are not allowed to verbally communicate, as that might disturb other workers. </span><span class="koboSpan" id="kobo.89.3">Instead, you can throw pieces of paper with short messages at each other. </span><span class="koboSpan" id="kobo.89.4">Since you are confined in a cubicle, neither of you can tell if the message has reached its destination. </span><span class="koboSpan" id="kobo.89.5">At any point, you or one of your colleagues may be called to the boss's office and kept there indefinitely. </span><span class="koboSpan" id="kobo.89.6">Design an algorithm in which you and your colleagues can decide when to meet at the local bar. </span><span class="koboSpan" id="kobo.89.7">With the exception of the one among you who was called to the boss's office, all of you have to decide on the same time. </span><span class="koboSpan" id="kobo.89.8">What if some of the paper pieces can arbitrarily miss the target cubicle?</span></li><li class="listitem"><span class="koboSpan" id="kobo.90.1">Imagine that, in the previous exercise, you and your colleagues also have a whiteboard in the hall next to the office. </span><span class="koboSpan" id="kobo.90.2">Each one of you can occasionally pass through the hall and write something on the whiteboard, but there is no guarantee that either of you will be in the hall at the same time.</span></li></ol></div><p><span class="koboSpan" id="kobo.91.1">Solve the problem from the previous exercise, this time using the whiteboard.</span></p></div></div></div></body></html>