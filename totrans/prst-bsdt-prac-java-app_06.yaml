- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NoSQL in Java Demystified – One API to Rule Them All
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NoSQL databases have gained significant popularity recently, and this chapter
    explores why they deserve more attention. With the evolution of software and increased
    diverse requirements, NoSQL databases offer an easier route to success. Using
    the Jakarta standard, this persistence type is helpful in various areas, including
    more traditional sectors such as finance. NoSQL databases provide flexible data
    modeling, horizontal scaling, and better performance, among other advantages.
    As a result, they are suitable for managing large amounts of structured or unstructured
    data and have become a popular choice for modern applications. This chapter will
    guide us on how to use NoSQL databases with Java, helping developers exploit their
    features and capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding NoSQL database trade-offs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming NoSQL databases with **Jakarta** **NoSQL** (**JNoSQL**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following are required for this chapter
  prefs: []
  type: TYPE_NORMAL
- en: Java 17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any preferred IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-06](https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-06).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding NoSQL database trade-offs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NoSQL databases are popular, including several persistence solutions offered
    by the top database engines. It is essential to remember that NoSQL databases
    do not eliminate the need for relational databases.
  prefs: []
  type: TYPE_NORMAL
- en: SQL databases remain crucial to most enterprise solutions. They are where people
    more often start to learn to program, and there are numerous articles and books
    written on the topic.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the maturity of the products that use SQL is vast! Those products
    can help you with crucial tasks, such as backups, migrations, and query analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal is not to demotivate you from using NoSQL. However, once you are a
    senior engineer, remember the second law of software architecture mentioned in
    *Fundamentals of Software Architecture: An Engineering Approach* by Neal Ford:
    everything has a trade-off!'
  prefs: []
  type: TYPE_NORMAL
- en: Consider that, and let’s move on to the NoSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming NoSQL databases with JNoSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are lucky to have several solutions and success cases in the Java platform.
    Thus, the next step is to create a standard API as soon as this technology matures.
  prefs: []
  type: TYPE_NORMAL
- en: The JNoSQL specification aims to simplify the communication between Java and
    NoSQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of standardizing the behavior and interface of multiple NoSQL databases
    is code portability and ease of integration. We usually talk about switching the
    database, which is true. However, the most significant advantage is to make it
    easier for everybody to work on a project. When it is required, you can switch
    databases naturally.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: NoSQL databases – document type](img/Figure_6.01_B19375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: NoSQL databases – document type'
  prefs: []
  type: TYPE_NORMAL
- en: There are great benefits to using a standard API; furthermore, you can use particular
    behavior, such as **Cassandra Query Language** (**CQL**) for Cassandra and **ArangoDB
    Query Language** (**AQL**) for ArangoDB.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: NoSQL databases – document type with a single API](img/Figure_6.02_B19375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: NoSQL databases – document type with a single API'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the main principle of JNoSQL, to simplify and make your and your organization’s
    life easier when it comes to Java and NoSQL databases. On the spec side, you can
    explore your entities; for example, with JPA, you can use annotations to operate
    with several NoSQL database types, such as document, column, graph, and key-value.
    See how the same annotations work in several document databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: JNoSQL abstraction for multiple database integrations](img/Figure_6.03_B19375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: JNoSQL abstraction for multiple database integrations'
  prefs: []
  type: TYPE_NORMAL
- en: 'The spec supports the most popular NoSQL types: key-value, document, wide-column
    or other column types, and graph.'
  prefs: []
  type: TYPE_NORMAL
- en: Key-value databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting with the simplest one: key-value. This NoSQL solution flavor has a
    structure that looks like a map. Thus, you can generally find information from
    the key, and the value is a blob. Each vendor has a different way of serializing
    and storing the value, such as text, JSON, or binary JSON.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the library system, we can use this database to save the user settings
    information; thus, we’ll create a `User` entity to preserve the language and categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide an example of this model, we’ll follow a simple Java SE application
    with JNoSQL. We will use the most popular key-value database solution: Redis.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining the configuration of Redis in production would require its own book;
    we’ll install this sample locally, but please, if working in production, check
    the Redis documentation for more details. For now, once you have Docker configured,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The server is running; the next step is to add dependencies to our project.
    This sample uses the Maven project, so we’ll add the mapping dependency and the
    Redis driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the dependencies ready, the next step is to create the `User` entities
    with the annotations to map to a key-value database. It requires an annotation
    to define as a JNoSQL entity and the key, where you’ll set the `Entity` and `Id`
    annotations, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Entity` and `Id` annotations are used when defining the `User` entity class
    and the `userName` field, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s execute it. `KeyValueTemplate` is the instance we use to operate a key-value
    database; it is the lowest level of mapping communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The queries on this database type have limitations, but it is powerful. The
    **Time To Live** (**TTL**) is a feature used to define the expiration time of
    the information in a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: But wait, where is the configuration? The JNoSQL implementation uses Eclipse
    MicroProfile configuration to preserve good software practices, such as twelve-factor
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this sample, we’ll put the properties in the `property` file, but we can
    overwrite the system environment or include more configurations, such as a username
    and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The key-value is a strong ally when you want to save entities that should be
    fast to read/write. These solutions usually work in memory with a snapshot to
    avoid data loss if the server goes down.
  prefs: []
  type: TYPE_NORMAL
- en: Like any technology solution, there are trade-offs to consider. For example,
    while it is possible to retrieve information using an ID and return the value
    as a unique blob, this approach may not be ideal in all situations. Therefore,
    let’s explore the next type of solution to address this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Column databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following database type is the wide-column type, which follows the same
    principles as key-value, but instead of a unique blob, you can split the information
    into small columns.
  prefs: []
  type: TYPE_NORMAL
- en: This NoSQL database is also known as a two-dimensional key-value store. The
    most popular implementation is Apache Cassandra; this section will cover an integration
    between Java and Apache Cassandra.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, we won’t cover tips for running in production; for now, we’ll
    run a single instance for test purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When running a Cassandra instance with Docker, please don’t run it this way
    in production. This configuration is best for your test environment. For production
    use, go to the Apache Cassandra documentation on the Apache website.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll follow the same idea of configuration, so we’ll use Java and Maven projects.
    The first step on the Java side is to add dependencies to the Maven project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This dependency seems different because it is a Cassandra extension; it is
    the column API plus behavior specific to Cassandra, such as CQL. If you wish,
    you can use it as we did with Redis, but you cannot use Cassandra-specific behavior
    easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This NoSQL database works differently from SQL. Indeed, denormalization is your
    best friend.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, visualize the model. Then, create it. We want to track and view the
    rental records of a user with a particular ID who rents books:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That’s it for the model; from the ID, we can return the track record of a book
    rental. We’re replicating information such as the book’s title and the user’s
    name to avoid any joins or more processes, but once a field has been updated,
    we need to run an event in the background to update it.
  prefs: []
  type: TYPE_NORMAL
- en: The `User` and `Book` entities are user-defined types, where we can add multiple
    values to a single column.
  prefs: []
  type: TYPE_NORMAL
- en: Despite JPA, JNoSQL must define each field to be stored using either a `Column`
    or `Id` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s execute the code, as essentially we can use the same principles and behavior
    that we did with key-value. We can also select the fields to return in a query
    instead of always returning everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Cassandra is not schemaless, although you need to create the schema before
    using it. Running the query locally is OK, but don’t use it in production. This
    is because it takes time to start and run it in production. The following code
    shows a configuration for using Cassandra:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Compared to key-value, wide-column has more flexibility in the model. But we
    still have the issue of searching fields that are not an ID; how can we solve
    this? Let’s move on to the following database type to answer this question.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Cassandra has a secondary index for allowing querying outside the key. Pay attention
    because there are several implications for using it.
  prefs: []
  type: TYPE_NORMAL
- en: Document databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our third NoSQL type can search for fields aside from the ID; good news! The
    document NoSQL type has an XML or JSON structure. Searching for the ID is still
    the more efficient way, but being able to search for information through other
    fields gives the model more flexibility and makes it easier to explore the information
    in the database as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this sample, we’ll use MongoDB for the implementation. We’ll run a single
    node locally. Please, pay attention when running this in production; but for now,
    we’ll run it from a Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As the Maven dependency, we’ll add the MongoDB extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this sample, we’ll show the book items inside the store. The model is similar
    to wide-column in that it is query-driven, but we have more flexibility to search
    this time. The model follows the DDD principle, with `Book` as the entity and
    `Author` as the value object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using an immutable value object, it is an excellent candidate to
    use to explore the newest feature from Java: records.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The model is ready to explore; thus, we’ll run it on Java SE and explore `DocumentTemplate`,
    which follows the same principle as the previous database flavors – being a bridge
    between Java and the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The power of documents is similar to relational databases, but we don’t have
    the same powerful transactions as SQL and JOINs. Even with this limitation, we
    can order elements from any field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties for running the sample will follow the same core idea to take
    advantage of the twelve-factor app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The flexibility the document NoSQL type has in querying is terrific! But what
    about the relationship between entities? This kind of query is required at some
    point, so how can we solve it? Let’s look at the last NoSQL type and find out.
  prefs: []
  type: TYPE_NORMAL
- en: Graph databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re looking for a relationship, you have come to the right place! Let’s
    talk about graph databases. A graph database is a powerful engine with a graph
    structure that saves information based on vertices and edges, where an edge is
    an object to hold the relationship information.
  prefs: []
  type: TYPE_NORMAL
- en: Using an edge, you can define a relationship’s direction and properties; it
    is even more potent than a relational database.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a simple recommendation engine with a person who can read/write
    and meet people.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: The relationships between people and books](img/Figure_6.04_B19375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: The relationships between people and books'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is ensure that we have at least a single instance running;
    remember, this is not the proper way to run in production:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll have two entities: `Book` and `Person`. A person can write N books, read
    N books, and meet N. A tree hierarchy and a meta-relationship indicate a graph
    database when we have multiple N-to-N relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The graph also has a `GraphTemplate` instance where you can operate with the
    graph database.
  prefs: []
  type: TYPE_NORMAL
- en: This sample will use a `LibraryGraph` to operate all the operations on this
    system. Be ready to refactor it as it gets bigger, mainly because it breaks the
    single responsibility **SOLID** principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main point to remember is the developer’s core principle to make the code
    maintainable and readable; unfortunately, we don’t yet have a full set of established
    best practices for NoSQL as we do with SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The last step is to run it. There are tiny differences between the query and
    operation when inserting entities and relationships. We can implement the following
    graph using Neo4j.
  prefs: []
  type: TYPE_NORMAL
- en: 'JNoSQL uses Apache TinkerPop as a communication layer where we can search for
    queries by using Gremlin. This opens up a world of possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The graph database has extensive capabilities to leverage relationships, but
    it comes at the cost of performance. It is tough to scale the database, and it
    is slower than a key-value database.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve finished our journey through NoSQL types, where we looked at the least
    flexible to the least scalable types. Paying attention to modeling is crucial
    because it is different from SQL databases and is a common pitfall for beginners
    in NoSQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced you to the JNoSQL Java API standard, which streamlines the integration
    of Java applications with NoSQL databases. We will discuss Jakarta and the data
    persistence layer in the chapter on polyglot persistence. In the next chapter,
    we will cover relational databases using jOOQ.
  prefs: []
  type: TYPE_NORMAL
