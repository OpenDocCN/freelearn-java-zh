- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: NoSQL in Java Demystified – One API to Rule Them All
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中的NoSQL揭秘 – 一个API统治一切
- en: NoSQL databases have gained significant popularity recently, and this chapter
    explores why they deserve more attention. With the evolution of software and increased
    diverse requirements, NoSQL databases offer an easier route to success. Using
    the Jakarta standard, this persistence type is helpful in various areas, including
    more traditional sectors such as finance. NoSQL databases provide flexible data
    modeling, horizontal scaling, and better performance, among other advantages.
    As a result, they are suitable for managing large amounts of structured or unstructured
    data and have become a popular choice for modern applications. This chapter will
    guide us on how to use NoSQL databases with Java, helping developers exploit their
    features and capabilities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 最近NoSQL数据库获得了显著的关注度，本章将探讨它们为什么值得更多的关注。随着软件的发展和多样化的需求增加，NoSQL数据库提供了一条更容易成功的途径。使用Jakarta标准，这种持久化类型在各个领域都有帮助，包括更传统的领域如金融。NoSQL数据库提供灵活的数据建模、水平扩展和更好的性能，以及其他优势。因此，它们适合管理大量结构化或非结构化数据，并已成为现代应用的热门选择。本章将指导我们如何使用Java操作NoSQL数据库，帮助开发者利用其功能和能力。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Understanding NoSQL database trade-offs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解NoSQL数据库的权衡
- en: Consuming NoSQL databases with **Jakarta** **NoSQL** (**JNoSQL**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Jakarta** **NoSQL** (**JNoSQL**)消费NoSQL数据库
- en: Graph databases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形数据库
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The following are required for this chapter
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为本章所需内容：
- en: Java 17
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 17
- en: Git
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Maven
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven
- en: Docker
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Any preferred IDE
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何首选的IDE
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-06](https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-06).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-06](https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-06)找到。
- en: Understanding NoSQL database trade-offs
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解NoSQL数据库的权衡
- en: NoSQL databases are popular, including several persistence solutions offered
    by the top database engines. It is essential to remember that NoSQL databases
    do not eliminate the need for relational databases.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库很受欢迎，包括顶级数据库引擎提供的几个持久化解决方案。我们必须记住，NoSQL数据库并没有消除对关系数据库的需求。
- en: SQL databases remain crucial to most enterprise solutions. They are where people
    more often start to learn to program, and there are numerous articles and books
    written on the topic.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: SQL数据库对于大多数企业解决方案来说仍然至关重要。人们通常从这里开始学习编程，关于这个主题有大量的文章和书籍。
- en: Furthermore, the maturity of the products that use SQL is vast! Those products
    can help you with crucial tasks, such as backups, migrations, and query analysis.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用SQL的产品成熟度非常广泛！这些产品可以帮助你完成关键任务，例如备份、迁移和查询分析。
- en: 'The goal is not to demotivate you from using NoSQL. However, once you are a
    senior engineer, remember the second law of software architecture mentioned in
    *Fundamentals of Software Architecture: An Engineering Approach* by Neal Ford:
    everything has a trade-off!'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 目标不是让你对使用NoSQL失去动力。然而，一旦你成为高级工程师，请记住Neal Ford在《软件架构基础：工程方法》中提到的软件架构的第二定律：一切皆有权衡！
- en: Consider that, and let’s move on to the NoSQL database.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这一点，让我们继续讨论NoSQL数据库。
- en: Consuming NoSQL databases with JNoSQL
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JNoSQL消费NoSQL数据库
- en: We are lucky to have several solutions and success cases in the Java platform.
    Thus, the next step is to create a standard API as soon as this technology matures.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很幸运在Java平台上拥有几个解决方案和成功案例。因此，下一步是尽快在技术成熟后创建一个标准API。
- en: The JNoSQL specification aims to simplify the communication between Java and
    NoSQL databases.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: JNoSQL规范旨在简化Java和NoSQL数据库之间的通信。
- en: The benefit of standardizing the behavior and interface of multiple NoSQL databases
    is code portability and ease of integration. We usually talk about switching the
    database, which is true. However, the most significant advantage is to make it
    easier for everybody to work on a project. When it is required, you can switch
    databases naturally.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化多个NoSQL数据库的行为和接口的好处是代码的可移植性和易于集成。我们通常谈论切换数据库，这是真的。然而，最大的优势是使每个人都能更容易地参与项目。当需要时，可以自然地切换数据库。
- en: '![Figure 6.1: NoSQL databases – document type](img/Figure_6.01_B19375.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：NoSQL数据库 – 文档类型](img/Figure_6.01_B19375.jpg)'
- en: 'Figure 6.1: NoSQL databases – document type'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：NoSQL数据库 – 文档类型
- en: There are great benefits to using a standard API; furthermore, you can use particular
    behavior, such as **Cassandra Query Language** (**CQL**) for Cassandra and **ArangoDB
    Query Language** (**AQL**) for ArangoDB.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准API的好处很大；此外，您可以使用特定的行为，例如Cassandra的**CQL**（Cassandra查询语言）和ArangoDB的**AQL**（ArangoDB查询语言）。
- en: '![Figure 6.2: NoSQL databases – document type with a single API](img/Figure_6.02_B19375.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2：NoSQL数据库 – 单API的文档类型](img/Figure_6.02_B19375.jpg)'
- en: 'Figure 6.2: NoSQL databases – document type with a single API'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：NoSQL数据库 – 单API的文档类型
- en: 'This is the main principle of JNoSQL, to simplify and make your and your organization’s
    life easier when it comes to Java and NoSQL databases. On the spec side, you can
    explore your entities; for example, with JPA, you can use annotations to operate
    with several NoSQL database types, such as document, column, graph, and key-value.
    See how the same annotations work in several document databases:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是JNoSQL的主要原则，即在Java和NoSQL数据库方面简化并使您和您组织的日常生活更加轻松。在规范方面，您可以探索您的实体；例如，使用JPA，您可以使用注解来操作多种NoSQL数据库类型，如文档、列、图和键值。看看相同的注解如何在多个文档数据库中工作：
- en: '![Figure 6.3: JNoSQL abstraction for multiple database integrations](img/Figure_6.03_B19375.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3：JNoSQL的多数据库集成抽象](img/Figure_6.03_B19375.jpg)'
- en: 'Figure 6.3: JNoSQL abstraction for multiple database integrations'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：JNoSQL的多数据库集成抽象
- en: 'The spec supports the most popular NoSQL types: key-value, document, wide-column
    or other column types, and graph.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 该规范支持最流行的NoSQL类型：键值、文档、宽列或其他列类型，以及图。
- en: Key-value databases
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键值数据库
- en: 'Starting with the simplest one: key-value. This NoSQL solution flavor has a
    structure that looks like a map. Thus, you can generally find information from
    the key, and the value is a blob. Each vendor has a different way of serializing
    and storing the value, such as text, JSON, or binary JSON.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从最简单的一个开始：键值。这种NoSQL解决方案的味道有一个类似于映射的结构。因此，您通常可以从键中找到信息，而值是一个blob。每个供应商都有不同的序列化和存储值的方式，例如文本、JSON或二进制JSON。
- en: Using the library system, we can use this database to save the user settings
    information; thus, we’ll create a `User` entity to preserve the language and categories.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图书馆系统，我们可以使用这个数据库来保存用户设置信息；因此，我们将创建一个`User`实体来保存语言和分类。
- en: 'To provide an example of this model, we’ll follow a simple Java SE application
    with JNoSQL. We will use the most popular key-value database solution: Redis.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个此模型的示例，我们将遵循一个简单的Java SE应用程序与JNoSQL。我们将使用最流行的键值数据库解决方案：Redis。
- en: 'Defining the configuration of Redis in production would require its own book;
    we’ll install this sample locally, but please, if working in production, check
    the Redis documentation for more details. For now, once you have Docker configured,
    run the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 定义生产中的Redis配置需要一本书；我们将本地安装此示例，但请记住，在生产环境中工作，请查阅Redis文档以获取更多详细信息。现在，一旦您已配置Docker，请运行以下命令：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The server is running; the next step is to add dependencies to our project.
    This sample uses the Maven project, so we’ll add the mapping dependency and the
    Redis driver:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器正在运行；下一步是向我们的项目中添加依赖项。此示例使用Maven项目，因此我们将添加映射依赖项和Redis驱动程序：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the dependencies ready, the next step is to create the `User` entities
    with the annotations to map to a key-value database. It requires an annotation
    to define as a JNoSQL entity and the key, where you’ll set the `Entity` and `Id`
    annotations, respectively:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好依赖项后，下一步是使用注解创建`User`实体，以映射到键值数据库。它需要一个注解来定义为一个JNoSQL实体和键，您将在其中设置`Entity`和`Id`注解，分别：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Entity` and `Id` annotations are used when defining the `User` entity class
    and the `userName` field, respectively.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义`User`实体类和`userName`字段时，分别使用`Entity`和`Id`注解。
- en: 'Let’s execute it. `KeyValueTemplate` is the instance we use to operate a key-value
    database; it is the lowest level of mapping communication:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行它。`KeyValueTemplate`是我们用于操作键值数据库的实例；这是映射通信的最低级别：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The queries on this database type have limitations, but it is powerful. The
    **Time To Live** (**TTL**) is a feature used to define the expiration time of
    the information in a database:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据库类型的查询有限制，但功能强大。**生存时间**（**TTL**）是用于定义数据库中信息过期时间的功能：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: But wait, where is the configuration? The JNoSQL implementation uses Eclipse
    MicroProfile configuration to preserve good software practices, such as twelve-factor
    app.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，配置在哪里？JNoSQL实现使用Eclipse MicroProfile配置来保留良好的软件实践，例如十二因素应用。
- en: 'In this sample, we’ll put the properties in the `property` file, but we can
    overwrite the system environment or include more configurations, such as a username
    and password:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将属性放在`property`文件中，但我们可以覆盖系统环境或包含更多配置，例如用户名和密码：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The key-value is a strong ally when you want to save entities that should be
    fast to read/write. These solutions usually work in memory with a snapshot to
    avoid data loss if the server goes down.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想快速读写实体时，键值是一个强大的盟友。这些解决方案通常在内存中工作，并使用快照来避免服务器宕机时的数据丢失。
- en: Like any technology solution, there are trade-offs to consider. For example,
    while it is possible to retrieve information using an ID and return the value
    as a unique blob, this approach may not be ideal in all situations. Therefore,
    let’s explore the next type of solution to address this issue.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何技术解决方案一样，需要考虑权衡。例如，虽然可以使用ID检索信息并将值作为唯一的blob返回，但这种方法在所有情况下可能并不理想。因此，让我们探索下一类解决方案来解决这个问题。
- en: Column databases
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列数据库
- en: The following database type is the wide-column type, which follows the same
    principles as key-value, but instead of a unique blob, you can split the information
    into small columns.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下数据库类型是宽列类型，它遵循与键值相同的原理，但与唯一的blob不同，你可以将信息拆分为小的列。
- en: This NoSQL database is also known as a two-dimensional key-value store. The
    most popular implementation is Apache Cassandra; this section will cover an integration
    between Java and Apache Cassandra.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个NoSQL数据库也被称为二维键值存储。最流行的实现是Apache Cassandra；本节将介绍Java和Apache Cassandra之间的集成。
- en: 'As mentioned, we won’t cover tips for running in production; for now, we’ll
    run a single instance for test purposes:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们不会涵盖在生产环境中运行的建议；目前，我们将运行单个实例以进行测试目的：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: When running a Cassandra instance with Docker, please don’t run it this way
    in production. This configuration is best for your test environment. For production
    use, go to the Apache Cassandra documentation on the Apache website.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Docker运行Cassandra实例时，请不要在生产环境中以这种方式运行。此配置最适合您的测试环境。对于生产使用，请访问Apache网站上的Apache
    Cassandra文档。
- en: 'We’ll follow the same idea of configuration, so we’ll use Java and Maven projects.
    The first step on the Java side is to add dependencies to the Maven project:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循相同的配置理念，因此我们将使用Java和Maven项目。在Java方面，第一步是为Maven项目添加依赖项：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This dependency seems different because it is a Cassandra extension; it is
    the column API plus behavior specific to Cassandra, such as CQL. If you wish,
    you can use it as we did with Redis, but you cannot use Cassandra-specific behavior
    easily:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个依赖项看起来不同，因为它是一个Cassandra扩展；它是列API加上特定于Cassandra的行为，例如CQL。如果你愿意，你可以像我们使用Redis一样使用它，但不能轻松地使用Cassandra特定的行为：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This NoSQL database works differently from SQL. Indeed, denormalization is your
    best friend.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个NoSQL数据库的工作方式与SQL不同。实际上，反规范化是你的最佳朋友。
- en: 'First, visualize the model. Then, create it. We want to track and view the
    rental records of a user with a particular ID who rents books:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，可视化模型。然后，创建它。我们希望跟踪和查看具有特定ID的用户租借书籍的记录：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That’s it for the model; from the ID, we can return the track record of a book
    rental. We’re replicating information such as the book’s title and the user’s
    name to avoid any joins or more processes, but once a field has been updated,
    we need to run an event in the background to update it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 模型就到这里；从ID，我们可以返回书籍租借的记录。我们正在复制诸如书籍标题和用户姓名等信息，以避免任何连接或更多过程，但一旦字段被更新，我们需要在后台运行一个事件来更新它。
- en: The `User` and `Book` entities are user-defined types, where we can add multiple
    values to a single column.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`和`Book`实体是用户定义的类型，其中我们可以向单个列添加多个值。'
- en: Despite JPA, JNoSQL must define each field to be stored using either a `Column`
    or `Id` annotation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有JPA，JNoSQL必须使用`Column`或`Id`注解定义每个要存储的字段。
- en: 'Let’s execute the code, as essentially we can use the same principles and behavior
    that we did with key-value. We can also select the fields to return in a query
    instead of always returning everything:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行代码，因为我们本质上可以使用与键值相同的原理和行为。我们还可以在查询中选择要返回的字段，而不是总是返回所有内容：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Cassandra is not schemaless, although you need to create the schema before
    using it. Running the query locally is OK, but don’t use it in production. This
    is because it takes time to start and run it in production. The following code
    shows a configuration for using Cassandra:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra不是无模式的，尽管在使用它之前你需要创建模式。在本地运行查询是可以的，但在生产环境中不要使用它。这是因为它在生产环境中启动和运行需要时间。以下代码显示了使用Cassandra的配置：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Compared to key-value, wide-column has more flexibility in the model. But we
    still have the issue of searching fields that are not an ID; how can we solve
    this? Let’s move on to the following database type to answer this question.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与键值对相比，宽列模型在模型中具有更多的灵活性。但我们仍然有搜索非ID字段的问题；我们如何解决这个问题？让我们继续到下一个数据库类型来回答这个问题。
- en: Tip
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Cassandra has a secondary index for allowing querying outside the key. Pay attention
    because there are several implications for using it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra有一个二级索引，允许在键之外进行查询。请注意，使用它有几个影响。
- en: Document databases
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档数据库
- en: Our third NoSQL type can search for fields aside from the ID; good news! The
    document NoSQL type has an XML or JSON structure. Searching for the ID is still
    the more efficient way, but being able to search for information through other
    fields gives the model more flexibility and makes it easier to explore the information
    in the database as well.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第三种NoSQL类型可以搜索ID之外的字段；好消息！文档NoSQL类型具有XML或JSON结构。搜索ID仍然是更有效的方式，但能够通过其他字段搜索信息使模型更具灵活性，并使探索数据库中的信息更容易。
- en: 'For this sample, we’ll use MongoDB for the implementation. We’ll run a single
    node locally. Please, pay attention when running this in production; but for now,
    we’ll run it from a Docker image:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将使用MongoDB进行实现。我们将本地运行单个节点。请注意，在生产环境中运行时；但现在，我们将从Docker镜像中运行它：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As the Maven dependency, we’ll add the MongoDB extension:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Maven依赖项，我们将添加MongoDB扩展：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this sample, we’ll show the book items inside the store. The model is similar
    to wide-column in that it is query-driven, but we have more flexibility to search
    this time. The model follows the DDD principle, with `Book` as the entity and
    `Author` as the value object:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将展示商店内的图书项。该模型与宽列类似，因为它是由查询驱动的，但这次我们有更多的灵活性来搜索。该模型遵循DDD原则，其中`Book`作为实体，`Author`作为值对象：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you are using an immutable value object, it is an excellent candidate to
    use to explore the newest feature from Java: records.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用不可变值对象，它是一个使用Java的最新功能：记录的绝佳候选者。
- en: 'The model is ready to explore; thus, we’ll run it on Java SE and explore `DocumentTemplate`,
    which follows the same principle as the previous database flavors – being a bridge
    between Java and the database:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 模型已经准备好探索；因此，我们将它在Java SE上运行，并探索`DocumentTemplate`，它遵循与之前数据库版本相同的原理——作为Java和数据库之间的桥梁：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The power of documents is similar to relational databases, but we don’t have
    the same powerful transactions as SQL and JOINs. Even with this limitation, we
    can order elements from any field:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 文档的力量与关系数据库相似，但我们没有像SQL和JOIN那样的强大事务。即使有这种限制，我们也可以从任何字段对元素进行排序：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The properties for running the sample will follow the same core idea to take
    advantage of the twelve-factor app:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例的属性将遵循相同的核心思想，以利用十二因素应用：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The flexibility the document NoSQL type has in querying is terrific! But what
    about the relationship between entities? This kind of query is required at some
    point, so how can we solve it? Let’s look at the last NoSQL type and find out.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 文档NoSQL类型在查询中的灵活性非常好！但实体之间的关系呢？这种查询在某些时候是需要的，那么我们如何解决这个问题？让我们看看最后一种NoSQL类型并找出答案。
- en: Graph databases
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图数据库
- en: If you’re looking for a relationship, you have come to the right place! Let’s
    talk about graph databases. A graph database is a powerful engine with a graph
    structure that saves information based on vertices and edges, where an edge is
    an object to hold the relationship information.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找关系，你来到了正确的位置！让我们来谈谈图数据库。图数据库是一个具有图结构的强大引擎，它根据顶点和边保存信息，其中边是一个用于保存关系信息的对象。
- en: Using an edge, you can define a relationship’s direction and properties; it
    is even more potent than a relational database.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用边，你可以定义关系的方向和属性；它甚至比关系数据库更强大。
- en: Let’s create a simple recommendation engine with a person who can read/write
    and meet people.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的推荐引擎，其中包含一个可以读写并能遇见人的角色。
- en: '![Figure 6.4: The relationships between people and books](img/Figure_6.04_B19375.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4：人与书之间的关系](img/Figure_6.04_B19375.jpg)'
- en: 'Figure 6.4: The relationships between people and books'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：人与书之间的关系
- en: 'The first thing to do is ensure that we have at least a single instance running;
    remember, this is not the proper way to run in production:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要确保我们至少有一个实例正在运行；记住，这并不是在生产环境中运行的正确方式：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We’ll have two entities: `Book` and `Person`. A person can write N books, read
    N books, and meet N. A tree hierarchy and a meta-relationship indicate a graph
    database when we have multiple N-to-N relationships:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有两个实体：`Book`和`Person`。一个人可以写N本书，读N本书，遇到N个人。当我们有多个N-to-N关系时，树形层次结构和元关系表明这是一个图数据库：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The graph also has a `GraphTemplate` instance where you can operate with the
    graph database.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该图还有一个`GraphTemplate`实例，您可以使用它来操作图数据库。
- en: This sample will use a `LibraryGraph` to operate all the operations on this
    system. Be ready to refactor it as it gets bigger, mainly because it breaks the
    single responsibility **SOLID** principle.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将使用`LibraryGraph`来操作该系统上的所有操作。准备好随着它变大而重构它，主要是因为它打破了单一责任**SOLID**原则。
- en: 'The main point to remember is the developer’s core principle to make the code
    maintainable and readable; unfortunately, we don’t yet have a full set of established
    best practices for NoSQL as we do with SQL:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的主要点是开发者的核心原则，即使代码易于维护和阅读；不幸的是，我们还没有像SQL那样拥有一套完整的已建立的最佳实践来处理NoSQL：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The last step is to run it. There are tiny differences between the query and
    operation when inserting entities and relationships. We can implement the following
    graph using Neo4j.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是运行它。在插入实体和关系时，查询和操作之间存在微小的差异。我们可以使用Neo4j实现以下图。
- en: 'JNoSQL uses Apache TinkerPop as a communication layer where we can search for
    queries by using Gremlin. This opens up a world of possibilities:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: JNoSQL使用Apache TinkerPop作为通信层，我们可以通过Gremlin进行查询搜索。这打开了一个无限可能的世界：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The graph database has extensive capabilities to leverage relationships, but
    it comes at the cost of performance. It is tough to scale the database, and it
    is slower than a key-value database.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据库具有利用关系的广泛能力，但这也带来了性能上的代价。数据库扩展很困难，并且比键值数据库慢。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We’ve finished our journey through NoSQL types, where we looked at the least
    flexible to the least scalable types. Paying attention to modeling is crucial
    because it is different from SQL databases and is a common pitfall for beginners
    in NoSQL databases.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了对NoSQL类型的旅程，我们查看的是从最不灵活到最不可扩展的类型。注意建模至关重要，因为它与SQL数据库不同，并且是NoSQL数据库初学者的常见陷阱。
- en: We introduced you to the JNoSQL Java API standard, which streamlines the integration
    of Java applications with NoSQL databases. We will discuss Jakarta and the data
    persistence layer in the chapter on polyglot persistence. In the next chapter,
    we will cover relational databases using jOOQ.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向您介绍了JNoSQL Java API标准，它简化了Java应用程序与NoSQL数据库的集成。我们将在关于多语言持久性的章节中讨论Jakarta和数据持久层。在下一章中，我们将介绍使用jOOQ的关系数据库。
