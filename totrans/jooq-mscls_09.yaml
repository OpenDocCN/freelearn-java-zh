- en: '*Chapter 7*: Types, Converters, and Bindings'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data types, converters, and bindings represent major aspects of working with
    a database via a Java-based **Domain-Specific Language** (**DSL**) **Application
    Programming Interface** (**API**). Sooner or later, standard **Structured Query
    Language** (**SQL**)/**Java Database Connectivity** (**JDBC**) data types will
    not be enough, or the default mappings between Java types and JDBC types will
    raise some shortcomings in your specific scenarios. At that moment, you''ll be
    interested in creating new data types, working with custom data types, type conversion,
    and type-binding capabilities of your DSL API. Fortunately, the **jOOQ Object
    Oriented Querying** (**jOOQ**) DSL provides versatile and easy-to-use APIs dedicated
    to the following agenda that represents the subject of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Default data type conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom data types and type conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom data types and type binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data type rewrites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling embeddable types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter07](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Default data type conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the aspects of jOOQ that allows us to use it in a smooth manner is its
    *default data type conversion*. Most of the time, jOOQ hides from us the ceremony
    of converting between JDBC and Java types. For instance, have you wondered how
    the following explicit conversions work? Take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Both conversions are resolved via *default data type conversion* or *auto-conversions*.
    Behind the scenes, jOOQ relies on its own API that is capable of performing soft
    type-safe conversions for `Object` types, arrays, and collections.
  prefs: []
  type: TYPE_NORMAL
- en: You can check out this example in the *ConvertUtil* application.
  prefs: []
  type: TYPE_NORMAL
- en: Custom data types and type conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In jOOQ, the common interface for all dialect-specific data types is named `org.jooq.DataType<T>`,
    where `T` represents the Java type associated with an SQL data type. Each association
    of a `T` Java data type with an SQL data type (generic SQL types, called standard
    JDBC types) represented by `java.sql.Types` is present in jOOQ's `org.jooq.impl.SQLDataType`
    API. The jOOQ Code Generator automatically maps Java types to this `SQLDataType`
    API, which has an almost 1:1 matching to databases' data types for most dialects.
    Of course, we are not including here some of the vendor-specific data types, such
    as spatial data types, PostgreSQL's `INET`/`HSTORE`, nor other non-standard JDBC
    types (data types not explicitly supported by JDBC).
  prefs: []
  type: TYPE_NORMAL
- en: 'Roughly, any data type that is not associated in the jOOQ API with a standard
    JDBC type is considered and treated as a *custom data type*. However, as Lukas
    Eder mentions: "*There are some data types that I think *should* be standard JDBC
    types, but are not. They''re also listed in* `SQLDataType`*, including:* `JSON`*,*
    `JSONB`*,* `UUID`*,* `BigInteger` *(!), unsigned numbers, intervals. These don''t
    require custom data types.*"'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever your custom data type needs to be mapped onto a standard JDBC type—that
    is, an `org.jooq.impl.SQLDataType` type—you need to provide and explicitly specify
    an `org.jooq.Converter` implementation. This converter does the hard work of performing
    a conversion between the involved types.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: When we want to map a type onto a non-standard JDBC type (a type that is not
    in `org.jooq.impl.SQLDataType`), we need to focus on the `org.jooq.Binding` API,
    which is covered later. So, if this is your case, don't try to shoehorn your conversion
    logic onto a `Converter`. Just use a `Binding` (we'll see this later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay attention that attempting to insert values/data of a custom data type without
    passing through a converter may result in inserting `null` values in the database
    (as Lukas Eder shared: "*This null behavior is an old design flaw. A long time
    ago, I''ve not followed a fail-early strategy throwing exceptions*"), while trying
    to fetch data of custom data type without a converter may lead to `org.jooq.exception.DataTypeException`,
    *no converter found for types Foo and Buzz*.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing an org.jooq.Converter interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`org.jooq.Converter` is an interface that represents a conversion between two
    types that are generically denoted as `<T>` and `<U>`. By `<T>`, we represent
    the database type, and by `<U>`, we represent the `<T>` to `<U>` is accomplished
    in a method named `U from(T)`, and converting from `<U>` to `<T>` is accomplished
    in a method named `T to(U)`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you find it hard to remember which direction is "`from()`" and which direction
    is "`to()`", then think that the former can be read as "*FROM the database to
    the client*" and the latter as "*from the client TO the database*". Also, pay
    attention to not confuse `T` and `U` because you risk spending hours staring at
    compilation errors in generated code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, via `U from(T)`, we convert from a database type to a UDT (for
    example, this is useful in `SELECT` statements), and via `T to(U)`, we convert
    from a UDT to a database type (for example, this is useful in `INSERT`, `UPDATE`,
    and `DELETE` statements). Moreover, a `T to(U)` direction is used wherever bind
    variables are used, so also in `SELECT` when writing predicates—for instance,
    `T.CONVERTED.eq(u)`. The stub of `org.jooq.Converter` is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'jOOQ comes with an abstract implementation of this interface (`AbstractConverter`)
    and a few concrete extensions (converters) of this abstraction that you can explore
    here: [https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/impl/AbstractConverter.html](https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/impl/AbstractConverter.html).
    But as you''ll see next, we can write our own converters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If, for instance, you want to use Java 8''s `java.time.YearMonth` type in the
    application but store it as an SQL `INTEGER` type in the database, you write a
    converter like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this converter via `new YearMonthConverter()` or define a handy `static`
    type, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, using this converter for arrays can be done via the following `static`
    type, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have a converter, we can define a new data type. More precisely, we
    define our own `DataType` type programmatically by calling `asConvertedDataType(Converter)`
    or `asConvertedDataType(Binding)`. For example, here, we define a `YEARMONTH`
    data type that can be used as any other data type defined in `SQLDataType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here, `INTEGER` is the `org.jooq.impl.SQLDataType.INTEGER` data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CUSTOMER` table, we have a field named `FIRST_BUY_DATE` of type `INT`.
    When a customer makes their first purchase, we store the date (year-month) as
    an integer. For example, the date *2020-10* is stored as *24249* (we manually
    applied the `Integer to(YearMonth u)` method). Without a converter, we have to
    insert *24249* explicitly; otherwise, the code will not compile (for example,
    a type-safe `INSERT` statement will not compile) or we''ll get an invalid insert
    (for example, a non-type-safe `INSERT` statement may store `null`). Relying on
    our converter, we can write the following type-safe `INSERT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, fetching all the `FIRST_BUY_DATE` values of *Atelier One* without using
    the converter will result in an array or list of integers. To fetch an array/list
    of `YearMonth`, we can use the converter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code (*YearMonthConverter*, available for MySQL and PostgreSQL),
    you can see more examples, including the usage of the `YEARMONTH` data type for
    coercing and casting operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing a converter having its own class is useful when the converter is used
    sporadically across different places/classes. If you know that the converter is
    used only in a single class, then you can define it locally in that class via
    `Converter.of()/ofNullable()`, as follows (the difference between them consists
    of the fact that `Converter.ofNullable()` always returns `null` for `null` inputs):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, starting with jOOQ 3.15+, we can use a so-called *ad hoc converter*.
    This type of converter is very handy for attaching a converter to a certain column
    just for one query or a few local queries. For instance, having a converter (`INTEGER_YEARMONTH_CONVERTER`),
    we can use it for a single column, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, jOOQ provides—next to the ad hoc `convert()` function (allows
    you to turn a `Field<T>` type into a `Field<U>` type and vice versa)—`convertTo()`(allows
    you to turn a `Field<U>` type into a `Field<T>` type) and `convertFrom()` (allows
    you to turn a `Field<T>` type into a `Field<U>` type) ad hoc flavors. Since our
    `INSERT` statement cannot take advantage of both directions of the converter,
    we can revert to `convertTo()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, in the case of a `SELECT` statement, you may wish to use `converterFrom()`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you don''t even need to define the converter''s workload in a separate
    class. You can simply inline it, as we''ve done here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: You can check the examples for ad hoc converters in *YearMonthAdHocConverter*
    for MySQL and PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Going further, converters can be nested by nesting the calls of the `to()`/`from()`
    methods and can be chained via the `<X> Converter<T,X> andThen(Converter<? super
    U, X> converter)` method. Both nesting and chaining are exemplified in the bundled
    code (*YearMonthConverter*) by using a second converter that converts between
    `YearMonth` and `Date`, named `YEARMONTH_DATE_CONVERTER`.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, if you want to inverse a converter from `<T, U>` to `<U, T>`, then
    rely on the `Converter.inverse()` method. This can be useful when nesting/chaining
    converters that may require you to inverse `T` with `U` in order to obtain a proper
    match between data types. This is also exemplified in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new data type can be defined based on `converter`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The new data type can be defined without an explicit `Converter` as well. Just
    use the `public default <U> DataType<U> asConvertedDataType(Class<U> toType, Function<?
    super T,? extends U> from, Function<? super U,? extends T> to)` flavor, as in
    the bundled code, and jOOQ will use behind the scenes `Converter.of(Class, Class,
    Function, Function)`.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if a converter is heavily used, then it is better to allow
    jOOQ to apply it automatically without an explicit call, as in the previous examples.
    To accomplish this, we need to perform the proper configurations of the jOOQ Code
    Generator.
  prefs: []
  type: TYPE_NORMAL
- en: Hooking forced types for converters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using so-called *forced types* (`<forcedTypes/>`), we can instruct the jOOQ
    Code Generator to override the column data type. One way to accomplish this consists
    of mapping the column data type to a user-defined data type via `org.jooq.Converter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This configuration step relies on using the `<forcedTypes/>` tag, which is
    a child of the `<database/>` tag. Under the `<forcedTypes/>` tag, we can have
    one or multiple `<forcedType/>` tags, and each of these tags wraps a specific
    case of overriding the column''s data types. Each such case is defined via several
    tags. First, we have the `<userType/>` and `<converter/>` tags, used to link the
    UDT and the proper `Converter`. Second, we have several tags used for identifying
    a certain column (or multiple columns) by name and/or type. While you can find
    all these tags described in the jOOQ manual ([https://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced/codegen-config-database/codegen-database-forced-types/](https://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced/codegen-config-database/codegen-database-forced-types/)),
    let''s mention here two of the most used: `<includeExpression/>` and `<includeTypes/>`.
    `<includeExpression/>` contains a Java `<includeTypes/>` contains a Java regex
    matching the data types that should be forced to have this type (the `<userType/>`
    type). In case of multiple regexes, use the pipe operator (`|`) to separate them,
    and if `<includeExpression/>` and `<includeTypes/>` are present in the same `<forcedType/>`
    tag, then keep in mind that they must match.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the `<forcedType/>` type for `YearMonthConverter` looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we identified the `first_buy_date` column via an expression containing
    the schema, table, and column name. In other cases, you may wish to use less restrictive
    expressions; therefore, here are some popular examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that all regexes in the jOOQ Code Generator match any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1) **Fully qualified object names** (**FQONs**)
  prefs: []
  type: TYPE_NORMAL
- en: 2) Partially qualified object names
  prefs: []
  type: TYPE_NORMAL
- en: 3) Unqualified object names
  prefs: []
  type: TYPE_NORMAL
- en: So, instead of `.*\.customer\.first_buy_date`, you can also just write `customer\.first_buy_date`.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, keep in mind that, by default, regexes are case-sensitive. This is
    important when you're using more than one dialect (for instance, Oracle **identifiers**
    (**IDs**) are *UPPER_CASE*, in PostgreSQL, they are *lower_case*, and in SQL Server,
    they are *PascalCase*).
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, matching any type is done via `<includeTypes>.*</includeTypes>`,
    while matching a certain type such as `NVARCHAR(4000)` is done via `NVARCHAR\(4000\)`,
    and a type such as `NUMBER(1, 0)` via `NUMBER\(1,\s*0\)`. A more verbose version
    of this example with detailed comments is available in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, the `FIRST_BUY_DATE` field is not mapped to `java.lang.Integer`.
    If we check the generated table class that mirrors the `CUSTOMER` table (`jooq.generated.tables.Customer`),
    then we see the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'So, `FIRST_BUY_DATE` is mapped to `YearMonth`, therefore our previous `INSERT`
    and `SELECT` statements will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `SELECT` statement will then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'jOOQ applies our converter automatically, so there''s no need to call it explicitly.
    It even works when we perform a coercing operation of `ResultQuery<R1>` to `ResultQuery<R2>`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: In other words, jOOQ uses our converter automatically for binding variables
    and for fetching data from `java.util.ResultSet`. In queries, we just treat `FIRST_BUY_DATE`
    as of type `YEARMONTH`. The code is named *YearMonthConverterForcedTypes* and
    is available for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an inline converter via Converter.of() or Converter.ofNullable()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, our converter was written as a Java class, and we
    referenced that class in the configuration of the jOOQ Code Generator. But instead
    of writing this class, we can associate the custom data type with an *inline converter*,
    which is a converter written directly into the configuration. For this, we use
    the `<converter/>` tag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: The usage part of this converter remains unchanged. The complete code is named
    *InlineYearMonthConverter*, and the programmatic version is named *ProgrammaticInlineYearMonthConverter*.
    Both applications are available for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an inline converter via lambda expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A more concise inline converter can be written via `<lambdaExpression/>`. This
    tag saves us from the explicit usage of `Converter.of()`/`Converter.ofNullable()`
    and allows us to simply specify a lambda expression that converts from the database
    type via the `<from/>` tag, and a lambda expression that converts to the database
    type via the `<to/>` tag. Let''s exemplify this in our converter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Again, the usage part of this converter remains unchanged. The complete code
    is named *LambdaYearMonthConverter*, and the programmatic version is named *ProgrammaticLambdaYearMonthConverter*.
    Both applications are available for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Matching forced types via SQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous sections, we matched the column names by using regexes in `<includeExpression/>`
    and `<includeTypes/>` tags. Whenever we need more complex criteria for matching
    column names, we can rely on the `<sql/>` tag. The body of this tag is an SQL
    query that executes against the dictionary views of our database. For instance,
    matching all columns of type `TIMESTAMP` from our MySQL `classicmodels` database
    can be achieved like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return several columns, among them being two from the `PAYMENT`
    table and one from the `BANK_TRANSACTION` table: `PAYMENT.PAYMENT_DATE`, `PAYMENT.CACHING_DATE`,
    and `BANK_TRANSACTION.CACHING_DATE`. For these columns, jOOQ will apply `Converter<LocalDateTime,
    JsonNode>` developed in the bundled code. But these are not the only columns returned
    by our query, and jOOQ will apply this converter to `PAYMENT.MODIFIED` and `TOKEN.UPDATED_ON`,
    which are also of type `TIMESTAMP`. Now, we have two options to avoid this—we
    can tune our query predicate accordingly or we can quickly add `<excludeExpression/>`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: You can find the example for MySQL under the name *SqlMatchForcedTypes*.
  prefs: []
  type: TYPE_NORMAL
- en: I'm pretty sure that you got the idea, and you know how to write such queries
    for your favorite database.
  prefs: []
  type: TYPE_NORMAL
- en: JSON converters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever jOOQ detects that the database uses `JSON` type), it maps the database
    type to the `org.jooq.JSON` class. This is a very handy class that represents
    a neat JSON wrapper type for JSON data fetched from the database. Its API consists
    of the `JSON.data()` method that returns a `String` representation of `org.jooq.JSON`
    and a `JSON.valueOf(String data)` method that returns `org.jooq.JSON` from the
    `String` representation. Typically, `org.jooq.JSON` is all you need, but if you
    want to manipulate the fetched JSON via dedicated APIs (Jackson, Gson, **JSON
    Binary** (**JSONB**), and so on), then you need a converter.
  prefs: []
  type: TYPE_NORMAL
- en: So, in order to practice more examples, the bundled code with this book comes
    with a JSON converter (`JsonConverter`), as explained in more detail next.
  prefs: []
  type: TYPE_NORMAL
- en: For MySQL and PostgreSQL, which have the `JSON` data type. The converter converts
    between `org.jooq.JSON` and `com.fasterxml.jackson.databind.JsonNode`, therefore
    it implements `Converter<JSON, JsonNode>`. Of course, you can use this as an example,
    and replace Jackson's `JsonNode` with `com.google.gson.Gson`, `javax/jakarta.json.bind.Jsonb`,
    and so on. The code available for MySQL and PostgreSQL is named *JsonConverterForcedTypes*.
    A programmatic version of this application is available only for MySQL (but you
    can easily adapt it for any other dialect) and is named *ProgrammaticJsonConverter*.
  prefs: []
  type: TYPE_NORMAL
- en: For Oracle 18c, which doesn't have a dedicated JSON type (however, this type
    is available starting with Oracle 21c; see [https://oracle-base.com/articles/21c/json-data-type-21c](https://oracle-base.com/articles/21c/json-data-type-21c)),
    it's common to use `VARCHAR2(4000)` for relatively small JSON data and `BLOB`
    for large JSON data. In both cases, we can add a `CHECK ISJSON()` constraint to
    ensure the JSON data validity. Astonishingly, jOOQ detects that JSON data is present,
    and it maps such columns to the `org.jooq.JSON` type. Our converter converts between
    `org.jooq.JSON` and `com.fasterxml.jackson.databind.JsonNode`. Consider the applications
    named *ConverterJSONToJsonNodeForcedTypes*.
  prefs: []
  type: TYPE_NORMAL
- en: For SQL Server, which doesn't have a dedicated JSON type, it's common to use
    `NVARCHAR` with a `CHECK ISJSON()` constraint. jOOQ doesn't have support to detect
    the usage of JSON data (as in the case of Oracle) and maps this type to `String`.
    In this context, we have a converter in *JsonConverterVarcharToJSONForcedTypes*
    that converts between `NVARCHAR` and `org.jooq.JSON`, and one between `NVARCHAR`
    and `JsonNode` in *JsonConverterVarcharToJsonNodeForcedTypes*.
  prefs: []
  type: TYPE_NORMAL
- en: Take your time and practice these examples in order to get familiar with jOOQ
    converters. Next, let's tackle UDT converters.
  prefs: []
  type: TYPE_NORMAL
- en: UDT converters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you know from [*Chapter 3*](B16833_03.xhtml#_idTextAnchor040), *jOOQ Core
    Concepts*, Oracle and PostgreSQL support UDTs, and we have a UDT in our schema
    named `EVALUATION_CRITERIA`. This UDT is the data type of the `MANAGER.MANAGER_EVALUATION`
    field, and in Oracle, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: We already know that the jOOQ Code Generator automatically maps the fields of
    the `evaluation_criteria` UDT via `jooq.generated.udt.EvaluationCriteria`, and
    the `jooq...pojos.EvaluationCriteria` `jooq...udt.EvaluationCriteria.EvaluationCriteriaRecord`
    record.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we assume that our application needs to manipulate this type as JSON,
    then we need a converter that converts between `EvaluationCriteriaRecord` and
    JSON types (for instance, Jackson `JsonNode`). The `JsonConverter` stub looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we configure this converter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'Having this set, we can express an `INSERT` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can express a `SELECT` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: The bundled code is named *ConverterUDTToJsonNodeForcedTypes* and is available
    for Oracle and PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Custom data types and type binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Roughly, when we want to map a type onto a non-standard JDBC type (a type that
    is not in `org.jooq.impl.SQLDataType`), we need to focus on the `org.jooq.Binding`
    API, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, binding the non-standard vendor-specific PostgreSQL `HSTORE`
    data type to some Java data type (for instance, `HSTORE` can be mapped quite conveniently
    to Java `Map<String, String>`) needs to take advantage of the `Binding` API, which
    contains the following methods (please read the comments):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, let''s consider that we already have an `org.jooq.Converter`
    implementation between `Map<String, String>` and `HSTORE` named `HstoreConverter`,
    and we continue by adding an `org.jooq.Binding` implementation named `HstoreBinding`
    that starts like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, for a MySQL vendor-specific `POINT` type, we may have a
    converter named `PointConverter`, and we need a `PointBinding` class as follows—the
    `POINT` type maps well to the Java `Point2D.Double` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we focus on implementing the `Binding` SPI for PostgreSQL `HSTORE` and
    MySQL `POINT`. An important aspect of this is rendering a bind variable for the
    binding context''s value and casting it to the `HSTORE` type. This is done in
    the `sql()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that for the jOOQ inlined parameters (for details, check [*Chapter 3*](B16833_03.xhtml#_idTextAnchor040),
    *jOOQ Core Concepts*), we don''t need to render a placeholder (`?`); therefore,
    we render only the PostgreSQL specific syntax, `::hstore`. Depending on the database-specific
    syntax, you have to render the expected SQL. For instance, for the PostgreSQL
    `INET` data type, you''ll render `?::inet` (or, `::inet`), while for the MySQL
    `POINT` type, you''ll render `ST_PointFromText(?)` as follows (`Point2D` is `java.awt.geom.Point2D`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we focus on registering a compatible/proper type for JDBC `CallableStatement`
    OUT parameters. Usually, `VARCHAR` is a proper choice (for instance, `VARCHAR`
    is a good choice for `HSTORE`, `INET`, or `JSON` types). The code is illustrated
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: 'But since by default MySQL returns a `POINT` as binary data (as long as we
    don''t use any MySQL function such as `ST_AsText(g)` or `ST_AsWKT(g)` for converting
    geometry values from an internal geometry format to a `java.sql.Blob`, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we convert `Map<String, String>` to a `String` value and set it on a
    JDBC `PreparedStatement` (for the MySQL `POINT` type, we convert `Point2D` to
    `String`), like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, for PostgreSQL `HSTORE`, we get a `String` value from JDBC `ResultSet`
    and convert it to `Map<String, String>`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: 'While for MySQL `POINT`, we get a `Blob` (or an `InputStream`) from JDBC `ResultSet`
    and convert it to `Point2D`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we do the same thing for JDBC `CallableStatement`. For the `HSTORE` type,
    we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: 'And for the `POINT` type, we have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we override the `get(BindingGetSQLInputContext<?> bgsqlc)` and `set(BindingSetSQLOutputContext<?>
    bsqlc)` methods. Since, we don't need them for `HSTORE`/`POINT`, we just throw
    an `SQLFeatureNotSupportedException` exception. For brevity, we skipped this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `Binding` is ready, we have to configure it in the jOOQ Code Generator.
    This is quite similar to the configuration of a `Converter` only that, instead
    of using the `<converter/>` tag, we use the `<binding/>` tag as follows—here,
    we configure `HstoreBinding` (the configuration of `PointBinding` is available
    in the bundled code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can test `HstoreBinding`. For instance, the `PRODUCT` table has a field
    named `SPECS` of type `HSTORE`. The following code inserts a new product with
    some specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the rendered SQL looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: 'After resolving the `?` placeholders, the SQL looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: 'At `INSERT` (`UPDATE`, `DELETE`, and so on), `HstoreConverter` converts from
    Java `Map<String, String>` to an `HSTORE` type. At `SELECT`, the same converter
    converts `HSTORE` to `Map<String, String>`. So, our `SELECT` statement could look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we don't use explicitly any `Binding` or `Converter` and we don't
    *touch* the `HSTORE` type. For us, in the application, `SPECS` is of the type
    `Map<String, String>`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, starting with jOOQ 3.15, we have access to the *jOOQ-postgres-extensions*
    module ([https://github.com/jOOQ/jOOQ/issues/5507](https://github.com/jOOQ/jOOQ/issues/5507)),
    which supports `HSTORE` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bindings and converters can be used to write different helper methods. For
    instance, the following method can be used to convert any `Param` to its database
    data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: But what's happening without `Binding`? Is everything lost?
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what's happening without Binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When jOOQ detects a non-standard JDBC type that doesn't have an associated `Binding`,
    it will mark the corresponding field with *@deprecated Unknown data type*, and
    with the message, *Please define an explicit {@link org.jooq.Binding} to specify
    how this type should be handled. Deprecation can be turned off using {@literal
    <deprecationOnUnknownTypes/>} in your Code Generator configuration.*
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, relying on `Binding`s is the way to go, but as a workaround,
    we can also use explicit mapping for `SELECT` statements and `public static <T>
    Field<T> field(String sql, Class<T> type, Object... bindings)`, or another `field()`
    flavor that fits better, for `INSERT`, `UPDATE`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: However, using a non-standard JDBC type in `INSERT` statements (`UPDATE` statements,
    and so on) just like that leads to jOOQ's `SQLDialectNotSupportedException` exception,
    *Type Foo is not supported in dialect Buzz, and in SELECT statements, to jOOQ's
    DataTypeException, No Converter found for types Foo and Buzz.*
  prefs: []
  type: TYPE_NORMAL
- en: You can check the `HSTORE` examples from this section in the application named
    *HstoreBinding*, and the `POINT` examples in the application named *PointGeometryBinding*.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the bundled code contains *InetBinding* for the PostgreSQL `INET`
    type, *JsonBinding* for the PostgreSQL `JSON` type, and *ProgrammaticInetBinding*
    representing the programmatic configuration of `Binding` for the PostgreSQL `INET`
    type. Next, let's discuss enums and how to convert these.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'jOOQ represents an SQL enum type (for example, the MySQL `enum` or PostgreSQL
    `enum` data type created via `CREATE TYPE`) via an interface named `org.jooq.EnumType`.
    Whenever the jOOQ Java Code Generator detects the usage of an SQL enum type, it
    automatically generates a Java enum that implements `EnumType`. For instance,
    the MySQL schema of the `SALE` table contains the following `enum` data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: 'For `vat`, the jOOQ generator renders the `jooq.generated.enums.VatType` enum,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the name of such a class is composed of the table name and the
    column name in *PascalCase*, which means that the name of the preceding class
    should be `SaleVat`. But whenever we want to modify the default name, we can rely
    on jOOQ *generator strategies* and regexes, as we did in [*Chapter 2*](B16833_02.xhtml#_idTextAnchor024),
    *Customizing the jOOQ Level of Involvement*. For instance, we''ve customized the
    preceding class name as `VatType` via the following strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: 'Having these pieces of knowledge is enough to start writing queries based on
    jOOQ-generated enums—for instance, an `INSERT` statement into the `SALE` table
    and a `SELECT` statement from it, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the `Sale`-generated POJO (or user-defined POJOs) and `SaleRecord`
    take advantage of `VatType`, as with any other type.
  prefs: []
  type: TYPE_NORMAL
- en: Writing enum converters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whenever jOOQ-generated jOOQ enums are not enough, we focus on enum converters.
    Here is a non-exhaustive list of scenarios that may require some kind of enum
    converting to be done:'
  prefs: []
  type: TYPE_NORMAL
- en: Using your own Java enum for a database enum type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using your own Java enum for a database non-enum type (or enum-like type)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a Java non-enum type for a database enum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always converting to a Java enum and occasionally to another Java enum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To simplify enum conversion tasks, jOOQ provides a built-in default converter
    named `org.jooq.impl.EnumConverter`. This converter can convert `VARCHAR` values
    to enum literals (and vice versa), or `NUMBER` values to enum ordinals (and vice
    versa). You can also instantiate it explicitly, as has been done here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's tackle the previous list of enum scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Using your own Java enum for a database enum type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Of our four databases, only MySQL and PostgreSQL have dedicated types for enums.
    MySQL has the `enum` type and PostgreSQL has the `CREATE TYPE foo AS enum( ...)`
    syntax. In both cases, jOOQ generates enum classes on our behalf, but let''s suppose
    that we''d prefer to use our own Java enums. For instance, let''s focus on the
    MySQL schema of the `SALE` table, which contains these two enums:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: 'The same enums in PostgreSQL are declared like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s assume that for `vat`, we still rely on a jOOQ-generated Java enum-class
    (as in the previous section, `VatType`), while for `rate`, we have written the
    following Java enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to automatically map the `rate` column to the `RateType` enum, we
    rely on the `<forcedType/>` and `<enumConverter/>` flag tags, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: 'By enabling `<enumConverter/>`, we instruct jOOQ to automatically apply the
    built-in `org.jooq.impl.EnumConverter` converter whenever `SALE.RATE` is used.
    Done! From this point forward, we can treat the `SALE.RATE` field as of type `RateType`,
    and jOOQ will handle the conversion aspects of the mapped field (listed here for
    MySQL), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: The application named *SimpleBuiltInEnumConverter* contains the complete example
    for MySQL and PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very convenient approach and works the same in MySQL and PostgreSQL,
    but if we don't employ this automatic conversion, we still can use our `RateType`
    Java enum manually or explicitly. Let's see how!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we configure the jOOQ Code Generator to exclude enum generation for
    the `sale_rate` (MySQL)/`rate_type` (PostgreSQL) types; otherwise, the `SALE.RATE`
    field will be automatically mapped to the generated Java enum. The code is illustrated
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: 'In this context, jOOQ maps `SALE.RATE` to `String` in MySQL, and to `Object`
    in PostgreSQL. In PostgreSQL, the field is annotated as *@deprecated Unknown data
    type*, but we turn off this deprecation via the `<deprecationOnUnknownTypes/>`
    configuration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in MySQL, we can write an `INSERT` statement, as follows (`SALE.RATE`
    is of type `String`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can write a `SELECT` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: 'While for MySQL this is quite smooth, for PostgreSQL it''s a little bit tricky.
    The PostgreSQL syntax requires us to render at `INSERT` something like `?::"public"."rate_type"`,
    as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: 'And at `SELECT`, we need an explicit coercing of `Object` to `String`, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: The application named *MyEnumBuiltInEnumConverter* contains complete examples
    for MySQL and PostgreSQL. If we don't suppress the jOOQ enum generation, then
    another approach consists of writing an explicit converter (by extending the jOOQ
    built-in `org.jooq.impl.EnumConverter` converter) between the jOOQ generated enum
    and our enum. Of course, this converter must be called explicitly in your queries.
    You can find such an example for the `vat` enum in the application mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Using your own Java enum for a database non-enum type (or enum-like type)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s consider a legacy database containing a column that takes only certain
    values but was declared as `VARCHAR` (or `NUMBER`)—for instance, the `SALE` table
    has a `TREND` field of type `VARCHAR` that takes only the values *UP*, *DOWN*,
    and *CONSTANT*. In this context, it would be more practical to enforce the usage
    of this field via an enum, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: 'But now, we have to handle the conversion between `TrendType` and `VARCHAR`.
    This can be done automatically by jOOQ if we add the following `<forcedType/>`
    tag (here, for Oracle):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: In the *SimpleBuiltInEnumConverter* application, you can see a complete example
    next to other examples for all four databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since SQL Server and Oracle don''t have an enum type, we have used an alternative.
    Among others, a common alternative relies on a `CHECK` constraint to obtain an
    enum-like behavior. These enum-like types can take advantage of `<enumConverter/>` exactly
    as shown previously. Here, it is the `SALE.VAT` field in Oracle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: 'And here, it is the `<forcedType/>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don''t want to rely on automatic conversion, then we can use an explicit
    converter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: In the *BuiltInEnumConverter* application, you can find a complete example next
    to other examples for all four databases.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Java non-enum type for a database enum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, we need a non-enum type for a database enum. For instance, let''s
    assume that we want to use some integers in place of the `VatType` enum (*0* for
    *NONE*, *5* for *MIN*, and *19* for *MAX*) because we might need these integers
    in different computations. Maybe the best idea is to write a converter that starts
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: 'But this doesn''t work, because the `EnumConverter` signature is actually of
    type `EnumConverter<T,``U extends Enum<U>>`. Obviously, `Integer` doesn''t pass
    this signature since it doesn''t extend `java.lang.Enum`, hence we can rely on
    a regular converter (as you saw in the previous section), as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: The *BuiltInEnumConverter* application contains this example next to other examples.
    Of course, you can try to write this converter as an inline converter via `Converter.of()`/`ofNullable()`
    or lambda expressions as well.
  prefs: []
  type: TYPE_NORMAL
- en: Always converting to a Java enum and occasionally to another Java enum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always converting to a Java enum and occasionally to another Java enum is most
    probably not such a popular task, but let's use it as a pretext to condense what
    we've learned so far about enum conversions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the well-known `SALE.RATE` enum field in MySQL. First, we want
    to always/automatically convert `SALE.RATE` to our `RateType` Java enum, shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: 'For this, we write the following `<forcedType/>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we can refer in queries to `SALE.RATE` as a `RateType` enum, but let''s
    assume that we also have the following `StarType` enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, `StarType` is an alternative to `RateType` (*THREE_STARS* corresponds
    to *SILVER*, *FOUR_STARS* to *GOLD*, and *FIVE_STARS* to *PLATINUM*). Now, we
    may occasionally want to use `StarType` in queries instead of `RateType`, therefore
    we need a converter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: Since `RateType` and `StarType` don't contain the same literals, we have to
    override the `to()` method and define the expected matches. Done!
  prefs: []
  type: TYPE_NORMAL
- en: 'Expressing an `INSERT` statement that uses `RateType` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: 'And whenever we want to use `StarType` instead of `RateType`, we rely on the
    static `SALE_RATE_STAR_CONVERTER` converter, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: The *BuiltInEnumConverter* application contains this example, along with other
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Via `classicmodels\.sale\.rate`, we nominated a certain column (`CLASSICMODELS.SALE.RATE`),
    but we may want to pick up all columns of this enum type. In such cases, an SQL
    query is more proper than a regex. Here is such a query for Oracle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: You can find this example for MySQL and Oracle as *BuiltInEnumSqlConverter*.
  prefs: []
  type: TYPE_NORMAL
- en: In the bundled code, there are more applications, such as *EnumConverter*, which
    has examples of plain `org.jooq.Converter` types for enums; *EnumConverterForceTypes*,
    which has `<forcedType/>` and enum examples; and `I`*nsertEnumPlainSql*, which
    has `INSERT` and enum examples when the jOOQ Code Generator is not used.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the DataType<T> tag for a given enum data type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Retrieving the `DataType<T>` tag for a given enum data type can be done as
    in the following three examples that speak for themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can use this data type as any other data type. Next, let's tackle the
    topic of data type rewrites.
  prefs: []
  type: TYPE_NORMAL
- en: Data type rewrites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another utility of `<forcedTypes/>` is data type rewrites. This allows us to
    explicitly choose the SQL data type (supported by the database, or unsupported
    but present in `org.jooq.impl.SQLDataType`) that should be used in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, in Oracle, a common use case is to map the missing `BOOLEAN`
    type as `NUMBER(1,0)` or `CHAR(1)`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: But this means that the jOOQ Code Generator will map fields of type `NUMBER(1,
    0)` to the `SQLDataType.TINYINT` SQL data type and the `java.lang.Byte` type and,
    respectively, the fields of type `CHAR(1)` to the `SQLDataType.CHAR` SQL data
    type and the `String` Java type.
  prefs: []
  type: TYPE_NORMAL
- en: But the Java `String` type is commonly associated with text data manipulation,
    while the `Byte` type is commonly associated with binary data manipulations (for
    example, reading/writing a binary file) and the Java `Boolean` type clearly communicates
    the intention of using flag-type data. Moreover, the Java `Boolean` type has an
    SQL type (standard JDBC type) homologous to `SQLDataType.BOOLEAN`.
  prefs: []
  type: TYPE_NORMAL
- en: 'jOOQ allows us to force the type of columns, therefore we can force the type
    of `SALE.HOT` to `BOOLEAN`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: 'Done! Now, we can treat `SALE.HOT` as a Java `Boolean` type. Here is an `INSERT`
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on `NUMBER` precision, jOOQ will map this data type to `BigInteger`,
    `Short`, or even `Byte` (as you just saw). If you find it cumbersome to use such
    Java types and you know that your data fits better for `Long` or `Integer` types,
    then you have two options: adjust the `NUMBER` precision accordingly, or rely
    on jOOQ type rewriting. Of course, you can apply this technique to any other type
    and dialect.'
  prefs: []
  type: TYPE_NORMAL
- en: A complete example can be found in *DataTypeRewriting*. The programmatic version
    of this example is called *ProgrammaticDataTypeRewriting*. Next, let's understand
    how you can handle jOOQ embeddable types.
  prefs: []
  type: TYPE_NORMAL
- en: Handling embeddable types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Embeddable types represent a powerful feature introduced in jOOQ 3.14\. Roughly,
    this feature gets materialized in synthetic UDTs that can be used with all databases
    supported by jOOQ. While PostgreSQL and Oracle support UDTs (we can use UDTs directly
    in **Data Definition Language** (**DDL**)), other databases including MySQL and
    SQL Server don't support UDTs. But via jOOQ embeddable types, we can work at the
    application level with synthetic UDTs for any database, and jOOQ will take care
    of the underlying aspects of mapping these types to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'An embeddable type mimics a UDT by synthetically wrapping one (usually more)
    database column in a generated `org.jooq.EmbeddableRecord`. For instance, we can
    wrap `OFFICE.CITY`, `OFFICE.STATE`, `OFFICE.COUNTRY`, `OFFICE.TERRITORY`, and
    `OFFICE.ADDRESS_LINE_FIRST` under an embeddable type named `OFFICE_FULL_ADDRESS`
    via the following configuration in the jOOQ Code Generator (here, for MySQL):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: 'And we continue with the settings for matching tables and fields, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, jOOQ generates `jooq...records.OfficeFullAddressRecord`, which extends
    `EmbeddableRecordImpl` and `jooq...pojos.OfficeFullAddress`. Moreover, in the
    generated `Office` table, we observe a new `OFFICE_FULL_ADDRESS` field that can
    be used as in the following `INSERT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, the `OFFICE_FULL_ADDRESS` column can be used in all types of statements,
    including `INSERT`, `UPDATE`, `DELETE`, and `SELECT`. Here, it is used in a `SELECT`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: 'Or it can be fetched into the `OfficeFullAddress` POJO, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, for MySQL, we have *EmbeddableType*, which contains the
    previous example, and for PostgreSQL, we have *ProgrammaticEmbeddableType*, which
    is the programmatic version of the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we have access to (we can use) the embeddable type, but we still
    have direct access to fields wrapped in this embeddable type. For instance, these
    fields can be used in `INSERT` statements, `SELECT` statements, and so on, and
    they appear in the **Integrated Development Environment's** (**IDE's**) autocompletion
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *replacing fields* feature means to signal to jOOQ to disallow direct access
    to fields that are part of an embeddable type. These fields will not appear in
    the IDE''s autocompletion list anymore, and the result set of `SELECT` statements
    will not contain these fields. Enabling this feature can be done via the `<replacesFields/>`
    flag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: The *EmbeddableTypeReplaceFields* application contains this example for Oracle,
    while *ProgrammaticEmbeddableTypeReplaceFields* contains a programmatic version
    of this example for SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: Converting embeddable types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Converting an embeddable type can be done via `org.jooq.Converter`, as for
    any other type. For example, converting between `JsonNode` and `OFFICE_FULL_ADDRESS`
    can be done via a `Converter` that starts like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: 'And here, it is a `SELECT` statement that fetches `OFFICE.OFFICE_FULL_ADDRESS`
    as `JsonNode` via `JSON_CONVERTER`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: The *ConvertEmbeddableType* application for MySQL contains this example.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded domains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quite popular in PostgreSQL, *domain* types represent UDTs built on top of
    other types and containing optional constraints. For instance, in our PostgreSQL
    schema, we have the following domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: 'And it is used in the `office` table, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: 'jOOQ can generate a Java type for each domain type if we turn on this feature,
    as has been done here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: While `.*` matches all domain types, you can use more restrictive regexes to
    match exactly the domains that will be replaced by embeddable types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The jOOQ Code Generator generates an embeddable type named (by default) `PostalCodeRecord`
    (in `jooq.generated.embeddables.records`). We can use it for creating semantically
    type-safe queries, as in these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for PostgreSQL is named *Domain*.
  prefs: []
  type: TYPE_NORMAL
- en: Well, we've reached the end of this section and the end of this chapter. Notice
    that we intentionally skipped the topic of embeddable types and embeddable keys
    (including composite keys) since this topic is covered later in [*Chapter 11*](B16833_11.xhtml#_idTextAnchor209),
    *jOOQ Keys*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a must-have in your jOOQ arsenal. Mastering the topics covered
    here—such as custom data types, converters, bindings, database vendor-specific
    data types, enums, embeddable types, and so on—will help you to shape the interaction
    between Java and database data types to fit your non-trivial scenarios. In the
    next chapter, we cover the topics of fetching and mapping.
  prefs: []
  type: TYPE_NORMAL
