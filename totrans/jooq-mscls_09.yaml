- en: '*Chapter 7*: Types, Converters, and Bindings'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第七章*: 类型、转换器和绑定'
- en: 'Data types, converters, and bindings represent major aspects of working with
    a database via a Java-based **Domain-Specific Language** (**DSL**) **Application
    Programming Interface** (**API**). Sooner or later, standard **Structured Query
    Language** (**SQL**)/**Java Database Connectivity** (**JDBC**) data types will
    not be enough, or the default mappings between Java types and JDBC types will
    raise some shortcomings in your specific scenarios. At that moment, you''ll be
    interested in creating new data types, working with custom data types, type conversion,
    and type-binding capabilities of your DSL API. Fortunately, the **jOOQ Object
    Oriented Querying** (**jOOQ**) DSL provides versatile and easy-to-use APIs dedicated
    to the following agenda that represents the subject of this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型、转换器和绑定代表了通过基于Java的 **领域特定语言** (**DSL**) **应用程序编程接口** (**API**) 与数据库交互的主要方面。迟早，标准的
    **结构化查询语言** (**SQL**)/**Java数据库连接** (**JDBC**) 数据类型将不足以满足需求，或者Java类型和JDBC类型之间的默认映射将在你的特定场景中引起一些不足。在那个时刻，你将感兴趣于创建新的数据类型，使用自定义数据类型，以及你的DSL
    API的类型转换和类型绑定能力。幸运的是，**jOOQ面向对象的查询** (**jOOQ**) DSL提供了多功能且易于使用的API，专注于以下议程，这也是本章的主题：
- en: Default data type conversion
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认数据类型转换
- en: Custom data types and type conversion
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义数据类型和类型转换
- en: Custom data types and type binding
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义数据类型和类型绑定
- en: Manipulating enums
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作枚举
- en: Data type rewrites
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型重写
- en: Handling embeddable types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理可嵌入类型
- en: Let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter07](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter07).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：[https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter07](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter07)。
- en: Default data type conversion
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认数据类型转换
- en: 'One of the aspects of jOOQ that allows us to use it in a smooth manner is its
    *default data type conversion*. Most of the time, jOOQ hides from us the ceremony
    of converting between JDBC and Java types. For instance, have you wondered how
    the following explicit conversions work? Take a look:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ允许我们以平滑方式使用的一个方面是其 *默认数据类型转换*。大多数时候，jOOQ会隐藏JDBC和Java类型之间转换的仪式。例如，你是否好奇以下显式转换是如何工作的？看看下面：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Both conversions are resolved via *default data type conversion* or *auto-conversions*.
    Behind the scenes, jOOQ relies on its own API that is capable of performing soft
    type-safe conversions for `Object` types, arrays, and collections.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种转换都通过 *默认数据类型转换* 或 *自动转换* 来解决。在幕后，jOOQ依赖于它自己的API，能够为 `Object` 类型、数组以及集合执行软类型安全的转换。
- en: You can check out this example in the *ConvertUtil* application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *ConvertUtil* 应用程序中查看这个示例。
- en: Custom data types and type conversion
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义数据类型和类型转换
- en: In jOOQ, the common interface for all dialect-specific data types is named `org.jooq.DataType<T>`,
    where `T` represents the Java type associated with an SQL data type. Each association
    of a `T` Java data type with an SQL data type (generic SQL types, called standard
    JDBC types) represented by `java.sql.Types` is present in jOOQ's `org.jooq.impl.SQLDataType`
    API. The jOOQ Code Generator automatically maps Java types to this `SQLDataType`
    API, which has an almost 1:1 matching to databases' data types for most dialects.
    Of course, we are not including here some of the vendor-specific data types, such
    as spatial data types, PostgreSQL's `INET`/`HSTORE`, nor other non-standard JDBC
    types (data types not explicitly supported by JDBC).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在jOOQ中，所有特定方言数据类型的通用接口命名为 `org.jooq.DataType<T>`，其中 `T` 代表与SQL数据类型关联的Java类型。每个
    `T` Java数据类型与由 `java.sql.Types` 表示的SQL数据类型的关联（称为通用SQL类型，即标准JDBC类型）都存在于jOOQ的 `org.jooq.impl.SQLDataType`
    API中。jOOQ代码生成器自动将Java类型映射到这个 `SQLDataType` API，对于大多数方言，它与数据库的数据类型几乎1:1匹配。当然，我们不包括一些供应商特定的数据类型，例如空间数据类型、PostgreSQL的
    `INET`/`HSTORE`，以及其他非标准JDBC类型（JDBC未明确支持的数据类型）。
- en: 'Roughly, any data type that is not associated in the jOOQ API with a standard
    JDBC type is considered and treated as a *custom data type*. However, as Lukas
    Eder mentions: "*There are some data types that I think *should* be standard JDBC
    types, but are not. They''re also listed in* `SQLDataType`*, including:* `JSON`*,*
    `JSONB`*,* `UUID`*,* `BigInteger` *(!), unsigned numbers, intervals. These don''t
    require custom data types.*"'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 大概来说，任何与jOOQ API没有关联标准JDBC类型的非数据类型都被视为和当作*自定义数据类型*。然而，正如卢卡斯·埃德尔提到的：“*我认为有些数据类型应该是标准JDBC类型，但不是。它们也列在*
    `SQLDataType`*中，包括：`JSON`、`JSONB`、`UUID`、`BigInteger`（!）、无符号数字、区间。这些不需要自定义数据类型。”
- en: Whenever your custom data type needs to be mapped onto a standard JDBC type—that
    is, an `org.jooq.impl.SQLDataType` type—you need to provide and explicitly specify
    an `org.jooq.Converter` implementation. This converter does the hard work of performing
    a conversion between the involved types.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的自定义数据类型需要映射到标准JDBC类型——即`org.jooq.impl.SQLDataType`类型时，你需要提供并明确指定一个`org.jooq.Converter`实现。这个转换器执行涉及类型之间的转换的艰苦工作。
- en: Important Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When we want to map a type onto a non-standard JDBC type (a type that is not
    in `org.jooq.impl.SQLDataType`), we need to focus on the `org.jooq.Binding` API,
    which is covered later. So, if this is your case, don't try to shoehorn your conversion
    logic onto a `Converter`. Just use a `Binding` (we'll see this later in this chapter).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将一个类型映射到非标准JDBC类型（不在`org.jooq.impl.SQLDataType`中的类型）时，我们需要关注`org.jooq.Binding`
    API，这将在后面进行介绍。因此，如果这是你的情况，不要试图将你的转换逻辑强行应用到`Converter`上。只需使用`Binding`（我们将在本章后面看到这一点）。
- en: 'Pay attention that attempting to insert values/data of a custom data type without
    passing through a converter may result in inserting `null` values in the database
    (as Lukas Eder shared: "*This null behavior is an old design flaw. A long time
    ago, I''ve not followed a fail-early strategy throwing exceptions*"), while trying
    to fetch data of custom data type without a converter may lead to `org.jooq.exception.DataTypeException`,
    *no converter found for types Foo and Buzz*.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尝试在不通过转换器的情况下插入自定义数据类型的价值/数据可能会导致数据库中插入`null`值（正如卢卡斯·埃德尔分享的那样：“*这种null行为是一个旧的设计缺陷。很久以前，我没有遵循尽早失败策略抛出异常*”），而尝试在没有转换器的情况下获取自定义数据类型的数据可能会导致`org.jooq.exception.DataTypeException`，*没有找到Foo和Buzz类型的转换器*。
- en: Writing an org.jooq.Converter interface
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写org.jooq.Converter接口
- en: '`org.jooq.Converter` is an interface that represents a conversion between two
    types that are generically denoted as `<T>` and `<U>`. By `<T>`, we represent
    the database type, and by `<U>`, we represent the `<T>` to `<U>` is accomplished
    in a method named `U from(T)`, and converting from `<U>` to `<T>` is accomplished
    in a method named `T to(U)`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.jooq.Converter`是一个接口，它表示两种类型之间的转换，这两种类型被泛型表示为`<T>`和`<U>`。通过`<T>`，我们表示数据库类型，通过`<U>`，我们表示`<T>`到`<U>`的转换是通过一个名为`U
    from(T)`的方法完成的，而从`<U>`到`<T>`的转换是通过一个名为`T to(U)`的方法完成的。'
- en: If you find it hard to remember which direction is "`from()`" and which direction
    is "`to()`", then think that the former can be read as "*FROM the database to
    the client*" and the latter as "*from the client TO the database*". Also, pay
    attention to not confuse `T` and `U` because you risk spending hours staring at
    compilation errors in generated code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现很难记住哪个方向是"`from()`"`，哪个方向是"`to()`"`，那么可以这样想：前者可以读作"*从数据库到客户端*"，后者可以读作"*从客户端到数据库*"。此外，请注意不要混淆`T`和`U`，因为这样你可能会花费数小时盯着生成的代码中的编译错误。
- en: 'In other words, via `U from(T)`, we convert from a database type to a UDT (for
    example, this is useful in `SELECT` statements), and via `T to(U)`, we convert
    from a UDT to a database type (for example, this is useful in `INSERT`, `UPDATE`,
    and `DELETE` statements). Moreover, a `T to(U)` direction is used wherever bind
    variables are used, so also in `SELECT` when writing predicates—for instance,
    `T.CONVERTED.eq(u)`. The stub of `org.jooq.Converter` is listed here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，通过`U from(T)`，我们将数据库类型转换为UDT（例如，这在`SELECT`语句中很有用），通过`T to(U)`，我们将UDT转换为数据库类型（例如，这在`INSERT`、`UPDATE`和`DELETE`语句中很有用）。此外，`T
    to(U)`方向用于任何使用绑定变量的地方，所以也在`SELECT`时编写谓词——例如，`T.CONVERTED.eq(u)`。`org.jooq.Converter`的存根如下：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'jOOQ comes with an abstract implementation of this interface (`AbstractConverter`)
    and a few concrete extensions (converters) of this abstraction that you can explore
    here: [https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/impl/AbstractConverter.html](https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/impl/AbstractConverter.html).
    But as you''ll see next, we can write our own converters.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 提供了这个接口的抽象实现（`AbstractConverter`）以及一些抽象的具体系列（转换器），您可以在以下链接中探索：[https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/impl/AbstractConverter.html](https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/impl/AbstractConverter.html)。但正如您接下来会看到的，我们可以编写自己的转换器。
- en: 'If, for instance, you want to use Java 8''s `java.time.YearMonth` type in the
    application but store it as an SQL `INTEGER` type in the database, you write a
    converter like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想在应用程序中使用 Java 8 的 `java.time.YearMonth` 类型，但在数据库中存储为 SQL `INTEGER` 类型，您可以编写如下转换器：
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Use this converter via `new YearMonthConverter()` or define a handy `static`
    type, like so:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `new YearMonthConverter()` 或定义一个方便的 `static` 类型，如下所示来使用这个转换器：
- en: '[PRE39]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Moreover, using this converter for arrays can be done via the following `static`
    type, like so:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用此转换器处理数组可以通过以下 `static` 类型完成，如下所示：
- en: '[PRE41]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once we have a converter, we can define a new data type. More precisely, we
    define our own `DataType` type programmatically by calling `asConvertedDataType(Converter)`
    or `asConvertedDataType(Binding)`. For example, here, we define a `YEARMONTH`
    data type that can be used as any other data type defined in `SQLDataType`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了转换器，我们就可以定义一个新的数据类型。更确切地说，我们通过调用 `asConvertedDataType(Converter)` 或 `asConvertedDataType(Binding)`
    程序化地定义自己的 `DataType` 类型。例如，在这里，我们定义了一个 `YEARMONTH` 数据类型，它可以像 `SQLDataType` 中定义的任何其他数据类型一样使用：
- en: '[PRE44]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, `INTEGER` is the `org.jooq.impl.SQLDataType.INTEGER` data type.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`INTEGER` 是 `org.jooq.impl.SQLDataType.INTEGER` 数据类型。
- en: 'In the `CUSTOMER` table, we have a field named `FIRST_BUY_DATE` of type `INT`.
    When a customer makes their first purchase, we store the date (year-month) as
    an integer. For example, the date *2020-10* is stored as *24249* (we manually
    applied the `Integer to(YearMonth u)` method). Without a converter, we have to
    insert *24249* explicitly; otherwise, the code will not compile (for example,
    a type-safe `INSERT` statement will not compile) or we''ll get an invalid insert
    (for example, a non-type-safe `INSERT` statement may store `null`). Relying on
    our converter, we can write the following type-safe `INSERT` statement:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CUSTOMER` 表中，我们有一个名为 `FIRST_BUY_DATE` 的字段，其类型为 `INT`。当客户进行首次购买时，我们将日期（年月）存储为整数。例如，日期
    *2020-10* 被存储为 *24249*（我们手动应用了 `Integer to(YearMonth u)` 方法）。如果没有转换器，我们必须显式地插入
    *24249*；否则，代码将无法编译（例如，类型安全的 `INSERT` 语句将无法编译）或者我们可能会得到一个无效的插入（例如，非类型安全的 `INSERT`
    语句可能会存储 `null`）。依赖我们的转换器，我们可以编写以下类型安全的 `INSERT` 语句：
- en: '[PRE46]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, fetching all the `FIRST_BUY_DATE` values of *Atelier One* without using
    the converter will result in an array or list of integers. To fetch an array/list
    of `YearMonth`, we can use the converter, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在不使用转换器的情况下获取 *Atelier One* 的所有 `FIRST_BUY_DATE` 值将导致得到一个整数数组或列表。要获取 `YearMonth`
    类型的数组/列表，我们可以使用转换器，如下所示：
- en: '[PRE51]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the bundled code (*YearMonthConverter*, available for MySQL and PostgreSQL),
    you can see more examples, including the usage of the `YEARMONTH` data type for
    coercing and casting operations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码（*YearMonthConverter*，适用于 MySQL 和 PostgreSQL）中，您可以看到更多示例，包括使用 `YEARMONTH`
    数据类型进行强制转换和类型转换的操作。
- en: 'Writing a converter having its own class is useful when the converter is used
    sporadically across different places/classes. If you know that the converter is
    used only in a single class, then you can define it locally in that class via
    `Converter.of()/ofNullable()`, as follows (the difference between them consists
    of the fact that `Converter.ofNullable()` always returns `null` for `null` inputs):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当转换器在不同位置/类中偶尔使用时，编写具有其自己类的转换器是有用的。如果您知道转换器只在一个类中使用，那么您可以通过 `Converter.of()/ofNullable()`
    在该类中本地定义它，如下所示（它们之间的区别在于 `Converter.ofNullable()` 对于 `null` 输入始终返回 `null`）：
- en: '[PRE56]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Moreover, starting with jOOQ 3.15+, we can use a so-called *ad hoc converter*.
    This type of converter is very handy for attaching a converter to a certain column
    just for one query or a few local queries. For instance, having a converter (`INTEGER_YEARMONTH_CONVERTER`),
    we can use it for a single column, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从 jOOQ 3.15+ 开始，我们可以使用所谓的 *ad hoc 转换器*。这种类型的转换器对于将转换器附加到特定列以供单个查询或几个局部查询使用非常有用。例如，有一个转换器（`INTEGER_YEARMONTH_CONVERTER`），我们可以用它来处理单个列，如下所示：
- en: '[PRE66]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'For convenience, jOOQ provides—next to the ad hoc `convert()` function (allows
    you to turn a `Field<T>` type into a `Field<U>` type and vice versa)—`convertTo()`(allows
    you to turn a `Field<U>` type into a `Field<T>` type) and `convertFrom()` (allows
    you to turn a `Field<T>` type into a `Field<U>` type) ad hoc flavors. Since our
    `INSERT` statement cannot take advantage of both directions of the converter,
    we can revert to `convertTo()`, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，jOOQ除了提供特定的`convert()`函数（允许你将`Field<T>`类型转换为`Field<U>`类型，反之亦然）之外，还提供了`convertTo()`（允许你将`Field<U>`类型转换为`Field<T>`类型）和`convertFrom()`（允许你将`Field<T>`类型转换为`Field<U>`类型）的特定风味。由于我们的`INSERT`语句无法利用转换器的两个方向，我们可以回退到`convertTo()`，如下所示：
- en: '[PRE70]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Or, in the case of a `SELECT` statement, you may wish to use `converterFrom()`,
    as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在`SELECT`语句的情况下，你可能希望使用`converterFrom()`，如下所示：
- en: '[PRE75]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Of course, you don''t even need to define the converter''s workload in a separate
    class. You can simply inline it, as we''ve done here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你甚至不需要在单独的类中定义转换器的负载。你可以简单地内联它，就像我们在这里所做的那样：
- en: '[PRE81]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: You can check the examples for ad hoc converters in *YearMonthAdHocConverter*
    for MySQL and PostgreSQL.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看*YearMonthAdHocConverter*中的示例，了解MySQL和PostgreSQL的特定转换器。
- en: Going further, converters can be nested by nesting the calls of the `to()`/`from()`
    methods and can be chained via the `<X> Converter<T,X> andThen(Converter<? super
    U, X> converter)` method. Both nesting and chaining are exemplified in the bundled
    code (*YearMonthConverter*) by using a second converter that converts between
    `YearMonth` and `Date`, named `YEARMONTH_DATE_CONVERTER`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，可以通过嵌套`to()`/`from()`方法的调用来嵌套转换器，可以通过`<X> Converter<T,X> andThen(Converter<?
    super U, X> converter)`方法进行链式调用。嵌套和链式调用都在捆绑代码（*YearMonthConverter*）中通过使用第二个转换器进行了示例，该转换器在`YearMonth`和`Date`之间进行转换，命名为`YEARMONTH_DATE_CONVERTER`。
- en: Moreover, if you want to inverse a converter from `<T, U>` to `<U, T>`, then
    rely on the `Converter.inverse()` method. This can be useful when nesting/chaining
    converters that may require you to inverse `T` with `U` in order to obtain a proper
    match between data types. This is also exemplified in the bundled code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你想从`<T, U>`逆转换到`<U, T>`，那么就依靠`Converter.inverse()`方法。这在嵌套/链式调用转换器时可能很有用，可能需要你逆转换`T`与`U`以获得数据类型之间的适当匹配。这也在捆绑代码中得到了示例。
- en: 'The new data type can be defined based on `converter`, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 新的数据类型可以根据`converter`进行定义，如下所示：
- en: '[PRE90]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The new data type can be defined without an explicit `Converter` as well. Just
    use the `public default <U> DataType<U> asConvertedDataType(Class<U> toType, Function<?
    super T,? extends U> from, Function<? super U,? extends T> to)` flavor, as in
    the bundled code, and jOOQ will use behind the scenes `Converter.of(Class, Class,
    Function, Function)`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以不使用显式的`Converter`来定义新的数据类型。只需使用`public default <U> DataType<U> asConvertedDataType(Class<U>
    toType, Function<? super T,? extends U> from, Function<? super U,? extends T>
    to)`这种风味，就像捆绑代码中那样，jOOQ将在幕后使用`Converter.of(Class, Class, Function, Function)`。
- en: On the other hand, if a converter is heavily used, then it is better to allow
    jOOQ to apply it automatically without an explicit call, as in the previous examples.
    To accomplish this, we need to perform the proper configurations of the jOOQ Code
    Generator.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果一个转换器被大量使用，那么最好允许jOOQ在没有显式调用的情况下自动应用它，就像之前的示例中那样。为了实现这一点，我们需要对jOOQ代码生成器进行适当的配置。
- en: Hooking forced types for converters
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为转换器强制类型
- en: By using so-called *forced types* (`<forcedTypes/>`), we can instruct the jOOQ
    Code Generator to override the column data type. One way to accomplish this consists
    of mapping the column data type to a user-defined data type via `org.jooq.Converter`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用所谓的*强制类型* (`<forcedTypes/>`)，我们可以指示jOOQ代码生成器覆盖列的数据类型。实现这一目标的一种方法是通过`org.jooq.Converter`将列数据类型映射到用户定义的数据类型。
- en: 'This configuration step relies on using the `<forcedTypes/>` tag, which is
    a child of the `<database/>` tag. Under the `<forcedTypes/>` tag, we can have
    one or multiple `<forcedType/>` tags, and each of these tags wraps a specific
    case of overriding the column''s data types. Each such case is defined via several
    tags. First, we have the `<userType/>` and `<converter/>` tags, used to link the
    UDT and the proper `Converter`. Second, we have several tags used for identifying
    a certain column (or multiple columns) by name and/or type. While you can find
    all these tags described in the jOOQ manual ([https://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced/codegen-config-database/codegen-database-forced-types/](https://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced/codegen-config-database/codegen-database-forced-types/)),
    let''s mention here two of the most used: `<includeExpression/>` and `<includeTypes/>`.
    `<includeExpression/>` contains a Java `<includeTypes/>` contains a Java regex
    matching the data types that should be forced to have this type (the `<userType/>`
    type). In case of multiple regexes, use the pipe operator (`|`) to separate them,
    and if `<includeExpression/>` and `<includeTypes/>` are present in the same `<forcedType/>`
    tag, then keep in mind that they must match.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置步骤依赖于使用 `<forcedTypes/>` 标签，它是 `<database/>` 标签的子标签。在 `<forcedTypes/>` 标签下，我们可以有一个或多个
    `<forcedType/>` 标签，并且每个这样的标签都封装了覆盖列数据类型的特定情况。每种情况都通过几个标签定义。首先，我们有 `<userType/>`
    和 `<converter/>` 标签，用于将 UDT 和适当的 `Converter` 链接起来。其次，我们有几个标签用于通过名称和/或类型识别某个特定列（或多个列）。虽然你可以在
    jOOQ 手册中找到所有这些标签的描述（[https://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced/codegen-config-database/codegen-database-forced-types/](https://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced/codegen-config-database/codegen-database-forced-types/))，但在这里我们提到两个最常用的标签：`<includeExpression/>`
    和 `<includeTypes/>`。`<includeExpression/>` 包含一个 Java `<includeTypes/>` 包含一个 Java
    正则表达式，匹配应该强制具有此类型的数据类型（`<userType/>` 类型）。在存在多个正则表达式的情况下，使用管道操作符（`|`）分隔它们，并且如果
    `<includeExpression/>` 和 `<includeTypes/>` 在同一个 `<forcedType/>` 标签中存在，那么请记住它们必须匹配。
- en: 'For instance, the `<forcedType/>` type for `YearMonthConverter` looks like
    this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`YearMonthConverter` 的 `<forcedType/>` 类型看起来像这样：
- en: '[PRE92]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Notice how we identified the `first_buy_date` column via an expression containing
    the schema, table, and column name. In other cases, you may wish to use less restrictive
    expressions; therefore, here are some popular examples:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何通过包含模式、表和列名称的表达式来识别 `first_buy_date` 列的。在其他情况下，你可能希望使用更宽松的表达式；因此，这里有一些流行的例子：
- en: '[PRE109]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Important Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Notice that all regexes in the jOOQ Code Generator match any of the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，jOOQ 代码生成器中的所有正则表达式都匹配以下内容之一：
- en: 1) **Fully qualified object names** (**FQONs**)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 1) **完全限定对象名称**（**FQONs**）
- en: 2) Partially qualified object names
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 2) 部分限定对象名称
- en: 3) Unqualified object names
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 3) 未限定对象名称
- en: So, instead of `.*\.customer\.first_buy_date`, you can also just write `customer\.first_buy_date`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了 `.*\.customer\.first_buy_date`，你也可以直接写 `customer\.first_buy_date`。
- en: Moreover, keep in mind that, by default, regexes are case-sensitive. This is
    important when you're using more than one dialect (for instance, Oracle **identifiers**
    (**IDs**) are *UPPER_CASE*, in PostgreSQL, they are *lower_case*, and in SQL Server,
    they are *PascalCase*).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，默认情况下，正则表达式是区分大小写的。当你使用多个方言时，这一点很重要（例如，Oracle **标识符**（**IDs**）是 *UPPER_CASE*，在
    PostgreSQL 中，它们是 *lower_case*，而在 SQL Server 中，它们是 *PascalCase*）。
- en: Furthermore, matching any type is done via `<includeTypes>.*</includeTypes>`,
    while matching a certain type such as `NVARCHAR(4000)` is done via `NVARCHAR\(4000\)`,
    and a type such as `NUMBER(1, 0)` via `NUMBER\(1,\s*0\)`. A more verbose version
    of this example with detailed comments is available in the bundled code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，匹配任何类型是通过 `<includeTypes>.*</includeTypes>` 完成的，而匹配特定类型如 `NVARCHAR(4000)`
    是通过 `NVARCHAR\(4000\)` 完成的，而类型如 `NUMBER(1, 0)` 是通过 `NUMBER\(1,\s*0\)` 完成的。有关此示例的更详细注释的完整版本可在捆绑的代码中找到。
- en: 'This time, the `FIRST_BUY_DATE` field is not mapped to `java.lang.Integer`.
    If we check the generated table class that mirrors the `CUSTOMER` table (`jooq.generated.tables.Customer`),
    then we see the following declaration:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`FIRST_BUY_DATE` 字段没有映射到 `java.lang.Integer`。如果我们检查生成的与 `CUSTOMER` 表对应的表类（`jooq.generated.tables.Customer`），那么我们会看到以下声明：
- en: '[PRE120]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'So, `FIRST_BUY_DATE` is mapped to `YearMonth`, therefore our previous `INSERT`
    and `SELECT` statements will now look like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`FIRST_BUY_DATE` 映射到 `YearMonth`，因此我们之前的 `INSERT` 和 `SELECT` 语句现在看起来是这样的：
- en: '[PRE123]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'And the `SELECT` statement will then look like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`SELECT` 语句将看起来像这样：
- en: '[PRE127]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'jOOQ applies our converter automatically, so there''s no need to call it explicitly.
    It even works when we perform a coercing operation of `ResultQuery<R1>` to `ResultQuery<R2>`,
    like so:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 会自动应用我们的转换器，因此不需要显式调用它。它甚至在我们执行 `ResultQuery<R1>` 到 `ResultQuery<R2>` 的强制操作时也能工作，如下所示：
- en: '[PRE131]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: In other words, jOOQ uses our converter automatically for binding variables
    and for fetching data from `java.util.ResultSet`. In queries, we just treat `FIRST_BUY_DATE`
    as of type `YEARMONTH`. The code is named *YearMonthConverterForcedTypes* and
    is available for MySQL.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，jOOQ 会自动使用我们的转换器来绑定变量和从 `java.util.ResultSet` 中获取数据。在查询中，我们只需将 `FIRST_BUY_DATE`
    视为 `YEARMONTH` 类型。代码命名为 *YearMonthConverterForcedTypes* 并适用于 MySQL。
- en: Defining an inline converter via Converter.of() or Converter.ofNullable()
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 Converter.of() 或 Converter.ofNullable() 定义内联转换器
- en: 'In the previous section, our converter was written as a Java class, and we
    referenced that class in the configuration of the jOOQ Code Generator. But instead
    of writing this class, we can associate the custom data type with an *inline converter*,
    which is a converter written directly into the configuration. For this, we use
    the `<converter/>` tag, as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们的转换器被编写为一个 Java 类，并在 jOOQ 代码生成器的配置中引用了这个类。但我们可以将自定义数据类型与一个 *内联转换器*
    关联起来，这是一个直接写入配置的转换器。为此，我们使用 `<converter/>` 标签，如下所示：
- en: '[PRE135]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: The usage part of this converter remains unchanged. The complete code is named
    *InlineYearMonthConverter*, and the programmatic version is named *ProgrammaticInlineYearMonthConverter*.
    Both applications are available for MySQL.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个转换器的使用部分保持不变。完整的代码命名为 *InlineYearMonthConverter*，程序化版本命名为 *ProgrammaticInlineYearMonthConverter*。这两种应用都适用于
    MySQL。
- en: Defining an inline converter via lambda expressions
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 lambda 表达式定义内联转换器
- en: 'A more concise inline converter can be written via `<lambdaExpression/>`. This
    tag saves us from the explicit usage of `Converter.of()`/`Converter.ofNullable()`
    and allows us to simply specify a lambda expression that converts from the database
    type via the `<from/>` tag, and a lambda expression that converts to the database
    type via the `<to/>` tag. Let''s exemplify this in our converter, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `<lambdaExpression/>` 编写更简洁的内联转换器。这个标签使我们免去了显式使用 `Converter.of()`/`Converter.ofNullable()`
    的麻烦，并允许我们简单地指定一个通过 `<from/>` 标签从数据库类型转换的 lambda 表达式，以及一个通过 `<to/>` 标签转换到数据库类型的
    lambda 表达式。让我们在我们的转换器中举例说明，如下所示：
- en: '[PRE153]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Again, the usage part of this converter remains unchanged. The complete code
    is named *LambdaYearMonthConverter*, and the programmatic version is named *ProgrammaticLambdaYearMonthConverter*.
    Both applications are available for MySQL.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个转换器的使用部分保持不变。完整的代码命名为 *LambdaYearMonthConverter*，程序化版本命名为 *ProgrammaticLambdaYearMonthConverter*。这两种应用都适用于
    MySQL。
- en: Matching forced types via SQL
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 SQL 匹配强制类型
- en: 'In the previous sections, we matched the column names by using regexes in `<includeExpression/>`
    and `<includeTypes/>` tags. Whenever we need more complex criteria for matching
    column names, we can rely on the `<sql/>` tag. The body of this tag is an SQL
    query that executes against the dictionary views of our database. For instance,
    matching all columns of type `TIMESTAMP` from our MySQL `classicmodels` database
    can be achieved like so:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们通过 `<includeExpression/>` 和 `<includeTypes/>` 标签使用正则表达式匹配列名。每当我们需要更复杂的匹配列名的标准时，我们都可以依赖
    `<sql/>` 标签。这个标签的正文是一个针对我们数据库字典视图执行的 SQL 查询。例如，匹配来自我们的 MySQL `classicmodels` 数据库的所有
    `TIMESTAMP` 类型的列可以这样实现：
- en: '[PRE172]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'This should return several columns, among them being two from the `PAYMENT`
    table and one from the `BANK_TRANSACTION` table: `PAYMENT.PAYMENT_DATE`, `PAYMENT.CACHING_DATE`,
    and `BANK_TRANSACTION.CACHING_DATE`. For these columns, jOOQ will apply `Converter<LocalDateTime,
    JsonNode>` developed in the bundled code. But these are not the only columns returned
    by our query, and jOOQ will apply this converter to `PAYMENT.MODIFIED` and `TOKEN.UPDATED_ON`,
    which are also of type `TIMESTAMP`. Now, we have two options to avoid this—we
    can tune our query predicate accordingly or we can quickly add `<excludeExpression/>`,
    as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回几个列，其中包含来自 `PAYMENT` 表的两个列和来自 `BANK_TRANSACTION` 表的一个列：`PAYMENT.PAYMENT_DATE`、`PAYMENT.CACHING_DATE`
    和 `BANK_TRANSACTION.CACHING_DATE`。对于这些列，jOOQ 将应用在捆绑代码中开发的 `Converter<LocalDateTime,
    JsonNode>`。但我们的查询返回的不仅仅是这些列，jOOQ 还会将此转换器应用于 `PAYMENT.MODIFIED` 和 `TOKEN.UPDATED_ON`，它们也是
    `TIMESTAMP` 类型。现在，我们有两种避免这种情况的方法——我们可以相应地调整我们的查询谓词，或者我们可以快速添加 `<excludeExpression/>`，如下所示：
- en: '[PRE179]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: You can find the example for MySQL under the name *SqlMatchForcedTypes*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在名为 *SqlMatchForcedTypes* 的名称下找到 MySQL 的示例。
- en: I'm pretty sure that you got the idea, and you know how to write such queries
    for your favorite database.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我很确信你已经明白了这个概念，并且知道如何为你的数据库编写这样的查询。
- en: JSON converters
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON转换器
- en: Whenever jOOQ detects that the database uses `JSON` type), it maps the database
    type to the `org.jooq.JSON` class. This is a very handy class that represents
    a neat JSON wrapper type for JSON data fetched from the database. Its API consists
    of the `JSON.data()` method that returns a `String` representation of `org.jooq.JSON`
    and a `JSON.valueOf(String data)` method that returns `org.jooq.JSON` from the
    `String` representation. Typically, `org.jooq.JSON` is all you need, but if you
    want to manipulate the fetched JSON via dedicated APIs (Jackson, Gson, **JSON
    Binary** (**JSONB**), and so on), then you need a converter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当jOOQ检测到数据库使用`JSON`类型时，它将数据库类型映射到`org.jooq.JSON`类。这是一个非常方便的类，它代表了一个从数据库中获取的整洁JSON包装类型。它的API包括`JSON.data()`方法，该方法返回`org.jooq.JSON`的字符串表示形式，以及`JSON.valueOf(String
    data)`方法，该方法从字符串表示形式返回`org.jooq.JSON`。通常，`org.jooq.JSON`就是你所需要的，但如果你想要通过专用API（Jackson、Gson、**JSON
    Binary**（**JSONB**）等）来操作获取的JSON，那么你需要一个转换器。
- en: So, in order to practice more examples, the bundled code with this book comes
    with a JSON converter (`JsonConverter`), as explained in more detail next.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了练习更多示例，本书附带的自带代码包含一个JSON转换器（`JsonConverter`），如以下更详细地解释。
- en: For MySQL and PostgreSQL, which have the `JSON` data type. The converter converts
    between `org.jooq.JSON` and `com.fasterxml.jackson.databind.JsonNode`, therefore
    it implements `Converter<JSON, JsonNode>`. Of course, you can use this as an example,
    and replace Jackson's `JsonNode` with `com.google.gson.Gson`, `javax/jakarta.json.bind.Jsonb`,
    and so on. The code available for MySQL and PostgreSQL is named *JsonConverterForcedTypes*.
    A programmatic version of this application is available only for MySQL (but you
    can easily adapt it for any other dialect) and is named *ProgrammaticJsonConverter*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有`JSON`数据类型的MySQL和PostgreSQL，转换器在`org.jooq.JSON`和`com.fasterxml.jackson.databind.JsonNode`之间进行转换，因此它实现了`Converter<JSON,
    JsonNode>`接口。当然，你可以将Jackson的`JsonNode`替换为`com.google.gson.Gson`、`javax/jakarta.json.bind.Jsonb`等。MySQL和PostgreSQL可用的代码命名为*JsonConverterForcedTypes*。此应用程序的程序化版本仅适用于MySQL（但你很容易将其适应其他方言），并命名为*ProgrammaticJsonConverter*。
- en: For Oracle 18c, which doesn't have a dedicated JSON type (however, this type
    is available starting with Oracle 21c; see [https://oracle-base.com/articles/21c/json-data-type-21c](https://oracle-base.com/articles/21c/json-data-type-21c)),
    it's common to use `VARCHAR2(4000)` for relatively small JSON data and `BLOB`
    for large JSON data. In both cases, we can add a `CHECK ISJSON()` constraint to
    ensure the JSON data validity. Astonishingly, jOOQ detects that JSON data is present,
    and it maps such columns to the `org.jooq.JSON` type. Our converter converts between
    `org.jooq.JSON` and `com.fasterxml.jackson.databind.JsonNode`. Consider the applications
    named *ConverterJSONToJsonNodeForcedTypes*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Oracle 18c，它没有专门的JSON类型（然而，从Oracle 21c开始，这种类型是可用的；参见[https://oracle-base.com/articles/21c/json-data-type-21c](https://oracle-base.com/articles/21c/json-data-type-21c)），对于相对较小的JSON数据，通常使用`VARCHAR2(4000)`，而对于大型JSON数据，则使用`BLOB`。在这两种情况下，我们都可以添加一个`CHECK
    ISJSON()`约束来确保JSON数据的有效性。令人惊讶的是，jOOQ能够检测到JSON数据的存在，并将此类列映射到`org.jooq.JSON`类型。我们的转换器在`org.jooq.JSON`和`com.fasterxml.jackson.databind.JsonNode`之间进行转换。请考虑名为*ConverterJSONToJsonNodeForcedTypes*的应用程序。
- en: For SQL Server, which doesn't have a dedicated JSON type, it's common to use
    `NVARCHAR` with a `CHECK ISJSON()` constraint. jOOQ doesn't have support to detect
    the usage of JSON data (as in the case of Oracle) and maps this type to `String`.
    In this context, we have a converter in *JsonConverterVarcharToJSONForcedTypes*
    that converts between `NVARCHAR` and `org.jooq.JSON`, and one between `NVARCHAR`
    and `JsonNode` in *JsonConverterVarcharToJsonNodeForcedTypes*.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有专门JSON类型的SQL Server，通常使用带有`CHECK ISJSON()`约束的`NVARCHAR`。jOOQ没有检测JSON数据使用情况的支持（如Oracle的情况），并将此类型映射到`String`。在这种情况下，我们有一个名为*JsonConverterVarcharToJSONForcedTypes*的转换器，它在`NVARCHAR`和`org.jooq.JSON`之间进行转换，还有一个名为*JsonConverterVarcharToJsonNodeForcedTypes*的转换器，它在`NVARCHAR`和`JsonNode`之间进行转换。
- en: Take your time and practice these examples in order to get familiar with jOOQ
    converters. Next, let's tackle UDT converters.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请花时间练习这些示例，以便熟悉jOOQ转换器。接下来，让我们来处理UDT转换器。
- en: UDT converters
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDT转换器
- en: 'As you know from [*Chapter 3*](B16833_03.xhtml#_idTextAnchor040), *jOOQ Core
    Concepts*, Oracle and PostgreSQL support UDTs, and we have a UDT in our schema
    named `EVALUATION_CRITERIA`. This UDT is the data type of the `MANAGER.MANAGER_EVALUATION`
    field, and in Oracle, it looks like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从 [*第 3 章*](B16833_03.xhtml#_idTextAnchor040)，*jOOQ 核心概念* 中所知，Oracle 和 PostgreSQL
    支持用户定义类型（UDTs），并且在我们的模式中有一个名为 `EVALUATION_CRITERIA` 的 UDT。这个 UDT 是 `MANAGER.MANAGER_EVALUATION`
    字段的类型，在 Oracle 中看起来像这样：
- en: '[PRE183]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: We already know that the jOOQ Code Generator automatically maps the fields of
    the `evaluation_criteria` UDT via `jooq.generated.udt.EvaluationCriteria`, and
    the `jooq...pojos.EvaluationCriteria` `jooq...udt.EvaluationCriteria.EvaluationCriteriaRecord`
    record.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道 jOOQ 代码生成器自动通过 `jooq.generated.udt.EvaluationCriteria` 和 `jooq...pojos.EvaluationCriteria`
    `jooq...udt.EvaluationCriteria.EvaluationCriteriaRecord` 记录映射 `evaluation_criteria`
    UDT 的字段。
- en: 'But if we assume that our application needs to manipulate this type as JSON,
    then we need a converter that converts between `EvaluationCriteriaRecord` and
    JSON types (for instance, Jackson `JsonNode`). The `JsonConverter` stub looks
    like this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们假设我们的应用程序需要将此类型作为 JSON 进行操作，那么我们需要一个在 `EvaluationCriteriaRecord` 和 JSON
    类型（例如，Jackson `JsonNode`）之间进行转换的转换器。`JsonConverter` 模板如下所示：
- en: '[PRE190]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'Next, we configure this converter, as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们配置此转换器，如下所示：
- en: '[PRE198]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Having this set, we can express an `INSERT` statement, as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这个集合后，我们可以表达一个 `INSERT` 语句，如下所示：
- en: '[PRE208]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'And we can express a `SELECT` statement, as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以表达一个 `SELECT` 语句，如下所示：
- en: '[PRE213]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: The bundled code is named *ConverterUDTToJsonNodeForcedTypes* and is available
    for Oracle and PostgreSQL.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 包含的代码命名为 *ConverterUDTToJsonNodeForcedTypes*，适用于 Oracle 和 PostgreSQL。
- en: Custom data types and type binding
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义数据类型和类型绑定
- en: 'Roughly, when we want to map a type onto a non-standard JDBC type (a type that
    is not in `org.jooq.impl.SQLDataType`), we need to focus on the `org.jooq.Binding`
    API, as illustrated in the following code snippet:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 大概来说，当我们想要将一个类型映射到非标准的 JDBC 类型（一个不在 `org.jooq.impl.SQLDataType` 中的类型）时，我们需要关注
    `org.jooq.Binding` API，如下面的代码片段所示：
- en: '[PRE217]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'For instance, binding the non-standard vendor-specific PostgreSQL `HSTORE`
    data type to some Java data type (for instance, `HSTORE` can be mapped quite conveniently
    to Java `Map<String, String>`) needs to take advantage of the `Binding` API, which
    contains the following methods (please read the comments):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将非标准的特定供应商的 PostgreSQL `HSTORE` 数据类型绑定到某些 Java 数据类型（例如，`HSTORE` 可以非常方便地映射到
    Java 的 `Map<String, String>`）需要利用 `Binding` API，该 API 包含以下方法（请参阅注释）：
- en: '[PRE218]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'For instance, let''s consider that we already have an `org.jooq.Converter`
    implementation between `Map<String, String>` and `HSTORE` named `HstoreConverter`,
    and we continue by adding an `org.jooq.Binding` implementation named `HstoreBinding`
    that starts like this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑我们已经有一个在 `Map<String, String>` 和 `HSTORE` 之间名为 `HstoreConverter` 的 `org.jooq.Converter`
    实现，并且我们继续添加一个名为 `HstoreBinding` 的 `org.jooq.Binding` 实现，如下所示：
- en: '[PRE241]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'On the other hand, for a MySQL vendor-specific `POINT` type, we may have a
    converter named `PointConverter`, and we need a `PointBinding` class as follows—the
    `POINT` type maps well to the Java `Point2D.Double` type:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对于 MySQL 的特定供应商 `POINT` 类型，我们可能有一个名为 `PointConverter` 的转换器，并且需要一个如下所示的
    `PointBinding` 类——`POINT` 类型很好地映射到 Java 的 `Point2D.Double` 类型：
- en: '[PRE252]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'Next, we focus on implementing the `Binding` SPI for PostgreSQL `HSTORE` and
    MySQL `POINT`. An important aspect of this is rendering a bind variable for the
    binding context''s value and casting it to the `HSTORE` type. This is done in
    the `sql()` method, as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们专注于实现 PostgreSQL 的 `HSTORE` 和 MySQL 的 `POINT` 的 `Binding` SPI。这一过程的一个重要方面是将绑定上下文值转换为
    `HSTORE` 类型。这是在 `sql()` 方法中完成的，如下所示：
- en: '[PRE261]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'Notice that for the jOOQ inlined parameters (for details, check [*Chapter 3*](B16833_03.xhtml#_idTextAnchor040),
    *jOOQ Core Concepts*), we don''t need to render a placeholder (`?`); therefore,
    we render only the PostgreSQL specific syntax, `::hstore`. Depending on the database-specific
    syntax, you have to render the expected SQL. For instance, for the PostgreSQL
    `INET` data type, you''ll render `?::inet` (or, `::inet`), while for the MySQL
    `POINT` type, you''ll render `ST_PointFromText(?)` as follows (`Point2D` is `java.awt.geom.Point2D`):'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于 jOOQ 内联参数（详细信息请参阅 [*第 3 章*](B16833_03.xhtml#_idTextAnchor040)，*jOOQ 核心概念*），我们不需要渲染占位符（`?`）；因此，我们只渲染
    PostgreSQL 特定的语法，`::hstore`。根据数据库特定的语法，您必须渲染预期的 SQL。例如，对于 PostgreSQL 的 `INET`
    数据类型，您将渲染 `?::inet`（或，`::inet`），而对于 MySQL 的 `POINT` 类型，您将渲染 `ST_PointFromText(?)`
    如下所示（`Point2D` 是 `java.awt.geom.Point2D`）：
- en: '[PRE271]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: 'Next, we focus on registering a compatible/proper type for JDBC `CallableStatement`
    OUT parameters. Usually, `VARCHAR` is a proper choice (for instance, `VARCHAR`
    is a good choice for `HSTORE`, `INET`, or `JSON` types). The code is illustrated
    in the following snippet:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们关注为 JDBC `CallableStatement` 的 OUT 参数注册一个兼容的/合适的类型。通常，`VARCHAR` 是一个合适的选择（例如，对于
    `HSTORE`、`INET` 或 `JSON` 类型，`VARCHAR` 是一个好的选择）。下面的代码片段展示了代码：
- en: '[PRE282]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'But since by default MySQL returns a `POINT` as binary data (as long as we
    don''t use any MySQL function such as `ST_AsText(g)` or `ST_AsWKT(g)` for converting
    geometry values from an internal geometry format to a `java.sql.Blob`, as illustrated
    in the following code snippet:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，由于默认情况下 MySQL 以二进制数据形式返回 `POINT`（只要我们不使用任何 MySQL 函数，例如 `ST_AsText(g)` 或 `ST_AsWKT(g)`
    将几何值从内部几何格式转换为 `java.sql.Blob`，如下面的代码片段所示）：
- en: '[PRE288]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'Next, we convert `Map<String, String>` to a `String` value and set it on a
    JDBC `PreparedStatement` (for the MySQL `POINT` type, we convert `Point2D` to
    `String`), like so:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 `Map<String, String>` 转换为 `String` 值，并将其设置在 JDBC `PreparedStatement`
    上（对于 MySQL 的 `POINT` 类型，我们将 `Point2D` 转换为 `String`），如下所示：
- en: '[PRE294]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: 'Further, for PostgreSQL `HSTORE`, we get a `String` value from JDBC `ResultSet`
    and convert it to `Map<String, String>`, like so:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于 PostgreSQL 的 `HSTORE`，我们从 JDBC `ResultSet` 中获取一个 `String` 值，并将其转换为 `Map<String,
    String>`，如下所示：
- en: '[PRE300]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: 'While for MySQL `POINT`, we get a `Blob` (or an `InputStream`) from JDBC `ResultSet`
    and convert it to `Point2D`, like so:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理 MySQL 的 `POINT` 类型时，我们会从 JDBC `ResultSet` 中获取一个 `Blob`（或一个 `InputStream`），并将其转换为
    `Point2D`，如下所示：
- en: '[PRE306]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: 'Next, we do the same thing for JDBC `CallableStatement`. For the `HSTORE` type,
    we have the following:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们对 JDBC `CallableStatement` 做同样的事情。对于 `HSTORE` 类型，我们有以下内容：
- en: '[PRE312]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: 'And for the `POINT` type, we have this:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `POINT` 类型，我们有以下内容：
- en: '[PRE318]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: Finally, we override the `get(BindingGetSQLInputContext<?> bgsqlc)` and `set(BindingSetSQLOutputContext<?>
    bsqlc)` methods. Since, we don't need them for `HSTORE`/`POINT`, we just throw
    an `SQLFeatureNotSupportedException` exception. For brevity, we skipped this code.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们重写了 `get(BindingGetSQLInputContext<?> bgsqlc)` 和 `set(BindingSetSQLOutputContext<?>
    bsqlc)` 方法。由于我们不需要 `HSTORE`/`POINT`，我们只是抛出一个 `SQLFeatureNotSupportedException`
    异常。为了简洁，我们省略了这段代码。
- en: 'Once the `Binding` is ready, we have to configure it in the jOOQ Code Generator.
    This is quite similar to the configuration of a `Converter` only that, instead
    of using the `<converter/>` tag, we use the `<binding/>` tag as follows—here,
    we configure `HstoreBinding` (the configuration of `PointBinding` is available
    in the bundled code):'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `Binding` 准备就绪，我们必须在 jOOQ 代码生成器中对其进行配置。这相当类似于 `Converter` 的配置，只是我们使用 `<binding/>`
    标签而不是 `<converter/>` 标签，如下所示——在这里，我们配置 `HstoreBinding`（`PointBinding` 的配置可以在捆绑的代码中找到）：
- en: '[PRE324]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: 'Now, we can test `HstoreBinding`. For instance, the `PRODUCT` table has a field
    named `SPECS` of type `HSTORE`. The following code inserts a new product with
    some specifications:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试 `HstoreBinding`。例如，`PRODUCT` 表有一个名为 `SPECS` 的字段，其类型为 `HSTORE`。下面的代码插入了一个带有一些规格的新产品：
- en: '[PRE334]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: 'Here''s what the rendered SQL looks like:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是渲染后的 SQL 看起来的样子：
- en: '[PRE341]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: 'After resolving the `?` placeholders, the SQL looks like this:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决 `?` 占位符之后，SQL 看起来是这样的：
- en: '[PRE344]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: 'At `INSERT` (`UPDATE`, `DELETE`, and so on), `HstoreConverter` converts from
    Java `Map<String, String>` to an `HSTORE` type. At `SELECT`, the same converter
    converts `HSTORE` to `Map<String, String>`. So, our `SELECT` statement could look
    like this:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `INSERT`（`UPDATE`、`DELETE` 等等）时，`HstoreConverter` 将 Java `Map<String, String>`
    转换为 `HSTORE` 类型。在 `SELECT` 时，相同的转换器将 `HSTORE` 转换为 `Map<String, String>`。因此，我们的
    `SELECT` 语句可能看起来像这样：
- en: '[PRE350]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: Notice that we don't use explicitly any `Binding` or `Converter` and we don't
    *touch* the `HSTORE` type. For us, in the application, `SPECS` is of the type
    `Map<String, String>`.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有显式地使用任何 `Binding` 或 `Converter`，也没有**触及**`HSTORE` 类型。对我们来说，在应用程序中，`SPECS`
    的类型是 `Map<String, String>`。
- en: Notice that, starting with jOOQ 3.15, we have access to the *jOOQ-postgres-extensions*
    module ([https://github.com/jOOQ/jOOQ/issues/5507](https://github.com/jOOQ/jOOQ/issues/5507)),
    which supports `HSTORE` as well.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从 jOOQ 3.15 版本开始，我们可以访问 `jOOQ-postgres-extensions` 模块（[https://github.com/jOOQ/jOOQ/issues/5507](https://github.com/jOOQ/jOOQ/issues/5507)），它也支持
    `HSTORE`。
- en: 'Bindings and converters can be used to write different helper methods. For
    instance, the following method can be used to convert any `Param` to its database
    data type:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `Binding` 和 `Converter` 来编写不同的辅助方法。例如，以下方法可以用来将任何 `Param` 转换为其数据库数据类型：
- en: '[PRE354]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: But what's happening without `Binding`? Is everything lost?
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，没有 `Binding` 会发生什么？是不是一切都丢失了？
- en: Understanding what's happening without Binding
  id: totrans-471
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不使用 `Binding` 理解所发生的事情
- en: When jOOQ detects a non-standard JDBC type that doesn't have an associated `Binding`,
    it will mark the corresponding field with *@deprecated Unknown data type*, and
    with the message, *Please define an explicit {@link org.jooq.Binding} to specify
    how this type should be handled. Deprecation can be turned off using {@literal
    <deprecationOnUnknownTypes/>} in your Code Generator configuration.*
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 当jOOQ检测到一个没有关联`Binding`的非标准JDBC类型时，它将相应的字段标记为`@deprecated Unknown data type`，并附带消息，*请定义一个明确的{@link
    org.jooq.Binding}来指定如何处理此类型。可以通过在代码生成器配置中使用{@literal <deprecationOnUnknownTypes/>}来关闭弃用。*
- en: As a rule of thumb, relying on `Binding`s is the way to go, but as a workaround,
    we can also use explicit mapping for `SELECT` statements and `public static <T>
    Field<T> field(String sql, Class<T> type, Object... bindings)`, or another `field()`
    flavor that fits better, for `INSERT`, `UPDATE`, and so on.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 根据经验法则，依赖`Binding`是最佳做法，但作为权宜之计，我们也可以为`SELECT`语句和`public static <T> Field<T>
    field(String sql, Class<T> type, Object... bindings)`或更适合的`field()`变体使用显式映射，对于`INSERT`、`UPDATE`等。
- en: However, using a non-standard JDBC type in `INSERT` statements (`UPDATE` statements,
    and so on) just like that leads to jOOQ's `SQLDialectNotSupportedException` exception,
    *Type Foo is not supported in dialect Buzz, and in SELECT statements, to jOOQ's
    DataTypeException, No Converter found for types Foo and Buzz.*
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`INSERT`语句（`UPDATE`语句等）中使用这样的非标准JDBC类型会导致jOOQ的`SQLDialectNotSupportedException`异常，*类型Foo在方言Buzz中不受支持，并且在SELECT语句中，会导致jOOQ的`DataTypeException`，没有找到类型Foo和Buzz的转换器。*
- en: You can check the `HSTORE` examples from this section in the application named
    *HstoreBinding*, and the `POINT` examples in the application named *PointGeometryBinding*.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以检查名为*HstoreBinding*的应用程序中的此节中的`HSTORE`示例，以及名为*PointGeometryBinding*的应用程序中的`POINT`示例。
- en: In addition, the bundled code contains *InetBinding* for the PostgreSQL `INET`
    type, *JsonBinding* for the PostgreSQL `JSON` type, and *ProgrammaticInetBinding*
    representing the programmatic configuration of `Binding` for the PostgreSQL `INET`
    type. Next, let's discuss enums and how to convert these.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，捆绑的代码包含用于PostgreSQL `INET`类型的`InetBinding`，用于PostgreSQL `JSON`类型的`JsonBinding`，以及代表PostgreSQL
    `INET`类型`Binding`程序配置的`ProgrammaticInetBinding`。接下来，让我们讨论枚举以及如何转换这些枚举。
- en: Manipulating enums
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作枚举
- en: 'jOOQ represents an SQL enum type (for example, the MySQL `enum` or PostgreSQL
    `enum` data type created via `CREATE TYPE`) via an interface named `org.jooq.EnumType`.
    Whenever the jOOQ Java Code Generator detects the usage of an SQL enum type, it
    automatically generates a Java enum that implements `EnumType`. For instance,
    the MySQL schema of the `SALE` table contains the following `enum` data type:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ通过名为`org.jooq.EnumType`的接口表示SQL枚举类型（例如，通过`CREATE TYPE`创建的MySQL `enum`或PostgreSQL
    `enum`数据类型）。每当jOOQ Java代码生成器检测到SQL枚举类型的用法时，它会自动生成一个实现`EnumType`的Java枚举。例如，`SALE`表的MySQL模式包含以下`enum`数据类型：
- en: '[PRE357]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: 'For `vat`, the jOOQ generator renders the `jooq.generated.enums.VatType` enum,
    as follows:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`vat`，jOOQ生成器渲染了`jooq.generated.enums.VatType`枚举，如下所示：
- en: '[PRE358]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: 'By default, the name of such a class is composed of the table name and the
    column name in *PascalCase*, which means that the name of the preceding class
    should be `SaleVat`. But whenever we want to modify the default name, we can rely
    on jOOQ *generator strategies* and regexes, as we did in [*Chapter 2*](B16833_02.xhtml#_idTextAnchor024),
    *Customizing the jOOQ Level of Involvement*. For instance, we''ve customized the
    preceding class name as `VatType` via the following strategy:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此类名称由表名和列名以*PascalCase*形式组成，这意味着前一个类的名称应该是`SaleVat`。但每当我们要修改默认名称时，我们可以依靠jOOQ
    *生成策略*和正则表达式，就像我们在[*第2章*](B16833_02.xhtml#_idTextAnchor024)，*自定义jOOQ参与级别*中所做的那样。例如，我们已经通过以下策略将前一个类名称自定义为`VatType`：
- en: '[PRE384]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: 'Having these pieces of knowledge is enough to start writing queries based on
    jOOQ-generated enums—for instance, an `INSERT` statement into the `SALE` table
    and a `SELECT` statement from it, as illustrated in the following code snippet:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些知识就足以开始编写基于jOOQ生成枚举的查询了——例如，向`SALE`表插入的`INSERT`语句和从中选择的`SELECT`语句，如下面的代码片段所示：
- en: '[PRE397]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: Of course, the `Sale`-generated POJO (or user-defined POJOs) and `SaleRecord`
    take advantage of `VatType`, as with any other type.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`Sale`生成的POJO（或用户定义的POJO）和`SaleRecord`利用了`VatType`，就像任何其他类型一样。
- en: Writing enum converters
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写枚举转换器
- en: 'Whenever jOOQ-generated jOOQ enums are not enough, we focus on enum converters.
    Here is a non-exhaustive list of scenarios that may require some kind of enum
    converting to be done:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 当jOOQ生成的枚举不足以使用时，我们关注枚举转换器。以下是一些可能需要某种枚举转换的场景列表：
- en: Using your own Java enum for a database enum type
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自己的Java枚举作为数据库枚举类型
- en: Using your own Java enum for a database non-enum type (or enum-like type)
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自己的Java枚举作为数据库非枚举类型（或枚举类似类型）
- en: Using a Java non-enum type for a database enum
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java非枚举类型作为数据库枚举
- en: Always converting to a Java enum and occasionally to another Java enum
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是转换为Java枚举，偶尔转换为另一个Java枚举
- en: 'To simplify enum conversion tasks, jOOQ provides a built-in default converter
    named `org.jooq.impl.EnumConverter`. This converter can convert `VARCHAR` values
    to enum literals (and vice versa), or `NUMBER` values to enum ordinals (and vice
    versa). You can also instantiate it explicitly, as has been done here:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化枚举转换任务，jOOQ提供了一个内置的默认转换器，名为`org.jooq.impl.EnumConverter`。此转换器可以将`VARCHAR`值转换为枚举字面量（反之亦然），或将`NUMBER`值转换为枚举序号（反之亦然）。您也可以显式实例化它，如下所示：
- en: '[PRE405]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: Next, let's tackle the previous list of enum scenarios.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们解决之前列出的枚举场景。
- en: Using your own Java enum for a database enum type
  id: totrans-542
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用自己的Java枚举作为数据库枚举类型
- en: 'Of our four databases, only MySQL and PostgreSQL have dedicated types for enums.
    MySQL has the `enum` type and PostgreSQL has the `CREATE TYPE foo AS enum( ...)`
    syntax. In both cases, jOOQ generates enum classes on our behalf, but let''s suppose
    that we''d prefer to use our own Java enums. For instance, let''s focus on the
    MySQL schema of the `SALE` table, which contains these two enums:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的四个数据库中，只有MySQL和PostgreSQL有针对枚举的专用类型。MySQL有`enum`类型，PostgreSQL有`CREATE TYPE
    foo AS enum( ...)`语法。在这两种情况下，jOOQ都会为我们生成枚举类，但假设我们更愿意使用自己的Java枚举。例如，让我们关注`SALE`表的MySQL模式，其中包含这两个枚举：
- en: '[PRE408]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: 'The same enums in PostgreSQL are declared like this:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostgreSQL中，相同的枚举声明如下：
- en: '[PRE410]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: 'And let''s assume that for `vat`, we still rely on a jOOQ-generated Java enum-class
    (as in the previous section, `VatType`), while for `rate`, we have written the
    following Java enum:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 假设对于`vat`，我们仍然依赖于jOOQ生成的Java枚举类（如前文所述，`VatType`），而对于`rate`，我们已经编写了以下Java枚举：
- en: '[PRE415]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: 'In order to automatically map the `rate` column to the `RateType` enum, we
    rely on the `<forcedType/>` and `<enumConverter/>` flag tags, as illustrated here:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动将`rate`列映射到`RateType`枚举，我们依赖于`<forcedType/>`和`<enumConverter/>`标志标签，如下所示：
- en: '[PRE416]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: 'By enabling `<enumConverter/>`, we instruct jOOQ to automatically apply the
    built-in `org.jooq.impl.EnumConverter` converter whenever `SALE.RATE` is used.
    Done! From this point forward, we can treat the `SALE.RATE` field as of type `RateType`,
    and jOOQ will handle the conversion aspects of the mapped field (listed here for
    MySQL), as follows:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启用`<enumConverter/>`，我们指示jOOQ在`SALE.RATE`被使用时自动应用内置的`org.jooq.impl.EnumConverter`转换器。完成！从现在起，我们可以将`SALE.RATE`字段视为`RateType`类型，jOOQ将处理映射字段的转换方面（如下列MySQL所示），如下所示：
- en: '[PRE430]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: The application named *SimpleBuiltInEnumConverter* contains the complete example
    for MySQL and PostgreSQL.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为*SimpleBuiltInEnumConverter*的应用程序包含了MySQL和PostgreSQL的完整示例。
- en: This is a very convenient approach and works the same in MySQL and PostgreSQL,
    but if we don't employ this automatic conversion, we still can use our `RateType`
    Java enum manually or explicitly. Let's see how!
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常方便的方法，在MySQL和PostgreSQL中效果相同，但如果我们不使用这种自动转换，我们仍然可以使用我们的`RateType` Java枚举手动或显式地使用。让我们看看如何！
- en: 'First, we configure the jOOQ Code Generator to exclude enum generation for
    the `sale_rate` (MySQL)/`rate_type` (PostgreSQL) types; otherwise, the `SALE.RATE`
    field will be automatically mapped to the generated Java enum. The code is illustrated
    in the following snippet:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们配置jOOQ代码生成器以排除`sale_rate`（MySQL）/`rate_type`（PostgreSQL）类型的枚举生成；否则，`SALE.RATE`字段将自动映射到生成的Java枚举。代码如下所示：
- en: '[PRE434]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: 'In this context, jOOQ maps `SALE.RATE` to `String` in MySQL, and to `Object`
    in PostgreSQL. In PostgreSQL, the field is annotated as *@deprecated Unknown data
    type*, but we turn off this deprecation via the `<deprecationOnUnknownTypes/>`
    configuration, as follows:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，jOOQ将MySQL中的`SALE.RATE`映射为`String`，在PostgreSQL中映射为`Object`。在PostgreSQL中，该字段被注释为`@deprecated
    Unknown data type`，但我们通过`<deprecationOnUnknownTypes/>`配置关闭了这种弃用，如下所示：
- en: '[PRE439]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: 'Next, in MySQL, we can write an `INSERT` statement, as follows (`SALE.RATE`
    is of type `String`):'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在MySQL中，我们可以编写如下`INSERT`语句（`SALE.RATE`为`String`类型）：
- en: '[PRE442]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: 'And we can write a `SELECT` statement, as follows:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写如下`SELECT`语句：
- en: '[PRE445]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: 'While for MySQL this is quite smooth, for PostgreSQL it''s a little bit tricky.
    The PostgreSQL syntax requires us to render at `INSERT` something like `?::"public"."rate_type"`,
    as illustrated in the following code snippet:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MySQL来说，这相当顺畅，但对于PostgreSQL来说，则有点棘手。PostgreSQL的语法要求我们在`INSERT`时渲染类似`?::"public"."rate_type"`的内容，如下面的代码片段所示：
- en: '[PRE449]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: 'And at `SELECT`, we need an explicit coercing of `Object` to `String`, as illustrated
    in the following code snippet:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SELECT`时，我们需要将`Object`显式转换为`String`，如下面的代码片段所示：
- en: '[PRE453]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: The application named *MyEnumBuiltInEnumConverter* contains complete examples
    for MySQL and PostgreSQL. If we don't suppress the jOOQ enum generation, then
    another approach consists of writing an explicit converter (by extending the jOOQ
    built-in `org.jooq.impl.EnumConverter` converter) between the jOOQ generated enum
    and our enum. Of course, this converter must be called explicitly in your queries.
    You can find such an example for the `vat` enum in the application mentioned earlier.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序名为*MyEnumBuiltInEnumConverter*，其中包含MySQL和PostgreSQL的完整示例。如果我们不抑制jOOQ枚举生成，那么另一种方法是通过扩展jOOQ内置的`org.jooq.impl.EnumConverter`转换器，在jOOQ生成的枚举和我们的枚举之间编写一个显式的转换器。当然，这个转换器必须在你的查询中显式调用。你可以在前面提到的应用程序中找到`vat`枚举的此类示例。
- en: Using your own Java enum for a database non-enum type (or enum-like type)
  id: totrans-606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用您自己的Java枚举类型来表示数据库的非枚举类型（或类似枚举的类型）
- en: 'Let''s consider a legacy database containing a column that takes only certain
    values but was declared as `VARCHAR` (or `NUMBER`)—for instance, the `SALE` table
    has a `TREND` field of type `VARCHAR` that takes only the values *UP*, *DOWN*,
    and *CONSTANT*. In this context, it would be more practical to enforce the usage
    of this field via an enum, as shown here:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个包含只接受某些值的列的遗留数据库，但该列被声明为`VARCHAR`（或`NUMBER`）——例如，`SALE`表有一个`TREND`字段，其类型为`VARCHAR`，只接受*UP*、*DOWN*和*CONSTANT*的值。在这种情况下，通过枚举强制使用此字段会更实用，如下所示：
- en: '[PRE457]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: 'But now, we have to handle the conversion between `TrendType` and `VARCHAR`.
    This can be done automatically by jOOQ if we add the following `<forcedType/>`
    tag (here, for Oracle):'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，我们必须处理`TrendType`和`VARCHAR`之间的转换。如果我们添加以下`<forcedType/>`标签（这里针对Oracle），jOOQ可以自动完成此操作：
- en: '[PRE458]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: In the *SimpleBuiltInEnumConverter* application, you can see a complete example
    next to other examples for all four databases.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 在*SimpleBuiltInEnumConverter*应用程序中，你可以看到与其他四个数据库的示例并排的完整示例。
- en: 'Since SQL Server and Oracle don''t have an enum type, we have used an alternative.
    Among others, a common alternative relies on a `CHECK` constraint to obtain an
    enum-like behavior. These enum-like types can take advantage of `<enumConverter/>` exactly
    as shown previously. Here, it is the `SALE.VAT` field in Oracle:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SQL Server和Oracle没有枚举类型，我们使用了替代方案。其中之一是，一个常见的替代方案依赖于`CHECK`约束来实现类似枚举的行为。这些类似枚举的类型可以像之前展示的那样利用`<enumConverter/>`。这里，它是Oracle中的`SALE.VAT`字段：
- en: '[PRE466]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: 'And here, it is the `<forcedType/>` tag:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`<forcedType/>`标签：
- en: '[PRE468]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: 'If we don''t want to rely on automatic conversion, then we can use an explicit
    converter, as follows:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望依赖自动转换，那么我们可以使用一个显式的转换器，如下所示：
- en: '[PRE476]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: In the *BuiltInEnumConverter* application, you can find a complete example next
    to other examples for all four databases.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 在*BuiltInEnumConverter*应用程序中，你可以找到与其他四个数据库的示例并排的完整示例。
- en: Using a Java non-enum type for a database enum
  id: totrans-639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Java非枚举类型表示数据库枚举
- en: 'Sometimes, we need a non-enum type for a database enum. For instance, let''s
    assume that we want to use some integers in place of the `VatType` enum (*0* for
    *NONE*, *5* for *MIN*, and *19* for *MAX*) because we might need these integers
    in different computations. Maybe the best idea is to write a converter that starts
    like this:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要一个非枚举类型来表示数据库枚举。例如，假设我们想用一些整数代替`VatType`枚举（*0*代表*NONE*，*5*代表*MIN*，*19*代表*MAX*），因为我们可能在不同的计算中需要这些整数。也许最好的办法是编写一个像这样的转换器：
- en: '[PRE482]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: 'But this doesn''t work, because the `EnumConverter` signature is actually of
    type `EnumConverter<T,``U extends Enum<U>>`. Obviously, `Integer` doesn''t pass
    this signature since it doesn''t extend `java.lang.Enum`, hence we can rely on
    a regular converter (as you saw in the previous section), as illustrated here:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不起作用，因为`EnumConverter`的签名实际上是`EnumConverter<T, U extends Enum<U>>`类型。显然，`Integer`不满足这个签名，因为它没有扩展`java.lang.Enum`，因此我们可以依赖一个常规的转换器（正如你在上一节中看到的），如下所示：
- en: '[PRE484]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: The *BuiltInEnumConverter* application contains this example next to other examples.
    Of course, you can try to write this converter as an inline converter via `Converter.of()`/`ofNullable()`
    or lambda expressions as well.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '*BuiltInEnumConverter*应用包含此示例，以及其他示例。当然，您也可以尝试通过`Converter.of()`/`ofNullable()`或lambda表达式将此转换器作为内联转换器编写。'
- en: Always converting to a Java enum and occasionally to another Java enum
  id: totrans-647
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总是转换为Java枚举，偶尔也转换为另一个Java枚举
- en: Always converting to a Java enum and occasionally to another Java enum is most
    probably not such a popular task, but let's use it as a pretext to condense what
    we've learned so far about enum conversions.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 总是转换为Java枚举和偶尔转换为另一个Java枚举可能不是一项流行的任务，但让我们用它作为前提来总结我们迄今为止关于枚举转换所学到的东西。
- en: 'Let''s consider the well-known `SALE.RATE` enum field in MySQL. First, we want
    to always/automatically convert `SALE.RATE` to our `RateType` Java enum, shown
    here:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑MySQL中众所周知的`SALE.RATE`枚举字段。首先，我们希望始终/自动将`SALE.RATE`转换为我们的`RateType` Java枚举，如下所示：
- en: '[PRE486]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: 'For this, we write the following `<forcedType/>` tag:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 为了此目的，我们编写以下`<forcedType/>`标签：
- en: '[PRE487]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '[PRE488]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: 'So far, we can refer in queries to `SALE.RATE` as a `RateType` enum, but let''s
    assume that we also have the following `StarType` enum:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以在查询中引用`SALE.RATE`为`RateType`枚举，但让我们假设我们还有以下`StarType`枚举：
- en: '[PRE495]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: 'Basically, `StarType` is an alternative to `RateType` (*THREE_STARS* corresponds
    to *SILVER*, *FOUR_STARS* to *GOLD*, and *FIVE_STARS* to *PLATINUM*). Now, we
    may occasionally want to use `StarType` in queries instead of `RateType`, therefore
    we need a converter, as follows:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`StarType`是`RateType`的替代品（*THREE_STARS*对应于*SILVER*，*FOUR_STARS*对应于*GOLD*，*FIVE_STARS*对应于*PLATINUM*）。现在，我们可能偶尔想在查询中使用`StarType`而不是`RateType`，因此我们需要一个转换器，如下所示：
- en: '[PRE496]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '[PRE508]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[PRE512]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[PRE513]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[PRE514]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: Since `RateType` and `StarType` don't contain the same literals, we have to
    override the `to()` method and define the expected matches. Done!
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`RateType`和`StarType`不包含相同的字面量，我们必须重写`to()`方法并定义预期的匹配。完成！
- en: 'Expressing an `INSERT` statement that uses `RateType` looks like this:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`RateType`的`INSERT`语句表达如下：
- en: '[PRE515]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[PRE517]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: '[PRE518]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: 'And whenever we want to use `StarType` instead of `RateType`, we rely on the
    static `SALE_RATE_STAR_CONVERTER` converter, as shown here:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 并且每当我们要使用`StarType`而不是`RateType`时，我们就依赖于静态的`SALE_RATE_STAR_CONVERTER`转换器，如下所示：
- en: '[PRE519]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[PRE520]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '[PRE521]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: '[PRE523]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: The *BuiltInEnumConverter* application contains this example, along with other
    examples.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '*BuiltInEnumConverter*应用包含此示例，以及其他示例。'
- en: 'Via `classicmodels\.sale\.rate`, we nominated a certain column (`CLASSICMODELS.SALE.RATE`),
    but we may want to pick up all columns of this enum type. In such cases, an SQL
    query is more proper than a regex. Here is such a query for Oracle:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`classicmodels\.sale\.rate`，我们指定了一个特定的列（`CLASSICMODELS.SALE.RATE`），但我们可能希望获取此枚举类型的所有列。在这种情况下，SQL查询比正则表达式更合适。以下是一个Oracle的查询示例：
- en: '[PRE524]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: '[PRE525]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: '[PRE526]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: '[PRE527]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: '[PRE528]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '[PRE529]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: '[PRE530]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: '[PRE531]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '[PRE532]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: '[PRE533]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: '[PRE534]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: '[PRE535]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: You can find this example for MySQL and Oracle as *BuiltInEnumSqlConverter*.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在MySQL和Oracle中找到此示例，作为*BuiltInEnumSqlConverter*。
- en: In the bundled code, there are more applications, such as *EnumConverter*, which
    has examples of plain `org.jooq.Converter` types for enums; *EnumConverterForceTypes*,
    which has `<forcedType/>` and enum examples; and `I`*nsertEnumPlainSql*, which
    has `INSERT` and enum examples when the jOOQ Code Generator is not used.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，有更多应用，例如*EnumConverter*，它提供了枚举的`org.jooq.Converter`类型的示例；*EnumConverterForceTypes*，它包含`<forcedType/>`和枚举示例；以及`I`*nsertEnumPlainSql*，当不使用jOOQ代码生成器时，它包含`INSERT`和枚举示例。
- en: Retrieving the DataType<T> tag for a given enum data type
  id: totrans-710
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取给定枚举数据类型的`DataType<T>`标签
- en: 'Retrieving the `DataType<T>` tag for a given enum data type can be done as
    in the following three examples that speak for themselves:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 获取给定枚举数据类型的`DataType<T>`标签可以像以下三个自解释的示例那样完成：
- en: '[PRE536]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: '[PRE537]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: '[PRE538]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: '[PRE539]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: '[PRE540]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: '[PRE541]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: Now, you can use this data type as any other data type. Next, let's tackle the
    topic of data type rewrites.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用此数据类型作为任何其他数据类型。接下来，让我们讨论数据类型重写的话题。
- en: Data type rewrites
  id: totrans-719
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型重写
- en: Another utility of `<forcedTypes/>` is data type rewrites. This allows us to
    explicitly choose the SQL data type (supported by the database, or unsupported
    but present in `org.jooq.impl.SQLDataType`) that should be used in Java.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '`<forcedTypes/>`的另一个实用功能是数据类型重写。这允许我们显式选择在Java中应使用的SQL数据类型（由数据库支持，或不支持但在`org.jooq.impl.SQLDataType`中存在）。'
- en: 'For instance, in Oracle, a common use case is to map the missing `BOOLEAN`
    type as `NUMBER(1,0)` or `CHAR(1)`, as follows:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Oracle中，一个常见的用例是将缺失的`BOOLEAN`类型映射为`NUMBER(1,0)`或`CHAR(1)`，如下所示：
- en: '[PRE542]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: '[PRE543]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: '[PRE544]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: '[PRE545]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: '[PRE546]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '[PRE547]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: But this means that the jOOQ Code Generator will map fields of type `NUMBER(1,
    0)` to the `SQLDataType.TINYINT` SQL data type and the `java.lang.Byte` type and,
    respectively, the fields of type `CHAR(1)` to the `SQLDataType.CHAR` SQL data
    type and the `String` Java type.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 但这意味着jOOQ代码生成器将字段类型`NUMBER(1, 0)`映射到`SQLDataType.TINYINT` SQL数据类型和`java.lang.Byte`类型，并将类型为`CHAR(1)`的字段映射到`SQLDataType.CHAR`
    SQL数据类型和`String` Java类型。
- en: But the Java `String` type is commonly associated with text data manipulation,
    while the `Byte` type is commonly associated with binary data manipulations (for
    example, reading/writing a binary file) and the Java `Boolean` type clearly communicates
    the intention of using flag-type data. Moreover, the Java `Boolean` type has an
    SQL type (standard JDBC type) homologous to `SQLDataType.BOOLEAN`.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 但Java的`String`类型通常与文本数据处理相关联，而`Byte`类型通常与二进制数据处理相关联（例如，读取/写入二进制文件），Java的`Boolean`类型则清楚地表达了使用标志类型数据的意图。此外，Java的`Boolean`类型有一个与`SQLDataType.BOOLEAN`同源的SQL类型（标准JDBC类型）。
- en: 'jOOQ allows us to force the type of columns, therefore we can force the type
    of `SALE.HOT` to `BOOLEAN`, as follows:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ允许我们强制指定列的类型，因此我们可以强制将`SALE.HOT`的类型设置为`BOOLEAN`，如下所示：
- en: '[PRE548]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: '[PRE549]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: '[PRE550]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: '[PRE551]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: '[PRE552]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: '[PRE553]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: 'Done! Now, we can treat `SALE.HOT` as a Java `Boolean` type. Here is an `INSERT`
    example:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，我们可以将`SALE.HOT`视为Java `Boolean`类型。以下是一个`INSERT`示例：
- en: '[PRE554]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: '[PRE555]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: '[PRE556]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: 'Depending on `NUMBER` precision, jOOQ will map this data type to `BigInteger`,
    `Short`, or even `Byte` (as you just saw). If you find it cumbersome to use such
    Java types and you know that your data fits better for `Long` or `Integer` types,
    then you have two options: adjust the `NUMBER` precision accordingly, or rely
    on jOOQ type rewriting. Of course, you can apply this technique to any other type
    and dialect.'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`NUMBER`的精度，jOOQ将此数据类型映射到`BigInteger`、`Short`，甚至`Byte`（正如您刚才看到的）。如果您觉得使用此类Java类型很麻烦，并且知道您的数据更适合`Long`或`Integer`类型，那么您有两个选择：相应地调整`NUMBER`精度，或者依赖jOOQ类型重写。当然，您可以将此技术应用于任何其他类型和方言。
- en: A complete example can be found in *DataTypeRewriting*. The programmatic version
    of this example is called *ProgrammaticDataTypeRewriting*. Next, let's understand
    how you can handle jOOQ embeddable types.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的示例可以在*DataTypeRewriting*中找到。这个示例的程序版本被称为*ProgrammaticDataTypeRewriting*。接下来，让我们了解如何处理jOOQ的可嵌入类型。
- en: Handling embeddable types
  id: totrans-743
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理可嵌入类型
- en: Embeddable types represent a powerful feature introduced in jOOQ 3.14\. Roughly,
    this feature gets materialized in synthetic UDTs that can be used with all databases
    supported by jOOQ. While PostgreSQL and Oracle support UDTs (we can use UDTs directly
    in **Data Definition Language** (**DDL**)), other databases including MySQL and
    SQL Server don't support UDTs. But via jOOQ embeddable types, we can work at the
    application level with synthetic UDTs for any database, and jOOQ will take care
    of the underlying aspects of mapping these types to the database.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 可嵌入类型是jOOQ 3.14版本引入的一个强大功能。大致来说，这个功能通过合成UDT（用户定义类型）来实现，这些UDT可以与jOOQ支持的所有数据库一起使用。虽然PostgreSQL和Oracle支持UDT（我们可以在**数据定义语言**（**DDL**）中直接使用UDT），但包括MySQL和SQL
    Server在内的其他数据库不支持UDT。但是，通过jOOQ的可嵌入类型，我们可以在应用级别使用合成UDT与任何数据库一起工作，jOOQ将负责将这些类型映射到数据库的底层方面。
- en: 'An embeddable type mimics a UDT by synthetically wrapping one (usually more)
    database column in a generated `org.jooq.EmbeddableRecord`. For instance, we can
    wrap `OFFICE.CITY`, `OFFICE.STATE`, `OFFICE.COUNTRY`, `OFFICE.TERRITORY`, and
    `OFFICE.ADDRESS_LINE_FIRST` under an embeddable type named `OFFICE_FULL_ADDRESS`
    via the following configuration in the jOOQ Code Generator (here, for MySQL):'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 可嵌入类型通过在生成的`org.jooq.EmbeddableRecord`中合成地包装一个（通常是多个）数据库列来模拟UDT。例如，我们可以通过以下jOOQ代码生成器中的配置将`OFFICE.CITY`、`OFFICE.STATE`、`OFFICE.COUNTRY`、`OFFICE.TERRITORY`和`OFFICE.ADDRESS_LINE_FIRST`包装在名为`OFFICE_FULL_ADDRESS`的可嵌入类型下（这里针对MySQL）：
- en: '[PRE557]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: '[PRE558]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: '[PRE559]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: '[PRE560]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: '[PRE561]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: '[PRE562]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: '[PRE563]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: '[PRE564]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: '[PRE565]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: '[PRE566]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: '[PRE567]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: '[PRE568]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: '[PRE569]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: 'And we continue with the settings for matching tables and fields, as follows:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续设置匹配表和字段，如下所示：
- en: '[PRE570]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: '[PRE571]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: '[PRE572]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: '[PRE573]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: '[PRE574]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: '[PRE575]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: '[PRE576]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: '[PRE577]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: '[PRE578]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: '[PRE579]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: '[PRE580]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: '[PRE581]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '[PRE582]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: '[PRE583]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: '[PRE584]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: '[PRE585]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: '[PRE586]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: 'Next, jOOQ generates `jooq...records.OfficeFullAddressRecord`, which extends
    `EmbeddableRecordImpl` and `jooq...pojos.OfficeFullAddress`. Moreover, in the
    generated `Office` table, we observe a new `OFFICE_FULL_ADDRESS` field that can
    be used as in the following `INSERT` statement:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，jOOQ生成`jooq...records.OfficeFullAddressRecord`，它扩展了`EmbeddableRecordImpl`和`jooq...pojos.OfficeFullAddress`。此外，在生成的`Office`表中，我们观察到一个新的`OFFICE_FULL_ADDRESS`字段，它可以在以下`INSERT`语句中使用：
- en: '[PRE587]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: '[PRE588]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: '[PRE589]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: '[PRE590]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: '[PRE591]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: '[PRE592]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: '[PRE593]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: 'Obviously, the `OFFICE_FULL_ADDRESS` column can be used in all types of statements,
    including `INSERT`, `UPDATE`, `DELETE`, and `SELECT`. Here, it is used in a `SELECT`
    statement:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`OFFICE_FULL_ADDRESS`列可以在所有类型的语句中使用，包括`INSERT`、`UPDATE`、`DELETE`和`SELECT`。在这里，它被用在`SELECT`语句中：
- en: '[PRE594]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: '[PRE595]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: '[PRE596]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: 'Or it can be fetched into the `OfficeFullAddress` POJO, like this:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它也可以被检索到`OfficeFullAddress` POJO中，如下所示：
- en: '[PRE597]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: '[PRE598]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: '[PRE599]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: In the bundled code, for MySQL, we have *EmbeddableType*, which contains the
    previous example, and for PostgreSQL, we have *ProgrammaticEmbeddableType*, which
    is the programmatic version of the previous example.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，对于MySQL，我们有*EmbeddableType*，它包含前面的示例，而对于PostgreSQL，我们有*ProgrammaticEmbeddableType*，它是前面示例的程序化版本。
- en: Replacing fields
  id: totrans-794
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换字段
- en: At this point, we have access to (we can use) the embeddable type, but we still
    have direct access to fields wrapped in this embeddable type. For instance, these
    fields can be used in `INSERT` statements, `SELECT` statements, and so on, and
    they appear in the **Integrated Development Environment's** (**IDE's**) autocompletion
    list.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以访问（可以使用）可嵌入类型，但我们仍然可以直接访问这个可嵌入类型包装的字段。例如，这些字段可以用在`INSERT`语句、`SELECT`语句等中，并且它们出现在**集成开发环境**（**IDE**）的自动完成列表中。
- en: 'The *replacing fields* feature means to signal to jOOQ to disallow direct access
    to fields that are part of an embeddable type. These fields will not appear in
    the IDE''s autocompletion list anymore, and the result set of `SELECT` statements
    will not contain these fields. Enabling this feature can be done via the `<replacesFields/>`
    flag, as follows:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换字段*功能意味着向jOOQ发出信号，不允许直接访问可嵌入类型的一部分的字段。这些字段将不再出现在IDE的自动完成列表中，并且`SELECT`语句的结果集将不包含这些字段。可以通过`<replacesFields/>`标志启用此功能，如下所示：'
- en: '[PRE600]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: '[PRE601]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: '[PRE602]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: '[PRE603]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: The *EmbeddableTypeReplaceFields* application contains this example for Oracle,
    while *ProgrammaticEmbeddableTypeReplaceFields* contains a programmatic version
    of this example for SQL Server.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '*EmbeddableTypeReplaceFields*应用程序包含Oracle的此示例，而*ProgrammaticEmbeddableTypeReplaceFields*包含SQL
    Server的此示例的程序化版本。'
- en: Converting embeddable types
  id: totrans-802
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换可嵌入类型
- en: 'Converting an embeddable type can be done via `org.jooq.Converter`, as for
    any other type. For example, converting between `JsonNode` and `OFFICE_FULL_ADDRESS`
    can be done via a `Converter` that starts like this:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 转换可嵌入类型可以通过`org.jooq.Converter`完成，就像对任何其他类型一样。例如，在`JsonNode`和`OFFICE_FULL_ADDRESS`之间进行转换可以通过一个以如下方式开始的`Converter`完成：
- en: '[PRE604]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: '[PRE605]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: '[PRE606]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: '[PRE607]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: '[PRE608]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: '[PRE609]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: '[PRE610]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: '[PRE611]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: '[PRE612]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: '[PRE613]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: 'And here, it is a `SELECT` statement that fetches `OFFICE.OFFICE_FULL_ADDRESS`
    as `JsonNode` via `JSON_CONVERTER`:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这是一个`SELECT`语句，通过`JSON_CONVERTER`获取`OFFICE.OFFICE_FULL_ADDRESS`作为`JsonNode`：
- en: '[PRE614]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: '[PRE615]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: '[PRE616]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: The *ConvertEmbeddableType* application for MySQL contains this example.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '*ConvertEmbeddableType*应用程序包含MySQL的此示例。'
- en: Embedded domains
  id: totrans-819
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌入式域
- en: 'Quite popular in PostgreSQL, *domain* types represent UDTs built on top of
    other types and containing optional constraints. For instance, in our PostgreSQL
    schema, we have the following domain:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostgreSQL中非常流行，*域*类型是在其他类型之上构建的UDT，并包含可选约束。例如，在我们的PostgreSQL模式中，我们有以下域：
- en: '[PRE617]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: '[PRE618]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: '[PRE619]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: '[PRE620]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: '[PRE621]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: 'And it is used in the `office` table, as shown here:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 它在`office`表中使用，如下所示：
- en: '[PRE622]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: '[PRE623]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: '[PRE624]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: '[PRE625]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: '[PRE626]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: 'jOOQ can generate a Java type for each domain type if we turn on this feature,
    as has been done here:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启用此功能，jOOQ可以为每个域类型生成一个Java类型，如下所示：
- en: '[PRE627]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: '[PRE628]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: '[PRE629]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: '[PRE630]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: '[PRE631]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: '[PRE632]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: '[PRE633]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: '[PRE634]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: '[PRE635]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: '[PRE636]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: '[PRE637]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: While `.*` matches all domain types, you can use more restrictive regexes to
    match exactly the domains that will be replaced by embeddable types.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`.*`匹配所有域类型，但你可以使用更严格的正则表达式来精确匹配将被可嵌入类型替换的域。
- en: 'The jOOQ Code Generator generates an embeddable type named (by default) `PostalCodeRecord`
    (in `jooq.generated.embeddables.records`). We can use it for creating semantically
    type-safe queries, as in these examples:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ代码生成器生成一个默认名为`PostalCodeRecord`（在`jooq.generated.embeddables.records`中）的可嵌入类型。我们可以用它来创建语义上类型安全的查询，如下例所示：
- en: '[PRE638]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: '[PRE639]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: '[PRE640]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: '[PRE641]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: '[PRE642]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: '[PRE643]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: '[PRE644]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: '[PRE645]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: '[PRE646]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: The complete code for PostgreSQL is named *Domain*.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL的完整代码命名为*Domain*。
- en: Well, we've reached the end of this section and the end of this chapter. Notice
    that we intentionally skipped the topic of embeddable types and embeddable keys
    (including composite keys) since this topic is covered later in [*Chapter 11*](B16833_11.xhtml#_idTextAnchor209),
    *jOOQ Keys*.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们已经到达了本节的结尾和本章的结尾。请注意，我们故意跳过了可嵌入类型和可嵌入键（包括复合键）的主题，因为这个主题将在[*第11章*](B16833_11.xhtml#_idTextAnchor209)，*jOOQ键*中稍后讨论。
- en: Summary
  id: totrans-857
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter is a must-have in your jOOQ arsenal. Mastering the topics covered
    here—such as custom data types, converters, bindings, database vendor-specific
    data types, enums, embeddable types, and so on—will help you to shape the interaction
    between Java and database data types to fit your non-trivial scenarios. In the
    next chapter, we cover the topics of fetching and mapping.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是你在 jOOQ 工具箱中不可或缺的一部分。掌握这里涵盖的主题——例如自定义数据类型、转换器、绑定、数据库厂商特定的数据类型、枚举、可嵌入类型等——将帮助你调整
    Java 和数据库数据类型之间的交互，以适应你的复杂场景。在下一章中，我们将介绍数据检索和映射的主题。
