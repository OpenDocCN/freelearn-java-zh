- en: Unification
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一
- en: 'Being able to understand and write good code in Scala requires developers to
    be familiar with the different concepts of the language. In a few places so far,
    we have mentioned that Scala is really expressive. To some extent, this is because
    there are a number of programming concepts that have been unified. In this chapter,
    we will focus on the following concepts:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 能够理解和编写良好的Scala代码要求开发者熟悉该语言的不同概念。到目前为止，我们在几个地方提到Scala确实具有很强的表达能力。在一定程度上，这是因为有多个编程概念被统一了。在本章中，我们将重点关注以下概念：
- en: Functions and classes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和类
- en: Algebraic data types and class hierarchies
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代数数据类型和类层次结构
- en: Modules and objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块和对象
- en: Functions and classes
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和类
- en: In Scala, every value is an object. Functions are first-class values, which
    also makes them objects of their respective classes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，每个值都是一个对象。函数是一等值，这也使它们成为各自类的对象。
- en: 'The following diagram shows the Scala unified type system and how this is achieved.
    It is adapted from [http://www.scala-lang.org/old/sites/default/files/images/classhierarchy.png](http://www.scala-lang.org/old/sites/default/files/images/classhierarchy.png)
    and represents an up-to-date view of the model (some classes such as `ScalaObject`
    have disappeared, as we have already mentioned earlier):'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了Scala统一类型系统及其实现方式。它改编自[http://www.scala-lang.org/old/sites/default/files/images/classhierarchy.png](http://www.scala-lang.org/old/sites/default/files/images/classhierarchy.png)，并代表了对该模型（一些类如`ScalaObject`已经消失，如我们之前提到的）的最新看法：
- en: '![](img/f035b5ee-e98b-4ffa-ae47-5b3db49ddcc2.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f035b5ee-e98b-4ffa-ae47-5b3db49ddcc2.png)'
- en: As you can see, Scala does not have the same concept of primitive types that
    Java has, and all types are ultimately subtypes of **Any**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Scala没有Java那样的原始类型概念，所有类型最终都是**Any**的子类型。
- en: Functions as classes
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为类的函数
- en: The fact that functions are classes means that they can be freely passed to
    other methods or classes as if they were just values. This leads to improving
    the expressiveness of Scala and making it much easier to achieve things, such
    as callbacks, than in other languages such as Java.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数作为类的事实意味着它们可以像值一样自由地传递给其他方法或类。这提高了Scala的表达能力，并使其比其他语言（如Java）更容易实现回调等功能。
- en: Function literals
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数字面量
- en: 'Let''s have a look at an example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we can see how the sum field of the `FunctionLiterals` class is actually
    assigned a function. We can assign any function to a variable and then call it
    as if it was a function (essentially invoking its `apply` method). Functions can
    also be passed as parameters to other methods. Let''s add the following to our
    `FunctionLiterals` class:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`FunctionLiterals`类的求和字段实际上被分配了一个函数。我们可以将任何函数分配给一个变量，然后像调用函数一样调用它（本质上是在对象名称或实例后使用括号调用其`apply`方法）。函数也可以作为参数传递给其他方法。让我们向我们的`FunctionLiterals`类添加以下内容：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can then pass the required function to `runOperation`, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将所需的函数传递给`runOperation`，如下所示：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Functions without syntactic sugar
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无语法糖的函数
- en: 'In the preceding example, we just used syntactic sugar. In order to understand
    exactly what happens, we will show you what the function literals are converted
    into. They basically represent extensions to the `FunctionN` trait, where `N`
    is the number of parameters. The implementations of the literals are invoked using
    the `apply` method (whenever a class or an object has an `apply` method, it can
    be implicitly invoked just using parentheses after the object name or instance
    and passing the required parameters, if any). Let''s see the equivalent implementation
    to our previous example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们只是使用了语法糖。为了确切了解发生了什么，我们将向您展示函数字面量被转换成了什么。它们基本上是`FunctionN`特质的扩展，其中`N`是参数的数量。字面量的实现是通过`apply`方法调用的（每当一个类或对象有`apply`方法时，它可以通过在对象名称或实例后使用括号并传递所需的参数（如果有）来隐式调用）。让我们看看与我们之前示例等效的实现：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Increased expressivity
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强表达能力
- en: As you can see from the examples, unifying classes and functions leads to increased
    expressivity and we can easily achieve various things such as callbacks, lazy
    parameter evaluation, centralized exception handling, and others, and without
    writing extra code and logic. Moreover, functions as classes mean that we can
    extend them to provide extra functionality.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如从示例中可以看出，统一类和函数导致表达能力增强，我们可以轻松实现回调、延迟参数评估、集中异常处理等功能，而无需编写额外的代码和逻辑。此外，函数作为类意味着我们可以扩展它们以提供额外功能。
- en: Algebraic data types and class hierarchies
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代数数据类型和类层次结构
- en: '**Algebraic data types** (**ADTs**) and class hierarchies are other unifications
    in the Scala programming language. In other functional languages, there are special
    ways to create custom algebraic data types. In Scala, this is achieved using class
    hierarchies and namely *case classes* and *objects*. Let''s see what an ADT actually
    is, what types there are, and how to define them.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**代数数据类型**（**ADTs**）和类层次结构是 Scala 编程语言中的其他统一方式。在其他函数式语言中，有特殊的方法来创建自定义的代数数据类型。在
    Scala 中，这是通过类层次结构以及所谓的 *案例类* 和 *对象* 来实现的。让我们看看 ADT 实际上是什么，有哪些类型，以及如何定义它们。'
- en: ADTs
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ADTs
- en: Algebraic data types are just composite types that combine other existing types
    or just represent some new ones. They only have data and do not contain any functionality
    on top of this data as normal classes would. Some examples can include the day
    of the week or a class that represents an RGB color—they have no extra functionality
    and they just carry information. The following few subsections will give a bit
    more insight on what ADTs are and what types are out there.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代数数据类型只是组合类型，它们结合了其他现有类型或仅仅代表一些新的类型。它们只包含数据，并且不包含任何在数据之上作为正常类会包含的功能。一些例子可以包括一周中的某一天或表示
    RGB 颜色的类——它们没有额外的功能，只是携带信息。接下来的几个小节将更深入地探讨 ADT 是什么以及有哪些类型。
- en: Sum ADTs
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 求和 ADTs
- en: 'Sum algebraic data types are the ones in which we can simply enumerate all
    the possible values of a type and provide a separate constructor for each value.
    As an example, let''s consider the months of the year. There are only 12 and they
    cannot change (hopefully):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 求和代数数据类型是我们可以在其中简单地列出类型的所有可能值并为每个值提供一个单独构造函数的类型。作为一个例子，让我们考虑一年中的月份。它们只有 12 个，而且它们不会改变（希望如此）：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Running this application will produce the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此应用程序将产生以下输出：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Month` trait in the preceding code is sealed because we do not want it
    to be extended outside the current file. As you can see, we've defined the different
    months as objects, as there is no reason for them to be separate instances. The
    values are what they are and they do not change.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中的 `Month` 特质是密封的，因为我们不希望它在当前文件之外被扩展。正如你所见，我们将不同的月份定义为对象，因为没有理由让它们成为单独的实例。值就是它们的样子，它们不会改变。
- en: Product ADTs
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品 ADTs
- en: In product algebraic data types, we cannot enumerate all the possible values.
    There are usually too many to manually write them. We cannot provide a separate
    constructor for each separate value.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在积代数数据类型中，我们无法列出所有可能的值。通常值太多，无法手动编写。我们无法为每个单独的值提供一个单独的构造函数。
- en: 'Let''s think about colors. There are different color models, but one of the
    most famous ones is RGB. It combines the different values of the main colors (red,
    green, and blue) in order to represent other colors. If we say that each of these
    colors can have a value between `0` and `255`, this would mean that to represent
    all possibilities, we would need to have 256³ different constructors. That''s
    why we can use a product ADT:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下颜色。有不同颜色模型，但其中最著名的一个是 RGB。它结合了主要颜色（红色、绿色和蓝色）的不同值来表示其他颜色。如果我们说每种颜色都可以在
    `0` 到 `255` 之间取值，这意味着要表示所有可能性，我们需要有 256³ 个不同的构造函数。这就是为什么我们可以使用积 ADT：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we can see that for the product ADTs, we have one constructor for different
    values.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到对于积 ADTs，我们有一个构造函数用于不同的值。
- en: Hybrid ADTs
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合 ADTs
- en: Hybrid algebraic data types represent a combination of the sum and product ones
    we described previously. This means that we can have specific value constructors,
    but these value constructors also provide parameters in order to wrap other types.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 混合代数数据类型代表了我们之前描述的求和和积的混合。这意味着我们可以有特定的值构造函数，但这些值构造函数也提供了参数来封装其他类型。
- en: 'Let''s see an example. Imagine we are writing a drawing application:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。想象我们正在编写一个绘图应用程序：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have different shapes. The preceding example shows a sum ADT because we have
    the specific `Circle` and `Rectangle` value constructors. Also, we have a product
    ADT because the constructors take extra parameters.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有不同的形状。前面的例子显示了一个求和 ADT，因为我们有特定的 `Circle` 和 `Rectangle` 值构造函数。此外，我们还有一个积 ADT，因为构造函数接受额外的参数。
- en: 'Let''s expand our classes a bit. When drawing our shapes, we need to know their
    positions. This is why we can add a `Point` class that holds the `x` and `y` coordinates:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微扩展一下我们的类。当我们绘制形状时，我们需要知道它们的位置。这就是为什么我们可以添加一个 `Point` 类来持有 `x` 和 `y` 坐标：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This should hopefully clarify what ADTs are in Scala and how they can be used.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这能清楚地说明在Scala中ADT（抽象数据类型）是什么以及它们如何被使用。
- en: The unification
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一
- en: After all of the preceding examples, it is obvious that class hierarchies and
    ADTs are unified and look like the same thing. This adds a high level of flexibility
    in the language and makes modeling easier than in other functional programming
    languages.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前面的例子之后，很明显，类层次和ADT是统一的，看起来像是同一件事。这为语言增加了高度的灵活性，使得建模比其他函数式编程语言更容易。
- en: Pattern matching
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Pattern matching is often used with ADTs. It makes the code much clearer and
    more readable as well as easier to extend in comparison to using the `if…else`
    statements when trying to do something with ADTs based on their values. As you
    could imagine, these statements can get quite cumbersome in some cases, especially
    when there are many different possible values for a certain data type. In some
    cases, pattern matching can be used the same way as *enums* and the `switch` statement
    is used in Java.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配通常与ADT一起使用。与使用`if…else`语句相比，它使代码更加清晰、易读，并且更容易扩展。正如你所想象的那样，在某些情况下，这些语句可能会变得相当繁琐，特别是当某个数据类型有多个可能的值时。在某些情况下，模式匹配可以像*枚举*一样使用，就像Java中的`switch`语句一样。
- en: Pattern matching with values
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值的模式匹配
- en: 'In the month''s example stated previously, we just have the month names. We
    might, however, want to also get their number, as the computer will not know this
    otherwise. Here is how to do this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前提到的月份示例中，我们只有月份名称。然而，我们可能还想获取它们的数字，因为否则计算机将不知道这一点。以下是这样做的方法：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can see how we match the different values, and based on them, we return
    the correct values. Here is how this method can be used now:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们如何匹配不同的值，并根据它们返回正确的值。以下是现在如何使用这个方法：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As expected, our application will produce the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们的应用程序将产生以下内容：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The fact that we have specified our base trait to be sealed guarantees that
    nobody else will extend it outside our code, and we will be able to have an exhaustive
    pattern match. Unexhaustive pattern matches are problematic. Just as an experiment,
    if we try to comment out the match rule for February and we compile, we will see
    the following warning:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定我们的基本特质为密封的，这保证了没有人会在我们的代码之外扩展它，我们将能够进行详尽的模式匹配。不详尽的模式匹配是有问题的。作为一个实验，如果我们尝试注释掉二月匹配规则并编译，我们将看到以下警告：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running the example this way proves that the warning is true and our code has
    failed when we use `February` as a parameter. For the sake of completeness, we
    can add a default case:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式运行示例证明了这个警告是真实的，当我们使用`February`作为参数时，我们的代码失败了。为了完整性，我们可以添加一个默认情况：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The examples shown in this subsection are what one can use in Scala, in order
    to achieve the functionality of *enums* in Java.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节中展示的例子是可以在Scala中使用，以实现Java中*枚举*的功能性。
- en: Pattern matching for product ADTs
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品ADT的模式匹配
- en: 'Pattern matching shows its real power when used for product and hybrid ADTs.
    In such cases, we can match the actual values of the data types. Let''s see how
    we would implement a functionality to calculate the area of a shape, as defined
    previously:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于产品和混合ADT时，模式匹配展示了它的真正力量。在这种情况下，我们可以匹配数据类型的实际值。让我们看看我们如何实现一个计算形状面积的功能，如之前定义的那样：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When matching, we can ignore values we don''t care about. For the area, we
    don''t really need the position information. In the preceding code, we just showed
    two different ways in which a matching is possible. The `_` operator can be anywhere
    in the match statement, and it will just ignore the value it is put for. After
    this, using our example is straightforward:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在匹配时，我们可以忽略我们不关心的值。对于面积，我们实际上并不需要位置信息。在前面的代码中，我们只展示了两种可能的匹配方式。`_`运算符可以在匹配语句中的任何位置，它将忽略它被放置的值。之后，使用我们的示例就很简单了：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will have an output similar to the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似于以下内容的输出：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can even put constants instead of variables for the ADT constructor parameters
    during pattern matching. This makes the language quite powerful and allows us
    to achieve even more complex logic, which will still look quite nice. You can
    try experimenting with the preceding examples in order to get an idea of how pattern
    matching actually works.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在模式匹配期间用常量代替ADT构造函数参数中的变量。这使得语言非常强大，并允许我们实现更复杂的逻辑，同时看起来仍然相当不错。你可以尝试使用前面的例子来了解模式匹配实际上是如何工作的。
- en: Pattern matching is often used with ADTs and it helps to achieve clean, extendible,
    and exhaustive code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配通常与ADT一起使用，有助于实现干净、可扩展和详尽的代码。
- en: Modules and objects
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和对象
- en: Modules are a way to organize programs. They are interchangeable and pluggable
    pieces of code that have well-defined interfaces and hidden implementations. In
    Java, modules are organized in packages. In Scala, modules are objects, just like
    everything else. This means that they can be parameterized, extended, and passed
    as parameters, and so on.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是组织程序的一种方式。它们是可互换的、可插入的代码片段，具有定义良好的接口和隐藏的实现。在Java中，模块组织在包中。在Scala中，模块就像其他一切一样是对象。这意味着它们可以被参数化、扩展，并且可以作为参数传递，等等。
- en: Scala modules can provide requirements in order to be used.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Scala模块可以提供要求以便被使用。
- en: Using modules
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块
- en: 'We already established that modules and objects are also unified in Scala.
    This means that we can pass an entire module around our application. It would
    be useful, however, to show what a module actually looks like. Here is an example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定在Scala中模块和对象也是统一的。这意味着我们可以将整个模块传递到我们的应用程序中。然而，展示模块的实际外观将是有用的。以下是一个示例：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, `Tick` is just an interface to one of our modules. The following is its
    implementation:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Tick`只是我们模块的一个接口。以下是其实现：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `TickUser` trait is an actual module. It implements `Tick` and contains
    the code hidden inside it. We create a singleton object that will carry the implementation.
    Note how the name in the object is the same as the method in `Tick`. This would
    cover the need to implement it when mixing in the trait.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`TickUser`特质实际上是一个模块。它实现了`Tick`并包含其内部的代码。我们创建了一个单例对象，它将携带实现。注意对象中的名称与`Tick`中的方法名称相同。这满足了在混入特质时实现它的需求。'
- en: 'Similarly, we can define another interface and an implementation as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以定义另一个接口及其实现如下：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The implementation will be the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 实现将如下所示：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'What is interesting here is that we extended both modules in the `AlarmUser`
    one. This shows how modules could be made to be dependent on each other. Finally,
    we can use our modules as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是，我们在`AlarmUser`中扩展了两个模块。这展示了模块如何相互依赖。最后，我们可以如下使用我们的模块：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In order for `ModuleDemo` to use the `AlarmUser` module, it is also required
    by the compiler to mix in `TickUser` or any module that mixes in `Tick`. This
    provides a possibility to plug in a different functionality.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让`ModuleDemo`使用`AlarmUser`模块，编译器还要求混入`TickUser`或任何混入`Tick`的模块。这提供了插入不同功能的可能性。
- en: 'The output of the program will be as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出将如下所示：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Modules in Scala can be passed as any other object. They are extendable, interchangeable,
    and their implementation is hidden.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Scala中的模块可以像其他任何对象一样传递。它们是可扩展的、可互换的，并且它们的实现是隐藏的。
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused on unification. We saw how there is a unification
    between functions and classes, ADTs, class hierarchies, as well as modules and
    objects. This allows us to be much more expressive and write cleaner and more
    efficient code. We also covered what pattern matching is and how it can be used
    in Scala to write good code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于统一。我们看到了函数和类、ADT、类层次结构以及模块和对象之间的统一。这使我们能够更加表达性，编写更干净、更高效的代码。我们还介绍了模式匹配是什么以及如何在Scala中使用它来编写良好的代码。
- en: Some of the concepts covered in this chapter will be useful in the following
    chapters where we will be implementing concrete design patterns. They can also
    be used to write good software outside the defined design patterns just because
    the expressivity of Scala allows it, and this defies the need to do the extra
    work that design patterns add.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中涉及的一些概念将在后续章节中非常有用，在这些章节中我们将实现具体的设计模式。仅仅因为Scala的表达能力允许这样做，它们也可以用来编写符合定义的设计模式的良好软件，而这违背了需要做额外工作来实现设计模式的需求。
- en: In the next chapter, we will look at **abstract** and **self-types** and what
    they can be useful for.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨**抽象**和**自类型**以及它们可能有什么用。
