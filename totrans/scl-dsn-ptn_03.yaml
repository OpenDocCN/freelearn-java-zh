- en: Unification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Being able to understand and write good code in Scala requires developers to
    be familiar with the different concepts of the language. In a few places so far,
    we have mentioned that Scala is really expressive. To some extent, this is because
    there are a number of programming concepts that have been unified. In this chapter,
    we will focus on the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions and classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Algebraic data types and class hierarchies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules and objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions and classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Scala, every value is an object. Functions are first-class values, which
    also makes them objects of their respective classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the Scala unified type system and how this is achieved.
    It is adapted from [http://www.scala-lang.org/old/sites/default/files/images/classhierarchy.png](http://www.scala-lang.org/old/sites/default/files/images/classhierarchy.png)
    and represents an up-to-date view of the model (some classes such as `ScalaObject`
    have disappeared, as we have already mentioned earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f035b5ee-e98b-4ffa-ae47-5b3db49ddcc2.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, Scala does not have the same concept of primitive types that
    Java has, and all types are ultimately subtypes of **Any**.
  prefs: []
  type: TYPE_NORMAL
- en: Functions as classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fact that functions are classes means that they can be freely passed to
    other methods or classes as if they were just values. This leads to improving
    the expressiveness of Scala and making it much easier to achieve things, such
    as callbacks, than in other languages such as Java.
  prefs: []
  type: TYPE_NORMAL
- en: Function literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see how the sum field of the `FunctionLiterals` class is actually
    assigned a function. We can assign any function to a variable and then call it
    as if it was a function (essentially invoking its `apply` method). Functions can
    also be passed as parameters to other methods. Let''s add the following to our
    `FunctionLiterals` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then pass the required function to `runOperation`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Functions without syntactic sugar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding example, we just used syntactic sugar. In order to understand
    exactly what happens, we will show you what the function literals are converted
    into. They basically represent extensions to the `FunctionN` trait, where `N`
    is the number of parameters. The implementations of the literals are invoked using
    the `apply` method (whenever a class or an object has an `apply` method, it can
    be implicitly invoked just using parentheses after the object name or instance
    and passing the required parameters, if any). Let''s see the equivalent implementation
    to our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Increased expressivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see from the examples, unifying classes and functions leads to increased
    expressivity and we can easily achieve various things such as callbacks, lazy
    parameter evaluation, centralized exception handling, and others, and without
    writing extra code and logic. Moreover, functions as classes mean that we can
    extend them to provide extra functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Algebraic data types and class hierarchies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Algebraic data types** (**ADTs**) and class hierarchies are other unifications
    in the Scala programming language. In other functional languages, there are special
    ways to create custom algebraic data types. In Scala, this is achieved using class
    hierarchies and namely *case classes* and *objects*. Let''s see what an ADT actually
    is, what types there are, and how to define them.'
  prefs: []
  type: TYPE_NORMAL
- en: ADTs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Algebraic data types are just composite types that combine other existing types
    or just represent some new ones. They only have data and do not contain any functionality
    on top of this data as normal classes would. Some examples can include the day
    of the week or a class that represents an RGB color—they have no extra functionality
    and they just carry information. The following few subsections will give a bit
    more insight on what ADTs are and what types are out there.
  prefs: []
  type: TYPE_NORMAL
- en: Sum ADTs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sum algebraic data types are the ones in which we can simply enumerate all
    the possible values of a type and provide a separate constructor for each value.
    As an example, let''s consider the months of the year. There are only 12 and they
    cannot change (hopefully):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this application will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `Month` trait in the preceding code is sealed because we do not want it
    to be extended outside the current file. As you can see, we've defined the different
    months as objects, as there is no reason for them to be separate instances. The
    values are what they are and they do not change.
  prefs: []
  type: TYPE_NORMAL
- en: Product ADTs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In product algebraic data types, we cannot enumerate all the possible values.
    There are usually too many to manually write them. We cannot provide a separate
    constructor for each separate value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s think about colors. There are different color models, but one of the
    most famous ones is RGB. It combines the different values of the main colors (red,
    green, and blue) in order to represent other colors. If we say that each of these
    colors can have a value between `0` and `255`, this would mean that to represent
    all possibilities, we would need to have 256³ different constructors. That''s
    why we can use a product ADT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now we can see that for the product ADTs, we have one constructor for different
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid ADTs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hybrid algebraic data types represent a combination of the sum and product ones
    we described previously. This means that we can have specific value constructors,
    but these value constructors also provide parameters in order to wrap other types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example. Imagine we are writing a drawing application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We have different shapes. The preceding example shows a sum ADT because we have
    the specific `Circle` and `Rectangle` value constructors. Also, we have a product
    ADT because the constructors take extra parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s expand our classes a bit. When drawing our shapes, we need to know their
    positions. This is why we can add a `Point` class that holds the `x` and `y` coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This should hopefully clarify what ADTs are in Scala and how they can be used.
  prefs: []
  type: TYPE_NORMAL
- en: The unification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After all of the preceding examples, it is obvious that class hierarchies and
    ADTs are unified and look like the same thing. This adds a high level of flexibility
    in the language and makes modeling easier than in other functional programming
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pattern matching is often used with ADTs. It makes the code much clearer and
    more readable as well as easier to extend in comparison to using the `if…else`
    statements when trying to do something with ADTs based on their values. As you
    could imagine, these statements can get quite cumbersome in some cases, especially
    when there are many different possible values for a certain data type. In some
    cases, pattern matching can be used the same way as *enums* and the `switch` statement
    is used in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching with values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the month''s example stated previously, we just have the month names. We
    might, however, want to also get their number, as the computer will not know this
    otherwise. Here is how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see how we match the different values, and based on them, we return
    the correct values. Here is how this method can be used now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, our application will produce the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The fact that we have specified our base trait to be sealed guarantees that
    nobody else will extend it outside our code, and we will be able to have an exhaustive
    pattern match. Unexhaustive pattern matches are problematic. Just as an experiment,
    if we try to comment out the match rule for February and we compile, we will see
    the following warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the example this way proves that the warning is true and our code has
    failed when we use `February` as a parameter. For the sake of completeness, we
    can add a default case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The examples shown in this subsection are what one can use in Scala, in order
    to achieve the functionality of *enums* in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching for product ADTs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pattern matching shows its real power when used for product and hybrid ADTs.
    In such cases, we can match the actual values of the data types. Let''s see how
    we would implement a functionality to calculate the area of a shape, as defined
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When matching, we can ignore values we don''t care about. For the area, we
    don''t really need the position information. In the preceding code, we just showed
    two different ways in which a matching is possible. The `_` operator can be anywhere
    in the match statement, and it will just ignore the value it is put for. After
    this, using our example is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will have an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can even put constants instead of variables for the ADT constructor parameters
    during pattern matching. This makes the language quite powerful and allows us
    to achieve even more complex logic, which will still look quite nice. You can
    try experimenting with the preceding examples in order to get an idea of how pattern
    matching actually works.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching is often used with ADTs and it helps to achieve clean, extendible,
    and exhaustive code.
  prefs: []
  type: TYPE_NORMAL
- en: Modules and objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modules are a way to organize programs. They are interchangeable and pluggable
    pieces of code that have well-defined interfaces and hidden implementations. In
    Java, modules are organized in packages. In Scala, modules are objects, just like
    everything else. This means that they can be parameterized, extended, and passed
    as parameters, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Scala modules can provide requirements in order to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Using modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already established that modules and objects are also unified in Scala.
    This means that we can pass an entire module around our application. It would
    be useful, however, to show what a module actually looks like. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `Tick` is just an interface to one of our modules. The following is its
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `TickUser` trait is an actual module. It implements `Tick` and contains
    the code hidden inside it. We create a singleton object that will carry the implementation.
    Note how the name in the object is the same as the method in `Tick`. This would
    cover the need to implement it when mixing in the trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can define another interface and an implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'What is interesting here is that we extended both modules in the `AlarmUser`
    one. This shows how modules could be made to be dependent on each other. Finally,
    we can use our modules as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In order for `ModuleDemo` to use the `AlarmUser` module, it is also required
    by the compiler to mix in `TickUser` or any module that mixes in `Tick`. This
    provides a possibility to plug in a different functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the program will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Modules in Scala can be passed as any other object. They are extendable, interchangeable,
    and their implementation is hidden.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on unification. We saw how there is a unification
    between functions and classes, ADTs, class hierarchies, as well as modules and
    objects. This allows us to be much more expressive and write cleaner and more
    efficient code. We also covered what pattern matching is and how it can be used
    in Scala to write good code.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the concepts covered in this chapter will be useful in the following
    chapters where we will be implementing concrete design patterns. They can also
    be used to write good software outside the defined design patterns just because
    the expressivity of Scala allows it, and this defies the need to do the extra
    work that design patterns add.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at **abstract** and **self-types** and what
    they can be useful for.
  prefs: []
  type: TYPE_NORMAL
