<html><head></head><body>
		<div id="_idContainer252">
			<h1 id="_idParaDest-377" class="chapter-number"><a id="_idTextAnchor377"/>15</h1>
			<h1 id="_idParaDest-378"><a id="_idTextAnchor378"/>Streams – Fundamentals</h1>
			<p>In <a href="B19793_14.xhtml#_idTextAnchor355"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>, we learned about lambda expressions. Lambda expressions enable us to write more concise code. Be aware, however, that the compiler is, in the background, inserting the code we omit. For that to work, the compiler must have no decisions to make. This is where “functional interfaces” come into play. A functional interface is an interface with just one <strong class="source-inline">abstract</strong> method; this is known as the “functional method.” Lambda expressions can only be used with <span class="No-Break">functional interfaces.</span></p>
			<p>We saw that if a local variable is used in a lambda expression, that variable must be <strong class="source-inline">final</strong> or “effectively final.” This keeps both views (method and lambda) of the variable’s value in sync. In other words, both the method and the lambda have the same value for the variable at <span class="No-Break">all times.</span></p>
			<p>We also examined the more popular functional interfaces in the API, namely, <strong class="source-inline">Predicate</strong>, <strong class="source-inline">BiPredicate</strong>, <strong class="source-inline">Supplier</strong>, <strong class="source-inline">Consumer</strong>, <strong class="source-inline">BiConsumer</strong>, <strong class="source-inline">Function</strong>, and <strong class="source-inline">BiFunction</strong>. There are many other functional interfaces in the API, including variants that cater to primitives (as opposed <span class="No-Break">to objects).</span></p>
			<p>Next, we discussed method references, which can make your code even more concise than lambdas. A method reference is a shorthand for a lambda expression. For the compiler to generate the lambda from the method reference, the context is key. The context factors in the functional interface declared and the generic <span class="No-Break">types used.</span></p>
			<p>We also explored the four types of method references: bound, unbound, static, and constructor. Bound method references bind, at compile time, to a variable from the method, whereas unbound rely on the object to be passed in at runtime. Static method references are unbound and invoke a <strong class="source-inline">static</strong> method. Constructor method references use the <strong class="source-inline">::new</strong> syntax to <span class="No-Break">create objects.</span></p>
			<p>We finished the chapter by discussing an example where the same method reference was used in three different contexts. Each of the method references resulted in a different lambda due to the differing contexts. This demonstrated the importance of context when examining <span class="No-Break">method references.</span></p>
			<p>In this chapter, we will start our coverage of streams. This is a large and important topic, requiring two chapters. Java 8 introduced both lambdas and streams to enable a more functional style of programming.  This can lead to cleaner, more expressive code as we are not bogged down in how to do something; we just say we want <span class="No-Break">it done.</span></p>
			<p>We will start by discussing the stream pipeline. We will then discuss stream “laziness” before moving on to show ways of creating streams. Lastly, we will, with the aid of code examples, examine <span class="No-Break">terminal operations.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Understanding <span class="No-Break">stream pipelines</span></li>
				<li>Exploring <span class="No-Break">stream laziness</span></li>
				<li><span class="No-Break">Creating streams</span></li>
				<li>Mastering <span class="No-Break">terminal operations</span></li>
			</ul>
			<h1 id="_idParaDest-379"><a id="_idTextAnchor379"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch15"><span class="No-Break">https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch15</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-380"><a id="_idTextAnchor380"/>Understanding stream pipelines</h1>
			<p>A <em class="italic">stream</em> in Java <a id="_idIndexMarker1199"/>is a sequence of data that can be processed by operations. Streams are not another way to organize data, such as using an array or <strong class="source-inline">Collection</strong>, because streams do not hold data. Streams are all about efficiently processing data that is <span class="No-Break">flowing by.</span></p>
			<p>Let’s look at the <span class="No-Break">stream pipeline.</span></p>
			<h2 id="_idParaDest-381"><a id="_idTextAnchor381"/>Stream pipeline</h2>
			<p>A <em class="italic">stream pipeline</em> is a set of <a id="_idIndexMarker1200"/>operations that run on a stream to produce a result. At a minimum, a stream pipeline consists of a source, zero or more intermediate operations, and a terminal operation, in that order. A pipeline is similar to an assembly line in a factory. Let’s look at <span class="No-Break">an example.</span></p>
			<h3>Assembly line analogy</h3>
			<p>Let’s assume we have a task of sharpening and stamping pencils that are currently sitting in a box (which contains 100 pencils). Stamping them means marking the pencil type on the pencil, such as 2B, 2H, and so forth. The<a id="_idIndexMarker1201"/> pencils must be sharpened, stamped, and finally packed away, in that order. Declaring a stream is the same as giving instructions to the supervisor. In this assembly line, Java is the supervisor. Nobody does anything until the supervisor shouts “Start.” The supervisor examines the instructions and sets up workstations with workers – one to take pencils from the box, one to sharpen the pencil, one to stamp the sharpened pencil, and one to pack away the <span class="No-Break">finished pencil.</span></p>
			<p>The worker taking pencils from the box is the pipeline <em class="italic">source</em>. The pencils are the data. Sharpening and stamping the pencils <a id="_idIndexMarker1202"/>are the <em class="italic">intermediate operations</em>. The last operation, packing away the pencils, is the <em class="italic">terminal operation</em>. The terminal operation is very<a id="_idIndexMarker1203"/> important as the supervisor will not shout “Start” until they see the terminal operation. Upon seeing it, however, the supervisor will shout “Start” and the process <span class="No-Break">will begin.</span></p>
			<p>Let’s examine <span class="No-Break">this process.</span></p>
			<p>The first worker takes a pencil out of the box and hands it to the second worker, who sharpens it. The second worker hands the sharpened pencil to the next worker, who stamps it and hands it to the final worker in the assembly line, who packs the <span class="No-Break">pencil away.</span></p>
			<p>Note that pencils (and data) can only proceed in one direction – once the worker passes on the pencil, they can’t get it back. From a Java perspective, this makes streams different from arrays and collections (where you can access the data at <span class="No-Break">any time).</span></p>
			<p>In addition, there is a principle of “lazy evaluation” in streams that we must be aware of here. We will discuss lazy evaluation in greater detail in the next section but for now, understand that data is <em class="italic">not</em> generated up front; it is only created <em class="italic">as and when needed</em>. This improves performance as you scale the amount of data you wish to process. Concerning our assembly line example, this means that the second pencil is not retrieved until required. What would be the point in having extra pencils sharpened and stamped if all you needed was one pencil? The supervisor, having the overall instructions, would be aware of this and ensure that the second pencil is <span class="No-Break">never started.</span></p>
			<p>Let’s get back to our analogy where, at this point, we have one pencil packed away. Let’s say we only want two pencils sharpened and stamped. This will require a new worker to be on the assembly line to keep count. The supervisor will place this new worker after the worker who stamps the pencils. The new worker’s job is to count the pencils as they pass by (to be packed) and to inform the supervisor when two pencils have passed. The supervisor then instructs the first worker to take the second pencil out of the box. This pencil is sharpened and stamped. The new worker sees this second pencil pass by to be packed and informs the supervisor of this fact. The supervisor lets the last worker finish <a id="_idIndexMarker1204"/>packing the second pencil and shouts “Stop.” Therefore, the other 98 pencils are never taken out of the box, as they were not needed. This is a <span class="No-Break">lazy evaluation.</span></p>
			<p>Now, let’s discuss what makes up a <span class="No-Break">stream pipeline.</span></p>
			<h3>Elements of a stream pipeline</h3>
			<p>A stream pipeline <a id="_idIndexMarker1205"/>consists of <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Source</strong>: This is where the stream <a id="_idIndexMarker1206"/>comes from; this could be an array, a collection, a file, or <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">varargs</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Intermediate operations</strong>: They transform the stream into another stream. We can have as many or<a id="_idIndexMarker1207"/> as few as we like (zero or more). Due to lazy evaluation, they do not run until the terminal <span class="No-Break">operation runs.</span></li>
				<li><strong class="bold">Terminal operation</strong>: This is<a id="_idIndexMarker1208"/> required to start the whole process and produce a result. Streams can only be used once – after the terminal operation completes, the stream is no longer usable (regenerate the stream <span class="No-Break">if necessary).</span></li>
			</ul>
			<p>Let’s discuss the <a id="_idIndexMarker1209"/>pipeline with the aid of an example. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.1</em> presents a <span class="No-Break">sample pipeline:</span></p>
			<div>
				<div id="_idContainer218" class="IMG---Figure">
					<img src="image/B19793_15_01.jpg" alt="Figure 15.1 – A sample pipeline"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1 – A sample pipeline</p>
			<p class="callout-heading">The var keyword</p>
			<p class="callout">The <strong class="source-inline">var</strong> keyword is known as <strong class="bold">local variable type inference</strong> (<strong class="bold">LVTI</strong>). LVTI enables us to omit a local variables type as the<a id="_idIndexMarker1210"/> compiler can infer it from the context. In this example, <strong class="source-inline">temps</strong> is <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">List&lt;Double&gt;</strong></span><span class="No-Break">.</span></p>
			<p>The output from <a id="_idIndexMarker1211"/>the previous figure is <span class="No-Break">as follows:</span></p>
			<pre class="console">
98.4100.2
100.2
87.9
102.8
102.8
2</pre>
			<p>In this figure, we are counting the number of temperatures <strong class="source-inline">&gt; 100</strong>.  As streams do not hold data, pipelines specify how we want to manipulate the source.  The first thing we do is to create a <strong class="source-inline">List&lt;Double&gt;</strong> list represented <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">temps</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
var temps = Arrays.asList(98.4, 100.2, 87.9, 102.8);</pre>			<p>We then stream the list – in other words, the list is <span class="No-Break">our source:</span></p>
			<pre class="source-code">
temps.stream()</pre>			<p>Next, we use the <strong class="source-inline">peek(Consumer)</strong> intermediate operation, which is useful for debugging <a id="_idIndexMarker1212"/>a pipeline and also for demonstrating what data is where in <span class="No-Break">the pipeline:</span></p>
			<pre class="source-code">
.peek(System.out::println)</pre>			<p>At this point, we want to filter <em class="italic">in</em> temperatures that are greater than 100. In other words, only temperatures <strong class="source-inline">&gt; 100</strong> will make it past <span class="No-Break">the filter:</span></p>
			<pre class="source-code">
.filter(temp -&gt; temp &gt; 100)</pre>			<p>Now that we have a temperature &gt; 100, we use <strong class="source-inline">peek(Consumer)</strong> again to ensure our filter is <span class="No-Break">working properly:</span></p>
			<pre class="source-code">
.peek(System.out::println)</pre>			<p>Lastly, we have the terminal operation, <strong class="source-inline">count()</strong>, which starts off the <span class="No-Break">whole process:</span></p>
			<pre class="source-code">
.count();</pre>			<p>Let us discuss how the streaming process works here. Firstly, <strong class="source-inline">98.4</strong> is streamed. As <strong class="source-inline">98.4</strong> fails the filter, it is removed from the stream. Next, <strong class="source-inline">100.2</strong> is streamed; it passes the filter and Java sets the count to 1. The next value <strong class="source-inline">87.9</strong>, is then streamed but it fails the filter. Lastly, <strong class="source-inline">102.8</strong> is streamed, which also passes the filter, thereby increasing the count to 2. Therefore, the count of temperatures that are <strong class="source-inline">&gt; 100</strong> is 2 (<strong class="source-inline">100.2</strong> and <strong class="source-inline">102.8</strong>). Notice the order in which the values come out of the stream is demonstrating <span class="No-Break">stream laziness.</span></p>
			<p>We will discuss the various operations from this example in due course. For the moment, we would like to cover stream laziness in <span class="No-Break">more detail.</span></p>
			<h1 id="_idParaDest-382"><a id="_idTextAnchor382"/>Exploring stream laziness</h1>
			<p>The principle of lazy evaluation is that you get what you need, only when you need it. For example, if shopping websites such as Amazon were to display 10,000 records to a user, the principle of lazy evaluation would be to retrieve the first 50 and while the user is viewing these, retrieve<a id="_idIndexMarker1213"/> the next 50 in the background. An eager evaluation would be to retrieve all 10,000 records in one go. With regards to streams, this means that nothing happens until the terminal operation <span class="No-Break">gets called.</span></p>
			<p>The pipeline specifies what operations we want performed on the source and in what order. As nothing happens until the terminal operation runs, Java is aware of the full pipeline. This enables Java to introduce efficiencies whenever possible. For example, why run an operation on a piece of data if that operation is not required? This could arise in the <span class="No-Break">following situations:</span></p>
			<ul>
				<li>We have already found the data item we are <span class="No-Break">looking for</span></li>
				<li>We may have a limit set of the number of elements (as in the <span class="No-Break">pencils analogy)</span></li>
			</ul>
			<p>Let’s examine an <a id="_idIndexMarker1214"/>example where the order of processing elements from the source demonstrates lazy evaluation. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.2</em> (<strong class="source-inline">Laziness.java</strong>) <span class="No-Break">shows this:</span></p>
			<div>
				<div id="_idContainer219" class="IMG---Figure">
					<img src="image/B19793_15_02.jpg" alt="Figure 15.2 – Lazy evaluation – stream pipeline example"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.2 – Lazy evaluation – stream pipeline example</p>
			<p>The algorithm in this figure obtains the first name that begins with 'B' or 'C' that is longer than 3 characters. In this example, we initially create a <strong class="source-inline">List&lt;String&gt;</strong> <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">names</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
   List&lt;String&gt; names = Arrays.asList("April", "Ben",             "Charlie","David", "Benildus", "Christian");</pre>
			<p>As  Java does not do <a id="_idIndexMarker1215"/>any streaming until the terminal operation is encountered; nothing happens in this example until the <strong class="source-inline">forEach(Consumer)</strong> operation (line 31). This means that the code <strong class="source-inline">names.stream()</strong> at the start, is merely creating an object that knows where to go for the data when the <span class="No-Break">streaming starts.</span></p>
			<p>The first thing we do in this pipeline is output the current string, representing the person’s name using the <strong class="source-inline">peek(Consumer)</strong> <span class="No-Break">intermediate operation:</span></p>
			<pre class="source-code">
.peek(System.out::println)</pre>			<p>Next, we use the <strong class="source-inline">filter(Predicate)</strong> intermediate operation to filter in names that begin with “B” <span class="No-Break">or “C.”:</span></p>
			<pre class="source-code">
.filter(s -&gt; {    System.out.println("filter1 : "+s);
    return s.startsWith("B") || s.startsWith("C"); } )</pre>
			<p>Immediately following that, we filter in names that are longer than <span class="No-Break">three characters:</span></p>
			<pre class="source-code">
.filter(s -&gt; {    System.out.println("filter2 : "+s);
    return s.length() &gt; 3; } )</pre>
			<p>After that, we use the <strong class="source-inline">limit(long)</strong> intermediate operation to keep track of how many names have passed the <span class="No-Break">second filter:</span></p>
			<pre class="source-code">
.limit(1)</pre>			<p>In this example, once one name passes by, the JVM is informed and no other name will be streamed from the source. Lastly, we provide the (required) <span class="No-Break">terminal operation:</span></p>
			<pre class="source-code">
.forEach(System.out::println);</pre>			<p><span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.3</em> shows the output from the code in <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.2</em>, which is <span class="No-Break">very revealing:</span></p>
			<div>
				<div id="_idContainer220" class="IMG---Figure">
					<img src="image/B19793_15_03.jpg" alt="Figure 15.3 – Output from Figure 15.2 (with comments on the right)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.3 – Output from Figure 15.2 (with comments on the right)</p>
			<p>Line 35 shows the first name, <strong class="source-inline">April</strong>, being streamed from the list. <strong class="source-inline">April</strong> makes it to the first filter and is removed (as <strong class="source-inline">April</strong> does not start with “B” <span class="No-Break">or “C”).</span></p>
			<p>Line 37 shows the next name, <strong class="source-inline">Ben</strong>, being streamed. <strong class="source-inline">Ben</strong> passes the first filter and makes it to the second filter. However, as the length of <strong class="source-inline">Ben</strong> is only 3 characters, it is removed by the <span class="No-Break">second filter.</span></p>
			<p>Line 40 shows the next name, <strong class="source-inline">Charlie</strong>, being streamed. <strong class="source-inline">Charlie</strong> passes the first filter (as <strong class="source-inline">Charlie</strong> begins with “C”) and is passed to the second filter. <strong class="source-inline">Charlie</strong> also passes this filter as the length of <strong class="source-inline">Charlie</strong> is &gt; 3 characters long. So, <strong class="source-inline">Charlie</strong> is passed to the <strong class="source-inline">limit(long)</strong> intermediate operation, which notes that this is the first name passing by. As the limit is set to 1, the JVM is informed. <strong class="source-inline">Charlie</strong> is processed by the <strong class="source-inline">forEach(Consumer)</strong> terminal operation printing out <strong class="source-inline">Charlie</strong> (line 43) and the stream is <span class="No-Break">shut down.</span></p>
			<p>Note that none of the <a id="_idIndexMarker1216"/>other names – <strong class="source-inline">David</strong>, <strong class="source-inline">Benildus</strong>, or <strong class="source-inline">Christian</strong> – are streamed at all. This is a small example but you can imagine the efficiencies of scale when you are dealing with millions of <span class="No-Break">data items.</span></p>
			<p>We will now move on to discussing how to <span class="No-Break">create streams.</span></p>
			<h1 id="_idParaDest-383"><a id="_idTextAnchor383"/>Creating streams</h1>
			<p>Streams, both finite and infinite, can be generated from various sources. For example, sources such as arrays, collections, <strong class="source-inline">varargs</strong>, and files can be used. Let’s examine these in turn. For the moment, we<a id="_idIndexMarker1217"/> will deal with non-primitive types; all the streams will be serial (non-parallel). Both primitive and parallel streams will be discussed in <a href="B19793_16.xhtml#_idTextAnchor401"><span class="No-Break"><em class="italic">Chapter 16</em></span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-384"><a id="_idTextAnchor384"/>Streaming from an array</h2>
			<p>We <a id="_idIndexMarker1218"/>will use <strong class="source-inline">Stream&lt;T&gt; Arrays.stream(T[] array)</strong> for this. This <strong class="source-inline">static</strong> method accepts<a id="_idIndexMarker1219"/> an array of type <strong class="source-inline">T</strong> and returns <strong class="source-inline">Stream&lt;T&gt;</strong>. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.4</em> (<strong class="source-inline">CreatingStreams.java</strong>) presents <span class="No-Break">an example:</span></p>
			<div>
				<div id="_idContainer221" class="IMG---Figure">
					<img src="image/B19793_15_04.jpg" alt="Figure 15.4 – Streaming an array"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.4 – Streaming an array</p>
			<p>In this figure, we declare a <strong class="source-inline">Double</strong> array (note that this is not a primitive <strong class="source-inline">double</strong> array). The stream object is created using the <strong class="source-inline">Arrays.stream(T[] array) </strong>method call. We start the stream off using the terminal operation <strong class="source-inline">count()</strong>. Lastly, we output the number of elements in the array. Note that this is just an example and that there is a more straightforward way (using the <strong class="source-inline">length</strong> property) of outputting the number of elements in <span class="No-Break">an array.</span></p>
			<p>Let’s examine how we stream from <span class="No-Break">a collection.</span></p>
			<h2 id="_idParaDest-385"><a id="_idTextAnchor385"/>Streaming from a collection</h2>
			<p>By <em class="italic">collection</em>, we<a id="_idIndexMarker1220"/> mean the <strong class="source-inline">Collection</strong> interface<a id="_idIndexMarker1221"/> hierarchy. The <strong class="source-inline">Collection</strong> interface has a <strong class="source-inline">default Stream&lt;E&gt; stream()</strong> method. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.5</em> (<strong class="source-inline">CreatingStreams.java</strong>) presents code that generates a stream from <span class="No-Break">a collection:</span></p>
			<div>
				<div id="_idContainer222" class="IMG---Figure">
					<img src="image/B19793_15_05.jpg" alt="Figure 15.5 – Streaming a collection"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.5 – Streaming a collection</p>
			<p>In this <a id="_idIndexMarker1222"/>figure, we <a id="_idIndexMarker1223"/>initially create a <strong class="source-inline">List&lt;String&gt;</strong> using <span class="No-Break"><strong class="source-inline">Arrays.asList(T… a)</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
List&lt;String&gt; animalList = Arrays.asList("cat", "dog", "sheep");</pre>			<p>We then use the <strong class="source-inline">Collection</strong> <strong class="source-inline">stream()</strong> method to create the <span class="No-Break">stream object:</span></p>
			<pre class="source-code">
Stream&lt;String&gt; streamAnimals = animalList.stream();</pre>			<p>To start the stream off, we use the terminal <span class="No-Break"><strong class="source-inline">count()</strong></span><span class="No-Break"> operation:</span></p>
			<pre class="source-code">
System.out.println("Number of elements: "+streamAnimals.count()); // 3</pre>			<p>What if you had a <em class="italic">Map</em> and wanted to stream it? Remember that <strong class="source-inline">Map</strong> is not a <strong class="source-inline">Collection</strong> as it does not implement it. This is what the second example shows. Firstly, let us declare and populate <span class="No-Break">the map:</span></p>
			<pre class="source-code">
Map&lt;String, Integer&gt; namesToAges = new HashMap&lt;&gt;();namesToAges.put("Mike", 22);
namesToAges.put("Mary", 24);
namesToAges.put("Alice", 31);</pre>
			<p>To bridge across from a <strong class="source-inline">Map</strong> to a <strong class="source-inline">Collection</strong> we will do <span class="No-Break">the following:</span></p>
			<pre class="source-code">
   namesToAges.entrySet()</pre>			<p>The <strong class="source-inline">entrySet()</strong> method in <strong class="source-inline">Map</strong> returns a <strong class="source-inline">Set</strong> view of the entries in the map. As <strong class="source-inline">Set</strong> is a sub-interface of <strong class="source-inline">Collection</strong>, <strong class="source-inline">Set</strong> “is-a” <strong class="source-inline">Collection</strong>. At this point, we can now stream the collection <span class="No-Break">as normal:</span></p>
			<pre class="source-code">
.stream()</pre>			<p>Finally, we <a id="_idIndexMarker1224"/>start off the process using the terminal operation, <strong class="source-inline">count()</strong>, which returns <strong class="source-inline">3</strong>, showing<a id="_idIndexMarker1225"/> that the <span class="No-Break">stream worked.</span></p>
			<p>Now, let’s look at the <span class="No-Break"><strong class="source-inline">Stream.of()</strong></span><span class="No-Break"> method.</span></p>
			<h2 id="_idParaDest-386"><a id="_idTextAnchor386"/>Stream.of()</h2>
			<p><strong class="source-inline">static &lt;T&gt; Stream&lt;T&gt; of(T… values)</strong> is a very useful method. While its signature <a id="_idIndexMarker1226"/>can seem a little confusing, it is very straightforward to use. It is a <strong class="source-inline">static</strong> method that is generically typed, hence <strong class="source-inline">&lt;T&gt;</strong>. Thus, the compiler does not complain about the use of <strong class="source-inline">T</strong> in the signature. It returns <strong class="source-inline">Stream&lt;T&gt;</strong> and <strong class="source-inline">T</strong> depends on what is passed in. For example, if you pass in strings, then you get back <strong class="source-inline">Stream&lt;String&gt;</strong>. The parameters are a <strong class="source-inline">varargs</strong> list, which is <span class="No-Break">very flexible.</span></p>
			<p>Let’s look at some examples. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.6</em> (BuildStreams.java) presents <span class="No-Break">the code:</span></p>
			<div>
				<div id="_idContainer223" class="IMG---Figure">
					<img src="image/B19793_15_06.jpg" alt="Figure 15.6 – Stream.of() examples"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.6 – Stream.of() examples</p>
			<p>In this figure, we initially declare an array <span class="No-Break">of strings:</span></p>
			<pre class="source-code">
String[] cities = {"Dublin", "Berlin", "Paris"};</pre>			<p>Using the <strong class="source-inline">Stream.of()</strong> method, we declare the stream source to be <span class="No-Break">the array:</span></p>
			<pre class="source-code">
Stream&lt;String&gt; citiesStream = Stream.of(cities);</pre>			<p>Once declared, we start the stream using the <strong class="source-inline">count()</strong> <span class="No-Break">terminal operation:</span></p>
			<pre class="source-code">
System.out.println(citiesStream.count()); // 3</pre>			<p>Next, <strong class="source-inline">Stream.of()</strong> sources the stream from a <strong class="source-inline">varargs</strong> of integers passed in (boxed <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">Integer</strong></span><span class="No-Break">s):</span></p>
			<pre class="source-code">
Stream&lt;Integer&gt; streamI = Stream.of(1,2,3);</pre>			<p>We start the<a id="_idIndexMarker1227"/> streaming process as before, using the <strong class="source-inline">count()</strong> <span class="No-Break">terminal operation:</span></p>
			<pre class="source-code">
System.out.println(streamI.count()); // 3</pre>			<p>Following that, <strong class="source-inline">Stream.of()</strong> sources the stream from a <strong class="source-inline">varargs</strong> of strings and <span class="No-Break">stream them:</span></p>
			<pre class="source-code">
Stream&lt;String&gt; streamS = Stream.of("a", "b", "c", "d");System.out.println(streamS.count()); // 4</pre>
			<p>Lastly, we source the stream from a <strong class="source-inline">varargs</strong> of <strong class="source-inline">Dog</strong> (just one), and <span class="No-Break">stream them:</span></p>
			<pre class="source-code">
Stream&lt;Dog&gt; streamD = Stream.of(new Dog());System.out.println(streamD.count()); // 1</pre>
			<p>Now, let’s examine how to stream from <span class="No-Break">a file.</span></p>
			<h2 id="_idParaDest-387"><a id="_idTextAnchor387"/>Streaming from a file</h2>
			<p>To<a id="_idIndexMarker1228"/> stream a file, we can use the <strong class="source-inline">Files.lines()</strong> method. Its signature is <strong class="source-inline">public static Stream&lt;String&gt; lines(Path path) </strong><span class="No-Break"><strong class="source-inline">throws IOException</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">Path</strong> parameter refers to the file we want to process. This file needs to be delimited; for example, using the <a id="_idIndexMarker1229"/>forward slash (<strong class="source-inline">/</strong>) character. The file we will use contains the <span class="No-Break">following lines:</span></p>
			<pre class="source-code">
Fido/BlackLily/White</pre>
			<p>The<a id="_idIndexMarker1230"/> returned <strong class="source-inline">Stream&lt;String&gt;</strong> refers to the lines from the file, one <strong class="source-inline">String</strong> for each line in the file. We can process the returned stream using the <strong class="source-inline">forEach(Consumer)</strong> terminal operation defined in the <strong class="source-inline">Stream</strong> interface. Inside the consumer block of code, each line from the file (a <strong class="source-inline">String</strong>) could be parsed into <strong class="source-inline">String[]</strong> using the <strong class="source-inline">split()</strong> method from the <strong class="source-inline">String</strong> class – where we pass in the delimiter and get back a <strong class="source-inline">String[]</strong> of the elements. Once we have this <strong class="source-inline">String[]</strong>, we can easily create our object and add it to a collection, such as <strong class="source-inline">ArrayList</strong>. This is an example of a <strong class="source-inline">Consumer</strong> <span class="No-Break">side effect.</span></p>
			<p>Assuming a <strong class="source-inline">Cat</strong> class with <strong class="source-inline">name</strong> and <strong class="source-inline">color</strong> instance variables and an associated constructor (ProcessFile.java), we could do <span class="No-Break">the following:</span></p>
			<pre class="source-code">
try(Stream&lt;String&gt; stream =  Files.lines(Paths.get(filename))){
       stream.forEach(line -&gt; {
           String[] catsArray = line.split("/");
           cats.add(new Cat(catsArray[0], catsArray[1]));
       });
  } catch (IOException ioe) {
            ioe.printStackTrace();
  }</pre>
			<p class="callout-heading">forEach(Consumer) versus forEach(Consumer)</p>
			<p class="callout">In the <a id="_idIndexMarker1231"/>Java API, these two versions of <strong class="source-inline">forEach()</strong> look very similar but they are in fact from two very different hierarchies. One is a <strong class="source-inline">default</strong> method in the <strong class="source-inline">Iterable</strong> interface (which <strong class="source-inline">Collection</strong> inherits). The other is a terminal operation in the <span class="No-Break"><strong class="source-inline">Stream</strong></span><span class="No-Break"> interface.</span></p>
			<h2 id="_idParaDest-388"><a id="_idTextAnchor388"/>Infinite streams</h2>
			<p>Infinite streams can easily be<a id="_idIndexMarker1232"/> created using two <strong class="source-inline">static</strong> methods from the <strong class="source-inline">Stream</strong> interface, namely <strong class="source-inline">generate()</strong> and <strong class="source-inline">iterate()</strong>. Let’s examine these <span class="No-Break">in turn.</span></p>
			<h3>Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</h3>
			<p>As per the API, it “returns an infinite, sequential <a id="_idIndexMarker1233"/>unordered stream where each element is generated by the provided <strong class="source-inline">Supplier</strong>.” <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.7</em> (<strong class="source-inline">InfiniteStreamsGenerate.java</strong>) presents some code that we <span class="No-Break">can discuss:</span></p>
			<div>
				<div id="_idContainer224" class="IMG---Figure">
					<img src="image/B19793_15_07.jpg" alt="Figure 15.7 – Creating an infinite stream using generate()"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.7 – Creating an infinite stream using generate()</p>
			<p>As this figure shows, the <strong class="source-inline">Supplier</strong> provided produces random numbers between 0 and <span class="No-Break">9 inclusive:</span></p>
			<pre class="source-code">
() -&gt; (int) (Math.random() * 10);</pre>			<p>We start the streaming process using the <strong class="source-inline">forEach(Consumer)</strong> <span class="No-Break">terminal operation:</span></p>
			<pre class="source-code">
infStream.forEach(System.out::println);</pre>			<p><strong class="source-inline">Consumer</strong> accepts a method reference to output the numbers generated. This stream will keep going until we terminate the application (for example, from within <span class="No-Break">the IDE).</span></p>
			<p class="callout-heading">Math.random()</p>
			<p class="callout">Recall that <strong class="source-inline">Math.random()</strong> returns a <strong class="source-inline">double</strong> type between <strong class="source-inline">0.0 &lt;= x &lt; 1.0</strong>. In other words, a number between <strong class="source-inline">0</strong> and less<a id="_idIndexMarker1234"/> than <strong class="source-inline">1</strong>. When we multiply this number by <strong class="source-inline">10</strong> and subsequently cast that number to an <strong class="source-inline">int</strong> type, we are, in effect, scaling it to <strong class="source-inline">0 &lt;= x &lt; </strong><span class="No-Break"><strong class="source-inline">10</strong></span><span class="No-Break">.</span></p>
			<p>Now, let’s discuss the other <a id="_idIndexMarker1235"/>method for generating infinite streams, <span class="No-Break">namely </span><span class="No-Break"><strong class="source-inline">iterate()</strong></span><span class="No-Break">.</span></p>
			<h3>Stream&lt;T&gt; iterate(T seed, UnaryOperator&lt;T&gt; fn)</h3>
			<p>This method gives you more control over the<a id="_idIndexMarker1236"/> numbers generated. The first argument is the seed, which is the first number in the stream. The second parameter is a <strong class="source-inline">UnaryOperator</strong> (a <strong class="source-inline">Function</strong> where the input and output are the same type). This <strong class="source-inline">UnaryOperator</strong> function is a lambda that accepts the previous value and generates the next value. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.8</em> (<strong class="source-inline">InfiniteStreamsIterate.java</strong>) presents a code example for us to discuss <span class="No-Break">this further:</span></p>
			<div>
				<div id="_idContainer225" class="IMG---Figure">
					<img src="image/B19793_15_08.jpg" alt=" Figure 15.8 – Creating an infinite stream using iterate()"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 15.8 – Creating an infinite stream using iterate()</p>
			<p>As this figure shows, the seed is <strong class="source-inline">2</strong> and the lambda expression generates the next even number after <strong class="source-inline">2</strong> and so forth. Thus, this stream generates <strong class="source-inline">2</strong>, <strong class="source-inline">4</strong>, <strong class="source-inline">6</strong>, <strong class="source-inline">8</strong>, and so on, until we kill <span class="No-Break">the application.</span></p>
			<p>What if we wanted only so many numbers? For example, what if we wanted only the even numbers up to <strong class="source-inline">20</strong> (starting at <strong class="source-inline">2</strong>)? There is an overloaded version of <strong class="source-inline">iterate()</strong> that caters to this – its second parameter is a <strong class="source-inline">Predicate</strong>, which states when to finish. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.9</em> (<strong class="source-inline">InfiniteStreamsIterate.java</strong>) presents <span class="No-Break">an example:</span></p>
			<div>
				<div id="_idContainer226" class="IMG---Figure">
					<img src="image/B19793_15_09.jpg" alt=" Figure 15.9 – Creating an infinite/finite stream using iterate() and Predicate"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 15.9 – Creating an infinite/finite stream using iterate() and Predicate</p>
			<p>The <span class="No-Break"><strong class="source-inline">Predicate</strong></span><span class="No-Break"> condition:</span></p>
			<pre class="source-code">
n -&gt; n &lt;=20</pre>			<p>is the important line <a id="_idIndexMarker1237"/>here. that specifies when this stream stops. Thus, this is one way of creating a finite stream from an infinite stream. If the <strong class="source-inline">Predicate</strong> condition keeps returning <strong class="source-inline">true</strong>, the stream will keep generating numbers until you kill <span class="No-Break">the application.</span></p>
			<p>In this figure, <strong class="source-inline">2</strong>, <strong class="source-inline">4</strong>, <strong class="source-inline">6</strong>, <strong class="source-inline">8</strong>, <strong class="source-inline">10</strong>, <strong class="source-inline">12</strong>, <strong class="source-inline">14</strong>, <strong class="source-inline">16</strong>, <strong class="source-inline">18</strong>, and <strong class="source-inline">20</strong> all pass the <strong class="source-inline">Predicate</strong> condition and are output. Once <strong class="source-inline">22</strong> is generated and the <strong class="source-inline">Predicate</strong> fails, the <span class="No-Break">stream stops.</span></p>
			<p>Another way of turning an infinite stream into a finite stream is to use the <strong class="source-inline">limit()</strong> intermediate operation. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.10</em> (<strong class="source-inline">InfiniteStreamsIterate.java</strong>) presents <span class="No-Break">this scenario:</span></p>
			<div>
				<div id="_idContainer227" class="IMG---Figure">
					<img src="image/B19793_15_10.jpg" alt=" Figure 15.10 – Creating a finite stream using limit()"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 15.10 – Creating a finite stream using limit()</p>
			<p>In this <a id="_idIndexMarker1238"/>figure, we restricted the numbers generated to 10 by using the <strong class="source-inline">limit()</strong> intermediate operation. We will discuss intermediate operations in <a href="B19793_16.xhtml#_idTextAnchor401"><span class="No-Break"><em class="italic">Chapter 16</em></span></a>. In this example, once the 10<span class="superscript">th</span> number has passed by, <strong class="source-inline">limit()</strong> informs the JVM of this fact, and no further numbers <span class="No-Break">are generated.</span></p>
			<p>Now that we know how to create streams, let’s examine <span class="No-Break">terminal operations.</span></p>
			<h1 id="_idParaDest-389"><a id="_idTextAnchor389"/>Mastering terminal operations</h1>
			<p>As we discussed earlier, no <a id="_idIndexMarker1239"/>streaming happens until the terminal operation executes. This gives the JVM an overall picture of the stream pipeline, thereby enabling efficiencies to be introduced in <span class="No-Break">the background.</span></p>
			<p>A terminal operation can be performed without any intermediate operation but not the other way around. <em class="italic">Reductions</em> are a special type of terminal operation where all of the contents of the stream are combined into a single primitive or <em class="italic">Object</em> (for example, <span class="No-Break">a </span><span class="No-Break"><em class="italic">Collection</em></span><span class="No-Break">).</span></p>
			<p><em class="italic">Table 15.1</em> represents the terminal operations we will be discussing in <span class="No-Break">this section:</span></p>
			<div>
				<div id="_idContainer228" class="IMG---Figure">
					<img src="image/B19793_15_Table_01.jpg" alt="Table 15.1 – Terminal operations"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 15.1 – Terminal operations</p>
			<p>Before we discuss them in turn, a brief discussion regarding the table. Remember, a reduction must look at all elements in the stream and then return a primitive <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">Object</strong></span><span class="No-Break">.</span></p>
			<p>Some of these terminal <a id="_idIndexMarker1240"/>operations, such as <strong class="source-inline">allMatch(Predicate)</strong>, may not look at all of the elements in the stream. For example, let’s say we had the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
List&lt;String&gt; names = Arrays.asList(<strong class="bold">"Alan"</strong>,<strong class="bold">"Brian"</strong>,<strong class="bold">"Colin"</strong>);Predicate&lt;String&gt; pred = name -&gt; name.startsWith(<strong class="bold">"A"</strong>);
System.out.println(names.stream().allMatch(pred)); // false</pre>
			<p>The <strong class="source-inline">Predicate</strong> condition fails on <strong class="source-inline">"Brian"</strong>, as it does not start with <strong class="source-inline">"A"</strong>, and <strong class="source-inline">allMatch()</strong> returns <strong class="source-inline">false</strong>. Therefore, <strong class="source-inline">"Colin"</strong> is never examined and hence, <strong class="source-inline">allMatch()</strong> is not <span class="No-Break">a reduction.</span></p>
			<p>We will discuss <strong class="source-inline">Optional</strong>s later but for the moment, <strong class="source-inline">Optional</strong>s were introduced in Java 8 to replace <strong class="source-inline">null</strong> return values (and thereby help to reduce the number of <strong class="source-inline">NullPointerException</strong>s). If the stream is empty, an empty <strong class="source-inline">Optional</strong> is returned (and not <strong class="source-inline">null</strong>). Therefore, an <strong class="source-inline">Optional</strong> object either has a non-<strong class="source-inline">null</strong> value or is empty. One way of ending up with an empty stream is by filtering out all of its elements before calling the <span class="No-Break">terminal operation.</span></p>
			<p>Let’s deal with the operations <span class="No-Break">in turn.</span></p>
			<h2 id="_idParaDest-390"><a id="_idTextAnchor390"/>count()</h2>
			<p>We have<a id="_idIndexMarker1241"/> already encountered <strong class="source-inline">count()</strong>, so a quick example<a id="_idIndexMarker1242"/> has been provided in <span class="No-Break"><em class="italic">Figure </em></span><span class="No-Break"><em class="italic">15</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">TerminalOperations.java</strong></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer229" class="IMG---Figure">
					<img src="image/B19793_15_11.jpg" alt="Figure 15.11 –  count() in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.11 –  count() in code</p>
			<p>The <strong class="source-inline">count()</strong> method works with finite streams as it will never terminate for an infinite stream. In this example, the two strings, <strong class="source-inline">"dog"</strong> and <strong class="source-inline">"cat"</strong>, are streamed and a count of <strong class="source-inline">2</strong> is returned. Note that <strong class="source-inline">count()</strong> is a reduction as it looks at each element in the stream and returns a <span class="No-Break">single value.</span></p>
			<h2 id="_idParaDest-391"><a id="_idTextAnchor391"/>min() and max()</h2>
			<p>Like <strong class="source-inline">count()</strong>, both <strong class="source-inline">min()</strong> and <strong class="source-inline">max()</strong> work with finite streams and hang on infinite streams (in case another value<a id="_idIndexMarker1243"/> might be the minimum or maximum value). Both are <a id="_idIndexMarker1244"/>reductions as they return a <a id="_idIndexMarker1245"/>single value after processing the whole stream. Given that the stream <a id="_idIndexMarker1246"/>could be empty, <em class="italic">Optional</em> is the <span class="No-Break">return type.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.12</em> (TerminalOperations.java) presents some code using <strong class="source-inline">min()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">max()</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer230" class="IMG---Figure">
					<img src="image/B19793_15_12.jpg" alt="Figure 15.12 – min() and max() in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.12 – min() and max() in code</p>
			<p>In this <a id="_idIndexMarker1247"/>example, we initially define a custom <strong class="source-inline">Comparator</strong> that sorts the list of strings into ascending length-of-string order. This <strong class="source-inline">Comparator</strong> is then passed into the <strong class="source-inline">min()</strong> method, where <strong class="source-inline">"pig"</strong> is returned <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Optional</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
.min((s1, s2) -&gt; s1.length()-s2.length())</pre>			<p>We then<a id="_idIndexMarker1248"/> use the <a id="_idIndexMarker1249"/>functional-style <strong class="source-inline">Optional</strong> method, <strong class="source-inline">ifPresent()</strong>, to determine if there is a non-<strong class="source-inline">null</strong> value in <strong class="source-inline">Optional</strong>. As <strong class="source-inline">"pig"</strong> is there (present)), it <span class="No-Break">is output:</span></p>
			<pre class="source-code">
min.ifPresent(System.out::println);// pig</pre>			<p>Next up is a different <a id="_idIndexMarker1250"/>custom <strong class="source-inline">Comparator</strong> that sorts the list of numbers into ascending numeric order. This is then passed into the <strong class="source-inline">max()</strong> method, where <strong class="source-inline">12</strong> is stored in the <strong class="source-inline">Optional</strong> <span class="No-Break">variable </span><span class="No-Break"><strong class="source-inline">max</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
.max((i1, i2) -&gt; i1-i2)</pre>			<p>Again, we use the <strong class="source-inline">ifPresent()</strong> method to determine if there is a non-<strong class="source-inline">null</strong> value in <strong class="source-inline">max</strong>. As <strong class="source-inline">12</strong> is present, it <span class="No-Break">is output:</span></p>
			<pre class="source-code">
max.ifPresent(System.out::println);// 12</pre>			<p>Lastly, we demonstrate that you can use <strong class="source-inline">Stream.empty()</strong> to create an <span class="No-Break">empty stream:</span></p>
			<pre class="source-code">
Optional&lt;Object&gt; noMin = Stream.empty().min((x1, x2) -&gt; 0)</pre>			<p>In this example, as the stream is empty, the<a id="_idIndexMarker1251"/> comparator <strong class="source-inline">(x1, x2) -&gt; 0</strong> is never<a id="_idIndexMarker1252"/> called and as <a id="_idIndexMarker1253"/>a result, there is <a id="_idIndexMarker1254"/>no value in <strong class="source-inline">Optional</strong>. Thus, <strong class="source-inline">isEmpty()</strong> returns true and <strong class="source-inline">isPresent()</strong> <span class="No-Break">returns false:</span></p>
			<pre class="source-code">
System.out.println(noMin.isEmpty());// trueSystem.out.println(noMin.isPresent());// false</pre>
			<h2 id="_idParaDest-392"><a id="_idTextAnchor392"/>findAny() and findFirst()</h2>
			<p>These terminal operations are not<a id="_idIndexMarker1255"/> reductions as they do not process the entire stream. As its name suggests, <strong class="source-inline">findAny()</strong> will return <a id="_idIndexMarker1256"/>any element – typically, the first one is returned but this is not guaranteed. On the other hand, <strong class="source-inline">findFirst()</strong> does just that – it returns the first element. Not surprisingly, these methods can work with infinite<a id="_idIndexMarker1257"/> streams (as they <a id="_idIndexMarker1258"/>don’t process all of the stream). An <em class="italic">Optional</em> is returned in both cases (as the stream may be empty when they <span class="No-Break">are called).</span></p>
			<p>A <em class="italic">short-circuiting</em> terminal operation is<a id="_idIndexMarker1259"/> defined as an operation that, when presented with infinite input, may terminate in finite time. Given that these operations can return before processing all of the stream, they are <span class="No-Break">considered short-circuiting.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.13</em> (TerminalOperationsFindAnyFindFirst.java) presents their use <span class="No-Break">in code:</span></p>
			<div>
				<div id="_idContainer231" class="IMG---Figure">
					<img src="image/B19793_15_13.jpg" alt="Figure 15.13 – findAny() and findFirst() in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.13 – findAny() and findFirst() in code</p>
			<p>In this figure, we execute <strong class="source-inline">findAny()</strong> on the stream of strings <strong class="source-inline">"John"</strong> and <strong class="source-inline">"Paul"</strong>. This returns <strong class="source-inline">"John"</strong> usually but is not guaranteed; whereas<a id="_idIndexMarker1260"/> when we execute <strong class="source-inline">findFirst()</strong> on the same <a id="_idIndexMarker1261"/>stream,  <strong class="source-inline">"John"</strong> is returned all the time. As this example demonstrates, neither <a id="_idIndexMarker1262"/>operation processes <strong class="source-inline">"Paul"</strong> and therefore<a id="_idIndexMarker1263"/> they are not <span class="No-Break">considered reductions.</span></p>
			<h2 id="_idParaDest-393"><a id="_idTextAnchor393"/>anyMatch(), allMatch, and noneMatch()</h2>
			<p>These three terminal operations all accept a <strong class="source-inline">Predicate</strong> condition and return a <strong class="source-inline">boolean</strong> value. Like the<a id="_idIndexMarker1264"/> <strong class="source-inline">"find"</strong> methods, they are not reductions either as they may not look at <em class="italic">all</em> of the elements. Depending<a id="_idIndexMarker1265"/> on the data, these<a id="_idIndexMarker1266"/> operations may or may not terminate when <a id="_idIndexMarker1267"/>presented with infinite streams. That said, they are<a id="_idIndexMarker1268"/> considered short-circuiting as they may<a id="_idIndexMarker1269"/> terminate. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.14</em> (<strong class="source-inline">TerminalOperations.java</strong>) presents <span class="No-Break">an example:</span></p>
			<div>
				<div id="_idContainer232" class="IMG---Figure">
					<img src="image/B19793_15_14.jpg" alt="Figure 15.14 – anyMatch(), allMatch(), and noneMatch() in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.14 – anyMatch(), allMatch(), and noneMatch() in code</p>
			<p>In this figure, we <a id="_idIndexMarker1270"/>define a finite stream of <strong class="source-inline">String</strong> names <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
List&lt;String&gt; names = Arrays.asList("Alan", "Brian", "Colin");</pre>			<p>A <a id="_idIndexMarker1271"/>predicate is defined to see if a name begins <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">"A"</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Predicate&lt;String&gt; pred = name -&gt; name.startsWith("A");</pre>			<p>We then stream the (source) list of names and check, using <strong class="source-inline">anyMatch()</strong>, if any of the names begin with <strong class="source-inline">"A"</strong> – as <strong class="source-inline">"Alan"</strong> does, <strong class="source-inline">true</strong> <span class="No-Break">is returned:</span></p>
			<pre class="source-code">
names.stream().anyMatch(pred); // true ("Alan")</pre>			<p>Next, we <a id="_idIndexMarker1272"/>re-stream the<a id="_idIndexMarker1273"/> list and check, using <strong class="source-inline">allMatch()</strong>, if all of the names begin with <strong class="source-inline">"A"</strong> – as <strong class="source-inline">"Brian"</strong> does not, <strong class="source-inline">false</strong> <span class="No-Break">is returned:</span></p>
			<pre class="source-code">
names.stream().allMatch(pred); // false ("Brian")</pre>			<p>We then <a id="_idIndexMarker1274"/>re-stream the list and check, using <strong class="source-inline">noneMatch()</strong>, if none of the names begin with <strong class="source-inline">"A"</strong> – as <strong class="source-inline">"Alan"</strong> does, <strong class="source-inline">false</strong> <span class="No-Break">is returned:</span></p>
			<pre class="source-code">
names.stream().noneMatch(pred);// false ("Alan")</pre>			<p>Notice that we have to<a id="_idIndexMarker1275"/> re-stream the source twice (for <strong class="source-inline">allMatch()</strong> and <strong class="source-inline">noneMatch()</strong>). This is because, once a terminal operation is performed, a stream is considered consumed and can no longer be used. If you need the same data, then you must return to the source and get a new stream. This is what we have done here. Attempting an operation on a closed source generates an <span class="No-Break"><strong class="source-inline">IllegalStateException</strong></span><span class="No-Break"> error.</span></p>
			<p>Let’s delve a little <a id="_idIndexMarker1276"/>deeper into the short-circuiting nature of these operations<a id="_idIndexMarker1277"/> when presented with infinite data. The following example (<span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.15</em>) presents code (<strong class="source-inline">TerminalOperations.java</strong>) where each of these <a id="_idIndexMarker1278"/>operations, given an infinite stream, may or may not terminate. Whether they terminate or<a id="_idIndexMarker1279"/> not is<a id="_idIndexMarker1280"/> determined by the data (and the predicate being<a id="_idIndexMarker1281"/> tested against <span class="No-Break">that data):</span></p>
			<div>
				<div id="_idContainer233" class="IMG---Figure">
					<img src="image/B19793_15_15.jpg" alt="Figure 15.15 – Short-circuiting nature of anyMatch(), allMatch(), and noneMatch() in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.15 – Short-circuiting nature of anyMatch(), allMatch(), and noneMatch() in code</p>
			<p>In this figure, we generated an infinite stream of <strong class="source-inline">"abc"</strong> strings and defined two predicates; one checks if the string begins with <strong class="source-inline">"a"</strong> and the other checks if the string begins with <strong class="source-inline">"b"</strong>. Note that, as explained previously, a closed stream must be reopened before being used. Therefore, lines 137-144 are <em class="italic">mutually exclusive</em> – you can only use one of them at a time. We have left them all uncommented as this aids the clarity of the diagram. When we run the code, we must comment out five of the <span class="No-Break">six lines.</span></p>
			<p><strong class="source-inline">infStr.anyMatch(startsWithA)</strong> checks if any of the strings start with <strong class="source-inline">"a"</strong> – as the first one does, it short-circuits <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">infStr.anyMatch(startsWithB)</strong> checks if any of the strings start with <strong class="source-inline">"b"</strong> – the first one does not, so it checks the next one; it does not either, and so on. We had to kill the program in <span class="No-Break">this instance.</span></p>
			<p><strong class="source-inline">infStr.noneMatch(startsWithA)</strong> checks if none of the strings start with <strong class="source-inline">"a"</strong> – as <strong class="source-inline">"abc"</strong> begins with <strong class="source-inline">"a"</strong>, <strong class="source-inline">noneMatch()</strong> short-circuits <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">infStr.noneMatch(startsWithB)</strong> checks if none of the strings start with <strong class="source-inline">"b"</strong> – the first one does not, so it checks the next one; it does not either, and so on. This goes on forever, so we had to kill the program. So, when does <strong class="source-inline">noneMatch()</strong> return <strong class="source-inline">true</strong>? If you have a finite <a id="_idIndexMarker1282"/>stream where none of the elements match the <span class="No-Break">given predicate.</span></p>
			<p><strong class="source-inline">infStr.allMatch(startsWithA)</strong> checks if all the<a id="_idIndexMarker1283"/> strings begin with <strong class="source-inline">"a"</strong>. In this<a id="_idIndexMarker1284"/> instance, this will <a id="_idIndexMarker1285"/>go on forever as we keep <a id="_idIndexMarker1286"/>generating strings that do begin with <strong class="source-inline">"a"</strong>, ensuring <strong class="source-inline">allMatch()</strong> needs to check the next one and <span class="No-Break">so on.</span></p>
			<p><strong class="source-inline">infStr.allMatch(startsWithB)</strong> can<a id="_idIndexMarker1287"/> short-circuit as <strong class="source-inline">"abc"</strong> does not begin with <strong class="source-inline">"b"</strong>, enabling <strong class="source-inline">allMatch()</strong> to <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-394"><a id="_idTextAnchor394"/>forEach()</h2>
			<p>As <strong class="source-inline">forEach(Consumer)</strong> has no return value (returns <strong class="source-inline">void</strong>), it is not considered a reduction. As it returns nothing, any <a id="_idIndexMarker1288"/>changes you wish to make <a id="_idIndexMarker1289"/>must occur inside <strong class="source-inline">Consumer</strong> as side effects. We covered several examples of <strong class="source-inline">forEach()</strong> already, so <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.16</em> (TerminalOperations.java) shows just a <span class="No-Break">simple one:</span></p>
			<div>
				<div id="_idContainer234" class="IMG---Figure">
					<img src="image/B19793_15_16.jpg" alt="Figure 15.16 – The forEach() terminal operation in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.16 – The forEach() terminal operation in code</p>
			<p>In this example, we are streaming a list of <em class="italic">strings</em>, representing peoples’ names and echoing them to <span class="No-Break">the screen.</span></p>
			<h2 id="_idParaDest-395"><a id="_idTextAnchor395"/>reduce()</h2>
			<p>The <strong class="source-inline">reduce()</strong> method combines a stream into a<a id="_idIndexMarker1290"/> single object. As it processes <a id="_idIndexMarker1291"/>all the elements, it is a reduction. There are three overloaded versions. We will discuss them in turn <span class="No-Break">with examples.</span></p>
			<h3>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</h3>
			<p>This is the most common way of doing a<a id="_idIndexMarker1292"/> reduction – start with an initial value (identity) and keep merging it with the next value. As well as the identity being the initial value, it is also the value returned if the stream is empty. This means that there will always be a result and thus <strong class="source-inline">Optional</strong> is not the return type (in <span class="No-Break">this version).</span></p>
			<p>The accumulator combines the current result with the current value in the stream. As it is a <strong class="source-inline">BinaryOperator</strong>, this means it is a function where the two inputs and the return type are all the <span class="No-Break">same type.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.17</em> (<strong class="source-inline">TerminalOperations.java</strong>) presents some examples to help <span class="No-Break">explain this:</span></p>
			<div>
				<div id="_idContainer235" class="IMG---Figure">
					<img src="image/B19793_15_17.jpg" alt="Figure 15.17 – T reduce(T identity, BinaryOperator&lt;T&gt; acc) in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.17 – T reduce(T identity, BinaryOperator&lt;T&gt; acc) in code</p>
			<p>Let us examine the first reduction in <span class="No-Break">this figure:</span></p>
			<pre class="source-code">
String name = Stream.of("s", "e", "a", "n")                    .reduce("", (s1, s2) -&gt; s1 + s2);
System.out.println(name);// sean</pre>
			<p>This reduction defines the empty string as the identity. This is both the string we start with and the string returned if the stream is empty. The accumulator takes in two strings, namely, <strong class="source-inline">s1</strong> and <strong class="source-inline">s2</strong>. The first time round, <strong class="source-inline">s1</strong> is <strong class="source-inline">""</strong> and <strong class="source-inline">s2</strong> is <strong class="source-inline">"s"</strong>, resulting in <strong class="source-inline">"s"</strong>. The next time round, <strong class="source-inline">s1</strong> is the result from the previous run, which is <strong class="source-inline">"s"</strong>, and <strong class="source-inline">s2</strong> is <strong class="source-inline">"e"</strong>, resulting in <strong class="source-inline">"se"</strong>. After that, <strong class="source-inline">s1</strong> is <strong class="source-inline">"se"</strong> and <strong class="source-inline">s2</strong> is <strong class="source-inline">"a"</strong>, resulting in <strong class="source-inline">"sea"</strong>. Finally, <strong class="source-inline">s1</strong> is <strong class="source-inline">"sea"</strong> and <strong class="source-inline">s2</strong> is <strong class="source-inline">"n"</strong>, resulting in <strong class="source-inline">"sean"</strong>. That’s how <span class="No-Break">accumulators work.</span></p>
			<p>The second reduction starts by re-streaming<a id="_idIndexMarker1293"/> <span class="No-Break">the source:</span></p>
			<pre class="source-code">
String name2 = Stream.of("s", "e", "a", "n")                .filter(s -&gt; s.length()&gt;2)
                .reduce("nothing", (s1, s2) -&gt; s1 + s2);
System.out.println(name2);// nothing</pre>
			<p>However, a <a id="_idIndexMarker1294"/>filter intermediate operation is applied. This filter ensures only strings with a length of <strong class="source-inline">&gt; 2</strong> are kept, resulting in an empty stream for <strong class="source-inline">reduce()</strong>. Thus, <strong class="source-inline">reduce()</strong> returns the <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">nothing"</strong></span><span class="No-Break"> identity.</span></p>
			<p>The last reduction gives another example of an identity and an accumulator <span class="No-Break">in action:</span></p>
			<pre class="source-code">
Integer product = Stream.of(2,3,4)                        .reduce(1, (n1, n2) -&gt; n1 * n2);
System.out.println(product);// 24</pre>
			<p>The sequence of values is <strong class="source-inline">n1</strong> is <strong class="source-inline">1</strong>, <strong class="source-inline">n2</strong> is <strong class="source-inline">2</strong>, and the result is <strong class="source-inline">2</strong>; <strong class="source-inline">n1</strong> is <strong class="source-inline">2</strong>, <strong class="source-inline">n2</strong> is <strong class="source-inline">3</strong>, and the result is <strong class="source-inline">6</strong>; <strong class="source-inline">n1</strong> is <strong class="source-inline">6</strong>, <strong class="source-inline">n2</strong> is <strong class="source-inline">4</strong> and the result <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">24</strong></span><span class="No-Break">.</span></p>
			<h3>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</h3>
			<p>This is very similar to the first version <a id="_idIndexMarker1295"/>except that no identity is provided. As no identity is provided, <strong class="source-inline">Optional</strong> is the return type (given that, the stream may be empty before this method is called). There are three <span class="No-Break">possible returns:</span></p>
			<ol>
				<li>An empty stream – results in an <span class="No-Break">empty </span><span class="No-Break"><strong class="source-inline">Optional</strong></span></li>
				<li>One element in the stream – that element is returned (<span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">Optional</strong></span><span class="No-Break">)</span></li>
				<li>Multiple elements in the stream – the accumulator <span class="No-Break">is applied</span></li>
			</ol>
			<p>Why are there two versions that are so similar? Why not just have the first version, with its identity? Well, there may be a situation, however unlikely, that the accumulator returns with the same value as the identity. In that scenario, you would not know whether the stream was empty (identity returned) or not (accumulator applied). This second version, with its use of <strong class="source-inline">Optional</strong>, ensures that you know when the stream <span class="No-Break">is empty.</span></p>
			<p>Now, let’s examine the third version <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">reduce()</strong></span><span class="No-Break">.</span></p>
			<h3>&lt;U&gt; reduce(U identity, BiFunction accumulator, BinaryOperator combiner)</h3>
			<p>This version is used when we are dealing with different types where intermediate reductions are created that are combined <a id="_idIndexMarker1296"/>at the end. This version is useful in parallel streams as the stream can be decomposed and reassembled by different threads. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.18</em> (<strong class="source-inline">TerminalOperations.java</strong>) presents an example <span class="No-Break">in code:</span></p>
			<div>
				<div id="_idContainer236" class="IMG---Figure">
					<img src="image/B19793_15_18.jpg" alt="Figure 15.18 - U reduce(U identity, BiFunction accumulator, BinaryOperator combiner) in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.18 - U reduce(U identity, BiFunction accumulator, BinaryOperator combiner) in code</p>
			<p>In this example, we are streaming a list of strings and we want to total the overall number of characters in all of the strings. The <strong class="source-inline">reduce()</strong> method is coded <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
   stream.reduce( 0,  // identity              (n, str) -&gt; n + str.length(), // n is Integer
              (n1, n2) -&gt; n1 + n2); // both are Integers</pre>
			<p>and has <span class="No-Break">3 elements:</span></p>
			<ul>
				<li>0 is the identity, which represents our <span class="No-Break">starting value.</span></li>
				<li><strong class="source-inline">(n, str) -&gt; n + str.length()</strong> is the <strong class="source-inline">BiFunction</strong> accumulator. In this case, the first parameter is <strong class="source-inline">Integer</strong> and the second parameter is <strong class="source-inline">String</strong>. The return type matches the first parameter – in other words, <strong class="source-inline">Integer</strong>. We did not highlight this in the method signature as all the letters can sometimes confuse the issue. This accumulator adds the length of the current <strong class="source-inline">String</strong> to the <span class="No-Break">current total.</span></li>
				<li><strong class="source-inline">(n1, n2) -&gt; n1 + n2</strong> represents the combiner <strong class="source-inline">BinaryOperator</strong> (a function where the types are the same). Its lambda simply adds the two numbers and returns the sum. This function adds the intermediate results from <span class="No-Break">the accumulators.</span></li>
			</ul>
			<p>Thus, with <a id="_idIndexMarker1297"/>parallel streams, one thread could return the accumulated value of 6, which is the sum of the lengths of <strong class="source-inline">"car"</strong> and <strong class="source-inline">"bus"</strong>, whereas another thread could return the accumulated value of 14, which is the sum of the lengths of <strong class="source-inline">"train"</strong> and <strong class="source-inline">"aeroplane"</strong>. These two values are then combined by the combiner, resulting <span class="No-Break">in 20.</span></p>
			<p>Now, we will move on to a powerful terminal operation, <span class="No-Break">namely </span><span class="No-Break"><strong class="source-inline">collect()</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-396"><a id="_idTextAnchor396"/>collect()</h2>
			<p>This is a special type of<a id="_idIndexMarker1298"/> reduction called a mutable reduction <a id="_idIndexMarker1299"/>because we are using the same mutable object while accumulating. This makes it more efficient than regular reductions. Common mutable objects include <strong class="source-inline">StringBuilder</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">ArrayList</strong></span><span class="No-Break">.</span></p>
			<p>This operation is extremely useful for getting data <strong class="bold">out</strong> of streams and putting it into other forms, such as a <strong class="source-inline">Map</strong>, <strong class="source-inline">List</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">Set</strong></span><span class="No-Break">.</span></p>
			<p>There are two versions – one that gives you complete control over the collecting process and another that gives you predefined collectors from the API. We will start with the first one, where you can specify <span class="No-Break">everything yourself.</span></p>
			<h3>collect(Supplier, BiConsumer, BiConsumer)</h3>
			<p>This method is best<a id="_idIndexMarker1300"/> explained with a code example, see <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.19</em>, which is taken from <strong class="source-inline">TerminalOperations.java</strong> on <span class="No-Break">the repo.</span></p>
			<div>
				<div id="_idContainer237" class="IMG---Figure">
					<img src="image/B19793_15_19.jpg" alt="Figure 15.19 – The collect(Supplier, BiConsumer, BiConsumer) operation in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.19 – The collect(Supplier, BiConsumer, BiConsumer) operation in code</p>
			<p>In this figure, we are building up one long word from a list of smaller words. Note that the equivalent method references (to the lambdas used), are in comments on the right-hand side of <span class="No-Break">each line.</span></p>
			<p>The first argument to <strong class="source-inline">collect()</strong> is a <strong class="source-inline">Supplier</strong> which specifies that we want to work with <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">StringBuilder</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
() -&gt; new StringBuilder()</pre>			<p>The <a id="_idIndexMarker1301"/>accumulator adds the current <strong class="source-inline">String</strong> to <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">StringBuilder</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
(sb, str) -&gt; sb.append(str)</pre>			<p>The combiner takes the two <strong class="source-inline">StringBuilder</strong>'s and <span class="No-Break">merges them:</span></p>
			<pre class="source-code">
(sb1, sb2) -&gt; sb1.append(sb2)</pre>			<p>This is useful in parallel processing, where different threads can perform accumulations and have their results combined. In this example, thread 1 could return <strong class="source-inline">"adjud"</strong>, the result of accumulating <strong class="source-inline">"ad"</strong> and <strong class="source-inline">"jud"</strong>; and thread 2 could return <strong class="source-inline">"icate"</strong>, the result of accumulating <strong class="source-inline">"i"</strong> and <strong class="source-inline">"cate"</strong>. These two results combine <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">"adjudicate"</strong></span><span class="No-Break">.</span></p>
			<p>Now, let’s look at the version of <strong class="source-inline">collect()</strong> where we pass in pre-defined <span class="No-Break">API collectors.</span></p>
			<h2 id="_idParaDest-397"><a id="_idTextAnchor397"/>collect(Collector)</h2>
			<p>This is the version that accepts a pre-defined API collector. We access these collectors via <strong class="source-inline">static</strong> methods in the <strong class="source-inline">Collectors</strong> class. These collectors do nothing on their own – they exist to be passed into the <span class="No-Break"><strong class="source-inline">collect(Collector)</strong></span><span class="No-Break"> method.</span></p>
			<p>We will examine many of them, particularly<a id="_idIndexMarker1302"/> the ones that help <a id="_idIndexMarker1303"/>us extract data out of the stream into collections for subsequent processing. In addition, we will look at how to group and partition information. Let’s start with some of the more <span class="No-Break">basic collectors.</span></p>
			<h3>Collectors.joining(CharSequence delimiter)</h3>
			<p>This collector returns a <strong class="source-inline">Collector</strong> that <a id="_idIndexMarker1304"/>concatenates the input elements, separated by the specified delimiter. The order of the stream is maintained. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.20</em> presents an example (taken from CollectorsExamples.java on <span class="No-Break">the repo).</span></p>
			<div>
				<div id="_idContainer238" class="IMG---Figure">
					<img src="image/B19793_15_20.jpg" alt="Figure 15.20 - Collectors.joining() in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.20 - Collectors.joining() in code</p>
			<p>In this example, the strings are appended together and delimited by <strong class="source-inline">", "</strong>.</p>
			<h3>Collectors.averagingInt(ToIntFunction)</h3>
			<p>This returns <a id="_idIndexMarker1305"/>a <strong class="source-inline">Collector</strong> that produces the average of the integers produced by the function supplied. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.21</em> (CollectorsExamples.java) presents <span class="No-Break">an example:</span></p>
			<div>
				<div id="_idContainer239" class="IMG---Figure">
					<img src="image/B19793_15_21.jpg" alt="Figure 15.21 – Collectors.averagingInt(ToIntFunction) in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.21 – Collectors.averagingInt(ToIntFunction) in code</p>
			<p>In this example, we are streaming strings, representing desserts. Each string has a length and we want to calculate the average of the lengths. The function, <strong class="source-inline">s -&gt; s.length()</strong> takes in a <strong class="source-inline">String</strong>, namely <strong class="source-inline">s</strong>, and returns its integer length. The method reference version is in a comment on the right. The average is <span class="No-Break">then output.</span></p>
			<p>Now, let’s examine how we can extract the stream contents into a <strong class="source-inline">List</strong>, <strong class="source-inline">Set</strong>, or <strong class="source-inline">Map</strong>. We will start <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">List</strong></span><span class="No-Break">.</span></p>
			<h3>Collectors.toList()</h3>
			<p>This returns a <strong class="source-inline">Collector</strong> operation that<a id="_idIndexMarker1306"/> accumulates the elements into a new <strong class="source-inline">List</strong>. There is no guarantee on the type of <strong class="source-inline">List</strong>. For example, there is no guarantee that the <strong class="source-inline">List</strong> is an <strong class="source-inline">ArrayList</strong> or a <strong class="source-inline">LinkedList</strong>. To gain that level of control, you must use the <strong class="source-inline">toCollection(Supplier)</strong> method (which we will be using in the <strong class="source-inline">Set</strong> example). <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.22</em> presents the <strong class="source-inline">Car</strong> type (<strong class="source-inline">CollectorsExamples.java</strong>) that we will use in the next <span class="No-Break">few examples:</span></p>
			<div>
				<div id="_idContainer240" class="IMG---Figure">
					<img src="image/B19793_15_22.jpg" alt="Figure 15.22 – The Car class"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.22 – The Car class</p>
			<p><span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.23</em> presents an example of <strong class="source-inline">Collectors.toList()</strong> in code (from <strong class="source-inline">CollectorsExamples.java</strong> in <span class="No-Break">the repo):</span></p>
			<div>
				<div id="_idContainer241" class="IMG---Figure">
					<img src="image/B19793_15_23.jpg" alt="Figure 15.23 – Collectors.toList() in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.23 – Collectors.toList() in code</p>
			<p>In this example, we added three <strong class="source-inline">Car</strong>s to our <strong class="source-inline">List</strong>. Recall that <strong class="source-inline">List</strong>s maintain insertion order. The <strong class="source-inline">map(Function)</strong> method is an intermediate operation that takes in one stream <a id="_idIndexMarker1307"/>and transforms it into another stream. We will discuss the <strong class="source-inline">map()</strong> method in more detail in <a href="B19793_16.xhtml#_idTextAnchor401"><span class="No-Break"><em class="italic">Chapter 16</em></span></a>, but for now, realize that there is <strong class="source-inline">Stream&lt;Car&gt;</strong> coming into <strong class="source-inline">map()</strong> and <strong class="source-inline">Stream&lt;String&gt;</strong> coming out. This is because <strong class="source-inline">brand</strong> in <strong class="source-inline">Car</strong> is a <strong class="source-inline">String</strong>. Now, we have a <strong class="source-inline">Stream&lt;String&gt;</strong> for <strong class="source-inline">collect()</strong> to extract in <span class="No-Break"><strong class="source-inline">List</strong></span><span class="No-Break"> format.</span></p>
			<p>As stated earlier, the implementation type is not guaranteed. What if we wanted a specific implementation and not just that, but an implementation that sorted the elements as they were added? <strong class="source-inline">TreeSet</strong> will do this. Let’s look at <span class="No-Break">that now.</span></p>
			<h3>Collectors.toSet() and Collectors.toCollection(Supplier)</h3>
			<p><strong class="source-inline">Collectors.toSet()</strong> returns a <strong class="source-inline">Collector</strong> that <a id="_idIndexMarker1308"/>accumulates the elements into a new <strong class="source-inline">Set</strong>. There is no guarantee on the<a id="_idIndexMarker1309"/> type of <strong class="source-inline">Set</strong>. In this example, however, we want a specific <strong class="source-inline">Set</strong>, namely <strong class="source-inline">TreeSet</strong>. We can use <strong class="source-inline">Collectors.toCollection(Supplier)</strong> when we want a specific implementation. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.24</em> presents the <span class="No-Break">code (</span><span class="No-Break"><strong class="source-inline">CollectorsExamples.java</strong></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer242" class="IMG---Figure">
					<img src="image/B19793_15_24.jpg" alt="Figure 15.24 – Collectors.toCollection(Supplier) in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.24 – Collectors.toCollection(Supplier) in code</p>
			<p>In this example, the cars have been deliberately added to our <strong class="source-inline">ArrayList</strong> in unsorted brand order. The following line is where the <span class="No-Break">magic happens:</span></p>
			<pre class="source-code">
.collect(Collectors.toCollection(TreeSet::new));</pre>			<p>We are passing in a <strong class="source-inline">Supplier</strong> method reference to create  a <strong class="source-inline">TreeSet</strong> that is, in<a id="_idIndexMarker1310"/> turn, passed to the <strong class="source-inline">Collectors.toCollection()</strong> method. This results in a <strong class="source-inline">TreeSet</strong> implementation. When <a id="_idIndexMarker1311"/>we output <strong class="source-inline">treeSet</strong> <span class="No-Break">we get:</span></p>
			<pre class="source-code">
[Audi, Ford, Tesla]</pre>			<p>Notice that the brands are now sorted alphabetically (the default sort order for strings). We can also extract data out of a stream into a <strong class="source-inline">Map</strong>. Let us examine <span class="No-Break">that now.</span></p>
			<h3>Collectors.toMap(Function keyMapper, Function valueMapper)</h3>
			<p>This returns a <strong class="source-inline">Collector</strong> that gathers <a id="_idIndexMarker1312"/>elements into a <strong class="source-inline">Map</strong> where the keys and values are the result of applying the provided mapping function to the stream elements. Again, there are no guarantees of the type of <strong class="source-inline">Map</strong> returned. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.25</em> presents an example in <span class="No-Break">code (</span><span class="No-Break"><strong class="source-inline">CollectorsExamples.java</strong></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer243" class="IMG---Figure">
					<img src="image/B19793_15_25.jpg" alt="Figure 15.25 – Collectors.toMap(Function keyMapper, Function valueMapper) in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.25 – Collectors.toMap(Function keyMapper, Function valueMapper) in code</p>
			<p>In this example, we are streaming a list of desserts (as strings). The declared <strong class="source-inline">Map</strong> states that our key is a <strong class="source-inline">String</strong> type and that the value is an <strong class="source-inline">Integer</strong> type. This is because we want to set up a <strong class="source-inline">Map</strong> so that the dessert name is the key and the number of characters in the dessert name is <span class="No-Break">the value.</span></p>
			<p>The keys in the <strong class="source-inline">Map</strong> are set up using the <span class="No-Break">following </span><span class="No-Break"><strong class="source-inline">Function</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
String::toString  // Function for key, same as: s -&gt; s</pre>			<p>Recall <a id="_idIndexMarker1313"/>that <strong class="source-inline">Function&lt;T, R&gt;</strong> takes in one parameter of type <strong class="source-inline">T</strong> and returns a result of type <strong class="source-inline">R</strong>. In this example, our function will be <strong class="source-inline">Function&lt;String, String&gt;</strong> as we are streaming a dessert (<strong class="source-inline">String</strong>) and this dessert is what we want to use as the key. We can simply use the lambda <strong class="source-inline">s -&gt; s</strong> or use the <strong class="source-inline">String::toString</strong> method reference. Either version <span class="No-Break">will work.</span></p>
			<p>The values in the Map are set up using the <span class="No-Break">following </span><span class="No-Break"><strong class="source-inline">Function</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
String::length     // Same as: s -&gt; s.length()</pre>			<p>Our function in this case is <strong class="source-inline">Function&lt;String, Integer&gt;</strong> as we want our function to return the length of the dessert. We can use the lambda <strong class="source-inline">s -&gt; s.length()</strong> or the <strong class="source-inline">String::length</strong> <span class="No-Break">method reference.</span></p>
			<p>The output that’s <span class="No-Break">generated is:</span></p>
			<pre class="source-code">
{biscuits=8, cake=4, apple tart=10}</pre>			<p>Before we present the next version, let’s look at an example that generates an exception. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.26</em> presents the example in <span class="No-Break">code (CollectorsExamples.java):</span></p>
			<div>
				<div id="_idContainer244" class="IMG---Figure">
					<img src="image/B19793_15_26.jpg" alt="Figure 15.26 – The Collectors.toMap(Function keyMapper, Function valueMapper) exception"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.26 – The Collectors.toMap(Function keyMapper, Function valueMapper) exception</p>
			<p>In this figure, we are trying to set up a <strong class="source-inline">Map</strong> where the key is the length of the dessert name and the <a id="_idIndexMarker1314"/>value is the dessert name itself. Note that the dessert names are subtly different from the previous figure. Now, instead of <strong class="source-inline">"apple tart"</strong>, we have <strong class="source-inline">"tart"</strong>. This is going to lead to problems. Maps cannot have duplicate keys and both <strong class="source-inline">"cake"</strong> and <strong class="source-inline">"tart"</strong> are 4 characters long. This leads to an <span class="No-Break"><strong class="source-inline">IllegalStateException</strong></span><span class="No-Break"> error.</span></p>
			<p>To fix this issue, we need to use the second version <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">toMap()</strong></span><span class="No-Break">.</span></p>
			<h3>Collectors.toMap(Function, Function, BinaryOperator mergeFunction)</h3>
			<p>This collector operates similarly to the previous collector, except when we encounter duplicate keys. In that scenario, the merge<a id="_idIndexMarker1315"/> function is applied to the <em class="italic">values</em>. The merge function is a <strong class="source-inline">BinaryOperator&lt;T</strong>,<strong class="source-inline">&gt;</strong>, which is-a <strong class="source-inline">BiFunction&lt;T,T,T&gt;</strong>. In other words, there are two inputs and one result, and they are all the same type. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.27</em> presents the code (<strong class="source-inline">CollectorsExamples.java</strong>) with the merge function present to handle <span class="No-Break">duplicate keys:</span></p>
			<div>
				<div id="_idContainer245" class="IMG---Figure">
					<img src="image/B19793_15_27.jpg" alt="Figure 15.27 – Collectors.toMap(Function, Function, BinaryOperator)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.27 – Collectors.toMap(Function, Function, BinaryOperator)</p>
			<p>In this example, the only difference is the <span class="No-Break">merge function:</span></p>
			<pre class="source-code">
(s1, s2) -&gt; s1 + "," + s2)</pre>			<p>The merge function takes in <strong class="source-inline">s1</strong> and <strong class="source-inline">s2</strong>, the values for the two colliding keys. In this example, the values are appended with a comma <span class="No-Break">between them.</span></p>
			<p>The output <span class="No-Break">generated is:</span></p>
			<pre class="source-code">
{4=cake,tart, 8=biscuits}</pre>			<p>The <a id="_idIndexMarker1316"/>colliding key was <strong class="source-inline">4</strong> and their values were <strong class="source-inline">"cake"</strong> and <strong class="source-inline">"tart"</strong>, resulting in <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">4=cake, tart"</strong></span><span class="No-Break">.</span></p>
			<p>The next version enables us to specify the <strong class="source-inline">Map</strong> implementation <span class="No-Break">we desire.</span></p>
			<h3>Collectors.toMap(Function, Function, BinaryOperator, Supplier mapFactory)</h3>
			<p>As we know, the <strong class="source-inline">Map</strong> implementations<a id="_idIndexMarker1317"/> that are returned are not guaranteed. You could get a <strong class="source-inline">HashMap</strong> or <strong class="source-inline">TreeMap</strong> implementation. This <strong class="source-inline">toMap()</strong> version is very similar to the previous one except there is an extra argument where we can specify our implementation type. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.28</em> presents the code (<strong class="source-inline">CollectorsExamples.java</strong>) with the constructor method reference used to ensure a <span class="No-Break"><strong class="source-inline">TreeMap</strong></span><span class="No-Break"> implementation:</span></p>
			<div>
				<div id="_idContainer246" class="IMG---Figure">
					<img src="image/B19793_15_28.jpg" alt="Figure 15.28 – Collectors.toMap(Function, Function, BinaryOperator, Supplier)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.28 – Collectors.toMap(Function, Function, BinaryOperator, Supplier)</p>
			<p>In this figure, the dessert name is the key and the length of the dessert name is the value. <strong class="source-inline">"cake"</strong> is in the source twice, causing a duplicate keys issue and a reason to invoke the merge function. In this instance, the values for the duplicate keys are to be added. As <strong class="source-inline">"cake"</strong> appears just twice, this means that <strong class="source-inline">"cake=8"</strong> will be <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">Map</strong></span><span class="No-Break">.</span></p>
			<p>In this <a id="_idIndexMarker1318"/>example, we want a <strong class="source-inline">TreeMap</strong> implementation. To ensure this, we specify an extra argument, the <span class="No-Break">following </span><span class="No-Break"><strong class="source-inline">Supplier</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
   TreeMap::new</pre>			<p>Thus, our keys will be sorted. When we output our map we can see that the keys are alphabetically sorted, <span class="No-Break">as expected:</span></p>
			<pre class="source-code">
   {apple tart=10, biscuits=8, cake=8}</pre>			<p>Also, note that <strong class="source-inline">"cake"</strong> maps to 8 (4 + <span class="No-Break">4).</span></p>
			<p>We can also use the <strong class="source-inline">getClass()</strong> method to prove that we have indeed a <span class="No-Break"><strong class="source-inline">TreeMap</strong></span><span class="No-Break"> implementation:</span></p>
			<pre class="source-code">
   System.out.println(map.getClass());// java.util.TreeMap</pre>			<p>Now, let’s examine the <strong class="source-inline">groupingBy</strong> <span class="No-Break">terminal operations.</span></p>
			<h3>Collectors.groupingBy(Function classifier)</h3>
			<p>The <strong class="source-inline">groupingBy()</strong> operation tells <strong class="source-inline">collect()</strong> to group all the elements into a <strong class="source-inline">Map</strong> implementation. The <strong class="source-inline">Function</strong> parameter <a id="_idIndexMarker1319"/>determines the keys in <strong class="source-inline">Map</strong>. The values are a <strong class="source-inline">List</strong> (the default) of all entries that match that key. Having the values returned as a <strong class="source-inline">List</strong> can, as we shall see, be changed. There is no guarantee as to the <strong class="source-inline">Map</strong> or <strong class="source-inline">List</strong> implementations used. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.29</em> presents an example in code, taken from <strong class="source-inline">CollectorsExamples.java</strong> in <span class="No-Break">the repo:</span></p>
			<div>
				<div id="_idContainer247" class="IMG---Figure">
					<img src="image/B19793_15_29.jpg" alt="Figure 15.29 – Collectors.groupingBy(Function) in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.29 – Collectors.groupingBy(Function) in code</p>
			<p>In this example, we are streaming a list of names and are extracting a <strong class="source-inline">Map&lt;Integer, List&lt;String&gt;</strong> from the stream (as per the declaration). The <strong class="source-inline">Function</strong> parameter <strong class="source-inline">String::length</strong> that’s passed into <strong class="source-inline">groupingBy()</strong>, tells <strong class="source-inline">collect()</strong> that the key in the map is the length of the <strong class="source-inline">String</strong> (in effect, the number of characters in the name). The values are organized into a <strong class="source-inline">List</strong>, and each<a id="_idIndexMarker1320"/> entry in the list is a <strong class="source-inline">String</strong>  where the length of the <strong class="source-inline">String</strong> matches the key. For example, as per <span class="No-Break">the output:</span></p>
			<pre class="source-code">
   {3=[Tom, Tom, Ann], 5=[Peter], 6=[Martin]}</pre>			<p> <strong class="source-inline">5</strong> maps to <strong class="source-inline">"Peter"</strong> and <strong class="source-inline">6</strong> maps to <strong class="source-inline">"Martin"</strong>. Note that in the output, <strong class="source-inline">"Tom"</strong> appears in the list twice. This is because lists <span class="No-Break">allow duplicates.</span></p>
			<p>What if we wanted <strong class="source-inline">"Tom"</strong> to appear only once in the output list? There is an overloaded version of <strong class="source-inline">groupingBy()</strong> that will help <span class="No-Break">us here.</span></p>
			<h3>Collectors.groupingBy(Function keyMapper, Collector downstreamCollector)</h3>
			<p>Recall that a <strong class="source-inline">Set</strong> implementation does not <a id="_idIndexMarker1321"/>allow duplicates, so using a <strong class="source-inline">Set</strong> implementation for the values, as opposed to the default <strong class="source-inline">List</strong>, will solve this. The second parameter here is known as a <em class="italic">downstream collector</em>. The function<a id="_idIndexMarker1322"/> of a downstream collector is to do something special with the <em class="italic">values</em>. In this example, we want the values organized as a <strong class="source-inline">Set</strong> implementation. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.30</em> presents the code (<span class="No-Break"><strong class="source-inline">CollectorsExamples.java</strong></span><span class="No-Break">) adjustments:</span></p>
			<div>
				<div id="_idContainer248" class="IMG---Figure">
					<img src="image/B19793_15_30.jpg" alt="Figure 15.30 – Using Collectors.groupingBy(Function, Collector) for a Set implementation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.30 – Using Collectors.groupingBy(Function, Collector) for a Set implementation</p>
			<p>In this example, the type for the values in the <strong class="source-inline">Map</strong> is <strong class="source-inline">Set&lt;String&gt;</strong> and not  <strong class="source-inline">List&lt;String&gt;</strong>. The <span class="No-Break">downstream</span><span class="No-Break"><a id="_idIndexMarker1323"/></span><span class="No-Break"> collector:</span></p>
			<pre class="source-code">
   Collectors.toSet()</pre>			<p>states that we want the values organized as a <strong class="source-inline">Set</strong>. The output shows that <strong class="source-inline">"Tom"</strong> is now listed <span class="No-Break">only once:</span></p>
			<pre class="source-code">
   {3=[Ann, Tom], 5=[Peter], 6=[Martin]}</pre>			<p>Note that the implementation type for our <strong class="source-inline">Map</strong> happens to be a <span class="No-Break"><strong class="source-inline">HashMap</strong></span><span class="No-Break"> implementation:</span></p>
			<pre class="source-code">
   System.out.println(map.getClass());// java.util.HashMap</pre>			<p>This implementation is not guaranteed. What if we wanted to guarantee a <strong class="source-inline">TreeMap</strong> implementation? There is an overloaded version to help us <span class="No-Break">here also.</span></p>
			<h3>Collectors.groupingBy(Function, Supplier mapFactory, Collector)</h3>
			<p>This version accepts a <strong class="source-inline">Supplier</strong> as its <a id="_idIndexMarker1324"/>second parameter. This <strong class="source-inline">Supplier</strong> returns the implementation that <span class="No-Break">you desire.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.31</em> presents the code <span class="No-Break">adjustments (</span><span class="No-Break"><strong class="source-inline">CollectorsExamples.java</strong></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer249" class="IMG---Figure">
					<img src="image/B19793_15_31.jpg" alt="Figure 15.31 – Using Collectors.groupingBy(Function, Supplier, Collector) for a TreeMap implementation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.31 – Using Collectors.groupingBy(Function, Supplier, Collector) for a TreeMap implementation</p>
			<p>In this example, we are reverting to a <strong class="source-inline">List</strong> type for <span class="No-Break">the values:</span></p>
			<pre class="source-code">
Map&lt;Integer, List&lt;String&gt;&gt; map</pre>			<p>To extract the stream data as a <strong class="source-inline">List</strong> type, we must use the appropriate <span class="No-Break">downstream collector:</span></p>
			<pre class="source-code">
Collectors.toList()</pre>			<p>As can be <a id="_idIndexMarker1325"/>seen from <span class="No-Break">the output:</span></p>
			<pre class="source-code">
{3=[Tom, Tom, Ann], 5=[Peter], 6=[Martin]}</pre>			<p><strong class="source-inline">"Tom"</strong> is now duplicated again (as lists <span class="No-Break">allow duplicates).</span></p>
			<p>We also pass a <strong class="source-inline">Supplier</strong> argument to <strong class="source-inline">groupingBy()</strong>, stating we want a <span class="No-Break"><strong class="source-inline">TreeMap</strong></span><span class="No-Break"> implementation:</span></p>
			<pre class="source-code">
TreeMap::new</pre>			<p>The <strong class="source-inline">map.getClass()</strong> <span class="No-Break">call outputs:</span></p>
			<pre class="source-code">
java.util.TreeMap</pre>			<p>showing that we have a <span class="No-Break"><strong class="source-inline">TreeMap</strong></span><span class="No-Break"> implementation.</span></p>
			<p>We will now look at a special case of grouping, <span class="No-Break">called partitioning.</span></p>
			<h3>Collectors.partitioningBy(Predicate)</h3>
			<p>Partitioning is a special case of grouping <a id="_idIndexMarker1326"/>where there are only two groups – true and false. Thus, the keys in the <strong class="source-inline">Map</strong> implementation will be of the <strong class="source-inline">Boolean</strong> type. The values will default to a <strong class="source-inline">List</strong> type. There is no guarantee as to the <strong class="source-inline">Map</strong> or <strong class="source-inline">List</strong> <span class="No-Break">implementations returned.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.32</em> presents a code <span class="No-Break">example (CollectorsExamples.java):</span></p>
			<div>
				<div id="_idContainer250" class="IMG---Figure">
					<img src="image/B19793_15_32.jpg" alt="Figure 15.32 – Collectors.partitioningBy(Predicate) in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.32 – Collectors.partitioningBy(Predicate) in code</p>
			<p>In this figure, we are extracting data from the stream into a <strong class="source-inline">Map&lt;Boolean, List&lt;String&gt;</strong>. The keys will be true and false. The values will be the elements in the stream that are either true or false based on the <span class="No-Break">predicate provided.</span></p>
			<p>Using the following line of code, we tell <strong class="source-inline">collect()</strong> to partition the stream based on whether the <strong class="source-inline">String</strong> name begins <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">"T"</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
   Collectors.partitioningBy(s -&gt; s.startsWith("T"))</pre>			<p>As can be seen from <span class="No-Break">the output:</span></p>
			<pre class="source-code">
   {false=[Mike, Alan, Peter, Alan], true=[Thomas, Teresa]}</pre>			<p>the true partition contains <strong class="source-inline">"Thomas"</strong> and <strong class="source-inline">"Teresa"</strong> and the false partition contains all the other names. Note that <strong class="source-inline">"Alan"</strong> is in the false partition twice, as lists <span class="No-Break">allow duplicates.</span></p>
			<p>There is an overloaded version of <strong class="source-inline">partitioningBy()</strong> that enables us to pass in a <span class="No-Break">downstream collector.</span></p>
			<h3>Collectors.partitioningBy(Predicate, Collector downstreamCollector)</h3>
			<p>A downstream collector is useful for <a id="_idIndexMarker1327"/>specifying a different collection for our values. For example, instead of a <strong class="source-inline">List</strong> view, we may want a <strong class="source-inline">Set</strong> view so that duplicates are automatically removed. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.33</em> presents a code <span class="No-Break">example (CollectorsExamples.java):</span></p>
			<div>
				<div id="_idContainer251" class="IMG---Figure">
					<img src="image/B19793_15_33.jpg" alt="Figure 15.33 – Collectors.partitioningBy(Predicate, Collector) in code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.33 – Collectors.partitioningBy(Predicate, Collector) in code</p>
			<p>In this example, note that the name <strong class="source-inline">"Alan"</strong> is in the <span class="No-Break">source twice:</span></p>
			<pre class="source-code">
Stream.of("Alan", "Teresa", "Mike", "Alan", "Peter");</pre>			<p>In addition, we are collecting data into a <span class="No-Break"><strong class="source-inline">Map&lt;Boolean, </strong></span><span class="No-Break"><em class="italic">Set</em></span><span class="No-Break"><strong class="source-inline">&lt;String&gt;&gt;</strong></span><span class="No-Break">.</span></p>
			<p>We also changed the predicate just to do <span class="No-Break">something different:</span></p>
			<pre class="source-code">
s -&gt; s.length() &gt; 4,// predicate</pre>			<p>Thus, if the number of characters in the string is <strong class="source-inline">&gt; 4</strong>, the string is placed in the true partition; otherwise, the string is placed in the <span class="No-Break">false partition.</span></p>
			<p>We specify the required downstream collector <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Collectors.toSet()</pre>			<p>This means that the values are to be returned as a <strong class="source-inline">Set</strong>. As can be seen in the output, <strong class="source-inline">"Alan"</strong> appears only once (in the <span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break"> partition):</span></p>
			<pre class="source-code">
{false=[Mike, Alan], true=[Teresa, Peter]}</pre>			<p>That completes our discussion on the terminal operations section and also concludes <a href="B19793_15.xhtml#_idTextAnchor377"><span class="No-Break"><em class="italic">Chapter 15</em></span></a>. Now, let’s put that knowledge into practice to reinforce the concepts <span class="No-Break">we’ve learned.</span></p>
			<h1 id="_idParaDest-398"><a id="_idTextAnchor398"/>Exercises</h1>
			<ol>
				<li>Create a stream of dinosaur names (use a List or an array). Use the <strong class="source-inline">filter</strong> method to create a new stream that only includes the names of carnivorous dinosaurs. Then, use the <strong class="source-inline">forEach</strong> method to print out <span class="No-Break">these names.</span><span class="No-Break">.</span></li>
				<li>Demonstrate stream laziness by creating a stream from a list of dinosaur ages. Use the <strong class="source-inline">filter</strong> method to filter out ages greater than 100, and then use a <strong class="source-inline">map</strong> method to increase each remaining age by 10. However, do not use any terminal operation. Explain why nothing is printed or no operation is performed until a terminal operation (like <strong class="source-inline">forEach</strong>) <span class="No-Break">is called.</span><span class="No-Break">.</span></li>
				<li>Using a stream of dinosaur weights (as doubles), count the number of dinosaurs that weigh more than 5000 kg using the filter and count <span class="No-Break">terminal operations.</span></li>
				<li>Given a stream of dinosaur species names (String), use the <strong class="source-inline">findFirst</strong> terminal operation to retrieve the first name on <span class="No-Break">the list.</span></li>
			</ol>
			<h1 id="_idParaDest-399"><a id="_idTextAnchor399"/>Project – dynamic dinosaur care system</h1>
			<p>Integrate the <a id="_idIndexMarker1328"/>Stream API into your dinosaur care system to process large volumes of dinosaur data, such as health records, feeding schedules, and so on. The system should also incorporate <strong class="source-inline">Optional</strong> and parallel streams where appropriate, optimizing data processing and minimizing potential null <span class="No-Break">pointer exceptions.</span></p>
			<p>Here are the steps to get <span class="No-Break">you there:</span></p>
			<ol>
				<li><strong class="bold">Set up your project</strong>: If you haven’t done so already, create a new Java project in your IDE of choice. You should have a <strong class="source-inline">Dinosaur</strong> class with properties such as <strong class="source-inline">name</strong>, <strong class="source-inline">species</strong>, <strong class="source-inline">healthStatus</strong>, and so on. There should also be a <strong class="source-inline">DinosaurCareSystem</strong> class for implementing the <span class="No-Break">main functionalities.</span></li>
				<li><strong class="bold">  Use streams to process </strong><span class="No-Break"><strong class="bold">dinosaur data</strong></span><span class="No-Break">:</span><ol><li class="upper-roman"><strong class="bold">Health records</strong>: Suppose you have a list of health records for each dinosaur and you want to find records where a dinosaur’s health status was below a certain threshold. You <a id="_idIndexMarker1329"/>could create a <strong class="source-inline">Stream</strong> from the list of records and use the <strong class="source-inline">filter</strong> method to get these records. Here’s an example: <strong class="source-inline">List&lt;HealthRecord&gt; criticalRecords = records.stream().filter(r -&gt; r.getHealthStatus() &lt; </strong><span class="No-Break"><strong class="source-inline">CRITICAL_THRESHOLD).collect(Collectors.toList())</strong></span><span class="No-Break">.</span></li><li class="upper-roman"><strong class="bold">Feeding schedules</strong>: Maybe you want to find out all the feeding schedules within a certain period. Again, you can use a <strong class="source-inline">Stream</strong> to filter the schedules. Here’s an example: <strong class="source-inline">List&lt;FeedingSchedule&gt; morningFeeds = schedules.stream().filter(s -&gt; </strong><span class="No-Break"><strong class="source-inline">s.getTime().isBefore(LocalTime.NOON)).collect(Collectors.toList())</strong></span><span class="No-Break">.</span></li></ol></li>
				<li><strong class="bold">Use Optional to avoid </strong><strong class="source-inline">NullPointerException</strong><strong class="bold"> errors</strong>: Let’s say each dinosaur has a trainer field that could be null. When trying to access the trainer’s name, use <strong class="source-inline">Optional</strong> to avoid a <strong class="source-inline">NullPointerException</strong> error. Here’s an example: <strong class="source-inline">Optional.ofNullable(dinosaur.getTrainer()).map(Trainer::getName).orElse("No </strong><span class="No-Break"><strong class="source-inline">trainer assigned").</strong></span></li>
				<li><strong class="bold">Use parallel streams to process large amounts of data</strong>: If the number of health records or<a id="_idIndexMarker1330"/> feeding schedules is very large, you could use parallel streams to speed up the processing. This is as simple as replacing <strong class="source-inline">stream()</strong> with <strong class="source-inline">parallelStream()</strong> in the previous examples. Be aware, though, that not every problem is suitable for parallel processing. If the tasks have dependencies or need to be processed in a specific order, stick with <span class="No-Break">regular streams.</span></li>
			</ol>
			<h1 id="_idParaDest-400"><a id="_idTextAnchor400"/>Summary</h1>
			<p>In this chapter, we explored the fundamentals of streams and stream terminal operations. Streams (along with lambda expressions) enable a style of programming known as functional-style programming, where you state what you want to solve rather than how to solve it (imperative style). Functional-style programming tends to be  easier to read because, with imperative programming, the details of how to solve the problem can get mixed up in <span class="No-Break">the implementation.</span></p>
			<p>We discussed stream pipelines using the analogy of an assembly line. A stream pipeline consists of a data source, zero or more intermediate operations, and a terminal operation, in that order. Streams are lazily evaluated, which means that data is only provided as and when needed. This is possible because the JVM has an overall view of the pipeline, as nothing happens until the terminal operation <span class="No-Break">is executed.</span></p>
			<p>Stream sources can vary from arrays (<strong class="source-inline">Arrays.stream(arrayToUse)</strong>), collections (<strong class="source-inline">collectionToUse.stream()</strong>), and files (<strong class="source-inline">Files.lines(Path)</strong>) to a variable number of arguments (<strong class="source-inline">Stream.of(varargs)</strong>). Infinite streams can be generated using two <strong class="source-inline">static</strong> methods from the Stream API: <strong class="source-inline">Stream.generate()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Stream.iterate()</strong></span><span class="No-Break">.</span></p>
			<p>Terminal operations kickstart the whole pipeline and every pipeline must have a terminal operation. Once a terminal operation executes on a stream, the stream is closed and must be re-streamed to be reused. Popular terminal operations include <strong class="source-inline">forEach()</strong>, <strong class="source-inline">count()</strong>, <strong class="source-inline">min()</strong>, <strong class="source-inline">max()</strong>, <strong class="source-inline">findAny()</strong>, <strong class="source-inline">findFirst()</strong>, <strong class="source-inline">allMatch()</strong>, <strong class="source-inline">anyMatch()</strong>, <strong class="source-inline">noneMatch()</strong>, <strong class="source-inline">reduce()</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">collect()</strong></span><span class="No-Break">.</span></p>
			<p>A reduction is a special type of terminal operation where all of the stream items are combined into one primitive or <strong class="source-inline">Object</strong>. The <strong class="source-inline">reduce()</strong> method has overloaded versions to facilitate this. The <strong class="source-inline">collect()</strong> method is very useful for extracting data out of the stream and into a collection, such as a <strong class="source-inline">List</strong> or <strong class="source-inline">Map</strong> delete The <strong class="source-inline">collect()</strong> method accepts collectors, which you can define yourself, or you can simply use one of the many pre-defined collectors in <span class="No-Break">the API.</span></p>
			<p>That completes our discussion on the fundamentals of streams. In the next chapter, we will expand into more advanced <span class="No-Break">streaming concepts.</span></p>
		</div>
	</body></html>