<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Accessing a Database with Spring and JDBC Template Patterns</h1>
                </header>
            
            <article>
                
<p>In earlier chapters, you learned about Spring core modules like the Spring IoC container, the DI pattern, container life cycle, and the used design patterns. Also you have seen how Spring makes magic using AOP. Now is the right time to move into the battlefield of <span>real</span> Spring applications with persisting data. Do you remember your first application during college days where you dealt with database access? That time, you probably, had to write boring boilerplate code to load database drivers, initialize your data-access framework, open connections, handle various exceptions, and to close connections. You also had to be very careful about that code. If anything went wrong, you would not have been able to make a database connection in your application, even though you would've invested a lot of time in such boring code, apart from writing the actual SQL and business code.</p>
<p>Because we always try to make things better and simpler, we have to focus on the solution to that tedious work for data-access. Spring comes with a solution for the tedious and boring work for data-access--it removes the code of data access. Spring provides data-access frameworks to integrate with a variety of data-access technologies. It allows you to use either JDBC directly or any <strong>object-relational mapping</strong> (<strong>ORM</strong>) framework, like Hibernate, to persist your data. Spring handles all the low-level code for data access work in your application; you can just write your SQL, application logic, and manage your application's data rather than investing time in writing code for making and closing database connections, and so on.</p>
<p>Now, you can choose any technology, such as JDBC, Hibernate, the <strong>Java Persistence API</strong> (<strong>JPA</strong>), or others. to persist your application's data. Irrespective of what you choose, Spring provides support for all these technologies for your application. In this chapter, we will explore Spring's support for JDBC. It will cover the following points:</p>
<ul>
<li>The best approach to designing your data access</li>
<li>Implementing the template design pattern</li>
<li>Problems with the traditional JDBC</li>
<li>Solving problems with the Spring <kbd>JdbcTemplate</kbd></li>
<li>Configuring the data source</li>
<li>Using the object pool design pattern to maintain database connections</li>
<li>Abstracting database access by the DAO pattern</li>
<li>Working with <kbd>JdbcTemplate</kbd></li>
<li>The Jdbc callback interfaces</li>
<li>Best practices for configuring <kbd>JdbcTemplate</kbd> in the application</li>
</ul>
<p>Before we go on to discuss more about JDBC and the template design pattern, let's first see the best approach to define the data-access tier in the layered architecture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The best approach to designing your data-access</h1>
                </header>
            
            <article>
                
<p>In previous chapters, you have seen that one of Spring's goals is to allow you to develop applications by following one of the OOPs principles of coding to interfaces. Any enterprise application needs to read data and write data to any kind of database, and to meet this requirement, we have to write the persistence logic. Spring allows you to avoid the scattering of persistence logic across all the modules in your application. For this, we can create a different component for data access and persistence logic, and this component is known as a <strong>data access object</strong> (<strong>DAO</strong>). Let's see, in the following diagram, the best approach to create modules in layered applications:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="267" width="166" class=" image-border" src="assets/e991c260-af90-4b2f-8686-622410d96461.png"/></div>
<p>As you can see in the preceding diagram, for a better approach, many enterprise applications consist of the following three logical layers:</p>
<ul>
<li><strong>The service layer</strong> (or application layer): This layer of the application exposes high-level application functions like use-cases and business logic. All application services are defined here.</li>
<li><strong>The data access layer</strong>: This layer of the application defines an interface to the application's data repository (such as a Relational or NoSQL database). This layer has the classes and interfaces which have the data-access logic's data persisting in the application.</li>
<li><strong>The infrastructure layer</strong>: This layer of the application exposes low-level services to the other layers, such as configuring DataSource by using the database URL, user credentials, and so on. Such configuration comes under this layer.</li>
</ul>
<p>In the previous figure, you can see that the <strong>Service Layer</strong> collaborates with the <strong>Data Access Layer</strong>. To avoid coupling between the application logic and data-access logic, we should expose their functionality through interfaces, as interfaces promote decoupling between the collaborating components. If we use the data-access logic by implementing interfaces, we can configure any particular data-access strategy to the application without making any changes in the application logic in the <strong>Service Layer</strong>. The following diagram shows the proper approach to designing our data-access layer:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="172" width="338" class=" image-border" src="assets/44d71d81-d448-4266-ad80-3c19a09c6b64.png"/></div>
<p>As shown in the preceding figure, your application service objects, that is, <strong>TransferService</strong>, don't handle their own data access. Instead, they delegate data access to the repositories. The repository's interface, that is, <strong>AccountRepository</strong> in your application, keeps it loosely coupled to the service object. You could configure any variant of the implementations-either the Jpa implementation of <strong>AccountRepository</strong> (<strong>JpaAccountRepository</strong>), or the Jdbc implementation of <strong>AccountRepository</strong> (<strong>JdbcAccountRepository</strong>).</p>
<p>Spring not only provides loose coupling between the application components working at the different layers in the layered architecture, but also helps to manage the resources in the enterprise layered architecture application. Let's see how Spring manages the resources, and what design pattern is using by Spring to solve the resource management problem.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The resource management problem</h1>
                </header>
            
            <article>
                
<p>Let's understand the resource management problem with the help of a real example. You must've ordered pizza online sometime. If so, what are the steps involved in the process, from the time of ordering the pizza till its delivery? There are many steps to this process--We first go to the online portal of the pizza company, select the size of the pizza and the toppings. After that, we place our order and check out. The order is accepted by the nearest pizza shop; they prepare our pizza accordingly, put the toppings on accordingly, wrap this pizza in the bag, the delivery boy comes to your place and hands over the pizza to you, and, finally, you enjoy your pizza with your friend. Even though there are many steps to this process, you're actively involved in only a couple of them. The pizza company is responsible for cooking the pizza and delivering it smoothly. You are involved only when you need to be, and other steps are taken care of by the pizza company. As you saw in this example, there are many steps involved in managing this process, and we also have to assign the resources to each step accordingly such that it is treated as a complete task without any break in the flow. This is a perfect scenario for a powerful design pattern, the template method pattern. The Spring framework implements this template design pattern to handle such type scenarios in the DAO layer of an application. Let's see what problems we face if we don't use Spring, and work with the traditional application instead.</p>
<p>In a traditional application, we work with the JDBC API to access the data from the database. It is a simple application where we access and persist the data using the JDBC API, and for this application, the following steps are required:</p>
<ol>
<li>Define the connection parameters.</li>
<li>Access a data source, and establish a connection.</li>
<li>Begin a transaction.</li>
<li>Specify the SQL statement.</li>
<li>Declare the parameters, and provide parameter values.</li>
<li>Prepare and execute the statement.</li>
<li>Set up the loop to iterate through the results.</li>
<li>Do the work for each iteration--execute the business logic.</li>
<li>Process any exception.</li>
<li>Commit or roll back the transaction.</li>
<li>Close the connection, statement, and resultset.</li>
</ol>
<p>If you use the Spring Framework for the same application, then you have to write the code for some steps of the preceding list of steps, while spring takes care of all the steps involving the low-level processes such as establishing a connection, beginning a transaction, processing any exception in the data layer, and closing the connection. Spring manages these steps by using the Template method design pattern, which we'll study in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the template design pattern</h1>
                </header>
            
            <article>
                
<div class="packt_quote">Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.</div>
<div class="packt_quote">-GOF Design Pattern</div>
<p>We discussed the Template method design pattern in <a href="bd05acbb-a42a-4070-9e01-54a8ce049e41.xhtml" target="_blank">Chapter 3</a>, <em>Consideration of Structural and Behavioral Patterns</em>. It is widely used, and comes under the structural design pattern of the GOF design pattern family. This pattern defines the outline or skeleton of an algorithm, and leaves the details to specific implementations later. This pattern hides away large amounts of boilerplate code. Spring provides many template classes, such as <kbd>JdbcTemplate</kbd>, <kbd>JmsTemplate</kbd>, <kbd>RestTemplate</kbd>, and <kbd>WebServiceTemplate</kbd>. Mostly, this pattern hides the low-level resource management as discussed earlier in the pizza example.</p>
<p>In the example, the process is ordering a pizza for home delivery from an online portal. The process followed by the pizza company has some fixed steps for each customer, like taking the order, preparing the pizza, adding the toppings according to the customer's specifications, and delivering it to the customer's address. We can add these steps, or define these steps to a specific algorithm. The system can then implement this algorithm accordingly.</p>
<p>Spring implements this pattern to access data from a database. In a database, or any other technology, there are some steps that are always common, such as establishing a connection to the database, handling transactions, handling exceptions, and some clean up actions which are required for each data access process. But there are also some steps which are not fixed, but depend on the application's requirement. It is the responsibility of the developer to define these steps. But spring allows us to separate the fixed and dynamic parts of the data-access process into different parts as templates and callbacks. All fixed steps come under the template, and dynamic custom steps come under callbacks. The following figure describes the two in detail:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="192" width="404" class=" image-border" src="assets/8047e98e-4603-4f21-b4f4-a0d9b28f703c.png"/></div>
<p>As you can see in the preceding figure, all the fixed parts of the process for data access wraps to the template classes of the Spring Framework as open and close connection, open and close statements, handling exceptions, and managing resources. But the other steps like writing SQLs, declaring connection parameters, and so on are parts of the callbacks, and callbacks are handled by the developer.</p>
<p>Spring provides several implementations of the Template method design pattern such as <kbd>JdbcTemplate</kbd>, <kbd>JmsTemplate</kbd>, <kbd>RestTemplate</kbd>, and <kbd>WebServiceTemplate</kbd>, but in this chapter, I will explain only its implementation for the JDBC API as <kbd>JdbcTemplate</kbd>. There is another variant of <kbd>JdbcTemplate-NamedParameterJdbcTemplate</kbd>, which wraps a <kbd>JdbcTemplate</kbd> to provide named parameters instead of the traditional JDBC "<kbd>?</kbd>" placeholders.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Problems with the traditional JDBC</h1>
                </header>
            
            <article>
                
<p>The following are the problems we have to face whenever we work with the traditional JDBC API:</p>
<ul>
<li><strong>Redundant results due to error-prone code</strong>: The traditional JDBC API required a lot of tedious code to work with the data access layer. Let's see the following code to connect the Database and execute the desired query:</li>
</ul>
<pre>        public List&lt;Account&gt; findByAccountNumber(Long accountNumber) { 
          List&lt;Account&gt; accountList = new ArrayList&lt;Account&gt;(); 
          Connection conn = null; 
          String sql = "select account_name,<br/>          account_balance from ACCOUNT where account_number=?"; 
          try { 
            DataSource dataSource = DataSourceUtils.getDataSource(); 
            conn = dataSource.getConnection(); 
            PreparedStatement ps = conn.prepareStatement(sql); 
            ps.setLong(1, accountNumber); 
            ResultSet rs = ps.executeQuery(); 
            while (rs.next()) { 
              accountList.add(new Account(rs.getString(<br/>                "account_name"), ...)); 
            } 
          } catch (SQLException e) { /* what to be handle here? */ } 
          finally { 
            try { 
              conn.close(); 
            } catch (SQLException e) { /* what to be handle here ?*/ } 
          } 
          return accountList; 
        } </pre>
<p>As you can see in the preceding code, there are some lines which are highlighted; only this bold code matters-the rest is boilerplate. Also, this code handles the SQLException in the application inefficiently, because the developer doesn't know what should be handled there. Let's now look at another problem in the traditional JDBC code.</p>
<ul>
<li><strong>Leads to poor exception handling</strong>: In the preceding code, the exceptions in the application are handled very poorly. The developers are not aware of what exceptions are to be handled here. SQLException is a checked Exception, which means it forces the developers to handle errors, but if you can't handle it, you must declare it. It is a very bad way of handling exceptions, and the intermediate methods must declare exception(s) from all methods in the code. It is a form of tight coupling.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Solving problems with Spring's JdbcTemplate</h1>
                </header>
            
            <article>
                
<p>Spring's <kbd>JdbcTemplate</kbd> solves both the problems listed in the last section. <kbd>JdbcTemplate</kbd> greatly simplifies the use of the JDBC API, and it eliminates repetitive boilerplate code. It alleviates the common causes of bugs, and handles SQLExceptions properly without sacrificing power. It provides full access to the standard JDBC constructs. Let's see the same code using Spring's <kbd>JdbcTemplate</kbd> class to solve these two problems:</p>
<ul>
<li><strong>Removing redundant code from the application using JdbcTemplate</strong>: Suppose you want a count of the accounts in a bank. The following code is required if you use the <kbd>JdbcTemplate</kbd> class:</li>
</ul>
<pre>        int count = jdbcTemplate.queryForObject("SELECT COUNT(*)<br/>         FROM ACCOUNT", Integer.class); 
 </pre>
<p style="padding-left: 60px">If you want to access the list of accounts for a particular user ID:</p>
<pre>        List&lt;Account&gt; results = jdbcTemplate.query(someSql,<br/>         new RowMapper&lt;Account&gt;() { 
           public Account mapRow(ResultSet rs, int row) throws <br/>            SQLException { 
              // map the current row to an Account object 
            } 
        }); </pre>
<p style="padding-left: 60px">As you can see in the preceding code, you don't need to write the code for Open and Close database connection, for preparing a statement to execute query, and so on.</p>
<ul>
<li><strong>Data Access Exceptions</strong>: Spring provides a consistent exception hierarchy to handle technology-specific exceptions like SQLException to its own exception class hierarchy with <kbd>DataAccessException</kbd> as the root exception. Spring wraps these original exceptions into different unchecked exceptions. Now Spring does not force the developers to handle these exceptions at development time. Spring provides the <kbd>DataAccessException</kbd> hierarchy to hide whether you are using JPA, Hibernate, JDBC, or similar. Actually, it is a hierarchy of sub-exceptions, and not just one exception for everything. It is consistent across all the supported data access technologies. The following diagram depicts the Spring Data Access Exception hierarchy:</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="215" width="374" class=" image-border" src="assets/a72f4691-be06-4a91-a90b-61638a59fd99.png"/></div>
<ul>
<li>As you can see in the preceding figure, Spring's <kbd>DataAccessException</kbd> extends the <kbd>RuntimeException</kbd>, that is, it is an unchecked exception. In an enterprise application, unchecked exceptions can be thrown up the call hierarchy to the best place to handle it. The good thing is that the methods in between don't know about it in the application.</li>
</ul>
<p>Let's first discuss how to configure Spring with a data source to be able to connect the database, before declaring the templates and repositories in a Spring application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the data source and object pool pattern</h1>
                </header>
            
            <article>
                
<p>In the Spring Framework, DataSource is part of the JDBC API, and it provides a connection to the database. It hides many boilerplate codes for connection pooling, exception handling, and transaction management issues from the application code. As a developer, you let it focus on your business logic only. Don't worry about connection pooling, exception handling, and managing transactions; it is the responsibility of the application administrators how they set up the container managed data source in production. You just write the code, and test that code.</p>
<p>In an enterprise application, we can retrieve DataSource in several ways. We can use the JDBC driver to retrieve DataSource, but it is not the best approach to create DataSource in the production environment. As performance is one of the key issues during application development, Spring implements the object pool pattern to provide DataSource to the application in a very efficient way. The object pool pattern says that <em>creation of objects is expensive rather than reuse.</em></p>
<p>Spring allows us to implement the object pool pattern for reusing the DataSource object in the application. You can use either the application server and container-managed pool (JNDI), or you can create a container by using third-party libraries such as DBCP, c3p0, and so on. These pools help to manage the available data sources in a better way.</p>
<p>In your Spring application, there are several options to configure the data-source beans, and they are as follows:</p>
<ul>
<li>Configuring data source using a JDBC driver</li>
<li>Implementing the object pool design pattern to provide data source objects
<ul>
<li>Configuring the data source using JNDI</li>
<li>Configuring the data source using pool connections
<ul>
<li>Implementing the Builder pattern to create an embedded data source</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Let's see how to configure a data-source bean in a Spring application.</p>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring a data source using a JDBC driver</h1>
                </header>
            
            <article>
                
<p>Using a JDBC driver to configure a data-source bean is the simplest data source in Spring. The three data source classes provided by Spring are as follows:</p>
<ul>
<li><kbd>DriverManagerDataSource</kbd>: It always creates a new connection for every connection request</li>
<li><kbd>SimpleDriverDataSource</kbd>: It is similar to the <kbd>DriverManagerDataSource</kbd> except that it works with the JDBC driver directly</li>
<li><kbd>SingleConnectionDataSource</kbd>: It returns the same connection for every connection request, but it is not a pooled data source</li>
</ul>
<p>Let's see the following code for configuring a data source bean using the <kbd>DriverManagerDataSource</kbd> class of Spring in your application:</p>
<p>In Java-based configuration, the code is as follows:</p>
<pre>    DriverManagerDataSource dataSource = new DriverManagerDataSource(); 
    dataSource.setDriverClassName("org.h2.Driver"); 
    dataSource.setUrl("jdbc:h2:tcp://localhost/bankDB"); 
    dataSource.setUsername("root"); 
    dataSource.setPassword("root"); </pre>
<p>In XML-based configuration, the code will be like this:</p>
<pre>    &lt;bean id="dataSource"<br/>     class="org.springframework.jdbc.datasource<br/>     .DriverManagerDataSource"&gt; 
     &lt;property name="driverClassName" value="org.h2.Driver"/&gt; 
     &lt;property name="url" value="jdbc:h2:tcp://localhost/bankDB"/&gt; 
     &lt;property name="username" value="root"/&gt; 
     &lt;property name="password" value="root"/&gt; 
    &lt;/bean&gt; </pre>
<p>The data source defined in the preceding code is a very simple data source, and we can use it in the development environment. It is not a suitable data source for production. I, personally, prefer to use JNDI to configure the data source for the production environment. Let's see how.</p>
<p>Let's implement the object pool design pattern to provide data source objects <em>by</em> configuring the data source <em>using</em> JNDI.</p>
<p>In a Spring application, you can configure a data source by using the JNDI lookup. Spring provides the <kbd>&lt;jee:jndi-lookup&gt;</kbd> element from Spring's JEE namespace. Let's see the code for this configuration.</p>
<p>In XML configuration, the code is given as follows:</p>
<pre>    &lt;jee:jndi-lookup id="dataSource"<br/>     jndi-name="java:comp/env/jdbc/datasource" /&gt; </pre>
<p>In Java configuration, the code is as follows:</p>
<pre>    @Bean 
    public JndiObjectFactoryBean dataSource() { 
      JndiObjectFactoryBean jndiObject = new JndiObjectFactoryBean(); 
      jndiObject.setJndiName("jdbc/datasource"); 
      jndiObject.setResourceRef(true); 
      jndiObject.setProxyInterface(javax.sql.DataSource.class); 
      return jndiObject; 
    } </pre>
<p>Application servers like WebSphere or JBoss allow you to configure data sources to be prepared via JNDI. Even a web container like Tomcat allows you to configure data sources to be prepared via JNDI. These servers manage the data sources in your application. It is beneficial, because the performance of the data source will be greater, as the application servers are often pooled. And they can be managed completely external to the application. This is one of the best ways to configure a data source to be retrieved via JNDI. If you are not able to retrieve through the JNDI lookup in production, you can choose another, better option, which we'll discuss next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the data source using pool connections</h1>
                </header>
            
            <article>
                
<p>The following open-sources technologies provide pooled data sources:</p>
<ul>
<li>Apache commons DBCP</li>
<li>c3p0</li>
<li>BoneCP</li>
</ul>
<p>The following code configures DBCP's <kbd>BasicDataSource</kbd>.</p>
<p>The XML-based DBCP configuration is given as follows:</p>
<pre>    &lt;bean id="dataSource" <br/>      class="org.apache.commons.dbcp.BasicDataSource"<br/>       destroy-method="close"&gt; 
      &lt;property name="driverClassName" value="org.h2.Driver"/&gt; 
      &lt;property name="url" value="jdbc:h2:tcp://localhost/bankDB"/&gt; 
      &lt;property name="username" value="root"/&gt; 
      &lt;property name="password" value="root"/&gt; 
      &lt;property name="initialSize" value="5"/&gt; 
      &lt;property name="maxActive" value="10"/&gt; 
    &lt;/bean&gt; </pre>
<p>The Java-based DBCP configuration is as follows:</p>
<pre>    @Bean 
    public BasicDataSource dataSource() { 
      BasicDataSource dataSource = new BasicDataSource(); 
      dataSource.setDriverClassName("org.h2.Driver"); 
      dataSource.setUrl("jdbc:h2:tcp://localhost/bankDB"); 
      dataSource.setUsername("root"); 
      dataSource.setPassword("root"); 
      dataSource.setInitialSize(5); 
      dataSource.setMaxActive(10); 
      return dataSource; 
    } </pre>
<p>As you can see in the preceding code, there are many other properties which are introduced for a pooled data sources provider. The properties of the <kbd>BasicDataSource</kbd> class in Spring are listed next:</p>
<ul>
<li><kbd>initialSize</kbd>: This is the number of connections created at the time of initialization of the pool.</li>
<li><kbd>maxActive</kbd>: This is the maximum number of connections that can be allocated from the pool at the time of initialization of the pool. If you set this value to 0, that means there's no limit.</li>
<li><kbd>maxIdle</kbd>: This is the maximum number of connections that can be idle in the pool without extras being released. If you set this value to 0, that means there's no limit.</li>
<li><kbd>maxOpenPreparedStatements</kbd>: This is the maximum number of prepared statements that can be allocated from the statement pool at the time of initialization of the pool. If you set this value to <kbd>0</kbd>, that means there's no limit.</li>
<li><kbd>maxWait</kbd>: This is the maximum waiting time for a connection to be returned to the pool before an exception is thrown. If you set it to 1, it means wait indefinitely.</li>
<li><kbd>minEvictableIdleTimeMillis</kbd>: This is the maximum time duration a connection can remain idle in the pool before it's eligible for eviction.</li>
<li><kbd>minIdle</kbd>: This is the minimum number of connections that can remain idle in the pool without new connections being created.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the Builder pattern to create an embedded data source</h1>
                </header>
            
            <article>
                
<p>In application development, the embedded database is very useful, because it doesn't require a separate database server that your application connects. Spring provides one more data source for embedded databases. It is not powerful enough for the production environment. We can use the embedded data source for the development and testing environment. In Spring, the <kbd>jdbc</kbd> namespace configures an embedded database, <kbd>H2</kbd>, as follows:</p>
<p>In XML configuration, <kbd>H2</kbd> is configured as follows:</p>
<pre>    &lt;jdbc:embedded-database id="dataSource" type="H2"&gt; 
     &lt;jdbc:script location="schema.sql"/&gt; 
     &lt;jdbc:script location="data.sql"/&gt; 
    &lt;/jdbc:embedded-database&gt; </pre>
<p>In Java configuration, <kbd>H2</kbd> is configured as follows:</p>
<pre>    @Bean 
    public DataSource dataSource(){ 
      EmbeddedDatabaseBuilder builder =<br/>        new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.H2); 
      builder.addScript("schema.sql"); 
      builder.addScript("data.sql"); 
      return builder.build(); 
    } </pre>
<p>As you can see in the preceding code, Spring provides the <kbd>EmbeddedDatabaseBuilder</kbd> class. It actually implements the Builder design pattern to create the object of the <kbd>EmbeddedDatabaseBuilder</kbd> class.</p>
<p>Let's see one more design pattern in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Abstracting database access using the DAO pattern</h1>
                </header>
            
            <article>
                
<p>The data access layer works as an aspect between the business layer and the database. Data accessing depends on the business call, and it varies depending on the source of the data for example database, flat files, XML, and so on. So, we can abstract all access by providing an interface. This is known as the data access object pattern. From the application's point of view, it makes no difference when it accesses a relational database or parses XML files using a DAO.</p>
<p>In an earlier version, EJB provided entity beans managed by the container; they were distributed, secure, and transactional components. These beans were very transparent to the client, that is, for the service layer in the application, they had automatic persistence without the care of underlying database. But mostly, the features offered by these entity beans were not required for your application, as you needed to persist data to the database. Due to <em>this,</em> some non-required features of the entity beans, like network traffic, increased, and your application's performance was impacted. And that time, the entity beans needed to run inside the EJB containers, which is why it was very difficult to test.</p>
<p>In a nutshell, if you are working with the traditional JDBC API or earlier EJB versions, you will face the following problems in your application:</p>
<ul>
<li>In a traditional JDBC application, you merge the business tier logic with persistence logic.</li>
<li>The Persistence tier or DAO layer is not consistent for the service layer or business tier. But DAO should be consistent for the service layer in an enterprise application.</li>
<li>In a traditional JDBC application, you have to handle a lot of boilerplate code like making and closing connection, preparing statement, handling exceptions, and so on. It degrades reusability and increases development time.</li>
<li>With EJB, the entity bean was created <em>as</em> an overhead to the application, and was difficult to test.</li>
</ul>
<p>Let's see how spring solves these problems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The DAO pattern with the Spring Framework</h1>
                </header>
            
            <article>
                
<p>Spring provides a comprehensive JDBC module to design and develop JDBC-based DAOs. These DAOs in the application take care of all the boilerplate code of the JDBC API, and help to provide a consistent API for data access. In the Spring JDBC, DAO is a generic object to access data for the business tier, and it provides a consistent interface to the services at the business tier. The main goal behind the DAO's classes is to abstract the underlying data access logic from the services at the business tier.</p>
<p>In our previous example, we saw how the pizza company helped us to understand the resource management problem, and now, we will continue with our bank application. Let's see the following example on how to implement DAOs in an application. Suppose, in our bank application, we want the total number accounts in a branch in the city. For this, we will first create an interface for the DAO. It promotes programming to interface, as discussed earlier. It is one of the best practices of the design principles. This DAO interface will be injected with the services at the business tier, and we can create a number of concrete classes of the DAO interface according to the underlying databases in the application. That means our DAO layer will be consistent for the business layer. Let's create a DAO interface as following:</p>
<pre>    package com.packt.patterninspring.chapter7.bankapp.dao; 
    public interface AccountDao { 
      Integer totalAccountsByBranch(String branchName); 
    } </pre>
<p>Let's see a concrete implementation of the DAO interface using Spring's <kbd>JdbcDaoSupport</kbd> class:</p>
<pre>    package com.packt.patterninspring.chapter7.bankapp.dao; 
 
    import org.springframework.jdbc.core.support.JdbcDaoSupport; 
    public class AccountDaoImpl extends JdbcDaoSupport implements<br/>     AccountDao { 
       @Override 
       public Integer totalAccountsByBranch(String branchName) { 
         String sql = "SELECT count(*) FROM Account WHERE branchName =<br/>          "+branchName; 
         return this.getJdbcTemplate().queryForObject(sql,<br/>          Integer.class); 
       } 
    } </pre>
<p>In the preceding code, you can see that the <kbd>AccountDaoImpl</kbd> class implements the <kbd>AccountDao</kbd> DAO interface, and it extends Spring's <kbd>JdbcDaoSupport</kbd> class to ease development with JDBC-based. This class provides a <kbd>JdbcTemplate</kbd> to its subclasses by using <kbd>getJdbcTemplate()</kbd>. The <kbd>JdbcDaoSupport</kbd> class is associated with a data source, and supplies the <kbd>JdbcTemplate</kbd> object for use in the DAO.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with JdbcTemplate</h1>
                </header>
            
            <article>
                
<p>As you learned earlier, Spring's <kbd>JdbcTemplate</kbd> solves two main problems in the application. It solves the redundant code problem as well as poor exception handling of the data access code in the application. Without <kbd>JdbcTemplate</kbd> in your application, only 20% of the code is required for querying a row, but 80% is boilerplate which handles exceptions and manages resources. If you use <kbd>JdbcTemplate</kbd>, then there is no need to worry about the 80% boilerplate code. Spring's <kbd>JdbcTemplate</kbd>, in a nutshell, is responsible for the following:</p>
<ul>
<li>Acquisition of the connection</li>
<li>Participation in the transaction</li>
<li>Execution of the statement</li>
<li>Processing of the result set</li>
<li>Handling any exceptions</li>
<li>Release of the connection</li>
</ul>
<p>Let's see when to use <kbd>JdbcTemplate</kbd> in the application, and how to create it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">When to use JdbcTemplate</h1>
                </header>
            
            <article>
                
<p><kbd>JdbcTemplate</kbd> is useful in standalone applications, and anytime when JDBC is needed. It is suitable in utility or test code to clean up messy legacy code. Also, in any layered application, you can implement a repository or data access object. Let's see how to create it in an application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a JdbcTemplate in an application</h1>
                </header>
            
            <article>
                
<p>If you want to create an object of the <kbd>JdbcTemplate</kbd> class to access data in your Spring application, you need to remember that it requires a <kbd>DataSource</kbd> to create the database connection. Let's create a template once, and reuse it. Do not create one for each thread, it is thread-safe after construction:</p>
<pre>    JdbcTemplate template = new JdbcTemplate(dataSource); </pre>
<p>Let's configure a <kbd>JdbcTemplate</kbd> bean in Spring with the following <kbd>@Bean</kbd> method:</p>
<pre>    @Bean 
    public JdbcTemplate jdbcTemplate(DataSource dataSource) { 
      return new JdbcTemplate(dataSource); 
    } </pre>
<p>In the preceding code, we use the constructor injection to inject the <kbd>DataSource</kbd> with the <kbd>JdbcTemplate</kbd> bean in the Spring application. The <kbd>dataSource</kbd> bean being referenced can be any implementation of <kbd>javax.sql.DataSource</kbd>. Let's see how to use the <kbd>JdbcTemplate</kbd> bean in your JDBC-based repository to access the database in your application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a JDBC-based repository</h1>
                </header>
            
            <article>
                
<p>We can use the Spring's <kbd>JdbcTemplate</kbd> class to implement the repositories in a Spring application. Let's see how to implement the repository class based on the JDBC template:</p>
<pre>    package com.packt.patterninspring.chapter7.bankapp.repository; 
 
    import java.sql.ResultSet; 
    import java.sql.SQLException; 
 
    import javax.sql.DataSource; 
 
    import org.springframework.jdbc.core.JdbcTemplate; 
    import org.springframework.jdbc.core.RowMapper; 
    import org.springframework.stereotype.Repository; 
  
    import com.packt.patterninspring.chapter7.bankapp.model.Account; 
    @Repository 
    public class JdbcAccountRepository implements AccountRepository{ 
    
      JdbcTemplate jdbcTemplate; 
    
      public JdbcAccountRepository(DataSource dataSource) { 
        super(); 
        this.jdbcTemplate = new JdbcTemplate(dataSource); 
      } 
 
      @Override 
      public Account findAccountById(Long id){ 
        String sql = "SELECT * FROM Account WHERE id = "+id; 
        return jdbcTemplate.queryForObject(sql,<br/>         new RowMapper&lt;Account&gt;(){ 
           @Override 
           public Account mapRow(ResultSet rs, int arg1) throws<br/>           SQLException { 
             Account account = new Account(id); 
             account.setName(rs.getString("name")); 
             account.setBalance(new Long(rs.getInt("balance"))); 
             return account; 
           } 
         }); 
      } 
    } </pre>
<p>In the preceding code, the <kbd>DataSource</kbd> bean is injected with the <kbd>JdbcAccountRepository</kbd> class by using the constructor injection. By using this DataSource, we created a <kbd>JdbcTemplate</kbd> object for accessing the data. The following methods are provided by <kbd>JdbcTemplate</kbd> to access data from the database:</p>
<ul>
<li><kbd>queryForObject(..)</kbd>: This is a query for simple java types (<kbd>int</kbd>, <kbd>long</kbd>, <kbd>String</kbd>, <kbd>Date</kbd> ...) and for custom domain objects.</li>
<li><kbd>queryForMap(..)</kbd>: This is used when expecting a single row. <kbd>JdbcTemplate</kbd> returns each row of a <kbd>ResultSet</kbd> as a Map.</li>
<li><kbd>queryForList(..)</kbd>: This is used when expecting multiple rows.</li>
</ul>
<div class="packt_infobox">Note that <kbd>queryForInt</kbd> and <kbd>queryForLong</kbd> have been deprecated since Spring 3.2; you can just use <kbd>queryForObject</kbd> instead (API improved in Spring 3).</div>
<p>Often, it is useful to map relational data into domain objects, for example, a <kbd>ResultSet</kbd> to an Account in the last code. Spring's <kbd>JdbcTemplate</kbd> supports this by using a callback approach. Let's discuss Jdbc callback interfaces in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Jdbc callback interfaces</h1>
                </header>
            
            <article>
                
<p>Spring provides three callback interfaces for JDBC as follows:</p>
<ul>
<li><strong>Implementing RowMapper</strong>: Spring provides a <kbd>RowMapper</kbd> interface for mapping a single row of a <kbd>ResultSet</kbd> to an object. It can be used for both single and multiple row queries. It is parameterized as of Spring 3.0:</li>
</ul>
<pre>      public interface RowMapper&lt;T&gt; { 
        T mapRow(ResultSet rs, int rowNum) 
        throws SQLException; 
      } </pre>
<ul>
<li>Let's understand this with the help of an example.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a RowMapper class</h1>
                </header>
            
            <article>
                
<p>In the following example, a class, <kbd>AccountRowMapper</kbd>, implements the <kbd>RowMapper</kbd> interface of the Spring Jdbc module:</p>
<pre>    package com.packt.patterninspring.chapter7.bankapp.rowmapper; 
 
    import java.sql.ResultSet; 
    import java.sql.SQLException; 
    import org.springframework.jdbc.core.RowMapper; 
    import com.packt.patterninspring.chapter7.bankapp.model.Account; 
    public class AccountRowMapper implements RowMapper&lt;Account&gt;{ 
      @Override 
      public Account mapRow(ResultSet rs, int id) throws SQLException { 
        Account account = new Account(); 
        account.setId(new Long(rs.getInt("id"))); 
        account.setName(rs.getString("name")); 
        account.setBalance(new Long(rs.getInt("balance"))); 
        return account; 
      } 
    } </pre>
<p>In the preceding code, a class, <kbd>AccountRowMapper</kbd>, maps a row of the result set to the domain object. This row-mapper class implements the <kbd>RowMapper</kbd> callback interface of the Spring Jdbc module.</p>
<p><strong>Query for single row with JdbcTemplate</strong></p>
<p>Let's now see how the row-mapper maps a single row to the domain object in the application in the following code:</p>
<pre>    public Account findAccountById(Long id){ 
      String sql = "SELECT * FROM Account WHERE id = "+id; 
      return jdbcTemplate.queryForObject(sql, new AccountRowMapper()); 
    } </pre>
<p>Here, there is no need to add typecasting for the Account object. The <kbd>AccountRowMapper</kbd> class maps the rows to the Account objects.</p>
<p><strong>Query for multiple rows</strong></p>
<p>The following code shows how the row mapper maps multiple rows to the list of domain objects:</p>
<pre>    public List&lt;Account&gt; findAccountById(Long id){ 
      String sql = "SELECT * FROM Account "; 
      return jdbcTemplate.queryForList(sql, new AccountRowMapper()); 
    } </pre>
<p>RowMapper is the best choice when each row of a <kbd>ResultSet</kbd> maps to a domain object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing RowCallbackHandler</h1>
                </header>
            
            <article>
                
<p>Spring provides a simpler <kbd>RowCallbackHandler</kbd> interface when there is no return object. It is used to stream rows to a file, converting the rows to XML, and filtering them before adding to a collection. But filtering in SQL is much more efficient, and is faster than the JPA equivalent for big queries. Let's look at the following example:</p>
<pre>    public interface RowCallbackHandler { 
      void processRow(ResultSet rs) throws SQLException; 
    } </pre>
<p>Â </p>
<p><strong>Example for using a RowCallbackHandler</strong></p>
<p>The following code is an example of a <kbd>RowCallbackHandler</kbd> in the application:</p>
<pre>    package com.packt.patterninspring.chapter7.bankapp.callbacks; 
    import java.sql.ResultSet; 
    import java.sql.SQLException; 
    import org.springframework.jdbc.core.RowCallbackHandler; 
    public class AccountReportWriter implements RowCallbackHandler { 
      public void processRow(ResultSet resultSet) throws SQLException { 
        // parse current row from ResultSet and stream to output 
        //write flat file, XML 
      } 
    } </pre>
<p>In preceding code, we have created a <kbd>RowCallbackHandler</kbd> implementation; the <kbd>AccountReportWriter</kbd> class implements this interface to process the result set returned from the database. Let's see the following code how to use AccountReportWriter call back class:</p>
<pre>    @Override 
    public void generateReport(Writer out, String branchName) { 
      String sql = "SELECT * FROM Account WHERE branchName = "+<br/>       branchName; 
      jdbcTemplate.query(sql, new AccountReportWriter()); 
    } </pre>
<p><kbd>RowCallbackHandler</kbd> is the best choice when no value should be returned from the callback method for each row, especially for large queries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing ResultSetExtractor</h1>
                </header>
            
            <article>
                
<p>Spring provides a <kbd>ResultSetExtractor</kbd> interface for processing an entire <kbd>ResultSet</kbd> at once. Here, you are responsible for iterating the <kbd>ResultSet</kbd>, for example, for mapping the entire <kbd>ResultSet</kbd> to a single object. Let's see the following example:</p>
<pre>    public interface ResultSetExtractor&lt;T&gt; { 
      T extractData(ResultSet rs) throws SQLException,<br/>      DataAccessException; 
    } </pre>
<p><strong>Example for using a ResultSetExtractor</strong></p>
<p>The following line of code implements the <kbd>ResultSetExtractor</kbd> interface in the application:</p>
<pre>    package com.packt.patterninspring.chapter7.bankapp.callbacks; 
 
    import java.sql.ResultSet; 
    import java.sql.SQLException; 
    import java.util.ArrayList; 
    import java.util.List; 
 
    import org.springframework.dao.DataAccessException; 
    import org.springframework.jdbc.core.ResultSetExtractor; 
 
    import com.packt.patterninspring.chapter7.bankapp.model.Account; 
 
    public class AccountExtractor implements<br/>     ResultSetExtractor&lt;List&lt;Account&gt;&gt; { 
       @Override 
       public List&lt;Account&gt; extractData(ResultSet resultSet) throws<br/>        SQLException, DataAccessException { 
          List&lt;Account&gt; extractedAccounts = null; 
          Account account = null; 
          while (resultSet.next()) { 
            if (extractedAccounts == null) { 
              extractedAccounts = new ArrayList&lt;&gt;(); 
              account = new Account(resultSet.getLong("ID"),<br/>               resultSet.getString("NAME"), ...); 
            } 
            extractedAccounts.add(account); 
          } 
          return extractedAccounts; 
       } 
    } </pre>
<p>This preceding class, <kbd>AccountExtractor</kbd>, implements <kbd>ResultSetExtractor</kbd>, and it is used to create an object for the entire data of the result set returned from the database. Let's see how to use this class in your application:</p>
<pre>    public List&lt;Account&gt; extractAccounts() { 
      String sql = "SELECT * FROM Account"; 
      return jdbcTemplate.query(sql, new AccountExtractor()); 
    } </pre>
<p>The previous code is responsible for accessing all the accounts of a bank, and for preparing a list of accounts by using the <kbd>AccountExtractor</kbd> class. This class implements the <kbd>ResultSetExtractor</kbd> callback interface of the Spring Jdbc module.</p>
<p><kbd>ResultSetExtractor</kbd> is the best choice when multiple rows of a <kbd>ResultSet</kbd> map to a single object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Best practices for Jdbc and configuring JdbcTemplate</h1>
                </header>
            
            <article>
                
<p>Instances of the <kbd>JdbcTemplate</kbd> class are thread-safe once configured. As a best practice of configuring the <kbd>JdbcTemplate</kbd> in a Spring application, it should be constructed in the constructor injection or setter injection of the data source bean in your DAO classes by passing that data source bean as a constructor argument of the <kbd>JdbcTemplate</kbd> class. This leads to DAOs that look, in part, like the following:</p>
<pre>    @Repository 
    public class JdbcAccountRepository implements AccountRepository{ 
      JdbcTemplate jdbcTemplate; 
    
      public JdbcAccountRepository(DataSource dataSource) { 
        super(); 
        this.jdbcTemplate = new JdbcTemplate(dataSource); 
      } 
      //... 
    } 
    Let's see some best practices to configure a database and write<br/>    the code for the DAO layer: </pre>
<ul>
<li>If you want to configure the embedded database at the time of development of the application, as the best practice, the embedded database will always be assigned a uniquely generated name. This is because in the Spring container, the embedded database is made available by configuring a bean of type <kbd>javax.sql.DataSource</kbd>, and that data source bean is injected to the data access objects.</li>
<li>Always use object pooling; this can be achieved in two ways:
<ul>
<li><strong>Connection pooling</strong>: It allows the pool manager to keep the connections in a <em>pool</em> after they are closed</li>
<li><strong>Statement pooling</strong>: It allows the driver to reuse the prepared Statement objects.
<ul>
<li>Choose the commit mode carefully</li>
<li>Consider removing the auto-commit mode for your application, and use manual commit instead to better control the commit logic, as follows:</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre>                  Connection.setAutoCommit(false); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>An application without data is like a car without fuel. Data is the heart of an application. Some applications may exist in the world without data, but these applications are simply showcase applications such as static blogs. Data is an important part of an application, and you need to develop data-access code for your application. This code should very simple, robust, and customizable.</p>
<p>In a traditional Java application, you could use JDBC to access the data. It is a very basic way, but sometimes, it is very messy to define specifications, handle JDBC exceptions, make database connections, load drivers, and so on. Spring simplifies these things by removing the boilerplate code and simplifying JDBC exception handling. You just write your SQL that should be executed in the application, and the rest is managed by the Spring framework.</p>
<p>In this chapter, you have seen how Spring provides support at the backend for data access and data persistence. JDBC is useful, but using the JDBC API directly is a tedious and error-prone task. <kbd>JdbcTemplate</kbd> simplifies data access, and enforces consistency. Data access with Spring uses the layered architecture principles-the higher layers should not know about data management. It isolates SQLException via Data Access Exceptions, and creates a hierarchy to make them easier to handle.</p>
<p>In the next chapter, we'll continue to discuss data access and persistence with the ORM framework, like Hibernate and JPA.</p>


            </article>

            
        </section>
    </body></html>