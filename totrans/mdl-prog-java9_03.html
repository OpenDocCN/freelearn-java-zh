<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Handling Inter-Module Dependencies</h1>
                
            
            <article>
                
<p class="calibre2">In the last chapter, we created our first Java 9 module and set up the beginnings of the address book application. However, we built the whole application as a single module, and thus, we didn't really leverage any of the cool new features of modularity. Here's what you'll learn to do in this chapter:</p>
<ul class="calibre14">
<li class="calibre15">You'll break the application up into two separate modules, and thereby create your second Java module</li>
<li class="calibre15">You'll learn how to establish dependencies between those two modules</li>
<li class="calibre15">You'll learn more about the module descriptor configuration that's required to wire in two separate modules</li>
<li class="calibre15">You'll revisit the compilation and execution steps with multiple modules</li>
</ul>
<p class="calibre2">This all starts with breaking our monolithic address book viewer application into two modules. Breaking the single module into two dependent modules has two consequences:</p>
<ul class="calibre14">
<li class="calibre15">Breaking the application up into modular parts enables these modular parts to potentially be reused in multiple other applications.</li>
<li class="calibre15">It's an opportunity to define the interface for the modules. It lets you, as the module author, define what the module exports and how it should be used and consumed.</li>
</ul>
<p class="calibre2">We'll look at both of these in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating the second module</h1>
                
            
            <article>
                
<p class="calibre2">Let's start by splitting the address book application into two separate modules. The obvious candidate for moving to its own module is the sorting logic. At this point, there's nothing about the sorting class, <kbd class="calibre12">SortUtil</kbd>, that has anything to do with the address book. We've designed the class to be generic and provide functionality to sort any list. That's good practice in general, but it makes additional sense when breaking it out as a separate module. What we will do is move the code related to sorting into a brand new module, called <kbd class="calibre12">packt.sortutil</kbd>. Here are the steps at a high level:</p>
<ol class="calibre17">
<li value="1" class="calibre15">Create a new module called <kbd class="calibre12">packt.sortutil</kbd>.</li>
<li value="2" class="calibre15">Move the code related to sorting into this newly created module.</li>
<li value="3" class="calibre15">Configure the <kbd class="calibre12">packt.sortutil</kbd> module to define its interface--what it exports and how the module needs to be used.</li>
<li value="4" class="calibre15">Configure the <kbd class="calibre12">packt.addressbook</kbd> module to use the new <kbd class="calibre12">packt.sortutil</kbd> module.</li>
</ol>
<p class="calibre2">Let's start by creating a new module. We've looked at the four steps to create a module in <a target="_blank" href="part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 2</a>, <em class="calibre22">Creating Your First Java Module</em>, already. We know what the module name is. Next, the module structure requires creating a module root directory in the source folder. Just like the <kbd class="calibre12">packt.addressbook</kbd> folder resides in the <kbd class="calibre12">src</kbd> folder and holds all the contents of the <kbd class="calibre12">packt.addressbook</kbd> module, the <kbd class="calibre12">packt.sortutil</kbd> module requires the creation of a folder named <kbd class="calibre12">packt.sortutil</kbd> in the same <kbd class="calibre12">src</kbd> location. What makes this folder a module root folder is the presence of the module descriptor <kbd class="calibre12">module-info.java</kbd>:</p>
<pre class="calibre23">    module packt.sortutil { 
    } </pre>
<p class="calibre2">Here's the folder structure at this point:</p>
<div class="packt_figure"><img class="image-border31" src="../images/00037.jpeg"/></div>
<p class="calibre2">Now that we have a module, we can move the necessary classes from the <kbd class="calibre12">packt.addressbook</kbd> module into the <kbd class="calibre12">packt.sortutil</kbd> module. There's just one class related to sorting--<kbd class="calibre12">SortUtil.java</kbd>. With the package folders located at the module folder, the folder structure after moving the class over should look as follows:</p>
<div class="packt_figure"><img class="image-border32" src="../images/00038.jpeg"/></div>
<p class="calibre2">When creating a module, you'd typically also configure the interface, that is, defining the module's inputs and outputs. We didn't do this to the <kbd class="calibre12">packt.addressbook</kbd> module in <a target="_blank" href="part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4"><span>Chapter 2</span></a>, <em class="calibre22">Creating Your First Java Module</em> because it existed as a standalone module. However, that's not the case anymore in this chapter, since we'll now need the two modules <kbd class="calibre12">packt.addressbook</kbd> and <kbd class="calibre12">packt.sortutil</kbd> to work together. This involves updating the <kbd class="calibre12">module-info.java</kbd> file for both the modules to provide this information. But let's skip this step for now and examine the default behavior first. Let's observe what happens if we don't add any module configuration and compile the two modules with empty module definition files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Compiling two modules</h1>
                
            
            <article>
                
<p class="calibre2">Now the module path (the <kbd class="calibre12">src</kbd> directory) has two modules. We can now run the <kbd class="calibre12">javac</kbd> command to compile all classes in both modules, since we are supplying <kbd class="calibre12">src</kbd> as the module source path.</p>
<p class="calibre2">Here, <kbd class="calibre12">packt.sortutil</kbd> is the simpler of the two modules. Since it doesn't have any external dependencies, this should just work like the <kbd class="calibre12">packt.addressbook</kbd> module did in the previous chapter. Let's look at the <kbd class="calibre12">packt.addressbook</kbd> module. Things are more interesting here. Since we've moved the sort related classes to the <kbd class="calibre12">packt.sortutil</kbd> module, the <kbd class="calibre12">packt.addressbook</kbd> module doesn't have the classes in the <kbd class="calibre12">packt.util</kbd> package anymore. But there is code in the module that still uses it. Notice what happens when we try to compile both the modules with the same command as the previous chapter. This time, since we are compiling two modules, we specify both the module names to the  <kbd class="calibre12">--module</kbd> argument separated by a comma.</p>
<pre class="calibre23"><strong class="calibre1">$ javac -d out --module-source-path src --module packt.addressbook,packt.sortutil</strong></pre>
<p class="calibre2">The error you get should look something like this:</p>
<pre class="calibre23"><strong class="calibre1">./src/packt.addressbook/packt/addressbook/Main.java:6: error: SortUtil is not visible because package packt.util is not visible</strong>
<strong class="calibre1">import packt.util.SortUtil;</strong>
    <strong class="calibre1">     ^</strong>
<strong class="calibre1">./src/packt.addressbook/packt/addressbook/Main.java:13: error: cannot find symbol</strong>
<strong class="calibre1">SortUtil sortUtil = new SortUtil();</strong>
    <strong class="calibre1">^</strong>
<strong class="calibre1">symbol:   class SortUtil</strong>
<strong class="calibre1">location: class Main</strong>
<strong class="calibre1">./src/packt.addressbook/packt/addressbook/Main.java:13: error: cannot find symbol</strong>
<strong class="calibre1">SortUtil sortUtil = new SortUtil();</strong>
    <strong class="calibre1">            ^</strong>
<strong class="calibre1">symbol:   class SortUtil</strong>
<strong class="calibre1">location: class Main</strong></pre>
<p class="calibre2">Firstly, note that the errors are only from compiling the <kbd class="calibre12">packt.addressbook</kbd> module. This means that the compilation of the <kbd class="calibre12">packt.sortutil</kbd> module succeeded! The three errors in the preceding output are specifically about the <kbd class="calibre12">Main.java</kbd> file. The compiler clearly doesn't see the <kbd class="calibre12">SortUtil</kbd> class and it complains it is missing. But is it really missing? We do have a public <kbd class="calibre12">SortUtil</kbd> class available in the <kbd class="calibre12">src</kbd> folder, but since it is in a different module folder, the compiler doesn't seem to see it, even though the class itself is <kbd class="calibre12">public</kbd>. This brings up an important new change relating to class visibility in Java 9.</p>
<div class="packt_infobox">Just because a class is marked <kbd class="calibre28">public</kbd> in Java 9, it doesn't necessarily mean it is visible to all other types.</div>
<p class="calibre2">This is a radical change from the way <kbd class="calibre12">public</kbd> types work in Java 8 and earlier. Before Java 9, if you had a public class or interface in the classpath, it was available for any other type in the classpath to import and use. This is no longer the case with the module source path in Java 9!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring module dependency</h1>
                
            
            <article>
                
<p class="calibre2">Think of a module being a walled garden by default. By default, any Java type in a module is accessible <em class="calibre22">only</em> to the types inside the same module. Previously, the <kbd class="calibre12">SortUtil</kbd> class was in the <kbd class="calibre12">packt.addressbook</kbd> module and was thus accessible to other types in that module. Move it to a different module however, and it is not accessible to types in the original module anymore.</p>
<p class="calibre2">Given two modules, <strong class="calibre1">A</strong> and <strong class="calibre1">B</strong>, for any type in module A to access a type in module B, two conditions need to be satisfied:</p>
<ul class="calibre14">
<li class="calibre15">Module A needs to declare its dependency on module B</li>
<li class="calibre15">Module B needs to declare that it's okay with that type being accessed externally by other modules</li>
</ul>
<p class="calibre2">If either of these conditions isn't met, the type being accessed in module B is said to be <em class="calibre22">not readable</em> by module A. We'll cover the topics of readability and accessibility in sufficient detail in <a target="_blank" href="part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4"><span>Chapter 6</span></a>, <em class="calibre22">Module Resolution, Accessibility, and Readability</em>, but, for now, note that these are two important requirements. Let's apply these to the <kbd class="calibre12">packt.addressbook</kbd> and <kbd class="calibre12">packt.sortutil</kbd> modules.</p>
<p class="calibre2">First, we need to have the <kbd class="calibre12">packt.addressbook</kbd> module declare that it is dependent on the <kbd class="calibre12">packt.sortutil</kbd> module. It is using a class from that module, and there's no way you can compile or run the module without it. The way to declare a dependency on a module is by using the <kbd class="calibre12">requires</kbd> keyword:</p>
<pre class="calibre23">    module packt.addressbook { 
      requires packt.sortutil; 
    } </pre>
<p class="calibre2">Following the <kbd class="calibre12">requires</kbd> keyword is the name of the module that is required. And yes, you can only require other modules, and not packages or classes. This line is enough for the compiler and runtime to look up types from the module that is being <em class="calibre22">required</em> any time those types are being used in the module. A module could depend on multiple other modules. So, it's actually common to have multiple such <kbd class="calibre12">requires</kbd> lines of code in a module declaration.</p>
<p class="calibre2">When a compiler tries to compile a module, imagine that it looks at this list of modules specified with the <kbd class="calibre12">requires</kbd> clause and says "Okay, I understand that this module requires all these other modules. While I compile this module, anytime I see a type being used in the code of this module that belongs to another module that is required, I'll go look at the module that contains the type and make sure it exports the type being used." Since every dependent module could potentially require other modules, this is a recursive process.</p>
<p class="calibre2">Now what does a module <em class="calibre22">exporting</em> a type mean? This is where we get to the second of the two preceding conditions. Every module needs to specifically declare what types in its module are okay for use outside the module. In our case, the <kbd class="calibre12">packt.sortutil</kbd> module needs to declare that the <kbd class="calibre12">SortUtil</kbd> class is allowed to be used outside its own module. This is done in the <kbd class="calibre12">sortutil</kbd> module's declaration file, using the <kbd class="calibre12">exports</kbd> keyword followed by the package you want to export. When a module <kbd class="calibre12">exports</kbd> a package, all the types belonging to that package are allowed access outside the module:</p>
<pre class="calibre23">    module packt.sortutil { 
      exports packt.util; 
    } </pre>
<p class="calibre2">In our case, we want to export the <kbd class="calibre12">packt.util.SortUtil</kbd> class. So, we <em class="calibre22">export</em> the package <kbd class="calibre12">packt.util</kbd> thereby exporting the class within it.</p>
<p class="calibre2">Again, note that you <em class="calibre22">require</em> modules and <em class="calibre22">export</em> packages. There are several reasons why the language designers decided to use the <kbd class="calibre12">exports</kbd> syntax with packages rather than having developers export individual types. The most obvious reason, of course, is that it is much more convenient than the tedium of having to export each class at an individual type level.</p>
<div class="packt_infobox">We've introduced a handful of new keywords so far--<kbd class="calibre28">module</kbd>, <kbd class="calibre28">requires</kbd>, and <kbd class="calibre28">exports</kbd>. You might be wondering if they are reserved words in the Java language as of Java 9. Are you in trouble if you've been using these as variable names all over your code today? The answer is no! These and other module related keywords we'll be learning in this book are what are called <em class="calibre29">restricted keywords</em>. You can still continue to use them in your code, but only when they are used in the context of a module descriptor, the compiler knows what they mean and it treats the keywords accordingly.</div>
<p class="calibre2">With both the conditions for cross-module access of types now satisfied, let's compile the code again from one directory above the module path:</p>
<pre class="calibre23"><strong class="calibre1">$ javac -d out --module-source-path src --module packt.addressbook,packt.sortutil</strong></pre>
<p class="calibre2">Again, the <kbd class="calibre12">--module-source-path</kbd> parameter specifies where the compiler can find all the Java modules that are required to do its job compiling your code. And, the <kbd class="calibre12">--module</kbd> indicates the two modules to be compiled--<kbd class="calibre12">packt.addressbook</kbd> and <kbd class="calibre12">packt.sortutil</kbd>. The compiler finds both the module root folders in the module source path and compiles them into their respective classes.</p>
<p class="calibre2">The compilation should quietly succeed. Just like last time, you'll notice that the <kbd class="calibre12">out</kbd> folder has a <kbd class="calibre12">.class</kbd> file corresponding to every <kbd class="calibre12">.java</kbd> file in each of the two modules, including the module descriptors, the two <kbd class="calibre12">module-info.java</kbd> files.</p>
<p class="calibre2">You can execute the <kbd class="calibre12">Main</kbd> class in the <kbd class="calibre12">packt.addressbook</kbd> module like before. For illustration, I'll use the terser  <kbd class="calibre12">-m</kbd> option (instead of <kbd class="calibre12">--module</kbd>) to specify the module and class to start execution. They both mean the same and can be used interchangeably.</p>
<pre class="calibre23"><strong class="calibre1">$ java --module-path out -m packt.addressbook/packt.addressbook.Main<br class="title-page-name"/></strong>
<strong class="calibre1">[Babbage 123-456-7890, Lovelace 234-567-8901, Dijkstra 345-678-9012, Turing 456-789-0123, Berners-Lee 456-789-0123]</strong></pre>
<p class="calibre2">Here as well, the <kbd class="calibre12">--module-path</kbd> option specifies where the Java runtime needs to look to find the modules required to execute the code. The runtime detects that the class it needs to start execution with (<kbd class="calibre12">Main</kbd>) is a part of the module <kbd class="calibre12">packt.addressbook</kbd> and since that module has a dependency on another module (<kbd class="calibre12">packt.sortutil</kbd>), it searches the location specified by the <kbd class="calibre12">module-path</kbd> option (the <kbd class="calibre12">out</kbd> directory here) to find the depended module. Thanks to our compile step placing the compiled module in the same location, the runtime finds it and the execution proceeds.</p>
<p class="calibre2">You should see the contacts successfully sorted by last name. Note that, to run this code, you just specified the <kbd class="calibre12">packt.addressbook</kbd> module and the <kbd class="calibre12">Main</kbd> class, and we didn't have to provide any information to the runtime about the dependent <kbd class="calibre12">packt.sortutil</kbd> module. This is because the Java runtime is reading off the same module descriptor (the <kbd class="calibre12">module-info.class</kbd> file this time) to know that the <kbd class="calibre12">packt.sortutil</kbd> module is required and so leverages the right class files from both modules as and when necessary.</p>
<p class="calibre2">Here is a diagram explaining the behavior of the two modules:</p>
<div class="packt_figure"><img class="image-border33" src="../images/00039.jpeg"/></div>
<p class="calibre2">What we've done is isolated the sorting functionality into its own module so that it can be used by other Java 9 modular applications that need sorting. All that any Java 9 module has to do in order to use <kbd class="calibre12">packt.sortutil</kbd> is:</p>
<ol class="calibre17">
<li value="1" class="calibre15">Add the <kbd class="calibre12">requires packt.sortutil</kbd> line in the definition of the module that needs the sorting functionality.</li>
<li value="2" class="calibre15">Import the <kbd class="calibre12">packt.util.SortUtil</kbd> class and call the <kbd class="calibre12">sortList()</kbd> method to sort any <kbd class="calibre12">List</kbd> of objects as long as the objects are <kbd class="calibre12">Comparable</kbd>.</li>
</ol>
<p class="calibre2">This is great, but before we share our new <kbd class="calibre12">packt.sortutil</kbd> library for the world to use, let's think about the library's API for a bit.</p>
<div class="packt_infobox">What I mean by a library's API is the code required to be used by the consumers of your library in order to access it. In the case of the simplistic <kbd class="calibre28">packt.sortutil</kbd> library, for example, the API is a single method <kbd class="calibre28">sortList()</kbd> on the class <kbd class="calibre28">packt.util.SortUtil</kbd>. More functional libraries obviously have multiple classes and methods that could potentially be called by their consumers.</div>
<p class="calibre2">When you create a library, before you allow others to use it, you have to very carefully define and finalize the library's API. The reason being that, once others start using your library, it becomes harder to make changes to the library's public API. Any changes to the API in future versions of your library would mean requiring all the consumers of your library update their code to work with the new API.</p>
<p class="calibre2">Right now, the <kbd class="calibre12">packt.sortutil</kbd> module contains just one class. We will be evolving the module in the next chapters, but for now, one change I'd like to do is to make the <kbd class="calibre12">SortUtil</kbd> class as lightweight as possible. That class acts as the <em class="calibre22">programming interface</em> to the <kbd class="calibre12">packt.sortutil</kbd> library, so making sure the class is as simple as it can be with fewer lines of code makes it less susceptible to possible changes in the future.</p>
<p class="calibre2">One way to achieve this is by moving the actual sorting functionality to an <em class="calibre22">implementation</em> class and have <kbd class="calibre12">SortUtil</kbd> just delegate the sorting logic to that class.</p>
<p class="calibre2">Let's assume we create a <kbd class="calibre12">BubbleSortUtil</kbd> class that has the same structure as the <kbd class="calibre12">SortUtil</kbd> class has so far:</p>
<pre class="calibre23">    public class BubbleSortUtilImpl { 
      public &lt;T extends Comparable&gt; List&lt;T&gt; sortList(List&lt;T&gt; list) { 
        ... 
      } 
      private &lt;T&gt; void swap(List&lt;T&gt;list, int inner) { 
        ... 
      } 
    } </pre>
<p class="calibre2">We can then update the <kbd class="calibre12">SortUtil</kbd> to just call <kbd class="calibre12">BubbleSortUtilImpl</kbd> class's <kbd class="calibre12">sortList</kbd> method to delegate:</p>
<pre class="calibre23">    public class SortUtil { 
      private BubbleSortUtilImpl sortImpl = new BubbleSortUtilImpl(); 
      public &lt;T extends Comparable&gt; List&lt;T&gt; sortList(List&lt;T&gt; list) { 
        return this.sortImpl.sortList(list); 
      } 
    }  </pre>
<p class="calibre2">This is much better, because if you'd like to change the structure of the library or the sorting logic, as long as you keep the structure of <kbd class="calibre12">SortUtil</kbd> unchanged, the consumers of your library don't have to change their code. The <kbd class="calibre12">SortUtil</kbd> class is still tightly coupled to <kbd class="calibre12">BubbleSortUtil</kbd> in that it is directly instantiating it, but we'll be improving this is in a subsequent chapter, so let's live with it for now.</p>
<p class="calibre2">Running the code at this stage should result in the same output as last time. Now, before we announce to the world that our <kbd class="calibre12">packt.sortutil</kbd> module is ready for consumption, think back to the problem Jack faced in <a target="_blank" href="part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4"><span>Chapter 1</span></a>, <em class="calibre22">Introducing Java 9 Modularity</em>. He had created a sorting library JAR file with pretty much the same design as far as classes are concerned--an internal <kbd class="calibre12">BubbleSortUtilImpl</kbd> and an external <kbd class="calibre12">SortUtil</kbd>. The problem he ran into was the fact that a certain class is either <em class="calibre22">internal</em> or <em class="calibre22">external</em> was only a matter of convention and wasn't enforceable without Jack lumping his code into a single package just to leverage the package-private mechanisms. Developers using his library started to use the <kbd class="calibre12">BubbleSortUtilImpl</kbd> class that they weren't supposed to use. Let's see if we have the same problem with our <kbd class="calibre12">sortutil</kbd> module, and if so, if there are better tools to protect certain classes using the module system in Java 9.</p>
<p class="calibre2">The answer is simple. Yes, we have the same problem that Jack ran into. Any consumer of the <kbd class="calibre12">sortutil</kbd> module could easily use <kbd class="calibre12">BubbleSortUtilImpl</kbd> directly. That's because the class is in a package that's exported from the module. We'd like to avoid that by encapsulating the class and prevent its usage outside the module. How do we do that? Simple! Just move the class to another package! Like we've already seen, the Java Platform Module System expects us to specify what packages are visible outside the module. If any type is accessible outside any module, it's only because it belongs to an exported package in that module. Which is why refactoring the type into a new package is a potential solution. As long as the new package doesn't show up with the <kbd class="calibre12">exports</kbd> clause in the module definition file of the module, the classes in the package are effectively hidden from outside use, like we've already seen:</p>
<div class="packt_figure"><img class="image-border34" src="../images/00040.jpeg"/></div>
<p class="calibre2">Here's a diagram of the modules, revisited with our newest change:</p>
<div class="packt_figure"><img class="image-border35" src="../images/00041.jpeg"/></div>
<div class="packt_infobox">Remember that packages in Java are not hierarchical. In this example, the packages <kbd class="calibre28">packt.util</kbd> and <kbd class="calibre28">packt.util.impl</kbd> are two separate packages that are not related in any way. Just because you've exported the package <kbd class="calibre28">packt.util</kbd>, it doesn't mean that you are automatically exporting <kbd class="calibre28">packt.util.impl</kbd> also. Nor does it mean that <kbd class="calibre28">packt.util.impl</kbd> is somehow <em class="calibre29">within </em><kbd class="calibre28">packt.util</kbd>. That's not how packages work in Java. These are two entirely different packages, and totally unrelated as far as package semantics are concerned.</div>
<p class="calibre2">The state of the code at this time is in the bundled source code. Compiling and executing the code as before should give us the same results. However, we have solved a major problem related to class encapsulation that we discussed in <a target="_blank" href="part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4"><span>Chapter 1</span></a>, <em class="calibre22">Introducing Java 9 Modularity</em>.</p>
<p class="calibre2">Think about the potential impact of this encapsulation on a library developer. Before Java 9, every <kbd class="calibre12">public</kbd> type that was shipped in a library could have been used and accessed by the consumers of the library. Now, with Java 9 modules, a library developer has full control over what classes can be used and what are just internal. So, the library developer can refactor the <em class="calibre22">internal</em> library code without having to worry about them potentially being used. Thanks to the module contract, they are inaccessible and hence guaranteed to be unused in code outside the module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Module versioning</h1>
                
            
            <article>
                
<p class="calibre2">There's one aspect of module dependency that you might have noticed is missing from what we've covered so far--versioning. When you declare a module definition, can you specify a version number for the module? Also, when you specify that a certain module requires another module, can you also specify which version of module it needs? The answer to both the questions is no. For various reasons, module versioning is not a feature that's available in the Java Module system. It is not a problem the Java platform attempts to solve.</p>
<p class="calibre2">The biggest advantage and utility with module versioning comes with dependency management. Think of tools like Maven or Gradle. These tools allow you to configure specific versions of external dependencies which they can then automatically download for you from some remote repository, and then make them available in the classpath. The Java platform does not attempt to do this, or to solve any dependency management problems. It assumes that all the dependencies are already available, perhaps assembled by a tool like Maven or Gradle. In <a target="_blank" href="part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 1</a>, <em class="calibre22">Introducing Java 9 Modularity</em>, I had mentioned how build tools like Maven or Gradle achieve predictability and consistency in assembling dependencies, but they cannot validate the accuracy or completeness of what's assembled. This is where the Java module system steps in. The platform assumes that all the necessary source files and classes are already there! Whatever your build tools are, and whatever the means you take to assemble your code and libraries, the Java platform works on what you have as a result and <em class="calibre22">then</em> makes sure the module contracts are being met.</p>
<p class="calibre2">This is a nuanced topic, and the reasoning can be debated extensively, but it's important to remember that module versioning is not available in Java 9. To manage multiple versions of modules, you are free to use whatever tools or processes you have already been using to pull in jars and libraries. In <a target="_blank" href="part0187.html#5IAP60-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 12</a>, <span><em class="calibre22">Using Build Tools and Testing Java Modules</em>, we examine how to integrate a Maven multi-module project with a Java 9 modular application to leverage the best of both worlds.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Rethinking package structure</h1>
                
            
            <article>
                
<p class="calibre2">The fact that you are required to <em class="calibre22">export</em> package names from modules has an interesting implication on the way we organize our types into packages in Java 9. Historically, the package construct has been used by Java developers to provide <em class="calibre22">namespaces</em> for Java types. While these namespaces created by package names serve the purpose, at least in theory, to prevent type name collisions and to affect visibility of package-private member variables and types, they also serve a slightly more informal purpose of grouping related types for search-ability and maintainability of code.</p>
<p class="calibre2">There's an additional significance to packages in Java 9 that affects how you group your classes and other types into packages--visibility outside modules. For instance, if you need to hide type <em class="calibre22">A</em> within a module and export type <em class="calibre22">B</em> to outside the module, you are essentially required to place types <em class="calibre22">A</em> and <em class="calibre22">B</em> in two separate packages. In most cases, typical internal classes of libraries are associated with different namespaces and packages in the pre-Java 9 world anyway, so this shouldn't be a big change in the way we do this. But it's important to note that this new change could factor into our decision to place classes in one package versus another.</p>
<p class="calibre2">Now that we've seen two modules and inter-modular dependency, I'd like you to introduce you to the concept of a module graph. You'll likely see this in a lot of Java documentation over time as a good way to represent relationships between modules. The way to draw a module graph is to plot modules as nodes and the relationships between modules with an arrow. If module <em class="calibre22">A</em> depends on module <em class="calibre22">B</em>, the arrow is drawn from <em class="calibre22">A</em> to <em class="calibre22">B</em>.</p>
<p class="calibre2">Here's the module graph for the code we have in the address book application so far:</p>
<div class="packt_figure"><img class="image-border36" src="../images/00042.jpeg"/></div>
<p class="calibre2">It is very simple at this time, but as we learn more about the module system and evolve our code, we'll be coming back to this module graph and adding detail to it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding module path arguments</h1>
                
            
            <article>
                
<p class="calibre2">Our example application is comprised of two Java modules. We have the source of both those modules in the module source path. In reality, it's common to be working on module sources that depend on compiled third-party modules pulled in as dependencies. In such cases, you'll need to provide to the compiler the module source path containing the module source files, and the module path for the compiled dependencies. The compiler needs a distinction between the code it needs to compile (in  <kbd class="calibre12">--module-source-path</kbd>) and the location of compiled dependencies and libraries ( <kbd class="calibre12">--module-path</kbd>). When it comes to execution, you just pass in  <kbd class="calibre12">--module-path</kbd> pointing to the compiled modules.</p>
<p class="calibre2">Here are the command line argument values passed to the compiler and runtime:</p>
<table class="msotablegrid">
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre8"/>
<td class="calibre8"> <kbd class="calibre12">--module-source-path</kbd></td>
<td class="calibre8"> <kbd class="calibre12">--module-path</kbd></td>
</tr>
<tr class="calibre7">
<td class="calibre8"><kbd class="calibre12">javac</kbd></td>
<td class="calibre8">Locations of all source modules</td>
<td class="calibre8">Locations of compiled modules that the source modules depend on.</td>
</tr>
<tr class="calibre7">
<td class="calibre8"><kbd class="calibre12">java</kbd></td>
<td class="calibre8">&lt;Not provided&gt;</td>
<td class="calibre8">Location of all compiled modules - including app modules and compiled module dependencies</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Revisiting classpath</h1>
                
            
            <article>
                
<p class="calibre2">We've seen that the new Java 9 platform comes with some new abilities to do module level compilation and execution using the <kbd class="calibre12">--module-source-path</kbd> and the <kbd class="calibre12">--module-path</kbd> arguments. It is now module-aware and knows what to do in order to compile and execute Java 9 modules. It's very likely that these flags are going to find increased usage as developers embrace Java modularity.</p>
<p class="calibre2">At the same time, there's a familiar compiler parameter that will, over time, see decreased usage--the <kbd class="calibre12">-classpath</kbd> parameter. The classpath that has been a concept that's essential to programming in Java for so many years, is for the most part, not required anymore!</p>
<p class="calibre2">For about two decades now, the Java classpath has played the crucial role of being the home for all the classes in any given Java application. Any Java application is obviously made up of multiple classes, often in multiple jar files. As a Java developer, all you had to do to get a class into play was to add it to the classpath. That would guarantee that the runtime would see it. Of course, there are still access modifiers such as <kbd class="calibre12">private</kbd>, <kbd class="calibre12">public</kbd>, and <kbd class="calibre12">protected</kbd> that control who gets to access a given Java type. But still, the presence of a class file in a classpath was all it took to make it <em class="calibre22">available</em> to the runtime.</p>
<p class="calibre2">Now, consider the new world where there are no standalone class files and everything is made up of modules. A Java 9 modular application is comprised of a number of different modules that have dependency on one another. Given the module paths, the compiler and runtime can now know where all the classes are. Also, thanks to the module convention, the classes that belong to the module reside in the module folder itself. In this case, why does Java need any other information to access the classes required for an application? The concept of a classpath isn't even needed anymore!</p>
<p class="calibre2">Wait! Before you let go of everything you've learned about classpaths from your memory, I should let you know that what I'm describing is the ideal scenario. Yes, ideally, classpath will likely hold lesser importance in Java in the future. However, we are still not done with it yet. We will be revisiting classpaths a few times in this book, especially in the context of working with older codebases and when migrating code to Java 9. More on that in <a target="_blank" href="part0161.html#4PHAI0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 10</a>, <span><em class="calibre22">Preparing Your Code for Java 9</em></span> .</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Revisiting the classpath problems</h1>
                
            
            <article>
                
<p class="calibre2">In <a target="_blank" href="part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4"><span>Chapter 1</span></a>, <em class="calibre22">Introducing Java 9 Modularity</em>, we looked at two problems faced by our friends Jack and Amit:</p>
<ul class="calibre14">
<li class="calibre15">Jack couldn't easily <em class="calibre22">encapsulate</em> internal library types and prevent use of that type outside the library, while retaining the ability to freely use them inside his own library</li>
<li class="calibre15">Amit couldn't <em class="calibre22">reliably</em> assemble a set of compiled Java code and guarantee that all the dependencies and imports of those types are sufficiently met before the program actually hits the dependency at runtime</li>
</ul>
<p class="calibre2">Have we solved these problems with the module system? Thankfully, yes!</p>
<p class="calibre2">We've already seen how the Java module's encapsulation prevents certain types from being accessed outside the module, even if the type is <kbd class="calibre12">public</kbd>, unless the package they belong to is explicitly exported. Indeed, we applied the same concept to hide the <kbd class="calibre12">BubbleSortUtilImpl</kbd> class from external use. When it comes time to upgrade our library, should we feel the need to modify (or even remove) that class, we can rest assured that the only consumer of that code is in the library itself.</p>
<p class="calibre2">How about the second problem--runtime verification? It turns out, the Java runtime refers to the same <kbd class="calibre12">module-info</kbd> module descriptor (this time in <kbd class="calibre12">.class</kbd> format) to figure this out. You ran the <kbd class="calibre12">Main</kbd> class in the <kbd class="calibre12">packt.addressbook</kbd> module and it worked fine because the runtime found the dependent module <kbd class="calibre12">packt.sortutil</kbd> in the module path. Let's see what happens if it doesn't find it. If I were to delete the compiled <kbd class="calibre12">sortutil</kbd> directory in the <kbd class="calibre12">out</kbd> directory, and run <kbd class="calibre12">packt.addressbook/packt.addressbook.Main</kbd> again, notice the error you get:</p>
<pre class="calibre23"><strong class="calibre1">$ java --module-path out --module packt.addressbook/packt.addressbook.Main</strong>
<strong class="calibre1">  <br class="title-page-name"/>  Error occurred during initialization of VM</strong>
<strong class="calibre1">  java.lang.module.ResolutionException: Module sortutil not found,<br class="title-page-name"/>   required by addressbook</strong>
<strong class="calibre1">  at java.lang.module.Resolver.fail(java.base@9/Resolver.java:841)</strong>
<strong class="calibre1">  at java.lang.module.Resolver.resolve(<br class="title-page-name"/>   java.base@9/Resolver.java:154)</strong>
  <strong class="calibre1">...</strong> </pre>
<p class="calibre2">The error message points out that the <kbd class="calibre12">packt.sortutil</kbd> module is not found, but the important thing to notice here is <em class="calibre22">when</em> the error is thrown. It's not when the class is loaded and the runtime tries to find the dependent types that it encounters this error. The error occurs right at the VM initialization time as the message clearly mentions. This is a huge advantage when it comes to reliability of your Java code. If there are potential errors, the runtime catches that right at initialization and not at some arbitrary point in time during execution.</p>
<p class="calibre2">One of the requirements that the module system was designed to meet is to achieve <em class="calibre22">fidelity across phases</em>. What does this mean? You've seen how the module descriptor enabled you to build modules, encapsulate types, and verify availability of the necessary dependencies by allowing you to specify the contract about each module. These benefits affect not only the compilation process of your code, but also the runtime process. The same module definition that lets the compiler know something is wrong when a required module is missing can also provide the runtime with the same information! Thanks to the module descriptor being compiled into the code as a class file, the Java runtime can also read the same descriptor and know well in advance if every module that is depended upon by the code that needs to be run is available. You get the same behavior and error checking across the compilation and execution phases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we've created a second Java module and established inter-module dependency. We learned how to set up <kbd class="calibre12">requires</kbd> and <kbd class="calibre12">exports</kbd> in module definition files. With two modules, we are finally able to see the modularity features that attempt to solve some of the problems in code organization and management that we've discussed in <a target="_blank" href="part0021.html#K0RQ0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4"><span>Chapter 1</span>,</a> <em class="calibre22">Introducing Java 9 Modularity</em>.</p>
<p class="calibre2">Now that we have a basic understanding of how to create Java 9 modules and use them in other modules, let's focus our attention to the platform itself. Java 9 not only comes with the module system that's meant for developers to use in order to create modules, it also comes with a completely revamped JRE and JDK that are themselves modularized. In the next chapter, you'll learn about the modularization of the platform, how it affects developers, and how it is, in a way, essential for bringing in modularity support into the Java language.</p>


            </article>

            
        </section>
    </body></html>