["```java\nexport PATH=/Library/Java/JavaVirtualMachines/<graalvm>/Contents/Home/bin:$PATH\nexport JAVA_HOME=/Library/Java/JavaVirtualMachines/<graalvm>/Contents/Home\n```", "```java\nsudo xattr -r -d com.apple.quarantine <graalvm-path>\n```", "```java\nexport PATH=<graalvm>/bin:$PATH\nexport JAVA_HOME=<graalvm>\n```", "```java\nsetx /M PATH \"C:\\Progra~1\\Java\\<graalvm>\\bin;%PATH%\"\nsetx /M JAVA_HOME \"C:\\Progra~1\\Java\\<graalvm>\"\n```", "```java\njava version \"11.0.10\" 2021-01-19 LTS\nJava(TM) SE Runtime Environment GraalVM EE 21.0.0 (build 11.0.10+8-LTS-jvmci-21.0-b06)\nJava HotSpot(TM) 64-Bit Server VM GraalVM EE 21.0.0 (build 11.0.10+8-LTS-jvmci-21.0-b06, mixed mode, sharing)\n```", "```java\nidealgraphvisualizer\n```", "```java\njava -Dgraal.Dump=:n <java class file>\n```", "```java\nclass FibonacciCalculator{\n    public int[] findFibonacci(int count) {\n        int fib1 = 0;\n        int fib2 = 1;\n        int currentFib, index;\n        int [] fibNumbersArray = new int[count];\n        for(index=2; index < count; ++index ) {    \n            currentFib = fib1 + fib2;    \n            fib1 = fib2;    \n            fib2 = currentFib;    \n            fibNumbersArray[index - 1] = currentFib;\n        }\n        return fibNumbersArray;\n    }\n    public static void main(String args[])  \n    {\n        FibonacciCalculator fibCal =             new FibonacciCalculator();\n        long startTime = System.currentTimeMillis();\n        long now = 0;\n        long last = startTime;\n        for (int i = 1000000000; i < 1000000010; i++) {\n            int[] fibs = fibCal.findFibonacci(i);\n            long total = 0;\n            for (int j=0; j<fibs.length; j++) {\n                total += fibs[j];\n            }\n            now = System.currentTimeMillis();\n            System.out.printf(\"%d (%d ms)%n\", i , now – last);\n            last = now;\n        }\n        long endTime = System.currentTimeMillis();\n        System.out.printf (\"total: (%d ms)%n\",            System.currentTimeMillis() - startTime);\n    }\n}\n```", "```java\n-XX:-UseJVMCICompiler\n```", "```java\njava -XX:-UseJVMCICompiler FibonacciCalculator/\n```", "```java\n-Dgraal.CompilerConfiguration\n```", "```java\n-Dgraal.UsePriorityInlining (true/false)\n```", "```java\n-Dgraal.Vectorization (true/false)\n```", "```java\n-Dgraal.OptDuplication (true/false)\nThis next flag can be set to values between -1 and 1\\. When the value is below 0, the JIT reduces the effort spent on inlining. This will improve the startup and provides throughput. When the value is greater than 0, the JIT spends more effort in inlining, increasing the performance:\n-Dgraal.TuneInlinerExploration (-1 to +1)\n```", "```java\n-Dgraal.TraceInlining (true/false)\n```", "```java\ncompilation of FibonacciCalculator.main(String[]): \n  at FibonacciCalculator.main(FibonacciCalculator.java:20) [bci: 4]: <GraphBuilderPhase> FibonacciCalculator.<init>(): yes, inline method\n  at FibonacciCalculator.main(FibonacciCalculator.java:25) [bci: 32]: <GraphBuilderPhase> FibonacciCalculator.findFibonacci(int): no, bytecode parser did not replace invoke\ncompilation of FibonacciCalculator.main(String[]): \n  at FibonacciCalculator.main(FibonacciCalculator.java:20) [bci: 4]: <GraphBuilderPhase> FibonacciCalculator.<init>(): yes, inline method\n  at FibonacciCalculator.main(FibonacciCalculator.java:25) [bci: 32]: \n  ├──<GraphBuilderPhase> FibonacciCalculator.findFibonacci(int): no, bytecode parser did not replace invoke\n  └──<PriorityInliningPhase> FibonacciCalculator.findFibonacci(int): yes, worth inlining according to the cost-benefit analysis.\ncompilation of java.lang.String.hashCode(): \n  at java.lang.String.hashCode(String.java:1504) [bci: 19]: \n  ├──<GraphBuilderPhase> java.lang.String.isLatin1(): no, bytecode parser did not replace invoke\n  └──<PriorityInliningPhase> java.lang.String.isLatin1(): yes, budget was large enough to inline this callsite.\n  at java.lang.String.hashCode(String.java:1504) [bci: 29]: \n  ├──<GraphBuilderPhase> java.lang.StringLatin1.hashCode(byte[]): no, bytecode parser did not replace invoke\n  └──<PriorityInliningPhase> java.lang.StringLatin1.hashCode(byte[]): yes, budget was large enough to inline this callsite.\n```", "```java\npublic class DemonstrateGraalGraph {\n    public long calculateResult() {\n        long result = 0;\n        for (int i=0; i<2000; i++) {\n            result = result + i;\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n        DemonstrateGraalGraph obj =            new DemonstrateGraalGraph();\n        while (true) { \n    //This loop is just to reach the compiler threshold\n            long result = obj.calculateResult();\n            System.out.println(\"Total: \" + result);\n        }\n    }\n}\n```", "```java\njava -XX:CompileOnly=DemonstrateGraalGraph::calculateResult \\\n -XX:-UseOnStackReplacement \\\n -Dgraal.Dump=:1 \\\n -XX:+PrintCompilation \\    \n  -Dgraal.FullUnroll=false \\\n  -Dgraal.PartialUnroll=false \\\n  -Dgraal.LoopPeeling=false \\\n  -Dgraal.LoopUnswitch=false \\\n  -Dgraal.OptScheduleOutOfLoops=false \\\n  -Dgraal.VectorizeLoops=false  \\\nDemonstrateGraalGraph\n```", "```java\npublic void method(boolean flag) {\n    Class1 object1 = new Class1();\n    Class2 object2 = new Class2();\n    //some processing\n    object1.parameter = value;\n    //some more logic\n    if(flag) {\n        return object1;\n    }\n    return object2;\n}\n```", "```java\npublic void method(boolean flag) {\n\n    Class2 object2 = new Class2();\n\n    tempValue = value;\n    if(flag) {\n        Class1 object1 = new Class1();\n        object1.parameter = tempValue;\n        return object1;\n    }\n    return object2;\n}\n```", "```java\npublic class OptionalDouble {\n    public double getAsDouble() {\n        if (!isPresent) {\n            throw new                 NoSuchElementException(\"No valuepresent\");\n        }\n        return value;\n    }\n}\n```"]