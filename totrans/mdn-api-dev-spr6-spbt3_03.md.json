["```java\nopenapi: 3.0.3info:\n  title: Sample Ecommerce App\n  description: >\n    'This is a ***sample ecommerce app API***.\n     You can find\n    out more about Swagger at [swagger.io]\n      (http://swagger.io).\n    Description supports markdown markup. For example,\n      you can\n    use the `inline code` using back ticks.'\n  termsOfService: https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-SpringBoot-3/blob/main/LICENSE\n  contact:\n    name: Packt Support\n    url: https://www.packt.com\n    email: support@packtpub.com\n  license:\n    name: MIT\n    url: https://github.com/PacktPublishing/Modern-API-\n         Development-with-Spring-6-and-Spring-Boot3/blob\n         /main/LICENSE\n  version: 1.0.0\nexternalDocs:\n  description: Any document link you want to generate along\n               with API.\n  url: http://swagger.io\n```", "```java\nservers:  - url: https://ecommerce.swagger.io/v2\ntags:\n  - name: cart\n    description: Everything about cart\n    externalDocs:\n      description: Find out more (extra document link)\n      url: http://swagger.io\n  - name: order\n    description: Operation about orders\n```", "```java\ncomponents:  schemas:\n    Cart:\n      description: Shopping Cart of the user\n      type: object\n      properties:\n        customerId:\n          description: Id of the customer who possesses\n          the cart\n          type: string\n        items:\n          description: Collection of items in cart.\n          type: array\n          items:\n            $ref: '#/components/schemas/Item'\n```", "```java\norderDate:  type: string\n  format: date-time\n```", "```java\n# Relative Schema Document$ref: Cart.yaml\n# Relative Document with embedded Schema\n$ref: definitions.yaml#/Cart\n```", "```java\nItem:  description: Items in shopping cart\n  type: object\n  properties:\n    id:\n      description: Item Identifier\n      type: string\n    quantity:\n      description: The item quantity\n      type: integer\n      format: int32\n    unitPrice:\n      description: The item's price per unit\n      type: number\n      format: double\n```", "```java\npaths:  /api/v1/carts/{customerId}:\n    get:\n      tags:\n        - cart\n      summary: Returns the shopping cart\n      description: Returns the shopping cart of\n      given customer\n      operationId: getCartByCustomerId\n      parameters:\n        - name: customerId\n          in: path\n          description: Customer Identifier\n          required: true\n          schema:\n            type: string\n      responses:\n        200:\n          description: successful operation\n          content:\n            application/xml:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/Cart'\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/Cart'\n        404:\n          description: Given customer ID doesn't exist\n          content: {}\n```", "```java\n    responses:  200:    description: operation successful      headers:        X-RateLimit-Limit:          schema:            type: integer\n    ```", "```java\nswaggerCodegen 'org.openapitools:openapi-generator-cli:6.2.1'compileOnly 'io.swagger:swagger-annotations:1.6.4'\ncompileOnly 'org.springframework.boot:spring-boot-starter-\n             validation'\ncompileOnly 'org.openapitools:jackson-databind-nullable:0.2.3'\nimplementation 'com.fasterxml.jackson.dataformat:jackson-\n                dataformat-xml'\nimplementation 'org.springframework.boot:spring-boot-starter-\n                hateoas'\nimplementation 'io.springfox:springfox-oas:3.0.0'\n```", "```java\n    plugins {  …  …  id 'config.json (/src/main/resources/api/config.json):\n\n    ```", "```java\n\n    ```", "```java\n    **/*Controller.java\n    ```", "```java\n    swaggerSources {  def typeMappings = 'URI=URI'  def importMappings = 'URI=java.net.URI'  eStore {    def apiYaml = \"${rootDir}/src/main/resources/api/openapi.     yaml\"    def configJson = \"${rootDir}/src/main/resources/api/config.     json\"    inputFile = file(apiYaml)    def ignoreFile = file(\"${rootDir}/src/main/resources/api/.openapi-generator-ignore\")    code {      language = 'spring'      configFile = file(configJson)      rawOptions = ['--ignore-file-override',ignoreFile,                   '--type-mappings', typeMappings,                   '--import-mappings',                      importMappings]                   as List<String>      components = [models: true, apis: true,supportingFiles:        'ApiUtil.java']      dependsOn validation    }  }}\n    ```", "```java\ncompileJava.dependsOn generateSwaggerCode task as a dependency to the processResources task:\n\n```", "```java\n\nYou may get a warning in prior to Gradle 8 versions if you don’t define this dependency, and but it will still work. However, this code block is required for the Gradle 8 version.\n\n1.  `sourceSets`. This makes the generated source code and resources available for development and build:\n\n    ```", "```java\n\nThe source code will be generated in the `/build` directory of the project, such as `Chapter03\\build\\swagger-code-eStore`. This will append the generated source code and resources to Gradle `sourceSets`.\nImportant note\nYou have generated the API Java interfaces and models using the Swagger Codegen utility. Therefore, when you load the project for the first time in your IDE, you may get errors if you don’t run your build because IDE won’t find the generated Java files (models and API Java interfaces). You can run the build’s `gradlew clean build` command to generate these files.\n\n1.  `build` path. The Java version should match the version defined in the property of `build.gradle` (`sourceCompatibility = '17'`) or in the IDE settings:\n\n    ```", "```java\n\nOnce the build is executed successfully, you can find the generated code in the `build` directory, as shown in the following screenshot:\n![Figure 3.2 ﻿– The OpenAPI-generated code](img/Figure_03.2_B19349.jpg)\n\nFigure 3.2 – The OpenAPI-generated code\nAnd that’s it. Once you follow all the aforementioned steps, you can successfully generate the API models and API Java interfaces code. In the next section, you’ll implement the API Java interfaces generated by OpenAPI Codegen.\nImplementing the OAS code interfaces\nSo far, we have generated code that consists of e-commerce app models and API Java interfaces. These generated interfaces contain all the annotations as per the YAML description provided by us. For example, in `CartApi.java`, `@RequestMapping`, `@PathVariable`, and `@RequestBody` contain the endpoint path (`/api/v1/carts/{customerId}/items`), the value of the `path` variable (such as `{customerId}` in `path`), and the request payload (such as `Item`), respectively. Similarly, generated models contain all the mapping required to support the JSON and XML content types.\nSwagger Codegen writes the Spring code for us. We just need to implement the interface and write the business logic inside it. Swagger Codegen generates the API Java interfaces for each of the provided tags. For example, it generates the `CartApi` and `PaymentAPI` Java interfaces for the `cart` and `payment` tags, respectively. All the paths are clubbed together into a single Java interface based on the given tag. For example, all the APIs with the `cart` tag will be clubbed together into a single Java interface, `CartApi.java`.\nNow, we just need to create a class for each of the interfaces and implement it. We’ll create `CartController.java` in the `com.packt.modern.api.controllers` package and implement `CartApi`:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/java/com/packt/modern/api/controllers/CartsController.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/java/com/packt/modern/api/controllers/CartsController.java)\nHere, we just implemented the two methods for demonstration purposes. We’ll implement the actual business logic in the next chapter.\nTo add an item (`POST /api/v1/carts/{customerId}/items`) request, we just log the incoming request payload and customer ID inside the `addCartItemsByCustomerId` method. Another method, `getCartByCustomerId`, simply throws an exception. This will allow us to demonstrate the Global Exception Handler in the next section.\nAdding a Global Exception Handler\nWe have multiple controllers that consist of multiple methods. Each method may have checked exceptions or throw runtime exceptions. We should have a centralized place to handle all these errors for better maintainability and modularity and clean code.\nSpring provides an AOP feature for this. We just need to write a single class annotated with `@ControllerAdvice`. Then, we just need to add `@ExceptionHandler` for each type of exception. This exception handler method will generate user-friendly error messages with other related information.\nYou can make use of the Project Lombok library if approved by your organization for third-party library usage. This will remove the verbosity of the code for getters, setters, constructors, and so on.\nLet’s first write the `Error` class in the `exceptions` package that contains all the error information:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/java/com/packt/modern/api/exceptions/Error.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/java/com/packt/modern/api/exceptions/Error.java)\nHere, we use the following properties:\n\n*   `errorCode`: Application error code, which is different from HTTP error code\n*   `message`: A short, human-readable summary of the problem\n*   `status`: An HTTP status code for this occurrence of the problem, set by the origin server\n*   `url`: A URL of the request that produced the error\n*   `reqMethod`: A method of the request that produced the error\n\nYou can add other fields here if required. The `exceptions` package will contain all the code for user-defined exceptions and global exception handling.\nAfter that, we’ll write an `enum` called `ErrorCode` that will contain all the exception keys, including user-defined errors and their respective error codes:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/java/com/packt/modern/api/exceptions/ErrorCode.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/java/com/packt/modern/api/exceptions/ErrorCode.java)\nHere, we just added a few error code enums with their code and messages. We also just added actual error messages instead of message keys. You can add message keys and add the resource file to `src/main/resources` for internationalization.\nNext, you’ll add a utility to create an `Error` object, as shown in the following code:\n\n```", "```java\n\nFinally, we’ll create a class to implement the Global Exception Handler, as shown here:\n\n```", "```java\n\n[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/java/com/packt/modern/api/exceptions/RestApiErrorHandler.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter03/src/main/java/com/packt/modern/api/exceptions/RestApiErrorHandler.java)\nAs you can see, we marked the class with `@ControllerAdvice`, which enables this class to trace all the request and response processing by the REST controllers and allows us to handle exceptions using `@ExceptionHandler`.\nIn the previous code, we handle two exceptions – a generic internal server error exception and `HttpMediaTypeNotSupportException`. The handling method just populates the `Error` object using `ErrorCode`, `HttpServletRequest`, and `HttpStatus`. Finally, it returns the error wrapped inside `ResponseEntity` with the appropriate HTTP status.\nIn this code, you can add user-defined exceptions too. You can also make use of the `Locale` instance (a method parameter) and the `messageSource` class member to support internationalized messages.\nNow that we have designed the API and generated the code and implementation, let’s now test the implementation in the following subsection.\nTesting the implementation of the API\nOnce the code is ready to run, you can compile and build the artifact using the following command from the root folder of the project:\n\n```", "```java\n\n The previous command removes the `build` folder and generates the artifact (the compiled classes and JAR). After the successful build, you can run the application using the following command:\n\n```", "```java\n\n Now, we can perform tests using the `curl` command:\n\n```", "```java\n\n This command calls the `GET` request for `/carts` with ID `1`. Here, we demand the XML response using the `Accept` header, and we get the following response:\n\n```", "```java\n\nIf you change the `Accept` header from `application/xml` to `application/json`, you will get the following JSON response:\n\n```", "```java\n\nSimilarly, we can also call the API to add an item to the cart, as shown here:\n\n```", "```java\n\nHere, we get `[]` (an empty array) as a response because, in the implementation, we just return the empty collection. You need to provide the `Content-Type` header in this request because we send the payload (item object) along with the request. You can change `Content-Type` to `application/xml` if the payload is written in XML. If the `Accept` header value is `application/xml`, it will return the `<List/>` value. You can remove/change the `Content-Type` and `Accept` headers or use the malformed JSON or XML to test the other error response.\nThis way, we can generate the API description using OpenAPI and then use the generated models and API Java interfaces to implement the APIs.\nSummary\nIn this chapter, we opted for the design-first approach to writing RESTful web services. You learned how to write an API description using OAS and how to generate models and API Java interfaces using the Swagger Codegen tool (using the Gradle plugin). We also implemented a Global Exception Handler to centralize the handling of all the exceptions. Once you have the API Java interfaces, you can write their implementations for business logic. Now, you know how to use OAS and Swagger Codegen to write RESTful APIs. You also now know how to handle exceptions globally.\nIn the next chapter, we’ll implement fully fledged API Java interfaces with business logic with database persistence.\nQuestions\n\n1.  What is OpenAPI and how does it help?\n2.  How can you define a nested array in a model in a YAML OAS-based file?\n3.  What annotations do we need to implement a Global Exception Handler?\n4.  How can you use models or classes written in Java code in your OpenAPI description?\n5.  Why do we only generate models and API Java interfaces using Swagger Codegen?\n\nAnswers\n\n1.  OAS was introduced to solve at least a few aspects of a REST API’s specification and description. It allows you to write REST APIs in the YAML or JSON markup languages, which allows you to interact with all stakeholders, including those who are non-technical, for review and discussion in the development phase. It also allows you to generate documentation, models, interfaces, clients, and servers in different languages.\n2.  The array is defined using the following code:\n\n    ```", "```java\n\n     3.  You need a class annotation, `@ControllerAdvice`, and a method annotation, `@ExceptionHandler`, to implement the Global Exception Handler.\n4.  You can use `--type-mappings` and `--import-mappings` `rawOptions` in the `swaggerSources` task of the `build.gradle` file.\n5.  We only generate the models and API Java interfaces using Swagger Codegen because this allows the complete implementation of controllers by developers only.\n\nFurther reading\n\n*   OAS 3.0: [https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md)\n*   The Gradle plugin for OpenAPI Codegen: [https://github.com/int128/gradle-swagger-generator-plugin](https://github.com/int128/gradle-swagger-generator-plugin)\n*   OAS Code Generator configuration options for Spring: [https://openapi-generator.tech/docs/generators/spring/](https://openapi-generator.tech/docs/generators/spring/)\n*   YAML specifications: [https://yaml.org/spec/](https://yaml.org/spec/)\n*   Semantic versioning: [https://semver.org/](https://semver.org/)\n\n```"]