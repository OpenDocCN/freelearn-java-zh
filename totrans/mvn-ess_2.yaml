- en: Chapter 2. Understanding the Project Object Model (POM)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: POM is at the heart of any Maven project. This chapter focuses on the core concepts
    and best practices related to POM in building a large-scale, multi-module Maven
    project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'As we proceed with this chapter, the following topics will be covered in detail:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The POM hierarchy, super POM, and parent POM
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending and overriding POM files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven coordinates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing dependencies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transitive dependencies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency scopes and optional dependencies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Object Model (POM)
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any Maven project must have a `pom.xml` file. POM is the Maven project descriptor
    just like the `web.xml` file in your Java EE web application, or the `build.xml`
    file in your Ant project. The following code lists out all the key elements in
    a Maven `pom.xml` file. As we proceed with the book, we will discuss how to use
    each element in the most effective manner:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following code shows a sample `pom.xml` file:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: POM hierarchy
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'POM files maintain a parent-child relationship between them. A child POM file
    inherits all the configuration elements from its parent POM. Using this trick,
    Maven sticks to its design philosophy *convention over configuration*. The minimal
    POM configuration for any Maven project is extremely simple, which is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Super POM
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any POM file can point to its parent POM. In case the parent POM element is
    missing, there is a system wide POM file that is automatically treated as the
    parent POM. This POM file is well known as the **super POM**. Ultimately, all
    the application POM files get extended from the super POM. The super POM file
    is at the top of the POM hierarchy and is bundled inside `MAVEN_HOME/lib/maven-model-builder-3.3.3.jar
    - org/apache/maven/model/pom-4.0.0.xml`. In Maven 2, this was bundled inside `maven-2.X.X-uber.jar`.
    All the default configurations are defined in the super POM file. Even the simplest
    form of a POM file will inherit all the configurations defined in the super POM
    file. Whatever configuration you need to override, you can do it by redefining
    the same section in your application POM file. The following lines of code show
    the super POM file configuration, which comes with Maven 3.3.3:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The Maven central is the only repository defined under the *repositories* section.
    It will be inherited by all the Maven application modules. Maven uses these repositories
    defined under the *repositories* section to download all the dependent artifacts
    during a Maven build. The following code snippet shows the configuration block
    in `pom.xml`, which is used to define repositories:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two types of repositories in Maven: local and remote. The local repository
    is maintained in your local machine—by default at `USER_HOME/.m2/repository`.
    Anything that you build locally with `mvn install` will get deployed into the
    local repository. When you start with a fresh Maven repository, it will be empty.
    You need to download everything—from the simplest `maven-compiler-plugin` to all
    your project dependencies. A Maven build can either be an online or offline build.
    By default, it is an online build, unless you add `-o` into your Maven build command.
    If it''s an offline build, Maven assumes that all the related artifacts are readily
    available in the local Maven repository; if not, it will complain. If it is an
    online build, Maven will download the artifacts from remote repositories and store
    them in the local repository. The Maven local repository location can be changed
    to a preferred location by editing `MAVEN_HOME/conf/settings.xml` to update the
    value of the `localRepository` element:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 中有两种类型的仓库：本地和远程。本地仓库存储在您的本地机器上——默认位置为`USER_HOME/.m2/repository`。您使用`mvn
    install`在本地构建的任何内容都将部署到本地仓库。当您从一个全新的 Maven 仓库开始时，它将是空的。您需要下载所有内容——从最简单的`maven-compiler-plugin`到您项目的所有依赖项。Maven
    构建可以是在线或离线构建。默认情况下，它是在线构建，除非您在 Maven 构建命令中添加`-o`。如果是离线构建，Maven 假设所有相关工件都已在本地 Maven
    仓库中准备好；如果没有，它将报错。如果是在线构建，Maven 将从远程仓库下载工件并将它们存储在本地仓库中。可以通过编辑`MAVEN_HOME/conf/settings.xml`来更改
    Maven 本地仓库的位置，以更新`localRepository`元素的值：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Plugin repositories define where to find Maven plugins. We''ll be talking about
    Maven plugins in [Chapter 4](ch04.html "Chapter 4. Maven Plugins"), *Maven Plugins*.
    The following code snippet shows the configuration related to the plugin repositories:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 插件仓库定义了查找 Maven 插件的位置。我们将在[第 4 章](ch04.html "第 4 章。Maven 插件")*Maven 插件*中讨论 Maven
    插件。以下代码片段显示了与插件仓库相关的配置：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `build` configuration section includes all the information required to
    build a project:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`build`配置部分包括构建项目所需的所有信息：'
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `reporting` section includes the details of report plugins, which are used
    to generate reports and are later displayed on the site generated by Maven. The
    super POM only provides a default value for the output directory:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`reporting`部分包括报告插件的详细信息，这些插件用于生成报告，随后在 Maven 生成的网站上显示。超级 POM 仅提供输出目录的默认值：'
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following code snippet defines the default build profile. When no profiles
    are defined at the application level, the default build profile will get executed.
    We will be talking about profiles in [Chapter 7](ch07.html "Chapter 7. Best Practices"),
    *Best Practices*:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段定义了默认的构建配置文件。当在应用程序级别没有定义配置文件时，默认构建配置文件将被执行。我们将在[第 7 章](ch07.html "第 7
    章。最佳实践")*最佳实践*中讨论配置文件：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following figure shows an abstract view of the super POM file with key
    configuration elements:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了超级 POM 文件的抽象视图，其中包含关键配置元素：
- en: '![Super POM](img/B02157_02_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![超级 POM](img/B02157_02_01.jpg)'
- en: POM extending and overriding
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POM 扩展和覆盖
- en: 'Let''s see how POM overriding works. In the following example, we extend the
    `repositories` section to add one more repository than what is defined in the
    Maven super POM:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 POM 覆盖是如何工作的。在以下示例中，我们将`repositories`部分扩展以添加比 Maven 超级 POM 中定义的更多仓库：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Execute the following command from the directory where the above POM file is
    located:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述 POM 文件所在的目录执行以下命令：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will display the effective POM for the application, which combines all
    the default settings from the super POM file and the configuration defined in
    your application POM. In the following code snippet, you can see that the `<repositories>`
    section in the super POM file is being extended by your application-specific configuration.
    Now, the `<repositories>` section has the central repository defined in the super
    POM as well as your application-specific repository:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示应用程序的有效 POM，它结合了来自超级 POM 文件的所有默认设置以及您在应用程序 POM 中定义的配置。在以下代码片段中，您可以看到超级 POM
    文件中的`<repositories>`部分正被您的应用程序特定配置扩展。现在，`<repositories>`部分包含了超级 POM 中定义的中心仓库以及您应用程序特定的仓库：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you want to override any of the configuration elements corresponding to the
    Maven central repository inherited from the super POM file, then you have to define
    a repository in your application POM with the same repository `id` (as of the
    Maven central repository), and override the configuration element that you need.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要覆盖从超级 POM 文件继承的 Maven 中央仓库的任何配置元素，那么你必须在你的应用程序 POM 中定义一个具有相同仓库 `id`（与 Maven
    中央仓库相同）的仓库，并覆盖你需要的配置元素。
- en: 'One main advantage of the POM hierarchy in Maven is that you can extend as
    well as override the configuration inherited from the top. Say, for example, that
    you may need to keep all the plugins defined in the super POM, but just want to
    override the `version` of `maven-release-plugin`. The following configuration
    shows how to do it. By default, in the super POM, the `maven-release-plugin` version
    is 2.3.2, and here, we update it to 2.5 in our application POM. If you run `mvn
    help:effective-pom` again against the updated POM file, you will notice that the
    plugin `version` is updated, whereas the rest of the plugin configuration from
    the super POM remains unchanged:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Maven POM 层次结构的一个主要优势是，你可以扩展以及覆盖从顶层继承的配置。比如说，你可能需要保留超级 POM 中定义的所有插件，但只想覆盖 `maven-release-plugin`
    的 `version`。以下配置显示了如何操作。默认情况下，在超级 POM 中，`maven-release-plugin` 的版本是 2.3.2，而在这里，我们在应用程序
    POM 中将其更新为 2.5。如果你再次对更新的 POM 文件运行 `mvn help:effective-pom`，你会注意到插件 `version` 已更新，而来自超级
    POM 的其余插件配置保持不变：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To override the configuration of a given element or an artifact in the POM hierarchy,
    Maven should be able to uniquely identify the corresponding artifact. In the preceding
    scenario, the plugin was identified by its `artifactId`. In [Chapter 4](ch04.html
    "Chapter 4. Maven Plugins"), *Maven Plugins* we will further discuss how Maven
    locates plugins.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖 POM 层次结构中给定元素或工件的配置，Maven 应该能够唯一标识相应的工件。在前面的场景中，插件是通过其 `artifactId` 来识别的。在
    [第 4 章](ch04.html "第 4 章。Maven 插件") *Maven 插件* 中，我们将进一步讨论 Maven 如何定位插件。
- en: Maven coordinates
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven 坐标
- en: Maven coordinates uniquely identify a project, dependency, or plugin defined
    in a POM. Each entity is uniquely identified by the combination of a group identifier,
    artifact identifier, and the version (and, of course, with the packaging and the
    classifier). The group identifier is a way of grouping different Maven artifacts.
    For example, a set of artifacts produced by a company can be grouped under the
    same group identifier. The artifact identifier is the way you identify an artifact,
    which could be a JAR, WAR, or any type of an artifact uniquely identified within
    a given group. The `version` element lets you keep the same artifact in different
    versions in the same repository.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 坐标唯一标识了一个在 POM 中定义的项目、依赖项或插件。每个实体都通过组合一个组标识符、工件标识符和版本（当然，还有打包方式和分类器）来唯一标识。组标识符是一种将不同的
    Maven 工件分组的方式。例如，一个公司生产的工件集可以放在同一个组标识符下。工件标识符是识别工件的方式，这可能是一个 JAR、WAR 或任何在给定组内唯一标识的工件。`version`
    元素允许你在同一个存储库中保持同一工件的多个版本。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A valid Maven POM file must have `groupId`, `artifactId`, and `version`. The
    `groupId` and `version` elements can also be inherited from the parent POM.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有效的 Maven POM 文件必须包含 `groupId`、`artifactId` 和 `version`。`groupId` 和 `version`
    元素也可以从父 POM 继承。
- en: 'All the three coordinates of a given Maven artifact are used to define its
    path in the Maven repository. If we take the following example, the corresponding
    JAR file is installed into the local repository with the path `M2_REPO/repository/com/packt/sample-one/1.0.0/`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 Maven 工件的三个坐标都用于定义其在 Maven 仓库中的路径。如果我们以以下示例为例，相应的 JAR 文件被安装到本地仓库的路径为 `M2_REPO/repository/com/packt/sample-one/1.0.0/`：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you have gone through the elements of the super POM file carefully, you might
    have noticed that it does not have any of the previously mentioned elements—no
    `groupId`, `artifactId`, or `version`. Does this mean that the super POM file
    is not a valid POM? The super POM file is similar to an abstract class in Java.
    It does not work by itself; it must be inherited by a child POM. Another way to
    look at the super POM file is that it's the Maven's way of sharing default configurations.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细阅读了超级 POM 文件的内容，可能会注意到它没有之前提到的任何元素——没有 `groupId`、`artifactId` 或 `version`。这难道意味着超级
    POM 文件不是一个有效的 POM 文件吗？超级 POM 文件类似于 Java 中的抽象类。它不能单独工作；它必须被子 POM 继承。另一种看待超级 POM
    文件的方式是，它是 Maven 分享默认配置的方式。
- en: 'Once again, if you look at the `<pluginManagement>` section of the super POM,
    as shown in the following code snippet, you will notice that a given plugin artifact
    is only identified by its `artifactId` and `version` elements. This contradicts
    what was mentioned before: a given artifact is uniquely identified by the combination
    of `groupId`, `artifactId`, and `version`. How is this possible?'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，如果你查看超级 POM 的 `<pluginManagement>` 部分，如以下代码片段所示，你会注意到一个特定的插件工件仅通过其 `artifactId`
    和 `version` 元素来识别。这与之前提到的内容相矛盾：一个特定的工件通过 `groupId`、`artifactId` 和 `version` 的组合来唯一标识。这是如何可能的？
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There is an exception for plugins. You need not specify `groupId` for a plugin
    in the POM file—it is optional. By default, Maven uses `org.apache.maven.plugins`
    or `org.codehaus.mojo` as `groupId`. Have a look at the following section in `MAVEN_HOME/conf/settings.xml`.
    Everything that you define in this file will be globally applicable for all the
    Maven builds, which run in the corresponding machine. In case you want to keep
    the configuration at user level (in a multi-user environment), you can simply
    copy the `settings.xml` file from `MAVEN_HOME/conf` to `USER_HOME/.m2`. If you
    want to add the additional `groupId` elements for plugin lookup, you will have
    to uncomment the following section and add them there:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于插件有一个例外。在 POM 文件中，对于插件不需要指定 `groupId`——它是可选的。默认情况下，Maven 使用 `org.apache.maven.plugins`
    或 `org.codehaus.mojo` 作为 `groupId`。请查看 `MAVEN_HOME/conf/settings.xml` 中的以下部分。在这个文件中定义的所有内容都将对在相应机器上运行的所有的
    Maven 构建全局有效。如果你想在用户级别（在多用户环境中）保留配置，你可以简单地从 `MAVEN_HOME/conf` 复制 `settings.xml`
    文件到 `USER_HOME/.m2`。如果你想为插件查找添加额外的 `groupId` 元素，你必须取消注释以下部分并添加它们：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will be discussing Maven plugins in detail in [Chapter 4](ch04.html "Chapter 4. Maven
    Plugins"), *Maven Plugins*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 4 章](ch04.html "第 4 章。Maven 插件") *Maven 插件* 中详细讨论 Maven 插件。
- en: The parent POM
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 父 POM
- en: When we deal with hundreds of Maven modules, we need to structure the project
    to avoid any redundancies or duplicate configurations. If not, it will lead to
    a huge maintenance nightmare. Let's have a look at some popular open source projects.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理数百个 Maven 模块时，我们需要对项目进行结构化，以避免任何冗余或重复配置。否则，它将导致巨大的维护噩梦。让我们看看一些流行的开源项目。
- en: 'The WSO2 Carbon Turing project, available at [https://svn.wso2.org/repos/wso2/carbon/platform/branches/turing/](https://svn.wso2.org/repos/wso2/carbon/platform/branches/turing/),
    has more than 1000 Maven modules. Anyone who downloads the source code from the
    root should be able to build it with all the components. The `pom.xml` file at
    the root acts as a module aggregating POM. It defines all the Maven modules that
    need to be built under the `<modules>` element. Each module element defines the
    relative path (from the root POM) to the corresponding Maven module. There needs
    to be another POM file under the defined relative path. The root POM in the WSO2
    Carbon Turing project only acts as an aggregator module. It does not build any
    parent-child relationship with other Maven modules. The following code snippet
    shows the module configuration in the root `pom.xml`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: WSO2 Carbon Turing 项目，可在 [https://svn.wso2.org/repos/wso2/carbon/platform/branches/turing/](https://svn.wso2.org/repos/wso2/carbon/platform/branches/turing/)
    找到，包含超过 1000 个 Maven 模块。任何从根目录下载源代码的人都应该能够使用所有组件构建它。根目录下的 `pom.xml` 文件充当模块聚合 POM。它定义了需要在
    `<modules>` 元素下构建的所有 Maven 模块。每个模块元素定义了从根 POM 到相应 Maven 模块的相对路径。在定义的相对路径下需要另一个
    POM 文件。WSO2 Carbon Turing 项目的根 POM 只充当聚合模块。它不与其他 Maven 模块建立任何父子关系。以下代码片段显示了根 `pom.xml`
    中的模块配置：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s have a look at the POM file inside the `parent` module. This POM
    file defines plugin repositories, a distribution repository, plugins, and a set
    of properties. This does not have any dependencies, and this is the POM file that
    acts as the parent for all the other Maven submodules. The parent POM file has
    the following coordinates:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `parent` 模块内部的 POM 文件。这个 POM 文件定义了插件仓库、分发仓库、插件和一系列属性。它没有依赖项，这是作为所有其他
    Maven 子模块父 POM 的 POM 文件。父 POM 文件具有以下坐标：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you look at the POM file inside the `components` module, it refers to `parent/pom.xml`
    as the parent Maven module. The value of the `relativePath` element, by default,
    refers to the `pom.xml` file a level above, that is, `../pom.xml`. However, in
    this case, it is not the parent POM; hence, the value of the element must be overridden
    and set to `../parent/pom.xml`, shown as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`components`模块内的POM文件，它将`parent/pom.xml`作为父Maven模块。默认情况下，`relativePath`元素的值指向位于其上一级的`pom.xml`文件，即`../pom.xml`。然而，在这种情况下，它不是父POM；因此，该元素的值必须被覆盖并设置为`../parent/pom.xml`，如下所示：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you go inside the `components` module and run `mvn help:effective-pom`,
    you will notice that an effective POM aggregates both the configurations defined
    in `parent/pom.xml` and `components/pom.xml`. Parent POM files help to propagate
    common configuration elements to downstream Maven modules, and it can go up to
    many levels. The `components/pom.xml` file acts as the parent POM for Maven modules
    below its level. For example, let''s have a look at the following `components/identity/pom.xml`
    file. It has a reference to the `components/pom.xml` file as its parent. Note
    that here we do not need to use the `relativePath` element, since the corresponding
    parent POM is at the default location:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进入`components`模块并运行`mvn help:effective-pom`，你会注意到一个有效的POM会聚合`parent/pom.xml`和`components/pom.xml`中定义的配置。父POM文件有助于将公共配置元素传播到下游Maven模块，它可以向上传播到许多级别。`components/pom.xml`文件作为其级别以下Maven模块的父POM。例如，让我们看看下面的`components/identity/pom.xml`文件。它引用了`components/pom.xml`文件作为其父文件。请注意，在这里我们不需要使用`relativePath`元素，因为相应的父POM位于默认位置：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A complete list of elements in a POM file is explained in detail at [http://maven.apache.org/ref/3.3.3/maven-model/maven.html](http://maven.apache.org/ref/3.3.3/maven-model/maven.html).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: POM文件中所有元素的完整列表在[http://maven.apache.org/ref/3.3.3/maven-model/maven.html](http://maven.apache.org/ref/3.3.3/maven-model/maven.html)中详细解释。
- en: Managing POM dependencies
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理POM依赖项
- en: 'In a large-scale development project with hundreds of Maven modules, managing
    dependencies could be a hazardous task. There are two effective ways to manage
    dependencies: POM inheritance and dependency grouping. With POM inheritance, the
    parent POM has to define all the common dependencies used by its child modules
    under the `dependencyManagement` section. In this way, we can avoid all the duplicate
    dependencies. Also, if we have to update the version of a given dependency, then
    we only have to make changes in one place. Let''s take the same example we discussed
    before using the WSO2 Carbon Turing project. Let''s have a look at the `dependencyManagement`
    section of `parent/pom.xml` (only a part of the POM file is shown here):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个拥有数百个Maven模块的大型开发项目中，管理依赖项可能是一项危险的任务。有两种有效的方法来管理依赖项：POM继承和依赖分组。使用POM继承时，父POM必须在`dependencyManagement`部分定义其子模块使用的所有公共依赖项。这样，我们可以避免所有重复的依赖项。此外，如果我们必须更新给定依赖项的版本，我们只需在一个地方进行更改。让我们以之前讨论的WSO2
    Carbon Turing项目为例。让我们看看`parent/pom.xml`中的`dependencyManagement`部分（这里只显示了POM文件的一部分）：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To know more about dependency management, refer to *Introduction to the Dependency
    Mechanism*, available at [http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html](http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于依赖项管理的信息，请参阅[依赖机制简介](http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html)。
- en: 'Let''s have a look at the `dependency` section of `identity/org.wso2.carbon.identity.core/4.2.3/pom.xml`,
    which extends from `components/pom.xml`. Here, you will only see `groupId` and
    `artifactId` of a given dependency, and not `version`. The version of each dependency
    is managed through the `dependencyManagement` section of the parent POM. In case
    any child Maven module wants to override the version of an inherited dependency,
    it can simply add the `version` element:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`identity/org.wso2.carbon.identity.core/4.2.3/pom.xml`文件中的`dependency`部分，它继承自`components/pom.xml`。在这里，你将只能看到给定依赖项的`groupId`和`artifactId`，而不是`version`。每个依赖项的版本通过父POM中的`dependencyManagement`部分进行管理。如果任何子Maven模块想要覆盖继承的依赖项的版本，它只需简单地添加`version`元素：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Another best practice to highlight here is the way dependency versions are
    specified in the parent POM file, which is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要强调的另一个最佳实践是，在父POM文件中指定依赖项版本的方式，如下所示：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Instead of specifying the version number inside the `dependency` element itself,
    here, we have taken it out and represented the version as a property. The value
    of the property is defined under the `properties` section of the parent POM, as
    shown in the following line of code. This makes POM maintenance extremely easy:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The second approach to manage dependencies is through dependency grouping. All
    the common dependencies can be grouped into a single POM file. This approach is
    much better than POM inheritance. Here, you do not need to add references to individual
    dependencies. Let's go through a simple example. First, we need to logically group
    all the dependencies into a single POM file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Apache Axis2 is an open source SOAP engine. To build an Axis2 client, you need
    to have all the following dependencies added to your project:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have multiple Axis2 client modules, in each module, you need to duplicate
    all these dependencies. The complete source code of the Apache Axis2 project is
    available at [http://svn.apache.org/viewvc/axis/axis2/java/core/trunk/modules/](http://svn.apache.org/viewvc/axis/axis2/java/core/trunk/modules/).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid dependency duplication, we can create a Maven module with all the
    previously mentioned five dependencies, as shown in the following project. Make
    sure to set the value of the `packaging` element to `pom`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, in all of your Axis2 client projects, you only need to add a dependency
    to the `com.packt.axis2-client` module, shown as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Make sure to set the value of the `type` element to `pom` under the `dependency`
    element, as we are referring to a dependency of `pom` packaging here. In case
    it is skipped, Maven, by default, will look for an artifact with the `jar` packaging:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Transitive dependencies
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The transitive dependency feature was introduced in Maven 2.0, which automatically
    identifies the dependencies of your project dependencies and gets all of them
    into the build path of your project. Let''s take the following POM as an example.
    It only has a single dependency:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you try to create an Eclipse project from the previous POM file using the
    `mvn eclipse:eclipse` command, it will result in the following `.classpath` file.
    There you can see, in addition to the `nimbus-jose-jwt-2.26.jar` file, three more
    JARs have been added. These are the transitive dependencies of the `nimbus-jose-jwt`
    dependency:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you look at the POM file of the `nimbus-jose-jwt` project, you will see that
    the previously mentioned transitive dependencies are defined there as dependencies.
    Maven does not define a limit for transitive dependencies. One transitive dependency
    may have a reference to another transitive dependency, and it can go on like that
    endlessly, given that there are no cyclic dependencies found.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Transitive dependencies can cause some pain too, if not used with care. If we
    take the same Maven module that we discussed before as an example, and have the
    following Java code inside the `src/main/java` directory, it will compile exquisitely
    with no errors. This only has a single dependency—`nimbus-jose-jwt-2.26.jar`.
    However, the `net.minidev.json.JSONArray` class comes from a transitive dependency,
    which is `json-smart-1.1.1.jar`. The build works fine, because Maven gets all
    the transitive dependencies into the project build path. Everything will work
    finely until, one fine day, you update the version of `nimbus-jose-jwt` and the
    new version has a reference to a new version of the `json-smart` JAR, which is
    not compatible with your code. This could easily break your build, or it may cause
    test cases to fail. This would create hazards, and it would be a nightmare to
    find out the root cause.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不谨慎使用，传递依赖项也可能带来一些麻烦。如果我们以之前讨论过的同一个Maven模块为例，并在`src/main/java`目录内有以下Java代码，它将编译得很好，没有任何错误。这只有一个依赖项——`nimbus-jose-jwt-2.26.jar`。然而，`net.minidev.json.JSONArray`类来自传递依赖项，即`json-smart-1.1.1.jar`。构建工作正常，因为Maven将所有传递依赖项放入项目构建路径中。一切都会运行得很好，直到有一天，你更新了`nimbus-jose-jwt`的版本，而新版本引用了一个与你的代码不兼容的新版本的`json-smart`
    JAR。这可能会轻易破坏你的构建，或者可能导致测试用例失败。这会带来风险，找到根本原因将是一场噩梦。
- en: 'The following Java code uses the `JSONArray` class from `json-smart-1.1.1.jar`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Java代码使用了来自`json-smart-1.1.1.jar`的`JSONArray`类：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To avoid such a nightmare, you need to follow a simple rule of thumb. If you
    have any `import` statement in a Java class, you need to make sure that the dependency
    JAR file corresponding to this is being added to the project POM file.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这样的噩梦，你需要遵循一个简单的经验法则。如果你在Java类中有任何`import`语句，你需要确保对应的依赖项JAR文件被添加到项目的POM文件中。
- en: 'The Maven dependency plugin helps you to find such inconsistencies in your
    Maven module. Run the following command and observe its output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Maven依赖项插件可以帮助你找到你的Maven模块中的此类不一致性。运行以下命令并观察其输出：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note the two warnings in the previous output. It clearly says that we have an
    undeclared dependency for `json-smart jar`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前一个输出中的两个警告。它清楚地说明我们有一个未声明的依赖项`json-smart jar`。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Maven dependency plugin has several goals to find out inconsistencies and
    possible loopholes in how you manage dependencies. For more details on this, refer
    to [http://maven.apache.org/plugins/maven-dependency-plugin/](http://maven.apache.org/plugins/maven-dependency-plugin/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Maven依赖项插件有几个目标来查找你在管理依赖项时的不一致性和可能的漏洞。有关更多详细信息，请参阅[http://maven.apache.org/plugins/maven-dependency-plugin/](http://maven.apache.org/plugins/maven-dependency-plugin/)。
- en: Dependency scopes
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖项范围
- en: Maven defines the following six scope types. If there is no `scope` element
    defined for a given dependency, the default scope—`compile` - will be applied.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Maven定义了以下六个范围类型。如果给定依赖项没有定义`scope`元素，则将应用默认范围——`compile`。
- en: '`compile`: This is the default scope. Any dependency defined under the `compile`
    scope will be available in all the class paths. It will be packaged into the final
    artifact produced by the Maven project. If you are building a WAR type artifact,
    then the referred JAR files with the `compile` scope will be embedded into the
    WAR file itself.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compile`：这是默认范围。在`compile`范围内定义的任何依赖项都将可在所有类路径中找到。它将被打包到Maven项目产生的最终工件中。如果你正在构建WAR类型工件，那么带有`compile`范围的引用JAR文件将嵌入到WAR文件本身中。'
- en: '`provided`: This scope would expect that, the corresponding dependency would
    be provided either by the JDK or a container that runs the application. The best
    example is the servlet API. Any dependency with the `provided` scope will be available
    in the build time class path, but it won''t be packaged into the final artifact.
    If it''s a WAR file, the servlet API will be available in the class path during
    build time, but won''t get packaged into the WAR file. See the following example
    of the `provided` scope:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`provided`：这个范围期望相应的依赖项要么由JDK提供，要么由运行应用程序的容器提供。最好的例子是servlet API。任何带有`provided`范围的依赖项都将可在构建时类路径中找到，但它不会被打包到最终工件中。如果是一个WAR文件，servlet
    API将在构建时类路径中可用，但不会打包到WAR文件中。请参见以下`provided`范围的示例：'
- en: '[PRE32]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`runtime`: Dependencies defined under the `runtime` scope will be available
    only during the runtime, not in the build time class path. These dependencies
    will be packaged into the final artifact. You may have a web-based app that talks
    to a MySQL database in runtime. Your code does not have any hard dependency to
    the MySQL database driver. The code is written against the Java JDBC API, and
    it does not need the MySQL database driver at build time. However, during runtime,
    it needs the driver to talk to the MySQL database. For this, the driver should
    be packaged into the final artifact.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runtime`：在`runtime`作用域下定义的依赖项仅在运行时可用，而不是在构建时类路径中。这些依赖项将被打包到最终工件中。你可能有一个在运行时与MySQL数据库通信的基于Web的应用程序。你的代码对MySQL数据库驱动没有硬依赖。代码是针对Java
    JDBC API编写的，并且在构建时不需要MySQL数据库驱动。然而，在运行时，它需要驱动程序与MySQL数据库通信。为此，驱动程序应该打包到最终工件中。'
- en: '`test`: Dependencies are only needed for test compilation (for example, JUnit
    and TestNG), and execution must be defined under the `test` scope. These dependencies
    won''t get packaged into the final artifact.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`：依赖项仅用于测试编译（例如JUnit和TestNG），并且必须在`test`作用域下定义。这些依赖项不会打包到最终工件中。'
- en: '`system`: This is very much similar to the scope `provided`. The only difference
    is that with the `system` scope, you need to tell Maven how to find it. System
    dependencies are useful when you do not have the referred dependency in a Maven
    repository. With this you need to make sure that all the system dependencies are
    available to download with the source code itself. It is always recommended to
    avoid using system dependencies. The following code snippet shows how to define
    a system dependency:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system`：这与`provided`作用域非常相似。唯一的区别是，在使用`system`作用域时，你需要告诉Maven如何找到它。当你在Maven仓库中没有找到所引用的依赖时，系统依赖很有用。使用这种方式，你需要确保所有系统依赖都能与源代码本身一起下载。总是建议避免使用系统依赖。以下代码片段显示了如何定义一个系统依赖：'
- en: '[PRE33]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`basedir` is an inbuilt property defined in Maven to represent the directory,
    which has the corresponding POM file.'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`basedir`是Maven中定义的一个内置属性，用于表示具有相应POM文件的目录。'
- en: '`import`: This is only applicable for dependencies defined under the `dependencyManagement`
    section with the packaging type `pom`. Let''s take the following POM file; it
    has the packaging type defined as `pom`:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import`：这仅适用于在`dependencyManagement`部分定义的依赖项，其打包类型为`pom`。让我们看一下以下POM文件；它已将打包类型定义为`pom`：'
- en: '[PRE34]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, from a different Maven module, we add a dependency under the `dependencyManagement`
    section to the previous module, with the scope value set to `import` and the value
    of type set to `pom`:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，从不同的Maven模块中，我们在上一个模块的`dependencyManagement`部分添加了一个依赖项，作用域值设置为`import`，类型值设置为`pom`：
- en: '[PRE35]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, if we run `mvn help:effective-pom` against the above POM file, we will
    see that the dependencies from the first are being imported as follows:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果我们对上面的POM文件运行`mvn help:effective-pom`，我们会看到第一个依赖项被导入如下：
- en: '[PRE36]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Optional dependencies
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选依赖
- en: 'Let''s say that we have a Java project that has to work with two different
    OSGi runtimes. We have written almost all the code to the OSGi API, but there
    are certain parts in the code that consumes the OSGi runtime-specific APIs. When
    the application is running, only the code path related to the underneath OSGi
    runtime will get executed, not both. This raises the need to have both the OSGi
    runtime JARs at the build time. However, in runtime, we do not need both code
    execution paths, only the one related to the corresponding OSGi runtime. We can
    meet these requirements by optional dependencies, shown as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个必须与两个不同的OSGi运行时一起工作的Java项目。我们几乎将所有代码都写到了OSGi API中，但代码中有某些部分消耗了OSGi运行时特定的API。当应用程序运行时，只有与底层OSGi运行时相关的代码路径会被执行，而不是两者都会执行。这产生了在构建时需要两个OSGi运行时JAR的需求。然而，在运行时，我们不需要两个代码执行路径，只需要与相应的OSGi运行时相关的那个。我们可以通过以下所示的可选依赖来满足这些要求：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For any client project that needs `com.packt.osgi.client` to work in an Equinox
    OSGi runtime, it must explicitly add a dependency to the Equinox JAR file, as
    shown in the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何需要`com.packt.osgi.client`在Equinox OSGi运行时中工作的客户端项目，它必须显式地添加对Equinox JAR文件的依赖，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Dependency exclusion
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖排除
- en: 'Dependency exclusion helps to avoid getting a selected set of transitive dependencies.
    Say, for example, that we have the following POM file with two dependencies: one
    for `nimbus-jose-jwt` and the other for the `json-smart` artifact:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you try to run `mvn eclipse:eclipse` against the previous POM file, you
    will see the following `.classpath` file having a dependency on the `json-smart`
    file version 1.0.9, as rightly expected:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s say that we have another project that refers the same `nimbus-jose-jwt`
    artifact, and a newer version of the `json-smart` JAR file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you try to run `mvn eclipse:eclipse` against the previous POM file, you
    will see the following `.classpath` file having a dependency on the `json-smart`
    artifact version 1.1.1:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Still, we do not see a problem. Now, say that we build a WAR file having dependencies
    to both the previous Maven modules:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once the WAR file is created inside `WEB-INF/lib`, we can only see version
    1.1.1 of the `json-smart` JAR file. This comes as a transitive dependency of the
    `com.packt.jose.ext` project. There can be a case where the WAR file does not
    need version 1.1.1 in its runtime, but version 1.0.9\. To achieve this, we need
    to exclude the version 1.1.1 of the `json-smart` JAR file from the `com.packt.jose.ext`
    project, as shown in the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, if you look inside `WEB-INF/lib`, you will only see version 1.0.9 of the
    `json-smart` JAR file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused our discussion around Maven POM, and how to adhere
    to industry-wide accepted best practices to avoid maintenance nightmares. The
    key elements of a POM file, POM hierarchy and inheritance, managing dependencies,
    and related topics were covered here.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will have a look at Maven archetypes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
