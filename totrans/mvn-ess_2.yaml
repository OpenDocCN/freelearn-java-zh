- en: Chapter 2. Understanding the Project Object Model (POM)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: POM is at the heart of any Maven project. This chapter focuses on the core concepts
    and best practices related to POM in building a large-scale, multi-module Maven
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we proceed with this chapter, the following topics will be covered in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The POM hierarchy, super POM, and parent POM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending and overriding POM files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven coordinates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transitive dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency scopes and optional dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Object Model (POM)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any Maven project must have a `pom.xml` file. POM is the Maven project descriptor
    just like the `web.xml` file in your Java EE web application, or the `build.xml`
    file in your Ant project. The following code lists out all the key elements in
    a Maven `pom.xml` file. As we proceed with the book, we will discuss how to use
    each element in the most effective manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows a sample `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: POM hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'POM files maintain a parent-child relationship between them. A child POM file
    inherits all the configuration elements from its parent POM. Using this trick,
    Maven sticks to its design philosophy *convention over configuration*. The minimal
    POM configuration for any Maven project is extremely simple, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Super POM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any POM file can point to its parent POM. In case the parent POM element is
    missing, there is a system wide POM file that is automatically treated as the
    parent POM. This POM file is well known as the **super POM**. Ultimately, all
    the application POM files get extended from the super POM. The super POM file
    is at the top of the POM hierarchy and is bundled inside `MAVEN_HOME/lib/maven-model-builder-3.3.3.jar
    - org/apache/maven/model/pom-4.0.0.xml`. In Maven 2, this was bundled inside `maven-2.X.X-uber.jar`.
    All the default configurations are defined in the super POM file. Even the simplest
    form of a POM file will inherit all the configurations defined in the super POM
    file. Whatever configuration you need to override, you can do it by redefining
    the same section in your application POM file. The following lines of code show
    the super POM file configuration, which comes with Maven 3.3.3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The Maven central is the only repository defined under the *repositories* section.
    It will be inherited by all the Maven application modules. Maven uses these repositories
    defined under the *repositories* section to download all the dependent artifacts
    during a Maven build. The following code snippet shows the configuration block
    in `pom.xml`, which is used to define repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two types of repositories in Maven: local and remote. The local repository
    is maintained in your local machine—by default at `USER_HOME/.m2/repository`.
    Anything that you build locally with `mvn install` will get deployed into the
    local repository. When you start with a fresh Maven repository, it will be empty.
    You need to download everything—from the simplest `maven-compiler-plugin` to all
    your project dependencies. A Maven build can either be an online or offline build.
    By default, it is an online build, unless you add `-o` into your Maven build command.
    If it''s an offline build, Maven assumes that all the related artifacts are readily
    available in the local Maven repository; if not, it will complain. If it is an
    online build, Maven will download the artifacts from remote repositories and store
    them in the local repository. The Maven local repository location can be changed
    to a preferred location by editing `MAVEN_HOME/conf/settings.xml` to update the
    value of the `localRepository` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Plugin repositories define where to find Maven plugins. We''ll be talking about
    Maven plugins in [Chapter 4](ch04.html "Chapter 4. Maven Plugins"), *Maven Plugins*.
    The following code snippet shows the configuration related to the plugin repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `build` configuration section includes all the information required to
    build a project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `reporting` section includes the details of report plugins, which are used
    to generate reports and are later displayed on the site generated by Maven. The
    super POM only provides a default value for the output directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet defines the default build profile. When no profiles
    are defined at the application level, the default build profile will get executed.
    We will be talking about profiles in [Chapter 7](ch07.html "Chapter 7. Best Practices"),
    *Best Practices*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows an abstract view of the super POM file with key
    configuration elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Super POM](img/B02157_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: POM extending and overriding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how POM overriding works. In the following example, we extend the
    `repositories` section to add one more repository than what is defined in the
    Maven super POM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following command from the directory where the above POM file is
    located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the effective POM for the application, which combines all
    the default settings from the super POM file and the configuration defined in
    your application POM. In the following code snippet, you can see that the `<repositories>`
    section in the super POM file is being extended by your application-specific configuration.
    Now, the `<repositories>` section has the central repository defined in the super
    POM as well as your application-specific repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you want to override any of the configuration elements corresponding to the
    Maven central repository inherited from the super POM file, then you have to define
    a repository in your application POM with the same repository `id` (as of the
    Maven central repository), and override the configuration element that you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'One main advantage of the POM hierarchy in Maven is that you can extend as
    well as override the configuration inherited from the top. Say, for example, that
    you may need to keep all the plugins defined in the super POM, but just want to
    override the `version` of `maven-release-plugin`. The following configuration
    shows how to do it. By default, in the super POM, the `maven-release-plugin` version
    is 2.3.2, and here, we update it to 2.5 in our application POM. If you run `mvn
    help:effective-pom` again against the updated POM file, you will notice that the
    plugin `version` is updated, whereas the rest of the plugin configuration from
    the super POM remains unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To override the configuration of a given element or an artifact in the POM hierarchy,
    Maven should be able to uniquely identify the corresponding artifact. In the preceding
    scenario, the plugin was identified by its `artifactId`. In [Chapter 4](ch04.html
    "Chapter 4. Maven Plugins"), *Maven Plugins* we will further discuss how Maven
    locates plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Maven coordinates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maven coordinates uniquely identify a project, dependency, or plugin defined
    in a POM. Each entity is uniquely identified by the combination of a group identifier,
    artifact identifier, and the version (and, of course, with the packaging and the
    classifier). The group identifier is a way of grouping different Maven artifacts.
    For example, a set of artifacts produced by a company can be grouped under the
    same group identifier. The artifact identifier is the way you identify an artifact,
    which could be a JAR, WAR, or any type of an artifact uniquely identified within
    a given group. The `version` element lets you keep the same artifact in different
    versions in the same repository.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A valid Maven POM file must have `groupId`, `artifactId`, and `version`. The
    `groupId` and `version` elements can also be inherited from the parent POM.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the three coordinates of a given Maven artifact are used to define its
    path in the Maven repository. If we take the following example, the corresponding
    JAR file is installed into the local repository with the path `M2_REPO/repository/com/packt/sample-one/1.0.0/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you have gone through the elements of the super POM file carefully, you might
    have noticed that it does not have any of the previously mentioned elements—no
    `groupId`, `artifactId`, or `version`. Does this mean that the super POM file
    is not a valid POM? The super POM file is similar to an abstract class in Java.
    It does not work by itself; it must be inherited by a child POM. Another way to
    look at the super POM file is that it's the Maven's way of sharing default configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, if you look at the `<pluginManagement>` section of the super POM,
    as shown in the following code snippet, you will notice that a given plugin artifact
    is only identified by its `artifactId` and `version` elements. This contradicts
    what was mentioned before: a given artifact is uniquely identified by the combination
    of `groupId`, `artifactId`, and `version`. How is this possible?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an exception for plugins. You need not specify `groupId` for a plugin
    in the POM file—it is optional. By default, Maven uses `org.apache.maven.plugins`
    or `org.codehaus.mojo` as `groupId`. Have a look at the following section in `MAVEN_HOME/conf/settings.xml`.
    Everything that you define in this file will be globally applicable for all the
    Maven builds, which run in the corresponding machine. In case you want to keep
    the configuration at user level (in a multi-user environment), you can simply
    copy the `settings.xml` file from `MAVEN_HOME/conf` to `USER_HOME/.m2`. If you
    want to add the additional `groupId` elements for plugin lookup, you will have
    to uncomment the following section and add them there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will be discussing Maven plugins in detail in [Chapter 4](ch04.html "Chapter 4. Maven
    Plugins"), *Maven Plugins*.
  prefs: []
  type: TYPE_NORMAL
- en: The parent POM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we deal with hundreds of Maven modules, we need to structure the project
    to avoid any redundancies or duplicate configurations. If not, it will lead to
    a huge maintenance nightmare. Let's have a look at some popular open source projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The WSO2 Carbon Turing project, available at [https://svn.wso2.org/repos/wso2/carbon/platform/branches/turing/](https://svn.wso2.org/repos/wso2/carbon/platform/branches/turing/),
    has more than 1000 Maven modules. Anyone who downloads the source code from the
    root should be able to build it with all the components. The `pom.xml` file at
    the root acts as a module aggregating POM. It defines all the Maven modules that
    need to be built under the `<modules>` element. Each module element defines the
    relative path (from the root POM) to the corresponding Maven module. There needs
    to be another POM file under the defined relative path. The root POM in the WSO2
    Carbon Turing project only acts as an aggregator module. It does not build any
    parent-child relationship with other Maven modules. The following code snippet
    shows the module configuration in the root `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s have a look at the POM file inside the `parent` module. This POM
    file defines plugin repositories, a distribution repository, plugins, and a set
    of properties. This does not have any dependencies, and this is the POM file that
    acts as the parent for all the other Maven submodules. The parent POM file has
    the following coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the POM file inside the `components` module, it refers to `parent/pom.xml`
    as the parent Maven module. The value of the `relativePath` element, by default,
    refers to the `pom.xml` file a level above, that is, `../pom.xml`. However, in
    this case, it is not the parent POM; hence, the value of the element must be overridden
    and set to `../parent/pom.xml`, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you go inside the `components` module and run `mvn help:effective-pom`,
    you will notice that an effective POM aggregates both the configurations defined
    in `parent/pom.xml` and `components/pom.xml`. Parent POM files help to propagate
    common configuration elements to downstream Maven modules, and it can go up to
    many levels. The `components/pom.xml` file acts as the parent POM for Maven modules
    below its level. For example, let''s have a look at the following `components/identity/pom.xml`
    file. It has a reference to the `components/pom.xml` file as its parent. Note
    that here we do not need to use the `relativePath` element, since the corresponding
    parent POM is at the default location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A complete list of elements in a POM file is explained in detail at [http://maven.apache.org/ref/3.3.3/maven-model/maven.html](http://maven.apache.org/ref/3.3.3/maven-model/maven.html).
  prefs: []
  type: TYPE_NORMAL
- en: Managing POM dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a large-scale development project with hundreds of Maven modules, managing
    dependencies could be a hazardous task. There are two effective ways to manage
    dependencies: POM inheritance and dependency grouping. With POM inheritance, the
    parent POM has to define all the common dependencies used by its child modules
    under the `dependencyManagement` section. In this way, we can avoid all the duplicate
    dependencies. Also, if we have to update the version of a given dependency, then
    we only have to make changes in one place. Let''s take the same example we discussed
    before using the WSO2 Carbon Turing project. Let''s have a look at the `dependencyManagement`
    section of `parent/pom.xml` (only a part of the POM file is shown here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To know more about dependency management, refer to *Introduction to the Dependency
    Mechanism*, available at [http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html](http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the `dependency` section of `identity/org.wso2.carbon.identity.core/4.2.3/pom.xml`,
    which extends from `components/pom.xml`. Here, you will only see `groupId` and
    `artifactId` of a given dependency, and not `version`. The version of each dependency
    is managed through the `dependencyManagement` section of the parent POM. In case
    any child Maven module wants to override the version of an inherited dependency,
    it can simply add the `version` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Another best practice to highlight here is the way dependency versions are
    specified in the parent POM file, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of specifying the version number inside the `dependency` element itself,
    here, we have taken it out and represented the version as a property. The value
    of the property is defined under the `properties` section of the parent POM, as
    shown in the following line of code. This makes POM maintenance extremely easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The second approach to manage dependencies is through dependency grouping. All
    the common dependencies can be grouped into a single POM file. This approach is
    much better than POM inheritance. Here, you do not need to add references to individual
    dependencies. Let's go through a simple example. First, we need to logically group
    all the dependencies into a single POM file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apache Axis2 is an open source SOAP engine. To build an Axis2 client, you need
    to have all the following dependencies added to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have multiple Axis2 client modules, in each module, you need to duplicate
    all these dependencies. The complete source code of the Apache Axis2 project is
    available at [http://svn.apache.org/viewvc/axis/axis2/java/core/trunk/modules/](http://svn.apache.org/viewvc/axis/axis2/java/core/trunk/modules/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid dependency duplication, we can create a Maven module with all the
    previously mentioned five dependencies, as shown in the following project. Make
    sure to set the value of the `packaging` element to `pom`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in all of your Axis2 client projects, you only need to add a dependency
    to the `com.packt.axis2-client` module, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Make sure to set the value of the `type` element to `pom` under the `dependency`
    element, as we are referring to a dependency of `pom` packaging here. In case
    it is skipped, Maven, by default, will look for an artifact with the `jar` packaging:'
  prefs: []
  type: TYPE_NORMAL
- en: Transitive dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The transitive dependency feature was introduced in Maven 2.0, which automatically
    identifies the dependencies of your project dependencies and gets all of them
    into the build path of your project. Let''s take the following POM as an example.
    It only has a single dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to create an Eclipse project from the previous POM file using the
    `mvn eclipse:eclipse` command, it will result in the following `.classpath` file.
    There you can see, in addition to the `nimbus-jose-jwt-2.26.jar` file, three more
    JARs have been added. These are the transitive dependencies of the `nimbus-jose-jwt`
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the POM file of the `nimbus-jose-jwt` project, you will see that
    the previously mentioned transitive dependencies are defined there as dependencies.
    Maven does not define a limit for transitive dependencies. One transitive dependency
    may have a reference to another transitive dependency, and it can go on like that
    endlessly, given that there are no cyclic dependencies found.
  prefs: []
  type: TYPE_NORMAL
- en: Transitive dependencies can cause some pain too, if not used with care. If we
    take the same Maven module that we discussed before as an example, and have the
    following Java code inside the `src/main/java` directory, it will compile exquisitely
    with no errors. This only has a single dependency—`nimbus-jose-jwt-2.26.jar`.
    However, the `net.minidev.json.JSONArray` class comes from a transitive dependency,
    which is `json-smart-1.1.1.jar`. The build works fine, because Maven gets all
    the transitive dependencies into the project build path. Everything will work
    finely until, one fine day, you update the version of `nimbus-jose-jwt` and the
    new version has a reference to a new version of the `json-smart` JAR, which is
    not compatible with your code. This could easily break your build, or it may cause
    test cases to fail. This would create hazards, and it would be a nightmare to
    find out the root cause.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Java code uses the `JSONArray` class from `json-smart-1.1.1.jar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: To avoid such a nightmare, you need to follow a simple rule of thumb. If you
    have any `import` statement in a Java class, you need to make sure that the dependency
    JAR file corresponding to this is being added to the project POM file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Maven dependency plugin helps you to find such inconsistencies in your
    Maven module. Run the following command and observe its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note the two warnings in the previous output. It clearly says that we have an
    undeclared dependency for `json-smart jar`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Maven dependency plugin has several goals to find out inconsistencies and
    possible loopholes in how you manage dependencies. For more details on this, refer
    to [http://maven.apache.org/plugins/maven-dependency-plugin/](http://maven.apache.org/plugins/maven-dependency-plugin/).
  prefs: []
  type: TYPE_NORMAL
- en: Dependency scopes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maven defines the following six scope types. If there is no `scope` element
    defined for a given dependency, the default scope—`compile` - will be applied.
  prefs: []
  type: TYPE_NORMAL
- en: '`compile`: This is the default scope. Any dependency defined under the `compile`
    scope will be available in all the class paths. It will be packaged into the final
    artifact produced by the Maven project. If you are building a WAR type artifact,
    then the referred JAR files with the `compile` scope will be embedded into the
    WAR file itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`provided`: This scope would expect that, the corresponding dependency would
    be provided either by the JDK or a container that runs the application. The best
    example is the servlet API. Any dependency with the `provided` scope will be available
    in the build time class path, but it won''t be packaged into the final artifact.
    If it''s a WAR file, the servlet API will be available in the class path during
    build time, but won''t get packaged into the WAR file. See the following example
    of the `provided` scope:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`runtime`: Dependencies defined under the `runtime` scope will be available
    only during the runtime, not in the build time class path. These dependencies
    will be packaged into the final artifact. You may have a web-based app that talks
    to a MySQL database in runtime. Your code does not have any hard dependency to
    the MySQL database driver. The code is written against the Java JDBC API, and
    it does not need the MySQL database driver at build time. However, during runtime,
    it needs the driver to talk to the MySQL database. For this, the driver should
    be packaged into the final artifact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`: Dependencies are only needed for test compilation (for example, JUnit
    and TestNG), and execution must be defined under the `test` scope. These dependencies
    won''t get packaged into the final artifact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`system`: This is very much similar to the scope `provided`. The only difference
    is that with the `system` scope, you need to tell Maven how to find it. System
    dependencies are useful when you do not have the referred dependency in a Maven
    repository. With this you need to make sure that all the system dependencies are
    available to download with the source code itself. It is always recommended to
    avoid using system dependencies. The following code snippet shows how to define
    a system dependency:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '`basedir` is an inbuilt property defined in Maven to represent the directory,
    which has the corresponding POM file.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`import`: This is only applicable for dependencies defined under the `dependencyManagement`
    section with the packaging type `pom`. Let''s take the following POM file; it
    has the packaging type defined as `pom`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, from a different Maven module, we add a dependency under the `dependencyManagement`
    section to the previous module, with the scope value set to `import` and the value
    of type set to `pom`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if we run `mvn help:effective-pom` against the above POM file, we will
    see that the dependencies from the first are being imported as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Optional dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say that we have a Java project that has to work with two different
    OSGi runtimes. We have written almost all the code to the OSGi API, but there
    are certain parts in the code that consumes the OSGi runtime-specific APIs. When
    the application is running, only the code path related to the underneath OSGi
    runtime will get executed, not both. This raises the need to have both the OSGi
    runtime JARs at the build time. However, in runtime, we do not need both code
    execution paths, only the one related to the corresponding OSGi runtime. We can
    meet these requirements by optional dependencies, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'For any client project that needs `com.packt.osgi.client` to work in an Equinox
    OSGi runtime, it must explicitly add a dependency to the Equinox JAR file, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Dependency exclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Dependency exclusion helps to avoid getting a selected set of transitive dependencies.
    Say, for example, that we have the following POM file with two dependencies: one
    for `nimbus-jose-jwt` and the other for the `json-smart` artifact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to run `mvn eclipse:eclipse` against the previous POM file, you
    will see the following `.classpath` file having a dependency on the `json-smart`
    file version 1.0.9, as rightly expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say that we have another project that refers the same `nimbus-jose-jwt`
    artifact, and a newer version of the `json-smart` JAR file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to run `mvn eclipse:eclipse` against the previous POM file, you
    will see the following `.classpath` file having a dependency on the `json-smart`
    artifact version 1.1.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Still, we do not see a problem. Now, say that we build a WAR file having dependencies
    to both the previous Maven modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the WAR file is created inside `WEB-INF/lib`, we can only see version
    1.1.1 of the `json-smart` JAR file. This comes as a transitive dependency of the
    `com.packt.jose.ext` project. There can be a case where the WAR file does not
    need version 1.1.1 in its runtime, but version 1.0.9\. To achieve this, we need
    to exclude the version 1.1.1 of the `json-smart` JAR file from the `com.packt.jose.ext`
    project, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you look inside `WEB-INF/lib`, you will only see version 1.0.9 of the
    `json-smart` JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused our discussion around Maven POM, and how to adhere
    to industry-wide accepted best practices to avoid maintenance nightmares. The
    key elements of a POM file, POM hierarchy and inheritance, managing dependencies,
    and related topics were covered here.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will have a look at Maven archetypes.
  prefs: []
  type: TYPE_NORMAL
