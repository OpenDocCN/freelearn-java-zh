<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Understanding WebDriver Events</h1>
                </header>
            
            <article>
                
<p class="mce-root">Selenium WebDriver provides an API for tracking the various events that happen when test scripts are executed using WebDriver. Many navigation events get fired before and after a WebDriver internal event occurs (such as before and after navigating to a URL, and before and after browser back-navigation) and these can be tracked and captured. To throw an event, WebDriver gives you a class named <kbd>EventFiringWebDriver</kbd>, and to catch that event, it provides the test-script developer with an interface named <kbd>WebDriverEventListener</kbd>. The test-script developer should provide its own implementations for the overridden methods from the interface. In this chapter, we will look at the following topics:</p>
<ul>
<li class="mce-root"><span>How to listen to and handle </span>various browser-navigation events by using EventFiringWebDriver</li>
<li class="mce-root">How to listen to and handle web-element action events that get triggered during the execution of test scripts</li>
<li>Adding additional features to WebDriver to capture performance or accessibility testing</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing the eventFiringWebDriver and eventListener classes </h1>
                </header>
            
            <article>
                
<p>The <kbd>EventFiringWebDriver</kbd> class is a wrapper around the WebDriver that gives the driver the capability to fire events. The <kbd>EventListener</kbd> class, on the other hand, waits to listen to <kbd>EventFiringWebDriver</kbd> and handles all of the events that are dispatched. There can be more than one listener waiting to hear from the <kbd>EventFiringWebDriver</kbd> class for an event to fire. All of the event listeners should be registered with the <kbd>EventFiringWebDriver</kbd> class to get notified.</p>
<p>The following flow diagram explains what has to be done to capture all of the events raised by <kbd>EventFiringWebDriver</kbd> during the execution of test cases:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5da5045c-da26-4484-b978-97540a96bb62.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an instance of EventListener </h1>
                </header>
            
            <article>
                
<p>The <kbd>EventListener</kbd> class handles all of the events that are dispatched by the <kbd>EventFiringWebDriver</kbd> class. There are two ways to create an <kbd>EventListener</kbd> class:</p>
<ul>
<li>By implementing the <kbd>WebDriverEventListener</kbd> interface.</li>
<li>By extending the <kbd>AbstractWebDriverEventListener</kbd> class provided in the WebDriver library.</li>
</ul>
<p>It is up to you, as a test-script developer, to choose which way to go.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing WebDriverEventListener </h1>
                </header>
            
            <article>
                
<p>The <kbd>WebDriverEventListener</kbd> interface has all the event methods declared. The <kbd>EventFiringWebDriver</kbd> class, as soon as it realizes an event has occurred, invokes the registered method of <kbd>WebDriverEventListener</kbd>. Here, we have created an <kbd>IAmTheEventListener</kbd> named class and have implemented <kbd>WebDriverEventListener</kbd>. Now we need to provide implementation for all the methods declared in it. Currently, in <kbd>WebDriverEventListener</kbd>, there are 15 methods. We will discuss each one of them shortly. Make sure the IDE provides us with the dummy implementation of these methods. The class that we have created with all 15 overridden methods is as follows (we have provided implementations for a couple of methods as an example):</p>
<pre><span>public class </span>IAmTheEventListener <span>implements </span>WebDriverEventListener {<br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>beforeAlertAccept</span>(WebDriver webDriver) {<br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>afterAlertAccept</span>(WebDriver webDriver) {<br/><br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>afterAlertDismiss</span>(WebDriver webDriver) {<br/><br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>beforeAlertDismiss</span>(WebDriver webDriver) {<br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>beforeNavigateTo</span>(String url<span>, </span>WebDriver webDriver) {<br/>        System.<span>out</span>.println(<span>"Before Navigate To " </span>+ url)<span>;<br/></span><span>    </span>}<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>afterNavigateTo</span>(String s<span>, </span>WebDriver webDriver) {<br/>        System.<span>out</span>.println(<span>"Before Navigate Back. Right now I'm at "<br/></span><span>                </span>+ webDriver.getCurrentUrl())<span>;<br/></span><span>    </span>}<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>beforeNavigateBack</span>(WebDriver webDriver) {<br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>afterNavigateBack</span>(WebDriver webDriver) {<br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>beforeNavigateForward</span>(WebDriver webDriver) {<br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>afterNavigateForward</span>(WebDriver webDriver) {<br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>beforeNavigateRefresh</span>(WebDriver webDriver)     {<br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>afterNavigateRefresh</span>(WebDriver webDriver) {<br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>beforeFindBy</span>(By by<span>, </span>WebElement webElement<span>, </span>WebDriver webDriver) {<br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>afterFindBy</span>(By by<span>, </span>WebElement webElement<span>, </span>WebDriver webDriver) {<br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>beforeClickOn</span>(WebElement webElement<span>, </span>WebDriver webDriver) {<br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>afterClickOn</span>(WebElement webElement<span>, </span>WebDriver webDriver) {<br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>beforeChangeValueOf</span>(WebElement webElement<span>, </span>WebDriver webDriver<span>, </span>CharSequence[] charSequences) {<br/><br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>afterChangeValueOf</span>(WebElement webElement<span>, </span>WebDriver webDriver<span>, </span>CharSequence[] charSequences) {<br/><br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>beforeScript</span>(String s<span>, </span>WebDriver webDriver)     {<br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>afterScript</span>(String s<span>, </span>WebDriver webDriver)     {<br/>    }<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>onException</span>(Throwable throwable<span>, </span>WebDriver webDriver) {<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extending AbstractWebDriverEventListener</h1>
                </header>
            
            <article>
                
<p class="mce-root">The second way to create a listener class is by extending the <kbd>AbstractWebDriverEventListene r</kbd><span> class.</span> <kbd>AbstractWebDriverEventListener</kbd> <span>is an abstract class that implements</span> <kbd>WebDriverEventListener</kbd><span>. Though it doesn't really provide any implementation for the methods in the</span> <kbd>WebDriverEventListener</kbd> <span>interface, it creates a dummy implementation such that the listener class that you are creating doesn't have to contain all the methods, only the ones that you, as a test-script developer, are interested in. The following is a class we have created that extends</span> <kbd>AbstractWebDriverEventListener</kbd> <span>and provides implementations for a couple of methods in it. This way, we can override only the methods that we are interested in rather than all of the methods in our class:</span></p>
<pre><span>package </span>com.example<span>;<br/></span><span><br/></span><span>import </span>org.openqa.selenium.WebDriver<span>;<br/></span><span>import    </span>org.openqa.selenium.support.events.AbstractWebDriverEventListener<span>;<br/></span><span><br/></span><span>public class </span>IAmTheEventListener2 <span>extends </span>AbstractWebDriverEventListener {<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>beforeNavigateTo</span>(String url<span>, </span>WebDriver driver) {<br/>        System.<span>out</span>.println(<span>"Before Navigate To "</span>+ url)<span>;<br/></span><span>    </span>}<br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>beforeNavigateBack</span>(WebDriver driver) {<br/>        System.<span>out</span>.println(<span>"Before Navigate Back. Right now I'm at "<br/></span><span>                </span>+ driver.getCurrentUrl())<span>;<br/></span><span>    </span>}<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a WebDriver instance </h1>
                </header>
            
            <article>
                
<p>Now that we have created our listener class that listens for all of the events generated, it's time to create our test script class and let it call <kbd>IAmTheDriver.java</kbd>. After the class is created, we declare a ChromeDriver instance in it:</p>
<pre>WebDriver driver = new ChromeDriver();</pre>
<p>The <kbd>ChromeDriver</kbd> instance will be the underlying driver instance that drives all the driver events. This is nothing new. The step explained in the next section is where we make this driver an instance of <kbd>EventFiringWebDriver</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating EventFiringWebDriver and EventListener instances</h1>
                </header>
            
            <article>
                
<p>Now that we have the basic driver instance, pass it as an argument while constructing the <kbd>EventFiringWebDriver</kbd> instance. We will be using this instance of the driver to execute all of the further user actions.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now, using the following code, instantiate the <kbd>EventListener</kbd>, <kbd>IAmTheEventListener.java</kbd>, or <kbd>IAmTheEventListener2.java</kbd> class that we created previously. This will be the class to which all of the events are dispatched:</p>
<pre>EventFiringWebDriver eventFiringDriver = <br/>        <span>new </span>EventFiringWebDriver(<span>driver</span>)<span>;<br/></span>IAmTheEventListener eventListener = <br/>        <span>new </span>IAmTheEventListener()<span>;</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Registering EventListener with EventFiringWebDriver</h1>
                </header>
            
            <article>
                
<p>For the event executions to be notified by <kbd>EventListener</kbd>, we have registered <kbd>EventListener</kbd> to the <kbd>EventFiringWebDriver</kbd> class. Now the <kbd>EventFiringWebDriver</kbd> class will know where to send the notifications. This is done by the following line of code: <kbd>eventFiringDriver.register(eventListener);</kbd></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Executing and verifying the events</h1>
                </header>
            
            <article>
                
<p>Now it's time for our test script to execute events, such as navigation events. Let's first navigate to Google and then Facebook. We will use the browser back-navigation to go back to Google. The full code of the test script is as follows:</p>
<pre><span>public class </span>IAmTheDriver {<br/>    <span>public static void </span><span>main</span>(String... args){<br/><br/>        System.<span>setProperty</span>(<span>"webdriver.chrome.driver"</span><span>,<br/></span><span>                </span><span>"./src/test/resources/drivers/chromedriver"</span>)<span>;<br/></span><span><br/></span><span>        </span>WebDriver driver = <span>new </span>ChromeDriver()<span>;<br/></span><span><br/></span><span>        try </span>{<br/>            EventFiringWebDriver eventFiringDriver = <span>new<br/></span><span>                    </span>EventFiringWebDriver(driver)<span>;<br/></span><span>            </span>IAmTheEventListener eventListener = <span>new </span>IAmTheEventListener()<span>;<br/></span><span>            </span>eventFiringDriver.register(eventListener)<span>;<br/></span><span>            </span>eventFiringDriver.get(<span>"http://www.google.com"</span>)<span>;<br/></span><span>            </span>eventFiringDriver.get(<span>"http://www.facebook.com"</span>)<span>;<br/></span><span>            </span>eventFiringDriver.navigate().back()<span>;<br/></span><span>        </span>} <span>finally </span>{<br/>            driver.close()<span>;<br/></span><span>            </span>driver.quit()<span>;<br/></span><span>        </span>}<br/>    }<br/>}</pre>
<p>In the preceding code, we modify our listener class to record <kbd>navigateTo</kbd> and <kbd>navigateBack</kbd> before and after events inherited from the <kbd>AbstractWebDriverEventListener</kbd> class. The modified methods are as follows:</p>
<pre><span>@Override<br/></span><span>public void </span><span>beforeNavigateTo</span>(String url<span>, </span>WebDriver driver) {<br/>    System.<span>out</span>.println(<span>"Before Navigate To: " </span>+ url<br/>            + <span>" and Current url is: " </span>+ driver.getCurrentUrl())<span>;<br/></span>}<br/><br/><span>@Override<br/></span><span>public void </span><span>afterNavigateTo</span>(String url<span>, </span>WebDriver driver) {<br/>    System.<span>out</span>.println(<span>"After Navigate To: " </span>+ url<br/>            + <span>" and Current url is: " </span>+ driver.getCurrentUrl())<span>;<br/></span>}<br/><br/><span>@Override<br/></span><span>public void </span><span>beforeNavigateBack</span>(WebDriver driver) {<br/>    System.<span>out</span>.println(<span>"Before Navigate Back. Right now I'm at " </span>+ driver.getCurrentUrl())<span>;<br/></span>}<br/><br/><span>@Override<br/></span><span>public void </span><span>afterNavigateBack</span>(WebDriver driver) {<br/>    System.<span>out</span>.println(<span>"After Navigate Back. Right now I'm at " </span>+ driver.getCurrentUrl())<span>;<br/></span>}</pre>
<p><span>Now if you execute your test script, the output will be as follows:</span></p>
<pre>Before Navigate To: http://www.google.com and Current url is: data:,<br/> After Navigate To: http://www.google.com and Current url is: https://www.google.com/?gws_rd=ssl<br/> Before Navigate To: http://www.facebook.com and Current url is: https://www.google.com/?gws_rd=ssl<br/> After Navigate To: http://www.facebook.com and Current url is: https://www.facebook.com/<br/> Before Navigate Back. Right now I'm at https://www.facebook.com/<br/> After Navigate Back. Right now I'm at https://www.google.com/?gws_rd=ssl</pre>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Registering multiple EventListeners</h1>
                </header>
            
            <article>
                
<p>We can register more than one listener with <kbd>EventFiringWebDriver</kbd>. Once the event occurs, all of the registered listeners are notified about it. Let's modify our test script to register both our <kbd>IAmTheListener.java</kbd> and <kbd>IAmTheListener2.java</kbd> files:</p>
<pre><span>public class </span>RegisteringMultipleListeners {<br/>    <span>public static void </span><span>main</span>(String... args){<br/><br/>        System.<span>setProperty</span>(<span>"webdriver.chrome.driver"</span><span>,<br/></span><span>                </span><span>"./src/test/resources/drivers/chromedriver"</span>)<span>;<br/></span><span><br/></span><span>        </span>WebDriver driver = <span>new </span>ChromeDriver()<span>;<br/></span><span><br/></span><span>        try </span>{<br/>            EventFiringWebDriver eventFiringDriver = <span>new<br/></span><span>                    </span>EventFiringWebDriver(driver)<span>;<br/></span><span>            </span>IAmTheEventListener eventListener = <span>new </span>IAmTheEventListener()<span>;<br/></span><span>            </span>IAmTheEventListener2 eventListener2 = <span>new<br/></span><span>                    </span>IAmTheEventListener2()<span>;<br/></span><span>            </span>eventFiringDriver.register(eventListener)<span>;<br/></span><span>            </span>eventFiringDriver.register(eventListener2)<span>;<br/></span><span>            </span>eventFiringDriver.get(<span>"http://www.google.com"</span>)<span>;<br/></span><span>            </span>eventFiringDriver.get(<span>"http://www.facebook.com"</span>)<span>;<br/></span><span>            </span>eventFiringDriver.navigate().back()<span>;<br/></span><span>        </span>} <span>finally </span>{<br/>            driver.close()<span>;<br/></span><span>            </span>driver.quit()<span>;<br/></span><span>        </span>}<br/>    }<br/>}</pre>
<p>Modify the listeners slightly to differentiate the log statements. Now if you execute the preceding code, you will see the following output:</p>
<pre>Before Navigate To: http://www.google.com and Current url is: data:,<br/> Before Navigate To http://www.google.com<br/> After Navigate To: http://www.google.com and Current url is: https://www.google.com/?gws_rd=ssl<br/> Before Navigate To: http://www.facebook.com and Current url is: https://www.google.com/?gws_rd=ssl<br/> Before Navigate To http://www.facebook.com<br/> After Navigate To: http://www.facebook.com and Current url is: https://www.facebook.com/<br/> Before Navigate Back. Right now I'm at https://www.facebook.com/<br/> Before Navigate Back. Right now I'm at https://www.facebook.com/<br/> After Navigate Back. Right now I'm at https://www.google.com/?gws_rd=ssl</pre>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring different WebDriver event listeners</h1>
                </header>
            
            <article>
                
<p>We have seen some of the methods in our <kbd>EventListeners</kbd> that get invoked when their corresponding events are executed, for example, before and after navigation methods are invoked when the <kbd>navigateTo</kbd> event is triggered. Here, we'll see all the methods that <kbd>WebDriverEventListener</kbd> provides us.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listening for WebElement value changes</h1>
                </header>
            
            <article>
                
<p>This event occurs when the value of a WebElement changes when the <kbd>sendKeys()</kbd> or <kbd>clear()</kbd> methods are executed on them. There are two methods associated with this event:</p>
<pre>public void beforeChangeValueOf(WebElement element, WebDriver driver)</pre>
<p>The preceding method is invoked before the WebDriver attempts to change the value of the WebElement. As a parameter, the WebElement itself is passed to the method so that you can log the value of the element before the change:</p>
<pre>public void afterChangeValueOf(WebElement element, WebDriver driver)</pre>
<p>The preceding method is the second method associated with the value-change event that is invoked after the driver changes the value of the WebElement. Again, the WebElement and the WebDriver are sent as parameters to the method. If an exception occurs when changing the value, this method is not invoked.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listening for the clicked WebElement</h1>
                </header>
            
            <article>
                
<p>This event occurs when a WebElement is clicked, that is, by executing <kbd>webElement.click()</kbd>. There are two methods to listen for this event in the <kbd>WebDriverEventListener</kbd> implementation:</p>
<pre>public void beforeClickOn(WebElement element, WebDriver driver)</pre>
<p class="mce-root"/>
<p>The preceding method is invoked when the WebDriver is about to click on a particular WebElement. The WebElement that is going to be clicked on and the WebDriver that is clicking on it are sent as parameters to this method so that the test-script developer can interpret which driver performed the click action, and on which element the action was performed:</p>
<pre>public void afterClickOn(WebElement element, WebDriver driver)</pre>
<p>The <kbd>EventFiringWebDriver</kbd> class notifies the preceding method after the click action is taken on a WebElement. Similar to the <kbd>beforeClickOn()</kbd> method, this method is also sent the WebElement and WebDriver instances. If an exception occurs during a click event, this method is not called.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listening for a WebElement search event</h1>
                </header>
            
            <article>
                
<p>This event is triggered when the WebDriver searches for a WebElement on the web page using <kbd>findElement()</kbd> or <kbd>findElements()</kbd>. There are, again, two methods associated with this event:</p>
<pre>public void beforeFindBy(By by, WebElement element, WebDriver driver)</pre>
<p>The preceding method is invoked just before WebDriver begins searching for a particular WebElement on the page. For parameters, it sends the locating mechanism, that is, the WebElement that is searched for, and the WebDriver instance that is performing the search:</p>
<pre>public void afterFindBy(By by, WebElement element, WebDriver driver)</pre>
<p>Similarly, the <kbd>EventFiringWebDriver</kbd> class calls the preceding method after the search for an element is over and the element is found. If there are any exceptions during the search, this method is not called, and an exception is raised.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listening for browser back-navigation</h1>
                </header>
            
            <article>
                
<p>The browser back-navigation event, as we have already seen, gets invoked when we use the <kbd>driver.navigation().back()</kbd> method. The browser goes back one level in its history. Just like all the other events, this event is associated with two methods:</p>
<pre>public void beforeNavigateBack(WebDriver driver)</pre>
<p class="mce-root"/>
<p>The preceding method is invoked before the browser takes you back in its history. The WebDriver that invoked this event is passed as a parameter to this method:</p>
<pre>public void afterNavigateBack(WebDriver driver)</pre>
<p>Just as in all the after <kbd>&lt;&lt;event&gt;&gt;</kbd> methods, the preceding method is invoked when the navigate-back action is triggered. The preceding two methods will be invoked irrespective of the navigation of the browser; that is, if the browser doesn't have any history and you invoke this method, the browser doesn't take you to any of its history. But, even in that scenario, as the event is triggered, those two methods are invoked.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listening for browser forward-navigation</h1>
                </header>
            
            <article>
                
<p>This event is very similar to the browser back-navigation, except that this is browser forward-navigation, so it is using <kbd>driver.navigate().forward()</kbd>. The two methods associated with this event are:</p>
<ul>
<li><kbd>public void afterNavigateForward(WebDriver driver)</kbd></li>
<li><kbd>public void beforeNavigateForward(WebDriver driver)</kbd></li>
</ul>
<p>Just as in browser back-navigation, these methods are invoked irrespective of whether or not the browser takes you one level forward.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listening for browser NavigateTo events</h1>
                </header>
            
            <article>
                
<p>As we've seen earlier, this event occurs whenever the driver executes <kbd>driver. get(url)</kbd>. The related methods for this event are as follows:</p>
<ul>
<li><kbd>public void beforeNavigateTo(java.lang.String url, WebDriver driver)</kbd></li>
<li><kbd>public void afterNavigateTo(java.lang.String url, WebDriver driver)</kbd></li>
</ul>
<p>The URL that is used for the driver-navigation is passed as a parameter to the preceding methods, along with the driver that triggered the event.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listening for script execution</h1>
                </header>
            
            <article>
                
<p>This event is triggered whenever the driver executes a JavaScript. The associated methods for this event are as follows: </p>
<ul>
<li><kbd>public void beforeScript(java.lang.String script, WebDriver driver)</kbd></li>
<li><kbd>public void afterScript(java.lang.String script, WebDriver driver)</kbd></li>
</ul>
<p>The preceding methods get the JavaScript that was executed as a string, and the WebDriver that executed it as a parameter. If an exception occurs during script execution, the <kbd>afterScript()</kbd> method will not be invoked.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listening for an exception</h1>
                </header>
            
            <article>
                
<p>This event occurs when the WebDriver comes across an exception. For instance, if you try to search for a WebElement using <kbd>findElement()</kbd>, and that element doesn't exist on the page, the driver throws an exception (<kbd>NoSuchElementException</kbd>). At this point, this event is triggered, and the following method gets notified:</p>
<pre>public void onException(java.lang.Throwable throwable, WebDriver driver)</pre>
<p>In all the <kbd>after&lt;&lt;event&gt;&gt;</kbd> methods, we have seen that they will not be invoked if the driver comes across any exception. In that case, instead of those <kbd>after&lt;&lt;event&gt;&gt;</kbd> methods, the <kbd>onException()</kbd> method is invoked and the throwable object and the WebDriver object are sent to it as parameters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unregistering EventListener with EventFiringWebDriver</h1>
                </header>
            
            <article>
                
<p>Now, we have seen the different kinds of events that get triggered, and the <kbd>EventFiringWebDriver</kbd> class that notifies all of the listeners registered to it. If, at any point, you want one of your event listeners to stop listening from <kbd>EventFiringWebDriver</kbd>, you can do that by unregistering from that driver. The following API unregisters an event listener from a driver:</p>
<pre>public EventFiringWebDriver unregister(WebDriverEventListener eventListener)</pre>
<p class="mce-root"/>
<p>The parameter of the method should be the event listener that wants to opt out of getting event notifications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Performing accessibility testing</h1>
                </header>
            
            <article>
                
<p>We can perform basic accessibility checks by using tools such as Google's<span> Accessibility Developer Tools (</span><a href="https://github.com/GoogleChrome/accessibility-developer-tools">https://github.com/GoogleChrome/accessibility-developer-tools</a><span>). We can inject the <kbd>Google Accessibility testing library</kbd> in a web page and perform the <kbd>Accessibility Audit</kbd>. This can be done automatically every time <kbd>afterNavigatTo()</kbd> is called. In the following code example, we will inject the <kbd>axe_testing.js</kbd> file provided by the Google Accessibility Developer Tools and perform the audit, which will print a report on the console:</span></p>
<pre><span>public class </span>IAmTheEventListener2 <span>extends </span>AbstractWebDriverEventListener {<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>beforeNavigateTo</span>(String url<span>, </span>WebDriver driver) {<br/>        System.<span>out</span>.println(<span>"Before Navigate To "</span>+ url)<span>;<br/></span><span>    </span>}<br/><br/>    <span>@Override<br/></span><span>    </span><span>public void </span><span>beforeNavigateBack</span>(WebDriver driver) {<br/>        System.<span>out</span>.println(<span>"Before Navigate Back. Right now I'm at "<br/></span><span>                </span>+ driver.getCurrentUrl())<span>;<br/></span><span>    </span>}<br/><br/>    <strong><span>@Override<br/></span><span>    </span><span>public void </span><span>afterNavigateTo</span>(String to<span>, </span>WebDriver driver) {</strong><br/><strong>        <span>try </span>{</strong><br/><strong>            JavascriptExecutor jsExecutor = (JavascriptExecutor) driver<span>;<br/></span><span>            </span>URL url = <span>new </span>URL(<span>"https://raw.githubusercontent.com/GoogleChrome/" </span>+</strong><br/><strong>                    <span>"accessibility-developer-tools/stable/dist/js/axs_testing.js"</span>)<span>;<br/></span><span>            </span>String script = IOUtils.<span>toString</span>(url.openStream()<span>, </span>StandardCharsets.<span>UTF_8</span>)<span>;<br/></span><span>            </span>jsExecutor.executeScript(script)<span>;<br/></span><span>            </span>String report = (String) jsExecutor.executeScript(<span>"var results = axs.Audit.run();" </span>+</strong><br/><strong>                    <span>"return axs.Audit.createReport(results);"</span>)<span>;<br/></span><span>            </span>System.<span>out</span>.println(<span>"### Accessibility Report for " </span>+  driver.getTitle() + <span>"####"</span>)<span>;<br/></span><span>            </span>System.<span>out</span>.println(report)<span>;<br/></span><span>            </span>System.<span>out</span>.println(<span>"### END ####"</span>)<span>;<br/></span><span><br/></span><span>        </span>} <span>catch </span>(MalformedURLException e) {</strong><br/><strong>            e.printStackTrace()<span>;<br/></span><span>        </span>} <span>catch </span>(IOException e) {</strong><br/><strong>            e.printStackTrace()<span>;<br/></span><span>        </span>}</strong><br/><strong>    }</strong><br/>}</pre>
<p>The report is printed in the console, as shown here:</p>
<pre>### Accessibility Report for Google####<br/> *** Begin accessibility audit results ***<br/> An accessibility audit found<br/> Warnings:<br/> Warning: AX_FOCUS_01 (These elements are focusable but either invisible or obscured by another element) failed on the following element:<br/> #hplogo &gt; DIV &gt; .fOwUFe &gt; A<br/> See https://github.com/GoogleChrome/accessibility-developer-tools/wiki/Audit-Rules#-ax_focus_01--these-elements-are-focusable-but-either-invisible-or-obscured-by-another-element for more information.<br/>Warning: AX_TEXT_02 (Images should have an alt attribute) failed on the following element:<br/> #hplogo &gt; DIV &gt; .fOwUFe &gt; A &gt; .fJOQGe<br/> See https://github.com/GoogleChrome/accessibility-developer-tools/wiki/Audit-Rules#-ax_text_02--images-should-have-an-alt-attribute-unless-they-have-an-aria-role-of-presentation for more information.<br/><span>...<br/></span> *** End accessibility audit results ***<br/> ### END ####</pre>
<p>This report contains <span>a collection of audit rules that check for common accessibility problems.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Capturing page-performance metrics</h1>
                </header>
            
            <article>
                
<p>Measuring and optimizing the client-side performance is essential for a seamless user experience, and this is critical for Web 2.0 applications using AJAX.</p>
<p>Capturing vital<span> </span>information, such<span> </span>as the time taken for page load, rendering of the elements, and the JavaScript code execution, will help in identifying the areas where performance is slow and optimizes the overall client-side performance.</p>
<p class="mce-root"/>
<p><span class="strong"><strong>Navigation Timing</strong></span><span> </span>is a W3C-Standard JavaScript API to measure performance on the web. The API provides a simple way to get accurate and detailed timing statistics natively for page navigation and load events. It is available on Internet Explorer 9, Google Chrome, Firefox, and WebKit-based browsers.</p>
<p>The API is accessed via the properties of the timing interface of the<span> <kbd>window.performance</kbd> object using JavaScript. We will capture the page-load time every time we navigate to a page. This can be done by using <kbd>JavaScriptExecutor</kbd> to call <kbd>winodw.performance</kbd> in the <kbd>afterNavigateTo()</kbd> method in <kbd>IAmTheEventListener2.java</kbd>, as shown in the following code snippet:</span></p>
<pre><span>@Override<br/></span><span>public void </span><span>afterNavigateTo</span>(String to<span>, </span>WebDriver driver) {<br/>    <span>try </span>{<br/><br/>        JavascriptExecutor jsExecutor = (JavascriptExecutor) driver<span>;<br/></span><span> </span><span><br/></span><span>        </span><strong><span>// Get the Load Event End<br/></span><span>        </span><span>long </span>loadEventEnd = (Long) jsExecutor.executeScript(<span>"return window.performance.timing.loadEventEnd;"</span>)<span>;<br/></span><span>        </span><span>// Get the Navigation Event Start<br/></span><span>        </span><span>long </span>navigationStart = (Long) jsExecutor.executeScript(<span>"return window.performance.timing.navigationStart;"</span>)<span>;<br/></span><span>        </span><span>// Difference between Load Event End and Navigation Event Start is // Page Load Time<br/></span><span>        </span>System.<span>out</span>.println(<span>"Page Load Time is " </span>+ (loadEventEnd - navigationStart)/<span>1000 </span>+ <span>" seconds."</span>)</strong><span><strong>;</strong><br/></span><span><br/></span><span>    </span>} <span>catch </span>(MalformedURLException e) {<br/>        e.printStackTrace()<span>;<br/></span><span>    </span>} <span>catch </span>(IOException e) {<br/>        e.printStackTrace()<span>;<br/></span><span>    </span>}</pre>
<p><span>As discussed</span><span> in the previous code, the <kbd>window.performance</kbd> </span><span>object provides us with the performance metric that is available within the <kbd>Browser Window object</kbd>. We need to use JavaScript to retrieve this metric. </span><span>Here, we are collecting the <kbd>loadEventEnd</kbd> time and the <kbd>navigationEventStart</kbd> time, and calculating the difference between them, which will give us the page-load time.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you have learned about <kbd>EventFiringWebDriver</kbd> and <kbd>EventListeners</kbd>, and how they work together to make a developer's life easier by helping them to debug what is going on at each step while the test cases get executed. You also learned how to use WebDriver events to perform different types of testing on a page, such as accessibility and client-side performance checks. In the next <a href="a1d063a0-5332-4970-9d11-61aad05ae4f3.xhtml">chapter</a>, you will learn more about RemoteWebDriver for running tests on remote machines in distributed and parallel mode for Cross-Browser Testing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>You can listen to WebDriver events using <span><kbd>WebDriverEventListener</kbd> interface— True or False?</span></li>
<li>How you can automatically clear an input field before calling the <kbd>sendKeys</kbd> method using <kbd>WebDriverEventListener</kbd>?</li>
<li>Selenium supports accessibility testing— True or False?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further information</h1>
                </header>
            
            <article>
                
<p><span>You can check out the following links for more information about the topics covered in this chapter:</span></p>
<ul>
<li>Find out more about the Navigation Timing API at <a href="https://www.w3.org/TR/navigation-timing/">https://www.w3.org/TR/navigation-timing/</a></li>
<li>Find more details on Google's Accessibility Developer Tools at <a href="https://github.com/GoogleChrome/accessibility-developer-tools">https://github.com/GoogleChrome/accessibility-developer-tools</a></li>
</ul>


            </article>

            
        </section>
    </body></html>