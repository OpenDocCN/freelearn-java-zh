<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Going Functional</h1>
                </header>
            
            <article>
                
<p>This chapter introduces a programming paradigm called functional programming and its applicability in Java 9. We will cover the following recipes:</p>
<ul>
<li>Understanding and creating a functional interface</li>
<li>Understanding lambda expressions</li>
<li>Using method references</li>
<li>Creating and invoking lambda-friendly APIs</li>
<li>Leveraging lambda expressions in your programs</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Functional programming--the ability to treat a certain piece of functionality as an object and to pass it as a parameter or the return value of a method--is a feature present in many programming languages. It avoids the changing of an object state and mutable data. The result of a function depends only on the input data, no matter how many times it is called. This style makes the outcome more predictable, which is the most attractive aspect of functional programming.</p>
<p>Its introduction to Java also allows you to improve parallel programming capabilities in Java 8 by shifting the responsibility of parallelism from the client code to the library. Before this, in order to process elements of Java collections, the client code had to acquire an iterator from the collection and organize the processing of the collection.</p>
<p>In Java 8, new (default) methods were added that accept a function (implementation of a functional interface) as a parameter and then apply it to each element of the collection. So, it is the library's responsibility to organize parallel processing. One example is the <kbd>forEach(Consumer)</kbd> method that is available in every <kbd>Iterable</kbd> interface, where <kbd>Consumer</kbd> is a functional interface. Another example is the <kbd>removeIf(Predicate)</kbd> method that is available for every <kbd>Collection</kbd> interface, where <kbd>Predicate</kbd> is a functional interface too. Then we have the <kbd>sort(Comparator)</kbd> and <kbd>replaceAll(UnaryOperator)</kbd> methods that are available for <kbd>List</kbd> and several other methods, such as <kbd>compute()</kbd> for <kbd>Map</kbd>.</p>
<p>Forty-three functional interfaces are provided in the <kbd>java.util.function</kbd><span> package. Each of them contains only one abstract method. Lambda expressions take advantage of the one-abstract-method limitation and significantly simplifies the implementation of such an interface.</span></p>
<p>Without functional programming, the only way to pass some functionality as a parameter in Java would be through writing a class that implements an interface, creating its object, and then passing it as a parameter. But even the least involved style--using an anonymous class--requires writing too much of code. Using functional interfaces and lambda expressions makes the code shorter, clearer, and more expressive. </p>
<p>Throughout the chapter, we will define and explain these new Java features--functional interfaces and lambda expressions--and demonstrate their applicability in code examples. Bringing these new features into Java makes functions first-class citizens of the language. But taking advantage of their power requires, for those not exposed to functional programming yet, a new way of thinking and organizing the code.</p>
<p>Demonstrating these features and sharing the best practices of using them is the purpose of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding and creating a functional interface</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn about functional interfaces that are supported since Java 8.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Any interface that has one and only one abstract method is called a functional interface. To help avoid a runtime error, the <kbd>@FunctionalInterface</kbd> annotation was introduced in Java 8 that tells the compiler about the intent. In our demo code in the previous chapters, we've already had an example of a functional interface:</p>
<pre>public interface SpeedModel {<br/>  double getSpeedMph(double timeSec, <br/>  int weightPounds, int horsePower);<br/>  enum DrivingCondition {<br/>    ROAD_CONDITION,<br/>    TIRE_CONDITION<br/>  }<br/>  enum RoadCondition {<br/>    //...<br/>  }<br/>  enum TireCondition {<br/>    //...<br/>  }<br/>}</pre>
<p>The presence of <kbd>enum</kbd> types or any implemented (default or static) methods does not make it a non-functional interface. Only abstract (not implemented) methods count. So, this is an example of a functional interface too:</p>
<pre>public interface Vehicle {<br/>  void setSpeedModel(SpeedModel speedModel);<br/>  default double getSpeedMph(double timeSec){ return -1; };<br/>  default int getWeightPounds(){ return -1; }<br/>  default int getWeightKg(){ <br/>    return convertPoundsToKg(getWeightPounds());<br/>  }<br/>  private int convertPoundsToKg(int pounds){<br/>    return (int) Math.round(0.454 * pounds);<br/>  }<br/>  static int convertKgToPounds(int kilograms){<br/>    return (int) Math.round(2.205 * kilograms);<br/>  }<br/>}</pre>
<p>To recap what you have already learned about interfaces in one of the previous chapters, the implementation of the <kbd>getWeightPounds()</kbd> method will return <kbd>-1</kbd> when called by <kbd>getWeightKg()</kbd>. However, this is true only if the <kbd>getWeightPounds()</kbd> method is not implemented in a class. Otherwise, the class implementation will be used at runtime.</p>
<p>In addition to default and static interface methods, a functional interface can include any and all abstract methods of the base <kbd>java.lang.Object</kbd>. In Java, every object is provided with the default implementation of <kbd>java.lang.Object</kbd> methods, so the compiler and Java runtime ignore such abstract methods.</p>
<p>For example, this is a functional interface too:</p>
<pre>public interface SpeedModel {<br/>  double getSpeedMph(double timeSec, <br/>  int weightPounds, int horsePower);<br/>  boolean equals(Object obj);<br/>  String toString();<br/>}</pre>
<p>The following is not a functional interface, though:</p>
<pre>public interface Car extends Vehicle {<br/>  int getPassengersCount();<br/>}</pre>
<p>This is because the <kbd>Car</kbd> interface has two abstract methods: its own <kbd>getPassengersCount()</kbd> method and the <kbd>setSpeedModel()</kbd> method inherited from the <kbd>Vehicle</kbd> interface. Say, we add the <kbd>@FunctionalInterface</kbd> annotation to the <kbd>Car</kbd> interface: </p>
<pre>@FunctionalInterface <br/>public interface Car extends Vehicle {<br/>  int getPassengersCount();<br/>}</pre>
<p>If we do this, the compiler will generate the following error:</p>
<div class="CDPAlignCenter CDPAlign"><img height="44" width="552" class="image-border" src="assets/d457737f-7b1c-49f2-a9bc-cc493febdc0d.png"/></div>
<p>Using the <kbd>@FunctionalInterface</kbd> annotation helps to not only catch errors at compile time, but it also secures reliable communication of the design intent. It helps you or other programmers remember that this interface cannot have more than one abstract method, which is especially important in case code exists already that relies on such an assumption.  </p>
<p>For the same reason, the <kbd>Runnable</kbd> and <kbd>Callable</kbd> interfaces (they existed in Java since its earlier versions) in Java 8 were annotated as <kbd>@FunctionalInterface</kbd> to make this distinction explicit and remind the users about it or those attempting to add another abstract method to them:</p>
<pre>@FunctionalInterface<br/>interface Runnable { void run(); }<br/><br/>@FunctionalInterface<br/>interface Callable&lt;V&gt; { V call() throws Exception; }</pre>
<p>Before you create your own functional interface that you plan to use as a parameter for a method, consider avoiding it using one of the forty-three functional interfaces provided in the <kbd>java.util.function</kbd> package first. Most of them are specializations of the following four interfaces: <kbd>Function</kbd>, <kbd>Consumer</kbd>, <kbd>Supplier</kbd>, and <kbd>Predicate</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The following are the steps you can follow to get familiar with functional interfaces:</p>
<ol>
<li>Look at the functional interface <kbd>Function</kbd>: </li>
</ol>
<pre>        @FunctionalInterface<br/>        public interface Function&lt;T,R&gt;</pre>
<p style="padding-left: 60px">Here is its Javadoc, <em>Accepts one argument of type T and produces result of type R. The functional method is apply(Object).</em> You can create an implementation of this interface using an anonymous class:</p>
<pre>        Function&lt;Integer, Double&gt; ourFunc = new <br/>                          Function&lt;Integer, Double&gt;(){<br/>          public Double apply(Integer i){<br/>            return i * 10.0;<br/>          }<br/>        };</pre>
<p style="padding-left: 60px">Its only method, namely <kbd>apply()</kbd>, accepts the <span>value of the type </span><kbd>Integer</kbd> (or the primitive <kbd>int</kbd>, which is going to be autoboxed) as a parameter, then multiplies it by <kbd>10</kbd>, and returns the value of the type <kbd>Double</kbd> (or unboxed to the primitive <kbd>double</kbd>) so we can write the following:</p>
<pre>        System.out.println(ourFunc.apply(1));</pre>
<p style="padding-left: 60px">The result will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="29" width="170" class="image-border" src="assets/5c88fe54-f8a0-4f08-8bfc-36529d7aac51.png"/></div>
<p style="padding-left: 60px">In the next recipe, we will introduce a lambda expression and show you how its usage makes the implementation much shorter. But for now, we will continue using an anonymous class.</p>
<ol start="2">
<li>Look at the functional interface <kbd>Consumer</kbd> (the name helps to remember that the method of this interface accepts a value but does not return anything--it only consumes):</li>
</ol>
<pre>        public interface Consumer&lt;T&gt;<br/>        Accepts a single input argument of type T and returns no result.<br/>        The functional method is accept(Object).</pre>
<p style="padding-left: 60px">The implementation of this interface can look like the following:</p>
<pre>        Consumer&lt;String&gt; ourConsumer = new Consumer&lt;String&gt;() {<br/>          public void accept(String s) {<br/>            System.out.println("The " + s + " is consumed.");<br/>          }<br/>        };</pre>
<p style="padding-left: 60px">The <kbd>accepts()</kbd> method receives the parameter <span>value of the type</span> <kbd>String</kbd> and prints it. Say, we write the following:</p>
<pre>        ourConsumer.accept("Hello!");</pre>
<p style="padding-left: 60px">The result of this will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="35" width="268" class="image-border" src="assets/ba791e29-423b-48ed-be9e-cad408a7aa89.png"/></div>
<ol start="3">
<li>Look at the functional interface <kbd>Supplier</kbd> <span>(the name helps to remember that the method of this interface does not accept any value but does return something--only supplies</span><span>):</span></li>
</ol>
<pre>        public interface Supplier&lt;T&gt;<br/>        Represents a supplier of results of type T.<br/>        The functional method is get().</pre>
<p style="padding-left: 60px">It means that the only method of this interface is <kbd>get()</kbd>, which has no input parameter and returns the value of the type <kbd>T</kbd>. Based on this, we can create a function:</p>
<pre>        Supplier&lt;String&gt; ourSupplier = new Supplier&lt;String&gt;() {<br/>          public String get() {<br/>            String res = "Success";<br/>            //Do something and return result – Success or Error.<br/>            return res;<br/>          }<br/>        };</pre>
<p style="padding-left: 60px">The <kbd>(get()</kbd> method does something and then returns the value of the type <kbd>String</kbd>, so we can write the following:</p>
<pre>        System.out.println(ourSupplier.get());</pre>
<p style="padding-left: 60px">The result of this will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="32" width="198" class="image-border" src="assets/1ffd7bc3-6c96-4ee4-9f52-963e982b0a64.png"/></div>
<ol start="4">
<li>Look at the functional interface <kbd>Predicate</kbd> <span>(the name helps to remember that the method of this interface returns a boolean--predicates</span><span> something):</span></li>
</ol>
<pre>       @FunctionalInterface<br/>       public interface Predicate&lt;T&gt;</pre>
<p style="padding-left: 60px">Its JavaDoc states: <em>Represents a predicate (boolean-valued function) of one argument of type T. The functional method is test(Object)</em>. It means that the only method of this interface is <kbd>test(Object)</kbd> that accepts an input parameter of the type <kbd>T</kbd> and returns the value of the type <kbd>boolean</kbd>. Let's create a function:</p>
<pre>        Predicate&lt;Double&gt; ourPredicate = new Predicate&lt;Double&gt;() {<br/>          public boolean test(Double num) {<br/>            System.out.println("Test if " + num + <br/>                               " is smaller than 20");<br/>            return num &lt; 20;<br/>          }<br/>        };</pre>
<p style="padding-left: 60px">Its <kbd>test()</kbd> method accepts a <span>value of the type </span><kbd>Double</kbd> as a parameter and returns the value of the type <kbd>boolean</kbd> so we can write the following:</p>
<pre>        System.out.println(ourPredicate.test(10.0) ? <br/>                           "10 is smaller" : "10 is bigger");</pre>
<p style="padding-left: 60px">The result of this will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="33" width="228" class="image-border" src="assets/065dc324-ec5a-4355-80da-f432f7dce0c8.png"/></div>
<ol start="5">
<li>Look at the other 39 functional interfaces in the <kbd>java.util.function</kbd> package. Notice that they are variations of the four interfaces we have discussed already. These variations are created for the following reasons:</li>
</ol>
<ul>
<li style="list-style-type: none">
<ul>
<li>For better performance by avoiding autoboxing and unboxing via the explicit usage of the <kbd>int</kbd>, <kbd>double</kbd>, or <kbd>long</kbd> primitives </li>
<li>For accepting two input parameters</li>
<li>For a shorter notation</li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">The following functional interfaces are just a few examples from the list of 39 interfaces.</p>
<p style="padding-left: 60px">The functional interface <kbd>IntFunction&lt;R&gt;</kbd> (its only abstract method is <kbd>apply(int)</kbd>), accepts an <kbd>int</kbd> primitive and returns the value of the type <kbd>R</kbd>. It provides a shorter notation (without generics for the parameter type) and avoids autoboxing (by defining the <kbd>int</kbd> primitive as the parameter). Here's an example of this:</p>
<p> </p>
<pre>        IntFunction&lt;String&gt; function = new IntFunction&lt;String&gt;() {<br/>          public String apply(int i) {<br/>            return String.valueOf(i * 10);<br/>          }<br/>        };</pre>
<p style="padding-left: 60px">The functional interface <kbd>BiFunction&lt;T,U,R&gt;</kbd> (the <kbd>apply(T,U)</kbd> method) accepts two parameters of the types <kbd>T</kbd> and <kbd>U</kbd> and returns the value of the type <kbd>R</kbd>. Here's an example of this:</p>
<p> </p>
<pre>         BiFunction&lt;String, Integer, Double&gt; function = <br/>               new BiFunction&lt;String, Integer, Double &gt;() {<br/>           public Double apply(String s, Integer i) {<br/>             return (s.length() * 10d)/i;<br/>           }<br/>         };</pre>
<p style="padding-left: 60px">The functional interface <kbd>BinaryOperator&lt;T&gt;</kbd> (the <kbd>apply(T,T)</kbd> method) accepts two parameters of the type <kbd>T</kbd> and returns the value of the type <kbd>T</kbd>. It provides a shorter notation by avoiding repeating the same type three times. Here's an example of this:</p>
<pre>         BinaryOperator&lt;Integer&gt; function = <br/>                           new BinaryOperator&lt;Integer&gt;(){<br/>           public Integer apply(Integer i, Integer j) {<br/>             return i &gt;= j ? i : j;<br/>           }<br/>         };</pre>
<p style="padding-left: 60px">The functional interface <kbd>IntBinaryOperator</kbd> (the <kbd>applyAsInt(int,int)</kbd> method) accepts two parameters of the type <kbd>int</kbd> and returns the value of the type <kbd>int</kbd> too. Here's an example of this:</p>
<pre>        IntBinaryOperator function = new IntBinaryOperator(){<br/>          public int apply(int i, int j) {<br/>            return i &gt;= j ? i : j;<br/>          }<br/>        };</pre>
<p style="padding-left: 30px">We will see examples of the usage of such specializations in the following recipes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You can create and pass around an implementation of any functional interface as you do with any object. For example, let's write a method that creates <kbd>Function&lt;Integer, Double&gt;</kbd>:</p>
<pre>Function&lt;Integer, Double&gt; createMultiplyBy10(){<br/>  Function&lt;Integer, Double&gt; ourFunc = new Function&lt;Integer, Double&gt;(){<br/>    public Double apply(Integer i){ return i * 10.0; }<br/>  };<br/>  return ourFunc;<br/>}</pre>
<p>Better yet, we can create a generic method that uses the following:</p>
<pre>Function&lt;Integer, Double&gt; createMultiplyBy(<strong>double num</strong>){<br/>  Function&lt;Integer, Double&gt; ourFunc = new Function&lt;Integer, Double&gt;(){<br/>    public Double apply(Integer i){ return i * <strong>num</strong>; }<br/>  };<br/>  return ourFunc;<br/>}</pre>
<p>Now we can write this:</p>
<pre>Function&lt;Integer, Double&gt; multiplyBy10 = createMultiplyBy(10d);<br/>System.out.println(multiplyBy10.apply(1));<br/><br/>Function&lt;Integer, Double&gt; multiplyBy30 = createMultiplyBy(30d);<br/>System.out.println(multiplyBy30.apply(1));</pre>
<p>The results will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="39" width="106" class="image-border" src="assets/a434b198-33f7-4ae1-a5c2-659d7663861f.png"/></div>
<p>Similarly, we can have factory methods that create the <kbd>Function&lt;Double, Double&gt;</kbd> function, the <kbd>Consumer&lt;String&gt;</kbd> function, and the <kbd>Supplier&lt;String&gt;</kbd> function:</p>
<pre>Function&lt;Double, Double&gt; createSubtract(double num){<br/>  Function&lt;Double, Double&gt; ourFunc = new Function&lt;Double, Double&gt;(){<br/>    public Double apply(Double dbl){ return dbl - num; }<br/>  };<br/>  return ourFunc;<br/>}<br/>public static Consumer&lt;String&gt; createTalker(String value){<br/>  Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() {<br/>    public void accept(String s) { <br/>      System.out.println(s + value); <br/>    }<br/>  };<br/>  return consumer;<br/>}<br/>public static Supplier&lt;String&gt; createResultSupplier(){<br/>  Supplier&lt;String&gt; supplier = new Supplier&lt;String&gt;() {<br/>    public String get() {<br/>      String res = "Success";<br/>      //Do something and return Success or Error.<br/>      return res;<br/>    }<br/>  };<br/>  return supplier;<br/>}</pre>
<p>Let's use the preceding functions:</p>
<pre>Function&lt;Double,Double&gt; subtract7 = createSubtract(7.0);<br/>System.out.println(subtract7.apply(10.0));<br/><br/>Consumer&lt;String&gt; sayHappyToSee = createTalker("Happy to see<br/>                                              you again!");<br/>sayHappyToSee.accept("Hello!");<br/><br/>Supplier&lt;String&gt; successOrFailure = createResultSupplier();<br/>System.out.println(successOrFailure.get());</pre>
<p>The results will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="53" width="228" class="image-border" src="assets/a19d773c-2d8d-4a2f-8c58-39ce517fd946.png"/></div>
<p>We can also have factory methods that create different versions of the <kbd>Predicate&lt;Double&gt;</kbd> function: </p>
<pre>Predicate&lt;Double&gt; createIsSmallerThan(double limit){<br/>  Predicate&lt;Double&gt; pred = new Predicate&lt;Double&gt;() {<br/>    public boolean test(Double num) {<br/>      System.out.println("Test if " + num + " is smaller than " <br/>                         + limit);<br/>      return num &lt; limit;<br/>    }<br/>  };<br/>  return pred;<br/>}<br/>Predicate&lt;Double&gt; createIsBiggerThan(double limit){<br/>  Predicate&lt;Double&gt; pred = new Predicate&lt;Double&gt;() {<br/>    public boolean test(Double num) {<br/>      System.out.println("Test if " + num + " is bigger than " <br/>                         + limit);<br/>      return num &gt; limit;<br/>    }<br/>  };<br/>  return pred;<br/>}</pre>
<p>Let's use the preceding methods as following: </p>
<pre>Predicate&lt;Double&gt; isSmallerThan20 = createIsSmallerThan(20d);<br/>System.out.println(isSmallerThan20.test(10d));<br/><br/>Predicate&lt;Double&gt; isBiggerThan18 = createIsBiggerThan(18d);<br/>System.out.println(isBiggerThan18.test(10d));</pre>
<p>When we use them, we get the following results:</p>
<div class="CDPAlignCenter CDPAlign"><img height="55" width="262" class="image-border" src="assets/413eabe8-c132-4df0-b53f-f090dff46400.png"/></div>
<p>If needed, a function with more complex logic can be composed of several already existing functions:</p>
<pre>Supplier&lt;String&gt; applyCompareAndSay(int i,<br/>                      Function&lt;Integer, Double&gt; func,<br/>                      Predicate&lt;Double&gt; isSmaller){<br/>  Supplier&lt;String&gt; supplier = new Supplier&lt;String&gt;() {<br/>    public String get() {<br/>      double v = func.apply(i);<br/>      return isSmaller.test(v)? v + " is smaller" : v + " is bigger";<br/>    }<br/>  };<br/>  return supplier;<br/>}</pre>
<p>We can create it by passing the <kbd>multiplyBy10</kbd>, <kbd>multiplyBy30</kbd>, and <kbd>isSmallerThan20</kbd> functions to the factory method, which we have created before:</p>
<pre>Supplier&lt;String&gt; compare1By10And20 = <br/>         applyCompareAndSay(1, multiplyBy10, isSmallerThan20);<br/>System.out.println(compare1By10And20.get());<br/>Supplier&lt;String&gt; compare1By30And20 = <br/>         applyCompareAndSay(1, multiplyBy30, isSmallerThan20);<br/>System.out.println(compare1By30And20.get());</pre>
<p>If we run the preceding code, you'll get the following results:</p>
<div class="CDPAlignCenter CDPAlign"><img height="58" width="238" class="image-border" src="assets/49834ab6-22fd-46a6-a0b1-305cfd0c4c13.png"/></div>
<p>The first and the third lines come from the <kbd>isSmallerThan20</kbd> function, while the second and fourth line come from the <kbd>compare1By10And20</kbd> and <span><kbd>compare1By30And20</kbd> functions, correspondingly.</span></p>
<p>As you see, the introduction of functional interfaces enhances Java by allowing passing functions as parameters. An application developer can now concentrate on the implementation of the function (business process) and not worry about the plumbing of applying it to each element of a collection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Many of the functional interfaces in the <kbd>java.util.function</kbd> package have default methods that not only enhance their functionality, but also allow you to chain the functions and pass the result of one as an input parameter to another. For example, we can use the default method <kbd>andThen(Function after)</kbd> of the <kbd>Function</kbd> interface:  </p>
<pre>Supplier&lt;String&gt; compare1By30Less7To20 = <br/>         applyCompareAndSay(1, multiplyBy30.andThen(subtract7), <br/>                            isSmallerThan20);<br/>System.out.println(compare1By30Less7To20.get());<br/>Supplier&lt;String&gt; compare1By30Less7TwiceTo20 = <br/>         applyCompareAndSay(1, multiplyBy30.andThen(subtract7)<br/>                               .andThen(subtract7),isSmallerThan20);<br/>System.out.println(compare1By30Less7TwiceTo20.get());</pre>
<p>The <kbd>after</kbd> function is applied to the result of this function, so naturally, the input type of the <kbd>after</kbd> function has to be the same or a base type of the result of this function. The result of this code is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="61" width="270" class="image-border" src="assets/dab16363-d953-4944-bf4a-3c2511b2f31a.png"/></div>
<p>We could achieve the same result using another default method of the <kbd>Function</kbd> interface called <kbd>compose(Function before)</kbd>, which applies the <kbd>before</kbd> function first before applying this function. Naturally, in this case, we would need to switch positions of the <kbd>multiplyBy30</kbd> function and the <kbd>subtract7</kbd>: function: </p>
<pre>Supplier&lt;String&gt; compare1By30Less7To20 = <br/>         applyCompareAndSay(1, subtract7.<strong>compose</strong>(multiplyBy30),<br/>                            isSmallerThan20);<br/>System.out.println(compare1By30Less7To20.get());<br/>Supplier&lt;String&gt; compare1By30Less7TwiceTo20 = <br/>         applyCompareAndSay(1, subtract7.<strong>compose</strong>(multiplyBy30)<br/>                               .andThen(subtract7), isSmallerThan20);<br/> System.out.println(compare1By30Less7TwiceTo20.get());</pre>
<p>The result is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="59" width="262" class="image-border" src="assets/dab16363-d953-4944-bf4a-3c2511b2f31a.png"/></div>
<p>The <kbd>Consumer</kbd> interface has the <kbd>andThen(Consumer after)</kbd> method too, so we can create a dialog using the <kbd>sayHappyToSee</kbd> function we have created before:</p>
<pre>Consumer&lt;String&gt; askHowAreYou = createTalker("How are you?");<br/>sayHappyToSee.andThen(askHowAreYou).accept("Hello!");</pre>
<p>The result will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="36" width="227" class="image-border" src="assets/432a6e8d-bf34-480b-a221-23e999eabf3b.png"/></div>
<p><span>The </span><kbd>Supplier</kbd> interface does not have default methods, while the <kbd>Predicate</kbd> interface has one <kbd>isEqual(Object targetRef)</kbd> static method and three default methods: <kbd>and(Predicate other)</kbd>, <kbd>negate()</kbd>, and <kbd>or(Predicate other)</kbd>. We will demonstrate the usage of the <span><kbd>and(Predicate other)</kbd> method. </span></p>
<p>We can create a predicate, using the already created functions <kbd>isSmallerThan20</kbd> and <kbd>isBiggerThan18</kbd>, that checks whether the input value falls between the two values. But before this, we need to overload the <kbd>applyCompareAndSay()</kbd> factory method by adding another parameter to the signature named <kbd>message</kbd> that matches the new predicate:</p>
<pre>Supplier&lt;String&gt; applyCompareAndSay(int i, <br/>                   Function&lt;Integer, Double&gt; func, <br/>                   Predicate&lt;Double&gt; compare, String message) {<br/>  Supplier&lt;String&gt; supplier = new Supplier&lt;String&gt;() {<br/>    public String get() {<br/>      double v = func.apply(i);<br/>      return (compare.test(v)? v + " is " : v + " is not ") + message;<br/>    }<br/>  };<br/>  return supplier;<br/>} </pre>
<p>Now we can write the following:</p>
<pre>Supplier&lt;String&gt; compare1By30Less7TwiceTo18And20 = <br/>         applyCompareAndSay(1, multiplyBy30.andThen(subtract7)<br/>                               .andThen(subtract7),<br/>                            isSmallerThan20.and(isBiggerThan18), <br/>                            "between 18 and 20");<br/>System.out.println(compare1By30Less7TwiceTo18And20.get());</pre>
<p>We get the following results:</p>
<div class="CDPAlignCenter CDPAlign"><img height="50" width="306" class="image-border" src="assets/54b0267a-5ebe-4f00-a0ab-4b4552cc747b.png"/></div>
<p>If this coding looks a bit over-engineered and convoluted, it is true. We did it for demo purposes. Good news is that lambda expressions (presented in the next recipe) allow you to achieve the same results in a much more straightforward and clear way. </p>
<p>Before we end this recipe, we would like to mention that functional interfaces of the <kbd>java.util.function</kbd> package have other helpful default methods. The one that stands out is the <kbd>identity()</kbd> method, which returns a function that always returns its input argument:</p>
<pre>Function&lt;Integer, Integer&gt; id = Function.identity();<br/>System.out.println("Function.identity.apply(4) =&gt; " + id.apply(4));</pre>
<p>We will get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="30" width="314" class="image-border" src="assets/4be0aa15-0428-46c9-bc68-984fc6c4b2fd.png"/></div>
<p>The <kbd>identity()</kbd> method is very helpful when some procedure requires you to provide a certain function, but you do not want this function to modify the result.</p>
<p>Other default methods are mostly related to conversion and boxing and unboxing and extracting min and max of two parameters. We encourage you to walk through the API of all the functional interfaces of the <kbd>java.util.function</kbd> package and get a feeling of the possibilities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipes in this chapter:</p>
<ul>
<li>Understanding lambda expressions</li>
<li>Using method references</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding lambda expressions</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn about lambda expressions that are supported since Java 8.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>The examples in the previous recipe (that used anonymous classes for functional interfaces' implementation) looked bulky and felt excessively verbose. For one, there was no need to repeat the interface name because we had declared it already as the type for the object reference. Second, in the case of a functional interface (that had only one abstract method), there was no need to specify the method name to be implemented. The compiler and Java runtime can figure it out anyway. All we needed was to provide the new functionality. This is where a lambda expression comes to the rescue. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The following steps will help you to understand lambda expressions:</p>
<ol>
<li>Consider the following code, for example:</li>
</ol>
<pre>        Function&lt;Integer, Double&gt; ourFunc = <br/>                          new Function&lt;Integer, Double&gt;(){<br/>          public Double apply(Integer i){ return i * 10.0; }<br/>        };<br/>        System.out.println(ourFunc.apply(1));<br/><br/>        Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() {<br/>          public void accept(String s) {<br/>            System.out.println("The " + s + " is consumed.");<br/>          }<br/>        };<br/>        consumer.accept("Hello!");<br/><br/>        Supplier&lt;String&gt; supplier = new Supplier&lt;String&gt;() {<br/>          public String get() {<br/>            String res = "Success";<br/>            //Do something and return result – Success or Error.<br/>            return res;<br/>          }<br/>        };<br/>        System.out.println(supplier.get());<br/><br/>        Predicate&lt;Double&gt; pred = new Predicate&lt;Double&gt;() {<br/>          public boolean test(Double num) {<br/>            System.out.println("Test if " + num + <br/>                               " is smaller than 20");<br/>            return num &lt; 20;<br/>          }<br/>        };<br/>        System.out.println(pred.test(10.0) ? <br/>                           "10 is smaller" : "10 is bigger");</pre>
<ol start="2">
<li>Rewrite it using lambda expressions:</li>
</ol>
<pre>        Function&lt;Integer, Double&gt; ourFunc = i -&gt; i * 10.0;<br/>        System.out.println(ourFunc.apply(1));<br/><br/>        Consumer&lt;String&gt; consumer = <br/>           s -&gt; System.out.println("The " + s + " is consumed.");<br/>        consumer.accept("Hello!");<br/><br/>        Supplier&lt;String&gt; supplier = () -&gt; {<br/>          String res = "Success";<br/>          //Do something and return result – Success or Error.<br/>          return res;<br/>        };<br/>        System.out.println(supplier.get());<br/><br/>        Predicate&lt;Double&gt; pred = num -&gt; {<br/>          System.out.println("Test if " + num + " is smaller than 20");<br/>          return num &lt; 20;<br/>        };<br/>        System.out.println(pred.test(10.0) ? <br/>                           "10 is smaller" : "10 is bigger");</pre>
<ol start="3">
<li>Run it and you'll get the same result:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="69" width="254" class="image-border" src="assets/3a00634a-788a-4c8b-9c48-999ea420d64c.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The syntax of a lambda expression includes the list of parameters, an arrow token (<kbd>-&gt;</kbd>), and a body. The list of parameters can be empty (<kbd>()</kbd>), without brackets (if there is only one parameter, as in our examples), or a comma-separated list of parameters surrounded by brackets. The body can be a single expression (as in our preceding code) or a statement block. Here is another example:</p>
<pre>BiFunction&lt;Integer, String, Double&gt; demo = <br/>                  (x,y) -&gt; x * 10d + Double.parseDouble(y);<br/>System.out.println(demo.apply(1, "100"));<br/><br/>//The above is the equivalent to the statement block: <br/>demo = (x,y) -&gt; {<br/>  //You can add here any code you need<br/>  double v = 10d;<br/>  return x * v + Double.parseDouble(y); <br/>};<br/>System.out.println(demo.apply(1, "100"));</pre>
<p><span>The result of this example is as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="41" width="146" class="image-border" src="assets/6cdd87cf-be5b-48ae-8393-aa5f5fabf643.png"/></div>
<p><span>Braces are required only in the case of a statement block. They are optional in a one-line lambda expression, whether the function returns a value or not. </span></p>
<p>Let's rewrite the code we wrote before using lambda expressions:</p>
<pre>Function&lt;Integer, Double&gt; multiplyBy10 = i -&gt; i * 10.0;<br/>System.out.println("1 * 10.0 =&gt; "+multiplyBy10.apply(1));<br/><br/>Function&lt;Integer, Double&gt; multiplyBy30 = i -&gt; i * 30.0;<br/>System.out.println("1 * 30.0 =&gt; "+multiplyBy30.apply(1));<br/><br/>Function&lt;Double,Double&gt; subtract7 = x -&gt; x - 7.0;<br/>System.out.println("10.0 - 7.0 =&gt;"+subtract7.apply(10.0));<br/><br/>Consumer&lt;String&gt; sayHappyToSee = <br/>   s -&gt; System.out.println(s + " Happy to see you again!");<br/>sayHappyToSee.accept("Hello!");<br/><br/>Predicate&lt;Double&gt; isSmallerThan20 = x -&gt; x &lt; 20d;<br/>System.out.println("10.0 is smaller than 20.0 =&gt; " + <br/>                   isSmallerThan20.test(10d));<br/><br/>Predicate&lt;Double&gt; isBiggerThan18 = x -&gt; x &gt; 18d;<br/>System.out.println("10.0 is smaller than 18.0 =&gt; " + <br/>                   isBiggerThan18.test(10d));</pre>
<p>If we run this, we get the following:</p>
<div class="CDPAlignCenter CDPAlign"><img height="90" width="322" class="image-border" src="assets/9eaf6140-d6ac-436e-abf1-3bb7768056ee.png"/></div>
<p>As you see, the results are exactly the same, but the code is much simpler and captures only the essence.</p>
<p>The factory method can be rewritten and simplified using lambda expressions too:</p>
<pre>Supplier&lt;String&gt; applyCompareAndSay(int i, <br/>                      Function&lt;Integer, Double&gt; func, <br/>                      Predicate&lt;Double&gt; compare, String message){<br/>  return () -&gt; {<br/>    double v = func.apply(i);<br/>    return (compare.test(v) ? v + " is " : v + " is not ") + message;<br/>  };<br/>}</pre>
<p>We don't repeat the name of the implemented <kbd>Supplier&lt;String&gt;</kbd> interface anymore because it is specified as the return type in the method signature. And we do not specify the name of the implemented <kbd>test()</kbd> method either because it is the only method of the <kbd>Supplier</kbd> interface that has to be implemented. Writing such a compact and efficient code became possible because of the combination of a lambda expression and functional interface.</p>
<p>As in an anonymous class, the variable created outside and used inside a lambda expression becomes effectively final and cannot be modified. You can write the following code:</p>
<pre>double v = 10d;<br/>multiplyBy10 = i -&gt; i * v;</pre>
<p>However, you cannot change the value of the variable <kbd>v</kbd> outside the lambda expression:</p>
<pre>double v = 10d;<br/>v = 30d; //Causes compiler error<br/>multiplyBy10 = i -&gt; i * v;</pre>
<p>You cannot change it inside the expression as well: </p>
<pre><span>double </span>v = <span>10d</span><span>;<br/></span>multiplyBy10 = i -&gt; {<br/>  <span>v </span>= <span>30d</span><span>; //Causes compiler error<br/></span><span>  return </span>i * <span>v</span><span>;<br/></span>}<span>;<br/></span></pre>
<p>The reason for this restriction is that a function can be passed and executed for different arguments in different contexts (different threads, for example), and the attempt to synchronize these contexts would frustrate the original idea of the distributed evaluation of functions. </p>
<p>One principal difference between an anonymous class and lambda expression is the interpretation of the <kbd>this</kbd> keyword. Inside an anonymous class, it refers to the instance of the anonymous class. Inside the lambda expression, <kbd>this</kbd> refers to the instance of the class that surrounds the expression. Here is the demo code:</p>
<pre>public static void main(String arg[]) {<br/>  Demo d = new Demo();<br/>  d.method();<br/>}<br/><br/>public static class Demo{<br/>  private String prop = "DemoProperty";<br/>  public void method(){<br/>    Consumer&lt;String&gt; consumer = s -&gt; {<br/>    System.out.println("Lambda accept(" + s + "): this.prop=" <br/>                       + this.prop);<br/>  };<br/>  consumer.accept(this.prop);<br/><br/>  consumer = new Consumer&lt;String&gt;() {<br/>    private String prop = "ConsumerProperty";<br/>    public void accept(String s) {<br/>      System.out.println("Anonymous accept(" + s + "): this.prop=" <br/>                         + this.prop);<br/>    }<br/>  };<br/>  consumer.accept(this.prop);<br/>}</pre>
<p>The output of this code is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="48" width="401" class="image-border" src="assets/b355229c-dd29-4b91-aeef-4b48703a7312.png"/></div>
<p>The lambda expression is not an inner class and cannot be referred to by <kbd>this</kbd>. According to the Java specification, such an approach <span>allows you to have more flexibility of implementation by treating reference <kbd>this</kbd> as coming from the surrounding context.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Look how simpler and less convoluted the demo code becomes. We can create functions on the fly while passing them as parameters:</p>
<pre>Supplier&lt;String&gt; compare1By30Less7TwiceTo18And20 = <br/>        applyCompareAndSay(1, x -&gt; x * 30.0 - 7.0 - 7.0, <br/>                           x -&gt; x &lt; 20 &amp;&amp; x &gt; 18, "betwen 18 and 20");<br/>System.out.println("Compare (1 * 30 - 7 - 7) and the range"<br/>                   + " 18 to 20 =&gt; " <br/>                   + compare1By30Less7TwiceTo18And20Lambda.get());</pre>
<p>However, the result does not change:</p>
<div class="CDPAlignCenter CDPAlign"><img height="29" width="528" class="image-border" src="assets/599e058b-51ed-40a4-bfc1-8234aa557e00.png"/></div>
<p class="mce-root CDPAlignLeft CDPAlign"><span>This is the power and beauty of lambda expressions in combination with functional interfaces. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipes in this chapter:</p>
<ul>
<li>Understanding and creating a functional interface</li>
<li>Using method references</li>
</ul>
<p>Also, refer to <a href="ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml">Chapter 5</a>, <em>Stream Operations and Pipelines</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using method references</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn how to use a method reference, the constructor reference being one of the cases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In the cases, when a one-line lambda expression consists of a reference to an existing method only (implemented somewhere else), it is possible to further simplify the notation using the method reference. The reference method can be static or non-static (the latter can be bound to a particular object or not) or can be a constructor with or without parameters.</p>
<p>The syntax of the method reference is <kbd>Location::methodName</kbd>, where <kbd>Location</kbd> indicates where (in which object or class) the <kbd>methodName</kbd> method can be found. The two colons (<kbd>::</kbd>) serve as a separator between the location and the method name. If there are several methods with the same name at the specified location (because of the method overload), the reference method is identified by the signature of the abstract method of the functional interface implemented by the lambda expression.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Using a method reference is straightforward and can be easily illustrated by a few examples for each case: </p>
<ol>
<li>First, we have the static method reference. If a <kbd>Food</kbd> <span>class has a static method, named </span><kbd>String getFavorite()</kbd><span>, then the lambda expression may look like this: </span></li>
</ol>
<pre>         Supplier&lt;String&gt; supplier = Food::getFavorite;</pre>
<p style="padding-left: 60px">If the <kbd>Foo</kbd> class has another method, named <kbd>String <span>getFavorite</span>(int num)</kbd>, the lambda expression that uses it may look exactly the same:</p>
<pre>         Function&lt;Integer, String&gt; func = Food::<span>getFavorite</span>; </pre>
<p style="padding-left: 60px">The difference is in the interface that this lambda expression implements. It allows the compiler and Java runtime to identify the method to be used. Let's look at the code. Here is the <kbd>Food</kbd> class: </p>
<pre>         public class Food{<br/>           public static String getFavorite(){ return "Donut!"; }<br/>           public static String getFavorite(int num){<br/>             return num &gt; 1 ? String.valueOf(num) <br/>                              + " donuts!" : "Donut!";<br/>           }<br/>         }</pre>
<p style="padding-left: 60px">We can use its static methods as the implementation of the functional interfaces:</p>
<pre>         Supplier&lt;String&gt; supplier = Food::getFavorite;<br/>         System.out.println("supplier.get() =&gt; " + supplier.get());<br/><br/>         Function&lt;Integer, String&gt; func = Food::getFavorite;<br/>         System.out.println("func.getFavorite(1) =&gt; "<br/>                            + func.apply(1));<br/>         System.out.println("func.getFavorite(2) =&gt; " <br/>                            + func.apply(2));</pre>
<p style="padding-left: 60px">The result is going to be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="49" width="250" class="image-border" src="assets/243fe333-473d-483a-aebf-68e988515afd.png"/></div>
<ol start="2">
<li>Second, we have the method reference to a constructor. </li>
</ol>
<p style="padding-left: 60px">Let's assume that the <kbd>Food</kbd> class does not have an explicit constructor or has one without parameters. The closest to such a signature is a functional interface called <kbd>Supplier&lt;Food&gt;</kbd> because it does not take any parameter either. Let's add the following to our <kbd>Food</kbd> class: </p>
<pre>         private String name;<br/>         public Food(){ this.name = "Donut"; };<br/>         public String sayFavorite(){<br/>           return this.name + (this.name.toLowerCase()<br/>                      .contains("donut") ? "? Yes!" : "? D'oh!");<br/>         }</pre>
<p style="padding-left: 60px">Then we can write the following:</p>
<pre>         Supplier&lt;Food&gt; constrFood = Food::new;<br/>         Food food = constrFood.get();<br/>         System.out.println("new Food().sayFavorite() =&gt; " <br/>                            + food.sayFavorite());</pre>
<p style="padding-left: 60px">If we write this, we get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="32" width="345" class="image-border" src="assets/254a9d0b-de8b-4633-8769-dfa1d41c53a6.png"/></div>
<p style="padding-left: 60px">The preceding non-static method reference was bound to a particular instance of the <kbd>Food</kbd> class. We will come back to it and also discuss an unbound non-static method reference later. But, for now, we will add another constructor with one parameter to the <kbd>Food</kbd> class: </p>
<pre>         public Food(String name){ <br/>           this.name = name; <br/>         } </pre>
<p style="padding-left: 60px">Once we do this, we will express it via the method reference:</p>
<pre>         Function&lt;String, Food&gt; constrFood1 = Food::new;<br/>         food = constrFood1.apply("Donuts");<br/>         System.out.println("new Food(Donuts).sayFavorite() =&gt; " <br/>                            + food.sayFavorite());<br/>         food = constrFood1.apply("Carrot");<br/>         System.out.println("new Food(Carrot).sayFavorite() =&gt; " <br/>                            + food.sayFavorite());</pre>
<p style="padding-left: 60px">This results in the following code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="34" width="295" class="image-border" src="assets/15b7d338-980c-4b3f-822a-7833c90bf457.png"/></div>
<p style="padding-left: 60px">In the same manner, we can add a constructor with two parameters:</p>
<pre>         public Food(String name, String anotherName) {<br/>           this.name = name + " and " + anotherName;<br/>         }</pre>
<p style="padding-left: 60px">Once we do this, we can express it via <kbd>BiFunction&lt;String, String&gt;</kbd>:</p>
<pre>         BiFunction&lt;String, String, Food&gt; constrFood2 = Food::new;<br/>         food = constrFood2.apply("Donuts", "Carrots");<br/>         System.out.println("new Food(Donuts,Carrot).sayFavorite() =&gt; "<br/>                            + food.sayFavorite());<br/>         food = constrFood2.apply("Carrot", "Broccoli");<br/>         System.out.println("new Food(Carrot,Broccoli)<br/>                            .sayFavorite() =&gt; " + food.sayFavorite());</pre>
<p style="padding-left: 60px">This results in the following:</p>
<div class="CDPAlignCenter CDPAlign"><img height="39" width="408" class="image-border" src="assets/7216db59-3d5f-49fb-943d-030db088c859.png"/></div>
<p style="padding-left: 60px">To express a constructor that accepts more than two parameters, we can create a custom functional interface with any number of parameters. For example, consider the following:</p>
<pre>        @FunctionalInterface<br/>        interface Func&lt;T1,T2,T3,R&gt;{ R apply(T1 t1, T2 t2, T3 t3);}</pre>
<p style="padding-left: 60px">We can use it for different types:</p>
<pre>         Func&lt;Integer<span>, Double</span><span>, String</span><span>, Food</span>&gt; constr3 = Food::new;<br/>         Food food = constr3.apply(1, 2d, "Food");</pre>
<p style="padding-left: 60px">The name of this custom interface and the name of its only method can be anything we like:</p>
<pre>        @FunctionalInterface<br/>        interface FourParamFunction&lt;T1,T2,T3,R&gt;{<br/>          R <strong>construct</strong>(T1 t1, T2 t2, T3 t3);<br/>        }<br/>        Func&lt;Integer, Double, String, Food&gt; constr3 = Food::new;<br/>        Food food = constr3.<strong>construct</strong>(1, 2d, "Food");</pre>
<ol start="3">
<li>Third, we have the bound and unbound non-static methods. </li>
</ol>
<p style="padding-left: 60px">The method reference we used for the <kbd>sayFavorite()</kbd> method requires (bound to) the class instance. This means that we cannot change the instance of the class used in the function after the function is created. To demonstrate this, let's create three instances of the <kbd>Food</kbd> class and three instances of the <kbd>Supplier&lt;String&gt;</kbd> interface that capture the functionality of the <kbd>sayFavorite()</kbd> method: </p>
<pre>         Food food1 = new Food();<br/>         Food food2 = new Food("Carrot");<br/>         Food food3 = new Food("Carrot", "Broccoli");<br/>         Supplier&lt;String&gt; supplier1 = food1::sayFavorite;<br/>         Supplier&lt;String&gt; supplier2 = food2::sayFavorite;<br/>         Supplier&lt;String&gt; supplier3 = food3::sayFavorite;<br/>         System.out.println("new Food()=&gt;supplier1.get() =&gt; " + <br/>                            supplier1.get());<br/>         System.out.println("new Food(Carrot)=&gt;supplier2.get() =&gt; " <br/>                            + supplier2.get());<br/>         System.out.println("new Food(Carrot,Broccoli)" +<br/>                            "=&gt;supplier3.get() =&gt; " + supplier3.get());</pre>
<p style="padding-left: 60px">As you can see, after the supplier is created, we can only call the <kbd>get()</kbd> method on it and cannot change the instance (of the <kbd>Food</kbd> class) to which it was bound (the <kbd>get()</kbd> method refers to the method of the objects <kbd>food1</kbd>, <kbd>food2</kbd>, or <kbd>food3</kbd>). The results are as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="45" width="378" class="image-border" src="assets/5cecb1b6-cc9e-4cbc-b5ab-895055fa6efa.png"/></div>
<p style="padding-left: 60px">By contrast, we can create an unbound master reference with the instance of the <kbd>Function&lt;Food, String&gt;</kbd> interface (notice that the method location is specified as a class name called <kbd>Food</kbd>):</p>
<pre>        Function&lt;Food, String&gt; func = Food::sayFavorite;</pre>
<p style="padding-left: 60px">This means we can use a different instance of the <kbd>Food</kbd> class for every call of this function:</p>
<pre>        System.out.println("new Food().sayFavorite() =&gt; " <br/>                           + func.apply(food1));<br/>        System.out.println("new Food(Carrot).sayFavorite() =&gt; " <br/>                           + func.apply(food2));<br/>        System.out.println("new Food(Carrot,Broccoli).sayFavorite()=&gt; " <br/>                           + func.apply(food3));</pre>
<p style="padding-left: 60px">This is why this method reference is called <strong>unbound</strong>.</p>
<p style="padding-left: 60px">Finally, we can overload the <kbd>sayFavorite()</kbd> method (in the same way we did it for the static method <kbd>getFavorite()</kbd>) by adding the <kbd>sayFavorite(String name)</kbd> method: </p>
<pre>        public String sayFavorite(String name){<br/>          this.name = this.name + " and " + name;<br/>          return sayFavorite();<br/>        }</pre>
<p style="padding-left: 60px">With this, we can show that the compiler and Java runtime can still understand (using the signature of the specified functional interface) our intent and invoke the correct method: </p>
<pre>        Function&lt;String, String&gt; func1 = food1::sayFavorite;<br/>        Function&lt;String, String&gt; func2 = food2::sayFavorite;<br/>        Function&lt;String, String&gt; func3 = food3::sayFavorite;<br/>        System.out.println("new Food().sayFavorite(Carrot) =&gt; " <br/>                           + func1.apply("Carrot"));<br/>        System.out.println("new Food(Carrot).sayFavorite(Broccoli) =&gt; "<br/>                           + func2.apply("Broccoli"));<br/>        System.out.println("new Food(Carrot,Broccoli)" +<br/>                           ".sayFavorite(Donuts) =&gt; " + <br/>                           func3.apply("Donuts"));</pre>
<p style="padding-left: 60px">The results are as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="54" width="541" class="image-border" src="assets/4a2625f3-e5d8-4e9b-8ef1-e74acc1c38d5.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>There are several simple but useful lambda expressions and method references often used in practice:</p>
<pre>Function&lt;String, Integer&gt; strLength = String::length;<br/>System.out.println(strLength.apply("3"));<br/><br/>Function&lt;String, Integer&gt; parseInt = Integer::parseInt;<br/>System.out.println(parseInt.apply("3"));<br/><br/>Consumer&lt;String&gt; consumer = System.out::println;<br/>consumer.accept("Hello!");</pre>
<p>If we run them, the results would be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="51" width="148" class="image-border" src="assets/5ca72d7c-0e95-4351-a9ab-2ae57f7d3c14.png"/></div>
<p>Here are a few useful methods for working with arrays and lists:</p>
<pre>Function&lt;Integer, String[]&gt; createArray = String[]::new;<br/>String[] arr = createArray.apply(3);<br/>System.out.println("Array length=" + arr.length);<br/>int i = 0;<br/>for(String s: arr){ arr[i++] = String.valueOf(i); }<br/><br/>Function&lt;String[], List&lt;String&gt;&gt; toList = Arrays::&lt;String&gt;asList;<br/>List&lt;String&gt; l = toList.apply(arr);<br/>System.out.println("List size=" + l.size());<br/>for(String s: l){ System.out.println(s); }</pre>
<p>Here are the results of the preceding code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="67" width="147" class="image-border" src="assets/06ceb52f-9e96-4b4a-a4ed-b73c7f1a7530.png"/></div>
<p>We leave it up to you to analyze how they were created and used.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipes in this chapter:</p>
<ul>
<li>Understanding and creating a functional interface</li>
<li>Understanding lambda expressions</li>
</ul>
<p><span>Also, refer to <a href="ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml">Chapter 5</a>,</span> <em>Stream Operations and Pipelines</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating and invoking lambda-friendly APIs</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn how to create lambda-friendly APIs and the best practices of doing it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>When an idea of a new API first comes up, it usually looks clean and well focused. Even the first implemented version often preserves the same qualities. But then "one-offs" and other small deviations from the main use cases become pressing, and the API starts to grow (and becomes increasingly complex and more difficult to use) as the variety of use cases increases. Life does not always comply with our vision of it. That's why any API designer at some point faces the question of how generic and flexible the API should be. A too-generic API makes it difficult to understand in terms of the specific business domain, while a very flexible API makes the implementation more complex and difficult to test, maintain, and use.</p>
<p>Using interfaces as parameters facilitate flexibility but require writing new code that implements them. Functional interfaces and lambda expressions allow the decreasing of the scope of such code to a minimum by capturing the functionality with almost no plumbing. The granularity of such an implementation can be as fine or as coarse as needed without the need to create new classes, their object factories, and other traditional infrastructure.</p>
<p>However, it is possible to push the flexibility too far and overuse the power of the new features to the point when it defeats the purpose by making the API difficult to understand and next to impossible to use. To warn about certain pitfalls and share the best practices of a lambda-friendly API design is the purpose of this recipe. </p>
<p>The best practices of a lambda-friendly API design include the following:</p>
<ul>
<li>Prefer the interfaces of the <kbd>java.util.function</kbd> package </li>
<li>Avoid overloading methods by the type of the functional interface</li>
<li>Use the <kbd>@FunctionalInterface</kbd> annotation for custom functional interfaces</li>
<li>Consider the functional interface as a parameter instead of creating several methods that are different only as per some step of the functionality</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We talked about the first two of the listed practices in the <em>Understanding and creating a functional interface</em> recipe. The advantage of using the interfaces of the <kbd>java.util.function</kbd> package is based on two facts. First, any standardization facilitates better understanding and ease of API usage. Second, it facilitates minimal code writing.</p>
<p><span>To illustrate these considerations, let's try to create an API and call it <kbd>GrandApi</kbd>--an interface that is going to be implemented in the <kbd>GrandApiImpl</kbd> class. </span></p>
<p><span>Let's add a method to our new API that allows the client to pass a function that calculates something. Such an arrangement allows a client to customize the behavior of the API as needed. This design is called a delegation pattern. It helps with an object composition, which we have discussed in <a href="8fa56f18-959c-4d24-8073-c4cb67c30355.xhtml">Chapter 2</a>, <em>Fast Track to OOP - Classes and Interfaces</em>. </span></p>
<p>First, we demonstrate the traditional object-oriented approach and introduce a <kbd>Calculator</kbd> interface that has a method that calculates something:</p>
<pre>public interface Calculator {<br/>  double calculateSomething();<br/>}<br/>public class CalcImpl implements Calculator{<br/>  private int par1;<br/>  private double par2;<br/>  public CalcImpl(int par1, double par2){<br/>    this.par1 = par1;<br/>    this.par2 = par2;<br/>  }<br/>  public double calculateSomething(){<br/>    return par1 * par2;<br/>  }<br/>}</pre>
<p><span>So, the first method of our new interface can have the following method:</span></p>
<pre>public interface GrandApi{<br/>  double doSomething(Calculator calc, String str, int i);<br/>}</pre>
<p><span>The implementation of this method may look like this:</span></p>
<pre>double doSomething(Calculator calc, String str, int i){<br/>  return calc.calculateSomething() * i + str.length();<br/>}</pre>
<p><span>We can now create a <kbd>CalucaltorImpl</kbd> class that implements the <kbd>Calculator</kbd> interface and pass the object of <kbd>CalculatorImpl</kbd> to the <kbd>doSomething()</kbd> method:</span></p>
<pre>GrandApi api = new GrandImpl();<br/>Calculator calc = new CalcImpl(20, 10d);<br/>double res = api.doSomething(calc, "abc", 2);<br/>System.out.println(res);</pre>
<p><span>The result will be as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/88382a8e-acde-4623-bfbe-51e25c1dc10c.png"/></div>
<p>If the client would want to use another <kbd>Calculator</kbd> implementation, this approach would require you to either create a new class or use an anonymous class:</p>
<pre>GrandApi api = new GrandImpl();<br/>double res = api.doSomething(new Calculator() {<br/>  public double calculateSomething() {<br/>    return 20 * 10d;<br/>  }<br/>}, "abc", 2);<br/>System.out.println(res);</pre>
<p>These were the two options available for a client before Java 8. And if the client is forced to use a certain <kbd>Calculator</kbd> implementation (developed by a third party, for example), the anonymous class could not be used; therefore, only one option would remain.</p>
<p>With Java 8, the client can take advantage of the <kbd>Calculator</kbd> interface that has one abstract method only (so, it is being a functional interface). Say, a client is forced to use a third-party implementation:</p>
<pre>public static class AnyImpl{<br/>  public double doIt(){ return 1d; }<br/>  public double doSomethingElse(){ return 100d; }<br/>}</pre>
<p>The client could write the following:</p>
<pre>GrandApi api = new GrandImpl();<br/>AnyImpl anyImpl = new AnyImpl();<br/>double res = api.doSomething(anyImpl::doIt, "abc", 2); <br/>System.out.println(res);</pre>
<p>If they do this, they'll get the following result:</p>
<div class="CDPAlignCenter CDPAlign"><img height="34" width="145" class="image-border" src="assets/c3ae1f26-eec3-451b-a4a9-42ab557bf033.png"/> </div>
<p>The compiler and Java runtime match the functional interface primarily by the number of input parameters and the presence or absence of the return value.</p>
<p>If the usage of a third-party implementation is not mandatory, the client can use a lambda expression, for example, the following:</p>
<pre>double res = api.doSomething(() -&gt; 20 * 10d, "abc", 2);<br/>System.out.println(res);</pre>
<p>They can alternatively use this:</p>
<pre>int i = 20;<br/>double d = 10.0;<br/>double res = api.doSomething(() -&gt; i * d, "abc", 2);<br/>System.out.println(res);</pre>
<p>In both these cases, they will get this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="38" width="171" class="image-border" src="assets/bc4b4875-90b6-4d2c-ba26-f211b37b2a25.png"/></div>
<p>However, all of these is possible only as long as the <kbd>Calculator</kbd> interface has only one abstract method. So, we better have the <kbd>@FunctionalInterface</kbd> annotation added to it, if we can. This is because the client code with lambda will break as soon as <kbd>Calculator</kbd> gains another abstract method. </p>
<p><span>However, we can avoid creating a custom interface if we use one of the standard functional interfaces from the <kbd>java.util.function</kbd> package. The matching one, in this case, would be <kbd>Supplier&lt;Double&gt;</kbd>, and we can change our first API method to this:</span></p>
<pre>public interface GrandApi{<br/>  double doSomething(Supplier&lt;Double&gt; supp, String str, int i);<br/>}</pre>
<p>Now we are sure that the client code with lambda will never break, and the client code will be much shorter:</p>
<pre>GrandApi api = new GrandImpl();<br/>Supplier&lt;Double&gt; supp = () -&gt; 20 * 10d;<br/>double res = api.doSomething(supp, "abc", 2);<br/>System.out.println(res);</pre>
<p><span>It could also be this:</span></p>
<pre>GrandApi api = new GrandImpl();<br/>double res = api.doSomething(() -&gt; 20 * 10d, "abc", 2);<br/>System.out.println(res);</pre>
<p>In either case, the result will be the same:</p>
<div class="CDPAlignCenter CDPAlign"><img height="33" width="141" class="image-border" src="assets/88382a8e-acde-4623-bfbe-51e25c1dc10c.png"/></div>
<p>If the client is forced to use the existing implementation, the code can be as follows:</p>
<pre>GrandApi api = new GrandImpl();<br/>AnyImpl anyImpl = new AnyImpl();<br/>double res = api.doSomething(anyImpl::doIt, "abc", 2); <br/>System.out.println(res);</pre>
<p><span>It will still yield the same result for the <kbd>AnyImpl</kbd> class:  </span></p>
<div class="CDPAlignCenter CDPAlign"><img height="31" width="132" class="image-border" src="assets/c3ae1f26-eec3-451b-a4a9-42ab557bf033.png"/></div>
<p><span>This is why using standard functional interfaces is highly advisable because it allows more flexibility and less client code writing. </span><span>That said, one should be careful not to get into an overloading of the methods by the type of functional interface only. The problem is that the algorithm that identifies the method by its functional interface parameter often does not have much to work with, especially if the method invocation includes an inline lambda expression only. The algorithm checks the number of input parameters (arity) and the presence or absence (<kbd>void</kbd>) of the return value. But even this may be not enough, and the API user may have a serious debugging problem. Let's look at an example and add these two methods to our API: </span></p>
<pre><span>double doSomething2(Function&lt;Integer,Integer&gt; function, double num);<br/>void doSomething2(Consumer&lt;String&gt; consumer, double num);<br/></span></pre>
<p><span>For a human eye, these methods have very different signatures. They are resolved correctly as long as the passed-in instance of a functional interface is explicitly specified:</span></p>
<pre> GrandApi api = new GrandImpl();<br/> Consumer&lt;String&gt; consumer = System.out::println;<br/> api.doSomething2(consumer, 2d);</pre>
<p><span>The type of the functional interface can be also specified using typecasting: </span></p>
<pre>GrandApi api = new GrandImpl();<br/>api.doSomething2((Consumer&lt;String&gt;)System.out::println,2d);</pre>
<p><span>Now consider the code that does not specify the type of the passed-in functional interface:</span></p>
<pre>GrandApi api = new GrandImpl();<br/>api.doSomething2(System.out::println, 2d);</pre>
<p><span>It does not even compile, and gives the following error message:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/41807ce9-ca2b-4604-a011-eee52b892265.png"/></div>
<p><span>The reason for the error is that both the interfaces (<kbd>Function&lt;Integer, Integer&gt;</kbd> and <kbd>Consumer&lt;String&gt;</kbd></span><span>) have the same number of input parameters, while the different return type (<kbd>Integer</kbd> and <kbd>void</kbd> ) apparently is not enough to resolve the method overload in this case. So, instead of overloading the method using different functional interfaces, use different method names. For example, check out the following: </span></p>
<pre><span>double doSomethingWithFunction(Function&lt;Integer, Integer&gt; function,<br/>                               double num);<br/>void doSomethingWIthConsumer(Consumer&lt;String&gt; consumer, double num);</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The following are the best practices for constructing a lambda expression:</p>
<ul>
<li>Keep it stateless</li>
<li>Avoid a block statement</li>
<li>Use a method reference</li>
<li>Rely on effectively final</li>
<li>Do not work around effectively final</li>
<li>Avoid specifying the parameter type</li>
<li>Avoid brackets for a single parameter</li>
<li>Avoid braces and the return statement</li>
</ul>
<p>An API designer should keep these guidelines in mind too because the API clients will probably use them.</p>
<p>Keeping lambda expressions stateless means that the result of the function evaluation must depend only on the input parameters, no matter how often the expression is evaluated or which parameters were used for the previous call. For example, this would be a bug-prone code:</p>
<pre>GrandApi api = new GrandImpl();<br/>int[] arr = new int[1];<br/>arr[0] = 1;<br/>double res = api.doSomething(() -&gt; 20 * 10d + arr[0]++, "abc", 2);<br/>System.out.println(res);<br/>res = api.doSomething(() -&gt; 20 * 10d + arr[0]++, "abc", 2);<br/>System.out.println(res);<br/>res = api.doSomething(() -&gt; 20 * 10d + arr[0]++, "abc", 2);<br/>System.out.println(res);</pre>
<p>This is because it yields different results every time:</p>
<div class="CDPAlignCenter CDPAlign"><img height="53" width="183" class="image-border" src="assets/c89a1037-79a6-44ba-96b4-c94608f85055.png"/></div>
<p>This example also covers recommendations to rely on effectively final and not to work around it. By specifying <kbd>final int[] arr</kbd> in the preceding example, one gets an illusion that the code is bulletproof while, in fact, it hides the defect.</p>
<p>Other best practices of a lambda help to keep the code clear to better express its main logic, which otherwise might be lost in long-winded code and a multitude of notations. Just compare the following lines. Here's the first line:</p>
<pre>double res = api.doSomething2((Integer i) -&gt; { return i * 10; }, 2d);</pre>
<p>Here's the second line:</p>
<pre>double res = api.doSomething2(i -&gt; i * 10, 2d); </pre>
<p>The second line is much cleaner and clearer, especially in the case of several parameters and complex logic in the block statement. We will see examples of block statements and how to avoid them in the next recipe. Any modern editor helps to remove unnecessary notation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipe in this chapter:</p>
<ul>
<li>Leveraging lambda expressions in your programs</li>
</ul>
<p><span>Also, refer to <a href="ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml">Chapter 5</a>﻿,</span> <em>Stream Operations and Pipelines</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Leveraging lambda expressions in your programs</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will learn how to apply a lambda expression to your code. We will get back to the demo application and modify it by introducing a lambda where it makes sense.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Equipped with functional interfaces, lambda expressions, and the best practices of a lambda-friendly API design, we can substantially improve our speed-calculating application by making its design more flexible and user friendly. Let's set up some background, the motivation, and the infrastructure as close to a real-life problem as possible without making it too complex.</p>
<p>The driverless cars and related problems are on the front pages today, and there is a good reason to believe it is going be this way for quite some time. One of the tasks in this domain is the analysis and modeling of the traffic flow in an urban area based on real data. A lot of such data already exists and will continue to be collected in future. Let's assume that we have access to such a database by date, time, and geographical location. Let's also assume that the traffic data from this database comes in units, each capturing details about one vehicle and its driving conditions:</p>
<pre>public interface TrafficUnit {<br/>  VehicleType getVehicleType();<br/>  int getHorsePower();<br/>  int getWeightPounds();<br/>  int getPayloadPounds();<br/>  int getPassengersCount();<br/>  double getSpeedLimitMph();<br/>  double getTraction();<br/>  RoadCondition getRoadCondition();<br/>  TireCondition getTireCondition();<br/>  int getTemperature();<br/>} </pre>
<p>This is where <kbd>VehicleType</kbd>, <kbd>RoadCondition</kbd>, and <kbd>TireCondition</kbd> are <kbd>enum</kbd> types we have already constructed in the previous chapter:</p>
<pre>enum VehicleType { <br/>  CAR("Car"), TRUCK("Truck"), CAB_CREW("CabCrew");<br/>  private String type;<br/>  VehicleType(String type){ this.type = type; }<br/>  public String getType(){ return this.type;}<br/>}<br/>enum RoadCondition {<br/>  DRY(1.0), <br/>  WET(0.2) { public double getTraction() { <br/>    return temperature &gt; 60 ? 0.4 : 0.2; } }, <br/>  SNOW(0.04);<br/>  public static int temperature;<br/>  private double traction;<br/>  RoadCondition(double traction){ this.traction = traction; }<br/>  public double getTraction(){return this.traction;}<br/>}<br/>enum TireCondition {<br/>  NEW(1.0), WORN(0.2);<br/>  private double traction;<br/>  TireCondition(double traction){ this.traction = traction; }<br/>  public double getTraction(){ return this.traction;}<br/>}<br/><br/></pre>
<p>The interface of accessing traffic data may look like this:</p>
<pre>TrafficUnit <span>getOneUnit</span>(Month month<span>, </span>DayOfWeek dayOfWeek<span>, <br/>                       int </span>hour<span>, </span>String country<span>, </span>String city<span>, <br/></span>                       String trafficLight);<br/>List&lt;TrafficUnit&gt; generateTraffic(int trafficUnitsNumber, <br/>                  Month month, DayOfWeek dayOfWeek, int hour,<br/>                  String country, String city, String trafficLight);</pre>
<p>So the possible call could be done as follows: </p>
<pre>TrafficUnit trafficUnit = FactoryTraffic.getOneUnit(Month.APRIL, <br/>               DayOfWeek.FRIDAY, 17, "USA", "Denver", "Main103S");</pre>
<p>This is where <kbd>17</kbd> refers to an hour of the day (5 p.m.), and <kbd>Main1035</kbd> is a traffic light identification, or the call can request multiple results as follows:</p>
<pre>List&lt;TrafficUnit&gt; trafficUnits = <br/>    FactoryTrafficModel.<span>generateTraffic</span>(<span>20</span><span>, </span>Month.<span>APRIL</span><span>, D</span>ayOfWeek.<span>FRIDAY</span><span>,<br/>                                        </span><span>17</span><span>, </span><span>"USA"</span><span>, </span><span>"Denver"</span><span>, </span><span>"Main103S"</span>)<span>;</span></pre>
<p>Where <kbd>20</kbd> is the number of the requested units of traffic.</p>
<p>As you can see, such a traffic factory provides data about traffic in a particular location at a particular time (between 5 p.m. and 6 p.m. in our example). Each call to the factory yields a different result, while the list of traffic units describes statistically correct data (including the most probable weather conditions) in the specified location. </p>
<p>We will also change the interfaces of <kbd>FactoryVehicle</kbd> and <kbd>FactorySpeedModel</kbd> so they could build <kbd>Vehicle</kbd> and <kbd>SpeedModel</kbd> based on the <kbd>TrafficUnit</kbd> interface. The resulting demo code is as follows:</p>
<pre>double timeSec = 10.0;<br/>TrafficUnit trafficUnit = FactoryTraffic.getOneUnit(Month.APRIL, <br/>            DayOfWeek.FRIDAY, 17, "USA", "Denver", "Main103S");<br/>Vehicle vehicle = FactoryVehicle.build(trafficUnit);<br/>SpeedModel speedModel =  <br/>          FactorySpeedModel.generateSpeedModel(trafficUnit);<br/>vehicle.setSpeedModel(speedModel);<br/>printResult(trafficUnit, timeSec, vehicle.getSpeedMph(timeSec));</pre>
<p>Where method <kbd>printResult()</kbd> has the following code:</p>
<pre>void printResult(TrafficUnit tu, double timeSec, <br/>                                          double speedMph){<br/>   System.out.println("Road " + tu.getRoadCondition() + ", tires "<br/>                      + tu.getTireCondition() + ": " <br/>                      + tu.getVehicleType().getType() <br/>                      + " speedMph (" + timeSec + " sec)=" <br/>                      + speedMph + " mph");<br/>}</pre>
<p>The output of this code may look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="37" width="426" class="image-border" src="assets/ecdb20f0-5281-4fdf-80bd-bb6ac0dade0e.png"/></div>
<p>Since we use the "real" data now, every run of this program produces a different result, based on the statistical properties of the data. In a certain location, a car or dry weather would appear more often at that date and time, while in another location, a truck or snow would be more typical. </p>
<p>In this run, the traffic unit brought a wet road, new tires, and <kbd>Truck</kbd> with such an engine power and load that in 10 seconds it was able to reach the speed of 22 mph. The formula which we used to calculate the speed (inside an object of <kbd>SpeedModel</kbd>) is familiar to you:</p>
<pre>double weightPower = 2.0 * horsePower * 746 * 32.174 / weightPounds;<br/>double speed = Math.round(Math.sqrt(timeSec * weightPower) <br/>                          * 0.68 * traction);</pre>
<p>Here, the <kbd>traction</kbd> value comes from <kbd>TrafficUnit</kbd> (see its interface we just discussed). In the class that implements the <kbd>TrafficUnit</kbd> interface, the method <kbd>getTraction()</kbd> looks like the following:</p>
<pre>public double getTraction() {<br/>  double rt = getRoadCondition().getTraction();<br/>  double tt = getTireCondition().getTraction();<br/>  return rt * tt;<br/>}</pre>
<p>The methods <kbd>getRoadCondition()</kbd> and <kbd>getTireCondition()</kbd> return the elements of the corresponding <kbd>enum</kbd> types we just described. </p>
<p><span>Now we are ready to improve our speed-calculating application using the new features of Java we discussed in the previous recipes.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow these steps to learn how to use lambda expressions:</p>
<ol>
<li>Let's start building an API. We will call it <kbd>Traffic</kbd>. Without using functional interfaces, it might look like this:</li>
</ol>
<pre>        public interface Traffic {<br/>          void speedAfterStart(double timeSec, int trafficUnitsNumber);<br/>        }  </pre>
<p style="padding-left: 60px">Its implementation may be as follows:</p>
<pre>        public class TrafficImpl implements Traffic {<br/>          private int hour;<br/>          private Month month;<br/>          private DayOfWeek dayOfWeek;<br/>          private String country, city, trafficLight;<br/>          public TrafficImpl(Month month, DayOfWeek dayOfWeek, <br/>                             int hour, String country, String city, <br/>                             String trafficLight){<br/>            this.month = month;<br/>            this.dayOfWeek = dayOfWeek;<br/>            this.hour = hour;<br/>            this.country = country;<br/>            this.city = city;<br/>            this.trafficLight = trafficLight;<br/>          }<br/>          public void speedAfterStart(double timeSec, <br/>                                      int trafficUnitsNumber) {<br/>            List&lt;TrafficUnit&gt; trafficUnits = <br/>                FactoryTraffic.generateTraffic(trafficUnitsNumber,<br/>                               month, dayOfWeek, hour, country,<br/>                               city, trafficLight);<br/>            for(TrafficUnit tu: trafficUnits){<br/>              Vehicle vehicle = FactoryVehicle.build(tu);<br/>              SpeedModel speedModel = <br/>                  FactorySpeedModel.generateSpeedModel(tu);<br/>              vehicle.setSpeedModel(speedModel);<br/>              double speed = vehicle.getSpeedMph(timeSec);<br/>              printResult(tu, timeSec, speed);<br/>            }<br/>          }<br/>        }</pre>
<ol start="2">
<li>Now let's write sample code that uses this interface:</li>
</ol>
<pre>        Traffic api = new TrafficImpl(Month.APRIL, DayOfWeek.FRIDAY,<br/>                                      17, "USA", "Denver", "Main103S");<br/>        double timeSec = 10.0;<br/>        int trafficUnitsNumber = 10;<br/>        api.speedAfterStart(timeSec, trafficUnitsNumber); </pre>
<p style="padding-left: 60px">We get results similar to the following:</p>
<div class="CDPAlignCenter CDPAlign"><img height="131" width="415" class="image-border" src="assets/61d60df2-8a6c-4572-a6de-5d40af385cff.png"/></div>
<p style="padding-left: 60px">As mentioned before, since we are using real data, the same code does not produce exactly the same result every time. One should not expect to see the speed values as in the preceding screenshot but something that looks very similar instead.</p>
<ol start="3">
<li>Let's use a lambda expression. The preceding API is quite limited. For example, it does not allow you to test different speed calculation formulas without changing <kbd>FactorySpeedModel</kbd><span>. Meanwhile, the</span> <kbd>SpeedModel</kbd> <span>interface has only one abstract method called </span><kbd>getSpeedMph()</kbd><span>:</span></li>
</ol>
<pre>        public interface SpeedModel {<br/>          double getSpeedMph(double timeSec, int weightPounds, <br/>                             int horsePower);<br/>        }</pre>
<p style="padding-left: 60px">This makes it a functional interface, and we can take advantage of this fact and add another method to our API that is able to accept the <kbd>SpeedModel</kbd> implementation as a lambda expression:</p>
<pre>        public interface Traffic {<br/>          void speedAfterStart(double timeSec, int trafficUnitsNumber, <br/>                               SpeedModel speedModel);<br/>        }</pre>
<p style="padding-left: 60px">The problem though is that the <kbd>traction</kbd> value does not come as a parameter to the <kbd>getSpeedMph()</kbd> method, so we cannot implement it as a function before passing it to our API method. Look closer at the speed calculation:</p>
<pre>        double weightPower = <br/>               2.0 * horsePower * 746 * 32.174/weightPounds;<br/>        double speed = Math.round(Math.sqrt(timeSec * weightPower) <br/>                                  * 0.68 * traction);</pre>
<p style="padding-left: 60px">When you do this, you notice that <kbd>traction</kbd> acts as a simple multiplier to the value of <kbd>speed</kbd>, so we can apply it after the speed calculation (and avoid calling <kbd>FactorySpeedModel</kbd>):</p>
<pre>        public void speedAfterStart(double timeSec, <br/>               int trafficUnitsNumber, SpeedModel speedModel) {<br/>          List&lt;TrafficUnit&gt; trafficUnits = <br/>               FactoryTraffic.generateTraffic(trafficUnitsNumber,<br/>                                   month, dayOfWeek, hour, country,<br/>                                   city, trafficLight);<br/>          for(TrafficUnit tu: trafficUnits){<br/>            Vehicle vehicle = FactoryVehicle.build(tu);<br/>            vehicle.setSpeedModel(speedModel);<br/>            double speed = vehicle.getSpeedMph(timeSec);<br/>            <strong>speed = Math.round(speed * tu.getTraction());</strong><br/>            printResult(tu, timeSec, speed);<br/>          }<br/>        }</pre>
<p style="padding-left: 60px">This change allows the API users to pass <kbd>SpeedModel</kbd> as a function: </p>
<pre>        Traffic api = new TrafficImpl(Month.APRIL, DayOfWeek.FRIDAY, <br/>                                      17, "USA", "Denver", "Main103S");<br/>        double timeSec = 10.0;<br/>        int trafficUnitsNumber = 10;<br/>        SpeedModel speedModel = (t, wp, hp) -&gt; {<br/>          double weightPower = 2.0 * hp * 746 * 32.174 / wp;<br/>          return Math.round(Math.sqrt(t * weightPower) * 0.68);<br/>        };<br/>        api.speedAfterStart(timeSec, trafficUnitsNumber, speedModel);</pre>
<ol start="4">
<li>The result of this code is the same as <kbd>SpeedModel</kbd> generated by <kbd>FactorySpeedModel</kbd>. But now the API users can come up with their own speed-calculating function. For example, they can write the following:</li>
</ol>
<pre>        Vehicle vehicle = FactoryVehicle.build(trafficUnit);<br/>        SpeedModel speedModel = (t, wp, hp) -&gt; {<br/><strong>          return -1.0;</strong><br/>        };<br/>        vehicle.setSpeedModel(speedModel);<br/>        printResult(trafficUnit, timeSec, vehicle.getSpeedMph(timeSec));</pre>
<p style="padding-left: 30px">The result will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="128" width="437" class="image-border" src="assets/f1b90891-2535-41cc-b37c-3eef5007afc1.png"/></div>
<ol start="5">
<li>Annotate the <kbd>SpeedModel</kbd> interface as <kbd>@FunctionalInterface</kbd>, so everybody who tries to add another method to it would be dutifully warned and would not be able to add another abstract method without removing this annotation and being aware of the risk of breaking the code of the existing clients that have implemented this functional interface already. </li>
<li>Improve the API by adding various criteria that slice all of the possible traffic into segments.</li>
</ol>
<p style="padding-left: 60px">For example, API users might want to analyze only cars, trucks, cars that have an engine bigger than 300 horsepower, trucks with an engine bigger than 400 horsepower, and so on. The traditional way to accomplish this would be by creating methods such as these:  </p>
<pre>        void speedAfterStartCarEngine(double timeSec, <br/>                            int trafficUnitsNumber, int horsePower);<br/>        void speedAfterStartCarTruckOnly(double timeSec, <br/>                                 int trafficUnitsNumber);<br/>        void speedAfterStartCarTruckEngine(double timeSec, <br/>                            int trafficUnitsNumber, int carHorsePower, <br/>                            int truckHorsePower);</pre>
<p style="padding-left: 60px">Instead, we can just add standard functional interfaces to the existing method and let the API user decide which slice of traffic to extract:</p>
<pre>        void speedAfterStart(double timeSec, int trafficUnitsNumber,<br/>                             SpeedModel speedModel, <br/>                             Predicate&lt;TrafficUnit&gt; limitTraffic);</pre>
<p style="padding-left: 60px">The implementation would look like as follows:</p>
<pre>        public void speedAfterStart(double timeSec, <br/>                    int trafficUnitsNumber, SpeedModel speedModel, <br/>                    Predicate&lt;TrafficUnit&gt; limitTraffic) {<br/>          List&lt;TrafficUnit&gt; trafficUnits = <br/>               FactoryTraffic.generateTraffic(trafficUnitsNumber,<br/>                                      month, dayOfWeek, hour, country,<br/>                                      city, trafficLight);<br/>          for(TrafficUnit tu: trafficUnits){<br/>            <strong>if(limitTraffic.test(tu){</strong><br/>              Vehicle vehicle = FactoryVehicle.build(tu);<br/>              vehicle.setSpeedModel(speedModel);<br/>              double speed = vehicle.getSpeedMph(timeSec);<br/>              speed = Math.round(speed * tu.getTraction());<br/>              printResult(tu, timeSec, speed);<br/>            <strong>}</strong><br/>          }<br/>        }</pre>
<p style="padding-left: 60px">The API users can call it, for example, as follows:</p>
<pre>        Predicate&lt;TrafficUnit&gt; limitTraffic = tu -&gt;<br/>                  (tu.getHorsePower() &lt; 250 &amp;&amp; tu.getVehicleType() <br/>                   == VehicleType.CAR) || (tu.getHorsePower() &lt; 400 <br/>                   &amp;&amp; tu.getVehicleType()==VehicleType.TRUCK);<br/><br/>        api.speedAfterStart(timeSec, trafficUnitsNumber, <br/>                            speedModel, limitTraffic);</pre>
<p style="padding-left: 60px">The results are now limited to the cars with an engine smaller than 250 hp and trucks with an engine smaller than 400 hp:</p>
<div class="CDPAlignCenter CDPAlign"><img height="74" width="373" class="image-border" src="assets/f3af413f-cd39-410d-ad62-574945845fac.png"/></div>
<p style="padding-left: 60px">In fact, an API user can now apply any criteria for limiting the traffic as long as they are applicable to the values in the <kbd>TrafficUnit</kbd> object. A user can write, for example, the following:</p>
<pre>        Predicate&lt;TrafficUnit&gt; limitTraffic2 = <br/>            tu -&gt; tu.getTemperature() &gt; 65 <br/>            &amp;&amp; tu.getTireCondition() == TireCondition.NEW <br/>            &amp;&amp; tu.getRoadCondition() == RoadCondition.WET;</pre>
<p style="padding-left: 60px">Alternatively, they can write any other combination of limits on the values that come from <kbd>TrafficUnit</kbd>. If a user decides to remove the limit and analyze all of the traffic, this code will do it too:</p>
<pre>        api.speedAfterStart(timeSec, trafficUnitsNumber, <br/>                            speedModel, tu -&gt; true);</pre>
<ol start="7">
<li>Allow including the value of the calculated speed in the list of the criteria. One way to do this is to change the implementation this way:  </li>
</ol>
<pre>        public void speedAfterStart(double timeSec,  <br/>                    int trafficUnitsNumber, SpeedModel speedModel,<br/>                    BiPredicate&lt;TrafficUnit, Double&gt; limitSpeed){<br/>          List&lt;TrafficUnit&gt; trafficUnits = <br/>               FactoryTraffic.generateTraffic(trafficUnitsNumber,<br/>                                      month, dayOfWeek, hour, country,<br/>                                      city, trafficLight);<br/>          for(TrafficUnit tu: trafficUnits){<br/>            Vehicle vehicle = FactoryVehicle.build(tu);<br/>            vehicle.setSpeedModel(speedModel);<br/>            double speed = vehicle.getSpeedMph(timeSec);<br/>            speed = Math.round(speed * tu.getTraction());<br/>            <strong>if(limitSpeed.test(tu, speed)){</strong><br/>              printResult(tu, timeSec, speed);<br/>            <strong>}</strong><br/>          }<br/>        }</pre>
<p style="padding-left: 60px">The API would then look like this:</p>
<pre>        void speedAfterStart(double timeSec, int trafficUnitsNumber, <br/>                       SpeedModel speedModel,<br/>                       BiPredicate&lt;TrafficUnit, Double&gt; limitSpeed);</pre>
<p style="padding-left: 60px">The client code may be as follows:</p>
<pre>          BiPredicate&lt;TrafficUnit, Double&gt; limitSpeed = (tu, sp) -&gt;<br/>            (sp &gt; (tu.getSpeedLimitMph() + 8.0) <br/>             &amp;&amp; tu.getRoadCondition() == RoadCondition.DRY) || <br/>            (sp &gt; (tu.getSpeedLimitMph() + 5.0) <br/>             &amp;&amp; tu.getRoadCondition() == RoadCondition.WET) || <br/>            (sp &gt; (tu.getSpeedLimitMph() + 0.0) <br/>             &amp;&amp; tu.getRoadCondition() == RoadCondition.SNOW);<br/><br/>          api.speedAfterStart(timeSec, trafficUnitsNumber, <br/>                              speedModel, limitSpeed);</pre>
<p style="padding-left: 60px">This example limits traffic by the speed that exceeds a different cushion in different driving conditions. If needed, it can disregard the speed at all and limit traffic exactly the same way the previous predicate did. The only drawback of this implementation is that it is slightly less efficient because the predicate is applied after the speed calculations. This means that the speed calculation will be done for each generated traffic unit, not to a limited number, as in the previous implementation. If this is a concern, you might leave all the different signatures in the API:</p>
<pre>        public interface Traffic {<br/>          void speedAfterStart(double timeSec, int trafficUnitsNumber);<br/>          void speedAfterStart(double timeSec, int trafficUnitsNumber,<br/>                               SpeedModel speedModel);<br/>          void speedAfterStart(double timeSec, int trafficUnitsNumber,<br/>                         SpeedModel speedModel, <br/>                         Predicate&lt;TrafficUnit&gt; limitTraffic);<br/>          void speedAfterStart(double timeSec, int trafficUnitsNumber,<br/>                         SpeedModel speedModel, <br/>                         BiPredicate&lt;TrafficUnit,Double&gt; limitTraffic);<br/>        }</pre>
<p style="padding-left: 30px">Once you leave them, let the user decide which of the methods to use, more flexible or more efficient (if the default speed calculation implementation is acceptable). </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>So far, we did not leave the API user a choice of the output format. Currently, it is implemented as the method <kbd>printResult()</kbd>: </p>
<pre>void printResult(TrafficUnit tu, double timeSec, double speedMph) {<br/>  System.out.println("Road " + tu.getRoadCondition() + ", tires " <br/>                     + tu.getTireCondition() + ": " <br/>                     + tu.getVehicleType().getType() + " speedMph (" <br/>                     + timeSec + " sec)=" + speedMph + " mph");<br/>}</pre>
<p>To make it more flexible, we can add another parameter to our API:</p>
<pre>Traffic api = new TrafficImpl(Month.APRIL, DayOfWeek.FRIDAY, 17,<br/>                              "USA", "Denver", "Main103S");<br/>double timeSec = 10.0;<br/>int trafficUnitsNumber = 10;<br/>BiConsumer&lt;TrafficUnit, Double&gt; output = (tm, sp) -&gt;<br/>  System.out.println("Road " + tm.getRoadCondition() + ", tires " <br/>                     + tm.getTireCondition() + ": " <br/>                     + tm.getVehicleType().getType() + " speedMph (" <br/>                     + timeSec + " sec)=" + sp + " mph");<br/>api.speedAfterStart(timeSec, trafficUnitsNumber, speedModel, output);</pre>
<p>Notice that we take the <kbd>timeSec</kbd> value not as one of the function parameters, but from the enclosed scope of the function. We can do this because it remains constant (and can be effectively final) throughout the calculations. In the same manner, we can add any other object to the <kbd>output</kbd> function--a filename or another output device, for example--thus leaving all the output-related decisions to the API user. To accommodate this new function, the API implementation changes to the following:</p>
<pre>public void speedAfterStart(double timeSec, int trafficUnitsNumber,<br/>                            SpeedModel speedModel) {<br/>  List&lt;TrafficUnit&gt; trafficUnits = FactoryTraffic<br/>              .generateTraffic(trafficUnitsNumber, month, <br/>                               dayOfWeek, hour, country, city,<br/>                               trafficLight);<br/>  for(TrafficUnit tu: trafficUnits){<br/>    Vehicle vehicle = FactoryVehicle.build(tu);<br/>    vehicle.setSpeedModel(speedModel);<br/>    double speed = vehicle.getSpeedMph(timeSec);<br/>    speed = Math.round(speed * tu.getTraction());<br/>    <strong>printResult.accept(tu, speed);</strong><br/>  }<br/>}</pre>
<p>It took us a while to come to this point where the power of functional programming starts shining and justifying the effort of learning it. Yet, in conjunction with Reactive Streams, described in the next chapter, this Java addition yields even more power. In the next chapter, the motivation for this enhancement becomes even more apparent and fully appreciated. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to <a href="ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml">Chapter 5</a>, <em>Stream Operations and Pipelines</em></p>


            </article>

            
        </section>
    </body></html>