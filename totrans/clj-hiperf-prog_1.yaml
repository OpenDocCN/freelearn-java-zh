- en: Chapter 1. Performance by Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clojure is a safe, functional programming language that brings great power and
    simplicity to the user. Clojure is also dynamically and strongly typed, and has
    very good performance characteristics. Naturally, every activity performed on
    a computer has an associated cost. What constitutes acceptable performance varies
    from one use-case and workload to another. In today's world, performance is even
    the determining factor for several kinds of applications. We will discuss Clojure
    (which runs on the **JVM** (**Java Virtual Machine**)), and its runtime environment
    in the light of performance, which is the goal of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The performance of Clojure applications depend on various factors. For a given
    application, understanding its use cases, design and implementation, algorithms,
    resource requirements and alignment with the hardware, and the underlying software
    capabilities is essential. In this chapter, we will study the basics of performance
    analysis, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Classifying the performance anticipations by the use cases types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outlining the structured approach to analyze performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A glossary of terms, commonly used to discuss performance aspects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The performance numbers that every programmer should know
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case classification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The performance requirements and priority vary across the different kinds of
    use cases. We need to determine what constitutes acceptable performance for the
    various kinds of use cases. Hence, we classify them to identify their performance
    model. When it comes to details, there is no sure shot performance recipe for
    any kind of use case, but it certainly helps to study their general nature. Note
    that in real life, the use cases listed in this section may overlap with each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: The user-facing software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The performance of user-facing applications is strongly linked to the user's
    anticipation. Having a difference of a good number of milliseconds may not be
    perceptible for the user but at the same time, a wait of more than a few seconds
    may not be taken kindly. One important element in normalizing anticipation is
    to engage the user by providing duration-based feedback. A good idea to deal with
    such a scenario would be to start the task asynchronously in the background, and
    poll it from the UI layer to generate a duration-based feedback for the user.
    Another way could be to incrementally render the results to the user to even out
    the anticipation.
  prefs: []
  type: TYPE_NORMAL
- en: Anticipation is not the only factor in user facing performance. Common techniques
    like staging or precomputation of data, and other general optimization techniques
    can go a long way to improve the user experience with respect to performance.
    Bear in mind that all kinds of user facing interfaces fall into this use case
    category—the Web, mobile web, GUI, command line, touch, voice-operated, gesture...you
    name it.
  prefs: []
  type: TYPE_NORMAL
- en: Computational and data-processing tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Non-trivial compute intensive tasks demand a proportional amount of computational
    resources. All of the CPU, cache, memory, efficiency and the parallelizability
    of the computation algorithms would be involved in determining the performance.
    When the computation is combined with distribution over a network or reading from/staging
    to disk, I/O bound factors come into play. This class of workloads can be further
    subclassified into more specific use cases.
  prefs: []
  type: TYPE_NORMAL
- en: A CPU bound computation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A CPU bound computation is limited by the CPU cycles spent on executing it.
    Arithmetic processing in a loop, small matrix multiplication, determining whether
    a number is a **Mersenne prime**, and so on, would be considered CPU bound jobs.
    If the algorithm complexity is linked to the number of iterations/operations *N*,
    such as *O(N)*, *O(N* *²)* and more, then the performance depends on how big *N*
    is, and how many CPU cycles each step takes. For parallelizable algorithms, performance
    of such tasks may be enhanced by assigning multiple CPU cores to the task. On
    virtual hardware, the performance may be impacted if the CPU cycles are available
    in bursts.
  prefs: []
  type: TYPE_NORMAL
- en: A memory bound task
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A memory bound task is limited by the availability and bandwidth of the memory.
    Examples include large text processing, list processing, and more. For example,
    specifically in Clojure, the `(reduce f (pmap g coll))` operation would be memory
    bound if `coll` is a large sequence of big maps, even though we parallelize the
    operation using `pmap` here. Note that higher CPU resources cannot help when memory
    is the bottleneck, and vice versa. Lack of availability of memory may force you
    to process smaller chunks of data at a time, even if you have enough CPU resources
    at your disposal. If the maximum speed of your memory is *X* and your algorithm
    on single the core accesses the memory at speed *X/3*, the multicore performance
    of your algorithm cannot exceed three times the current performance, no matter
    how many CPU cores you assign to it. The memory architecture (for example, SMP
    and NUMA) contributes to the memory bandwidth in multicore computers. Performance
    with respect to memory is also subject to page faults.
  prefs: []
  type: TYPE_NORMAL
- en: A cache bound task
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A task is cache bound when its speed is constrained by the amount of cache available.
    When a task retrieves values from a small number of repeated memory locations,
    for example a small matrix multiplication, the values may be cached and fetched
    from there. Note that CPUs (typically) have multiple layers of cache, and the
    performance will be at its best when the processed data fits in the cache, but
    the processing will still happen, more slowly, when the data does not fit into
    the cache. It is possible to make the most of the cache using **cache-oblivious**
    algorithms. A higher number of concurrent cache/memory bound threads than CPU
    cores is likely to flush the instruction pipeline, as well as the cache at the
    time of context switch, likely leading to a severely degraded performance.
  prefs: []
  type: TYPE_NORMAL
- en: An input/output bound task
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An **input/output** (**I/O**) bound task would go faster if the I/O subsystem,
    that it depends on, goes faster. Disk/storage and network are the most commonly
    used I/O subsystems in data processing, but it can be serial port, a USB-connected
    card reader, or any I/O device. An I/O bound task may consume very few CPU cycles.
    Depending on the speed of the device, connection pooling, data compression, asynchronous
    handling, application caching, and more, may help in performance. One notable
    aspect of I/O bound tasks is that performance is usually dependent on the time
    spent waiting for connection/seek, and the amount of serialization that we do,
    and hardly on the other resources.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, many data processing workloads are usually a combination of CPU
    bound, memory bound, cache bound, and I/O bound tasks. The performance of such
    mixed workloads effectively depends on the even distribution of CPU, cache, memory,
    and I/O resources over the duration of the operation. A bottleneck situation arises
    only when one resource gets too busy to make way for another.
  prefs: []
  type: TYPE_NORMAL
- en: Online transaction processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Online transaction processing** (**OLTP**) systems process the business transactions
    on demand. They can sit behind systems such as a user-facing ATM machine, point-of-sale
    terminal, a network-connected ticket counter, ERP systems, and more. The OLTP
    systems are characterized by low latency, availability, and data integrity. They
    run day-to-day business transactions. Any interruption or outage is likely to
    have a direct and immediate impact on sales or service. Such systems are expected
    to be designed for resiliency rather than delayed recovery from failures. When
    the performance objective is unspecified, you may like to consider graceful degradation
    as a strategy.'
  prefs: []
  type: TYPE_NORMAL
- en: It is a common mistake to ask the OLTP systems to answer analytical queries,
    something that they are not optimized for. It is desirable for an informed programmer
    to know the capability of the system, and suggest design changes as per the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Online analytical processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Online analytical processing** (**OLAP**) systems are designed to answer
    analytical queries in a short time. They typically get data from the OLTP operations,
    and their data model is optimized for querying. They basically provide for consolidation
    (roll-up), drill-down and slicing and dicing of data for analytical purposes.
    They often use specialized data stores that can optimize ad-hoc analytical queries
    on the fly. It is important for such databases to provide pivot-table like capability.
    Often, the OLAP cube is used to get fast access to the analytical data.'
  prefs: []
  type: TYPE_NORMAL
- en: Feeding the OLTP data into the OLAP systems may entail workflows and multistage
    batch processing. The performance concern of such systems is to efficiently deal
    with large quantities of data while also dealing with inevitable failures and
    recovery.
  prefs: []
  type: TYPE_NORMAL
- en: Batch processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Batch processing** is automated execution of predefined jobs. These are typically
    bulk jobs that are executed during off-peak hours. Batch processing may involve
    one or more stages of job processing. Often batch processing is clubbed with workflow
    automation, where some workflow steps are executed offline. Many of the batch
    processing jobs work on staging of data, and on preparing data for the next stage
    of processing to pick up.'
  prefs: []
  type: TYPE_NORMAL
- en: Batch jobs are generally optimized for the best utilization of the computing
    resources. Since there is little to moderate the demand to lower the latencies
    of some particular subtasks, these systems tend to optimize for throughput. A
    lot of batch jobs involve largely I/O processing and are often distributed over
    a cluster. Due to distribution, the data locality is preferred when processing
    the jobs; that is, the data and processing should be local in order to avoid network
    latency in reading/writing data.
  prefs: []
  type: TYPE_NORMAL
- en: A structured approach to the performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In practice, the performance of non-trivial applications is rarely a function
    of coincidence or prediction. For many projects, performance is not an option
    (it is rather a necessity), which is why this is even more important today. Capacity
    planning, determining performance objectives, performance modeling, measurement,
    and monitoring are key.
  prefs: []
  type: TYPE_NORMAL
- en: Tuning a poorly designed system to perform is significantly harder, if not practically
    impossible, than having a system well-designed from the start. In order to meet
    a performance goal, performance objectives should be known before the application
    is designed. The performance objectives are stated in terms of latency, throughput,
    resource utilization, and workload. These terms are discussed in the following
    section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The resource cost can be identified in terms of application scenarios, such
    as browsing of products, adding products to shopping cart, checkout, and more.
    Creating workload profiles that represent users performing various operations
    is usually helpful.
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance modeling** is a reality check for whether the application design
    will support the performance objectives. It includes performance objectives, application
    scenarios, constraints, measurements (benchmark results), workload objectives
    and if available, the performance baseline. It is not a replacement for measurement
    and load testing, rather, the model is validated using these. The performance
    model may include the performance test cases to assert the performance characteristics
    of the application scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application to production almost always needs some form of **capacity
    planning**. It has to take into account the performance objectives for today and
    for the foreseeable future. It requires an idea of the application architecture,
    and an understanding of how the external factors translate into the internal workload.
    It also requires informed expectations about the responsiveness and the level
    of service to be provided by the system. Often, capacity planning is done early
    in a project to mitigate the risk of provisioning delays.
  prefs: []
  type: TYPE_NORMAL
- en: The performance vocabulary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several technical terms that are heavily used in performance engineering.
    It is important to understand these, as they form the cornerstone of the performance-related
    discussions. Collectively, these terms form a performance vocabulary. The performance
    is usually measured in terms of several parameters, where every parameter has
    roles to play—such parameters are a part of the vocabulary.
  prefs: []
  type: TYPE_NORMAL
- en: Latency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Latency** is the time taken by an individual unit of work to complete the
    task. It does not imply successful completion of a task. Latency is not collective,
    it is linked to a particular task. If two similar jobs—`j1` and `j2` took 3 ms
    and 5 ms respectively, their latencies would be treated as such. If `j1` and `j2`
    were dissimilar tasks, it would have made no difference. In many cases the average
    latency of similar jobs is used in the performance objectives, measurement, and
    monitoring results.'
  prefs: []
  type: TYPE_NORMAL
- en: Latency is an important indicator of the health of a system. A high performance
    system often thrives on low latency. Higher than normal latency can be caused
    due to load or bottleneck. It helps to measure the latency distribution during
    a load test. For example, if more than 25 percent of similar jobs, under a similar
    load, have significantly higher latency than others, then it may be an indicator
    of a bottleneck scenario that is worth investigating.
  prefs: []
  type: TYPE_NORMAL
- en: When a task called `j1` consists of smaller tasks called `j2`, `j3`, and `j4`,
    the latency of `j1` is not necessarily the sum of the latencies of each of `j2`,
    `j3`, and `j4`. If any of the subtasks of `j1` are concurrent with another, the
    latency of `j1` will turn out to be less than the sum of the latencies of `j2`,
    `j3`, and `j4`. The I/O bound tasks are generally more prone to higher latency.
    In network systems, latency is commonly based on the round-trip to another host,
    including the latency from source to destination, and then back to source.
  prefs: []
  type: TYPE_NORMAL
- en: Throughput
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Throughput** is the number of successful tasks or operations performed in
    a unit of time. The top-level operations performed in a unit of time are usually
    of a similar kind, but with a potentially different from latencies. So, what does
    throughput tell us about the system? It is the rate at which the system is performing.
    When you perform load testing, you can determine the maximum rate at which a particular
    system can perform. However, this is not a guarantee of the conclusive, overall,
    and maximum rate of performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Throughput is one of the factors that determine the scalability of a system.
    The throughput of a higher level task depends on the capacity to spawn multiple
    such tasks in parallel, and also on the average latency of those tasks. The throughput
    should be measured during load testing and performance monitoring to determine
    the peak-measured throughput, and the maximum-sustained throughput. These factors
    contribute to the scale and performance of a system.
  prefs: []
  type: TYPE_NORMAL
- en: Bandwidth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Bandwidth** is the raw data rate over a communication channel, measured in
    a certain number of bits per second. This includes not only the payload, but also
    all the overhead necessary to carry out the communication. Some examples are:
    Kbits/sec, Mbits/sec, and more. An uppercase B such as KB/sec denotes Bytes, as
    in kilobytes per second. Bandwidth is often compared to throughput. While bandwidth
    is the raw capacity, throughput for the same system is the successful task completion
    rate, which usually involves a round-trip. Note that throughput is for an operation
    that involves latency. To achieve maximum throughput for a given bandwidth, the
    communication/protocol overhead and operational latency should be minimal.'
  prefs: []
  type: TYPE_NORMAL
- en: For storage systems (such as hard disks, solid-state drives, and more) the predominant
    way to measure performance is **IOPS** (**Input-output per second**), which is
    multiplied by the transfer size and represented as bytes per second, or further
    into MB/sec, GB/sec, and more. IOPS is usually derived for sequential and random
    workloads for read/write operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mapping the throughput of a system to the bandwidth of another may lead to
    dealing with an impedance mismatch between the two. For example, an order processing
    system may perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Transact with the database on disk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post results over the network to an external system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the bandwidth of the disk sub-system, the bandwidth of the network,
    and the execution model of order processing, the throughput may depend not only
    on the bandwidth of the disk sub-system and network, but also on how loaded they
    currently are. Parallelism and pipelining are common ways to increase the throughput
    over a given bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: Baseline and benchmark
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The performance **baseline**, or simply baseline, is the reference point, including
    measurements of well-characterized and understood performance parameters for a
    known configuration. The baseline is used to collect performance measurements
    for the same parameters that we may benchmark later for another configuration.
    For example, collecting "throughput distribution over 10 minutes at a load of
    50 concurrent threads" is one such performance parameter that we can use for baseline
    and benchmarking. A baseline is recorded together with the hardware, network,
    OS and JVM configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The performance **benchmark**, or simply benchmark, is the recording of the
    performance parameter measurements under various test conditions. A benchmark
    can be composed of a performance test suite. A benchmark may collect small to
    large amounts of data, and may take varying durations depending on the use-cases,
    scenarios, and environment characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: A baseline is a result of the benchmark that was conducted at one point in time.
    However, a benchmark is independent of the baseline.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Performance** **profiling** , or simply profiling, is the analysis of the
    execution of a program at its runtime. A program can perform poorly for a variety
    of reasons. A **profiler** can analyze and find out the execution time of various
    parts of the program. It is possible to put statements in a program manually to
    print the execution time of the blocks of code, but it gets very cumbersome as
    you try to refine the code iteratively.'
  prefs: []
  type: TYPE_NORMAL
- en: A profiler is of great assistance to the developer. Going by how profilers work,
    there are three major kinds—instrumenting, sampling, and event-based.
  prefs: []
  type: TYPE_NORMAL
- en: '**Event-based profilers**: These profilers work only for selected language
    platforms, and provide a good balance between the overhead and results; Java supports
    event-based profiling via the JVMTI interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The instrumenting profilers**: These profilers modify code at either compile
    time, or runtime to inject performance counters. They are intrusive by nature
    and add significant performance overhead. However, you can profile the regions
    of code very selectively using the instrumenting profilers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The sampling profilers**: These profilers pause the runtime and collect its
    state at "sampling intervals". By collecting enough samples, they get to know
    where the program is spending most of its time. For example, at a sampling interval
    of 1 millisecond, the profiler would have collected 1000 samples in a second.
    A sampling profiler also works for code that executes faster than the sampling
    interval (as in, the code may perform several iterations of work between the two
    sampling events), as the frequency of pausing and sampling is proportional to
    the overall execution time of any code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling is not meant only for measuring execution time. Capable profilers
    can provide a view of memory analysis, garbage collection, threads, and more.
    A combination of such tools is helpful to find memory leaks, garbage collection
    issues, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Performance optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simply put, **optimization** is enhancing a program's resource consumption after
    a performance analysis. The symptoms of a poorly performing program are observed
    in terms of high latency, low throughput, unresponsiveness, instability, high
    memory consumption, high CPU consumption, and more. During the performance analysis,
    one may profile the program in order to identify the bottlenecks and tune the
    performance incrementally by observing the performance parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Better and suitable algorithms are an all-around good way to optimize code.
    The CPU bound code can be optimized with computationally cheaper operations. The
    cache bound code can try using less memory lookups to keep a good hit ratio. The
    memory bound code can use an adaptive memory usage and conservative data representation
    to store in memory for optimization. The I/O bound code can attempt to serialize
    as little data as possible, and batching of operations will make the operation
    less chatty for better performance. Parallelism and distribution are other, overall
    good ways to increase performance.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency and parallelism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the computer hardware and operating systems that we use today provide
    concurrency. On the x86 architecture, hardware support for concurrency can be
    traced as far back as the 80286 chip. **Concurrency** is the simultaneous execution
    of more than one process on the same computer. In older processors, concurrency
    was implemented using the context switch by the operating system kernel. When
    concurrent parts are executed in parallel by the hardware instead of merely the
    switching context, it is called **parallelism**. Parallelism is the property of
    the hardware, though the software stack must support it in order for you to leverage
    it in your programs. We must write your program in a concurrent way to exploit
    the parallelism features of the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: While concurrency is a natural way to exploit hardware parallelism and speed
    up operations, it is worth bearing in mind that having significantly higher concurrency
    than the parallelism that your hardware can support is likely to schedule tasks
    to varying processor cores thereby, lowering the branch prediction and increasing
    cache misses.
  prefs: []
  type: TYPE_NORMAL
- en: At a low level, spawning the processes/threads, mutexes, semaphores, locking,
    shared memory, and interprocess communication are used for concurrency. The JVM
    has an excellent support for these concurrency primitives and interthread communication.
    Clojure has both—the low and higher level concurrency primitives that we will
    discuss in the concurrency chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Resource utilization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: R**esource utilization** is the measure of the server, network, and storage
    resources that is consumed by an application. Resources include CPU, memory, disk
    I/O, network I/O, and more. The application can be analyzed in terms of CPU bound,
    memory bound, cache bound, and I/O bound tasks. Resource utilization can be derived
    by means of benchmarking, by measuring the utilization at a given throughput.
  prefs: []
  type: TYPE_NORMAL
- en: Workload
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Workload** is the quantification of how much work is there in hand to be
    carried out by the application. It is measured in the total numbers of users,
    the concurrent active users, the transaction volume, the data volume, and more.
    Processing a workload should take in to account the load conditions, such as how
    much data the database currently holds, how filled up the message queues are,
    the backlog of I/O tasks after which the new load will be processed, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: The latency numbers that every programmer should know
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hardware and software have progressed over the years. Latencies for various
    operations put things in perspective. The latency numbers for the year 2015, reproduced
    with the permission of Aurojit Panda and Colin Scott of Berkeley University ([http://www.eecs.berkeley.edu/~rcs/research/interactive_latency.html](http://www.eecs.berkeley.edu/~rcs/research/interactive_latency.html)).
    Latency numbers that every programmer should know are as shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Time taken as of 2015 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| L1 cache reference | 1ns (nano second) |'
  prefs: []
  type: TYPE_TB
- en: '| Branch mispredict | 3 ns |'
  prefs: []
  type: TYPE_TB
- en: '| L2 cache reference | 4 ns |'
  prefs: []
  type: TYPE_TB
- en: '| Mutex lock/unlock | 17 ns |'
  prefs: []
  type: TYPE_TB
- en: '| Compress 1KB with Zippy(Zippy/Snappy: [http://code.google.com/p/snappy/](http://code.google.com/p/snappy/))
    | 2μs (1000 ns = 1μs: micro second) |'
  prefs: []
  type: TYPE_TB
- en: '| Send 2000 bytes over the commodity network | 200ns (that is, 0.2μs) |'
  prefs: []
  type: TYPE_TB
- en: '| SSD random read | 16 μs |'
  prefs: []
  type: TYPE_TB
- en: '| Round-trip in the same datacenter | 500 μs |'
  prefs: []
  type: TYPE_TB
- en: '| Read 1,000,000 bytes sequentially from SSD | 200 μs |'
  prefs: []
  type: TYPE_TB
- en: '| Disk seek | 4 ms (1000 μs = 1 ms) |'
  prefs: []
  type: TYPE_TB
- en: '| Read 1,000,000 bytes sequentially from disk | 2 ms |'
  prefs: []
  type: TYPE_TB
- en: '| Packet roundtrip CA to Netherlands | 150 ms |'
  prefs: []
  type: TYPE_TB
- en: The preceding table shows the operations in a computer vis-a-vis the latency
    incurred due to the operation. When a CPU core processes some data in a CPU register,
    it may take a few CPU cycles (for reference, a 3 GHz CPU runs 3000 cycles per
    nanosecond), but the moment it has to fall back on L1 or L2 cache, the latency
    becomes thousands of times slower. The preceding table does not show main memory
    access latency, which is roughly 100 ns (it varies, based on the access pattern)—about
    25 times slower than the L2 cache.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned about the basics of what it is like to think more deeply about performance.
    We saw the common performance vocabulary, and also the use cases by which performance
    aspects might vary. We concluded by looking at the performance numbers for the
    different hardware components, which is how performance benefits reach our applications.
    In the next chapter, we will dive into the performance aspects of the various
    Clojure abstractions.
  prefs: []
  type: TYPE_NORMAL
