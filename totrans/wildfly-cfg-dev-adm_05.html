<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Configuring a WildFly Domain"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Configuring a WildFly Domain</h1></div></div></div><p>Now that we have looked at the core configuration of the server, we can move on to the domain configuration. Shaping a server domain is a key task for administrators who want to efficiently coordinate a set of application servers. In this chapter, we will describe all the steps necessary to create and configure a domain of WildFly instances.</p><p>As we will see shortly, the configuration of subsystems does not vary between standalone and domain configuration. To work with domains, we also need to learn about the domain controller and host controller configurations. These are responsible for handling and coordinating the lifecycle of applications across several servers.</p><p>So, in this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introduction to the WildFly domain</li><li class="listitem" style="list-style-type: disc">How to configure the domain components</li><li class="listitem" style="list-style-type: disc">The criteria to choose between a domain and a standalone server</li><li class="listitem" style="list-style-type: disc">Introducing WildFly domain mode</li></ul></div><div class="section" title="Introducing the WildFly domain"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec23"/>Introducing the WildFly domain</h1></div></div></div><p>The concept of a domain mode might be perceived as a little difficult to understand. The reason for this is that in the Java EE paradigm, one is used to dealing with servers rather than domains.</p><p>Basically, a domain is a<a id="id591" class="indexterm"/> group of WildFly servers managed by one of the servers. The server managing the domain is called the domain controller. This group is under one administration—it is the administrative unit. It's important to understand that the concept of a domain does not interfere with the capabilities delivered by the managed servers. For example, you might set up a domain of application server nodes running in a cluster, providing load balancing and high availability. However, you can also achieve the same outcome with a set of standalone application servers.</p><p>What differentiates these two scenarios is that when running in a domain, you can efficiently manage your set of servers from a single, centralized unit. On the other hand, managing a set of<a id="id592" class="indexterm"/> standalone instances often requires sophisticated multiserver management capabilities that are significantly more complex, error-prone, and<a id="id593" class="indexterm"/> time-consuming.</p><p>From the process point of view, a domain is made up of four elements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Domain</strong></span> <span class="strong"><strong>controller</strong></span>: The domain controller is the management control point of your domain. An AS instance running in the domain mode has, at the most, one process<a id="id594" class="indexterm"/> instance acting as a domain controller. The domain controller holds a centralized configuration that is<a id="id595" class="indexterm"/> shared by the node instances belonging to the domain.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Host</strong></span> <span class="strong"><strong>controller</strong></span>: This is a process responsible for coordinating the life cycle of server processes and the<a id="id596" class="indexterm"/> distribution of <a id="id597" class="indexterm"/>deployments, from the domain controller to the server instances, with the domain controller.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Process</strong></span> <span class="strong"><strong>controller</strong></span>: This is a very lightweight process whose primary function is to spawn server and host controller processes, and manage their input/output streams. This also<a id="id598" class="indexterm"/> allows the host controller to be patched and restarted without impacting the associated servers.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Application</strong></span> <span class="strong"><strong>server</strong></span> <span class="strong"><strong>nodes</strong></span>: These are regular Java processes that map to instances of the application <a id="id599" class="indexterm"/>server. Each server node, in turn, belongs to a domain group. Domain groups will be <a id="id600" class="indexterm"/>explained in detail when we discuss the domain configuration file.</li></ul></div><p>In order to understand how to configure these components, we will first look at the basic domain configuration. This configuration is provided with the application server default distribution.</p></div></div>
<div class="section" title="Understanding the default domain configuration"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec24"/>Understanding the default domain configuration</h1></div></div></div><p>Out of the box, the default domain configuration (<code class="literal">domain.xml</code>) includes a basic configuration<a id="id601" class="indexterm"/> made up of the following elements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One process <a id="id602" class="indexterm"/>controller that starts the other JVM processes</li><li class="listitem" style="list-style-type: disc">One host controller that acts as the domain controller</li><li class="listitem" style="list-style-type: disc">Three server nodes, with the first two being part of the main server group and the third one (inactive) as part of the other server group</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>A server group is a group of servers that have the same configuration and are managed as one.</p></div></div><p>The following image reinforces these concepts:</p><div class="mediaobject"><img src="graphics/6232OS_05_01.jpg" alt="Understanding the default domain configuration"/></div><p>You can use<a id="id603" class="indexterm"/> the <code class="literal">VisualVM</code> utility to have a look at the low-level details of your domain from the point of view of the JVM. You can see from the following screenshot that four JVM processes are spawned. The process controller is started first, which, in turn, launches the host controller process and the two server nodes.</p><div class="mediaobject"><img src="graphics/6232OS_05_02.jpg" alt="Understanding the default domain configuration"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>
<span class="strong"><strong>VisualVM</strong></span> is a Java Virtual Machine monitoring tool that is included in the default Java SE distribution. You can find it in your <code class="literal">JAVA_HOME/bin</code> folder. Simply launch <code class="literal">jvisualvm.exe</code> if you are on Windows, or <code class="literal">jvisualvm</code> if you are on Linux.</p></div></div><p>The important<a id="id604" class="indexterm"/> thing to note from the preceding screenshot is that with the basic domain setup, the host controller also acts as the domain controller, that is, the host controller holds the centralized configuration of the domain. This means that the host controller and the domain controller share the same JVM process.</p><p>Having completed a basic introduction to the application server domain, we will now cover all the details concerning its configuration.</p></div>
<div class="section" title="Starting up and stopping a domain"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec25"/>Starting up and stopping a domain</h1></div></div></div><p>Starting<a id="id605" class="indexterm"/> up a WildFly domain is simply a matter of running the <code class="literal">JBOSS_HOME\bin\domain.sh</code> script (<code class="literal">JBOSS_HOME\bin\domain.bat</code> on Windows). In a <a id="id606" class="indexterm"/>matter of seconds, your domain will be up and running. Have a look at the following screenshot:</p><div class="mediaobject"><img src="graphics/6232OS_05_03.jpg" alt="Starting up and stopping a domain"/></div><p>In order to stop the application server domain, you can either use the <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> shortcut in the same<a id="id607" class="indexterm"/> window in which you started the domain, or you can use the command-line client and issue the <code class="literal">shutdown</code> command to the host controller.</p><p>Unix/Linux users can issue the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>./jboss-cli.sh --connect command=/host=master:shutdown</strong></span>
</pre></div><p>Windows users<a id="id608" class="indexterm"/> can issue the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>jboss-cli.bat --connect command=/host=master:shutdown</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>The default host name is <code class="literal">master</code>, and it is defined in the <code class="literal">host.xml</code>, file which is located in the <code class="literal">JBOSS_HOME\domain\configuration</code> folder. We will learn more about it in the next section.</p></div></div><p>Once the domain starts, several log files are created within the <code class="literal">JBOSS_HOME\domain\log</code> directory. The host controller activity is written to the <code class="literal">host-controller.log</code> file, while the process controller logs are written to the <code class="literal">process-controller.log</code> file.</p></div>
<div class="section" title="Configuring the domain"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec26"/>Configuring the domain</h1></div></div></div><p>One of the <a id="id609" class="indexterm"/>main advantages of setting up a WildFly domain is the control over, and management of, the server configurations and deployments from a single centralized point. The main domain configuration consists of the following two files found in the <code class="literal">JBOSS_HOME\domain\configuration</code> folder, which are<a id="id610" class="indexterm"/> as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">domain.xml</code>: This file describes the capabilities of your domain servers and defines the server <a id="id611" class="indexterm"/>groups that are part of the domain. While this file can be found on each host, only the <code class="literal">domain.xml</code> file found on the domain controller is used.</li><li class="listitem" style="list-style-type: disc"><code class="literal">host.xml</code>: This file<a id="id612" class="indexterm"/> is present on each host where the domain is installed and specifies the elements specific to the servers running on the host.</li></ul></div><div class="section" title="Overriding the default configuration files"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec64"/>Overriding the default configuration files</h2></div></div></div><p>It is possible to use configuration files other than the default files that are provided in a vanilla install. You<a id="id613" class="indexterm"/> can use your own custom configuration files by adding the following parameter to your shell command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>./domain.sh --domain-config=custom_domain.xml</strong></span>
<span class="strong"><strong>./domain.sh –host-config=custom_host.xml</strong></span>
</pre></div><p>Windows users<a id="id614" class="indexterm"/> use the same parameter, but obviously use the <code class="literal">domain.bat</code> file.</p><p>Note also that if you don't provide any path to your custom configuration file, it's assumed to be relative to the <code class="literal">jboss.server.config.dir</code> directory. Otherwise, you need to provide an absolute path to your file.</p></div><div class="section" title="Configuring the domain.xml file"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec65"/>Configuring the domain.xml file</h2></div></div></div><p>The <code class="literal">domain.xml</code> file contains the domain subsystems' configuration that is shared by all the servers in the domain. The content of the file follows the structure of the standalone file, with an obvious <a id="id615" class="indexterm"/>and important <a id="id616" class="indexterm"/>difference—a domain can have several profiles defined in it. By default, four profiles are defined: a default profile, a full profile, a ha profile, and lastly, a full-ha profile, with the last two being used for clustered domains. You could also, however, define your own custom profile, such as a messaging profile, as shown in the following image:</p><div class="mediaobject"><img src="graphics/6232OS_05_04.jpg" alt="Configuring the domain.xml file"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip21"/>Tip</h3><p>Changing from one profile to another is the recommended way to expand or narrow the capabilities of the servers running in your domain.</p></div></div><p>Each WildFly<a id="id617" class="indexterm"/> domain can be further split into server groups, with each one bound to a different profile. The concept of server groups can be seen as a set of servers managed as a single unit by the domain. You can actually<a id="id618" class="indexterm"/> use server groups for fine-grained configuration of nodes; for example, each server group is able to define its own settings, such as customized JVM settings, socket bindings interfaces, and deployed applications. The following figure illustrates some common attributes that can be applied to servers within a server group:</p><div class="mediaobject"><img src="graphics/6232OS_05_05.jpg" alt="Configuring the domain.xml file"/></div><p>For example, here is a more complete server group definition that is bound to the <code class="literal">default</code> profile. This<a id="id619" class="indexterm"/> server group defines a web application named <code class="literal">sample.war</code>, which is made available to all servers within<a id="id620" class="indexterm"/> the group. It also defines a customized JVM configuration and some system properties (loaded at boot time), and binds its services to the <code class="literal">standard-sockets</code> definition, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;server-group name="custom-server-group" profile="default"&gt;
  &lt;deployments&gt;
    &lt;deployment name="sample.war_v1" runtime-name="sample.war" /&gt; 
  &lt;/deployments&gt;
  &lt;jvm name="default"&gt;
    &lt;heap size="512m" max-size="1g"/&gt;
  &lt;/jvm&gt;
  &lt;socket-binding-group ref="standard-sockets"/&gt;
  &lt;system-properties&gt;
    &lt;property name="foo" value="bar" boot-time="true"/&gt;
    &lt;property name="key" value="value" boot-time="true"/&gt;
  &lt;/system-properties&gt;
&lt;/server-group&gt;</pre></div></div><div class="section" title="Configuring the host.xml file"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec66"/>Configuring the host.xml file</h2></div></div></div><p>The other domain configuration file is named <code class="literal">host.xml</code>, which is found in the <code class="literal">JBOSS_HOME\domain\configuration</code> folder. This file basically defines and configures the server nodes that are running on a host as part of a domain. The term "host" used here denotes a physical <a id="id621" class="indexterm"/>or virtual host. Within <a id="id622" class="indexterm"/>each host is a portion of the servers from the domain. Each host can have zero or more server instances. The following figure clarifies these details:</p><div class="mediaobject"><img src="graphics/6232OS_05_06.jpg" alt="Configuring the host.xml file"/></div><p>As you can see, a domain can contain several hosts (<span class="strong"><strong>host1</strong></span>, <span class="strong"><strong>host2</strong></span>) and also several groups (<span class="strong"><strong>main server group</strong></span>, <span class="strong"><strong>other server group</strong></span>). However, while a <a id="id623" class="indexterm"/>
<span class="strong"><strong>server group</strong></span> is a logical association of server nodes (which can be located anywhere), a <span class="strong"><strong>host</strong></span> refers<a id="id624" class="indexterm"/> to a set of nodes that are located on the same physical or virtual machine. Having provided our definition of hosts, we now look into the host configuration file, which allows you to shape the following set of core domain elements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The management interfaces used to control the domain</li><li class="listitem" style="list-style-type: disc">The domain controller definition</li><li class="listitem" style="list-style-type: disc">The network interfaces where services are bound</li><li class="listitem" style="list-style-type: disc">The defined JVM's configurations</li><li class="listitem" style="list-style-type: disc">The servers that are part of the domain</li></ul></div><p>In the next <a id="id625" class="indexterm"/>section, we will see each element<a id="id626" class="indexterm"/> of the <code class="literal">host.xml</code> file in detail and learn how to configure it appropriately.</p></div><div class="section" title="Configuring the management interfaces"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec67"/>Configuring the management interfaces</h2></div></div></div><p>The management<a id="id627" class="indexterm"/> interface includes the definition of the native <a id="id628" class="indexterm"/>
<span class="strong"><strong>command-line</strong></span> <span class="strong"><strong>interface</strong></span> (<span class="strong"><strong>CLI</strong></span>) and <code class="literal">http</code> interface that are used to<a id="id629" class="indexterm"/> manage the domain. The following example has been taken from the <code class="literal">host.xml</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;management-interfaces&gt;
    &lt;native-interface security-realm="ManagementRealm"&gt;
        &lt;socket interface="management" port="9999"/&gt;
    &lt;/native-interface&gt;
    &lt;http-interface security-realm="ManagementRealm" http-upgrade-enabled="true"&gt;
        &lt;socket interface="management" port="9990"/&gt;
    &lt;/http-interface&gt;
&lt;/management-interfaces&gt;</pre></div><p>With the default configuration, both services are bound to the <code class="literal">management</code> network interfaces. The CLI and administrative interface listen on port <code class="literal">9990</code>. The <code class="literal">native</code> interface configuration remains should you, for some reason, want to revert back to JBoss AS 7 settings and run on port number <code class="literal">9999</code>.</p></div><div class="section" title="Configuring the network interfaces"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec68"/>Configuring the network interfaces</h2></div></div></div><p>We have just mentioned <code class="literal">network</code> interfaces. As you can guess from its<a id="id630" class="indexterm"/> name, a <span class="strong"><strong>network interface</strong></span> refers to one network address or a set of network addresses. By default, the server contains three<a id="id631" class="indexterm"/> network interface<a id="id632" class="indexterm"/> definitions, namely, <span class="strong"><strong>management</strong></span>, <span class="strong"><strong>public</strong></span>, and <a id="id633" class="indexterm"/>
<span class="strong"><strong>unsecure</strong></span>, all of which are bound to the loopback<a id="id634" class="indexterm"/> address (<code class="literal">127.0.0.1</code>).</p><p>By changing<a id="id635" class="indexterm"/> the <code class="literal">inet-address</code> value of your network interface, you can configure the listening addresses of your application server. For example, if we want to bind the <code class="literal">management</code> interfaces to the loopback address (<code class="literal">127.0.0.1</code>), and the <code class="literal">public</code> interface to the address <code class="literal">192.168.1.1</code>, you can simply use the following configuration:</p><div class="informalexample"><pre class="programlisting">&lt;interfaces&gt;
<span class="strong"><strong>    &lt;interface name="management"&gt;</strong></span>
        &lt;inet-address value="127.0.0.1"/&gt;
    &lt;/interface&gt;
<span class="strong"><strong>    &lt;interface name="public"&gt;</strong></span>
        &lt;inet-address value="192.168.1.1"/&gt;
    &lt;/interface&gt;
&lt;/interfaces&gt;</pre></div><p>You can also update these properties via the command line by running the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[standalone@localhost:9990 /] /interface=management:write-attribute(name=inet-address,value=127.0.0.1)</strong></span>
<span class="strong"><strong>[standalone@localhost:9990 /] /interface=public:write-attribute(name=inet-address,value=192.168.1.1)</strong></span>
</pre></div><p>In practice, this<a id="id636" class="indexterm"/> means that the <code class="literal">management</code> interfaces (the <code class="literal">http</code> admin console and the CLI) will be bound to the loopback address, while application-related services (bound to the <code class="literal">public</code> interface) will be bound to the IP<a id="id637" class="indexterm"/> address <code class="literal">192.168.1.1</code>. The following configuration is taken from the <code class="literal">domain.xml</code> file. Here, you can see how it uses the <code class="literal">public</code> interface defined previously:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;socket-binding-group name="standard-sockets" default-interface="public"&gt;</strong></span>
  &lt;socket-binding name="http" port="8080"/&gt;
  &lt;socket-binding name="https" port="8443"/&gt;
  ...
&lt;/socket-binding-group&gt;</pre></div></div><div class="section" title="Configuring the domain controller"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec69"/>Configuring the domain controller</h2></div></div></div><p>By default, the domain <a id="id638" class="indexterm"/>controller is located on the same machine where you started your domain. Have a look at the following<a id="id639" class="indexterm"/> commands:</p><div class="informalexample"><pre class="programlisting">&lt;domain-controller&gt;
  &lt;local/&gt;
&lt;/domain-controller&gt;</pre></div><p>You can, however, configure your host to use a domain controller located on a remote host in the following way:</p><div class="informalexample"><pre class="programlisting">&lt;domain-controller&gt;
  &lt;remote <span class="strong"><strong>host="192.168.100.1" port="9999"</strong></span> security-realm="ManagementRealm"/&gt;
&lt;/domain-controller&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>This doesn't work if the management interface is bound to <code class="literal">localhost</code>. Ensure that you update the management interface correctly.</p></div></div><p>Configuring the domain controller on a remote host means that the local configuration (<code class="literal">domain.xml</code>) will not be used, and that all server nodes on that host will use the centralized remote<a id="id640" class="indexterm"/> configuration. You need authorization to access the domain controller. We will cover the details of this in the domain example toward the end of the chapter.</p></div><div class="section" title="Configuring the JVM"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec70"/>Configuring the JVM</h2></div></div></div><p>One of the key aspects of the domain configuration is the definition of JVM arguments for a given host. The JVM's elements<a id="id641" class="indexterm"/> are defined in<a id="id642" class="indexterm"/> the <code class="literal">host.xml</code> file. Here, you can define JVM settings and associate them with a name:</p><div class="informalexample"><pre class="programlisting">&lt;jvms&gt; 
    &lt;permgen size="256m" max-size="256m"/&gt; 
    &lt;jvm-options&gt; 
      &lt;option value="-server"/&gt; 
    &lt;/jvm-options&gt; 
&lt;/jvms&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip22"/>Tip</h3><p>Currently, there is no element available to configure Java 8 Metaspace properties. To configure these, you need to add them as <code class="literal">option</code> elements. To set the initial size, use <code class="literal">-XX:MetaspaceSize=256m</code>, and to set the maximum size, use <code class="literal">-XX:MaxMetaspaceSize=256m</code>.</p></div></div><p>This JVM definition can then be used as part of your server group configuration by referencing the <code class="literal">jvm</code> name property in your <code class="literal">server-group</code> configuration. Also note that any JVM definitions within the <code class="literal">server-group</code> overrides those in the <code class="literal">jvms</code> definition. For example, the <code class="literal">main-server-group</code> (<code class="literal">domain.xml</code>) server group uses the <code class="literal">default</code> JVM for all server nodes, but redefines the <code class="literal">heap max-size</code> and <code class="literal">size</code> values. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;server-group name="main-server-group" profile="full"&gt;
  <span class="strong"><strong>&lt;jvm name="default"&gt;</strong></span>
    <span class="strong"><strong>&lt;heap size="64m" max-size="512m"/&gt;</strong></span>
  <span class="strong"><strong>&lt;/jvm&gt;</strong></span>
  &lt;socket-binding-group ref="full-sockets"/&gt;
&lt;/server-group&gt;</pre></div><p>The defined JVMs can be also be associated with a single server, thus overriding the server group definition. For example, here, <code class="literal">server-one</code> (defined in <code class="literal">host.xml</code>) inherits the <code class="literal">default</code> JVM configuration but then overrides the minimum (512 MB) and maximum heap size (1 GB):</p><div class="informalexample"><pre class="programlisting">&lt;server name="server-one" group="main-server-group" auto-start="true"&gt;
  <span class="strong"><strong>&lt;jvm name="default"&gt;</strong></span>
    <span class="strong"><strong>&lt;heap size="512m" max-size="1G"/&gt;</strong></span>
  <span class="strong"><strong>&lt;/jvm&gt;</strong></span>
&lt;/server&gt;</pre></div><div class="section" title="Adding JVM options to a server definition"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec41"/>Adding JVM options to a server definition</h3></div></div></div><p>If you want to further specialize your JVM configuration, for example, by adding nonstandard<a id="id643" class="indexterm"/> options to the virtual machine, you can<a id="id644" class="indexterm"/> use the <code class="literal">jvm-options</code> element (<code class="literal">host.xml</code>). In this example, we add the concurrent, low-pause garbage collector to the <code class="literal">default</code> JVM options:</p><div class="informalexample"><pre class="programlisting">&lt;jvms&gt;
    &lt;jvm name="default"&gt;
        &lt;heap size="64m" max-size="128m"/&gt;
        <span class="strong"><strong>&lt;jvm-options&gt;</strong></span>
            <span class="strong"><strong>&lt;jvm-option value="-XX:+UseConcMarkSweepGC"/&gt;</strong></span>
        <span class="strong"><strong>&lt;/jvm-options&gt;</strong></span>
    &lt;/jvm&gt;
&lt;/jvms&gt;</pre></div></div><div class="section" title="Order of precedence between elements"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec42"/>Order of precedence between elements</h3></div></div></div><p>In the previous section, we showed you how to use the <code class="literal">default</code> JVM definition in the different configuration files (<code class="literal">host.xml</code> and <code class="literal">domain.xml</code>). As a matter of fact, the JVM definition is a typical<a id="id645" class="indexterm"/> example of a configuration that overlaps between files, which means that the JVM can be configured at any one of the following levels:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Host level</strong></span>: This configuration<a id="id646" class="indexterm"/> will apply to all servers that are defined in <code class="literal">host.xml</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Server-group level</strong></span>: This<a id="id647" class="indexterm"/> configuration applies to all servers that are part of the group</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Server level</strong></span>: This configuration<a id="id648" class="indexterm"/> is used just for a single host</li></ul></div><p>So far, so good. However, what happens if we define an element with the same name at multiple levels? The application server resolves this by letting most specific elements override their parent configuration. In other words, if you define a generic JVM at the host level, it is overridden by the same JVM at the server-group level. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;!-- host.xml --&gt;
&lt;jvms&gt;
  &lt;jvm name="default"&gt;
    &lt;heap size="64m" max-size="256m"/&gt;
  &lt;/jvm&gt;
&lt;/jvms&gt;

&lt;!—- domain.xml --&gt;

&lt;!—- Here the "default" jvm will be overridden by the server group jvm definition --&gt;

&lt;server-group name="other-server-group" profile="default"&gt;
  <span class="strong"><strong>&lt;jvm name="default"&gt;</strong></span>
    <span class="strong"><strong>&lt;heap size="64m" max-size="512m"/&gt;</strong></span>
  <span class="strong"><strong>&lt;/jvm&gt;</strong></span>
  &lt;socket-binding-group ref="standard-sockets"/&gt;
&lt;/server-group&gt;</pre></div><p>If you also define<a id="id649" class="indexterm"/> it at the server level, then that is the final choice for that server. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;!- Here, the server definition overrides any other host/group definition --&gt;
&lt;server name="server-one" group="main-server-group"&gt;
  <span class="strong"><strong>&lt;jvm name="default"&gt;</strong></span>
    <span class="strong"><strong>&lt;heap size="256m" max-size="768m"/&gt;</strong></span>
  <span class="strong"><strong>&lt;/jvm&gt;</strong></span>
&lt;/server&gt;</pre></div><p>The following figure describes the elements that can be defined (and possibly overridden) at different configuration levels:</p><div class="mediaobject"><img src="graphics/6232OS_05_07.jpg" alt="Order of precedence between elements"/></div><p>As you can see, this list also includes some elements, such as the <code class="literal">&lt;path&gt;</code> element, the <code class="literal">&lt;interface&gt;</code> element, and the <code class="literal">&lt;system-properties&gt;</code> element, which we have discussed in <a class="link" href="ch02.html" title="Chapter 2. Configuring the Core WildFly Subsystems">Chapter 2</a>, <span class="emphasis"><em>Configuring the Core WildFly Subsystems</em></span>.</p></div><div class="section" title="Configuring server nodes"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec43"/>Configuring server nodes</h3></div></div></div><p>The last element of the<a id="id650" class="indexterm"/> host configuration includes the list of server nodes that are part of the domain. Configuring a server requires, at minimum, the<a id="id651" class="indexterm"/> name of the server and the group to which the server belongs. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;!-- host.xml configuration file --&gt;
&lt;servers&gt;
  &lt;server name="server-one" group="main-server-group" /&gt;
&lt;/servers&gt;</pre></div><p>This server definition relies largely on default attributes for the application server nodes. You can, however, highly customize your servers by adding specific paths, socket-binding interfaces, system properties, and JVMs. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;server auto-start="true" name="sample" group="sample-group" &gt;
  &lt;paths&gt;
    &lt;path name="example" path="example" relative-to="jboss.server.log.dir"/&gt;
  &lt;/paths&gt;
  &lt;socket-bindings port-offset="259" socket-binding-group="standard-sockets" /&gt;
  &lt;system-properties&gt;
    &lt;property boot-time="true" name="envVar" value="12345"/&gt;
  &lt;/system-properties&gt;
  &lt;jvm name="default"&gt;
    &lt;heap size="256m" max-size="512m"/&gt;
  &lt;/jvm&gt;
&lt;/server&gt;</pre></div><p>If you want to know all the applicable attributes of the server nodes' configuration, we suggest that you have a look at the <code class="literal">jboss-as-config_2_1.xsd</code> schema, which is located in the <code class="literal">JBOSS_HOME/docs/schema</code> folder of your server distribution. In Eclipse, you can right-click on<a id="id652" class="indexterm"/> the schema file and then click on <span class="strong"><strong>Generate</strong></span> | <span class="strong"><strong>XML File</strong></span>.</p></div></div><div class="section" title="Applying domain configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec71"/>Applying domain configuration</h2></div></div></div><p>A common<a id="id653" class="indexterm"/> misconception among users who are new to the concept of a domain is that a domain is pretty much the equivalent of a cluster of nodes, so it can be used to achieve important features, such as load balancing and high availability.</p><p>It's important to understand that a domain is not pertinent to the functionalities that your application delivers—a domain is designed around the concept of server management. Thus, you can use it to manage both clustered applications and applications that are not intended to run<a id="id654" class="indexterm"/> in a cluster.</p><p>To understand it better, let's give an example. Let's consider that your server topology consists of multiple servers, and that you have defined a datasource that will be used by your application. So, whether or not you use a cluster, you need to configure your datasource across all your standalone servers' configurations (this means adding the definition of the datasource in every <code class="literal">standalone.xml</code>) file. In this case, the advantage of using a domain is evident: the datasource definition is contained just in the domain controller that provides a central point through which users can keep configurations consistent. It <a id="id655" class="indexterm"/>also has the benefit of being able to roll out configuration changes to the servers in a coordinated fashion. One other important aspect of a domain is the ability to provide a more fine-grained configuration than clustering is able to. For example, you can define server groups, each one with its own custom configuration. In order to achieve the same thing with a clustered configuration, you have to manage each machine's standalone configuration and adapt it to your needs.</p><p>However, domain and clustering are not mutually exclusive scenarios, but are often part of a larger picture. For example, using a domain can further enhance the efficiency of a cluster in advanced configurations where you need to manage starting and stopping multiple AS instances. At the same time, clustering provides typical load balancing and high-availability features, which are not integrated into domain management.</p><p>On the other hand, there are situations where using a domain may not prove to be that useful. For example, it's possible that your system administrators have bought or developed their own sophisticated multiserver management tools that can do more or less the same things that a domain configuration is able to do. In this situation, it may not be desirable to switch out what is already configured ad hoc.</p><p>Another classic example where a domain is not needed is the development phase, where you don't gain anything from a domain installation. Rather, it may add an unneeded additional complexity to your architecture.</p><p>Furthermore, the standalone<a id="id656" class="indexterm"/> mode is the only choice available in some scenarios. For example, if you are running the application server in the embedded mode, then the choice of a domain is incompatible. For example, when using an Arquillian project, you can test your Enterprise projects using an embedded container, which is managed by Arquillian using a standalone configuration.</p><p>Summing it up, since the individual server configuration does not vary when running the domain mode or the standalone mode, you can easily develop your application in the standalone mode and then switch to the domain mode when you are about to roll out the production application.</p></div></div>
<div class="section" title="Creating our very own domain configuration"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec27"/>Creating our very own domain configuration</h1></div></div></div><p>We will now provide a detailed example of a domain configuration. In this example, we include two separate host controller configurations, each one with a list of three nodes. You need two<a id="id657" class="indexterm"/> separate installations of WildFly 8, which can be executed on either two different machines or on the same machine. When running on the same machine, it's practical to assign a virtual IP address to your machines so that you don't have any port conflict in your domain.</p><p>The following figure shows our domain project:</p><div class="mediaobject"><img src="graphics/6232OS_05_08.jpg" alt="Creating our very own domain configuration"/></div><p>The first thing we need to do is bind the network interfaces to a valid <code class="literal">inet</code> address, both for the public<a id="id658" class="indexterm"/> and management interfaces. So, assuming that the first domain installation (master) will be bound to the <code class="literal">inet</code> address <code class="literal">192.168.1.1</code>, open the <code class="literal">host.xml</code> file and change it accordingly, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;interfaces&gt;
    &lt;interface name="management"&gt;
        <span class="strong"><strong>&lt;inet-address value="192.168.1.1"/&gt;</strong></span>
    &lt;/interface&gt;
    &lt;interface name="public"&gt;
        <span class="strong"><strong>&lt;inet-address value="192.168.1.1"/&gt;</strong></span>
    &lt;/interface&gt;
&lt;/interfaces&gt;</pre></div><p>In the second domain installation (slave), change the <code class="literal">inet</code> address to <code class="literal">192.168.1.2</code> in <code class="literal">host.xml</code>, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;interfaces&gt;
    &lt;interface name="management"&gt;
<span class="strong"><strong>        &lt;inet-address value="192.168.1.2"/&gt;</strong></span>
    &lt;/interface&gt;
    &lt;interface name="public"&gt;
<span class="strong"><strong>        &lt;inet-address value="192.168.1.2"/&gt;</strong></span>
    &lt;/interface&gt;
&lt;/interfaces&gt;</pre></div><p>The next thing to do is define a unique host name for each installation. So, for the first <code class="literal">host.xml</code> file, use the following code:</p><div class="informalexample"><pre class="programlisting">&lt;host name="master"/&gt;</pre></div><p>For the second file, simply use:</p><div class="informalexample"><pre class="programlisting">&lt;host name="slave"/&gt;</pre></div><p>Next, the most important step is to choose where the domain controller is located. As we have shown earlier in the image, the domain controller will be located in the first installation (master), so in the <code class="literal">host.xml</code> file, you should contain the default content:</p><div class="informalexample"><pre class="programlisting">&lt;domain-controller&gt;
<span class="strong"><strong>  &lt;local/&gt;</strong></span>
&lt;/domain-controller&gt;</pre></div><p>Now, looking at the other installation (slave), point to the domain controller that is running on host<code class="literal"> 192.168.1.1</code> (master), as follows:</p><div class="informalexample"><pre class="programlisting">&lt;domain-controller&gt;
<span class="strong"><strong>  &lt;remote host="192.168.1.1" port="9999"/&gt;</strong></span>
&lt;/domain-controller&gt;</pre></div><p>Authentication is required for the slave to connect to the domain controller, so next we will add a user to the installation housing the master domain. To do this, you need to run the <code class="literal">add-user</code> script in the <code class="literal">bin</code> directory of your WildFly installation, as follows:</p><div class="informalexample"><pre class="programlisting">JBOSS_HOME/bin/add-user.sh</pre></div><p>Perform the<a id="id659" class="indexterm"/> following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">When asked <span class="strong"><strong>What type of user do you wish to add?</strong></span>, enter <code class="literal">a</code> (management user).</li><li class="listitem">When asked for a username, enter <code class="literal">slave</code>.</li><li class="listitem">When asked for a password, enter <code class="literal">password</code>.</li><li class="listitem">When asked <span class="strong"><strong>What groups do you want this user to belong to?</strong></span>, leave it blank.</li><li class="listitem">Next, you will be asked if this is correct. Type <code class="literal">yes</code>.</li><li class="listitem">Lastly, and most importantly, you will be asked if you want this new user to be used for one AS process to connect to another AS process. You need to type <code class="literal">yes</code> again. This will cause XML to be printed out, which we will use in the slave configuration:</li></ol></div><div class="mediaobject"><img src="graphics/6232OS_05_09.jpg" alt="Creating our very own domain configuration"/></div><p>Lastly, on the slave server, we need to add the <code class="literal">secret value</code> (printed out to the console) within the <code class="literal">server-identities</code> element in the <code class="literal">host.xml</code> file, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;security-realm name="ManagementRealm"&gt;
    &lt;server-identities&gt;
        &lt;<span class="strong"><strong>secret value="YXNkZg==" /&gt;</strong></span>
    &lt;/server-identities&gt;
    ...
&lt;/security-realm&gt;</pre></div><p>The domain configuration is now complete. Let's start up the installation containing the domain controller (master) and then the second installation (slave) using the <code class="literal">domain.bat/domain.sh</code> scripts.</p><p>If everything is correctly configured, you will see the slave host registered on the domain controller (master), as follows:</p><div class="mediaobject"><img src="graphics/6232OS_05_10.jpg" alt="Creating our very own domain configuration"/></div><p>Now, let's have a look at the domain from the management console. The management interfaces are discussed in detail in the next chapter, but we need to briefly look at them for the purpose<a id="id660" class="indexterm"/> of showing our domain example.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip23"/>Tip</h3><p>By default, you need to create one management user to be able to log in to the management console. For now, you can just use the username and password you created for the slave server, but in production, you would most likely create a different management user.</p></div></div><p>If you point the browser to the management interface of your master server (<code class="literal">http://192.168.1.1:9990</code>), you will not be able to access the management interface of your slave servers.</p><p>From the main page of the management console, there are a couple of options in which to look at your domain configuration. At this point, we are interested in looking at the host controllers that make up the domain. So, in the top menu bar, select the <span class="strong"><strong>Domain</strong></span> menu. From here, you can select the host you are interested in from the combobox located on the left-hand side.</p><p>As you can see, you can find all servers grouped by the host, as follows:</p><div class="mediaobject"><img src="graphics/6232OS_05_11.jpg" alt="Creating our very own domain configuration"/></div><p>Now, select <span class="strong"><strong>Runtime</strong></span> from the menu. From here, you can view the status of each server, group them by server-group, and start/stop each node. For example, as per the default configuration, each distribution contains three nodes: two are activated at startup, while the third<a id="id661" class="indexterm"/> one is started on demand. Hover your mouse over each node, and options will appear allowing you to start/stop the single node. You can also start/stop an entire server-group. Also, note that there is an option to change the host currently being viewed, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6232OS_05_12.jpg" alt="Creating our very own domain configuration"/></div><p>It should be clear now that each host has its own list of nodes, all of which are part of the domain. Also, remember that each host depends on the configuration defined in the <code class="literal">profiles</code> section of <code class="literal">domain.xml</code> that contains the domain profile used by your domain. As mentioned earlier, one of the most evident advantages of a domain over individual installation is the ability to centralize the services' configuration as well as the deployed resources.</p><p>From within the<a id="id662" class="indexterm"/> web console, you can also deploy applications or install modules such as JDBC drivers. In the next chapter, we will discuss in depth how to deploy and install a module to a domain. The main difference between the domain mode and the standalone mode is that once the datasource is added to the domain controller (<code class="literal">master</code>), its definition becomes part of the default profile, and every host that connects to the domain inherits its configuration.</p><p>Have a look at the following screenshot:</p><div class="mediaobject"><img src="graphics/6232OS_05_13.jpg" alt="Creating our very own domain configuration"/></div><div class="section" title="Changing the domain configuration at runtime"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec72"/>Changing the domain configuration at runtime</h2></div></div></div><p>So far, we have<a id="id663" class="indexterm"/> modified the configuration files before starting the domain, but it is also possible to change the configuration on the fly while the domain is running. These changes will be made active without the need to restart the server, as they are done via the management console. For example, you may need to create, on the fly, a new server group and associate some servers and applications with it. It could be that one of your production applications has an issue that needs to be fixed. You could try to reproduce the issue on a development environment, but your results may not always be accurate since development and production often use different database and class versions.</p><p>So, one way<a id="id664" class="indexterm"/> you can quickly resolve the issue is by creating a new server group, associating one or more servers with it, and then deploying and testing the application on it.</p><p>This can be done using the admin console (or the CLI) in a matter of minutes. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open your browser, and navigate to the admin console. Then, select the <span class="strong"><strong>Domain</strong></span> menu option at the top. From there, choose the <span class="strong"><strong>Server Groups</strong></span> tab in the left-hand side column. This interface lets you add server groups by clicking on the <span class="strong"><strong>Add</strong></span> button, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/6232OS_05_14.jpg" alt="Changing the domain configuration at runtime"/></div></li><li class="listitem">Then, choose a meaningful name for your group, for example, <code class="literal">staging-server-group</code>, and select a <span class="strong"><strong>Profile</strong></span> and <span class="strong"><strong>Socket Binding</strong></span> configuration on which the new group will be based, as follows:<div class="mediaobject"><img src="graphics/6232OS_05_15.jpg" alt="Changing the domain configuration at runtime"/></div></li><li class="listitem">Now, it's time to<a id="id665" class="indexterm"/> associate one or more servers with the new group. Click on the <span class="strong"><strong>Server Configuration</strong></span> menu on the left-hand side, and then click the <span class="strong"><strong>Add</strong></span> button. Have a look at the following screenshot:<div class="mediaobject"><img src="graphics/6232OS_05_16.jpg" alt="Changing the domain configuration at runtime"/></div></li><li class="listitem">This pops up a dialog box that asks you for the new server name and the associated server group. In this example, we are going to call it <code class="literal">testServer</code>. Then, associate it with the <code class="literal">staging-server-group</code> with a port offset of <code class="literal">750</code> (in practice, every service is bound to a port of default port address (+ <code class="literal">750</code>)). Have a  look at the following screenshot:<div class="mediaobject"><img src="graphics/6232OS_05_17.jpg" alt="Changing the domain configuration at runtime"/></div></li></ol></div><p>Once you have<a id="id666" class="indexterm"/> set up a new server group and assigned one or more servers to it, you can deploy your applications to the server group. Deployment of applications can be done from the <span class="strong"><strong>Runtime</strong></span> page. Click on <span class="strong"><strong>Manage Deployments</strong></span> on the left-hand side, which shows you what applications, if any, are deployed. Have a look at the following screenshot:</p><div class="mediaobject"><img src="graphics/6232OS_05_18.jpg" alt="Changing the domain configuration at runtime"/></div><p>From here, you can add and remove deployments to your groups, which we will cover in the next chapter.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Summary</h1></div></div></div><p>In this chapter, we went through the WildFly domain setup and configuration. By configuring a server domain, you can manage your servers from a single centralized point, which is desirable when you have to administer a large set of server nodes.</p><p>Every domain is composed of four main elements: the domain controller, the host controller, the process controller, and the server.</p><p>The domain controller handles the domain configuration, while the host controller coordinates the life cycle of server processes and the distribution of deployments. The process controller handles the domain server processes and manages their I/O streams.</p><p>Every domain is made up of one or more server groups, which allows fine-grained configuration of the domain. Each server group can define its own JVM attributes, socket binding interfaces, and system properties, which are loaded at startup. You can also deploy applications to each of the nodes within the domain.</p><p>Server groups are defined in the <code class="literal">domain.xml</code> configuration file, along with the enterprise services enabled for the domain.</p><p>The composition of server groups is contained in the <code class="literal">host.xml</code> file. This file also contains the location of the domain controller, the default JVMs, and <code class="literal">network</code> and <code class="literal">management</code> interfaces.</p><p>We are going to cover application deployment in detail in the next chapter, <span class="emphasis"><em>Application Structure and Deployment</em></span>.</p></div></body></html>