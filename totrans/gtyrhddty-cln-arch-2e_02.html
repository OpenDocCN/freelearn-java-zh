<html><head></head><body>
<div class="IMG---Figure" id="_idContainer016">
<h1 class="hapter-number" id="_idParaDest-21"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-22"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.2.1">What’s Wrong with Layers?</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Chances are that you have developed a layered (web) application in the past. </span><span class="koboSpan" id="kobo.3.2">You might even be doing it in your current project </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">right now.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Thinking in layers</span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.6.1"> has been drilled into us in computer science classes, tutorials, and best practices. </span><span class="koboSpan" id="kobo.6.2">It has even </span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.7.1">been taught </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">in books.</span></span><span class="No-Break"><span id="footnote-011-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-011"><span class="koboSpan" id="kobo.9.1">1</span></a></span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-011">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-011-backlink"><span class="koboSpan" id="kobo.10.1">1</span></a><span class="koboSpan" id="kobo.11.1">	Layers as a pattern are, for example, taught in </span><em class="itali"><span class="koboSpan" id="kobo.12.1">Software Architecture Patterns</span></em><span class="koboSpan" id="kobo.13.1"> by Mark Richards, </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">O'Reilly, 2015.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.15.1"><img alt="Figure 2.1 – A conventional web application architecture consists of a web layer, a domain layer, and a persistence layer" src="image/Figure_02.1_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.16.1">Figure 2.1 – A conventional web application architecture consists of a web layer, a domain layer, and a persistence layer</span></p>
<p><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.17.1">Figure 2</span></em></span><em class="itali"><span class="koboSpan" id="kobo.18.1">.1</span></em><span class="koboSpan" id="kobo.19.1"> shows a high-level view of the very common three-layer architecture. </span><span class="koboSpan" id="kobo.19.2">We have a </span><strong class="bold"><span class="koboSpan" id="kobo.20.1">web layer</span></strong><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.21.1"> that receives requests and routes them to a service in the </span><a id="_idIndexMarker026"/><strong class="bold"><span class="koboSpan" id="kobo.22.1">domain layer</span></strong><span class="koboSpan" id="kobo.23.1">.</span><span id="footnote-010-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-010"><span class="koboSpan" id="kobo.24.1">2</span></a></span><span class="koboSpan" id="kobo.25.1"> The service does some business logic and calls components from the </span><strong class="bold"><span class="koboSpan" id="kobo.26.1">persistence layer</span></strong><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.27.1"> to query for or modify the current state of our domain entities in </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">the database.</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-010">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-010-backlink"><span class="koboSpan" id="kobo.29.1">2</span></a><span class="koboSpan" id="kobo.30.1">	Domain versus business: in this book, I use the terms “domain” and “business” synonymously. </span><span class="koboSpan" id="kobo.30.2">The domain layer or business layer is the place in the code that solves the business problems, as opposed to code that solves technical problems, like persisting things in a database or processing </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">web requests.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.32.1">You know what? </span><span class="koboSpan" id="kobo.32.2">Layers </span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.33.1">are a solid architecture pattern! </span><span class="koboSpan" id="kobo.33.2">If we get them right, we’re able to build domain logic that is independent of the web and persistence layers. </span><span class="koboSpan" id="kobo.33.3">We can switch out the web or persistence technologies without affecting our domain logic, if the need arises. </span><span class="koboSpan" id="kobo.33.4">We can also add new features without affecting </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">existing features.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">With a good layered architecture, we’re keeping our options open and are able to quickly adapt to changing requirements and external factors (such as our database vendor doubling their prices overnight). </span><span class="koboSpan" id="kobo.35.2">A good layered architecture </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">is maintainable.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">So, what’s wrong </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">with layers?</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">In my experience, a layered architecture</span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.40.1"> is very vulnerable to changes, which makes it hard to maintain. </span><span class="koboSpan" id="kobo.40.2">It allows bad dependencies to creep in and make the software increasingly harder to change over time. </span><span class="koboSpan" id="kobo.40.3">Layers don’t provide enough guardrails to keep the architecture on track. </span><span class="koboSpan" id="kobo.40.4">We need to rely too much on human discipline and diligence to keep </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">it maintainable.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">In the following sections, I’ll tell </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">you why.</span></span></p>
<h1 id="_idParaDest-23"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.44.1">They promote database-driven design</span></h1>
<p><span class="koboSpan" id="kobo.45.1">By its very </span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.46.1">definition, the foundation of a conventional layered architecture is the database. </span><span class="koboSpan" id="kobo.46.2">The web layer depends on the domain layer, which in turn depends on the persistence layer and thus the database. </span><span class="koboSpan" id="kobo.46.3">Everything builds on top of the persistence layer. </span><span class="koboSpan" id="kobo.46.4">This is problematic for </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">several reasons.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">Let’s take a step back and think about what we’re trying to achieve with almost any application we’re building. </span><span class="koboSpan" id="kobo.48.2">We’re typically trying to create a model of the rules or “policies” that govern the business in order to make it easier for the users to interact </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">with them.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">We’re primarily trying to model behavior, not the state. </span><span class="koboSpan" id="kobo.50.2">Yes, the state is an important part of any application, but the behavior is what changes the state and thus drives </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">the business!</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">So, why are we making the database the foundation of our architecture and not the </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">domain logic?</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">Think back to the last use cases you implemented in any application. </span><span class="koboSpan" id="kobo.54.2">Did you start by implementing the domain logic or the persistence layer? </span><span class="koboSpan" id="kobo.54.3">Most likely, you thought about what the database structure would look like and only then moved on to implementing the domain logic on top </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">of it.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">This makes sense in a conventional layered architecture since we’re going with the natural flow of dependencies. </span><span class="koboSpan" id="kobo.56.2">But it makes absolutely no sense from a business point of view! </span><span class="koboSpan" id="kobo.56.3">We should build the domain logic before building anything else! </span><span class="koboSpan" id="kobo.56.4">We want to find out whether we have understood the business rules correctly. </span><span class="koboSpan" id="kobo.56.5">And only once we know we’re building the right domain logic should we move on to build a persistence and web layer </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">around it.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">A driving force in such a </span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.59.1">database-centric architecture is the</span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.60.1"> use of </span><strong class="bold"><span class="koboSpan" id="kobo.61.1">object-relational mapping</span></strong><span class="koboSpan" id="kobo.62.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.63.1">ORM</span></strong><span class="koboSpan" id="kobo.64.1">) frameworks. </span><span class="koboSpan" id="kobo.64.2">Don’t get me wrong, I love those frameworks and work with them regularly. </span><span class="koboSpan" id="kobo.64.3">But if we combine an ORM framework with a layered architecture, we’re easily tempted to mix business rules with </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">persistence aspects.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.66.1"><img alt="Figure 2.2 – Using the database entities in the domain layer leads to strong coupling with the persistence layer" src="image/Figure_02.2_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.67.1">Figure 2.2 – Using the database entities in the domain layer leads to strong coupling with the persistence layer</span></p>
<p><span class="koboSpan" id="kobo.68.1">Usually, we have ORM-managed entities as part of the persistence layer, as shown in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.69.1">Figure 2</span></em></span><em class="itali"><span class="koboSpan" id="kobo.70.1">.2</span></em><span class="koboSpan" id="kobo.71.1">. </span><span class="koboSpan" id="kobo.71.2">Since a layer may access the layers below it, the domain layer is allowed to access those entities. </span><span class="koboSpan" id="kobo.71.3">And if it’s allowed to use them, it will use them at </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">some point.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">This creates a strong coupling between the domain layer and the persistence layer. </span><span class="koboSpan" id="kobo.73.2">Our business services use the persistence model as their business model and have to deal not only with the domain logic but also with eager versus lazy loading, database transactions, flushing caches, and similar </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">housekeeping tasks.</span></span><span class="No-Break"><span id="footnote-009-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-009"><span class="koboSpan" id="kobo.75.1">3</span></a></span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-009">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-009-backlink"><span class="koboSpan" id="kobo.76.1">3</span></a><span class="koboSpan" id="kobo.77.1">	In his seminal book </span><em class="itali"><span class="koboSpan" id="kobo.78.1">Refactoring</span></em><span class="koboSpan" id="kobo.79.1"> (Pearson, 2018), Martin Fowler calls this symptom “divergent change”: having to change seemingly unrelated parts of the code to implement a single feature. </span><span class="koboSpan" id="kobo.79.2">This is a code smell that should trigger </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">a refactoring.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.81.1">The persistence code is</span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.82.1"> virtually fused into the domain code and thus it’s hard to change one without the other. </span><span class="koboSpan" id="kobo.82.2">That’s the opposite of being flexible and keeping options open, which should be the goal of </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">our architecture.</span></span></p>
<h1 id="_idParaDest-24"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.84.1">They’re prone to shortcuts</span></h1>
<p><span class="koboSpan" id="kobo.85.1">In a conventional layered</span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.86.1"> architecture, the only global rule is that from a certain layer, we can only access components in the same layer or a layer below. </span><span class="koboSpan" id="kobo.86.2">There may be other rules that a development team has agreed upon and some of them might even be enforced by tooling, but the layered architecture style itself does not impose those rules </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">on us.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">So, if we need access to a certain component in a layer above ours, we can just push the component down a layer and we’re allowed to access it. </span><span class="koboSpan" id="kobo.88.2">Problem solved. </span><span class="koboSpan" id="kobo.88.3">Doing this once may be OK. </span><span class="koboSpan" id="kobo.88.4">But doing it once opens the door for doing it a second time. </span><span class="koboSpan" id="kobo.88.5">And if someone else was allowed to do it, so am </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">I, right?</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">I’m not saying that as developers, we take such shortcuts lightly. </span><span class="koboSpan" id="kobo.90.2">But if there is an option to do something, someone will do it, especially in combination with a looming deadline. </span><span class="koboSpan" id="kobo.90.3">And if something has been done before, the likelihood of someone doing it again will increase drastically. </span><span class="koboSpan" id="kobo.90.4">This is </span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.91.1">a psychological effect called the </span><strong class="bold"><span class="koboSpan" id="kobo.92.1">Broken Windows Theory</span></strong><span class="koboSpan" id="kobo.93.1"> – more </span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.94.1">on this in </span><a href="B19916_11.xhtml#_idTextAnchor096"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.95.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.96.1">, </span><em class="itali"><span class="koboSpan" id="kobo.97.1">Taking </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.98.1">Shortcuts Consciously</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<span class="koboSpan" id="kobo.100.1"><img alt="Figure 2.3 – Since any layer may access everything in the persistence layer, it tends to grow fat over time" src="image/Figure_02.3_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.101.1">Figure 2.3 – Since any layer may access everything in the persistence layer, it tends to grow fat over time</span></p>
<p><span class="koboSpan" id="kobo.102.1">Over years of development and maintenance of a software project, the persistence layer may very well end up like in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.103.1">Figure 2</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.104.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">The persistence layer (or, in more generic terms, the bottom-most layer) will grow fat as we push components down through the layers. </span><span class="koboSpan" id="kobo.106.2">Perfect candidates for this are helper or utility components since they don’t seem to belong to any </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">specific layer.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">So, if we want to disable </span><em class="itali"><span class="koboSpan" id="kobo.109.1">shortcut mode</span></em><span class="koboSpan" id="kobo.110.1"> for our architecture, layers are not the best option, at least not without enforcing some kind of additional architecture rules. </span><span class="koboSpan" id="kobo.110.2">And by </span><em class="itali"><span class="koboSpan" id="kobo.111.1">enforcing</span></em><span class="koboSpan" id="kobo.112.1">, I don’t </span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.113.1">mean a senior developer doing code reviews, but automatically enforced rules that make the build fail when </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">they’re broken.</span></span></p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.115.1">They grow hard to test</span></h1>
<p><span class="koboSpan" id="kobo.116.1">A common</span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.117.1"> evolution within a layered architecture is that layers are skipped. </span><span class="koboSpan" id="kobo.117.2">We access the persistence layer directly from the web layer since we’re only manipulating a single field of an entity, and for that, we need not bother the domain </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">layer, right?</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<span class="koboSpan" id="kobo.119.1"><img alt="Figure 2.4 – Skipping the domain layer tends to scatter domain logic across the code base" src="image/Figure_02.4_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.120.1">Figure 2.4 – Skipping the domain layer tends to scatter domain logic across the code base</span></p>
<p><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.121.1">Figure 2</span></em></span><em class="itali"><span class="koboSpan" id="kobo.122.1">.4</span></em><span class="koboSpan" id="kobo.123.1"> shows how we’re skipping the domain layer and accessing the persistence layer right from the </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">web layer.</span></span></p>
<p><span class="koboSpan" id="kobo.125.1">Again, this feels OK the first couple of times, but it has two drawbacks if it happens often (and it will, once someone has made the </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">first step).</span></span></p>
<p><span class="koboSpan" id="kobo.127.1">First, we’re implementing domain logic in the web layer, even if it’s only manipulating a single field. </span><span class="koboSpan" id="kobo.127.2">What if the use case expands in the future? </span><span class="koboSpan" id="kobo.127.3">We’re most likely going to add more domain logic to the web layer, mixing responsibilities and spreading essential domain logic across </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">all layers.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">Second, in the unit tests of our web layer, we not only have to manage the dependencies on the domain layer but also the dependencies on the persistence layer. </span><span class="koboSpan" id="kobo.129.2">If we’re using mocks in our tests, that means we have to create mocks for both layers. </span><span class="koboSpan" id="kobo.129.3">This adds complexity to the tests. </span><span class="koboSpan" id="kobo.129.4">And a complex test setup is the first step toward no tests at all because we don’t have time for them. </span><span class="koboSpan" id="kobo.129.5">As the web component grows over time, it may accumulate a lot of dependencies on different persistence components, adding</span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.130.1"> to the test’s complexity. </span><span class="koboSpan" id="kobo.130.2">At some point, it takes more time for us to understand the dependencies and create mocks for them than to actually write </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">test code.</span></span></p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.132.1">They hide the use cases</span></h1>
<p><span class="koboSpan" id="kobo.133.1">As developers, we </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.134.1">like to create new code that implements shiny new use cases. </span><span class="koboSpan" id="kobo.134.2">But we usually spend much more time changing existing code than we do creating new code. </span><span class="koboSpan" id="kobo.134.3">This is not only true for those dreaded legacy projects in which we’re working on a decades-old code base but also for a hot new greenfield project after the initial use cases have </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">been implemented.</span></span></p>
<p><span class="koboSpan" id="kobo.136.1">Since we’re so often searching for the right place to add or change functionality, our architecture should help us to quickly navigate the code base. </span><span class="koboSpan" id="kobo.136.2">How does a layered architecture hold up in </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">this regard?</span></span></p>
<p><span class="koboSpan" id="kobo.138.1">As already discussed previously, in a layered architecture, it easily happens that domain logic is scattered throughout the layers. </span><span class="koboSpan" id="kobo.138.2">It may exist in the web layer if we’re skipping the domain logic for an “easy” use case. </span><span class="koboSpan" id="kobo.138.3">And it may exist in the persistence layer if we have pushed a certain component down so it can be accessed from both the domain and persistence layers. </span><span class="koboSpan" id="kobo.138.4">This already makes finding the right spot to add new </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">functionality hard.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">But there’s more. </span><span class="koboSpan" id="kobo.140.2">A layered architecture does not impose rules on the “width” of domain services. </span><span class="koboSpan" id="kobo.140.3">Over time, this often leads to very broad services that serve multiple use cases (see </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.141.1">Figure 2</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.142.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">).</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.144.1"><img alt="Figure 2.5 – “Broad” services make it hard to find a certain use case within the code base" src="image/Figure_02.5_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.145.1">Figure 2.5 – “Broad” services make it hard to find a certain use case within the code base</span></p>
<p><span class="koboSpan" id="kobo.146.1">A broad service has many dependencies on the persistence layer and many components in the web layer depend on it. </span><span class="koboSpan" id="kobo.146.2">This not only makes the service hard to test but also makes it hard for us to find the code responsible for the use case we want to </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">work on.</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">How much easier would</span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.149.1"> it be if we had highly specialized, narrow domain services that each serve a single use case? </span><span class="koboSpan" id="kobo.149.2">Instead of searching for the user registration use case in </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.150.1">UserService</span></strong><span class="koboSpan" id="kobo.151.1">, we would just open up </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.152.1">RegisterUserService</span></strong><span class="koboSpan" id="kobo.153.1"> and start </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">hacking away.</span></span></p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.155.1">They make parallel work difficult</span></h1>
<p><span class="koboSpan" id="kobo.156.1">Management </span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.157.1">usually expects us to be done with building the software they sponsor on a certain date. </span><span class="koboSpan" id="kobo.157.2">Actually, they even expect us to be done within a certain budget as well, but let’s not complicate </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">things here.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">Aside from the fact that I have never seen “done” software in my career as a software engineer, to be “done” by a certain date usually implies that multiple people have to work </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">in parallel.</span></span></p>
<p><span class="koboSpan" id="kobo.161.1">You probably know this famous conclusion from “</span><em class="itali"><span class="koboSpan" id="kobo.162.1">The Mythical Man-Month</span></em><span class="koboSpan" id="kobo.163.1">,” even if you haven’t read the book: </span><em class="itali"><span class="koboSpan" id="kobo.164.1">Adding manpower to a late software project makes </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.165.1">it later</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">.</span></span><span class="No-Break"><span id="footnote-008-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-008"><span class="koboSpan" id="kobo.167.1">4</span></a></span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-008">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-008-backlink"><span class="koboSpan" id="kobo.168.1">4</span></a><span class="koboSpan" id="kobo.169.1">4	</span><em class="itali"><span class="koboSpan" id="kobo.170.1">The Mythical Man-Month: Essays on Software Engineering</span></em><span class="koboSpan" id="kobo.171.1"> by Frederick P. </span><span class="koboSpan" id="kobo.171.2">Brooks, Jr., </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">Addison-Wesley, 1995.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.173.1">This also holds true, to a degree, in software projects that are not (yet) late. </span><span class="koboSpan" id="kobo.173.2">You cannot expect a large group of 50 developers to be 5 times faster than a smaller team of 10 developers. </span><span class="koboSpan" id="kobo.173.3">If they’re working on a very large application where they can split up into sub-teams and work on separate parts of the software, it may work, but in most contexts, they will step on each </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">other’s feet.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">But on a healthy scale, we can certainly expect to be faster with more people on the project. </span><span class="koboSpan" id="kobo.175.2">And management is right to expect that </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">of us.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">To meet this expectation, </span><em class="itali"><span class="koboSpan" id="kobo.178.1">our architecture must support parallel work</span></em><span class="koboSpan" id="kobo.179.1">. </span><span class="koboSpan" id="kobo.179.2">This is not easy. </span><span class="koboSpan" id="kobo.179.3">And a layered architecture doesn’t really help </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">us here.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">Imagine we’re adding a new use case to our application. </span><span class="koboSpan" id="kobo.181.2">We have three developers available. </span><span class="koboSpan" id="kobo.181.3">One can add the needed features to the web layer, one to the domain layer, and the third to the persistence </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">layer, right?</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">Well, it usually doesn’t work that way in a layered architecture. </span><span class="koboSpan" id="kobo.183.2">Since everything builds on top of the persistence layer, the persistence layer must be developed first. </span><span class="koboSpan" id="kobo.183.3">Then comes the domain layer and finally the web layer. </span><span class="koboSpan" id="kobo.183.4">So only one developer can work on the feature at </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">a time!</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">“Ah, but the developers can define interfaces first,” you say, “and then each developer can work against these interfaces without having to wait for the </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">actual implementation.”</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">Sure, this is possible, but</span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.188.1"> only if we haven’t mixed our domain and persistence logic as discussed previously, blocking us from working on each </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">aspect separately.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">If we have broad services in our code base, it may even be hard to work on </span><em class="itali"><span class="koboSpan" id="kobo.191.1">different</span></em><span class="koboSpan" id="kobo.192.1"> features in parallel. </span><span class="koboSpan" id="kobo.192.2">Working on different use cases will cause the same service to be edited in parallel, which leads to merge conflicts and </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">potentially regressions.</span></span></p>
<h1 id="_idParaDest-28"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.194.1">How does this help me build maintainable software?</span></h1>
<p><span class="koboSpan" id="kobo.195.1">If you have built layered architectures in the past, you can probably relate to some of the issues discussed in this chapter, and you could maybe even add </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">some more.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">If done correctly, and if some additional rules are imposed on it, a layered architecture can be very maintainable and can make changing or adding to the code base </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">a breeze.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">However, the discussion shows that a layered architecture allows many things to go wrong. </span><span class="koboSpan" id="kobo.199.2">Without good self-discipline, it’s prone to degrading and becoming less maintainable over time. </span><span class="koboSpan" id="kobo.199.3">And our self-discipline usually takes a hit each time a team member rotates into or out of the team, or a manager draws a new deadline around the </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">development team.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">Keeping the traps of layered architecture in mind will help us the next time we argue against taking a shortcut and for building a more maintainable solution instead – be it in a layered architecture or a different </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">architecture style.</span></span></p>
</div>
</body></html>