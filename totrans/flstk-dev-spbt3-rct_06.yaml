- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Securing Your Backend
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护您的后端
- en: This chapter explains how to secure your Spring Boot backend. Securing your
    backend is a crucial part of code development. It is essential for protecting
    sensitive data, complying with regulations, and preventing unauthorized access.
    The backend often handles the user authentication and authorization process. Securing
    these aspects properly ensures that only authorized users can access the application
    and perform specific actions. We will use the database application that we created
    in the previous chapter as a starting point.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了如何保护您的 Spring Boot 后端。保护后端是代码开发的关键部分。对于保护敏感数据、遵守法规和防止未经授权的访问至关重要。后端通常处理用户认证和授权过程。正确保护这些方面确保只有授权用户可以访问应用程序并执行特定操作。我们将以前一章创建的数据库应用程序作为起点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding Spring Security
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Spring Security
- en: Securing your backend with a JSON Web Token
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSON Web Token 保护您的后端
- en: Role-based security
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于角色的安全
- en: Using OAuth2 with Spring Boot
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OAuth2 与 Spring Boot
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The Spring Boot application that we created in the previous chapters is required.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中创建的 Spring Boot 应用程序是必需的。
- en: 'The following GitHub link will also be required: [https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter05).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 GitHub 链接也将是必需的：[https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter05)。
- en: Understanding Spring Security
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Spring Security
- en: '**Spring Security** (https://spring.io/projects/spring-security) provides security
    services for Java-based web applications. The Spring Security project was started
    in 2003 and was previously named *Acegi Security System for Spring*.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Security** (https://spring.io/projects/spring-security) 为基于 Java 的
    Web 应用程序提供安全服务。Spring Security 项目始于 2003 年，之前被称为 *Acegi Security System for Spring*。'
- en: 'By default, Spring Security enables the following features:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Security 启用以下功能：
- en: An `AuthenticationManager` bean with an in-memory single user. The username
    is `user` and the password is printed to the console output.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有内存中单个用户的 `AuthenticationManager` 实例。用户名为 `user`，密码打印到控制台输出。
- en: Ignored paths for common static resource locations, such as `/css` and `/images`.
    HTTP basic authentication for all other endpoints.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略常见静态资源位置的路径，例如 `/css` 和 `/images`。其他所有端点的 HTTP 基本认证。
- en: Security events published to Spring’s `ApplicationEventPublisher` interface.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全事件发布到 Spring 的 `ApplicationEventPublisher` 接口。
- en: Common low-level features turned on by default, including **HTTP Strict Transport
    Security** (**HSTS**), **cross-site scripting** (**XSS**), and **cross-site request
    forgery** (**CSRF**).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认启用的常见低级功能，包括 **HTTP Strict Transport Security** (**HSTS**), **跨站脚本** (**XSS**),
    和 **跨站请求伪造** (**CSRF**)。
- en: A default autogenerated login page.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认自动生成的登录页面。
- en: 'You can include Spring Security in your application by adding the following
    highlighted dependencies to the `build.gradle` file. The first dependency is for
    the application and the second is for testing:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将以下突出显示的依赖项添加到 `build.gradle` 文件中来将 Spring Security 包含到您的应用程序中。第一个依赖项是用于应用程序的，第二个是用于测试的：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you haven’t enabled automatic refresh, remember to refresh the Gradle project
    from Eclipse after you have modified your `build.gradle` file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未启用自动刷新，请记住在修改了您的 `build.gradle` 文件后，从 Eclipse 中刷新 Gradle 项目。
- en: 'When you start your application, you can see from the console that Spring Security
    has created an in-memory user with a username of `user`. The user’s password can
    be seen in the console output, as illustrated here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当您启动应用程序时，您可以从控制台看到 Spring Security 已创建一个用户名为 `user` 的内存中用户。用户的密码可以在控制台输出中看到，如图所示：
- en: '![](img/B19818_05_01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_05_01.png)'
- en: 'Figure 5.1: Spring Security enabled'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：Spring Security 已启用
- en: If there is no password in the console, try to restart your project by pressing
    the red **Terminate** button in the console and re-running it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果控制台中没有密码，请尝试通过在控制台中按下红色 **终止** 按钮重新启动您的项目并重新运行它。
- en: The Eclipse console has limited output, and the default buffer size is 80,000
    characters, so the output might be truncated before the password statement can
    appear. You can change this setting from the **Window | Preferences | Run/Debug
    | Console** menu.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse控制台输出有限，默认缓冲区大小为80,000个字符，因此输出可能在密码语句出现之前被截断。您可以从**窗口 | 首选项 | 运行/调试 |
    控制台**菜单更改此设置。
- en: 'Now, if you make a `GET` request to your REST API root endpoint, you will see
    that it has been secured. Open your web browser and navigate to `http://localhost:8080/api`.
    You will be redirected to the Spring Security default login page, as illustrated
    in the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您向您的REST API根端点发送一个`GET`请求，您将看到它已被保护。打开您的网络浏览器并导航到`http://localhost:8080/api`。您将被重定向到Spring
    Security默认登录页面，如下面的截图所示：
- en: '![](img/B19818_05_02.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_05_02.png)'
- en: 'Figure 5.2: Secured REST API'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：受保护的REST API
- en: 'To be able to make a successful `GET` request, we have to authenticate to our
    RESTful API. Type `user` into the **Username** field and copy the generated password
    from the console to the **Password** field. With authentication, we can see that
    the response contains our API resources, as illustrated in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够成功发送`GET`请求，我们必须对我们的RESTful API进行身份验证。在**用户名**字段中输入`user`，并将从控制台生成的密码复制到**密码**字段。通过身份验证，我们可以看到响应包含我们的API资源，如下面的截图所示：
- en: '![](img/B19818_05_03.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19818_05_03.png)'
- en: 'Figure 5.3: Basic authentication'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：基本身份验证
- en: To configure how Spring Security behaves, we have to add a new configuration
    class for Spring Security. The security configuration file can be used to define
    which URLs or URL patterns are accessible to which roles or users. You can also
    define the authentication mechanism, the login process, session management, and
    so on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置Spring Security的行为，我们必须为Spring Security添加一个新的配置类。安全配置文件可以用来定义哪些URL或URL模式对哪些角色或用户是可访问的。您还可以定义认证机制、登录过程、会话管理等。
- en: 'Create a new class called `SecurityConfig` in your application root package
    (`com.packt.cardatabase`). The following source code shows the structure of the
    security configuration class:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序根包（`com.packt.cardatabase`）中创建一个名为`SecurityConfig`的新类。以下源代码显示了安全配置类的结构：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `@Configuration` and `@EnableWebSecurity` annotations switch off the default
    web security configuration, and we can define our own configuration in this class.
    Inside the `filterChain(HttpSecurity http)` method that we will see in action
    later, we can define which endpoints in our application are secure and which are
    not. We don’t actually need this method yet because we can use the default settings
    where all the endpoints are secured.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Configuration`和`@EnableWebSecurity`注解关闭了默认的Web安全配置，我们可以在此类中定义自己的配置。在稍后我们将看到其作用的`filterChain(HttpSecurity
    http)`方法中，我们可以定义我们的应用程序中哪些端点是安全的，哪些不是。实际上我们目前不需要这个方法，因为我们可以在所有端点都受保护的情况下使用默认设置。'
- en: We can also add in-memory users to our application by using Spring Security’s
    `InMemoryUserDetailsManager`,which implements `UserDetailsService`. Then we can
    implement user/password authentication that is stored in memory. We can also use
    `PasswordEncoder` to encode passwords using the `bcrypt` algorithm.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用Spring Security的`InMemoryUserDetailsManager`（它实现了`UserDetailsService`）将内存中的用户添加到我们的应用程序中。然后我们可以实现存储在内存中的用户/密码认证。我们还可以使用`PasswordEncoder`通过`bcrypt`算法对密码进行编码。
- en: 'The following highlighted source code will create an in-memory user with a
    username of `user`, a password of `password`, and a role of `USER`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的高亮源代码将创建一个名为`user`、密码为`password`、角色为`USER`的内存中用户：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, restart the application, and you will be able to test authentication using
    the in-memory user. The use of in-memory users is fine in the development phase,
    but a proper application should save users in the database.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新启动应用程序，您将能够使用内存中的用户进行身份验证测试。在开发阶段使用内存中的用户是可以的，但一个合适的应用程序应该将用户保存在数据库中。
- en: 'To save users to the database, you have to create a user entity class and repository.
    Passwords shouldn’t be saved to the database in plaintext format. If a database
    containing user passwords is hacked, attackers will be able to get the passwords
    directly in plaintext. Spring Security provides multiple hashing algorithms, such
    as `bcrypt`, that you can use to hash passwords. The following steps show you
    how to implement this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要将用户保存到数据库中，你必须创建一个用户实体类和存储库。密码不应以明文格式保存到数据库中。如果包含用户密码的数据库被黑客攻击，攻击者将能够直接以明文形式获取密码。Spring
    Security 提供了多种哈希算法，例如 `bcrypt`，你可以使用这些算法来哈希密码。以下步骤展示了如何实现这一点：
- en: 'Create a new class called `AppUser` in the `com.packt.cardatabase.domain` package.
    Activate the domain package and right-click it. Select **New** | **Class** from
    the menu and name the new class `User`. After that, your project structure should
    look like this:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `com.packt.cardatabase.domain` 包中创建一个名为 `AppUser` 的新类。激活领域包，然后右键单击它。从菜单中选择
    **新建** | **类**，并将新类命名为 `User`。之后，你的项目结构应该看起来像这样：
- en: '![](img/B19818_05_04.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_05_04.png)'
- en: 'Figure 5.4: Project structure'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：项目结构
- en: 'Annotate the `AppUser` class with the `@Entity` annotation. Add the ID, username,
    password, and role class fields. Finally, add the constructors, getters, and setters.
    We will set all the fields to be not `nullable`. This means that database columns
    cannot hold `null` values. We will also specify that the username must be unique
    by using `unique=true` in the username’s `@Column` annotation. Refer to the following
    `AppUser.java` source code for the fields:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `@Entity` 注解标注 `AppUser` 类。添加 ID、用户名、密码和角色类字段。最后，添加构造函数、获取器和设置器。我们将所有字段设置为不可为空。这意味着数据库列不能包含
    `null` 值。我们还将通过在用户名的 `@Column` 注解中使用 `unique=true` 来指定用户名必须是唯一的。请参考以下 `AppUser.java`
    源代码以了解字段：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is the `AppUser.java` constructors source code:'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是 `AppUser.java` 构造函数的源代码：
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the `AppUser.java` source code with the getters and setters:'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是带有获取器和设置器的 `AppUser.java` 源代码：
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Create a new interface called `AppUserRepository` in the domain package. To
    do this, activate the domain package and right-click it. Select **New** | **Interface**
    from the menu and name it `AppUserRepository`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在领域包中创建一个名为 `AppUserRepository` 的新接口。为此，激活领域包，然后右键单击它。从菜单中选择 **新建** | **接口**，并将其命名为
    `AppUserRepository`。
- en: 'The source code for the repository class is similar to what we saw in the previous
    chapter, but there is one query method, `findByUsername`, that we need for the
    steps that follow. This method is used to find a `user` from the database in the
    authentication process. The method returns `Optional` to prevent a null exception.
    Refer to the following `AppUserRepository` source code:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储库类的源代码与我们之前章节中看到的大致相同，但有一个名为 `findByUsername` 的查询方法，这是我们接下来需要用到的。此方法用于在认证过程中从数据库中查找
    `用户`。该方法返回 `Optional` 以防止空指针异常。请参考以下 `AppUserRepository` 源代码：
- en: '[PRE6]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we will create a class that implements the `UserDetailsService` interface
    that’s provided by Spring Security. Spring Security uses this for user authentication
    and authorization. Create a new `service` package in the root package. To do this,
    activate the root package and right-click it. Select **New** | **Package** from
    the menu and name the new package `service`, as illustrated in the following screenshot:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个实现 Spring Security 提供的 `UserDetailsService` 接口的类。Spring Security
    使用它来进行用户认证和授权。在根包中创建一个新的 `service` 包。为此，激活根包，然后右键单击它。从菜单中选择 **新建** | **包**，并将其命名为
    `service`，如图所示：
- en: '![](img/B19818_05_05.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_05_05.png)'
- en: 'Figure 5.5: The service package'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：服务包
- en: 'Create a new class called `UserDetailsServiceImpl` in the `service` package
    we just created. Now, your project structure should look like this (in Eclipse,
    refresh the Project Explorer by pressing *F5*):'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们刚刚创建的 `service` 包中创建一个名为 `UserDetailsServiceImpl` 的新类。现在，你的项目结构应该看起来像这样（在
    Eclipse 中，通过按 *F5* 刷新项目资源管理器）：
- en: '![](img/B19818_05_06.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_05_06.png)'
- en: 'Figure 5.6: Project structure'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：项目结构
- en: 'We have to inject the `AppUserRepository` class into the `UserDetailsServiceImpl`
    class because it is needed to fetch the user from the database when Spring Security
    handles authentication. The `findByUsername` method that we implemented earlier
    returns `Optional`, therefore we can use the `isPresent()` method to check if
    the `user` exists. If the `user` doesn’t exist, we throw a `UsernameNotFoundException`
    exception. The `loadUserByUsername` method returns the `UserDetails` object, which
    is required for authentication. We are using the Spring Security `UserBuilder`
    class to build the user for the authentication. Here is the source code for `UserDetailsServiceImpl.java`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须将`AppUserRepository`类注入到`UserDetailsServiceImpl`类中，因为当Spring Security处理认证时需要从数据库中获取用户。我们之前实现的`findByUsername`方法返回`Optional`，因此我们可以使用`isPresent()`方法来检查`user`是否存在。如果`user`不存在，我们抛出`UsernameNotFoundException`异常。`loadUserByUsername`方法返回`UserDetails`对象，这是认证所必需的。我们使用Spring
    Security的`UserBuilder`类来构建用于认证的用户。以下是`UserDetailsServiceImpl.java`的源代码：
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In our security configuration class, we have to specify that Spring Security
    should use users from the database instead of in-memory users. Delete the `userDetailsService()`
    method from the `SecurityConfig` class to disable in-memory users. Add a new `configureGlobal`
    method to enable users from the database.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的安全配置类中，我们必须指定Spring Security应使用数据库中的用户而不是内存中的用户。从`SecurityConfig`类中删除`userDetailsService()`方法以禁用内存中的用户。添加一个新的`configureGlobal`方法以启用数据库中的用户。
- en: 'We should never save the password as plaintext to the database. Therefore,
    we will define a password hashing algorithm in the `configureGlobal` method. In
    this example, we are using the `bcrypt` algorithm. This can be easily implemented
    with the Spring Security `BCryptPasswordEncoder` class, which encodes a hashed
    password during the authentication process. Here is the `SecurityConfig.java`
    source code:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们永远不应该将密码以明文形式保存到数据库中。因此，我们将在`configureGlobal`方法中定义一个密码散列算法。在这个例子中，我们使用`bcrypt`算法。这可以通过Spring
    Security的`BCryptPasswordEncoder`类轻松实现，该类在认证过程中编码散列密码。以下是`SecurityConfig.java`的源代码：
- en: '[PRE8]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, the password must be hashed using `bcrypt` before it’s saved to the database.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，在将密码保存到数据库之前，必须使用`bcrypt`对其进行散列。
- en: 'Finally, we can save a couple of test users to the database using the `CommandLineRunner`
    interface. Open the `CardatabaseApplication.java` file and inject `AppUserRepository`
    into the main class:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`CommandLineRunner`接口将几个测试用户保存到数据库中。打开`CardatabaseApplication.java`文件，并将`AppUserRepository`注入到主类中：
- en: '[PRE9]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s save two users to the database with `bcrypt` hashed passwords. You can
    find `bcrypt` calculators or generators on the internet. These generators allow
    you to input a plaintext password, and they will produce the corresponding `bcrypt`
    hash:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`bcrypt`散列密码将两个用户保存到数据库中。你可以在互联网上找到`bcrypt`计算器或生成器。这些生成器允许你输入明文密码，然后它们将生成相应的`bcrypt`散列：
- en: '[PRE10]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**bcrypt** is a strong hashing function that was designed by Niels Provos and
    David Mazières. Here is an example of a bcrypt hash that is generated from the
    `admin` string:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**bcrypt**是一种由Niels Provos和David Mazières设计的强大散列函数。以下是从`admin`字符串生成的bcrypt散列的示例：'
- en: '`$2a$10$8cjz47bjbR4Mn8GMg9IZx.vyjhLXR/SKKMSZ9.mP9vpMu0ssKi8GW`'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$2a$10$8cjz47bjbR4Mn8GMg9IZx.vyjhLXR/SKKMSZ9.mP9vpMu0ssKi8GW`'
- en: '`$2a` represents the algorithm version, and `$10` represents the strength of
    the algorithm. The default strength of Spring Security’s `BcryptPasswordEncoder`
    class is 10\. bcrypt generates a random **salt** in hashing, so the hashed result
    is always different.'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$2a`代表算法版本，`$10`代表算法的强度。Spring Security的`BcryptPasswordEncoder`类的默认强度是10。bcrypt在散列过程中生成一个随机的**盐**，因此散列结果总是不同的。'
- en: 'After running your application, you will see that there is now an `app_user`
    table in the database and that two user records are saved with hashed passwords,
    as illustrated in the following screenshot:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的应用程序后，你会看到现在数据库中有一个`app_user`表，并且有两个用户记录以散列密码的形式保存，如下面的截图所示：
- en: '![](img/B19818_05_07.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_05_07.png)'
- en: 'Figure 5.7: Users'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7：用户
- en: Now, you should restart the application and you will get a `401 Unauthorized`
    error if you try to send a `GET` request to the `http://localhost:8080/api` path
    without authentication. You must authenticate to be able to send a successful
    request. The difference, when compared with the previous example, is that we are
    using the users from the database to authenticate.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你应该重新启动应用程序，如果你尝试在不进行认证的情况下向 `http://localhost:8080/api` 路径发送 `GET` 请求，你会得到一个
    `401 未授权` 错误。你必须进行认证才能发送成功的请求。与上一个示例相比，区别在于我们现在使用数据库中的用户进行认证。
- en: 'Now, you can log in by sending a `GET` request to the `/api` endpoint using
    the browser, or we can use Postman and basic authentication, as shown in the following
    screenshot:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，你可以通过使用浏览器向 `/api` 端点发送 `GET` 请求来登录，或者我们可以使用 Postman 和基本认证，如下面的截图所示：
- en: '![](img/B19818_05_08.png)'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B19818_05_08.png)'
- en: 'Figure 5.8: GET request authentication'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5.8：GET 请求认证
- en: 'You can see that we currently get users by calling the `api/appUsers` endpoint
    in our RESTful web service, which is something we want to avoid. As mentioned
    in *Chapter 4*, Spring Data REST generates a RESTful web service from all public
    repositories by default. We can use the `exported` flag of the `@RepositoryRestResource`
    annotation and set it to `false`, which means the following repository is not
    exposed as a REST resource:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以看到，我们目前通过在我们的 RESTful 网络服务中调用 `api/appUsers` 端点来获取用户，这是我们想要避免的。如 *第 4 章*
    中所述，Spring Data REST 默认会从所有公共仓库生成 RESTful 网络服务。我们可以使用 `@RepositoryRestResource`
    注解的 `exported` 标志，并将其设置为 `false`，这意味着以下仓库不会作为 REST 资源暴露：
- en: '[PRE11]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, if you restart the application and send a `GET` request to the `/api` endpoint,
    you will see that the `/appUsers` endpoint is not visible anymore.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你重新启动应用程序并向 `/api` 端点发送一个 `GET` 请求，你会看到 `/appUsers` 端点不再可见。
- en: Next, we will start to implement authentication using a JSON Web Token.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始使用 JSON Web Token 实现认证。
- en: Securing your backend with a JSON Web Token
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JSON Web Token 保护你的后端
- en: In the previous section, we covered how to use basic authentication with a RESTful
    web service. Basic authentication doesn’t provide a way to handle tokens or manage
    sessions. When a user logs in, the credentials are sent with each request, which
    can cause session management challenges and potential security risks. This method
    is not usable when we develop our own frontend with React, so we are going to
    use **JSON Web Token** (**JWT**) authentication instead (https://jwt.io/). This
    will also give you an idea of how you can configure Spring Security in more detail.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了如何使用基本认证来与 RESTful 网络服务交互。基本认证不提供处理令牌或管理会话的方法。当用户登录时，凭证会随着每个请求发送，这可能导致会话管理挑战和潜在的安全风险。当我们使用
    React 开发自己的前端时，这种方法不可用，因此我们将使用 **JSON Web Token**（**JWT**）认证代替（https://jwt.io/）。这也会让你了解如何更详细地配置
    Spring Security。
- en: The other option for securing your RESTful web service is **OAuth 2**. OAuth2
    (https://oauth.net/2/) is the industry standard for authorization and it can be
    used quite easily in Spring Boot applications. There is a section later on in
    the chapter that will give you a basic idea about how to use it in your applications.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 保护你的 RESTful 网络服务的另一种选择是 **OAuth 2**。OAuth2（https://oauth.net/2/）是行业标准的授权，它可以在
    Spring Boot 应用程序中非常容易地使用。本章后面有一个部分将给你一个基本的概念，了解如何在你的应用程序中使用它。
- en: JWTs are commonly used in RESTful APIs for authentication and authorization
    purposes. They are a compact way to implement authentication in modern web applications.
    A JWT is really small in size and can therefore be sent in the URL, in the `POST`
    parameter, or inside the header. It also contains all the necessary information
    about the user, such as their username and role.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: JWTs 常用于 RESTful API 的认证和授权目的。它们是实现现代网络应用认证的一种紧凑方式。JWT 非常小，因此可以发送在 URL 中、`POST`
    参数中或头信息中。它还包含有关用户的所有必要信息，例如他们的用户名和角色。
- en: 'A JWT contains three different parts, separated by dots: `xxxxx.yyyyy.zzzzz`.
    These parts are broken up as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 包含三个不同的部分，由点分隔：`xxxxx.yyyyy.zzzzz`。这些部分如下划分：
- en: The first part (`xxxxx`) is the **header,** which defines the type of token
    and the hashing algorithm.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一部分（`xxxxx`）是 **头部**，它定义了令牌的类型和哈希算法。
- en: The second part (`yyyyy`) is the **payload,** which, typically, in the case
    of authentication, contains user information.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二部分（`yyyyy`）是 **负载**，通常情况下，在认证的情况下，它包含用户信息。
- en: The third part (`zzzzz`) is the **signature,** which is used to verify that
    the token hasn’t been changed along the way.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三部分（`zzzzz`）是**签名**，它用于验证令牌在传输过程中没有被更改。
- en: 'Here is an example of a JWT:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个JWT的示例：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following diagram shows a simplified representation of the authentication
    process using a JWT:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了使用JWT的简化认证过程表示：
- en: '![](img/B19818_05_09.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_05_09.png)'
- en: 'Figure 5.9: JWT authentication process'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9：JWT认证过程
- en: After successful authentication, the requests sent by the client should always
    contain the JWT that was received in the authentication.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在认证成功后，客户端发送的请求应始终包含在认证中接收到的JWT。
- en: 'We will use `jjwt` (https://github.com/jwtk/jjwt), which is the JWT library
    for Java and Android for creating and parsing JWTs. Therefore, we have to add
    the following dependencies to the `build.gradle` file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`jjwt`（https://github.com/jwtk/jjwt），这是Java和Android的JWT库，用于创建和解析JWT。因此，我们必须将以下依赖项添加到`build.gradle`文件中：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Remember to refresh the Gradle project from Eclipse after you have updated the
    dependencies.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在你更新了依赖项之后，记得从Eclipse刷新Gradle项目。
- en: The following steps demonstrate how to enable JWT authentication in our backend.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤演示了如何在我们的后端启用JWT认证。
- en: Securing the login
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护登录
- en: 'We will start with the login functionality:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从登录功能开始：
- en: 'First, we will create a class that generates and verifies a signed JWT. Create
    a new class called `JwtService` in the `com.packt.cardatabase.service` package.
    At the beginning of the class, we will define a few constants: `EXPIRATIONTIME`
    defines the expiration time of the token in milliseconds, `PREFIX` defines the
    prefix of the token, and the `"Bearer"` schema is typically used. A JWT is sent
    in the `Authorization` header and the content of the header looks like the following
    when using the Bearer schema:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个类来生成和验证已签名的JWT。在`com.packt.cardatabase.service`包中创建一个新的类名为`JwtService`。在类的开头，我们将定义一些常量：`EXPIRATIONTIME`定义了令牌的过期时间（以毫秒为单位），`PREFIX`定义了令牌的前缀，通常使用`"Bearer"`模式。JWT在`Authorization`头中发送，当使用Bearer模式时，头的样子如下：
- en: '[PRE14]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `JwtService` source code looks like the following:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`JwtService`源代码看起来如下：'
- en: '[PRE15]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will create a secret key using the `jjwt` library’s `secretKeyFor` method.
    This is only for demonstration purposes. In a production environment, you should
    read your secret key from the application configuration. The `getToken` method
    then generates and returns the token. The `getAuthUser` method gets the token
    from the response `Authorization` header. Then, we will use the `parserBuilder`
    method provided by the `jjwt` library to create a `JwtParserBuilder` instance.
    The `setSigningKey` method is used to specify a secret key for token verification.
    The `parseClaimsJws` method removes the `Bearer` prefix from the `Authorization`
    header. Finally, we will use the `getSubject` method to get the username. The
    whole `JwtService` source code follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`jjwt`库的`secretKeyFor`方法创建一个密钥。这只是为了演示目的。在生产环境中，你应该从应用程序配置中读取你的密钥。然后，`getToken`方法生成并返回令牌。`getAuthUser`方法从响应的`Authorization`头中获取令牌。接下来，我们将使用`jjwt`库提供的`parserBuilder`方法创建一个`JwtParserBuilder`实例。`setSigningKey`方法用于指定用于令牌验证的密钥。`parseClaimsJws`方法从`Authorization`头中移除`Bearer`前缀。最后，我们将使用`getSubject`方法获取用户名。整个`JwtService`源代码如下：
- en: '[PRE16]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, we will add a new class to store credentials for authentication. Here
    we can use a Java **record**, which was introduced in Java 14\. A record is a
    good choice if you need a class that only holds data; you can avoid a lot of boilerplate
    code. Create a new record (**New** | **Record**) called `AccountCredentials` in
    the `com.packt.cardatabase.domain` package:![](img/B19818_05_10.png)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个新的类来存储用于认证的凭据。在这里，我们可以使用Java **record**，这是在Java 14中引入的。如果你需要一个只持有数据的类，record是一个不错的选择；你可以避免编写很多样板代码。在`com.packt.cardatabase.domain`包中创建一个新的record（**新建**
    | **记录**）名为`AccountCredentials`！[](img/B19818_05_10.png)
- en: 'Figure 5.10: Create a new record'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.10：创建新记录
- en: 'The record has two fields: `username` and `password`. Here is the source code
    for the record. As you can see, we don’t have to write getters and setters when
    using it:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记录有两个字段：`username`和`password`。以下是记录的源代码。正如你所见，当我们使用它时，我们不需要编写getter和setter：
- en: '[PRE17]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we will implement the `controller` class for login. Login is done by calling
    the `/login` endpoint using the `POST` method and sending the username and password
    inside the request body. Create a class called `LoginController` inside the `com.packt.cardatabase.web`
    package. We have to inject a `JwtService` instance into the controller class because
    that is used to generate a signed JWT in the case of a successful login. The code
    is illustrated in the following snippet:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将实现登录的 `controller` 类。登录是通过调用 `POST` 方法的 `/login` 端点并将在请求体中发送用户名和密码来完成的。在
    `com.packt.cardatabase.web` 包内创建一个名为 `LoginController` 的类。我们必须将 `JwtService` 实例注入到控制器类中，因为这是在登录成功的情况下生成签名
    JWT 所使用的。代码如下所示：
- en: '[PRE18]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we will implement the `getToken` method that handles the login functionality.
    We get a JSON object from the request body that contains the username and password.
    `AuthenticationManager` is used to perform authentication and it uses credentials
    that we get from the request. Then, we use the `JwtService` class’ `getToken`
    method to generate a JWT. Finally, we build an HTTP response that contains the
    generated JWT in the `Authorization` header:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实现处理登录功能的 `getToken` 方法。我们从请求体中获取一个包含用户名和密码的 JSON 对象。使用 `AuthenticationManager`
    进行身份验证，它使用我们从请求中获取的凭据。然后，我们使用 `JwtService` 类的 `getToken` 方法生成 JWT。最后，我们构建一个包含生成的
    JWT 的 `Authorization` 标头的 HTTP 响应：
- en: '[PRE19]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We have also injected `AuthenticationManager` into the `LoginController` class,
    therefore we have to add the following highlighted code to the `SecurityConfig`
    class:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还向 `LoginController` 类中注入了 `AuthenticationManager`，因此我们必须向 `SecurityConfig`
    类中添加以下突出显示的代码：
- en: '[PRE20]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this step, we have to configure Spring Security functionality. Spring Security’s
    `SecurityFilterChain` bean defines which paths are secured and which are not.
    Add the following `filterChain` method to the `SecurityConfig` class. In the method,
    we define that the `POST` method request to the `/login` endpoint is allowed without
    authentication and that requests to all other endpoints require authentication.
    We will also define that Spring Security will never create a session, and therefore
    we can disable cross-site request forgery (`csrf`). JWTs are designed to be stateless,
    which reduces the risk of session-related vulnerabilities. We will use Lambdas
    in the HTTP security configuration:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此步骤中，我们必须配置 Spring Security 功能。Spring Security 的 `SecurityFilterChain` bean
    定义了哪些路径是受保护的，哪些不是。将以下 `filterChain` 方法添加到 `SecurityConfig` 类中。在方法中，我们定义了对 `/login`
    端点的 `POST` 方法请求不需要身份验证，以及对所有其他端点的请求需要身份验证。我们还将定义 Spring Security 将永远不会创建会话，因此我们可以禁用跨站请求伪造
    (`csrf`)。JWT 被设计为无状态，这降低了与会话相关的漏洞风险。我们将在 HTTP 安全配置中使用 Lambdas：
- en: In some other programming languages, Lambdas are called **anonymous functions**.
    The usage of Lambdas makes code more readable and reduces boilerplate code.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在某些其他编程语言中，Lambdas 被称为**匿名函数**。Lambdas 的使用使代码更易读，并减少了样板代码。
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we are ready to test our login functionality. Open Postman and make
    a `POST` request to the `http://localhost:8080/login` URL. Define a valid user
    inside the request body, for example, `{"username":"user", "password":"user"}`
    and select **JSON** from the drop-down list. Postman will then set the `Content-Type`
    header to `application/json` automatically. You should check from the **Headers**
    tab that the `Content-Type` header is set correctly. Now, you should see an `Authorization`
    header in the response that contains the signed JWT, like the one shown in the
    following screenshot:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们准备好测试我们的登录功能。打开 Postman 并向 `http://localhost:8080/login` URL 发送 `POST`
    请求。在请求体中定义一个有效用户，例如，`{"username":"user", "password":"user"}` 并从下拉列表中选择 **JSON**。Postman
    将自动设置 `Content-Type` 标头为 `application/json`。您应该从 **Headers** 选项卡检查 `Content-Type`
    标头是否设置正确。现在，您应该在响应中看到一个包含签名 JWT 的 `Authorization` 标头，如下面的截图所示：
- en: '![](img/B19818_05_11.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_05_11.png)'
- en: 'Figure 5.11: Login request'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11：登录请求
- en: You can also test the login by using the wrong password and seeing that the
    response doesn’t contain the `Authorization` header.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过使用错误的密码并查看响应不包含 `Authorization` 标头来测试登录。
- en: Securing the other requests
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护其他请求
- en: We have now finalized the login step, and we will move on to handling authentication
    for the rest of the incoming requests. In the authentication process, we are using
    **filters** that allow us to perform some operations before a request goes to
    the controller or before a response is sent to a client.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了登录步骤，接下来我们将继续处理其他传入请求的认证。在认证过程中，我们使用 **过滤器** 来在请求发送到控制器或响应发送到客户端之前执行一些操作。
- en: 'The following steps demonstrate the rest of the authentication process:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了认证过程的其余部分：
- en: 'We will use a filter class to authenticate all other incoming requests. Create
    a new class called `AuthenticationFilter` in the root package. The `AuthenticationFilter`
    class extends Spring Security’s `OncePerRequestFilter` interface, which provides
    a `doFilterInternal` method where we implement our authentication. We have to
    inject a `JwtService` instance into the filter class because it is needed to verify
    a token from the request. The `SecurityContextHolder` is where Spring Security
    stores the details of the authenticated user. The code is illustrated in the following
    snippet:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个过滤器类来认证所有其他传入的请求。在根包中创建一个名为 `AuthenticationFilter` 的新类。`AuthenticationFilter`
    类扩展了 Spring Security 的 `OncePerRequestFilter` 接口，该接口提供了一个 `doFilterInternal` 方法，我们在其中实现认证。我们必须将一个
    `JwtService` 实例注入到过滤器类中，因为它需要验证请求中的令牌。`SecurityContextHolder` 是 Spring Security
    存储已认证用户详情的地方。代码在下面的代码片段中展示：
- en: '[PRE22]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we have to add our filter class to the Spring Security configuration.
    Open the `SecurityConfig` class and inject the `AuthenticationFilter` class that
    we just implemented, as shown in the highlighted code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须将我们的过滤器类添加到 Spring Security 配置中。打开 `SecurityConfig` 类，并注入我们刚刚实现的 `AuthenticationFilter`
    类，如高亮代码所示：
- en: '[PRE23]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, modify the `filterChain` method in the `SecurityConfig` class and add
    the following lines of code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，修改 `SecurityConfig` 类中的 `filterChain` 方法，并添加以下代码行：
- en: '[PRE24]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we are ready to test the whole workflow. After we run the application,
    we can first log in by calling the `/login` endpoint with the `POST` method and,
    in the case of a successful login, we will receive a JWT in the `Authorization`
    header. Remember to add a valid user inside the body and set the `Content-Type`
    header to `application/json` if it is not done automatically by Postman. The following
    screenshot illustrates the process:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好测试整个工作流程。在运行应用程序后，我们可以首先通过调用 `POST` 方法的 `/login` 端点来登录，如果登录成功，我们将在
    `Authorization` 标头中收到一个 JWT。请记住，如果 Postman 没有自动完成，请在请求体中添加一个有效的用户，并将 `Content-Type`
    标头设置为 `application/json`。以下屏幕截图展示了这个过程：
- en: '![](img/B19818_05_12.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_05_12.png)'
- en: 'Figure 5.12: Login request'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12：登录请求
- en: 'Following a successful login, we can call the other RESTful service endpoints
    by sending the JWT that was received from the login in the `Authorization` header.
    Copy the token from the login response (without the `Bearer` prefix) and add the
    `Authorization` header with the token in the `VALUE` column. Refer to the example
    in the following screenshot where a `GET` request to the `/cars` endpoint is done:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功登录后，我们可以通过在 `Authorization` 标头中发送从登录接收到的 JWT 来调用其他 RESTful 服务端点。从登录响应中复制令牌（不带
    `Bearer` 前缀），并在 `VALUE` 列中添加带有令牌的 `Authorization` 标头。参考以下屏幕截图中的示例，其中对 `/cars`
    端点执行了一个 `GET` 请求：
- en: '![](img/B19818_05_13.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19818_05_13.png)'
- en: 'Figure 5.13: Authenticated GET request'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13：认证 GET 请求
- en: Each time the application is restarted, you must authenticate again because
    a new JWT is generated.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 每次应用程序重启时，你必须重新认证，因为会生成一个新的 JWT。
- en: The JWT is not valid forever because an expiration date was set for it. In our
    case, we set a long expiration time for demonstration purposes. In production,
    the time should preferably be minutes, depending on the use case.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 不是永远有效的，因为它被设置了一个过期日期。在我们的例子中，为了演示目的，我们设置了一个较长的过期时间。在生产环境中，时间应该根据用例最好设置为分钟。
- en: Handling exceptions
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理异常
- en: 'We should also handle exceptions in the authentication. At the moment, if you
    try to log in using the wrong password, you get a `403 Forbidden` status without
    any further clarification. Spring Security provides an `AuthenticationEntryPoint`
    interface that can be used to handle exceptions. Let’s see how it works:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该在认证中处理异常。目前，如果你尝试使用错误的密码登录，你会收到一个没有进一步说明的 `403 Forbidden` 状态。Spring Security
    提供了一个 `AuthenticationEntryPoint` 接口，可以用来处理异常。让我们看看它是如何工作的：
- en: 'Create a new class named `AuthEntryPoint` in the root package that implements
    `AuthenticationEntryPoint`. We will implement the `commence` method, which gets
    an exception as a parameter. In the case of an exception, we set the response
    status to `401 Unauthorized` and write an exception message to the response body.
    The code is illustrated in the following snippet:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根包中创建一个名为`AuthEntryPoint`的新类，该类实现了`AuthenticationEntryPoint`接口。我们将实现`commence`方法，该方法接受一个异常作为参数。在异常的情况下，我们将响应状态设置为`401
    Unauthorized`并将异常消息写入响应体。代码如下所示：
- en: '[PRE25]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we have to configure Spring Security for the exception handling. Inject
    our `AuthEntryPoint` class into the `SecurityConfig` class, as shown in the following
    highlighted code:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须为异常处理配置Spring Security。将我们的`AuthEntryPoint`类注入到`SecurityConfig`类中，如下所示的高亮代码：
- en: '[PRE26]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, modify the `filterChain` method as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按照以下方式修改`filterChain`方法：
- en: '[PRE27]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, if you send a login `POST` request with the wrong credentials, you will
    get a `401 Unauthorized` status in the response and an error message in the body,
    as shown in the following screenshot:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果您发送一个带有错误凭证的登录`POST`请求，您将在响应中获得`401 Unauthorized`状态和一个错误消息，如下面的屏幕截图所示：
- en: '![](img/B19818_05_14.png)Figure 5.14: Bad credentials'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/B19818_05_14.png)图5.14：无效凭证'
- en: Adding a CORS filter
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加CORS过滤器
- en: We will also add a **cross-origin resource sharing** (**CORS**) filter to our
    security configuration class. CORS introduces certain headers that help the client
    and server decide if cross-origin requests should be allowed or denied. The CORS
    filter is needed for the frontend, which is sending requests from the other origin.
    The CORS filter intercepts requests, and if these are identified as cross-origin,
    it adds proper headers to the request. For that, we will use Spring Security’s
    `CorsConfigurationSource` interface.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将向我们的安全配置类添加一个**跨源资源共享**（**CORS**）过滤器。CORS引入了一些帮助客户端和服务器决定是否允许或拒绝跨源请求的头部。CORS过滤器对于前端是必需的，前端从其他来源发送请求。CORS过滤器拦截请求，如果这些请求被识别为跨源，它会在请求中添加适当的头部。为此，我们将使用Spring
    Security的`CorsConfigurationSource`接口。
- en: 'In this example, we will allow all origins’ HTTP methods and headers. You can
    define a list of permissible origins, methods, and headers here if you require
    a more finely graded definition. Let’s begin:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将允许所有来源的HTTP方法和头。如果您需要一个更精细的定义，您可以在以下位置定义一个允许的来源、方法和头列表。让我们开始吧：
- en: 'Add the following imports and methods to your `SecurityConfig` class to enable
    the CORS filter:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下导入和方法添加到您的`SecurityConfig`类中，以启用CORS过滤器：
- en: '[PRE28]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you want to explicitly define the origins, you can set this in the following
    way:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您想明确定义来源，您可以按照以下方式设置：
- en: '[PRE29]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We also have to add the `cors()` function to the `filterChain` method, as shown
    in the following code snippet:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须在`filterChain`方法中添加`cors()`函数，如下面的代码片段所示：
- en: '[PRE30]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, we have secured our backend. In the next section, we will introduce the
    basics of role-based security, which you can use to get more fine-grained access
    control in your Spring Boot application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经确保了我们的后端安全。在下一节中，我们将介绍基于角色的安全基础，您可以使用它来在您的Spring Boot应用程序中获得更细粒度的访问控制。
- en: Role-based security
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于角色的安全
- en: In Spring Security, **roles** can be used to define coarse-grained role-based
    security, and users can be assigned to one or multiple roles. Roles often have
    a hierarchical structure, for example, `ADMIN`, `MANAGER`, `USER`. Spring Security
    also provides **authorities**, which can be used for more fine-grained access
    control. We have defined simple roles for our users, `ADMIN` and `USER`, and we
    don’t use role-based security in our sample backend application. This section
    introduces the different ways to implement role-based security in your Spring
    Boot applications.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Security中，**角色**可以用来定义粗粒度的基于角色的安全，用户可以被分配到一个或多个角色。角色通常具有层次结构，例如，`ADMIN`、`MANAGER`、`USER`。Spring
    Security还提供了**权限**，可以用于更细粒度的访问控制。我们已经为我们的用户定义了简单的角色`ADMIN`和`USER`，在我们的示例后端应用程序中我们没有使用基于角色的安全。本节介绍了在您的Spring
    Boot应用程序中实现基于角色安全的不同方法。
- en: 'You can define role-based access control at the request level in your security
    configuration class. In the following example code, we define which endpoints
    require specific roles for access. The `/admin/**` endpoint requires the `ADMIN`
    role for access and the `/user/**` endpoint requires the `USER` role for access.
    We use the Spring Security `hasRole()` method, which returns true if the user
    has the specified role:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的安全配置类中在请求级别定义基于角色的访问控制。在下面的示例代码中，我们定义了哪些端点需要特定的角色才能访问。`/admin/**` 端点需要
    `ADMIN` 角色才能访问，而 `/user/**` 端点需要 `USER` 角色才能访问。我们使用 Spring Security 的 `hasRole()`
    方法，如果用户具有指定的角色则返回 true：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can read more about request authorization in the Spring Boot documentation:
    https://docs.spring.io/spring-security/reference/servlet/authorization/authorize-http-requests.html.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Spring Boot 文档中了解更多关于请求授权的信息：https://docs.spring.io/spring-security/reference/servlet/authorization/authorize-http-requests.html。
- en: 'Spring Security provides the `@PreAuthorize`, `@PostAuthorize`, `@PreFilter`,
    `@PostFilter`, and `@Secured` annotations, which are used to apply **method-level
    security**. Method-level security is not enabled by default in `spring-boot-starter-security`.
    You have to enable it in your Spring configuration class, for example, in top-level
    configuration, by using the `@EnableMethodSecurity` annotation:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 提供了 `@PreAuthorize`、`@PostAuthorize`、`@PreFilter`、`@PostFilter`
    和 `@Secured` 注解，用于应用**方法级安全**。在 `spring-boot-starter-security` 中默认不启用方法级安全。你必须在你的
    Spring 配置类中启用它，例如，在顶级配置中，通过使用 `@EnableMethodSecurity` 注解：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, you will be able to use the method-level security annotations in your
    methods. In the following example, users with the `USER` role can execute the
    `updateCar()` method and users with the `ADMIN` role can execute the `deleteOwner()`
    method. The `@PreAuthorize` annotation checks the rule before the method is executed.
    If the user does not have a specified role, Spring Security prevents method execution,
    and an `AccessDeniedException` is thrown:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将能够在你的方法中使用方法级安全注解。在下面的示例中，具有 `USER` 角色的用户可以执行 `updateCar()` 方法，而具有 `ADMIN`
    角色的用户可以执行 `deleteOwner()` 方法。`@PreAuthorize` 注解在方法执行前检查规则。如果用户没有指定的角色，Spring Security
    会阻止方法执行，并抛出 `AccessDeniedException`：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `@PreAuthorize` annotation replaces the `@Secured` annotation, and its use
    is recommended instead.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PreAuthorize` 注解取代了 `@Secured` 注解，并建议使用它。'
- en: The `@PostAuthorize` annotation can be used to check authorization after the
    method is executed. You can use this, for example, to check that the user has
    permission to access the object that the method returns, or you can filter the
    data returned based on the user’s authorization.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PostAuthorize` 注解可以在方法执行后用于检查授权。例如，你可以用它来检查用户是否有权限访问方法返回的对象，或者你可以根据用户的授权来过滤返回的数据。'
- en: The `@PreFilter` and `@PostFilter` annotations can be used to filter lists of
    objects, but they are not typically used for role-based access control. The rules
    used with these annotations are more fine-grained.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PreFilter` 和 `@PostFilter` 注解可以用来过滤对象列表，但它们通常不用于基于角色的访问控制。与这些注解一起使用的规则更为细致。'
- en: 'You can read more about method security in the Spring Security documentation:
    [https://docs.spring.io/spring-security/reference/servlet/authorization/method-security.html](https://docs.spring.io/spring-security/reference/servlet/authorization/method-security.html).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Spring Security 文档中了解更多关于方法安全的信息：[https://docs.spring.io/spring-security/reference/servlet/authorization/method-security.html](https://docs.spring.io/spring-security/reference/servlet/authorization/method-security.html)。
- en: In the next section, we will introduce the basics of OAuth with Spring Boot.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍使用 Spring Boot 的 OAuth 基础知识。
- en: Using OAuth2 with Spring Boot
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OAuth2 和 Spring Boot
- en: It is really challenging to implement fully secure authentication and authorization
    in your application. In a production environment, it is recommended that you do
    it using an OAuth2 provider. This actually simplifies the authentication process,
    and providers typically have excellent security practices.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中完全实现安全的认证和授权是非常具有挑战性的。在生产环境中，建议使用 OAuth2 提供商来实现。这实际上简化了认证过程，并且提供商通常有出色的安全实践。
- en: These are not detailed instructions for implementing OAuth 2.0 authorization,
    but they will give you an idea of the process.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不是实现 OAuth 2.0 授权的详细说明，但它们会给你一个关于该过程的概念。
- en: '**OAuth** (**Open Authorization**) is a standard for secure access to protected
    resources on the internet. The OAuth standard version 2.0 is commonly used nowadays.
    There are several OAuth 2.0 providers that implement OAuth authorization for third-party
    applications. Some common providers are listed here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**OAuth**（**开放授权**）是用于互联网上受保护资源的安全访问的标准。OAuth 标准版本 2.0 现在普遍使用。有几个 OAuth 2.0
    提供商实现了第三方应用程序的 OAuth 授权。以下列出了一些常见的提供商：'
- en: 'Auth0: [https://auth0.com/](https://auth0.com/)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Auth0: [https://auth0.com/](https://auth0.com/)'
- en: 'Okta: [https://www.okta.com/](https://www.okta.com/)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Okta: [https://www.okta.com/](https://www.okta.com/)'
- en: 'Keycloak: [https://www.keycloak.org/](https://www.keycloak.org/)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Keycloak: [https://www.keycloak.org/](https://www.keycloak.org/)'
- en: You can implement social logins using OAuth2, after which users can log in with
    their existing credentials from social media platforms such as Facebook. OAuth
    also defines mechanisms for revoking access tokens and handling token expiration.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 OAuth2 实现社交登录，之后用户可以使用来自社交媒体平台（如 Facebook）的现有凭据登录。OAuth 还定义了撤销访问令牌和处理令牌过期的机制。
- en: If you want to use OAuth in your Spring Boot applications, the first step is
    to select an OAuth provider. All providers in the list above can be used with
    your Spring Boot applications.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在 Spring Boot 应用程序中使用 OAuth，第一步是选择一个 OAuth 提供商。上述列表中的所有提供商都可以与您的 Spring
    Boot 应用程序一起使用。
- en: In the OAuth2 process, the term **resource owner** refers typically to an end
    user and the **authorization server** is part of the OAuth provider’s service.
    The **client** is an application that wants to get access to protected resources.
    The **resource server** commonly refers to an API that the client wants to use.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OAuth2 过程中，术语 **资源所有者** 通常指最终用户，而 **授权服务器** 是 OAuth 提供商服务的一部分。**客户端** 是一个希望访问受保护资源的应用程序。**资源服务器**
    通常指客户端希望使用的 API。
- en: 'The simplified version of the OAuth2 authentication process with a REST API
    contains the following steps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 REST API 的 OAuth2 认证过程的简化版本包含以下步骤：
- en: 'Authentication: The third-party application authenticates by requesting access
    to protected resources.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认证：第三方应用程序通过请求访问受保护资源来进行认证。
- en: 'Authorization: The resource owner authorizes access to their resources, commonly
    through user login.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权：资源所有者授权访问其资源，通常通过用户登录。
- en: The authorization server authorizes the resource owner and redirects the user
    back to the client with an authorization code.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器授权资源所有者，并使用授权码将用户重定向回客户端。
- en: The client requests an access token from the authorization server using the
    authorization code. The access token format is not specified in the standard,
    and JWTs are quite commonly used.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端使用授权码从授权服务器请求访问令牌。访问令牌的格式在标准中未指定，JWT 非常常用。
- en: The authorization server validates the access token. If the token is valid,
    the client application receives an access token.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器验证访问令牌。如果令牌有效，客户端应用程序将收到访问令牌。
- en: The client can start to use the access token to access protected resources,
    for example, calling REST API endpoints.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端可以使用访问令牌开始访问受保护资源，例如，调用 REST API 端点。
- en: After you have selected a provider and know how its service works, you have
    to configure your Spring Boot application. Spring Boot provides the `spring-boot-starter-oauth2-client`
    dependency for OAuth2 authentication and authorization. It is used to simplify
    OAuth 2.0 integration in your Spring Boot application. Quite a few OAuth providers
    have documentation for different technologies, such as Spring Boot.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在您选择了提供商并了解了其服务的工作方式后，您必须配置您的 Spring Boot 应用程序。Spring Boot 提供了 `spring-boot-starter-oauth2-client`
    依赖项，用于 OAuth2 认证和授权。它用于简化 Spring Boot 应用程序中的 OAuth 2.0 集成。许多 OAuth 提供商为不同的技术提供了文档，例如
    Spring Boot。
- en: 'The implementation will differ depending on the provider. Here are some useful
    links:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 实现将取决于提供商。以下是一些有用的链接：
- en: 'Auth0 has a good tutorial for how to add login to your Spring Boot application:
    [https://auth0.com/docs/quickstart/webapp/java-spring-boot/interactive](https://auth0.com/docs/quickstart/webapp/java-spring-boot/interactive).'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Auth0 提供了一个很好的教程，介绍如何将登录添加到您的 Spring Boot 应用程序中：[https://auth0.com/docs/quickstart/webapp/java-spring-boot/interactive](https://auth0.com/docs/quickstart/webapp/java-spring-boot/interactive).
- en: 'Baeldung provides a quick guide to using Keycloak with Spring Boot applications:
    [https://www.baeldung.com/spring-boot-keycloak](https://www.baeldung.com/spring-boot-keycloak).'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Baeldung 提供了使用 Spring Boot 应用程序与 Keycloak 一起使用的快速指南：[https://www.baeldung.com/spring-boot-keycloak](https://www.baeldung.com/spring-boot-keycloak).
- en: 'Spring also has a tutorial on how to implement social login using GitHub: https://spring.io/guides/tutorials/spring-boot-oauth2.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 还有一个关于如何使用 GitHub 实现社交登录的教程：https://spring.io/guides/tutorials/spring-boot-oauth2。
- en: We recommend reading these to get a better idea of using OAuth 2.0 in your own
    applications.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议阅读这些内容，以更好地了解如何在您的应用程序中使用 OAuth 2.0。
- en: Now, we have finished securing our backend using the JWT, and we will use this
    version when we start to develop our frontend.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经使用 JWT 完成了后端的保护，当我们开始开发前端时，我们将使用这个版本。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused on making our Spring Boot backend more secure. We
    started by adding extra protection using Spring Security. Then, we implemented
    JWT authentication. JWTs are commonly used to secure RESTful APIs and it is a
    lightweight authentication method suitable for our needs. We also covered the
    basics of the OAuth 2.0 standard and how to start using it in your Spring Boot
    application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于使我们的 Spring Boot 后端更加安全。我们首先通过使用 Spring Security 添加额外的保护。然后，我们实现了
    JWT 认证。JWT 通常用于保护 RESTful API，它是一种轻量级的认证方法，适合我们的需求。我们还介绍了 OAuth 2.0 标准的基础知识以及如何在
    Spring Boot 应用程序中开始使用它。
- en: In the next chapter, we will learn the basics of testing in Spring Boot applications.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习在 Spring Boot 应用程序中进行测试的基础知识。
- en: Questions
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is Spring Security?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Security 是什么？
- en: How can you secure your backend with Spring Boot?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用 Spring Boot 保护您的后端？
- en: What is a JWT?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JWT 是什么？
- en: How can you secure your backend with a JWT?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用 JWT 保护您的后端？
- en: What is OAuth 2.0?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OAuth 2.0 是什么？
- en: Further reading
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Packt has other resources available for you to learn about Spring Security.
    For instance:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Packt 为您提供了其他资源，以了解 Spring Security。例如：
- en: '*Spring Security Core: Beginner to Guru,* by John Thompson ([https://www.packtpub.com/product/spring-security-core-beginner-to-guru-video/9781800560000](https://www.packtpub.com/product/spring-security-core-beginner-to-guru-video/9781800560000))'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Spring Security Core：从入门到精通》，作者：约翰·汤普森* ([https://www.packtpub.com/product/spring-security-core-beginner-to-guru-video/9781800560000](https://www.packtpub.com/product/spring-security-core-beginner-to-guru-video/9781800560000))'
- en: Learn more on Discord
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask the author questions, and learn about new releases – follow the QR code below:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里您可以分享反馈、向作者提问以及了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
- en: '![](img/QR_Code107961080093826402.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code107961080093826402.png)'
