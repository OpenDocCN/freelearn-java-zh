- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing Your Backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explains how to secure your Spring Boot backend. Securing your
    backend is a crucial part of code development. It is essential for protecting
    sensitive data, complying with regulations, and preventing unauthorized access.
    The backend often handles the user authentication and authorization process. Securing
    these aspects properly ensures that only authorized users can access the application
    and perform specific actions. We will use the database application that we created
    in the previous chapter as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Spring Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing your backend with a JSON Web Token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role-based security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using OAuth2 with Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Boot application that we created in the previous chapters is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following GitHub link will also be required: [https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Spring Security** (https://spring.io/projects/spring-security) provides security
    services for Java-based web applications. The Spring Security project was started
    in 2003 and was previously named *Acegi Security System for Spring*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Spring Security enables the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: An `AuthenticationManager` bean with an in-memory single user. The username
    is `user` and the password is printed to the console output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignored paths for common static resource locations, such as `/css` and `/images`.
    HTTP basic authentication for all other endpoints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security events published to Spring’s `ApplicationEventPublisher` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common low-level features turned on by default, including **HTTP Strict Transport
    Security** (**HSTS**), **cross-site scripting** (**XSS**), and **cross-site request
    forgery** (**CSRF**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A default autogenerated login page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can include Spring Security in your application by adding the following
    highlighted dependencies to the `build.gradle` file. The first dependency is for
    the application and the second is for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you haven’t enabled automatic refresh, remember to refresh the Gradle project
    from Eclipse after you have modified your `build.gradle` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you start your application, you can see from the console that Spring Security
    has created an in-memory user with a username of `user`. The user’s password can
    be seen in the console output, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Spring Security enabled'
  prefs: []
  type: TYPE_NORMAL
- en: If there is no password in the console, try to restart your project by pressing
    the red **Terminate** button in the console and re-running it.
  prefs: []
  type: TYPE_NORMAL
- en: The Eclipse console has limited output, and the default buffer size is 80,000
    characters, so the output might be truncated before the password statement can
    appear. You can change this setting from the **Window | Preferences | Run/Debug
    | Console** menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you make a `GET` request to your REST API root endpoint, you will see
    that it has been secured. Open your web browser and navigate to `http://localhost:8080/api`.
    You will be redirected to the Spring Security default login page, as illustrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Secured REST API'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to make a successful `GET` request, we have to authenticate to our
    RESTful API. Type `user` into the **Username** field and copy the generated password
    from the console to the **Password** field. With authentication, we can see that
    the response contains our API resources, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Basic authentication'
  prefs: []
  type: TYPE_NORMAL
- en: To configure how Spring Security behaves, we have to add a new configuration
    class for Spring Security. The security configuration file can be used to define
    which URLs or URL patterns are accessible to which roles or users. You can also
    define the authentication mechanism, the login process, session management, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `SecurityConfig` in your application root package
    (`com.packt.cardatabase`). The following source code shows the structure of the
    security configuration class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `@Configuration` and `@EnableWebSecurity` annotations switch off the default
    web security configuration, and we can define our own configuration in this class.
    Inside the `filterChain(HttpSecurity http)` method that we will see in action
    later, we can define which endpoints in our application are secure and which are
    not. We don’t actually need this method yet because we can use the default settings
    where all the endpoints are secured.
  prefs: []
  type: TYPE_NORMAL
- en: We can also add in-memory users to our application by using Spring Security’s
    `InMemoryUserDetailsManager`,which implements `UserDetailsService`. Then we can
    implement user/password authentication that is stored in memory. We can also use
    `PasswordEncoder` to encode passwords using the `bcrypt` algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following highlighted source code will create an in-memory user with a
    username of `user`, a password of `password`, and a role of `USER`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, restart the application, and you will be able to test authentication using
    the in-memory user. The use of in-memory users is fine in the development phase,
    but a proper application should save users in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To save users to the database, you have to create a user entity class and repository.
    Passwords shouldn’t be saved to the database in plaintext format. If a database
    containing user passwords is hacked, attackers will be able to get the passwords
    directly in plaintext. Spring Security provides multiple hashing algorithms, such
    as `bcrypt`, that you can use to hash passwords. The following steps show you
    how to implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `AppUser` in the `com.packt.cardatabase.domain` package.
    Activate the domain package and right-click it. Select **New** | **Class** from
    the menu and name the new class `User`. After that, your project structure should
    look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_05_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Project structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Annotate the `AppUser` class with the `@Entity` annotation. Add the ID, username,
    password, and role class fields. Finally, add the constructors, getters, and setters.
    We will set all the fields to be not `nullable`. This means that database columns
    cannot hold `null` values. We will also specify that the username must be unique
    by using `unique=true` in the username’s `@Column` annotation. Refer to the following
    `AppUser.java` source code for the fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the `AppUser.java` constructors source code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the `AppUser.java` source code with the getters and setters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new interface called `AppUserRepository` in the domain package. To
    do this, activate the domain package and right-click it. Select **New** | **Interface**
    from the menu and name it `AppUserRepository`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source code for the repository class is similar to what we saw in the previous
    chapter, but there is one query method, `findByUsername`, that we need for the
    steps that follow. This method is used to find a `user` from the database in the
    authentication process. The method returns `Optional` to prevent a null exception.
    Refer to the following `AppUserRepository` source code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create a class that implements the `UserDetailsService` interface
    that’s provided by Spring Security. Spring Security uses this for user authentication
    and authorization. Create a new `service` package in the root package. To do this,
    activate the root package and right-click it. Select **New** | **Package** from
    the menu and name the new package `service`, as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_05_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: The service package'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `UserDetailsServiceImpl` in the `service` package
    we just created. Now, your project structure should look like this (in Eclipse,
    refresh the Project Explorer by pressing *F5*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_05_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Project structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to inject the `AppUserRepository` class into the `UserDetailsServiceImpl`
    class because it is needed to fetch the user from the database when Spring Security
    handles authentication. The `findByUsername` method that we implemented earlier
    returns `Optional`, therefore we can use the `isPresent()` method to check if
    the `user` exists. If the `user` doesn’t exist, we throw a `UsernameNotFoundException`
    exception. The `loadUserByUsername` method returns the `UserDetails` object, which
    is required for authentication. We are using the Spring Security `UserBuilder`
    class to build the user for the authentication. Here is the source code for `UserDetailsServiceImpl.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our security configuration class, we have to specify that Spring Security
    should use users from the database instead of in-memory users. Delete the `userDetailsService()`
    method from the `SecurityConfig` class to disable in-memory users. Add a new `configureGlobal`
    method to enable users from the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We should never save the password as plaintext to the database. Therefore,
    we will define a password hashing algorithm in the `configureGlobal` method. In
    this example, we are using the `bcrypt` algorithm. This can be easily implemented
    with the Spring Security `BCryptPasswordEncoder` class, which encodes a hashed
    password during the authentication process. Here is the `SecurityConfig.java`
    source code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, the password must be hashed using `bcrypt` before it’s saved to the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we can save a couple of test users to the database using the `CommandLineRunner`
    interface. Open the `CardatabaseApplication.java` file and inject `AppUserRepository`
    into the main class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s save two users to the database with `bcrypt` hashed passwords. You can
    find `bcrypt` calculators or generators on the internet. These generators allow
    you to input a plaintext password, and they will produce the corresponding `bcrypt`
    hash:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**bcrypt** is a strong hashing function that was designed by Niels Provos and
    David Mazières. Here is an example of a bcrypt hash that is generated from the
    `admin` string:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$2a$10$8cjz47bjbR4Mn8GMg9IZx.vyjhLXR/SKKMSZ9.mP9vpMu0ssKi8GW`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$2a` represents the algorithm version, and `$10` represents the strength of
    the algorithm. The default strength of Spring Security’s `BcryptPasswordEncoder`
    class is 10\. bcrypt generates a random **salt** in hashing, so the hashed result
    is always different.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After running your application, you will see that there is now an `app_user`
    table in the database and that two user records are saved with hashed passwords,
    as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_05_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: Users'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should restart the application and you will get a `401 Unauthorized`
    error if you try to send a `GET` request to the `http://localhost:8080/api` path
    without authentication. You must authenticate to be able to send a successful
    request. The difference, when compared with the previous example, is that we are
    using the users from the database to authenticate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you can log in by sending a `GET` request to the `/api` endpoint using
    the browser, or we can use Postman and basic authentication, as shown in the following
    screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B19818_05_08.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.8: GET request authentication'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can see that we currently get users by calling the `api/appUsers` endpoint
    in our RESTful web service, which is something we want to avoid. As mentioned
    in *Chapter 4*, Spring Data REST generates a RESTful web service from all public
    repositories by default. We can use the `exported` flag of the `@RepositoryRestResource`
    annotation and set it to `false`, which means the following repository is not
    exposed as a REST resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, if you restart the application and send a `GET` request to the `/api` endpoint,
    you will see that the `/appUsers` endpoint is not visible anymore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will start to implement authentication using a JSON Web Token.
  prefs: []
  type: TYPE_NORMAL
- en: Securing your backend with a JSON Web Token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we covered how to use basic authentication with a RESTful
    web service. Basic authentication doesn’t provide a way to handle tokens or manage
    sessions. When a user logs in, the credentials are sent with each request, which
    can cause session management challenges and potential security risks. This method
    is not usable when we develop our own frontend with React, so we are going to
    use **JSON Web Token** (**JWT**) authentication instead (https://jwt.io/). This
    will also give you an idea of how you can configure Spring Security in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The other option for securing your RESTful web service is **OAuth 2**. OAuth2
    (https://oauth.net/2/) is the industry standard for authorization and it can be
    used quite easily in Spring Boot applications. There is a section later on in
    the chapter that will give you a basic idea about how to use it in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: JWTs are commonly used in RESTful APIs for authentication and authorization
    purposes. They are a compact way to implement authentication in modern web applications.
    A JWT is really small in size and can therefore be sent in the URL, in the `POST`
    parameter, or inside the header. It also contains all the necessary information
    about the user, such as their username and role.
  prefs: []
  type: TYPE_NORMAL
- en: 'A JWT contains three different parts, separated by dots: `xxxxx.yyyyy.zzzzz`.
    These parts are broken up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first part (`xxxxx`) is the **header,** which defines the type of token
    and the hashing algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second part (`yyyyy`) is the **payload,** which, typically, in the case
    of authentication, contains user information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third part (`zzzzz`) is the **signature,** which is used to verify that
    the token hasn’t been changed along the way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of a JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows a simplified representation of the authentication
    process using a JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_05_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: JWT authentication process'
  prefs: []
  type: TYPE_NORMAL
- en: After successful authentication, the requests sent by the client should always
    contain the JWT that was received in the authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use `jjwt` (https://github.com/jwtk/jjwt), which is the JWT library
    for Java and Android for creating and parsing JWTs. Therefore, we have to add
    the following dependencies to the `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Remember to refresh the Gradle project from Eclipse after you have updated the
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The following steps demonstrate how to enable JWT authentication in our backend.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the login
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start with the login functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a class that generates and verifies a signed JWT. Create
    a new class called `JwtService` in the `com.packt.cardatabase.service` package.
    At the beginning of the class, we will define a few constants: `EXPIRATIONTIME`
    defines the expiration time of the token in milliseconds, `PREFIX` defines the
    prefix of the token, and the `"Bearer"` schema is typically used. A JWT is sent
    in the `Authorization` header and the content of the header looks like the following
    when using the Bearer schema:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `JwtService` source code looks like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will create a secret key using the `jjwt` library’s `secretKeyFor` method.
    This is only for demonstration purposes. In a production environment, you should
    read your secret key from the application configuration. The `getToken` method
    then generates and returns the token. The `getAuthUser` method gets the token
    from the response `Authorization` header. Then, we will use the `parserBuilder`
    method provided by the `jjwt` library to create a `JwtParserBuilder` instance.
    The `setSigningKey` method is used to specify a secret key for token verification.
    The `parseClaimsJws` method removes the `Bearer` prefix from the `Authorization`
    header. Finally, we will use the `getSubject` method to get the username. The
    whole `JwtService` source code follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we will add a new class to store credentials for authentication. Here
    we can use a Java **record**, which was introduced in Java 14\. A record is a
    good choice if you need a class that only holds data; you can avoid a lot of boilerplate
    code. Create a new record (**New** | **Record**) called `AccountCredentials` in
    the `com.packt.cardatabase.domain` package:![](img/B19818_05_10.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 5.10: Create a new record'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The record has two fields: `username` and `password`. Here is the source code
    for the record. As you can see, we don’t have to write getters and setters when
    using it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will implement the `controller` class for login. Login is done by calling
    the `/login` endpoint using the `POST` method and sending the username and password
    inside the request body. Create a class called `LoginController` inside the `com.packt.cardatabase.web`
    package. We have to inject a `JwtService` instance into the controller class because
    that is used to generate a signed JWT in the case of a successful login. The code
    is illustrated in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will implement the `getToken` method that handles the login functionality.
    We get a JSON object from the request body that contains the username and password.
    `AuthenticationManager` is used to perform authentication and it uses credentials
    that we get from the request. Then, we use the `JwtService` class’ `getToken`
    method to generate a JWT. Finally, we build an HTTP response that contains the
    generated JWT in the `Authorization` header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have also injected `AuthenticationManager` into the `LoginController` class,
    therefore we have to add the following highlighted code to the `SecurityConfig`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this step, we have to configure Spring Security functionality. Spring Security’s
    `SecurityFilterChain` bean defines which paths are secured and which are not.
    Add the following `filterChain` method to the `SecurityConfig` class. In the method,
    we define that the `POST` method request to the `/login` endpoint is allowed without
    authentication and that requests to all other endpoints require authentication.
    We will also define that Spring Security will never create a session, and therefore
    we can disable cross-site request forgery (`csrf`). JWTs are designed to be stateless,
    which reduces the risk of session-related vulnerabilities. We will use Lambdas
    in the HTTP security configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In some other programming languages, Lambdas are called **anonymous functions**.
    The usage of Lambdas makes code more readable and reduces boilerplate code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we are ready to test our login functionality. Open Postman and make
    a `POST` request to the `http://localhost:8080/login` URL. Define a valid user
    inside the request body, for example, `{"username":"user", "password":"user"}`
    and select **JSON** from the drop-down list. Postman will then set the `Content-Type`
    header to `application/json` automatically. You should check from the **Headers**
    tab that the `Content-Type` header is set correctly. Now, you should see an `Authorization`
    header in the response that contains the signed JWT, like the one shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_05_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.11: Login request'
  prefs: []
  type: TYPE_NORMAL
- en: You can also test the login by using the wrong password and seeing that the
    response doesn’t contain the `Authorization` header.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the other requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now finalized the login step, and we will move on to handling authentication
    for the rest of the incoming requests. In the authentication process, we are using
    **filters** that allow us to perform some operations before a request goes to
    the controller or before a response is sent to a client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps demonstrate the rest of the authentication process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a filter class to authenticate all other incoming requests. Create
    a new class called `AuthenticationFilter` in the root package. The `AuthenticationFilter`
    class extends Spring Security’s `OncePerRequestFilter` interface, which provides
    a `doFilterInternal` method where we implement our authentication. We have to
    inject a `JwtService` instance into the filter class because it is needed to verify
    a token from the request. The `SecurityContextHolder` is where Spring Security
    stores the details of the authenticated user. The code is illustrated in the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we have to add our filter class to the Spring Security configuration.
    Open the `SecurityConfig` class and inject the `AuthenticationFilter` class that
    we just implemented, as shown in the highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, modify the `filterChain` method in the `SecurityConfig` class and add
    the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we are ready to test the whole workflow. After we run the application,
    we can first log in by calling the `/login` endpoint with the `POST` method and,
    in the case of a successful login, we will receive a JWT in the `Authorization`
    header. Remember to add a valid user inside the body and set the `Content-Type`
    header to `application/json` if it is not done automatically by Postman. The following
    screenshot illustrates the process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_05_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: Login request'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following a successful login, we can call the other RESTful service endpoints
    by sending the JWT that was received from the login in the `Authorization` header.
    Copy the token from the login response (without the `Bearer` prefix) and add the
    `Authorization` header with the token in the `VALUE` column. Refer to the example
    in the following screenshot where a `GET` request to the `/cars` endpoint is done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_05_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.13: Authenticated GET request'
  prefs: []
  type: TYPE_NORMAL
- en: Each time the application is restarted, you must authenticate again because
    a new JWT is generated.
  prefs: []
  type: TYPE_NORMAL
- en: The JWT is not valid forever because an expiration date was set for it. In our
    case, we set a long expiration time for demonstration purposes. In production,
    the time should preferably be minutes, depending on the use case.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should also handle exceptions in the authentication. At the moment, if you
    try to log in using the wrong password, you get a `403 Forbidden` status without
    any further clarification. Spring Security provides an `AuthenticationEntryPoint`
    interface that can be used to handle exceptions. Let’s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class named `AuthEntryPoint` in the root package that implements
    `AuthenticationEntryPoint`. We will implement the `commence` method, which gets
    an exception as a parameter. In the case of an exception, we set the response
    status to `401 Unauthorized` and write an exception message to the response body.
    The code is illustrated in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we have to configure Spring Security for the exception handling. Inject
    our `AuthEntryPoint` class into the `SecurityConfig` class, as shown in the following
    highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, modify the `filterChain` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if you send a login `POST` request with the wrong credentials, you will
    get a `401 Unauthorized` status in the response and an error message in the body,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_05_14.png)Figure 5.14: Bad credentials'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a CORS filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will also add a **cross-origin resource sharing** (**CORS**) filter to our
    security configuration class. CORS introduces certain headers that help the client
    and server decide if cross-origin requests should be allowed or denied. The CORS
    filter is needed for the frontend, which is sending requests from the other origin.
    The CORS filter intercepts requests, and if these are identified as cross-origin,
    it adds proper headers to the request. For that, we will use Spring Security’s
    `CorsConfigurationSource` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will allow all origins’ HTTP methods and headers. You can
    define a list of permissible origins, methods, and headers here if you require
    a more finely graded definition. Let’s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following imports and methods to your `SecurityConfig` class to enable
    the CORS filter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want to explicitly define the origins, you can set this in the following
    way:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also have to add the `cors()` function to the `filterChain` method, as shown
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we have secured our backend. In the next section, we will introduce the
    basics of role-based security, which you can use to get more fine-grained access
    control in your Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: Role-based security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Spring Security, **roles** can be used to define coarse-grained role-based
    security, and users can be assigned to one or multiple roles. Roles often have
    a hierarchical structure, for example, `ADMIN`, `MANAGER`, `USER`. Spring Security
    also provides **authorities**, which can be used for more fine-grained access
    control. We have defined simple roles for our users, `ADMIN` and `USER`, and we
    don’t use role-based security in our sample backend application. This section
    introduces the different ways to implement role-based security in your Spring
    Boot applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define role-based access control at the request level in your security
    configuration class. In the following example code, we define which endpoints
    require specific roles for access. The `/admin/**` endpoint requires the `ADMIN`
    role for access and the `/user/**` endpoint requires the `USER` role for access.
    We use the Spring Security `hasRole()` method, which returns true if the user
    has the specified role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can read more about request authorization in the Spring Boot documentation:
    https://docs.spring.io/spring-security/reference/servlet/authorization/authorize-http-requests.html.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security provides the `@PreAuthorize`, `@PostAuthorize`, `@PreFilter`,
    `@PostFilter`, and `@Secured` annotations, which are used to apply **method-level
    security**. Method-level security is not enabled by default in `spring-boot-starter-security`.
    You have to enable it in your Spring configuration class, for example, in top-level
    configuration, by using the `@EnableMethodSecurity` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you will be able to use the method-level security annotations in your
    methods. In the following example, users with the `USER` role can execute the
    `updateCar()` method and users with the `ADMIN` role can execute the `deleteOwner()`
    method. The `@PreAuthorize` annotation checks the rule before the method is executed.
    If the user does not have a specified role, Spring Security prevents method execution,
    and an `AccessDeniedException` is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `@PreAuthorize` annotation replaces the `@Secured` annotation, and its use
    is recommended instead.
  prefs: []
  type: TYPE_NORMAL
- en: The `@PostAuthorize` annotation can be used to check authorization after the
    method is executed. You can use this, for example, to check that the user has
    permission to access the object that the method returns, or you can filter the
    data returned based on the user’s authorization.
  prefs: []
  type: TYPE_NORMAL
- en: The `@PreFilter` and `@PostFilter` annotations can be used to filter lists of
    objects, but they are not typically used for role-based access control. The rules
    used with these annotations are more fine-grained.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about method security in the Spring Security documentation:
    [https://docs.spring.io/spring-security/reference/servlet/authorization/method-security.html](https://docs.spring.io/spring-security/reference/servlet/authorization/method-security.html).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will introduce the basics of OAuth with Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: Using OAuth2 with Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is really challenging to implement fully secure authentication and authorization
    in your application. In a production environment, it is recommended that you do
    it using an OAuth2 provider. This actually simplifies the authentication process,
    and providers typically have excellent security practices.
  prefs: []
  type: TYPE_NORMAL
- en: These are not detailed instructions for implementing OAuth 2.0 authorization,
    but they will give you an idea of the process.
  prefs: []
  type: TYPE_NORMAL
- en: '**OAuth** (**Open Authorization**) is a standard for secure access to protected
    resources on the internet. The OAuth standard version 2.0 is commonly used nowadays.
    There are several OAuth 2.0 providers that implement OAuth authorization for third-party
    applications. Some common providers are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Auth0: [https://auth0.com/](https://auth0.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Okta: [https://www.okta.com/](https://www.okta.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keycloak: [https://www.keycloak.org/](https://www.keycloak.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can implement social logins using OAuth2, after which users can log in with
    their existing credentials from social media platforms such as Facebook. OAuth
    also defines mechanisms for revoking access tokens and handling token expiration.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use OAuth in your Spring Boot applications, the first step is
    to select an OAuth provider. All providers in the list above can be used with
    your Spring Boot applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the OAuth2 process, the term **resource owner** refers typically to an end
    user and the **authorization server** is part of the OAuth provider’s service.
    The **client** is an application that wants to get access to protected resources.
    The **resource server** commonly refers to an API that the client wants to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplified version of the OAuth2 authentication process with a REST API
    contains the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Authentication: The third-party application authenticates by requesting access
    to protected resources.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Authorization: The resource owner authorizes access to their resources, commonly
    through user login.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The authorization server authorizes the resource owner and redirects the user
    back to the client with an authorization code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client requests an access token from the authorization server using the
    authorization code. The access token format is not specified in the standard,
    and JWTs are quite commonly used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The authorization server validates the access token. If the token is valid,
    the client application receives an access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client can start to use the access token to access protected resources,
    for example, calling REST API endpoints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you have selected a provider and know how its service works, you have
    to configure your Spring Boot application. Spring Boot provides the `spring-boot-starter-oauth2-client`
    dependency for OAuth2 authentication and authorization. It is used to simplify
    OAuth 2.0 integration in your Spring Boot application. Quite a few OAuth providers
    have documentation for different technologies, such as Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation will differ depending on the provider. Here are some useful
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Auth0 has a good tutorial for how to add login to your Spring Boot application:
    [https://auth0.com/docs/quickstart/webapp/java-spring-boot/interactive](https://auth0.com/docs/quickstart/webapp/java-spring-boot/interactive).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Baeldung provides a quick guide to using Keycloak with Spring Boot applications:
    [https://www.baeldung.com/spring-boot-keycloak](https://www.baeldung.com/spring-boot-keycloak).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring also has a tutorial on how to implement social login using GitHub: https://spring.io/guides/tutorials/spring-boot-oauth2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We recommend reading these to get a better idea of using OAuth 2.0 in your own
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have finished securing our backend using the JWT, and we will use this
    version when we start to develop our frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on making our Spring Boot backend more secure. We
    started by adding extra protection using Spring Security. Then, we implemented
    JWT authentication. JWTs are commonly used to secure RESTful APIs and it is a
    lightweight authentication method suitable for our needs. We also covered the
    basics of the OAuth 2.0 standard and how to start using it in your Spring Boot
    application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn the basics of testing in Spring Boot applications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Spring Security?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you secure your backend with Spring Boot?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a JWT?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you secure your backend with a JWT?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is OAuth 2.0?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Packt has other resources available for you to learn about Spring Security.
    For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Spring Security Core: Beginner to Guru,* by John Thompson ([https://www.packtpub.com/product/spring-security-core-beginner-to-guru-video/9781800560000](https://www.packtpub.com/product/spring-security-core-beginner-to-guru-video/9781800560000))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask the author questions, and learn about new releases – follow the QR code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code107961080093826402.png)'
  prefs: []
  type: TYPE_IMG
