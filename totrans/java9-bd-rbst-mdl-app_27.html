<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Taking Notes with Monumentum</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">For our eighth project, we will again do something new--we'll build a web app. Whereas all of our other projects have been command lines, GUIs, or some combination thereof, this project will be a single module consisting of a REST API and a JavaScript frontend, all built with an eye toward the current microservice trend.</p>
<p class="mce-root">To build the application, you'll learn about the following topics:</p>
<ul class="calibre13">
<li class="calibre14">Some of the Java options to build microservice applications</li>
<li class="calibre14">Payara Micro and <kbd class="calibre16">microprofile.io</kbd></li>
<li class="calibre14">Java API for RESTful Web Services</li>
<li class="calibre14">Document data stores and MongoDB</li>
<li class="calibre14">OAuth authentication (against Google, specifically)</li>
<li class="calibre14"><strong class="calibre3">JSON Web Tokens</strong> (<strong class="calibre3">JWT</strong>)</li>
</ul>
<p class="mce-root">As you can see, this will be, in many ways, a much different type of project than what we've looked at to this point.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Most of us have likely used some sort of note-taking application such as EverNote, OneNote, or Google Keep. They're an extremely handy way of jotting down notes and thoughts, and having them available from just about every environment imaginable--desktop, mobile, and web. In this chapter, we'll build a fairly basic clone of these industry giants in order to exercise a number of concepts. We will call this app Monumentum, which is Latin for a reminder or memorial, an apt name for this type of application.</p>
<p class="mce-root">Before we get into those, let's take some time to list the requirements for our application:</p>
<ul class="calibre13">
<li class="calibre14">Be able to create notes</li>
<li class="calibre14">Be able to list notes</li>
<li class="calibre14">Be able to edit notes</li>
<li class="calibre14">Be able to delete notes</li>
<li class="calibre14">Note bodies must be capable of storing/displaying rich text</li>
<li class="calibre14">Be able to create a user account</li>
<li class="calibre14">Must be able to log into the application using OAuth2 credentials against an existing system</li>
</ul>
<p class="mce-root">Our non-functional requirements are fairly modest:</p>
<ul class="calibre13">
<li class="calibre14">Must have a RESTful API</li>
<li class="calibre14">Must have an HTML 5/JavaScript frontend</li>
<li class="calibre14">Must have a flexible, scalable data store</li>
<li class="calibre14">Must be easily deployable on resource-constrained systems</li>
</ul>
<p class="mce-root">Of course, this list of non-functional requirements was chosen in part because they reflect real-world requirements, but they also set us up very nicely to discuss some of the technologies I'd like to cover in this chapter. To cut to the chase, we'll create a web application that provides both a REST-based API and a JavaScript client. It will be backed by a document data store, and built using one of the many microservice libraries/frameworks available to the JVM.</p>
<p class="mce-root">So what does this stack look like? Let's take a quick survey of our options before we settle on a particular choice. Let's start with a look at the microservice frameworks.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Microservice frameworks on the JVM</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">While I am reluctant to spend a great deal of time on what a microservice is given that most people are familiar with the topic at this point, I think it would be a remiss not to give at least a brief description in case you are not familiar with the idea. With that said, here is a nice, concise definition of microservice from SmartBear, a provider of software quality tools perhaps best known for their stewardship of the Swagger API and related libraries:</p>
<div class="packt_quote">Essentially, microservice architecture is a method of developing software applications as a suite of independently deployable, small, modular services in which each service runs a unique process and communicates through a well-defined, lightweight mechanism to serve a business goal.</div>
<p class="mce-root">To put it another way, rather than the older, more established approach of bundling several related systems in one web application and deploying it to a large application server, such as GlassFish/Payara Server, Wildfly, WebLogic Server, or WebSphere, each of these systems would instead be run separately in their own JVM process. The benefits of this approach include easier, piecemeal upgrades, increased stability through process isolation, smaller resource requirements, greater machine utilization, and so on. The concept itself is not necessarily new, but it has certainly gained popularity in recent years, and continues to grow at a rapid pace.</p>
<p class="mce-root">So what do our options look like on the JVM? We have several, including, in no particular order, the following:</p>
<ul class="calibre13">
<li class="calibre14"><strong class="calibre3">Eclipse Vert.x</strong>: This is officially <em class="calibre22">a tool-kit for building reactive applications on the JVM</em>. It provides an event-driven application framework that lends itself well to writing microservices. Vert.x can be used in a number of languages, including Java, Javascript, Kotlin, Ceylon, Scala, Groovy, and Ruby. More information can be found at <a href="http://vertx.io/" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">http://vertx.io/</span></a>.</li>
<li class="calibre14"><strong class="calibre3">Spring Boot</strong>: This is a library to build stand alone Spring applications. Spring Boot applications have full access to the entire Spring ecosystem, and can be run using a single fat/uber JAR. Spring Boot lives at <a href="https://projects.spring.io/spring-boot/" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://projects.spring.io/spring-boot</span>/</a>.</li>
<li class="calibre14"><strong class="calibre3">Java EE MicroProfile</strong>: This is a community and vendor-led effort to create a new profile for Java EE, specifically tailored to microservices. At the time of writing, the profile includes <strong class="calibre3">Java API for RESTful Web Services</strong> (<strong class="calibre3">JAX-RS</strong>), CDI, and JSON-P, and is sponsored by several companies including Tomitribe, Payara, Red Hat, Hazelcast, IBM, and Fujitsu, and user groups such as London Java Community and SouJava. The MicroProfile home page is <a href="http://microprofile.io/" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">http://microprofile.io/</span></a>.</li>
<li class="calibre14"><strong class="calibre3">Lagom</strong>: This fairly new framework is a reactive microservices framework from Lightbend, the company behind Scala. It is described as an opinionated microservice framework, and is built using two of Lightbend's more famous libraries--Akka and Play. Lagom applications can be written either in Java or Scala. More details can be found at <a href="https://www.lightbend.com/platform/development/lagom-framework" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://www.lightbend.com/platform/development/lagom-framework</span></a>.</li>
<li class="calibre14"><strong class="calibre3">Dropwizard</strong>: This is a Java framework to develop ops-friendly, high-performance, RESTful web services. It is a framework that offers Jetty for HTTP, Jersey for REST services, and Jackson for JSON. It also provides support for other libraries such as Guava, Hibernate Validator, Freemarker, and others. You can find Dropwizard at <a href="http://www.dropwizard.io/" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">http://www.dropwizard.io/</span></a>.</li>
</ul>
<p class="mce-root">There are a few other options, but it should be clear that, as JVM developers, we have a myriad of choices, which is almost always good. Since we can only build using one, I have chosen to use the MicroProfile. Specifically, we'll base our application on Payara Micro, Payara's implementation, which is based on the GlassFish sources (plus Payara's bug fixes, enhancements, and so on).</p>
<p class="mce-root">By choosing the MicroProfile and Payara Micro, we choose, implicitly, JAX-RS as the basis for our REST services. We are free, of course, to use whatever we want, but deviating from what the framework offers lessens the value of the framework itself.</p>
<p class="mce-root">That leaves us with our choice of data store. One option we've already seen is the relational database. It is a tried and true choice that powers a wide swath of the industry. They are, however, not without their limitations and problems. While databases themselves can be complicated in terms of classifications and functionality, perhaps the most popular alternatives to relational databases are NoSQL databases. While these have existed for half a century, the idea had not gained any significant market traction until sometime in the last decade or so with the advent of <strong class="calibre8">Web 2.0</strong>.</p>
<p class="mce-root">While the term <strong class="calibre8">NoSQL</strong> is very broad, most examples of this type of database tend to be key-value, document, or graph data stores, each offering distinct performance and behavior characteristics. A full treatment of each type of NoSQL database and its various implementations is beyond the scope of this book, so, in the interest of time and space, we'll just get straight to our selection--MongoDB. Its scalability and flexibility, especially in regard to document schemas, meshes well with our target use case.</p>
<p class="mce-root">Finally, on the client side, we have a myriad of options again. Among the most popular are ReactJS from Facebook and Angular from Google. There is a variety of other frameworks, including older options such as Knockout and Backbone, as well as newer ones such as Vue.js. It is this latter option that we'll use. Not only is it a very powerful and flexible option, it also presents the least amount of friction getting started. Since this book is focused on Java, I felt it prudent to select an option that will require the least amount of setup while meeting our needs.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Creating the application</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To use Payara Micro, we create a Java web application like we normally would. In NetBeans, we will select <span class="calibre7">File</span> | <span class="calibre7">New Project</span> | <span class="calibre7">Maven</span> | <span class="calibre7">Web Application</span> and click on <span class="calibre7">Next</span>. For the project name, enter <kbd class="calibre16">monumentum</kbd>, select the appropriate <span class="calibre7">Project Location</span>, and fix up the <span class="calibre7">Group ID</span> and <span class="calibre7">Package</span> as desired:</p>
<div class="mce-root1"><img class="image-border17" src="Images/c894fa8c-00bf-4de2-96ac-97152a4d040d.png"/></div>
<p class="mce-root">The next window will ask us to choose a server, which we can leave blank, and a Java EE version, which we want to set to <span class="calibre7">Java EE 7 Web</span>:</p>
<div class="mce-root1"><img class="image-border57" src="Images/3ec66cd8-47ee-46b0-926c-298c456cddf7.png" width="740" height="512"/></div>
<p class="mce-root">After a few moments, we should have our project created and ready to go. Since we created a Java EE 7 web application, NetBeans has already added the Java EE API dependency to the project. Before we jump into coding, let's add Payara Micro to the build to get that part ready. To do that, we need to add a plugin to the build. That will look something like this (though we've only shown the highlights here):</p>
<pre class="calibre21">    &lt;plugin&gt;<br class="calibre2"/>      &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;<br class="calibre2"/>      &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;<br class="calibre2"/>      &lt;version&gt;1.5.0&lt;/version&gt;<br class="calibre2"/>      &lt;dependencies&gt;<br class="calibre2"/>        &lt;dependency&gt;<br class="calibre2"/>          &lt;groupId&gt;fish.payara.extras&lt;/groupId&gt;<br class="calibre2"/>          &lt;artifactId&gt;payara-microprofile&lt;/artifactId&gt;<br class="calibre2"/>          &lt;version&gt;1.0&lt;/version&gt;<br class="calibre2"/>        &lt;/dependency&gt;<br class="calibre2"/>      &lt;/dependencies&gt;</pre>
<p class="mce-root">This sets up the Maven exec plugin, which is used to execute either an external application or, as we'll do here, a Java application:</p>
<pre class="calibre21">    &lt;executions&gt;<br class="calibre2"/>      &lt;execution&gt;<br class="calibre2"/>        &lt;id&gt;payara-uber-jar&lt;/id&gt;<br class="calibre2"/>        &lt;phase&gt;package&lt;/phase&gt;<br class="calibre2"/>        &lt;goals&gt;<br class="calibre2"/>          &lt;goal&gt;java&lt;/goal&gt;<br class="calibre2"/>        &lt;/goals&gt;</pre>
<p class="mce-root">Here, we're associating the execution of this plugin with Maven's package phase. This means that when we run Maven to build our project, the plugin's java goal will be run as Maven starts to package the project, allowing us to alter exactly what gets packaged in the JAR:</p>
<pre class="calibre21">    &lt;configuration&gt;<br class="calibre2"/>      &lt;mainClass&gt;<br class="calibre2"/>        fish.payara.micro.PayaraMicro<br class="calibre2"/>      &lt;/mainClass&gt;<br class="calibre2"/>      &lt;arguments&gt;<br class="calibre2"/>        &lt;argument&gt;--deploy&lt;/argument&gt;<br class="calibre2"/>        &lt;argument&gt;<br class="calibre2"/>          ${basedir}/target/${warfile.name}.war<br class="calibre2"/>        &lt;/argument&gt;<br class="calibre2"/>        &lt;argument&gt;--outputUberJar&lt;/argument&gt;<br class="calibre2"/>        &lt;argument&gt;<br class="calibre2"/>          ${basedir}/target/${project.artifactId}.jar<br class="calibre2"/>        &lt;/argument&gt;<br class="calibre2"/>      &lt;/arguments&gt;<br class="calibre2"/>    &lt;/configuration&gt;</pre>
<p class="mce-root">This last section configures the plugin. It will run the <kbd class="calibre16">PayaraMicro</kbd> class, passing the <kbd class="calibre16">--deploy &lt;path&gt; --outputUberJar ...</kbd> command. Effectively, we're telling Payara Micro how to run our application, but, rather than executing the package right now, we want it to create an uber JAR that will run the application later.</p>
<div class="packt_infobox">Typically, when you build your project, you get a jar file that contains only the classes and resources that are directly included in your project. Any external dependencies are left as something that the execution environment has to provide. With an uber JAR, all of the dependencies are included in our project's jar as well, which is then configured in such a way that the execution environment can find them as needed.</div>
<p class="mce-root">The problem with the setup is that, left as is, when we build, we'll get an uber JAR, but we won't have any easy way to run the application from NetBeans. To fix that, we need a slightly different plugin configuration. Specifically, it needs these lines:</p>
<pre class="calibre21">    &lt;argument&gt;--deploy&lt;/argument&gt; 
    &lt;argument&gt; 
      ${basedir}/target/${project.artifactId}-${project.version} 
    &lt;/argument&gt; </pre>
<p class="mce-root">These replace the preceding <kbd class="calibre16">deploy</kbd> and <kbd class="calibre16">outputUberJar</kbd> options. To help speed up our builds, we also don't want the uber JAR created until we ask for it, so we can separate these two plugin configurations into two separate profiles, as follows:</p>
<pre class="calibre21">    &lt;profiles&gt; 
      &lt;profile&gt; 
        &lt;id&gt;exploded-war&lt;/id&gt; 
        &lt;!-- ... --&gt; 
      &lt;/profile&gt; 
      &lt;profile&gt; 
        &lt;id&gt;uber&lt;/id&gt; 
        &lt;!-- ... --&gt; 
      &lt;/profile&gt; 
    &lt;/profiles&gt; </pre>
<p class="mce-root">When we're ready to build the deployment artifact, we activate the uber profile when we execute Maven, and we'll get our executable jar:</p>
<pre class="calibre21"><strong class="calibre3">$ mvn -Puber install </strong></pre>
<p class="mce-root">The <kbd class="calibre16">exploded-war</kbd> profile is the configuration that we'll use from the IDE, which runs Payara Micro, pointing it at the exploded war in our build directory. To instruct NetBeans to use that, we need to modify a couple of action configurations. To do that, right-click on the project in NetBeans and select <span class="calibre7">Properties</span> from the bottom of the context menu. Under <span class="calibre7">Actions</span>, find <span class="calibre7">Run Project</span> and select it, then enter <kbd class="calibre16">exploded-war</kbd> under <span class="calibre7">Activate Profiles</span>:</p>
<div class="mce-root1"><img class="image-border58" src="Images/6555e9a8-b1b4-4d90-aeaf-d5a687ea786a.png"/></div>
<p class="mce-root">If we run the application now, NetBeans will complain because we haven't selected a server. While this is a web application and those have typically needed a server, we're using Payara Micro, so we don't need an application server defined. Fortunately, NetBeans will let us tell it that, as demonstrated in the following screenshot:</p>
<div class="mce-root1"><img class="image-border59" src="Images/8e5a2763-76d4-49ae-a724-cf30cd2fbb8e.png" width="517" height="364"/></div>
<p class="mce-root">Select <span class="calibre7">Ignore, I don't want IDE managed deployment</span> and click on <span class="calibre7">OK</span>, then watch the output window. You should see a fair amount of text scroll by, and after a few seconds, you should see text like this:</p>
<pre class="calibre21"><strong class="calibre3">Apr 05, 2017 1:18:59 AM fish.payara.micro.PayaraMicro bootStrap 
INFO: Payara MicroProfile  4.1.1.164-SNAPSHOT (build ${build.number}) ready in 9496 (ms)</strong> </pre>
<p class="mce-root">Once you see that, we're ready to test our application, such as it is at this point. In your browser, open <kbd class="calibre16"><span class="calibre5">http://localhost:8080/monumentum-1.0-SNAPSHOT/index.html</span></kbd> and you should see a large and exciting <em class="calibre20">Hello World!</em> message on the page. If you see this, you have successfully bootstrapped a Payara Micro project. Take a moment to congratulate yourself, and then we'll make the application do something useful.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Creating REST Services</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This being basically a Java EE application, albeit one that it is packaged and deployed a bit differently, everything you may have learned about writing Java EE applications most likely still applies. Of course, you may not have ever written such an application, so we'll walk through the steps.</p>
<p class="mce-root">REST applications in Java EE are written using JAX-RS, and our starting point for JAX-RS is an <kbd class="calibre16">Application</kbd>. The <kbd class="calibre16">Application</kbd> is a deployment-agnostic means for declaring root-level resources to the runtime. How the runtime finds the <kbd class="calibre16">Application</kbd> is, of course, dependent on the runtime itself. For a MicroProfile application like ours, we'll be running in a Servlet 3.0 environment, so we need not do anything special, as Servlet 3.0 supports a descriptor-less deployment option. The runtime will scan for a class of type <kbd class="calibre16">Application</kbd> that is annotated with <kbd class="calibre16">@ApplicationPath</kbd> and uses that to configure the JAX-RS application, as shown here:</p>
<pre class="calibre21">    @ApplicationPath("/api") 
      public class Monumentum extends javax.ws.rs.core.Application { 
      @Override 
      public Set&lt;Class&lt;?&gt;&gt; getClasses() { 
        Set&lt;Class&lt;?&gt;&gt; s = new HashSet&lt;&gt;(); 
        return s; 
      } 
    } </pre>
<p class="mce-root">With the <kbd class="calibre16">@ApplicationPath</kbd> annotation, we specify the root URL of our application's REST endpoints, which is, of course, relative to the web application's root context itself. <kbd class="calibre16">Application</kbd> has three methods we can override, but we're only interested in the one listed here: <kbd class="calibre16">getClasses()</kbd>. We'll provide more details on this method shortly, but, for now, keep in mind that this is how we will describe to JAX-RS what our top-level resources are.</p>
<p class="mce-root">Monumentum will have a very simple API, with the primary endpoint being that to interact with notes. To create that endpoint, we create a simple Java class and mark it up with the appropriate JAX-RS annotations:</p>
<pre class="calibre21">    @Path("/notes") 
    @RequestScoped 
    @Produces(MediaType.APPLICATION_JSON)  
    public class NoteResource { 
    } </pre>
<p class="mce-root">With this class, we're describing an endpoint that will live at <kbd class="calibre16">/api/notes</kbd> and will produce JSON results. JAX-RS supports, for example, XML, but most REST developers are accustomed to JSON and are expecting nothing else, so we need not support anything other than JSON. The needs of your application may vary, of course, so you can adjust the list of supported media types as needed.</p>
<p class="mce-root">While this will compile and run, and JAX-RS will attempt to handle requests to our endpoint, we haven't actually defined it yet. To do that, we need to add some methods to our endpoint that will define the inputs and outputs of the endpoint, as well as the HTTP verb/method we'll use. Let's start with the notes collection endpoint:</p>
<pre class="calibre21">    @GET 
    public Response getAll() { 
      List&lt;Note&gt; notes = new ArrayList&lt;&gt;(); 
      return Response.ok( 
        new GenericEntity&lt;List&lt;Note&gt;&gt;(notes) {}).build(); 
    } </pre>
<p class="mce-root">We now have an endpoint that answers <kbd class="calibre16">GET</kbd> requests at <kbd class="calibre16">/api/notes</kbd> and returns a <kbd class="calibre16">List</kbd> of <kbd class="calibre16">Note</kbd> instances. There is some debate among REST developers on the proper return from methods like these. There are some who prefer to return the actual type the client will see, for example <kbd class="calibre16">List&lt;Note&gt;</kbd> in our case, as it makes it clear to developers reading the source, or documentation generated from it. Others prefer, as we've done here, to return a JAX-RS <kbd class="calibre16">Response</kbd> object, as that gives greater control over the response, including HTTP headers, status code, and more. I tend to prefer this second approach as we've done here. You, of course, are free to use either approach.</p>
<p class="mce-root">One last thing to note here is the way in which we build the response body:</p>
<pre class="calibre21">    new GenericEntity&lt;List&lt;Note&gt;&gt;(notes) {} </pre>
<p class="mce-root">Typically, at runtime, the parameterized type of the List is lost due to type erasure. Using a <kbd class="calibre16">GenericEntity</kbd> like this allows us to capture the parameterized type, allowing the runtime to marshal the data. Using this allows us to avoid writing our own <kbd class="calibre16">MessageBodyWriter</kbd>. Less code is almost always a good thing.</p>
<p class="mce-root">If we run our application now, we'll get the following response, albeit a very boring one:</p>
<pre class="calibre21"><strong class="calibre3">$ curl http://localhost:8080/monumentum-1.0-SNAPSHOT/api/notes/</strong>
<strong class="calibre3">[]</strong> </pre>
<p class="mce-root">That's both satisfying, and it's not, but it does demonstrate that we're on the right track. Clearly, we want that endpoint to return data, but we have no way of adding a note, so let's fix that now.</p>
<p class="mce-root">Creating a new entity via REST is accomplished by POSTing a new entity to its collection. That method looks like this:</p>
<pre class="calibre21">    @POST 
    public Response createNote(Note note) { 
      Document doc = note.toDocument(); 
      collection.insertOne(doc); 
      final String id = doc.get("_id",  
        ObjectId.class).toHexString(); 
 
      return Response.created(uriInfo.getRequestUriBuilder() 
        .path(id).build()) 
      .build(); 
    } </pre>
<p class="mce-root">The <kbd class="calibre16">@POST</kbd> annotation indicates the use of the HTTP POST verb. The method takes a <kbd class="calibre16">Note</kbd> instance, and returns a <kbd class="calibre16">Response</kbd> as we saw in the preceding code. Notice that we don't deal with JSON directly. By specifying a <kbd class="calibre16">Note</kbd> in the method signature, we can take advantage of one of JAX-RS's great features--POJO mapping. We've already seen a hint of it in the previous code with <kbd class="calibre16">GenericEntity</kbd>. JAX-RS will attempt to unmarshal--that is, convert from a serialized form to a model object--the JSON request body. If the client sends a JSON object in the correct format, we get a usable <kbd class="calibre16">Note</kbd> instance. If the client sends an improperly built object, it gets a response. This feature allows us to deal solely with our domain objects and not worry about JSON encoding and decoding, which can save considerable time and energy.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Adding MongoDB</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the body of the method, we get our first glimpse of the integration with MongoDB. To make this compile, we need to add a dependency on the MongoDB Java Driver:</p>
<pre class="calibre21">    &lt;dependency&gt; 
      &lt;groupId&gt;org.mongodb&lt;/groupId&gt; 
      &lt;artifactId&gt;mongodb-driver&lt;/artifactId&gt; 
      &lt;version&gt;3.4.2&lt;/version&gt; 
    &lt;/dependency&gt; </pre>
<p class="mce-root">MongoDB deals with documents, so we need to convert our domain model to a <kbd class="calibre16">Document</kbd>, which we accomplish via a method on our model class. We haven't looked at the details of the <kbd class="calibre16">Note</kbd> class, so let's do that now:</p>
<pre class="calibre21">    public class Note { 
      private String id; 
      private String userId; 
      private String title; 
      private String body; 
      private LocalDateTime created = LocalDateTime.now(); 
      private LocalDateTime modified = null; 
 
      // Getters, setters and some constructors not shown 
 
      public Note(final Document doc) { 
        final LocalDateTimeAdapter adapter =  
          new LocalDateTimeAdapter(); 
        userId = doc.getString("user_id"); 
        id = doc.get("_id", ObjectId.class).toHexString(); 
        title = doc.getString("title"); 
        body = doc.getString("body"); 
        created = adapter.unmarshal(doc.getString("created")); 
        modified = adapter.unmarshal(doc.getString("modified")); 
      } 
 
      public Document toDocument() { 
        final LocalDateTimeAdapter adapter =  
           new LocalDateTimeAdapter(); 
        Document doc = new Document(); 
        if (id != null) { 
           doc.append("_id", new ObjectId(getId())); 
        } 
        doc.append("user_id", getUserId()) 
         .append("title", getTitle()) 
         .append("body", getBody()) 
         .append("created",  
           adapter.marshal(getCreated() != null 
           ? getCreated() : LocalDateTime.now())) 
         .append("modified",  
           adapter.marshal(getModified())); 
         return doc; 
      } 
    } </pre>
<p class="mce-root">This is mostly just a normal POJO. We have added a constructor and an instance method to handle converting to and from MongoDB's <kbd class="calibre16">Document</kbd> type.</p>
<p class="mce-root">There are a couple of things to call out here. The first is how the ID of the MongoDB <kbd class="calibre16">Document</kbd> is handled. Every document stored in a MongoDB database gets <kbd class="calibre16">_id</kbd> assigned to it. In the Java API, this <kbd class="calibre16">_id</kbd> is represented as <kbd class="calibre16">ObjectId</kbd>. We don't want that detail exposed in our domain model, so we convert it to a <kbd class="calibre16">String</kbd> and back again.</p>
<p class="mce-root">We also need to do some special handling for our date fields. We've chosen to represent the <kbd class="calibre16">created</kbd> and <kbd class="calibre16">modified</kbd> properties as <kbd class="calibre16">LocalDateTime</kbd> instances since the new date/time API is superior to the old <kbd class="calibre16">java.util.Date</kbd>. Unfortunately, the MongoDB Java Driver does not yet support Java 8, so we need to handle the conversion ourselves. We'll store these dates as strings and convert them as needed. That conversion is handled via the <kbd class="calibre16">LocalDateTimeAdapter</kbd> class:</p>
<pre class="calibre21">    public class LocalDateTimeAdapter  
      extends XmlAdapter&lt;String, LocalDateTime&gt; { 
      private static final Pattern JS_DATE = Pattern.compile 
        ("\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d+Z"); 
      private static final DateTimeFormatter DEFAULT_FORMAT =  
        DateTimeFormatter.ISO_LOCAL_DATE_TIME; 
      private static final DateTimeFormatter JS_FORMAT =  
        DateTimeFormatter.ofPattern 
        ("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"); 
 
      @Override 
      public LocalDateTime unmarshal(String date) { 
        if (date == null) { 
          return null; 
        } 
        return LocalDateTime.parse(date,  
          (JS_DATE.matcher(date).matches()) 
          ? JS_FORMAT : DEFAULT_FORMAT); 
      } 
 
      @Override 
      public String marshal(LocalDateTime date) { 
        return date != null ? DEFAULT_FORMAT.format(date) : null; 
      } 
    } </pre>
<p class="mce-root">This is probably a bit more complicated than you might expect, and that's because it's doing more than we've discussed so far. The usage we're looking at now, that from our model class, is not this class' primary purpose, but we'll get to that in a moment. That aside, the class' behavior is pretty straightforward--take a <kbd class="calibre16">String</kbd>, determine which of the two supported formats it represents, and convert it to a <kbd class="calibre16">LocalDateTime</kbd>. It also goes the other way.</p>
<p class="mce-root">This class' primary purpose is for JAX-RS' use. When we pass <kbd class="calibre16">Note</kbd> instances across the wire, <kbd class="calibre16">LocalDateTime</kbd> needs to be unmarshalled as well, and we can tell JAX-RS how to do this via an <kbd class="calibre16">XmlAdapter</kbd>.</p>
<p class="mce-root">With the class defined, we need to tell JAX-RS about it. We can do that in a couple of different ways. We could use an annotation on each property in our model like this:</p>
<pre class="calibre21">    @XmlJavaTypeAdapter(value = LocalDateTimeAdapter.class) 
    private LocalDateTime created = LocalDateTime.now(); </pre>
<p class="mce-root">While this works, it's a fairly large annotation, as far as these kinds of things go, and you have to put this on every <kbd class="calibre16">LocalDateTime</kbd> property. If you have several models with fields of this type, you will have to touch each property. Fortunately, there's a way to associate the type with the adapter once. We can do that in a special Java file called <kbd class="calibre16">package-info.java</kbd>. Most people have never heard of this file, and even fewer use it, but it is simply a place for package-level documentation and annotations. It is this latter use case that interests us. In the package for our model class, create <kbd class="calibre16">package-info.java</kbd> and put this in it:</p>
<pre class="calibre21">    @XmlJavaTypeAdapters({ 
      @XmlJavaTypeAdapter(type = LocalDateTime.class,  
        value = LocalDateTimeAdapter.class) 
    }) 
    package com.steeplesoft.monumentum.model; </pre>
<p class="mce-root">We have the same annotation we saw in the preceding code, but it's wrapped in <kbd class="calibre16">@XmlJavaTypeAdapters</kbd>. The JVM allows only annotation of a given type on an element, so this wrapper allows us to work around that limitation. We also need to specify the type parameter on the <kbd class="calibre16">@XmlJavaTypeAdapter</kbd> annotation since it is no longer on the target property. With this in place, every <kbd class="calibre16">LocalDateTime</kbd> property will be handled correctly without any additional work.</p>
<p class="mce-root">That's quite a bit of setup, but we're still not quite ready. We have everything set up on the REST side. We now need to get the MongoDB classes in place. To connect to a MongoDB instance, we start with a <kbd class="calibre16">MongoClient</kbd>. From the <kbd class="calibre16">MongoClient</kbd>, we then acquire a reference to a <kbd class="calibre16">MongoDatabase</kbd> from which we get a <kbd class="calibre16">MongoCollection</kbd>:</p>
<pre class="calibre21">    private MongoCollection&lt;Document&gt; collection; 
    private MongoClient mongoClient; 
    private MongoDatabase database; 
 
    @PostConstruct 
    public void postConstruct() { 
      String host = System.getProperty("mongo.host", "localhost"); 
      String port = System.getProperty("mongo.port", "27017"); 
      mongoClient = new MongoClient(host, Integer.parseInt(port)); 
      database = mongoClient.getDatabase("monumentum"); 
      collection = database.getCollection("note"); 
    } </pre>
<p class="mce-root">The <kbd class="calibre16">@PostConstruct</kbd> method runs on the bean after the constructor has run. In this method, we initialize our various MongoDB classes and store them in instance variables. With these classes ready, we can revisit, for example, <kbd class="calibre16">getAll()</kbd>:</p>
<pre class="calibre21">    @GET 
    public Response getAll() { 
      List&lt;Note&gt; notes = new ArrayList&lt;&gt;(); 
      try (MongoCursor&lt;Document&gt; cursor = collection.find() 
      .iterator()) { 
        while (cursor.hasNext()) { 
          notes.add(new Note(cursor.next())); 
        } 
      } 
 
      return Response.ok( 
        new GenericEntity&lt;List&lt;Note&gt;&gt;(notes) {}) 
      .build(); 
    } </pre>
<p class="mce-root">We can now query the database for our notes, and with the implementation of <kbd class="calibre16">createNote()</kbd> shown in the preceding code, we can create the following notes:</p>
<pre class="calibre21"><strong class="calibre3">$ curl -v -H "Content-Type: application/json" -X POST -d '{"title":"Command line note", "body":"A note from the command line"}' http://localhost:8080/monumentum-1.0-SNAPSHOT/api/notes/ 
*   Trying ::1... 
* TCP_NODELAY set 
* Connected to localhost (::1) port 8080 (#0) 
&gt; POST /monumentum-1.0-SNAPSHOT/api/notes/ HTTP/1.1 
... 
&lt; HTTP/1.1 201 Created 
... 
$ curl http://localhost:8080/monumentum-1.0-SNAPSHOT/api/notes/ | jq . 
[ 
  { 
    "id": "58e5d0d79ccd032344f66c37", 
    "userId": null, 
    "title": "Command line note", 
    "body": "A note from the command line", 
    "created": "2017-04-06T00:23:34.87", 
    "modified": null 
  } 
]</strong> </pre>
<div class="packt_tip">For this to work on your machine, you'll need an instance of MongoDB running. You can download an installer appropriate for your operating system as well as find installation instructions on the MongoDB website (<a href="https://docs.mongodb.com/manual/installation/" class="calibre25 pcalibre pcalibre3 pcalibre2 pcalibre1"><span class="calibre5">https://docs.mongodb.com/manual/installation/</span></a>).</div>
<p class="mce-root">Before we move on to the other resource methods, let's take one last look at our MongoDB API instances. While instantiating the instances like we have works, it also puts a fair amount of work on the resource itself. Ideally, we should be able to move those concerns elsewhere and inject the instances. Hopefully, this sounds familiar to you, as this is exactly the type of concern that <strong class="calibre8">dependency injection</strong> (<strong class="calibre8">DI</strong>) or <strong class="calibre8">inversion of control</strong> (<strong class="calibre8">IoC</strong>) frameworks were created to solve.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Dependency injection with CDI</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Java EE provides a framework such as CDI. With CDI, we can inject any container-controlled object into another with compile-time type safety. The problem, though, is the objects in question need to be container controlled, which our MongoDB API objects are not. Fortunately, CDI provides a means by which the container can create these instances, a facility known as producer methods. What might this look like? Let's start with the injection point, as that is the simplest piece:</p>
<pre class="calibre21">    @Inject 
    @Collection("notes") 
    private MongoCollection&lt;Document&gt; collection; </pre>
<p class="mce-root">When the CDI container sees <kbd class="calibre16">@Inject</kbd>, it inspects the element the annotation is on to determine the type. It will then attempt to look up an instance that will satisfy the injection request. If there is more than one, the injection would typically fail. Although, we have used a qualifier annotation to help CDI determine what to inject. That annotation is defined like this:</p>
<pre class="calibre21">    @Qualifier  
    @Retention(RetentionPolicy.RUNTIME)  
    @Target({ElementType.METHOD, ElementType.FIELD,  
      ElementType.PARAMETER, ElementType.TYPE})   
    public @interface Collection { 
      @Nonbinding String value() default "unknown";   
    } </pre>
<p class="mce-root">With this annotation, we can pass hints to the container that will help it select an instance for injection. As we've mentioned, <kbd class="calibre16">MongoCollection</kbd> is not container-managed, so we need to fix that, which we do via the following producer method:</p>
<pre class="calibre21">    @RequestScoped 
    public class Producers { 
      @Produces 
      @Collection 
      public MongoCollection&lt;Document&gt;  
        getCollection(InjectionPoint injectionPoint) { 
          Collection mc = injectionPoint.getAnnotated() 
          .getAnnotation(Collection.class); 
        return getDatabase().getCollection(mc.value()); 
      } 
    } </pre>
<p class="mce-root">The <kbd class="calibre16">@Produces</kbd> method tells CDI that this method will produce instances needed by the container. CDI determines the type of the injectable instance from the method signature. We also place the qualifier annotation on the method as an additional hint to the runtime as it tries to resolve our injection request.</p>
<p class="mce-root">In the method itself, we add <kbd class="calibre16">InjectionPoint</kbd> to the method signature. When CDI calls this method, it will provide an instance of this class, from which we can get information about each particular injection point as they are processed. From <kbd class="calibre16">InjectionPoint</kbd>, we get the <kbd class="calibre16">Collection</kbd> instance from which we can get the name of the MongoDB collection we're interested in. We are now ready to get the <kbd class="calibre16">MongoCollection</kbd> instance we saw earlier. The <kbd class="calibre16">MongoClient</kbd> and <kbd class="calibre16">MongoDatabase</kbd> instantiation is handled internally in the class and is not changed significantly from our earlier usage.</p>
<p class="mce-root">There is one small setup step for CDI. In order to avoid potentially expensive classpath scanning by the CDI container, we need to tell the system that we want the CDI turned on, so to speak. To do that, we need a <kbd class="calibre16">beans.xml</kbd> file, which can either be full of CDI configuration elements, or completely empty, which is what we'll do. For Java EE web applications, <kbd class="calibre16">beans.xml</kbd> needs to be in the <kbd class="calibre16">WEB-INF</kbd> directory, so we create the file in <kbd class="calibre16">src/main/webapp/WEB-INF</kbd>.</p>
<div class="packt_tip">Make sure that the file is truly empty. If there's even a blank line, Weld, Payara's CDI implementation, will attempt to parse the file, giving you an XML parsing error.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Finish the notes resource</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Before we can move on from the <kbd class="calibre16">Note</kbd> resource, we need to finish up a few operations, namely, read, update, and delete. Reading a single note is very straightforward:</p>
<pre class="calibre21">    @GET 
    @Path("{id}") 
    public Response getNote(@PathParam("id") String id) { 
      Document doc = collection.find(buildQueryById(id)).first(); 
      if (doc == null) { 
        return Response.status(Response.Status.NOT_FOUND).build(); 
      } else { 
        return Response.ok(new Note(doc)).build(); 
      } 
    } </pre>
<p class="mce-root">We've specified the use of the HTTP verb <kbd class="calibre16">GET</kbd> as we've already seen, but we have an additional annotation on this method, <kbd class="calibre16">@Path</kbd>. Using this annotation, we tell JAX-RS that this endpoint has additional path segments that the request needs to be matched against. In this case, we specify one additional segment, but we've wrapped it in curly braces. Without those braces, the match would be a literal match, that is to say, "Does this URL have the string 'id' on the end?" With the braces, though, we're telling JAX-RS that we want to match the additional segment, but its contents can be anything, and we want to capture that value and give it the name <kbd class="calibre16">id</kbd>. In our method signature, we instruct JAX-RS to inject the value via the <kbd class="calibre16">@PathParam</kbd> annotation, giving us access to the user-specified <kbd class="calibre16">Note</kbd> ID in our method.</p>
<p class="mce-root">To retrieve the note from MongoDB, we get our first real glimpse of how one queries MongoDB:</p>
<pre class="calibre21">    Document doc = collection.find(buildQueryById(id)).first(); </pre>
<p class="mce-root">In a nutshell, pass <kbd class="calibre16">BasicDBObject</kbd> to the <kbd class="calibre16">find()</kbd> method on <kbd class="calibre16">collection</kbd>, which returns a <kbd class="calibre16">FindIterable&lt;?&gt;</kbd> object, on which we call <kbd class="calibre16">first()</kbd> to get what should be the only element returned (assuming there is one, of course). The interesting bits here are hidden in <kbd class="calibre16">buildQueryById()</kbd>:</p>
<pre class="calibre21">    private BasicDBObject buildQueryById(String id) { 
      BasicDBObject query =  
        new BasicDBObject("_id", new ObjectId(id)); 
      return query; 
    } </pre>
<p class="mce-root">Our query filter is defined using this <kbd class="calibre16">BasicDBObject</kbd>, which we initialize with a key and value. In this case, we want to filter by the <kbd class="calibre16">_id</kbd> field in the document, so we use that as a key, but note that we pass <kbd class="calibre16">ObjectId</kbd> as the value, and not just <kbd class="calibre16">String</kbd>. If we want to filter by more fields, we would append more key/value pairs to the <kbd class="calibre16">BasicDBObject</kbd> variable, which we will see later.</p>
<p class="mce-root">Once we've queried the collection and gotten the document the user requested, we convert it from <kbd class="calibre16">Document</kbd> to <kbd class="calibre16">Note</kbd> using the helper method on <kbd class="calibre16">Note</kbd>, and return it with a status code of 200 or <kbd class="calibre16">OK</kbd>.</p>
<p class="mce-root">Updating a document in the database is a bit more complicated, but not excessively so, as you can see here:</p>
<pre class="calibre21">    @PUT 
    @Path("{id}") 
    public Response updateNote(Note note) { 
      note.setModified(LocalDateTime.now()); 
      UpdateResult result =  
        collection.updateOne(buildQueryById(note.getId()), 
        new Document("$set", note.toDocument())); 
      if (result.getModifiedCount() == 0) { 
        return Response.status(Response.Status.NOT_FOUND).build(); 
      } else { 
        return Response.ok().build(); 
      } 
    } </pre>
<p class="mce-root">The first thing to notice is the HTTP method--<kbd class="calibre16">PUT</kbd>. There is some debate on what verb to use for updates. Some, such as Dropbox and Facebook, say <kbd class="calibre16">POST</kbd>, while others, such as Google (depending on which API you look at), say <kbd class="calibre16">PUT</kbd>. I would contend that the choice is largely up to you. Just be consistent in your choice. We will be completely replacing the entity on the server with what the client passes in, so the operation is idempotent. By choosing <kbd class="calibre16">PUT</kbd>, we can signal this fact to the client, making the API a bit more self-describing for clients.</p>
<p class="mce-root">Inside the method, we start by setting the modified date to reflect the operation. Next, we call <kbd class="calibre16">Collection.updateOne()</kbd> to modify the document. The syntax is a little odd, but here's what's happening--we're querying the collection for the note we want to modify, then telling MongoDB to replace the loaded document with the new one we're providing. Finally, we query <kbd class="calibre16">UpdateResult</kbd> to see how many documents were updated. If none were, then the requested document doesn't exist, so we return <kbd class="calibre16">NOT_FOUND</kbd> (<kbd class="calibre16">404</kbd>). If it's non-zero, we return <kbd class="calibre16">OK</kbd> (<kbd class="calibre16">200</kbd>).</p>
<p class="mce-root">Finally, our delete method looks like this:</p>
<pre class="calibre21">    @DELETE 
    @Path("{id}") 
    public Response deleteNote(@PathParam("id") String id) { 
      collection.deleteOne(buildQueryById(id)); 
      return Response.ok().build(); 
    } </pre>
<p class="mce-root">We tell MongoDB to filter the collection using the same query filter we've seen before, then delete one document, which should be all it finds, of course, given our filter, but <kbd class="calibre16">deleteOne()</kbd> is a sensible safeguard. We could do a check like we did above in <kbd class="calibre16">updateNote()</kbd> to see if something was actually deleted, but there's little point--whether the document was there at the start of the request or not, it's not there at the end and that's our goal, so there's little to be gained from returning an error response.</p>
<p class="mce-root">We can now create, read, update, and delete notes, but the eagle-eyed among you may have noticed that anyone can read every note in the system. For a multi-user system, that's not a good thing, so let's fix that.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Adding authentication</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Authentication systems can easily get extremely complex. From homegrown systems, complete with custom user management screens, to sophisticated single sign-on solutions, we have a lot of options. One of the more popular options is OAuth2, and there are a number of options. For Monumentum, we'll implement sign in using Google. To do that, we need to create an application in Google's Developer Console, which can be found at <a href="https://console.developers.google.com" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://console.developers.google.com</span></a>.</p>
<p class="mce-root">Once you've logged in, click on the project dropdown at the top of page and click on <span class="calibre7">Create Project</span>, which should present this screen to you:</p>
<div class="mce-root1"><img class="image-border60" src="Images/0b47b3bc-b9b4-459b-b9eb-89daf802242d.png" width="647" height="444"/></div>
<p class="mce-root">Provide <span class="calibre7">Project Name</span>, make your choices for the next two questions, then click on <span class="calibre7">CREATE</span>. Once the project has been created, you should be redirected to the Library page. Click on the <span class="calibre7">Credentials</span> link on the left, then click on <span class="calibre7">Create credentials</span> and select <span class="calibre7">OAuth Client ID</span>. If needed, fill out the <span class="calibre7">OAuth Consent</span> screen as directed. Select <span class="calibre7">Web Application</span> for <span class="calibre7">Application Type</span>, enter <span class="calibre7">Name</span>, and provide <span class="calibre7">Authorized redirect URIs</span> as shown in this screenshot:</p>
<div class="mce-root1"><img class="image-border61" src="Images/dd5f9e8d-fedf-476c-bcf6-c0b60e913720.png"/></div>
<p class="mce-root">Before this is moved to production, we will need to add a production URI to this screen, but this configuration will work in development just fine. When you click on <span class="calibre7">Save</span>, you will be shown your new client ID and client secret. Make note of these:</p>
<div class="mce-root1"><img class="image-border62" src="Images/38a25359-1dc1-4c80-acfc-ccd9054bf5f9.png"/></div>
<p class="mce-root">With this data (note that these are not my actual ID and secret, so you'll have to generate your own), we are ready to start working on our authentication resource. We'll start by defining the resource as follows:</p>
<pre class="calibre21">    @Path("auth") 
    public class AuthenticationResource { </pre>
<p class="mce-root">We need to register this in our <kbd class="calibre16">Application</kbd>, as follows:</p>
<pre class="calibre21">    @ApplicationPath("/api") 
    public class Monumentum extends javax.ws.rs.core.Application { 
      @Override 
      public Set&lt;Class&lt;?&gt;&gt; getClasses() { 
        Set&lt;Class&lt;?&gt;&gt; s = new HashSet&lt;&gt;(); 
        s.add(NoteResource.class); 
        s.add(AuthenticationResource.class); 
        return s; 
      } 
    } </pre>
<p class="mce-root">To work with the Google OAuth provider, we'll need to declare a few instance variables and instantiate a few Google API classes:</p>
<pre class="calibre21">    private final String clientId; 
    private final String clientSecret; 
    private final GoogleAuthorizationCodeFlow flow; 
    private final HttpTransport HTTP_TRANSPORT =  
      new NetHttpTransport(); 
    private static final String USER_INFO_URL =  
      "https://www.googleapis.com/oauth2/v1/userinfo"; 
    private static final List&lt;String&gt; SCOPES = Arrays.asList( 
      "https://www.googleapis.com/auth/userinfo.profile", 
      "https://www.googleapis.com/auth/userinfo.email"); </pre>
<p class="mce-root">The variables <kbd class="calibre16">clientId</kbd> and <kbd class="calibre16">clientSecret</kbd> will hold the values that Google just gave us. The other two classes are necessary for the process we're about to walk through, and <kbd class="calibre16">SCOPES</kbd> holds the permissions we want from Google, which is just access to the user's profile and email. The class constructor finishes the setup of these items:</p>
<pre class="calibre21">    public AuthenticationResource() { 
      clientId = System.getProperty("client_id"); 
      clientSecret = System.getProperty("client_secret"); 
      flow = new GoogleAuthorizationCodeFlow.Builder(HTTP_TRANSPORT, 
        new JacksonFactory(), clientId, clientSecret, 
        SCOPES).build(); 
    } </pre>
<p class="mce-root">The first part of the authentication flow is to create an authentication URL, which is done like this:</p>
<pre class="calibre21">    @Context 
    private UriInfo uriInfo; 
    @GET 
    @Path("url") 
    public String getAuthorizationUrl() { 
      return flow.newAuthorizationUrl() 
      .setRedirectUri(getCallbackUri()).build(); 
    } 
    private String getCallbackUri()  
      throws UriBuilderException, IllegalArgumentException { 
      return uriInfo.getBaseUriBuilder().path("auth") 
        .path("callback").build() 
        .toASCIIString(); 
    } </pre>
<p class="mce-root">Using the JAX-RS class, <kbd class="calibre16">UriInfo</kbd>, we create a <kbd class="calibre16">URI</kbd> that points to another endpoint in our application, <kbd class="calibre16">/api/auth/callback</kbd>. We then pass that to <kbd class="calibre16">GoogleAuthorizationCodeFlow</kbd> to finish building our login URL. When the user clicks on the link, the browser will be directed to a login dialog from Google. Upon successful authentication, the user will be redirected to our callback URL, which is handled by this method:</p>
<pre class="calibre21">    @GET 
    @Path("callback") 
    public Response handleCallback(@QueryParam("code")  
    @NotNull String code) throws IOException { 
      User user = getUserInfoJson(code); 
      saveUserInformation(user); 
      final String jwt = createToken(user.getEmail()); 
      return Response.seeOther( 
        uriInfo.getBaseUriBuilder() 
        .path("../loginsuccess.html") 
        .queryParam("Bearer", jwt) 
        .build()) 
      .build(); 
    } </pre>
<p class="mce-root">When Google redirects to our <kbd class="calibre16">callback</kbd> endpoint, it will provide a code that we can use to finish the authentication. We do that in the <kbd class="calibre16">getUserInfoJson()</kbd> method:</p>
<pre class="calibre21">    private User getUserInfoJson(final String authCode)  
    throws IOException { 
      try { 
        final GoogleTokenResponse response =  
          flow.newTokenRequest(authCode) 
          .setRedirectUri(getCallbackUri()) 
          .execute(); 
        final Credential credential =  
          flow.createAndStoreCredential(response, null); 
        final HttpRequest request =  
          HTTP_TRANSPORT.createRequestFactory(credential) 
          .buildGetRequest(new GenericUrl(USER_INFO_URL)); 
        request.getHeaders().setContentType("application/json"); 
        final JSONObject identity =  
          new JSONObject(request.execute().parseAsString()); 
        return new User( 
          identity.getString("id"), 
          identity.getString("email"), 
          identity.getString("name"), 
          identity.getString("picture")); 
      } catch (JSONException ex) { 
        Logger.getLogger(AuthenticationResource.class.getName()) 
        .log(Level.SEVERE, null, ex); 
        return null; 
      } 
    } </pre>
<p class="mce-root">Using the authentication code we just got from Google, we send another request to Google, this time to get the user information. When the request returns, we take the JSON object in the response body and use it to build a <kbd class="calibre16">User</kbd> object, which we return.</p>
<p class="mce-root">Back in our REST endpoint method, we call this method to save the user to the database, if needed:</p>
<pre class="calibre21">    private void saveUserInformation(User user) { 
      Document doc = collection.find( 
        new BasicDBObject("email", user.getEmail())).first(); 
      if (doc == null) { 
        collection.insertOne(user.toDocument()); 
      } 
    } </pre>
<p class="mce-root">Once we've gotten the user's information from Google, we no longer need the code as we do not need to interact with any other Google resources, so we do not persist it anywhere.</p>
<p class="mce-root">Finally, we want to return something to the client --some kind of token -- which can be used to prove the client's identity. To do that, we'll use a technology called a JSON Web Token, or JWT for short. JWT is <em class="calibre20">a JSON-based open standard (RFC 7519) for creating access tokens that assert some number of claims</em>. We'll create a JWT using the user's email address. We'll sign it with a key only the server uses, so we can safely pass it to the client, which will pass it back with each request. Since it must be encrypted/signed with the server key, untrustworthy clients will not be able to alter or forge the token successfully.</p>
<p class="mce-root">To create JWTs, we need to add the library to our project as follows:</p>
<pre class="calibre21">    &lt;dependency&gt; 
      &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; 
      &lt;artifactId&gt;jjwt&lt;/artifactId&gt; 
      &lt;version&gt;0.7.0&lt;/version&gt; 
    &lt;/dependency&gt; </pre>
<p class="mce-root">We can then write this method:</p>
<pre class="calibre21">    @Inject 
    private KeyGenerator keyGenerator; 
    private String createToken(String login) { 
      String jwtToken = Jwts.builder() 
      .setSubject(login) 
      .setIssuer(uriInfo.getAbsolutePath().toString()) 
      .setIssuedAt(new Date()) 
      .setExpiration(Date.from( 
        LocalDateTime.now().plusHours(12L) 
      .atZone(ZoneId.systemDefault()).toInstant())) 
      .signWith(SignatureAlgorithm.HS512,  
        keyGenerator.getKey()) 
      .compact(); 
      return jwtToken; 
    } </pre>
<p class="mce-root">The subject of the token is the email address, our API's base address is the issuer, the expiration date and time is 12 hours in the future, and the token is signed by a key we generate with a new class, <kbd class="calibre16">KeyGenerator</kbd>. When we call <kbd class="calibre16">compact()</kbd>, a URL-safe String is generated, which we return to the caller. We can use the JWT debugger at <a href="http://jwt.io/" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">http://jwt.io</span></a> to look inside the token:</p>
<div class="mce-root1"><img class="image-border63" src="Images/2dbc46c7-26b5-4130-b8e1-3608c342acf1.png"/></div>
<p class="mce-root">Clearly, the claims in the token are readable, so don't store anything sensitive in them. What makes this secure is the use of a secret key when signing the token, making it impossible, in theory, to change its contents without detection.</p>
<p class="mce-root">The <kbd class="calibre16">KeyGenerator</kbd> class used to give us our signing key looks like this:</p>
<pre class="calibre21">    @Singleton 
    public class KeyGenerator { 
      private Key key; 
     
      public Key getKey() { 
        if (key == null) { 
          String keyString = System.getProperty("signing.key",  
            "replace for production"); 
          key = new SecretKeySpec(keyString.getBytes(), 0,  
            keyString.getBytes().length, "DES"); 
        } 
         
        return key; 
      } 
    } </pre>
<p class="mce-root">The class is annotated with <kbd class="calibre16">@Singleton</kbd>, so the container guarantees that one and only one instance of this bean will exist in the system. The <kbd class="calibre16">getKey()</kbd> method will use the system property <kbd class="calibre16">signing.key</kbd> as the key, allowing the user to specify a unique secret when starting the system. Of course, completely random keys are safer, but that adds some complexity should we ever try to scale this system out horizontally. We would need all instances to use the same signing key so that JWTs can be validated regardless of what server the client is directed to. A data grid solution, such as Hazelcast, would be an appropriate tool for those situations. As it is now, this is sufficient for our needs here.</p>
<p class="mce-root">Our authentication resource is now complete, but our system has not actually been secured yet. To do that, we need to tell JAX-RS how to authenticate requests, and we'll do that with a new annotation and <kbd class="calibre16">ContainerRequestFilter</kbd>.</p>
<p class="mce-root">If we were to install a request filter with no additional information, it would apply to every resource, including our authentication resource. That would mean we'd have to authenticate in order to authenticate. Clearly that doesn't make sense, so we need a way to discriminate between requests so that only requests for certain resources have this filter applied, and that means a new annotation:</p>
<pre class="calibre21">    @NameBinding 
    @Retention(RetentionPolicy.RUNTIME) 
    @Target({ElementType.TYPE, ElementType.METHOD}) 
    public @interface Secure { 
    } </pre>
<p class="mce-root">We've defined an annotation that is semantically meaningful. The <kbd class="calibre16">@NameBinding</kbd> annotation tells JAX-RS to apply the annotation only to certain resources, which are bound by name (as opposed to dynamically bound at runtime). With the annotation defined, we need to define the other side of things, the request filter:</p>
<pre class="calibre21">    @Provider 
    @Secure 
    @Priority(Priorities.AUTHENTICATION) 
    public class SecureFilter implements ContainerRequestFilter { 
      @Inject 
      private KeyGenerator keyGenerator; 
 
      @Override 
      public void filter(ContainerRequestContext requestContext)  
       throws IOException { 
        try { 
          String authorizationHeader = requestContext 
          .getHeaderString(HttpHeaders.AUTHORIZATION); 
          String token = authorizationHeader 
          .substring("Bearer".length()).trim(); 
          Jwts.parser() 
          .setSigningKey(keyGenerator.getKey()) 
          .parseClaimsJws(token); 
        } catch (Exception e) { 
          requestContext.abortWith(Response.status 
          (Response.Status.UNAUTHORIZED).build()); 
        } 
      } 
    } </pre>
<p class="mce-root">We start by defining a class that implements the <kbd class="calibre16">ContainerRequestFilter</kbd> interface. We have to annotate it with <kbd class="calibre16">@Provider</kbd> so that JAX-RS will recognize and load the class. We apply the <kbd class="calibre16">@Secure</kbd> annotation to associate the filter with the annotation. We'll apply this to the resource in a moment. Finally, we apply the <kbd class="calibre16">@Priority</kbd> annotation to instruct the system that this filter should be applied earlier in the request cycle.</p>
<p class="mce-root">Inside the filter, we inject the same <kbd class="calibre16">KeyGenerator</kbd> we looked at earlier. Since this is a singleton, we are guaranteed that the key used here and in the authentication method are the same. The only method on the interface is <kbd class="calibre16">filter()</kbd>, and in this method, we get the Authorization header from the request, extract the Bearer token, which is the JWT, and validate it using the JWT API. If we can decode and validate the token, then we know the user has successfully authenticated against the system. To tell the system about this new filter, we need to modify our JAX-RS <kbd class="calibre16">Application</kbd> as follows:</p>
<pre class="calibre21">    @ApplicationPath("/api") 
    public class Monumentum extends javax.ws.rs.core.Application { 
      @Override 
      public Set&lt;Class&lt;?&gt;&gt; getClasses() { 
        Set&lt;Class&lt;?&gt;&gt; s = new HashSet&lt;&gt;(); 
        s.add(NoteResource.class); 
        s.add(AuthenticationResource.class); 
        s.add(SecureFilter.class); 
        return s; 
      } 
    } </pre>
<p class="mce-root">The system knows about the filter now, but before it will do anything, we need to apply it to the resources that we want to secure. We do that by applying the <kbd class="calibre16">@Secure</kbd> annotation to the appropriate resources. It can either be applied at class level, which means that every endpoint in the class will be secured, or at the resource method level, which means that only those particular endpoints will be secured. In our case, we want every <kbd class="calibre16">Note</kbd> endpoint secured, so put the following annotation on the class:</p>
<pre class="calibre21">    @Path("/notes") 
    @RequestScoped 
    @Produces(MediaType.APPLICATION_JSON) 
    @Secure 
    public class NoteResource { </pre>
<p class="mce-root">Just a few more steps, and our application will be secured. We need to make some modifications to <kbd class="calibre16">NoteResource</kbd> so that it knows who is logged in, and so that notes are associated with the authenticated user. We will start by injecting <kbd class="calibre16">User</kbd>:</p>
<pre class="calibre21">    @Inject 
    private User user; </pre>
<p class="mce-root">This is obviously not a container-managed class, so we need to write another <kbd class="calibre16">Producer</kbd> method. There's a small bit of work to do there, so we'll wrap that in its own class:</p>
<pre class="calibre21">    @RequestScoped 
    public class UserProducer { 
      @Inject 
      private KeyGenerator keyGenerator; 
      @Inject 
      HttpServletRequest req; 
      @Inject 
      @Collection("users") 
      private MongoCollection&lt;Document&gt; users; </pre>
<p class="mce-root">We define this as a request-scoped CDI bean, and inject our <kbd class="calibre16">KeyGenerator</kbd>, the <kbd class="calibre16">HttpServletRequest</kbd>, and our users collection. The actual work is done in the <kbd class="calibre16">Producer</kbd> method:</p>
<pre class="calibre21">    @Produces 
    public User getUser() { 
      String authHeader = req.getHeader(HttpHeaders.AUTHORIZATION); 
      if (authHeader != null &amp;&amp; authHeader.contains("Bearer")) { 
        String token = authHeader 
        .substring("Bearer".length()).trim(); 
        Jws&lt;Claims&gt; parseClaimsJws = Jwts.parser() 
        .setSigningKey(keyGenerator.getKey()) 
        .parseClaimsJws(token); 
        return getUser(parseClaimsJws.getBody().getSubject()); 
      } else { 
        return null; 
      }  
    } </pre>
<p class="mce-root">Using the Servlet request, we retrieve the <kbd class="calibre16">AUTHORIZATION</kbd> header. If it's present and contains the <kbd class="calibre16">Bearer</kbd> string, we can process the token. If that condition is not true, we return null. To process the token, we extract the token value from the header, and then have <kbd class="calibre16">Jwts</kbd> parse the claims for us, which returns an object of type <kbd class="calibre16">Jws&lt;Claims&gt;</kbd>. We build the user in the <kbd class="calibre16">getUser()</kbd> method as follows:</p>
<pre class="calibre21">    private User getUser(String email) { 
      Document doc = users.find( 
        new BasicDBObject("email", email)).first(); 
      if (doc != null) { 
        return new User(doc); 
      } else { 
        return null; 
      } 
    } </pre>
<p class="mce-root">With the claims parsed, we can extract the subject and use it to query our <kbd class="calibre16">Users</kbd> collection, returning either the <kbd class="calibre16">User</kbd> if it is found, or <kbd class="calibre16">null</kbd> if not.</p>
<p class="mce-root">Back in our <kbd class="calibre16">NoteResource</kbd>, we need to modify our resource methods to be <kbd class="calibre16">User-aware</kbd>:</p>
<pre class="calibre21">    public Response getAll() { 
      List&lt;Note&gt; notes = new ArrayList&lt;&gt;(); 
      try (MongoCursor&lt;Document&gt; cursor =  
        collection.find(new BasicDBObject("user_id",  
        user.getId())).iterator()) { 
      // ... 
      @POST 
      public Response createNote(Note note) { 
        Document doc = note.toDocument(); 
        doc.append("user_id", user.getId()); 
        // ... 
      @PUT 
      @Path("{id}") 
      public Response updateNote(Note note) { 
        note.setModified(LocalDateTime.now()); 
        note.setUser(user.getId()); 
        // ... 
      private BasicDBObject buildQueryById(String id) { 
        BasicDBObject query =  
        new BasicDBObject("_id", new ObjectId(id)) 
         .append("user_id", user.getId()); 
        return query; 
    } </pre>
<p class="mce-root">We now have a complete and secured REST API. Other than a command-line tool like curl, we don't have any nice way to use it, so let's build a user interface.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building the user interface</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">For a UI, we have a number of options. We've already looked at JavaFX and the NetBeans RCP in this book. While those are great options, we'll do something a little different for this app and build a web-based interface. Even here, we have many, many options: JSF, Spring MVC, Google Web Toolkit, Vaadin, and more. Oftentimes, in real-world applications, while we may have a Java backend, we may have a JavaScript frontend, so that's what we'll do here, and that's where your choices can get really dizzying.</p>
<p class="mce-root">The two biggest players in that market at the time of the writing of this book are React from Facebook and Angular from Google. There are several smaller contenders, such as React API-compatible Preact, VueJS, Backbone, Ember, and so on. Which you choose will have a significant impact on the application, everything from architecture to the more mundane things such as building the project itself, or you could let architecture drive the framework if there's a compelling need for a specific architecture. As always, your particular environment will vary and should drive that decision more than what you read in a book or online.</p>
<p class="mce-root">Since this is a Java book, and I'd like to avoid getting too far into the intimate details of JavaScript build systems and alternate <strong class="calibre8">JavaScript VM</strong> languages, transpiling, and so on, I've chosen to use Vue, as it is a fast, modern, and popular framework that meets our needs, yet still allows us to build a simple system without requiring complicated build configurations. If you have experience with, or a preference for, another framework, it should be fairly simple for you to build a comparable system using the framework of your choice.</p>
<div class="packt_infobox">Note that I am <em class="calibre22">not</em> a JavaScript developer. The application we'll build in this part of the chapter should not be construed to be an example of best practices. It is merely an attempt to build a usable, albeit plain, JavaScript frontend to demonstrate a full stack application. Please consult the documentation for Vue or your framework of choice for details on how to build idiomatic applications with the tool.</div>
<p class="mce-root">Let's start with the index page. In the project explorer window in NetBeans, expand the <span class="calibre7">Other Sources</span> node, right-click on the <span class="calibre7">webapp</span> node, and select <span class="calibre7">New</span> | <span class="calibre7">Empty File</span>, giving it the name <kbd class="calibre16">index.html</kbd>. The bare minimum we need in the file at this point is the following:</p>
<pre class="calibre21">    &lt;!DOCTYPE html&gt; 
      &lt;html&gt; 
        &lt;head&gt; 
          &lt;title&gt;Monumentum&lt;/title&gt; 
          &lt;meta charset="UTF-8"&gt; 
          &lt;link rel="stylesheet" href="monumentum.css"&gt; 
          &lt;script src="https://unpkg.com/vue"&gt;&lt;/script&gt; 
        &lt;/head&gt; 
        &lt;body&gt; 
          &lt;div id="app"&gt; 
            {{ message }} 
          &lt;/div&gt; 
          &lt;script type="text/javascript" src="index.js"&gt;&lt;/script&gt; 
        &lt;/body&gt; 
      &lt;/html&gt; </pre>
<p class="mce-root">This will display a blank page at the moment, but it does import the source for Vue, as well as the JavaScript for our client app, <kbd class="calibre16">index.js</kbd>, which we need to create:</p>
<pre class="calibre21">    var vm = new Vue({ 
      el: '#app', 
      data: { 
        message : 'Hello, World!' 
      } 
    }); </pre>
<p class="mce-root">If we deploy those changes (HINT: If the app is already running, just press <em class="calibre20">F11</em> to tell NetBeans to build; that won't make any Java changes take effect, but it will copy these static resources to the output directory) and refresh the page in the browser, we should now see <em class="calibre20">Hello, World!</em> on the page.</p>
<p class="mce-root">Roughly put, what's happening is that we're creating a new <kbd class="calibre16">Vue</kbd> object, anchoring to the (<kbd class="calibre16">el</kbd>) element with the <kbd class="calibre16">app</kbd> ID. We're also defining some state for this component (<kbd class="calibre16">data</kbd>), which includes the single property, <kbd class="calibre16">message</kbd>. On the page, anywhere inside the element <kbd class="calibre16">app</kbd>, we can access the component's state using the Mustache syntax we see in the index page--<kbd class="calibre16">{{ message }}</kbd>. Let's expand our component a bit:</p>
<pre class="calibre21">    var vm = new Vue({ 
      el: '#app', 
      store, 
      computed: { 
        isLoggedIn() { 
          return this.$store.state.loggedIn; 
        } 
      }, 
      created: function () { 
        NotesActions.fetchNotes(); 
      } 
    }); </pre>
<p class="mce-root">We've added three items here:</p>
<ul class="calibre13">
<li class="calibre14">We've introduced a global data store, aptly called <kbd class="calibre16">store</kbd></li>
<li class="calibre14">We've added a new property called <kbd class="calibre16">isLoggedIn</kbd>, which gets its value from a method call</li>
<li class="calibre14">We've added a lifecycle method, <kbd class="calibre16">created</kbd>, which will load <kbd class="calibre16">Note</kbd> from the server when the component is created on the page</li>
</ul>
<p class="mce-root">Our data store is based on Vuex, a <span class="calibre7">state-management pattern + library</span> for <kbd class="calibre16">Vue.js</kbd> applications. It serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion. (<a href="https://vuex.vuejs.org/" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://vuex.vuejs.org</span></a>). To add it to our application, we need to add the following line of code to our page:</p>
<pre class="calibre21">    &lt;script src="https://unpkg.com/vuex"&gt;&lt;/script&gt;</pre>
<p class="mce-root">We then add a field called <kbd class="calibre16">store</kbd> to our component, which you can see in the preceding code. Most of the work so far takes place in the <kbd class="calibre16">NotesActions</kbd> object:</p>
<pre class="calibre21">    var NotesActions = { 
      buildAuthHeader: function () { 
        return new Headers({ 
          'Content-Type': 'application/json', 
          'Authorization': 'Bearer ' +    
          NotesActions.getCookie('Bearer') 
        }); 
      }, 
      fetchNotes: function () { 
        fetch('api/notes', { 
          headers: this.buildAuthHeader() 
        }) 
        .then(function (response) { 
          store.state.loggedIn = response.status === 200; 
          if (response.ok) { 
            return response.json(); 
          } 
        }) 
        .then(function (notes) { 
          store.commit('setNotes', notes); 
        }); 
      } 
    } </pre>
<p class="mce-root">When the page loads, the application will immediately send a request to the backend for Notes, sending the bearer token, if there is one, in the <kbd class="calibre16">Authorization</kbd> header. When the response returns, we update the state of the <kbd class="calibre16">isLoggedIn</kbd> property in the store, and, if the request was successful, we update the list of <kbd class="calibre16">Notes</kbd> on the page. Note that we're using <kbd class="calibre16">fetch()</kbd>. That is the new, experimental API for sending XHR, or Ajax, requests in browsers. As of the writing of this book, it is supported in every major browser except Internet Explorer, so be careful using this in production apps if you can't dictate the client's browser.</p>
<p class="mce-root">We've seen the store used a few times, so let's take a look at it:</p>
<pre class="calibre21">    const store = new Vuex.Store({ 
      state: { 
        notes: [], 
        loggedIn: false, 
        currentIndex: -1, 
        currentNote: NotesActions.newNote() 
      } 
    }; </pre>
<p class="mce-root">The store is of type <kbd class="calibre16">Vuex.Store</kbd>, and we specify the various state fields in its <kbd class="calibre16">state</kbd> property. Handled properly, any Vue component bound to one of these state fields is automatically updated for you. You don't need to track and manage state, manually reflecting changes on the page as the application state changes. Vue and Vuex handle that for you. Mostly. There are some situations, such as array mutation (or replacement), that require some special handling. Vuex offers <strong class="calibre8">mutations</strong> to help with that. For example, <kbd class="calibre16">NotesAction.fetchNotes()</kbd>, upon a successful request, we will make this call:</p>
<pre class="calibre21">     store.commit('setNotes', notes); </pre>
<p class="mce-root">The preceding code tells the store to <kbd class="calibre16">commit</kbd> a mutation called <kbd class="calibre16">setNotes</kbd>, with <kbd class="calibre16">notes</kbd> as the payload. We define mutations like this:</p>
<pre class="calibre21">    mutations: { 
      setNotes(state, notes) { 
        state.notes = []; 
        if (notes) { 
          notes.forEach(i =&gt; { 
            state.notes.push({ 
              id: i.id, 
              title: i.title, 
              body: i.body, 
              created: new Date(i.created), 
              modified: new Date(i.modified) 
            }); 
        }); 
      } 
    } </pre>
<p class="mce-root">What we are passing into this mutation (you can probably think of this as a function or a method with a peculiar invocation syntax if that helps) is a JSON array (hopefully, we show no type checking here), so we start by clearing out the current list of notes, then iterating over this array, creating and storing new objects, and reformatting some of the data as we do so. Strictly using only this mutation to replace the set of notes, we can guarantee that the user interface is kept in sync with the changing state of the application, all for free.</p>
<p class="mce-root">So how are these notes displayed? To do that, we define a new Vue component and add it to the page, as follows:</p>
<pre class="calibre21">    &lt;div id="app"&gt; 
      &lt;note-list v-bind:notes="notes" v-if="isLoggedIn"&gt;&lt;/note-list&gt; 
    &lt;/div&gt; </pre>
<p class="mce-root">Here, we've referenced a new component called <kbd class="calibre16">note-list</kbd>. We've bound the template variable <kbd class="calibre16">notes</kbd> to the application variable of the same name, and specified that the component is only displayed if the user is logged. The actual component definition happens in JavaScript. Back in <kbd class="calibre16">index.js</kbd>, we have this:</p>
<pre class="calibre21">    Vue.component('note-list', { 
      template: '#note-list-template', 
      store, 
      computed: { 
        notes() { 
          return this.$store.state.notes; 
        }, 
        isLoggedIn() { 
          return this.$store.state.loggedIn; 
        } 
      }, 
      methods: { 
        loadNote: function (index) { 
          this.$store.commit('noteClicked', index); 
        }, 
        deleteNote: function (index) { 
          if (confirm 
            ("Are you sure want to delete this note?")) { 
              NotesActions.deleteNote(index); 
            } 
        } 
      } 
    }); </pre>
<p class="mce-root">This component is named <kbd class="calibre16">note-list</kbd>; its template is found in an element with the <kbd class="calibre16">note-list-template</kbd> ID; it has two computed values: <kbd class="calibre16">notes</kbd> and <kbd class="calibre16">isLoggedIn</kbd>; and it provides two methods. In a typical Vue application, we would have a number of files, all ultimately compiled together using something like Grunt or Gulp, and one of these files would be our component's template. Since we are trying to make this as simple as possible by avoiding the JS build processes, we have everything declared right on our page. In <kbd class="calibre16">index.html</kbd>, we can find the template for our component:</p>
<pre class="calibre21">    &lt;script type="text/x-template" id="note-list-template"&gt; 
      &lt;div class="note-list"&gt; 
        &lt;h2&gt;Notes:&lt;/h2&gt; 
        &lt;ul&gt; 
          &lt;div class="note-list"  
            v-for="(note,index) in notes" :key="note.id"&gt; 
          &lt;span : 
             v-on:click="loadNote(index,note);"&gt; 
          {{ note.title }} 
          &lt;/span&gt; 
            &lt;a v-on:click="deleteNote(index, note);"&gt; 
              &lt;img src="images/x-225x225.png" height="20"  
                 width="20" alt="delete"&gt; 
            &lt;/a&gt; 
          &lt;/div&gt; 
        &lt;/ul&gt; 
        &lt;hr&gt; 
      &lt;/div&gt;  
    &lt;/script&gt; </pre>
<p class="mce-root">Using a <kbd class="calibre16">script</kbd> tag with with the <kbd class="calibre16">text/x-template</kbd> type, we can add the template to the DOM without it rendering on the page. Inside this template, the interesting part is the <kbd class="calibre16">div</kbd> tag with the <kbd class="calibre16">note-list</kbd> class. We have the <kbd class="calibre16">v-</kbd> attribute on it, which means the Vue template processor will iterate over the <kbd class="calibre16">notes</kbd> list using this <kbd class="calibre16">div</kbd> as a template for displaying each <kbd class="calibre16">note</kbd> in the array.</p>
<p class="mce-root">Each note will be rendered using the <kbd class="calibre16">span</kbd> tag. Using the template markup <kbd class="calibre16">:title</kbd>, we are able to create a value for the title tag using our application state (we can't say because string interpolation was deprecated in Vue 2.0). The sole child of the <kbd class="calibre16">span</kbd> tag is the <kbd class="calibre16">{{ note.title }}</kbd> expression, which renders the title of the <kbd class="calibre16">note</kbd> list as a string. When the user clicks on the note title on the page, we want to react to that, so we bind the <kbd class="calibre16">onClick</kbd> handler to the DOM element via <kbd class="calibre16">v-on:click</kbd>. The function referenced here is the <kbd class="calibre16">loadNote()</kbd> function that we defined in the <kbd class="calibre16">methods</kbd> block of our component definition.</p>
<p class="mce-root">The <kbd class="calibre16">loadNote()</kbd> function calls a mutation we haven't looked at yet:</p>
<pre class="calibre21">    noteClicked(state, index) { 
      state.currentIndex = index; 
      state.currentNote = state.notes[index]; 
      bus.$emit('note-clicked', state.currentNote); 
    } </pre>
<p class="mce-root">This mutation modifies the state to reflect the note that the user clicked on, then fires (or emits) an event called <kbd class="calibre16">note-clicked</kbd>. The event system is really quite simple. It is set up like this:</p>
<pre class="calibre21">    var bus = new Vue(); </pre>
<p class="mce-root">That's literally it. This is just a bare bones, globally scoped Vue component. We fire events by calling <kbd class="calibre16">bus.$emit()</kbd> method, and register event listeners by calling the <kbd class="calibre16">bus.$on()</kbd> method. We'll see what that looks like in the note form.</p>
<p class="mce-root">We will add the note form component to the page like we did the <kbd class="calibre16">note-list</kbd> component:</p>
<pre class="calibre21">    &lt;div id="app"&gt; 
      &lt;note-list v-bind:notes="notes" v-if="isLoggedIn"&gt;&lt;/note-list&gt; 
      &lt;note-form v-if="isLoggedIn"&gt;&lt;/note-form&gt; 
    &lt;/div&gt; </pre>
<p class="mce-root">And, again, the component is defined in <kbd class="calibre16">index.js</kbd> as follows:</p>
<pre class="calibre21">    Vue.component('note-form', { 
      template: '#note-form-template', 
      store, 
      data: function () { 
        return { 
          note: NotesActions.newNote() 
        }; 
      }, 
      mounted: function () { 
        var self = this; 
        bus.$on('add-clicked', function () { 
          self.$store.currentNote = NotesActions.newNote(); 
          self.clearForm(); 
        }); 
        bus.$on('note-clicked', function (note) { 
          self.updateForm(note); 
        }); 
        CKEDITOR.replace('notebody'); 
      } 
    }); </pre>
<p class="mce-root">The template is also in <kbd class="calibre16">index.html</kbd>, as shown here:</p>
<pre class="calibre21">    &lt;script type="text/x-template" id="note-form-template"&gt; 
      &lt;div class="note-form"&gt; 
        &lt;h2&gt;{{ note.title }}&lt;/h2&gt; 
        &lt;form&gt; 
          &lt;input id="noteid" type="hidden"  
            v-model="note.id"&gt;&lt;/input&gt; 
          &lt;input id="notedate" type="hidden"  
            v-model="note.created"&gt;&lt;/input&gt; 
          &lt;input id="notetitle" type="text" size="50"  
            v-model="note.title"&gt;&lt;/input&gt; 
          &lt;br/&gt; 
          &lt;textarea id="notebody"  
            style="width: 100%; height: 100%"  
            v-model="note.body"&gt;&lt;/textarea&gt; 
          &lt;br&gt; 
          &lt;button type="button" v-on:click="save"&gt;Save&lt;/button&gt; 
        &lt;/form&gt; 
      &lt;/div&gt; 
    &lt;/script&gt; </pre>
<p class="mce-root">This is mostly normal HTML form. The interesting bit is the v-model that ties the form element to the component's property. Changes made on the form are automatically reflected in the component, and changes made in the component (for example, via an event handler) are automatically reflected in the UI. We also attach an <kbd class="calibre16">onClick</kbd> handler via the now familiar <kbd class="calibre16">v-on:click</kbd> attribute.</p>
<p class="mce-root">Did you notice the reference to <kbd class="calibre16">CKEDITOR</kbd> in our component definition? We'll use the rich text editor <kbd class="calibre16">CKEditor</kbd> to provide a better experience. We could go to <kbd class="calibre16">CKEditor</kbd> and download the distribution bundle, but we have a better way--WebJars. The WebJars project takes popular client-side web libraries and packages them as JARs. This makes adding supported libraries to the project very simple:</p>
<pre class="calibre21">    &lt;dependency&gt; 
      &lt;groupId&gt;org.webjars&lt;/groupId&gt; 
      &lt;artifactId&gt;ckeditor&lt;/artifactId&gt; 
      &lt;version&gt;4.6.2&lt;/version&gt; 
    &lt;/dependency&gt; </pre>
<p class="mce-root">When we package the application, this binary jar is added to the web archive. However, if it's still archived, how do we access the resources? There are a number of options depending on the type of application you are building. We'll make use of Servlet 3's static resource handling (anything under <kbd class="calibre16">META-INF/resources</kbd> that's packaged in the web application's <kbd class="calibre16">lib</kbd> directory are automatically exposed). In <kbd class="calibre16">index.html</kbd>, we add <kbd class="calibre16">CKEditor</kbd> to the page with this simple line:</p>
<pre class="calibre21">    &lt;script type="text/javascript"<br class="calibre2"/>      src="webjars/ckeditor/4.6.2/standard/ckeditor.js"&gt;&lt;/script&gt;</pre>
<p class="mce-root"><kbd class="calibre16">CKEditor</kbd> is now ready to use.</p>
<p class="mce-root">One last major piece on the frontend is enabling the user to log in. To do that, we'll create another component as follows:</p>
<pre class="calibre21">    &lt;div id="app"&gt; 
      &lt;navbar&gt;&lt;/navbar&gt; 
      &lt;note-list v-bind:notes="notes" v-if="isLoggedIn"&gt;&lt;/note-list&gt; 
      &lt;note-form v-if="isLoggedIn"&gt;&lt;/note-form&gt; 
    &lt;/div&gt; </pre>
<p class="mce-root">Then, we will add the following component definition:</p>
<pre class="calibre21">    Vue.component('navbar', { 
      template: '#navbar-template', 
      store, 
      data: function () { 
        return { 
          authUrl: "#" 
        }; 
      }, 
      methods: { 
        getAuthUrl: function () { 
          var self = this; 
          fetch('api/auth/url') 
          .then(function (response) { 
            return response.text(); 
          }) 
          .then(function (url) { 
            self.authUrl = url; 
          }); 
        } 
      }, 
      mounted: function () { 
        this.getAuthUrl(); 
      } 
    }); </pre>
<p class="mce-root">And, finally, we will add the template as follows:</p>
<pre class="calibre21">    &lt;script type="text/x-template" id="navbar-template"&gt; 
      &lt;div id="nav" style="grid-column: 1/span 2; grid-row: 1 / 1;"&gt; 
        &lt;a v-on:click="add" style="padding-right: 10px;"&gt; 
          &lt;img src="images/plus-225x225.png" height="20"  
            width="20" alt="add"&gt; 
        &lt;/a&gt; 
        &lt;a v-on:click="logout" v-if="isLoggedIn"&gt;Logout&lt;/a&gt; 
        &lt;a v-if="!isLoggedIn" :href="authUrl"  
         style="text-decoration: none"&gt;Login&lt;/a&gt; 
      &lt;/div&gt; 
    &lt;/script&gt; </pre>
<p class="mce-root">When this component is <strong class="calibre8">mounted</strong> (or attached to the element in the DOM), we call the <kbd class="calibre16">getAuthUrl()</kbd> function that sends an Ajax request to the server for our Google login URL. Once that's fetched, the login anchor tag is updated to refer to the URL.</p>
<p class="mce-root">There are a few more details in the JavaScript file we've not covered here explicitly, but interested parties can check out the source code in the repository and read through it for the remaining details. We do have a working JavaScript frontend for our note-taking app that supports listing, creating, updating, and deleting notes, as well as supporting multiple users. It's not a pretty application, but it works. Not bad for a Java guy!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Now we're back to the familiar refrain--our application is <strong class="calibre8">finished</strong>. What have we covered in the chapter? We've created a REST API using JAX-RS that doesn't require direct JSON manipulation. We've learned how to apply request filters to JAX-RS endpoints to restrict access to authenticated users, which we authenticate against their Google accounts using Google's OAuth2 workflow. We've packaged the application using Payara Micro, a great option to develop microservices, and we've integrated MongoDB into our application using the MongoDB Java API. Finally, we built a very basic JavaScript client using Vue.js to access our application.</p>
<p class="mce-root">There are a lot of new concepts and technologies interacting in this application, which makes it interesting from a technical perspective, but there's still more that could be done. The application could use a great deal of styling, and support for embedded images and videos would be nice, as would a mobile client. There is lots of room for improvements and enhancements with the app, but interested parties have a solid foundation to start from. Although, for us, it's time to turn to the next chapter and a new project, where we'll jump into the world of cloud computing with Functions as a Service.</p>


            </article>

            
        </section>
    </div>



  </body></html>