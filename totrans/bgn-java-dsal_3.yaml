- en: Hash Tables and Binary Search Trees
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希表和二叉搜索树
- en: In the preceding chapter, we introduced the concept of data structures by looking
    at arrays, linked lists, queues, and stacks. In this chapter, we will use some
    of these primitive structures to build more complex ones. We'll start the chapter
    by looking at hash tables, which are useful data structures for fast key-value
    lookup. In the second part of the chapter, we will learn about a more complex
    data structure that supports range queries, called binary trees.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过查看数组、链表、队列和栈等数据结构来介绍数据结构的概念。在本章中，我们将使用一些这些基本结构来构建更复杂的数据结构。我们将从查看哈希表开始，这是一种用于快速键值查找的有用数据结构。在章节的第二部分，我们将学习一种支持范围查询的更复杂的数据结构，称为二叉树。
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Describe how hash tables work
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述哈希表的工作原理
- en: Implement two main techniques to deal with hash collisions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现两种处理哈希冲突的主要技术
- en: Characterize different hashing choices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述不同的哈希选择
- en: Explain the terminology, structure, and operations of binary trees
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释二叉树的术语、结构和操作
- en: Demonstrate various tree traversal techniques
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示各种树遍历技术
- en: Define balanced binary search trees
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义平衡二叉搜索树
- en: Introducing Hash Tables
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍哈希表
- en: A data structure that gives us the ability to insert, search, and optionally
    delete elements in a collection is called a **data dictionary**. Commonly, the
    type of data used is a key-value pair association, where we insert the key-value
    pair but search using a key to obtain the value.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在集合中插入、搜索，并可选择性删除元素的数据结构称为**数据字典**。通常，使用的数据类型是键值对关联，我们插入键值对，但使用键来搜索以获取值。
- en: Hash tables provide us with a fast data structure for organizing these key value
    pairs and implementing our data dictionary. They are useful in a wide variety
    of applications due to the quick lookup and ease of use for in-memory data storage.
    Insertion and search operations have a typical average runtime complexity of *O(1)*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表为我们提供了一种快速的数据结构来组织这些键值对并实现我们的数据字典。由于快速查找和在内存数据存储中的易用性，它们在广泛的领域中非常有用。插入和搜索操作的平均运行时间复杂度为*O(1)*。
- en: Understanding Hash Tables
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解哈希表
- en: 'Let''s look at an example problem to help us understand the need for hash tables.
    Imagine you are a teacher, instructing a class of a maximum capacity of 30 students.
    The students sit at their assigned desks every day. To make your life easier,
    you decide to assign a sequential number from one to 30 to each desk. You then
    use this number to identify each student, and use your self-developed app to bring
    up the student''s records after you enter the desk number (see *Figure 3.1*).
    This way, you can quickly look up details such as the student''s name, date of
    birth, notes, and exam history:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例问题来帮助我们理解哈希表的需求。想象你是一名教师，负责一个最多容纳30名学生的班级。学生们每天坐在指定的课桌旁。为了使你的生活更轻松，你决定为每个课桌分配一个从1到30的连续编号。然后你使用这个编号来识别每个学生，并在输入课桌编号后使用你自行开发的程序调出学生的记录（见*图3.1*）。这样，你可以快速查找学生的姓名、出生日期、笔记和考试历史等详细信息：
- en: '![](img/edfe6217-a5f9-4529-90a1-38aee455f640.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/edfe6217-a5f9-4529-90a1-38aee455f640.png)'
- en: 'Figure 3.1: App for displaying student''s records for student at desk number
    eight'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：显示编号为八的课桌学生的记录的应用程序
- en: In this problem, a simple array can be used to store all students' records in
    memory. Each of the array's positions can contain one student record. This would
    allow you to access the array directly using a strategy of *index = deskNumber
    - 1*. If, in a particular year you have fewer students, and not all the desks
    are occupied, you will place nulls at the corresponding array index. This solution
    is shown in *Figure 3.2*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，可以使用一个简单的数组来在内存中存储所有学生的记录。数组的每个位置可以包含一个学生记录。这将允许你使用*index = deskNumber
    - 1*的策略直接访问数组。如果在某一年你拥有的学生数量较少，并且不是所有的课桌都被占用，你将在相应的数组索引处放置null。这种解决方案在*图3.2*中显示。
- en: 'This is an example of direct addressing, where each student''s record is accessed using
    a key (the desk number). This type of solution can only be used when the possible
    key range is small enough to fit in an array which is directly in memory:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个直接寻址的示例，其中每个学生的记录都是通过一个键（课桌号）访问的。这种解决方案只能在可能的键范围足够小，可以放入直接在内存中的数组时使用：
- en: '![](img/738f0a76-df15-4b08-b50f-cab05fce1cec.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/738f0a76-df15-4b08-b50f-cab05fce1cec.png)'
- en: 'Figure 3.2: Example of direct addressing'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：直接寻址的示例
- en: To help us determine how efficiently we are using memory, we can measure the
    load factor. The load factor is simply a metric showing how fully utilized our
    data structure is. When the class is at max capacity, all the elements in the
    array will contain a record. We say that the load factor of our data structure
    is 1 (or at 100%). If, for example, only 15 students out of 30 spaces have registered
    for a particular year, the load factor is 0.5 (50%). A lower load factor value
    means that we are under-utilizing and wasting memory.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们确定我们使用内存的效率，我们可以测量负载因子。负载因子是一个简单的指标，显示我们的数据结构被充分利用的程度。当班级达到最大容量时，数组中的所有元素都将包含一个记录。我们说我们的数据结构的负载因子是1（或100%）。例如，如果只有15名学生中的30个空间注册了特定年份，则负载因子为0.5（50%）。较低的负载因子值意味着我们正在低效使用并浪费内存。
- en: Now, let's expand our example to include not just a class but an entire school,
    and instead of teaching one class, you have now been promoted to the head of the
    entire school. In this new position, you want to keep student records for every
    person currently enrolled. You also want to store historical records for any past
    students that are no longer in the school. You decide to use the national ID or
    passport number as a key to uniquely identify each one of your students. Assuming
    this is a US or an EU school, the national ID or passport number typically consists
    of nine numeric digits or more.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们的例子扩展到包括一个班级，甚至整个学校，而不仅仅是教授一个班级，你现在已经被提升为整个学校的校长。在这个新的职位上，你想要为目前注册的每个人保存学生记录。你还想存储任何不再在学校的学生的历史记录。你决定使用国家身份证或护照号码作为唯一标识每个学生的键。假设这是一所美国或欧盟的学校，国家身份证或护照号码通常由九位或更多的数字组成。
- en: Since our input range is quite big, directly addressing this would be very impractical.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的输入范围相当大，直接处理这个问题将非常不切实际。
- en: Since the US passport number (or national ID) is typically nine numeric digits, we
    would have to construct a huge array to store any possible number. For a nine-digit
    numeric range, the array's size would be 1,000,000,000\. Assuming each pointer
    is four bytes, this array alone would  consume almost 4 GB! The load factor of
    this example would also be terribly low. Most of the array will be empty, as the
    school will only have a few thousand present and past students.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于美国护照号码（或国家身份证）通常是九位数字，我们不得不构建一个巨大的数组来存储任何可能的数字。对于一个九位数字的范围，数组的大小将是1,000,000,000。假设每个指针是四字节，这个数组本身就会消耗近4
    GB！这个例子中的负载因子也会非常低。大多数数组将是空的，因为学校只有几千名现任和往届学生。
- en: We can still store the students' records in an array sized to a few thousand.
    All we need to do is find a way to squeeze our input key range into our array
    index range. Essentially, this means mapping our nine-digit numeric passport into
    a four-digit one. This job can be done by what is known as a hash function. A
    hash function would accept a key (our passport number) and return an array index
    within the size of our array (see *Figure 3.3*).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以将学生的记录存储在一个容量为几千的数组中。我们需要的只是找到一种方法将我们的输入键范围压缩到我们的数组索引范围内。本质上，这意味着将我们的九位数字护照映射到一个四位的数字。这项工作可以通过所谓的哈希函数来完成。哈希函数将接受一个键（我们的护照号码）并返回一个位于我们数组大小内的数组索引（见*图3.3*）。
- en: 'We say that a hash function maps our input key universe to our chosen hash
    range, which in this example is our array size:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说哈希函数将我们的输入键宇宙映射到我们选择的哈希范围，在这个例子中是数组大小：
- en: '![](img/6a09b166-4f1a-4a62-8b2c-0f819930271f.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6a09b166-4f1a-4a62-8b2c-0f819930271f.png)'
- en: 'Figure 3.3: Using hash functions'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：使用哈希函数
- en: 'Using a hash function enables us to use a much smaller array and saves us a
    lot of memory. However, there is a catch. Since we are forcing a bigger key space
    into a smaller one, there is a risk that multiple keys map to the same hashed
    array index. This is what is called a **collision**; we have a key hash to an
    already filled position. The strategy on how to deal with collisions together
    with the choice of hash function make up our hash table. The following code snippet
    shows a Java interface that defines our hash table API. We will gradually implement
    this interface in later sections of this chapter:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哈希函数使我们能够使用一个更小的数组，并节省大量内存。然而，有一个问题。由于我们正在将更大的键空间强制压缩到更小的空间中，存在多个键映射到同一个哈希数组索引的风险。这被称为**冲突**；我们有一个键哈希到已经填满的位置。如何处理冲突的策略以及哈希函数的选择构成了我们的哈希表。以下代码片段显示了一个Java接口，它定义了我们的哈希表API。我们将在本章的后续部分逐步实现这个接口：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Snippet 3.1: Hashtable interface. Source class name: Hashtable'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段3.1：Hashtable接口。源类名：Hashtable
- en: Go to [https://goo.gl/FK1q6k](https://goo.gl/FK1q6k) to access this code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://goo.gl/FK1q6k](https://goo.gl/FK1q6k)以获取此代码。
- en: In Java, the classes `java.util.Hashtable` and `java.util.HashMap` both implement
    the interface `HashTable`. The main difference between the two classes is that
    the `HashMap` is unsynchronized and permits nulls.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，类`java.util.Hashtable`和`java.util.HashMap`都实现了`HashTable`接口。这两个类的主要区别在于`HashMap`是非同步的，并允许null值。
- en: In this section, we first introduced direct addressing by looking at an example
    scenario. Later, we expanded the problem to a bigger key space, showing how hash
    tables can be used in such a scenario. In the next section, we will see two common
    solutions for dealing with hash table collisions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们首先通过查看一个示例场景介绍了直接寻址。随后，我们将问题扩展到更大的键空间，展示了在这种情况下如何使用哈希表。在下一节中，我们将看到处理哈希表碰撞的两种常见解决方案。
- en: Dealing with Collisions with Chaining
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理链式碰撞
- en: What do we do when two keys hash to the same slot in our array? Overwriting
    the element in our array is not an option as this would mean losing records. One
    common solution to deal with collisions is a technique called **chaining**. In
    this solution, the hash table data is stored outside the actual array itself.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个键在我们的数组中哈希到同一个槽位时，我们该怎么办？覆盖数组中的元素不是一种选择，因为这会导致记录丢失。处理碰撞的一个常见技术是称为**链式**。在这个解决方案中，哈希表数据存储在实际数组之外。
- en: 'The idea behind chaining is that each entry in our hash array has a pointer
    to its own linked list. Any items we add to our hash table are stored in these
    linked lists. Initially, every entry in the array is initialized to contain an
    empty linked list. Whenever we insert a particular array slot in the hash table,
    we insert it at the head of the linked list associated with that position. In
    this way, we can support hash collisions. Another insert, on an already occupied
    array slot, would result in a new item at the head of its linked list. *Figure
    3.4* shows an example in which two entries with different keys have hashed to
    the same array slot, resulting in the two records stored in the linked list:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 链式背后的思想是，我们哈希数组中的每个条目都有一个指向其自己的链表的指针。我们添加到哈希表中的任何项目都存储在这些链表中。最初，数组中的每个条目都被初始化为包含一个空链表。每次我们在哈希表中插入特定数组槽位时，我们都会将其插入到与该位置关联的链表头部。这样，我们可以支持哈希碰撞。在已经占用的数组槽位上进行的另一个插入操作将导致其链表头部出现一个新项目。"图3.4"展示了两个具有不同键的条目被哈希到同一个数组槽位的例子，导致这两个记录存储在链表中：
- en: '![](img/31c99548-bf7a-480e-bf9c-537ea923bc44.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/31c99548-bf7a-480e-bf9c-537ea923bc44.png)'
- en: 'Figure 3.4: Using linked lists to chain multiple entries in one hash slot'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：使用链表在单个哈希槽中链接多个条目
- en: Searching for a particular key requires first locating the array slot, and then
    traversing the linked list, one item at a time, looking for the required key until
    there is a match or the end of the list is reached. *Snippet 3.2* shows the search
    (`get`) and insert (`put`). The delete (`remove`) operation can be found by the
    URL provided after the snippet. We make use of Java's linked list collection for
    this hash table implementation. In the constructor, the array is initialized with
    the given capacity, and each element is filled with an empty linked list.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索特定键需要首先定位数组槽位，然后逐个遍历链表，寻找所需键，直到找到匹配项或到达链表末尾。"代码片段3.2"展示了搜索（`get`）和插入（`put`）。删除（`remove`）操作可以通过代码片段后面的URL找到。我们使用Java的链表集合来实现这个哈希表。在构造函数中，数组使用给定的容量初始化，并且每个元素都填充了一个空链表。
- en: Using the Java linked list collections enables us to use Java's lambda expressions
    when searching for the key in the `get(key)` method. When searching, we try to
    match the key with the ones found in the linked list and only return the optional
    value if a match is found.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java的链表集合，我们可以在`get(key)`方法中搜索键时使用Java的lambda表达式。在搜索时，我们尝试将键与链表中的键匹配，并且只有在找到匹配项时才返回可选值。
- en: 'Using the lambda expressions also enables us to implement the `delete` operation
    in a clean manner by just calling the `removeif()` method with a key-matching
    predicate (the `delete` operation can be found by the URL provided after the code
    snippet):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用lambda表达式还可以使我们通过仅调用带有键匹配谓词的`removeif()`方法（通过代码片段后面的URL可以找到删除操作）以干净的方式实现`delete`操作：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Snippet 3.2: The chained hash table. Source class name: ChainedHashTable'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段3.2：链式哈希表。源类名：ChainedHashTable
- en: Go to [https://goo.gl/mrzQfY](https://goo.gl/mrzQfY) to access this code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 访问此代码请前往 [https://goo.gl/mrzQfY](https://goo.gl/mrzQfY)。
- en: The best case runtime complexity for the search operation (`get()` method) shown
    in *Snippet 3.2* when the hash table contains *n* items is when we have no collisions,
    resulting in *O(1)*, and the worst is when we have n collisions, resulting in
    *O(n)*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *片段 3.2* 中显示的搜索操作（`get()` 方法）的最佳运行复杂度对于包含 *n* 个项目的哈希表是当没有冲突时，结果是 *O(1)*，而最坏的情况是有
    n 个冲突，结果是 *O(n)*。
- en: The `HashProvider` interface shown in *Snippet 3.2* simply provides us with
    a method that implements a hash function. We will implement this interface in
    the following sections when we explore different hash techniques. The runtime
    complexity for the chained hash table is dictated by how long our linked lists
    get. The best case is when every single item we insert in the hash table hashes
    to a different slot, that is, when there are no collisions. In the best case,
    we have a runtime of *O(1)* when each linked list only contains one item, and
    we can directly access any item.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *片段 3.2* 中显示的 `HashProvider` 接口简单地提供了一个实现哈希函数的方法。当我们在下一节探索不同的哈希技术时，我们将实现此接口。链式哈希表的时间复杂度取决于我们的链表有多长。最佳情况是当我们插入哈希表中的每个项目都散列到不同的槽位时，也就是说，没有冲突。在最佳情况下，当每个链表只包含一个项目时，我们有
    *O(1)* 的运行时间，并且可以直接访问任何项目。
- en: The worst-case is the other extreme, when every single item hashes to the same
    value, resulting in a linked list with n items. When this happens, the performance
    degrades to *O(n)* time to search for the required key. This is because we need
    to traverse the linked list of *n* nodes to search the required key.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏的情况是另一个极端，即每个项目都散列到相同的值，导致一个包含 n 个项目的链表。当这种情况发生时，性能下降到 *O(n)* 的时间来搜索所需的关键字。这是因为我们需要遍历
    *n* 个节点的链表来搜索所需的关键字。
- en: This worst runtime complexity of *O(n)* is applicable to all hash tables, not
    just chained ones. However, on average, and if the right hash function is chosen,
    the runtime performance of hash tables can be close to *O(1)*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种最坏的时间复杂度 *O(n)* 适用于所有哈希表，而不仅仅是链式哈希表。然而，平均而言，如果选择了正确的哈希函数，哈希表的运行性能可以接近 *O(1)*。
- en: A chained hash table has no load limit. Even in situations where none of the
    slots are empty, we can still add more items to the hash tables by continuing
    to append to the linked lists. This means that the load factor of a chained hash
    table can exceed the value of 1.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 链式哈希表没有负载限制。即使在没有任何槽位为空的情况下，我们仍然可以通过继续向链表追加来向哈希表添加更多项目。这意味着链式哈希表的负载因子可以超过 1
    的值。
- en: Chained hash tables are the most popular collision resolution implementation.
    The reason for this is that they are easy to implement, provide a good performance,
    and unlike some other techniques, allow the hash table structure to scale dynamically,
    and grow beyond the load factor of *1*. In the next section, we will discuss another
    solution dealing with collisions, called **open addressing**.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 链式哈希表是最流行的冲突解决实现方式。这是因为它们易于实现，提供了良好的性能，并且与一些其他技术不同，允许哈希表结构动态扩展，超过 *1* 的负载因子。在下一节中，我们将讨论另一种处理冲突的解决方案，称为
    **开放寻址**。
- en: Dealing with Collisions with Open Addressing
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用开放寻址处理冲突
- en: In the previous section, we saw how we can deal with collisions using linked
    lists at each array position. A chained hash table will keep on growing without
    any load limit. Open addressing is just another way of tackling hash collisions.
    In open addressing, all items are stored in the array itself, making the structure
    static with a maximum load factor limit of *1*. This means that once the array
    is full, you can't add any more items. The advantage of using open addressing
    is that, since you're not using linked lists, you're saving a bit of memory since
    you don't have to store any pointer references.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看到了如何使用每个数组位置的链表来处理冲突。链式哈希表将不断增长，没有任何负载限制。开放寻址只是处理哈希冲突的另一种方法。在开放寻址中，所有项目都存储在数组本身中，使得结构静态，最大负载因子限制为
    *1*。这意味着一旦数组满了，就不能再添加任何项目。使用开放寻址的优点是，由于你不需要使用链表，你可以节省一点内存，因为你不需要存储任何指针引用。
- en: You can then use this extra memory to have an even larger array and hold more
    of your key value pairs. To insert in an open-addressed hash table, we hash the
    key and simply insert the item in the hash slot, the same as a normal hash table.
    If the slot is already occupied, we search for another empty slot and insert the
    item in it. The manner in which we search for another empty slot is called the
    **probe sequence**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用这额外的内存来拥有一个更大的数组，并存储更多的键值对。要在开放地址哈希表中插入，我们首先对键进行哈希处理，然后将项目插入到哈希槽中，就像正常哈希表一样。如果槽位已被占用，我们搜索另一个空槽，并将项目插入其中。我们搜索另一个空槽的方式被称为**探测序列**。
- en: 'A simple strategy, shown in *Figure 3.5*, is to search by looking at the next
    available slot. This is called **linear probing**, where we start from the array
    index at the hash value and keep on increasing the index by one until we find
    an empty slot. The same probing technique needs to be used when searching for
    a key. We start from the hash slot and keep on advancing until we match the key
    or encounter an empty slot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的策略，如*图3.5*所示，是通过查看下一个可用的槽位来搜索。这被称为**线性探测**，我们从哈希值处的数组索引开始，继续增加索引一个单位，直到找到一个空槽。在搜索键时也需要使用相同的探测技术。我们从哈希槽开始，继续前进，直到匹配到键或遇到一个空槽：
- en: '![](img/7091d53a-8d89-4771-b0ac-6a3fc775c52e.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7091d53a-8d89-4771-b0ac-6a3fc775c52e.png)'
- en: 'Figure 3.5: Linear probing in open addressing'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：开放地址中的线性探测
- en: The next code snippet shows the pseudocode for linear probing insert. In this
    code, after we find the hash value we keep on increasing a pointer by one, searching
    for an empty slot.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了线性探测插入的伪代码。在这个代码中，我们在找到哈希值后，通过增加指针一个单位，继续寻找一个空槽。
- en: Once we reach the end of the array, we wrap around to the start using the *modulus*
    operator. This technique is similar to one we used when we implemented array-based
    stacks. We stop increasing the array pointer either when we find a null value
    (empty slot) or when we get back to where we started, meaning the hash table is
    full. Once we exit the loop, we store the key-value pair, but only if the hash
    table is not full.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们到达数组的末尾，我们使用*模数*运算符将其绕回到开始。这种技术与我们在实现基于数组的栈时使用的技术类似。我们停止增加数组指针，要么当我们找到一个null值（空槽），要么当我们回到起点，这意味着哈希表已满。一旦我们退出循环，我们就存储键值对，但前提是哈希表没有满。
- en: 'The pseudocode is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 伪代码如下：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Snippet 3.3: Pseudocode for inserting using linear probing'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 3.3节片段：使用线性探测插入的伪代码
- en: Searching for a key is similar to the insert operation. We first need to find
    the hash value from the key and then search the array in a linear fashion until
    we encounter the key, find a null value, or traverse the length of the array.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索键的操作与插入操作类似。我们首先需要从键中找到哈希值，然后以线性方式搜索数组，直到我们遇到键、找到一个null值或遍历数组的长度。
- en: If we want to delete items from our open, addressed hash table, we cannot simply
    remove the entry from our array and mark it as null. If we did this, the search
    operation would not be able to check all possible array positions for which the
    key might have been found. This is because the search operation stops as soon
    as it finds a null.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要从我们的开放、地址哈希表中删除项，我们不能简单地从数组中删除条目并将其标记为null。如果我们这样做，搜索操作将无法检查所有可能的位置，这些位置可能已经找到了键。这是因为搜索操作一旦找到null就会停止。
- en: One solution is to add a flag at each array position to signify that an item
    has been deleted without setting the entry to null. The search operation can then
    be modified to continue past entries marked as deleted. The insert operation also
    needs to be changed so that, if it encounters an entry marked as deleted, it writes
    the new item at that position.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是在每个数组位置添加一个标志，表示已删除项目，但未将条目设置为null。搜索操作可以修改为继续过去标记为已删除的条目。插入操作也需要更改，以便如果它遇到标记为已删除的条目，它将在该位置写入新项目。
- en: Linear probing suffers from a problem called **clustering**. This occurs when
    a long succession of non-empty slots develop, degrading the search and insert
    performance. One way to improve this is to use a technique called **quadratic
    probing**. This strategy is similar to linear probing, except that we probe for
    the next empty slot using a quadratic formula of the form *h + (ai + bi²)*, where
    *h* is the initial hash value, and *a* and *b* are constants. *Figure 3.6* shows
    the difference between using linear and quadratic probing with *a = 0* and *b
    = 1*. The diagram shows the order in which both techniques explore the array.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 线性探测有一个称为**聚类**的问题。这发生在一系列非空槽位连续出现时，会降低搜索和插入性能。一种改进的方法是使用称为**二次探测**的技术。这种策略与线性探测类似，但我们在使用二次公式*h
    + (ai + bi²)*探测下一个空槽位，其中*h*是初始哈希值，*a*和*b*是常数。*图3.6*显示了使用*a = 0*和*b = 1*时线性探测和二次探测之间的差异。该图显示了两种技术探索数组的顺序。
- en: 'In quadratic probing, we would change *Snippet 3.3* to check at array indexes
    of the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在二次探测中，我们将*3.3节代码片段*改为检查以下数组索引：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](img/89bf429a-fa38-4aee-b961-c970c6e2ace1.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89bf429a-fa38-4aee-b961-c970c6e2ace1.png)'
- en: Figure 3.6 Linear versus quadratic probing
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 线性探测与二次探测的比较
- en: Although quadratic probing reduces the effect of clustering, it suffers from
    a problem called secondary clustering. This is a milder form of clustering, however,
    it will still degrade performance. In addition, the constants *a* and *b*, and
    the array size need to be carefully chosen so that the probing explores the entire
    array.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然二次探测减少了聚类的效果，但它有一个称为**次级聚类**的问题。然而，这仍然会降低性能。此外，常数*a*和*b*以及数组大小需要仔细选择，以便探测可以探索整个数组。
- en: One other probing strategy used in open-addressing hash tables is called **double
    hashing**. This makes use of another hash function to determine the step offset
    from the initial hash value. In double hashing, we probe the array using the expression
    *h + ih'(k)*, where *h* is the hash value and *h'(k)* is a secondary hash function
    applied on the key. The probing mechanism is similar to linear probing, where
    we start with an *i* of zero and increase by one on every collision. Doing so
    results in probing the array every *h'(k)* step. The advantage of double hashing
    is that the probing strategy changes on every key insert, reducing the chances
    of clustering.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在开放寻址哈希表中使用的另一种探测策略被称为**双重哈希**。这利用另一个哈希函数来确定从初始哈希值开始的步长偏移。在双重哈希中，我们使用表达式*h +
    ih'(k)*来探测数组，其中*h*是哈希值，*h'(k)*是对键应用的一个辅助哈希函数。探测机制与线性探测类似，我们从*i*为零开始，每次冲突时增加一。这样做会导致每*h'(k)*步探测数组。双重哈希的优势在于探测策略在每次键插入时都会改变，从而减少了聚类的可能性。
- en: In double hashing, care must be taken to ensure that the entire array is explored.
    This can be achieved using various tricks. For example, we can size our array
    to an even number and make sure the secondary hash function returns only odd numbers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在双重哈希中，必须注意确保整个数组被探索。这可以通过各种技巧实现。例如，我们可以将数组大小设置为偶数，并确保辅助哈希函数只返回奇数。
- en: Carrying out the Linear Probing Search Operation
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行线性探测搜索操作
- en: The aim here is to develop pseudocode for the search operation in linear probing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目的是为线性探测中的搜索操作开发伪代码。
- en: 'Perform the following steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Write pseudocode similar to *Snippet 3.3* to show the search operation. The operation
    should return null if the key is not found in the hash table. The search function
    should have a signature as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写类似于*3.3节代码片段*的伪代码以显示搜索操作。如果键在哈希表中找不到，则操作应返回null。搜索函数的签名如下：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The pseudocode can be developed as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以按照以下方式开发伪代码：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Snippet 3.4: Solution pseudocode for searching using linear probing'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 3.4节代码片段：使用线性探测的搜索操作的伪代码
- en: In this section, we have seen another manner for dealing with hash collisions
    by keeping all items in the array itself, saving memory, but limiting the structure
    statically. In the next subsection, we shall go into detail about some of the
    various hash functions available.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了另一种处理哈希冲突的方法，即保持所有项目在数组本身中，节省内存，但限制了结构的静态性。在下一个小节中，我们将详细介绍一些可用的各种哈希函数。
- en: Remainder and Multiplication Hash Functions
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 余数和乘法哈希函数
- en: For hash tables, a hash function maps a specific key's space into a smaller
    number range. More formally, a hash function, *f*, maps keys of a specific data
    type to integers in a fixed interval *[0,..., N - 1]*. We say *f(x)* hashes the
    value of *x*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于哈希表，哈希函数将特定键的空间映射到一个更小的数字范围。更正式地说，哈希函数*f*将特定数据类型的键映射到固定区间*[0,..., N - 1]*中的整数。我们说*f(x)*对*x*的值进行哈希。
- en: The hash function can accept only numeric data types. To allow us to use hash
    tables on more complex data types, we usually need to convert all these types
    into numeric representations. This translation varies, depending on the type of
    data. For example, a character can be changed into its UTF-8 (or ASCII) numeric
    equivalent. Converting a full string can be done by converting each character
    separately and then using a strategy to combine the characters into one value.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数只能接受数值数据类型。为了使我们能够在更复杂的数据类型上使用哈希表，我们通常需要将这些类型转换为数值表示。这种转换因数据类型的不同而不同。例如，一个字符可以转换为它的UTF-8（或ASCII）数值等效。转换整个字符串可以通过分别转换每个字符然后使用一种策略将字符组合成一个值来完成。
- en: In Java, the `hashCode()` method converts an object into a numeric representation,
    which is ready to be used by a hash function. It is present in the object class
    and can be overridden using a custom implementation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，`hashCode()`方法将对象转换为数值表示，这可以由哈希函数使用。它在对象类中存在，可以通过自定义实现来重写。
- en: There are many techniques on how we can map keys from a wide range into smaller
    ones. An ideal hash function is one that reduces collisions to a minimum. In other
    words, when a good hash function is used, each key has the same probability of
    filling any of the slots in our array. In practice, finding an ideal hash function
    is very difficult unless we know the input distribution.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多技术可以帮助我们将广泛的键映射到更小的键集中。一个理想的哈希函数是那种将冲突减少到最小程度的函数。换句话说，当使用一个好的哈希函数时，每个键填充我们数组中任何槽位的概率都是相同的。在实践中，除非我们知道输入分布，否则找到理想的哈希函数是非常困难的。
- en: A simple technique to implement a hash function is what is known as the **remainder
    method**. The hash function simply takes in any numeric key, divides it by the
    table size (size of the array), and uses the resultant remainder as the hash value.
    This value can then be used as an index on the array.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实现哈希函数的一个简单技术被称为**余数法**。哈希函数简单地接受任何数值键，将其除以表大小（数组大小），并使用得到的余数作为哈希值。这个值然后可以用来作为数组的索引。
- en: 'The following code shows how the remainder hashing method can be implemented
    in Java using the modulus operator:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用取模运算符在Java中实现余数哈希方法：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Snippet 3.5: The remainder method. Source class name: RemainderHashing'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段3.5：余数法。源类名：RemainderHashing
- en: Go to [https://goo.gl/wNyWWX](https://goo.gl/wNyWWX) to access this code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://goo.gl/wNyWWX](https://goo.gl/wNyWWX)以获取此代码。
- en: The reminder method might result in many collisions if care is not taken when
    choosing an appropriate table size. Once again, consider the example given in
    the beginning of this section where we are using the student's passport or national
    ID number to identify a student in the school. To demonstrate the problem, we
    use an array-based hash table with a size of 1,000 elements. It just so happens
    that in the country where the school is based, the last four digits of the passport
    numbers represent the year of birth of the passport holder.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在选择适当的表大小时不小心，余数方法可能会导致许多冲突。再次考虑本节开头给出的例子，我们使用学生的护照或国家身份证号来识别学校中的学生。为了演示这个问题，我们使用了一个大小为1,000个元素的基于数组的哈希表。碰巧的是，在该学校所在的国家，护照号码的最后四位代表护照持有人的出生年份。
- en: When using the remainder method in this scenario, all the students with the
    same year of birth will hash to the same value, causing a lot of collisions on
    the hash table.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中使用余数方法时，所有同一年出生的学生都会哈希到相同的值，导致哈希表上发生大量冲突。
- en: A better choice of a table size is to use a prime number, ideally not too close
    to the power of 2\. For example, the value of 1,447 is a good choice in our example,
    since it's not too close to 1,024 or 2,048 (2^(10) and 2^(11)) and is also prime.
    Using this value as a table size for our example would reduce collisions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个更好的表大小是使用一个素数，理想情况下不要太接近2的幂。例如，在我们的例子中，1,447是一个不错的选择，因为它既不太接近1,024或2,048（2的10次方和2的11次方），也是素数。使用这个值作为我们的示例表大小将减少冲突。
- en: Using the remainder method restricts us on the choice of size for our hash table
    (to reduce the chance of collisions). To address this, we can use a different
    hashing technique, called the **multiplication method**. In this method, we multiply
    the key by a constant double value, *k*, in the range *0 < k < 1*. We then extract
    the fractional part from the result and multiply it by the size of our hash table.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用余数方法限制了我们对哈希表大小的选择（以减少冲突的机会）。为了解决这个问题，我们可以使用不同的哈希技术，称为**乘法方法**。在这个方法中，我们将键乘以一个常数双值，*k*，在范围*0
    < k < 1*内。然后我们从结果中提取分数部分，并将其乘以我们哈希表的大小。
- en: 'The hash value is then the floor of this result:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后哈希值是这个结果的下界：
- en: '![](img/3aea6a0b-1dfa-4092-9355-77455fc9f222.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3aea6a0b-1dfa-4092-9355-77455fc9f222.png)'
- en: 'Where:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '*k* is a decimal in the range between 0 and 1'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*k* 是介于0和1之间的十进制数'
- en: '*s* is the size of the hash table'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*s* 是哈希表的大小'
- en: '*x* is the key'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x* 是键'
- en: Implementing the Multiplication Method for a Hash Table
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现哈希表的乘法方法
- en: The aim here is to develop a code in Java for implementing the multiplication
    method for a hash table.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是开发一个Java代码，用于实现哈希表的乘法方法。
- en: 'Perform the following steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Implement a class with a method which accepts an integer and returns a hash
    value using the multiplication method shown in this section. The constant *k*
    is passed in as the class constructor. The method signature should be:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个类，其中包含一个方法，该方法接受一个整数并使用本节中所示的乘法方法返回哈希值。常数*k*作为类的构造函数传入。方法签名应该是：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following code shows an implementation for the multiplication hash function:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码显示了乘法哈希函数的实现：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Snippet 3.6: Solution for the multiplication method. Source class name: MultiplicationHashing.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 片段3.6：乘法方法的解决方案。源类名：MultiplicationHashing。
- en: Go to [https://goo.gl/xJ7i1b](https://goo.gl/xJ7i1b) to access this code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/xJ7i1b](https://goo.gl/xJ7i1b) 访问此代码。
- en: In this section, we have seen two basic techniques on how to compute hash values,
    the remainder method and the multiplication method. Both of these strategies are
    widely used in hash tables.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了两种基本的计算哈希值的技术，即余数方法和乘法方法。这两种策略在哈希表中都得到了广泛的应用。
- en: In the next section, we will examine yet another mechanism, called **universal
    hashing**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将检查另一种机制，称为**通用哈希**。
- en: Universal Hashing
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用哈希
- en: Both the remainder and multiplication hashing methods have a common vulnerability.
    If an attacker knows the details of our hash function (table size and any constant
    values), he/she could devise an input key sequence resulting in a collision on
    every item, turning our hash table into a linked list and slowing down our program.
    To address this problem, a hashing technique called universal hashing can be used.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法哈希和余数哈希方法都存在一个共同的弱点。如果攻击者知道我们哈希函数的细节（表大小和任何常数值），他/她可以设计一个输入键序列，导致每个项目都发生冲突，将我们的哈希表变成链表，并减慢我们的程序。为了解决这个问题，可以使用一种称为通用哈希的哈希技术。
- en: Universal hashing works by choosing a random function from a universal set of
    hash functions at the start of execution. This makes it difficult for an attacker
    to guess the exact workings of the hashing technique used. By using this technique,
    the same sequence of keys will produce a different sequence of hash values on
    every execution.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通用哈希通过在执行开始时从通用哈希函数集中选择一个随机函数来工作。这使得攻击者难以猜测所使用的哈希技术的确切工作方式。通过使用这种技术，相同的键序列将在每次执行中产生不同的哈希值序列。
- en: A set of hash functions, *H*, with size *n*, where each function maps a universe
    of keys ∪ to a fixed range of *[0, s)*, is said to be universal for all pairs,
    where *a*, *b ∈ ∪*, *a ≠ b* and the probability that *h(a) = h(b)*, *h ∈ H* is
    less than or equal to *n/s*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一组大小为*n*的哈希函数*H*，其中每个函数将键的集合∪映射到固定范围*[0, s)*，对于所有成对，其中*a*, *b ∈ ∪*，*a ≠ b*，且*h(a)
    = h(b)*，*h ∈ H*的概率小于或等于*n/s*。
- en: 'We can construct our set of universal hash functions by using two integer variables,
    *i* in a range of *[1, p)*, and *j* in a range of *[0, p)*, where *p* is a prime
    number larger than any possible value of the input key universe. We can then generate
    any hash function from this set using:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用两个整数变量*i*在范围*[1, p)*内，和*j*在范围*[0, p)*内来构造我们的通用哈希函数集，其中*p*是大于输入键宇宙可能值的任何值的质数。然后我们可以使用以下方法从这个集合中生成任何哈希函数：
- en: '![](img/8bb2319b-4912-42a6-b894-271b6b11f47e.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bb2319b-4912-42a6-b894-271b6b11f47e.png)'
- en: Where *s* is the size of the hash table and *x* is the key.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*s*是哈希表的大小，*x*是键。
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Snippet 3.7: Universal hashing for integer keys. Source class name: UniversalHashing'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 3.7 节片段：整数键的通用哈希。源类名：UniversalHashing
- en: Go to [https://goo.gl/5Kv7qG](https://goo.gl/5Kv7qG) to access this code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/5Kv7qG](https://goo.gl/5Kv7qG) 访问此代码。
- en: Java provides hash tables and built-in hashing mechanisms using the `Object.hashcode()`
    method. As a result of this, it is very difficult to implement a universal hashing
    table which integrates with Java's existing `hashcode()` method, since the `i`
    and `j` variables in the preceding code would have to be shared between different
    objects being inserted in the same table.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Java 通过 `Object.hashcode()` 方法提供了哈希表和内置的哈希机制。因此，要实现一个与 Java 现有的 `hashcode()`
    方法集成的通用哈希表非常困难，因为前述代码中的 `i` 和 `j` 变量必须在不同对象之间共享，这些对象被插入到同一个表中。
- en: 'For more information and mathematical proofs about why we pick a larger than
    key prime number, refer to Carter and Wegman, *Universal Classes of Hash Functions*,
    *Journal of Computer and System Sciences*: [https://doi.org/10.1016/0022-0000(79)90044-8](https://doi.org/10.1016/0022-0000(79)90044-8).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息和关于为什么选择大于键素数的数学证明，请参阅 Carter 和 Wegman 的 *通用哈希函数类*，*计算机与系统科学杂志*：[https://doi.org/10.1016/0022-0000(79)90044-8](https://doi.org/10.1016/0022-0000(79)90044-8)。
- en: Universal hashing provides us with good results, minimizing collisions, and
    is immune to malicious attacks, since the function parameters are chosen at random.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通用哈希提供了良好的结果，最小化了冲突，并且由于函数参数是随机选择的，因此对恶意攻击具有免疫力。
- en: 'Activity: Implementing Open Addressing'
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：实现开放寻址
- en: '**Scenario**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: We have been asked to develop an algorithm to search and remove data from a
    hash table using the open addressing technique.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被要求开发一个算法，使用开放寻址技术从哈希表中搜索和删除数据。
- en: '**Aim**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To implement a hash table using open addressing with linear probing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线性探测实现开放寻址哈希表
- en: '**Prerequisites**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: 'To solve this activity, you have to implement the methods found in the class
    that is available on GitHub at the following URL:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决此活动，你必须实现 GitHub 上以下 URL 中提供的类中的方法：
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson3/activity/openaddressing/OpenAddrHashTable.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson3/activity/openaddressing/OpenAddrHashTable.java)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson3/activity/openaddressing/OpenAddrHashTable.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson3/activity/openaddressing/OpenAddrHashTable.java)'
- en: 'If you have your project set up, you can run the following unit test for this
    activity by running:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经设置了项目，你可以通过运行以下单元测试来运行此活动的以下测试：
- en: '`**gradlew test --tests com.packt.datastructuresandalg.lesson3.activity.openaddressing***`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`**gradlew test --tests com.packt.datastructuresandalg.lesson3.activity.openaddressing***`'
- en: '**Steps for Completion**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Study the pseudocode shown in *Snippet 3.3* and *Snippet 3.4*
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 研究第 3.3 节和第 3.4 节中显示的伪代码
- en: Implement them in Java
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Java 中实现它们
- en: Create a container class that will hold your key and value in the hash table
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个容器类，该类将持有哈希表中的键和值
- en: Have a flag on this container to indicate when an item is deleted
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此容器上设置一个标志，以指示项目已删除
- en: Use this flag in the insert operation to overwrite it if it is deleted
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在插入操作中使用此标志，如果它被删除则覆盖它
- en: Getting Started with Binary Search Trees
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用二叉搜索树
- en: Like hash tables, binary search trees are fast lookup data structures for organizing
    key value pairs and implement the data dictionary operations. In addition to providing
    insert, search, and delete, binary tree supports efficient querying such as finding
    minimum and maximum, successor, and predecessor. When using balanced binary search
    trees, insert and search operations have a worst-case runtime complexity of *O(log
    n)*. This is a big theoretical improvement over the worst-case scenario of a hash
    table, which is *O(n)*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 像哈希表一样，二叉搜索树是用于组织键值对并实现数据字典操作的快速查找数据结构。除了提供插入、搜索和删除操作外，二叉树还支持高效的查询，例如查找最小值和最大值、后继和前驱。当使用平衡二叉搜索树时，插入和搜索操作的最坏情况时间复杂度为
    *O(log n)*。这比哈希表的最坏情况时间复杂度 *O(n)* 有很大的理论改进。
- en: Binary Tree Structure
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉树结构
- en: The structure of a binary tree is composed of a series of nodes connected together
    via pointers. *Figure 3.8* shows the fundamental relation between nodes. Each
    node can have a maximum of two child nodes, a left one and a right one.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树的结构由一系列通过指针连接在一起的节点组成。*图3.8*展示了节点之间的基本关系。每个节点最多可以有两个子节点，一个左子节点和一个右子节点。
- en: 'Each node (except the top-level node) also has exactly one parent:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点（除了顶级节点）恰好有一个父节点：
- en: '![](img/7ab6a211-a10f-45e0-9da5-0451b3557c4f.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ab6a211-a10f-45e0-9da5-0451b3557c4f.png)'
- en: 'Figure 3.8: Showing a simple binary tree relation'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：展示简单的二叉树关系
- en: '*Figure 3.9* shows some more terminology applied to binary trees. In this diagram,
    we also show that binary tree nodes can hold data items by showing the node storing different
    shapes. The top-level node is called the root node. The root node in a tree structure
    is the only node that doesn''t have a parent. Nodes that don''t have any children
    are called leaf nodes. The height of a tree is the number of hops it would take
    you to get from the root node to the furthest leaf node. The diagram shows an example
    of a tree which has a height of 2.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.9*展示了应用于二叉树的更多术语。在这个图中，我们还展示了二叉树节点可以通过显示存储不同形状的节点来持有数据项。顶级节点被称为根节点。在树结构中，根节点是唯一没有父节点的节点。没有子节点的节点被称为叶子节点。树的高度是从根节点到最远叶子节点所需跳跃的数量。该图展示了一个高度为2的树的示例。'
- en: The height of a tree is an important metric, as it affects the performance.
    The shallower a tree is (smaller height), the more performant a tree structure
    is.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 树的高度是一个重要的度量，因为它会影响性能。树越浅（高度越小），树结构的表现力越强。
- en: '![](img/2182c344-d7d7-4f7e-8206-ea8eb1a98530.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2182c344-d7d7-4f7e-8206-ea8eb1a98530.png)'
- en: 'Figure 3.9: Binary tree terminology'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9：二叉树术语
- en: 'Similar to a linked list, the binary tree structure is modeled using pointers
    and node objects. In a linked list node, we only have a next pointer, referencing
    the next node in the list. Similarly, in a binary tree node we have two pointers,
    each one linking to one child. These are the left and right child pointers. The
    following code snippet shows how we can model the binary tree node using a Java
    class:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与链表类似，二叉树结构是通过指针和节点对象来建模的。在链表节点中，我们只有一个指向下一个节点的指针。同样，在二叉树节点中，我们有两个指针，每个指针链接到一个子节点。这些是左子节点指针和右子节点指针。下面的代码片段展示了如何使用Java类来建模二叉树节点：
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Snippet 3.8: The Binary tree node class. Some getters and setters have been
    omitted for brevity. Source class name: BinaryTreeNode'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段3.8：二叉树节点类。为了简洁，省略了一些getter和setter方法。源类名：BinaryTreeNode
- en: Go to [https://goo.gl/D6Jvo2](https://goo.gl/D6Jvo2) to access this code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/D6Jvo2](https://goo.gl/D6Jvo2) 访问此代码。
- en: 'We can then have another class representing the binary tree itself, where the operations
    will be implemented. This class only needs to hold a pointer to the root node,
    since any node can be reached by starting from the root node and navigating down.
    In the following code snippet, we show an interface declaring the binary tree:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以有一个表示二叉树本身的另一个类，其中将实现操作。这个类只需要持有根节点的指针，因为任何节点都可以从根节点开始，通过导航向下到达。在下面的代码片段中，我们展示了声明二叉树的接口：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Snippet 3.9: Binary tree interface. Source class name: BinaryTree.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段3.9：二叉树接口。源类名：BinaryTree。
- en: Go to [https://goo.gl/jRcLhu](https://goo.gl/jRcLhu) to access this code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/jRcLhu](https://goo.gl/jRcLhu) 访问此代码。
- en: In this section, we have introduced the structure and terminology of binary
    trees. We then learned how to model each node using Java classes. In the next
    section, we will continue building on these concepts by introducing binary search
    trees and implementing the insert and search operations.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了二叉树的结构和术语。然后我们学习了如何使用Java类来建模每个节点。在下一节中，我们将通过介绍二叉搜索树并实现插入和搜索操作来继续构建这些概念。
- en: Binary Search Tree Operations
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树操作
- en: Binary search trees are normal binary trees in which data is organized in an
    ordered manner. Consider the same problem we encountered in the previous section,
    of the school keeping a student's records by using the passport numbers as a key.
    *Figure 3.10* shows an example of how you can organize the data in a binary tree.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树是数据以有序方式组织的普通二叉树。考虑我们在上一节中遇到的问题，即学校使用护照号码作为键来保存学生的记录。*图3.10*展示了如何在二叉树中组织数据的示例。
- en: Note how at each node the left child has a key which is less than its own. On
    the other hand, the right child has a larger key. Shown in the diagram, the root
    node has a left child containing a key of a smaller value than the root key. On
    the other hand, the right child has a key of a larger value than the root.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在每个节点，左子节点的键总是小于它自己的键。另一方面，右子节点的键更大。如图所示，根节点有一个左子节点，其键的值小于根键。另一方面，右子节点的键的值大于根。
- en: 'This rule is repeated through the entire tree. In a binary search tree, the
    left child will always have a smaller key than the parent, while the right child
    will have a larger one. Using this binary search tree property, we can create
    efficient operations on the tree structure:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则在整个树中重复出现。在二叉搜索树中，左子节点总是比父节点具有更小的键，而右子节点将具有更大的键。利用这个二叉搜索树的属性，我们可以在树结构上创建高效的操作：
- en: '![](img/ecfba1cb-3fe1-43ce-9cdc-b80f506be227.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ecfba1cb-3fe1-43ce-9cdc-b80f506be227.png)'
- en: 'Figure 3.10: An example of a binary search tree'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10：二叉搜索树的示例
- en: As a result of this simple rule, the tree exhibits important properties. For
    example, note how all the nodes that are descendants of the left child of the
    root node have a smaller key than the root. This property is valid for any node
    of the tree. All keys on the left subtree of a node will always have smaller keys,
    and vice versa.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个简单的规则，树表现出重要的属性。例如，注意所有是根节点左子节点后代的节点都具有比根节点更小的键。这个属性对树中的任何节点都有效。一个节点的左子树上的所有键总是具有更小的键，反之亦然。
- en: 'Searching in a binary search tree requires us to follow some simple instructions.
    We start at the root and at each node, we ask ourselves: "<q class="pcalibre5
    pcalibre4 calibre33">Is the key we''re looking for equal to less than, or greater
    than the key on this node?</q>" If the key is equal, we''re done and we have found
    our node. If the key is less, we follow the left child pointer, otherwise we follow
    the right one. We repeat this step until we find our key or hit a *null child
    pointer*.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在二叉搜索树中进行搜索需要我们遵循一些简单的指令。我们从根节点开始，在每一个节点，我们问自己：“<q class="pcalibre5 pcalibre4
    calibre33">我们要找的键是否等于、小于还是大于这个节点的键？</q>”如果键相等，我们就完成了，并且我们已经找到了我们的节点。如果键小于，我们跟随左子节点指针，否则我们跟随右子节点。我们重复这一步骤，直到找到我们的键或遇到一个*null子节点指针*。
- en: Another important property of a binary search tree is being able to easily find the
    maximum and minimum key in the tree. Finding the maximum key in a binary tree
    is easy. Conceptually, this is the rightmost node. This can be found by starting
    at the root and always picking the right child until there isn't any right child
    to choose. The reverse is valid (picking the left child) for the minimum key.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树的另一个重要属性是能够轻松地找到树中的最大和最小键。在二叉树中找到最大键很容易。概念上，这是最右边的节点。这可以通过从根节点开始，并且总是选择右子节点，直到没有更多的右子节点可以选择来实现。对于最小键，这个逻辑是相反的（选择左子节点）。
- en: 'The following code snippet shows the search implementation. In this implementation,
    we use the power of recursion to perform the search. We start by checking if the
    tree is empty by checking whether the root is null. If a root node is present,
    we compare the key and either return the value or recursively search the child
    nodes. To compare the key, we assume the provided key implements the comparable
    interface. Using Java''s optional flat mapping makes our implementation much more
    concise:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了搜索实现。在这个实现中，我们使用递归的力量来执行搜索。我们首先通过检查根节点是否为null来检查树是否为空。如果存在根节点，我们比较键并返回值或递归搜索子节点。为了比较键，我们假设提供的键实现了可比较接口。使用Java的可选扁平映射使我们的实现更加简洁：
- en: '[PRE15]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Snippet 3.10: Binary search tree search operation. Source class name: SimpleBinaryTree.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 碎片3.10：二叉搜索树搜索操作。源类名：SimpleBinaryTree。
- en: Go to [https://goo.gl/xE2GvH](https://goo.gl/xE2GvH) to access this code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://goo.gl/xE2GvH](https://goo.gl/xE2GvH)访问此代码。
- en: 'Java''s `objectA.compareTo(objectB)` method in the comparable interface returns a
    negative integer, zero, or a positive integer as `objectA` is less than, equal
    to, or greater than `objectB`. Thus, the following statement:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Java中，在可比较接口中的`objectA.compareTo(objectB)`方法返回一个负整数、零或正整数，这取决于`objectA`是小于、等于还是大于`objectB`。因此，以下语句：
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Is conceptually the same as the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 概念上等同于以下内容：
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Inserting in a binary tree follows the same logic as the search operation. We
    start from the root and keep on looking for a location where we need to create
    a new node. This is shown in the next code snippet. Like the search operation,
    this Java implementation is also recursive. If the root node is absent we just
    create a new one, otherwise we recursively insert the key value pair each time
    by choosing the left or right child depending on the value of the key.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在二叉树中插入的逻辑与搜索操作相同。我们从根节点开始，继续寻找需要创建新节点的地方。这将在下一个代码片段中展示。像搜索操作一样，这个 Java 实现也是递归的。如果根节点不存在，我们只需创建一个新的，否则我们根据键值的值递归地通过选择左子节点或右子节点来插入键值对。
- en: 'We have three stopping conditions for the recursive call that are, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个递归调用的停止条件，如下所述：
- en: When the *key is equal* to the one on the node, we simply overwrite the entry
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当*键值*等于节点上的键值时，我们简单地覆盖条目
- en: When the *left child is not present*, we create a new node with the key value
    pair
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当*左子节点不存在*时，我们创建一个新的节点，包含键值对
- en: When the *right child is not present*, we create a new node with the key value
    pair
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当*右子节点不存在*时，我们创建一个新的节点，包含键值对
- en: 'The following code demonstrates the binary search tree insert operation:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了二叉搜索树的插入操作：
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Snippet 3.11: Binary search tree insert operation. Source class name: SimpleBinaryTree'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段 3.11：二叉搜索树插入操作。源类名：SimpleBinaryTree
- en: Go to [https://goo.gl/hHpeiP](https://goo.gl/hHpeiP) to access this code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/hHpeiP](https://goo.gl/hHpeiP) 访问此代码。
- en: 'Binary tree deletion requires matching the subtree structure with a number
    of patterns and performing different actions with each case. In some situations,
    it requires that you connect the subtree with the parent of the deleted node,
    which can be quite complex. For this reason, the deletion algorithm is beyond
    the scope of this book. For information on the deletion operation, you may refer
    to the following sources:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树删除需要将子树结构与多种模式匹配，并对每种情况执行不同的操作。在某些情况下，它要求你将子树与被删除节点的父节点连接起来，这可能相当复杂。因此，删除算法超出了本书的范围。有关删除操作的信息，你可以参考以下来源：
- en: '*The Art of Computer Programming, Volume 3: Sorting and Searching*, by Donald
    Knuth.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《计算机程序设计艺术，第3卷：排序与搜索》，作者 Donald Knuth*。'
- en: Paul E. Black, "binary search tree", in Dictionary of *Algorithms and Data Structures*
    [online], Vreda Pieterse and Paul E. Black, eds. January 26, 2015\. Available
    at [https://www.nist.gov/dads/HTML/binarySearchTree.html](https://www.nist.gov/dads/HTML/binarySearchTree.html).
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Paul E. Black, "binary search tree", in Dictionary of *Algorithms and Data Structures*
    [online], Vreda Pieterse and Paul E. Black, eds. January 26, 2015\. 可在 [https://www.nist.gov/dads/HTML/binarySearchTree.html](https://www.nist.gov/dads/HTML/binarySearchTree.html)
    获取。
- en: Searching for a Minimum Key in a Binary Tree
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在二叉树中搜索最小键值
- en: The aim is to implement a method in Java to search for the minimum key in a
    binary tree.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是在 Java 中实现一个方法来搜索二叉树中的最小键值。
- en: 'Perform the following steps:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Add a method to the binary tree implementation with the following signature:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向二叉树实现中添加以下签名的函数：
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The method needs to find the minimum key in the tree and return it. If the tree
    is empty, it should return an empty optional.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该方法需要找到树中的最小键值并返回它。如果树为空，它应返回一个空的可选对象。
- en: 'Finding the minimum in a binary search tree requires us to always follow the left
    child node until we reach a node with no left child pointer. The following code
    demonstrates this:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在二叉搜索树中寻找最小值需要我们始终跟随左子节点，直到我们到达一个没有左子指针的节点。以下代码演示了这一点：
- en: '[PRE20]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Snippet 3.12: Minimum key operation. Source class name: SimpleBinaryTree.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段 3.12：最小键值操作。源类名：SimpleBinaryTree。
- en: Go to [https://goo.gl/YbZz6i](https://goo.gl/YbZz6i) to access this code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/YbZz6i](https://goo.gl/YbZz6i) 访问此代码。
- en: In this section, we have introduced binary search trees and explored how they
    can be used to organize key value pairs. We also saw how binary search trees can
    be used for simple range queries, such as finding the maximum and minimum keys.
    In the next section, we learn about all the different ways we can traverse a binary
    search tree.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了二叉搜索树，并探讨了如何使用它们来组织键值对。我们还看到了如何使用二叉搜索树进行简单的范围查询，例如查找最大和最小键值。在下一节中，我们将学习所有不同的方法来遍历二叉搜索树。
- en: Traversing a Binary Search Tree
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历二叉搜索树
- en: 'Traversing a binary tree is the process of stepping through each node of the
    tree and performing some sort of action on the data contained in the node (such
    as printing the key value pair). There are two main techniques to perform tree
    traversal: depth-first search and breadth-first search, more commonly known as
    DFS and BFS, respectively.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历二叉树是逐个节点地遍历树并对其中的数据进行某种操作（如打印键值对）的过程。有两种主要的技术来执行树遍历：深度优先搜索和广度优先搜索，分别称为DFS和BFS。
- en: In depth-first search, the algorithm goes down a path of tree nodes until it
    cannot go any further. Once it cannot go further, it backtracks and discovers
    any remaining unexplored branches. A recursive implementation is shown in the
    following code. In this traversal method, a different output sequence is produced
    depending on where the action is executed in the method.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在深度优先搜索中，算法沿着树节点的路径向下搜索，直到无法再前进。一旦无法再前进，它就会回溯并发现任何剩余的未探索分支。以下代码展示了递归实现。在这个遍历方法中，根据动作在方法中执行的位置，会产生不同的输出序列。
- en: 'In a **preorder** execution, we perform the action immediately, as soon as
    a new node is discovered. A **postorder** execution, on the other hand, is when
    both children of a node have been explored and we''re about to backtrack. An **inorder**
    execution is done when the left child has been processed but before processing
    the right one. When using an inorder traversal, the keys in the binary search
    trees will be processed in ascending order:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在**前序**执行中，我们一旦发现新节点就立即执行操作。另一方面，**后序**执行是在一个节点的两个子节点都已被探索并且即将回溯时进行的。**中序**执行是在处理左子节点之后但在处理右子节点之前进行的。当使用中序遍历时，二叉搜索树中的键将按升序处理：
- en: '[PRE21]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Snippet 3.13: Depth-first search. Source class name: SimpleBinaryTree'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段3.13：深度优先搜索。源类名：SimpleBinaryTree
- en: Go to [https://goo.gl/xMzkbE](https://goo.gl/xMzkbE) to access this code.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://goo.gl/xMzkbE](https://goo.gl/xMzkbE)访问此代码。
- en: 'In the breadth-first search traversal, the algorithm explores the binary tree
    one level at a time, left to right. The traversal starts from the root node and
    finishes at the leaf nodes. The output of an example binary tree is shown in *Figure
    3.11*. To implement a BFS traversal of a binary tree, we can make use of a queue
    initialized to contain the root node. Then, while the queue is not empty, we read
    the first node on the queue, process it, and add first the left and then the right
    child to the queue:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在广度优先搜索遍历中，算法逐层探索二叉树，从左到右。遍历从根节点开始，以叶节点结束。一个示例二叉树的输出显示在*图3.11*中。为了实现二叉树的BFS遍历，我们可以使用初始化为包含根节点的队列。然后，当队列不为空时，我们读取队列上的第一个节点，处理它，并将左子节点首先然后是右子节点添加到队列中：
- en: '![](img/0e506e9a-dfee-4baa-b211-c002bbe27a13.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0e506e9a-dfee-4baa-b211-c002bbe27a13.png)'
- en: 'Figure 3.11: Breadth-first search on a binary tree'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：二叉树上的广度优先搜索
- en: 'We show the pseudocode of this as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如下展示其伪代码：
- en: '[PRE22]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Snippet 3.14: Pseudocode for breadth-first search'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段3.14：广度优先搜索的伪代码
- en: If we substitute the queue with a stack, the algorithm shown in *Snippet 3.14*
    changes from breadth-first search to the non-recursive depth-first search. In
    fact, the way to implement a non-recursive DFS is to make use of a stack.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将队列替换为栈，*代码片段3.14*中显示的算法将从广度优先搜索变为非递归的深度优先搜索。实际上，实现非递归DFS的方法是利用栈。
- en: 'Activity: Implementing BFS in Java'
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：在Java中实现BFS
- en: '**Scenario**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: We have been asked to write code to implement an algorithm that searches the binary
    tree one level at a time, left to right. The traversal starts from the root node and
    finishes at the leaf nodes.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被要求编写代码来实现一个算法，该算法逐层、从左到右搜索二叉树。遍历从根节点开始，以叶节点结束。
- en: '**Aim**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To apply BFS traversal in Java.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中应用BFS遍历。
- en: '**Steps for Completion**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Implement the algorithm shown in the preceding code in Java.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Java中实现前面代码中显示的算法。
- en: 'Use the Java `LinkedList` collection to implement the queue shown in the pseudocode.
    The method signature should be as follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Java `LinkedList`集合实现伪代码中显示的队列。方法签名应如下所示：
- en: '[PRE23]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this section, we have learned about the various ways we can traverse a binary
    tree and the different ordering produced by each strategy. We have also seen how
    these algorithms can be implemented both in a recursive and in an iterative manner.
    In the next section, we will discuss a more restrictive type of binary search
    tree that ensures our data structure maintains a good performance, even in the
    worst input case.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了各种遍历二叉树的方法以及每种策略产生的不同排序。我们还看到了这些算法可以以递归和迭代的方式实现。在下一节中，我们将讨论一种更严格的二叉搜索树类型，确保我们的数据结构即使在最坏输入情况下也能保持良好的性能。
- en: Balanced Binary Search Trees
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平衡二叉搜索树
- en: The performance of a binary search tree is proportional to its height. This
    is because the search and insert operations start from the root and proceed down
    the tree one node at a time, doing a key comparison at each step. The taller the
    tree, the more steps are needed to accomplish this. Thus, if we determine the
    maximum possible height of a binary tree in relation to its input, we can find
    out the worst runtime complexity.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树的性能与其高度成正比。这是因为搜索和插入操作从根节点开始，逐个节点向下进行，每个步骤都进行键比较。树越高，需要的步骤就越多。因此，如果我们确定二叉树相对于其输入的最大可能高度，我们就可以找出最坏情况下的运行复杂度。
- en: If we insert keys in a binary tree, by always adding on the right child of the
    parent node, we end up with a tree similar to the one shown on the left-hand side
    of *Figure 3.12*. In this diagram, only the right child pointers on each node
    are being used. We end up with a tree of height *n*, where *n* is the number of
    items added to our data structure. We get this kind of one-sided tree when the
    key input pattern is in order.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在二叉树中插入键，总是添加到父节点的右子节点，最终得到的树类似于图3.12左侧所示的树。在这个图中，每个节点只使用了右子指针。我们得到一个高度为*n*的树，其中*n*是我们数据结构中添加的项目数量。当键输入模式有序时，我们会得到这种单侧树。
- en: 'In the example shown in *Figure 3.12*, we first insert 5 as a root, then 7
    is added as the right child, the next is 12 as the next right child, and so on.
    Always inserting an increasing number results in the next node on the right. This
    one type of input pattern makes our binary search tree operations (search, insert,
    and delete) behave in the worst-case runtime of *O(n)*:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在图3.12所示的示例中，我们首先插入5作为根节点，然后添加7作为右子节点，接下来是12作为下一个右子节点，以此类推。总是插入递增的数字会导致下一个节点在右侧。这种输入模式使得我们的二叉搜索树操作（搜索、插入和删除）在最坏情况下的运行时间为*O(n)*：
- en: '![](img/d5df6774-db10-4444-8504-d745772daded.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5df6774-db10-4444-8504-d745772daded.png)'
- en: 'Figure 3.12: Unbalanced versus balanced binary trees'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12：不平衡与平衡的二叉树
- en: The result is similar if we start from a big number and decrease it each time.
    We end up with a mirror of the tree shown on the left-hand side of *Figure 3.12*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从一个大数字开始并每次都减小它，结果也会类似。我们最终得到图3.12左侧所示的树的镜像。
- en: The output of a BFS traversal in a normal binary search tree when the key insert
    order is "1,2,3,4,5,6,7" would be in the same order as the input, that is, "1,2,3,4,5,6,7". We
    end up  creating a new right child at every insert. Since BFS traversal processes
    one level after another, starting from the root, the traversal output is the same
    as the input.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当键插入顺序为"1,2,3,4,5,6,7"时，在正常二叉搜索树中进行BFS遍历的输出将与输入顺序相同，即"1,2,3,4,5,6,7"。我们在每次插入时都会创建一个新的右子节点。由于BFS遍历是逐级处理的，从根节点开始，遍历输出与输入相同。
- en: In *Figure 3.12*, on the right-hand side, we show another binary tree containing
    the same keys. This binary tree has been restructured with the effect that the
    tree is now shorter. Note that the tree is still valid, that is, the left child
    always has a key that is smaller than its parent, and vice versa. A balanced binary
    tree has a height of about *log[2]n*.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在图3.12的右侧，我们展示了另一个包含相同键的二叉树。这个二叉树已经通过重构而变得较短。请注意，这个树仍然是有效的，也就是说，左子节点总是有一个小于其父节点的键，反之亦然。一个平衡的二叉树的高度大约为*log[2]n*。
- en: If we manage to find a way to rebalance the binary search tree at each insert
    in *O(log n)* or better, the worst-case runtime performance for inserts and searches
    would also be of *O(log n)*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够在每次插入时以*O(log n)*或更好的时间复杂度重新平衡二叉搜索树，那么插入和搜索的最坏情况运行时间性能也将是*O(log n)*。
- en: 'Luckily, various algorithms exist that self-balance the tree structure as you
    perform inserts. Some of the most common ones are as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，存在各种算法可以在你执行插入操作时自动平衡树结构。以下是一些最常见的算法：
- en: AVL trees
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AVL树
- en: Red black trees
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红黑树
- en: AA trees
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AA树
- en: All of these algorithms check that the binary tree is following specific balancing
    rules at key insert. If, due to a new node being inserted, the tree becomes unbalanced,
    the self-balancing algorithm kicks in and restructures some of the nodes to keep
    the tree balanced. The technique to rebalance the nodes relies on tree rotations,
    where under certain conditions some of the parent and child nodes are rotated.
    Importantly, these modifications are also performed in the worst-case of *O(log
    n)*, meaning that both inserts and searches on binary trees have a worst runtime
    complexity of *O(log n)*. In this section, we will examine tree rotations as they
    are the base operation for most self-balancing trees.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些算法都会检查在关键插入时二叉树是否遵循特定的平衡规则。如果由于插入新节点，树变得不平衡，则自平衡算法启动并重新结构化一些节点以保持树平衡。重新平衡节点的技术依赖于树旋转，在特定条件下，一些父节点和子节点会旋转。重要的是，这些修改在最坏情况下也以
    *O(log n)* 的复杂度执行，这意味着在二叉树上的插入和搜索的最坏运行时间复杂度都是 *O(log n)*。在本节中，我们将检查树旋转，因为它们是大多数自平衡树的基本操作。
- en: 'For more information about self-balancing trees, you may refer the following resources:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于自平衡树的信息，您可以参考以下资源：
- en: '*The Art of Computer Programming*, *Volume 3: Sorting and Searching by **Donald
    Knuth*.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算机程序设计艺术*，*第3卷：排序与搜索*，由**唐纳德·克努特**著。'
- en: 'Paul E. Black, "*red-black tree*", in *Dictionary of Algorithms and Data Structures*
    [online], Vreda Pieterse and Paul E. Black, eds. 13 April 2015\. Available at
    the link: [https://www.nist.gov/dads/HTML/redblack.html](https://www.nist.gov/dads/HTML/redblack.html).'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Paul E. Black, "*红黑树*", 在 *算法与数据结构词典* [在线], Vreda Pieterse 和 Paul E. Black 编著.
    2015年4月13日\. 可在以下链接中找到：[https://www.nist.gov/dads/HTML/redblack.html](https://www.nist.gov/dads/HTML/redblack.html).
- en: '*Figure 3.13* shows an example of a left and right rotation. Note how the node
    being rotated (node 5 in the right rotation and 9 in the left rotation) ends up
    being the new parent. Importantly, there is a constant number of child pointer
    reassignments. The properties of a binary search tree are still valid after a
    tree rotates, that is, a left child pointer always has a smaller key that points
    to its parent, and vice versa. This means that we can perform any number of these
    tree rotations and our binary search tree will still be valid:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.13* 展示了左右旋转的示例。注意正在旋转的节点（右旋转中的节点5和左旋转中的节点9）最终成为新的父节点。重要的是，子指针重新分配的数量是恒定的。在树旋转后，二叉搜索树的性质仍然有效，即，左子指针始终指向一个较小的键，该键指向其父节点，反之亦然。这意味着我们可以执行任意数量的这些树旋转，我们的二叉搜索树仍然有效：'
- en: '![](img/7f5c66a9-a6a2-42bf-96d1-c40479d1c864.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f5c66a9-a6a2-42bf-96d1-c40479d1c864.png)'
- en: 'Figure 3.13: Left and right tree rotations'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13：左右树旋转
- en: '*Snippet 3.15* shows how we perform a right rotation in Java. The method accepts
    a top-level node that needs rotation (node 5 in *Figure 3.13*) and its parent
    node. The method requires the parent node since it has to reassign its child pointer.
    Performing the opposite right rotation on the tree node is the mirror image of
    the following method:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*片段3.15* 展示了我们在Java中如何执行右旋转。该方法接受需要旋转的顶层节点（*图3.13* 中的节点5）及其父节点。该方法需要父节点，因为它必须重新分配其子指针。在树节点上执行相反的右旋转是以下方法的镜像：'
- en: '[PRE24]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Snippet 3.15: Java implementation of the left tree rotation. Source class name: SimpleBinaryTree'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 片段3.15：左树旋转的Java实现。源类名：SimpleBinaryTree
- en: Go to [https://goo.gl/Ts3JBu](https://goo.gl/Ts3JBu) to access this code.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://goo.gl/Ts3JBu](https://goo.gl/Ts3JBu)以获取此代码。
- en: Applying Right Tree Rotation
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用右树旋转
- en: The aim is to implement a right tree rotation in Java.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是在Java中实现右树旋转。
- en: 'Modify *Snippet 3.15* to make the method perform a right tree rotation instead of
    a left tree rotation. The following code shows the required modification:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *片段3.15* 修改为使方法执行右树旋转而不是左树旋转。以下代码显示了所需的修改：
- en: '[PRE25]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Snippet 3.16: Java implementation of the right tree rotation. Source class
    name: SimpleBinaryTree'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 片段3.16：右树旋转的Java实现。源类名：SimpleBinaryTree
- en: Go to [https://goo.gl/KKDWUa](https://goo.gl/KKDWUa) to access this code.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://goo.gl/KKDWUa](https://goo.gl/KKDWUa)以获取此代码。
- en: The right rotation is an exact mirror image of the left rotation. It's enough
    to change all the left references with right references and vice versa.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 右旋是左旋的精确镜像。只需将所有左引用更改为右引用，反之亦然。
- en: In this section, we saw how we can improve the performance of binary search
    trees by using tree rotations to balance the data structure. This enables the
    tree to remain of a shorter height with a runtime complexity of *O(log n)*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何通过使用树旋转来平衡数据结构，从而提高二叉搜索树的性能。这使得树保持较短的长度，运行时间复杂度为*O(log n)*。
- en: 'Activity: Retrieving the Successor of an Element When the Tree is Traversed
    in Inorder'
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：在以中序遍历树时检索元素的后续节点
- en: '**Scenario**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: 'We need to write a method that, given a key as an argument, returns the next
    in order key found in the binary search tree. If the key given as an argument
    is not found, the method should still return the next in order key. If the binary
    tree is empty or all the stored keys are smaller than the argument, then the return
    value should be empty. For example, using a collection of {10, 13, 52, 67, 68,
    83} stored in the binary search tree:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写一个方法，该方法接受一个键作为参数，返回在二叉搜索树中找到的下一个中序键。如果作为参数给出的键未找到，则该方法应返回下一个中序键。如果二叉树为空或所有存储的键都小于参数，则返回值应为空。例如，使用存储在二叉搜索树中的集合{10,
    13, 52, 67, 68, 83}：
- en: An input of 13 results in 52
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入13的结果为52
- en: An input of 67 results in 68
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入67的结果为68
- en: An input of 55 results in 67
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入55的结果为67
- en: An input of 5 results in 10
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入5的结果为10
- en: An input of 83 results in `Optional.empty`
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入83的结果为`Optional.empty`
- en: An input of 100 results in `Optional.empty`
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入100的结果为`Optional.empty`
- en: Any input on an empty binary tree results in `Optional.empty`
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在空二叉树上输入任何值的结果为`Optional.empty`
- en: Both the in order successor and predecessor algorithms have many applications.
    As an example, think about if you had to keep a scoreboard at some sports event
    where you only want to show the first three runners. If you keep your data in
    a binary search tree, you can find the maximum key and then work out the next
    two predecessor nodes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 中序后继者和前驱者算法有许多应用。例如，假设你需要在某个体育赛事中保持一个排行榜，而你只想显示前三名运动员。如果你将数据存储在二叉搜索树中，你可以找到最大键，然后计算出下一个两个前驱节点。
- en: The solution needs to have a runtime complexity of *O(log n)*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案需要具有*O(log n)*的运行时间复杂度。
- en: '**Aim**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To retrieve the successor of an element when the tree is traversed in inorder.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当树以中序遍历的方式检索一个元素的后续节点。
- en: '**Prerequisites**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: 'Implement the following method, provided in the `InOrderSuccessorBinaryTree` class
    that extends the `SimpleBinaryTree` class, which is available on GitHub at the following
    link:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 实现以下方法，该方法在`InOrderSuccessorBinaryTree`类中提供，该类扩展了`SimpleBinaryTree`类，可在以下链接在GitHub上找到：
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson3/activity/inordersuccessor/InOrderSuccessorBinaryTree.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson3/activity/inordersuccessor/InOrderSuccessorBinaryTree.java)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson3/activity/inordersuccessor/InOrderSuccessorBinaryTree.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson3/activity/inordersuccessor/InOrderSuccessorBinaryTree.java)'
- en: '[PRE26]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you have your project set up, you can run the unit test for this activity
    by running:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经设置了你的项目，你可以通过运行以下命令来运行此活动的单元测试：
- en: '`gradlew test --tests com.packt.datastructuresandalg.lesson3.activity.inordersuccessor*`'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`gradlew test --tests com.packt.datastructuresandalg.lesson3.activity.inordersuccessor*`'
- en: '**Steps for Completion**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Use a non-recursive search operation first to find the first node with a key
    equal to or less than the input
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先使用非递归搜索操作找到键值等于或小于输入的第一个节点
- en: Realize that the inorder successor can be in only one of two places, either
    as a parent of this node or the minimum key on the subtree of the right child
    of this node (if any)
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 意识到中序后继者只能位于两个地方之一，要么是这个节点的父节点，要么是这个节点右子树（如果有）的最小键（键值最小的节点）
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have studied two of the most commonly used data structures
    for implementing the data dictionary operation. Hash tables provide fast in-memory
    insertion and lookup operations. In addition, binary trees also give us the ability
    to perform various range queries such as successor, predecessor, minimum and maximum.
    In this chapter, we have seen examples of both data structures, and implementations
    of these operations.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了实现数据字典操作中最常用的两种数据结构。哈希表提供了快速的内存插入和查找操作。此外，二叉树还赋予我们执行各种范围查询的能力，例如后继、前驱、最小值和最大值。在本章中，我们看到了这两种数据结构的示例以及这些操作的实现。
