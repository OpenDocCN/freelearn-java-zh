- en: Functional Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming largely deals with data manipulation. Different styles of programming will
    treat data structures, and data itself, differently. For example, imperative programming
    treats data as mutable information stored in memory. We will see how the treatment
    of functional programming differs from that of imperative programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Collections framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The algebraic approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effect types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data structures in different programming languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collections framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When discussing data structures, it is only natural to start with collections.
    Collections are data structures that abstract away multiplicity. This means that
    whenever you have more than one item of a particular kind, and you want to run
    a number of operations on this data, you will need a proper abstraction—an abstraction
    that will establish the rules of the game you play when you encounter multiplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'It transpires that you will need to deal with abstraction of this nature in
    nearly every programming project. When you are dealing with strings, you frequently
    need to represent them as a collection of characters. Whenever you have a database
    application, and you have some queries in relation to this database, you need
    to present multiple results of these queries as collections. Whenever you are
    dealing with a text file, you may want to represent it as a list of lines. This
    happens rather frequently, for example, when dealing with configuration files.
    We specify our configuration entries as strings on separate lines. For example, the
    following is how we may represent a server connection configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Or, for example, you may want to communicate data with a web API. Most modern
    web APIs communicate data in the form of JSON or XML. These are structured ways
    of representing data and, if you observe them closely, you will notice that they
    follow a pattern; for example, an XML file is composed of a tree of multiple nodes,
    and a JSON object may contain more than one entry.
  prefs: []
  type: TYPE_NORMAL
- en: So, whenever you are working on a programming project, it is very likely that
    you will need to deal with some kind of abstraction over multiplicity. You require
    a collections framework. Because collections are so ubiquitous, it is only natural
    that modern programming languages include a collection framework in their core
    library. This is why looking at a language's collections framework is an easy
    way to see the philosophy of the language and its approach to programming in general.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will compare the collection frameworks of Java and Scala.
    Java represents a traditional, imperative approach to programming, and, hence,
    its collection framework also reflects this approach. On the other hand, Scala
    represents a functional, declarative approach to programming. Its collection framework
    is built and structured according to the philosophy of functional and declarative
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Imperative collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's have a look at how collections are understood within the framework of
    an imperative programming language, while also looking at Java's abstraction of
    a list. Its API documentation is available at [https://docs.oracle.com/javase/8/docs/api/java/util/List.html](https://docs.oracle.com/javase/8/docs/api/java/util/List.html.).
    This interface only has a limited number of methods defined. The first thing that
    we need to pay attention to here is mutability. Immediately, we see methods such
    as `add` and `remove`. This implies that this interface is supposed to be implemented
    by a mutable collection that is supposed to implement the operations that add
    or remove data from it. You should be aware that methods can throw an `UnsupportedOperationException`,
    which means that certain collections may implement this interface; however, they
    will not implement these two operations. Later in the book, we will see that functional
    programming does not welcome exceptions of this kind as they are a type of side
    effect and here, it is especially obvious why. One of the essential principles
    of object-oriented programming is polymorphism, which means that you can place
    an interface on top of a class and, from there, you are able to interact with
    this class according to this interface, without caring about the internal implementation.
    An interface is supposed to be a protocol of interaction with an object; it is
    supposed to specify which behavior it supports, and throwing an exception if a
    behavior is not supported is a rather clumsy move on the part of Java, since you
    need to bear in mind that certain behavior is not supported, even though the interface
    declares that it is. This further taxes the programmer's mind and, hence, it can
    lead to bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Another peculiarity we should observe is that other methods defined here are
    quite low level. You have the ability to add to the collection and to remove from
    the collection. It is assumed that whatever you need to do with the collection,
    you will be able to do so with the help of these and other low-level methods that
    the interface provides. This is realized by writing an imperative algorithm that
    specifies how exactly to perform a necessary operation given the low-level primitives
    provided by the language. This, in turn, means that you must be skilled with algorithms
    to write effective Java programs, because the use of algorithms is the only option
    open to you.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, it has long been a tradition in computer science and programming to
    focus extensively on algorithms. The data has been perceived as some kind of mutable
    information written in a certain medium, and the task of the programmer is to
    specify a sequence of steps to modify this data as per requirements. Hence, one
    of the first things people learn in computer science is sorting algorithms such
    as Bubble Sort.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms are certainly necessary. Under the hood of any computer program,
    algorithms are precisely what do the job. However, they are not the best way for
    humans to read, understand, and write programs. They are not the best way for
    humans to design programs since, due to their counter-intuitiveness, they can
    be error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's have a look at functional collections.
  prefs: []
  type: TYPE_NORMAL
- en: Functional collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's quite a different picture in functional languages. Let's have a look at
    the same abstraction, the List, in Scala's library. Its API documentation is available
    at [https://www.scala-lang.org/api/current/scala/collection/immutable/List.html](https://www.scala-lang.org/api/current/scala/collection/immutable/List.html).
    It contains many more methods than can be found in Java's List. In contrast to
    the Java List interface, Scala's List abstraction is immutable. This means that
    once you have created a list, you are not able to modify it. All the modifications
    to the list can be implemented by just creating a modified copy of the list. This
    concept is referred to as structural sharing. This means that the objects that
    are members of the list are not copied, just that the structure of the list is
    recreated. Therefore, you do not need to worry about memory leaks because only
    the structure is newly created. The objects that are the members of the list are
    not recreated.
  prefs: []
  type: TYPE_NORMAL
- en: There is also an abundance of declarative methods – high-level primitives, for
    example, `filter`, `map`, and `flatMap`. In contrast to Java, these methods specify
    fairly high-level operations. In the previous chapter, we saw how it can be pretty
    tedious to define a filter operation in Java. In contrast, in Scala, it is sufficient
    to specify the name of the operation that you need to perform, and you don't need
    to worry about how this operation is implemented. This seems like the right moment
    to draw parallels with the `goto` statement. It is a remarkable property of modern
    programming languages; the programs that you can express with `goto` can also
    be expressed with the help of several control structures. In the same way, all
    collection programs can be expressed using around a dozen declarative high-level
    methods. You don't need to specify how to create a loop with `goto` every time
    you need a loop. Similarly, it is not necessary to specify collection operations
    such as `filter` if they can be named and implemented in a language's core library.
  prefs: []
  type: TYPE_NORMAL
- en: While Java and imperative languages focus on algorithmic reasoning, functional
    languages, such as Scala, focus on algebraic reasoning. This means they view data
    transformations as algebraic expressions. Data can be viewed as operands of some
    algebra, and it can be combined with other data and transformed to get new data
    with the help of high-level operators. Hence, programs are no longer defined algorithmically,
    but in terms of mathematical expressions; expressions that compute some value
    based on their input.
  prefs: []
  type: TYPE_NORMAL
- en: When programming in a declarative language, it is no longer necessary to be
    an expert in algorithms, as was the case with imperative languages such as Java.
    This is the case because all the algorithms that you may need are already implemented
    in the language's core library. Of course, when you call a declarative method,
    such as `filter`, on a Scala collection, an algorithm is executed under the hood.
    The beauty of this approach is that you do not need to be aware of this at all.
    You're provided with a high-level building block, and you need to express your
    program in terms of these building blocks. You do not need to worry about how
    the blocks are created.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of benefits compared to the imperative approach. You do not
    need to deal with algorithms that are hard to read and prone to bugs. Everything
    you need is already implemented on a language level. This means that the implementation
    is used in a number of projects based on that language. Therefore, you can be
    sure that what you are using is tested extensively, thereby greatly reducing your
    chances of writing bug-prone code.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of focusing on low-level operations, you can focus on describing your
    program in high-level terms. Consider the example of filtering that we saw in
    [Chapter 1](485603d0-9f5e-4644-bd73-c46a8a317448.xhtml), The *Declarative Programming
    Style*. It is much easier to read the declarative code because you see the word
    `filter` at once, and this single word means an entire operation. In the case
    of Java, we have a loop and manipulation over two collections to get the same
    job done, and it is not at all obvious what the code stands for. This is why declarative
    programs are much better to read for humans.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at another example – mapping. Mapping is a process of transforming
    a collection element-wise. This means that you take a collection as an input and
    generate another collection by transforming every element of the original collection
    in some way. For example, if you have a list of integers, you can map this list
    by a function that squares each individual number. If you have the numbers `1`,
    `2`, and `3` in the collection, you will get a new collection with the numbers
    `1`, `4`, and `9`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do this operation in Java in an imperative way. First, let''s define
    the collections we are going to map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a new collection we are going to write our results to.
    Then, we will iterate over every element of the original collection, we will apply
    the required function to these, and then add them to the result collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at how this is done with Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In Scala, we simply call the built-in primitive method `map` on the collection
    we need to map. Here, we can also see the role that is played by the lambda functions
    here. We are able to specify that mapping function as a lambda function, as an
    argument to the `map` method. In Java, lambda functions are only supported starting
    from version 8, hence, this style would have been impossible in that language
    until recently. The general pattern here is that we often need to abstract away
    an entire computation. We need to embed one computation in another. This can be
    done with a lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: Algebraic approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functional and declarative programming can also be very well conceptualized
    as an algebraic style.  For our purposes, an algebraic approach can be regarded
    as a certain language of mathematical expressions—a language that consists of
    two major elements: operators and operands. Operands can be taken to mean data,
    the information that you want to manipulate, while operators can be taken to mean
    their behavior as an how this data is utilized.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the expression `1 + 2`. Here, numbers `1` and `2` are operands. They
    represent some numeric data. The `+` symbol is an operator that binds them together.
    It has certain semantics associated with it, that of adding one number to another.
    But it is important to remember that the symbolic structure of the expression
    and its semantics are two separate things. You can take the expression as specified
    previously and assign a different meaning to the numbers `1` and `*2*` and to
    the symbol `+`, and the semantics of the expression will be entirely different.
  prefs: []
  type: TYPE_NORMAL
- en: 'This line of reasoning can be applied to declarative programs. For example,
    consider the following snippet in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be rewritten with the Scala infix notation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is because Scala supports a syntactic sugar that is allowed to call Scala
    methods as infix operators. The point here is that you can read the `map` function
    as an operator. The operator that binds its operands together specifies what to
    do with them. The first operand is the collection we are mapping, while the second
    operand is the lambda function you are mapping it with.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of the program is expressed here as operators that bind their operands
    together, while the execution of the program is taken to mean a computation of
    some value, and not an execution of an algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'One advantage here is the absence of the notion of change. In algebra, time
    is effectively removed from the equation. Consider the implementation of map functionality
    in Java. It is algorithmic, which means that you explain about it in time, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Take the first element of the collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, apply a function to this element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, insert it into the resulting collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the same process with the second element, and then the third, and so
    on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice the presence of time in the preceding description. You clearly have a
    notion of what happens first and what happens after that.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at the Scala implementation of that functionality. In Scala,
    you specify what you need the program to do as an algebraic expression, as a binding
    of two operators, the collection and the lambda function, by the operator `map`.
    This expression no longer has a time dimension associated with it. You simply
    write down a mathematical expression and leave it to your language to assign some
    semantics to it.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that the `map` function in Scala is implemented with the help of algorithms
    and that it probably works just like it does in Java. However, for all intents
    and purposes, you can forget about this in most of the programs you will be writing.
    You can think of this program as a different paradigm, a paradigm of symbolically
    expressing what you want to do.
  prefs: []
  type: TYPE_NORMAL
- en: This paradigm separates the semantics from the structure of your program. When
    I say structure, I mean the symbols involved in describing the program; the symbols
    as in the collection you are mapping, the lambda function you are mapping it by,
    and the map as an operator. All of these entities are referred to with the help
    of symbols you write. By semantics, I mean the actions performed by the computer
    when it processes this expression, how it understands this expression, and how
    it runs this expression.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about programs this way allows you to treat them as mathematical expressions
    and work with them as with data structures—the symbolic structures of the expressions.
    This is in contrast to the algorithmic approach, which is so popular in traditional
    imperative programming, as we have seen with the example involving Java.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage here is that it is easier to use symbolic logic to explain programs
    that are expressed as mathematical expressions and not algorithms. Second, in
    a proper declarative program, there is no dimension of time, which removes a whole
    class of bugs. Of course, you should remember all of this is an abstraction. You
    can fairly say that it is an illusion. Under the hood, algorithms still matter;
    time still exists. However, in the declarative style, you leverage the principle
    of abstraction. You abstract away the time and the algorithms. This is comparable
    to how, when your program operates with a high-level language such as Java, you
    do not need to think about the byte code or the low-level processor instructions
    it compiles to. This low-level code still exists, it still matters, but, to all
    intents and purposes, you can forget about it. The same thing happens with algorithms
    being abstracted away with the declarative and algebraic styles.
  prefs: []
  type: TYPE_NORMAL
- en: Treating programs as mathematical expressions is facilitated by techniques that
    abstract away side effects. These rely on data structures specific to purely functional
    programming. Let's now have look at such data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Effect types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we discussed collections as an example of imperative and declarative
    data structures. However, the functional and declarative styles also contain some
    data structures specific to them.
  prefs: []
  type: TYPE_NORMAL
- en: Collections abstract away multiplicity. Functional languages such as Scala,
    Haskell, and others bring in some other data structures that abstract away side
    effects. We can refer to them as effect types.
  prefs: []
  type: TYPE_NORMAL
- en: We have argued that pure algebraic and declarative approaches remove time from
    the equation. This is advantageous because time taxes the programmer's mind. Functional
    programming takes this idea further by removing side effects from your programs.
    They also burden the mind as you also need to take them into account and handle
    them properly.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we discussed an example of how a Java list interface throws exceptions.
    We argued that it is pretty bad because it increases the mental load on a programmer's
    mind, since they need to constantly keep in mind that there are cases in which
    an exception can be thrown and they should account for these cases. In functional
    programming, this is not acceptable. Functional programming aspires to remove
    all side effects from the equation.
  prefs: []
  type: TYPE_NORMAL
- en: We will see in detail later in the book how this is done but, for now, let's
    have a look at the `Try` structure.
  prefs: []
  type: TYPE_NORMAL
- en: Try
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Try` data structure is present in one form or another in many programming
    languages. It may contain one of two values. One possibility is an arbitrary type
    of value `A`, while the second is an exception. This data structure can be returned
    as the result of a computation that can result in an error. This way, you no longer
    need to throw an exception. You can just return `Try[A]` when your method may
    result in an error. In Scala, the square bracket after the type name stands for
    type parameters, so `Try[A]` means the type `Try` with the type parameter `A`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider an example where we have a function that divides one
    number by another. However, in the event that the second number is zero, we throw
    an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call the method, in certain cases it may result in an exception – a
    side effect we may not be aware of or have forgotten:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The program will crash at this point. However, if we wrap it in `Try`, we can
    prevent the program from crashing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Because the return type clearly specifies the possibility of an error, this
    possibility no longer needs to be kept in mind. Since an error is now represented
    as a data structure, it does not disrupt the program when it happens. Here, we
    can see a representation of phenomena as data. Representing phenomena as data
    is called **reification**, and we will see later in the book how important this
    concept is in pure functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another example of a data structure that is characteristic of functional languages
    is an `Option`. An `Option` can either contain a value or be empty. You can think
    of it as an abstraction of the notion of the null pointer in Java or C++. The
    advantage here is that the programmer no longer needs to remember that some methods
    return a null. The methods that may, or may not, result in a value will return
    an `Option[A]` to signify this possibility, just as in the case of `Try`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider a method that returns the name of the user by their ID.
    Some IDs won''t map to a user. Hence, we can model the scenario where we can''t
    return a user that does not exist as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That is, if the user ID is `1`, `2` or `3`, we surmise that the user is present
    in the database, otherwise they are not. We explicitly include the information
    about whether the user is present as the `Option` type. That is, we don't just
    return the user's name, but also the information about whether they are present
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage here is that you won''t be able to access the user''s name without
    first checking whether they were found or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, the result of `getUserName`is not a raw `String` but a `String `wrapped
    in an `Option`. So, we first analyze the `Option` with the pattern matching statement
    before obtaining the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example outputs `User-1` to the console. However, this example
    outputs `User not found`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Data structures in different programming languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the preceding discussion, you may conclude that there is a substantial
    difference between a functional and comparative approach to programming. While
    imperative programming is focused on algorithms, declarative programming is focused
    on the phenomena produced by these algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Imperative programming allows you to produce phenomena with the help of algorithms.
    Declarative programming names the phenomena you may need and then allows you to
    call them by name. This abstracts away all the details of the inner workings of
    the phenomena.
  prefs: []
  type: TYPE_NORMAL
- en: This is reflected in the separation between the approaches to data structures
    in different languages. Imperative programming languages, such as C++ or Java,
    will have their data structures, specifically, collections, implemented in a low-level
    manner. Typically, they will be mutable and will have some very basic primitive
    methods defined therein. Whatever you want to express, you will need to express
    it algorithmically with the help of these primitives.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming languages, such as Scala or Haskell, will usually have
    immutable data structures. They focus on the phenomena and the high-level behavior
    you need to get things done. Examples of high-level behavior include mapping values
    of a certain type onto values of another type, and filtering certain values out
    of a collection of values.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is much easier to program with purely functional and declarative
    programming collections. They provide you with lots of building blocks with which
    to build your programs.
  prefs: []
  type: TYPE_NORMAL
- en: However, in certain circumstances, it may be desirable for you to use imperative
    data structures. Lower-level programming styles may be desirable if you want to
    craft your algorithms instead of relying on off-the-shelf implementations. The
    circumstances in question may be high-performance operations, for example.
  prefs: []
  type: TYPE_NORMAL
- en: In the gaming industry, if you are designing a performance-demanding game, it
    may be possible in certain sections of the game that you will need to write your
    operations yourself in order to meet performance requirements. Also, it is possible
    that you may need to employ such low-level approaches in the case of micro-controller
    programming or situations where you have limited computational resources and you
    need to take full advantage of what you have.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we had a look at how different programming styles define data
    structures and their approach to building programs using these data structures.
    We have seen how imperative programming relies heavily on algorithms and low-level
    operations. You have learned about basic mutable data structures and basic operations
    to mutate the data structures, as well as how to compose algorithms in your programming
    language of choice with the help of these data structures.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, in the declarative style, the focus shifts from algorithms to mathematical
    expressions. The collections data structures are usually immutable. You have a
    lot of high-level operations defined on these data structures. You use these operations
    in order to express the program, not with algorithms, but as a set of algebraic
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Collections are one of the main aspects of almost any program. Hence, most of
    the modern programming languages support them out of the box, and, looking at
    the collections framework, it is possible to say what approach and philosophy
    that programming language follows.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to collections, there are other data structures that are specific
    to functional programming. These data structures will be covered in detail in
    the later chapters of this book. For now, it is worth observing that data structures
    such as `Try` or `Option` are needed to abstract away side effects that may occur
    in your program.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these functional programming-specific data structures aim at bringing
    side effects into the purely functional paradigm. With these structures, you can
    work with side effects while maintaining referential transparency. In the next
    chapter, we will have a look at the problem of side effects in details.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the general approach you take when writing an imperative collections-based
    application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the general approach you take when writing a functional collections-based
    application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it not necessary to be trained in algorithm reasoning when dealing with
    functional data structures (in the majority of cases)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the algebraic approach to programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of adopting an algebraic style?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of effect types such as `Option` or `Try` ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Learning Scala Programming* by Vikash Sharma and the section entitled *Getting
    familiar with Scala collections* ([https://www.packtpub.com/application-development/learning-scala-programming](https://www.packtpub.com/application-development/learning-scala-programming)).'
  prefs: []
  type: TYPE_NORMAL
