<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Reducing the Coding Effort by Relying on Standards</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This chapter covers the following recipes:</p>
<ul class="calibre13">
<li class="calibre14">Preparing your application to use a connection pool</li>
<li class="calibre14">Using messaging services for asynchronous communication</li>
<li class="calibre14">Understanding a servlet's life cycle</li>
<li class="calibre14">Transaction management</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">One of the most important concepts that you need to know about Java EE is: it is a standard. If you go to the <strong class="calibre7">Java Community Process</strong> (<strong class="calibre7">JCP</strong>) website, you will find the <strong class="calibre7">Java Specification Request</strong> (<strong class="calibre7">JSR</strong>) for the Java EE platform (for Version 8 it is JSR 366).</p>
<p class="mce-root">A standard... for what? Well, for an application server! For instance, a Java EE application server.</p>
<p class="mce-root">It means that you can develop your Java EE application knowing it will run in an environment that provides a bunch of resources that you can rely on.</p>
<p class="mce-root">It also means you can easily move from one application server to another, as long as you stick to the Java EE patterns instead of some vendor-specific feature (considered a bad practice). Your application should have the same behavior no matter what Java EE-compatible server you are using.</p>
<p class="mce-root">Oh, yes! Beyond being a standard, Java EE is also a certification. For a Java EE server to be considered compatible, it has to pass through a number of tests to guarantee it implements every single point of the specification (JSR).</p>
<p class="mce-root">This amazing ecosystem allows for less coding of your application and gives you the chance to focus on what really matters to you or to your client. Without a standard environment, you would need to implement your own code for request/response management, queues, connection pooling, and other stuff.</p>
<p class="mce-root">You can definitely do it if you want, but you don't have to. Actually you can even write your own Java EE application server, if you want to.</p>
<p class="mce-root">Having said that let's move on with the chapter! In the following recipes, you are going to learn how to take advantage of some cool features already implemented on your favorite Java EE application server.</p>
<p class="mce-root">Examples will be based on GlassFish 5 but, as I mentioned before, they should have the same behavior for any other compatible implementation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Preparing your application to use a connection pool</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">One of the first things we should learn in our life, after feeding, is using a connection pool. Especially when we are talking about databases. This is the case covered here.</p>
<p class="mce-root">Why? Because a connection opened with the database is costly in terms of resources used for it. Even worse, if we look closer at the process of opening a new connection, it uses a lot of CPU resources, for example.</p>
<p class="mce-root">Maybe it won't make much difference if you have two users using a database with a couple of registers in a few tables. But it can start causing trouble if you have dozens of users, or if the database is large and gives you sleepless nights when you have hundreds of users using a huge database.</p>
<p class="mce-root">Actually I, myself, saw in the early days of J2EE 1.3 (the year was 2002), a performance issue being solved by a connection pool in an application used by 20 people. There were a few users, but the database was really big and not so well-designed (the same for the application, I have to say).</p>
<p class="mce-root">But you may say: why does a connection pool help us with this? Because once it is configured, the server will open all the connections you asked for, when it is starting up, and will manage them for you.</p>
<p class="mce-root">The only thing you have to do is to ask: <em class="calibre17">"Hey, server! Could you lend me a database connection, please?"</em> and kindly give it back when you are done (which means as quickly as possible).</p>
<p class="mce-root">This recipe will show you how to do it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">First, add the right dependency to your project:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>
<p class="mce-root">If you still haven't downloaded GlassFish 5 to your development environment, this is the right time to do it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">We will begin by configuring our connection pool in GlassFish 5. Once it is up and running, go to this URL:</li>
</ol>
<p class="calibre23"><kbd class="calibre16">http://localhost:8080</kbd></p>
<ol start="2" class="calibre19">
<li class="chapter">Now click on the <span class="calibre5">go to the Administration Console</span> link or if you prefer, go straight to the URL at:</li>
</ol>
<p class="calibre23"><kbd class="calibre16">http://localhost:4848/</kbd></p>
<ol start="3" class="calibre19">
<li class="chapter">Then follow this path in the left menu:</li>
</ol>
<p class="calibre23"><span class="calibre8">Resources</span> | <span class="calibre8">JDBC</span> | <span class="calibre8">JDBC Connection Pools</span></p>
<ol start="4" class="calibre19">
<li class="chapter">Click on the <span class="calibre5">New</span> button. It will open the <span class="calibre5">New JDBC Connection Pool</span> page. Fill in the fields as described here:</li>
</ol>
<ul class="calibre13">
<li class="calibre27"><span class="calibre5">Pool Name</span>: <kbd class="calibre16">MysqlPool</kbd></li>
<li class="calibre27"><span class="calibre5">Resource Type</span>: <kbd class="calibre16">javax.sql.DataSource</kbd></li>
<li class="calibre27"><span class="calibre5">Database Driver Vendor</span>: <kbd class="calibre16">MySql</kbd></li>
</ul>
<p class="calibre23">Of course, you can make your own custom choices, but then we will be following different paths!</p>
<ol start="5" class="calibre19">
<li class="chapter">Click on the <span class="calibre5">Next</span> button. It will open the second step for our pool creation process.</li>
</ol>
<p class="calibre23">This new page has three sections: <span class="calibre8">General Settings</span>, <span class="calibre8">Pool Settings</span>, and <span class="calibre8">Transaction and Additional Properties</span>. For our recipe, we are only dealing with <span class="calibre8">General Settings</span> and <span class="calibre8">Additional Properties</span>.</p>
<ol start="6" class="calibre19">
<li class="chapter">In the <span class="calibre5">General Settings</span> section make sure that <span class="calibre5">DataSource Classname</span> has this value selected:</li>
</ol>
<p class="calibre23"><kbd class="calibre16">com.mysql.jdbc.jdbc2.optional.MysqlDatasource</kbd></p>
<ol start="7" class="calibre19">
<li class="chapter">Now let's move to the <span class="calibre5">Additional Properties</span> section. There might be a bunch of properties listed, but we will just fill in a few of them:</li>
</ol>
<ul class="calibre13">
<li class="calibre27"><span class="calibre5">DatabaseName</span>: <kbd class="calibre16">sys</kbd></li>
<li class="calibre27"><span class="calibre5">ServerName</span>: <kbd class="calibre16">localhost</kbd></li>
<li class="calibre27"><span class="calibre5">User</span>: <kbd class="calibre16">root</kbd></li>
<li class="calibre27"><span class="calibre5">Password</span>: <kbd class="calibre16">mysql</kbd></li>
<li class="calibre27"><span class="calibre5">PortNumber</span>: <kbd class="calibre16">3306</kbd></li>
</ul>
<ol start="8" class="calibre19">
<li class="chapter">Click on the <span class="calibre5">Finish</span> button and voilá! Your connection pool is ready... or almost.</li>
</ol>
<p class="calibre23">You can't access it until you do one more configuration. In the same menu, on the left, following this path:</p>
<p class="calibre23"><span class="calibre8">Resources</span> | <span class="calibre8">JDBC</span> | <span class="calibre8">JDBC Resources</span></p>
<ol start="9" class="calibre19">
<li class="chapter">Click on the <span class="calibre5">New</span> button and then fill in the fields like this:</li>
</ol>
<ul class="calibre13">
<li class="calibre27"><span class="calibre5">JNDI Name</span>: <kbd class="calibre16">jdbc/MysqlPool</kbd></li>
<li class="calibre27"><span class="calibre5">Pool Name</span>: <kbd class="calibre16">MysqlPool</kbd></li>
</ul>
<p class="mce-root">Now you are good to go! Your connection pool is ready to be used. Let's build a simple application to try it:</p>
<ol class="calibre19">
<li class="chapter">First, we create a class to get a connection from the pool:</li>
</ol>
<pre class="mce-root2">public class ConnectionPool {<br class="calibre2"/><br class="calibre2"/>    public static Connection getConnection() throws SQLException, <br class="calibre2"/>    NamingException {<br class="calibre2"/>        InitialContext ctx = new InitialContext();<br class="calibre2"/>        DataSource ds = (DataSource) ctx.lookup("jdbc/MysqlPool");<br class="calibre2"/><br class="calibre2"/>        return ds.getConnection();<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">Then, a class that we will use as a representation of the <kbd class="calibre16">sys_config</kbd> table (MySQL's system table):</li>
</ol>
<pre class="mce-root2">public class SysConfig {<br class="calibre2"/><br class="calibre2"/>    private final String variable;<br class="calibre2"/>    private final String value;<br class="calibre2"/><br class="calibre2"/>    public SysConfig(String variable, String value) {<br class="calibre2"/>        this.variable = variable;<br class="calibre2"/>        this.value = value;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getVariable() {<br class="calibre2"/>        return variable;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getValue() {<br class="calibre2"/>        return value;<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">Here we create another class, to create a list based on the data returned from the database:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>public class SysConfigBean {<br class="calibre2"/><br class="calibre2"/>    public String getSysConfig() throws SQLException, NamingException {<br class="calibre2"/>        String sql = "SELECT variable, value FROM sys_config";<br class="calibre2"/><br class="calibre2"/>        try (Connection conn = ConnectionPool.getConnection();<br class="calibre2"/>                PreparedStatement ps = conn.prepareStatement(sql);<br class="calibre2"/>                ResultSet rs = ps.executeQuery()<br class="calibre2"/>                Jsonb jsonb = JsonbBuilder.create()) {<br class="calibre2"/><br class="calibre2"/>            List&lt;SysConfig&gt; list = new ArrayList&lt;&gt;();<br class="calibre2"/>            while (rs.next()) {<br class="calibre2"/>                list.add(new SysConfig(rs.getString("variable"), <br class="calibre2"/>                rs.getString("value")));<br class="calibre2"/>            }<br class="calibre2"/><br class="calibre2"/>            Jsonb jsonb = JsonbBuilder.create();<br class="calibre2"/>            return jsonb.toJson(list);<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="4" class="calibre19">
<li class="chapter">And finally a servlet that will try them all:</li>
</ol>
<pre class="mce-root2">@WebServlet(name = "PoolTestServlet", urlPatterns = {"/PoolTestServlet"})<br class="calibre2"/>public class PoolTestServlet extends HttpServlet {<br class="calibre2"/><br class="calibre2"/>    @EJB<br class="calibre2"/>    private SysConfigBean config;<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    protected void doGet(HttpServletRequest request, <br class="calibre2"/>    HttpServletResponse response)<br class="calibre2"/>            throws ServletException, IOException {<br class="calibre2"/><br class="calibre2"/>        try (PrintWriter writer = response.getWriter()) {<br class="calibre2"/>            config = new SysConfigBean();<br class="calibre2"/>            writer.write(config.getSysConfig());<br class="calibre2"/>        } catch (SQLException | NamingException ex) {<br class="calibre2"/>            System.err.println(ex.getMessage());<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="calibre23">To try it just open this URL in your browser:</p>
<p class="calibre23"><kbd class="calibre16">http://localhost:8080/ch06-connectionpooling/PoolTestServlet</kbd></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Deciding how many connections your pool will hold, as well as all the other parameters, is an architecture decision made based on a number of factors such as the type of data, database design, application and user behavior, and so on. We could write a whole book about it.</p>
<p class="mce-root">But if you are starting from scratch and/or still don't need much information, consider a number between 10% to 20% of your concurrent users. In other words, if your application has, for instance, 100 concurrent users, you should provide 10 to 20 connections to your pool.</p>
<p class="mce-root">You will know that your connections aren't enough if some methods are taking too much time to get a connection from the pool (it should take no time at all). It means that the server has no available connection at that moment.</p>
<p class="mce-root">So, you need to check if there are some methods taking too long to complete, or even some part in your code that is not closing the connection (consider what gives the connection back to the server). Depending on the issue, it might not be a pooling problem but a design one.</p>
<p class="mce-root">Another important thing for dealing with connection pools is to use the "try-with-resources" statement as we did here:</p>
<pre class="calibre21">        try (Connection conn = ConnectionPool.getConnection();<br class="calibre2"/>                PreparedStatement ps = conn.prepareStatement(sql);<br class="calibre2"/>                ResultSet rs = ps.executeQuery()) {</pre>
<p class="mce-root">This will guarantee that these resources will be properly closed once the method is done and also deal with their respective exceptions, also helping you to write less code.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">See this recipe's full source code at: <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-connectionpooling" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-connectionpooling</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using messaging services for asynchronous communication</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The message service, provided in Java EE by the <span class="calibre8"><strong class="calibre7">Java Message Service</strong> (</span><strong class="calibre7">JMS</strong>) API, is one of the most important and versatile features provided by Java EE environments.</p>
<p class="mce-root">It uses the Producer-Consumer approach, where one peer (the <span class="calibre8">Producer</span>) puts a message into a queue and another peer (the <span class="calibre8">Consumer</span>) reads the message from there.</p>
<p class="mce-root">Both the Producer and Consumer can be different applications, even using different technologies.</p>
<p class="mce-root">This recipe will show you how to build a messaging service using GlassFish 5. Each Java EE server has its own way to set up the service, so if are using some other implementations, you should take a look at its documentation. </p>
<p class="mce-root">On the other hand, the Java EE code generated here will work on any Java EE 8-compatible implementation. Standard for the win!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">First add the proper dependency to your project:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">We will begin by configuring our messaging service in GlassFish 5. Once the server is up and running, go to this URL:</li>
</ol>
<p class="calibre26"><kbd class="calibre16">http://localhost:8080</kbd></p>
<ol start="2" class="calibre19">
<li class="chapter">Now click on the <span class="calibre5">go to the Administration Console</span> link or if you prefer, go straight to the URL at:</li>
</ol>
<p class="calibre26"><kbd class="calibre16">http://localhost:4848/</kbd></p>
<p class="calibre23">Then follow this path in the left menu:</p>
<p class="calibre23"><span class="calibre8">Resources</span> | <span class="calibre8">JMS Resources</span> | <span class="calibre8">Connection Factories</span></p>
<ol start="3" class="calibre19">
<li class="chapter">Click on the <span class="calibre5">New</span> button. When the page is opened, fill the <span class="calibre5">General Settings</span> section fields like this:</li>
</ol>
<ul class="calibre13">
<li class="calibre27"><span class="calibre5">JNDI Name</span>: <kbd class="calibre16">jms/JmsFactory</kbd></li>
<li class="calibre27"><span class="calibre5">Resource Type</span>: <kbd class="calibre16">javax.jms.ConnectionFactory</kbd></li>
</ul>
<p class="calibre23">We will not touch the <span class="calibre8">Pool Settings</span> section here, so just click on the <span class="calibre8">OK</span> button to register your new factory.</p>
<ol start="4" class="calibre19">
<li class="chapter">Now follow this path in the left menu:</li>
</ol>
<p class="calibre23"><span class="calibre8">Resources</span> | <span class="calibre8">JMS Resources</span> | <span class="calibre8">Destination Resources</span></p>
<ol start="5" class="calibre19">
<li class="chapter"><span class="calibre5">Click on the <span class="calibre5">New</span> button. When the page is opened, fill the section fields like this:</span></li>
</ol>
<ul class="calibre13">
<li class="calibre27"><span class="calibre5"><span class="calibre5">JNDI Name</span>: <kbd class="calibre16">jms/JmsQueue</kbd></span></li>
<li class="calibre27"><span class="calibre5"><span class="calibre5">Physical Destination Name</span>: <kbd class="calibre16">JmsQueue</kbd></span></li>
<li class="calibre27"><span class="calibre5">ResourceType</span>: <kbd class="calibre16">javax.jms.Queue</kbd></li>
</ul>
<p class="mce-root">Click on the <span class="calibre8">OK</span> button and you are ready! Now you have a connection factory to access your JMS server and a queue. So let's build an application to use it:</p>
<ol class="calibre19">
<li class="chapter">First, we create a <strong class="calibre3">message driven bean</strong> (<span class="calibre5"><strong class="calibre3">MDB</strong>) </span>as a listener for any message dropped into our queue. This is the Consumer:</li>
</ol>
<pre class="mce-root2">@MessageDriven(activationConfig = {<br class="calibre2"/>    @ActivationConfigProperty(propertyName = "destinationLookup", <br class="calibre2"/>    propertyValue = "jms/JmsQueue"),<br class="calibre2"/>    @ActivationConfigProperty(propertyName = "destinationType", <br class="calibre2"/>    propertyValue = "javax.jms.Queue")<br class="calibre2"/>})<br class="calibre2"/>public class QueueListener implements MessageListener {<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public void onMessage(Message message) {<br class="calibre2"/>        TextMessage textMessage = (TextMessage) message;<br class="calibre2"/>        try {<br class="calibre2"/>            System.out.print("Got new message on queue: ");<br class="calibre2"/>            System.out.println(textMessage.getText());<br class="calibre2"/>            System.out.println();<br class="calibre2"/>        } catch (JMSException e) {<br class="calibre2"/>            System.err.println(e.getMessage());<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">Now we define the Producer class:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>public class QueueSender {<br class="calibre2"/><br class="calibre2"/>    @Resource(mappedName = "jms/JmsFactory")<br class="calibre2"/>    private ConnectionFactory jmsFactory;<br class="calibre2"/>    <br class="calibre2"/>    @Resource(mappedName = "jms/JmsQueue")<br class="calibre2"/>    private Queue jmsQueue;<br class="calibre2"/><br class="calibre2"/>    public void send() throws JMSException {<br class="calibre2"/>        MessageProducer producer;<br class="calibre2"/>        TextMessage message;<br class="calibre2"/><br class="calibre2"/>        try (Connection connection = jmsFactory.createConnection(); <br class="calibre2"/>             Session session = connection.createSession(false, <br class="calibre2"/>             Session.AUTO_ACKNOWLEDGE)) {<br class="calibre2"/>            <br class="calibre2"/>            producer = session.createProducer(jmsQueue);<br class="calibre2"/>            message = session.createTextMessage();<br class="calibre2"/><br class="calibre2"/>            String msg = "Now it is " + new Date();<br class="calibre2"/>            message.setText(msg);<br class="calibre2"/>            System.out.println("Message sent to queue: " + msg);<br class="calibre2"/>            producer.send(message);<br class="calibre2"/><br class="calibre2"/>            producer.close();<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">And a servlet to access the Producer:</li>
</ol>
<pre class="mce-root2">@WebServlet(name = "QueueSenderServlet", urlPatterns = {"/QueueSenderServlet"})<br class="calibre2"/>public class QueueSenderServlet extends HttpServlet {<br class="calibre2"/>    <br class="calibre2"/>    @Inject<br class="calibre2"/>    private QueueSender sender;<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    protected void doGet(HttpServletRequest request, <br class="calibre2"/>    HttpServletResponse response)<br class="calibre2"/>            throws ServletException, IOException {<br class="calibre2"/>        try(PrintWriter writer = response.getWriter()){<br class="calibre2"/>            sender.send();<br class="calibre2"/>            writer.write("Message sent to queue. <br class="calibre2"/>            Check the log for details.");<br class="calibre2"/>        } catch (JMSException ex) {<br class="calibre2"/>            System.err.println(ex.getMessage());<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="4" class="calibre19">
<li class="chapter">Finally, we create a page just to call our servlet:</li>
</ol>
<pre class="mce-root2">&lt;html&gt;<br class="calibre2"/>    &lt;head&gt;<br class="calibre2"/>        &lt;title&gt;JMS recipe&lt;/title&gt;<br class="calibre2"/>        &lt;meta http-equiv="Content-Type" content="text/html; <br class="calibre2"/>         charset=UTF-8"&gt;<br class="calibre2"/>    &lt;/head&gt;<br class="calibre2"/>    &lt;body&gt;<br class="calibre2"/>        &lt;p&gt;<br class="calibre2"/>            &lt;a href="QueueSenderServlet"&gt;Send Message to Queue&lt;/a&gt;<br class="calibre2"/>        &lt;/p&gt;<br class="calibre2"/>    &lt;/body&gt;<br class="calibre2"/>&lt;/html&gt;</pre>
<p class="mce-root">Now just deploy and run it. Each time you call <kbd class="calibre16">QueueSenderServlet</kbd> you should see something like this on your server log:</p>
<pre class="calibre21"><strong class="calibre3">Info: Message sent to queue: Now it is Tue Dec 19 06:52:17 BRST 2017</strong><br class="calibre2"/><strong class="calibre3">Info: Got new message on queue: Now it is Tue Dec 19 06:52:17 BRST 2017</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Thanks to the standards implemented in the Java EE 8 server, our MDB is 100% managed by the container. That's why we could just refer to the queue without looking back:</p>
<pre class="calibre21">@MessageDriven(activationConfig = {<br class="calibre2"/>    @ActivationConfigProperty(propertyName = "destinationLookup", <br class="calibre2"/>    propertyValue = "jms/JmsQueue"),<br class="calibre2"/>    @ActivationConfigProperty(propertyName = "destinationType", <br class="calibre2"/>    propertyValue = "javax.jms.Queue")<br class="calibre2"/>})</pre>
<p class="mce-root">We could have built a Consumer by our own hands, but it would build three times as many code lines and would be synchronous.</p>
<p class="mce-root">We get our container Producer from a session provided by our factory and made for our queue:</p>
<pre class="calibre21">        try (Connection connection = jmsFactory.createConnection(); <br class="calibre2"/>             Session session = connection.createSession(false, <br class="calibre2"/>             Session.AUTO_ACKNOWLEDGE)) {<br class="calibre2"/>            <br class="calibre2"/>            producer = session.createProducer(jmsQueue);<br class="calibre2"/>            ...<br class="calibre2"/>        }</pre>
<p class="mce-root">Then all we have to do is to create and send the message:</p>
<pre class="calibre21">            message = session.createTextMessage();<br class="calibre2"/><br class="calibre2"/>            String msg = "Now it is " + new Date();<br class="calibre2"/>            message.setText(msg);<br class="calibre2"/>            System.out.println("Message sent to queue: " + msg);<br class="calibre2"/>            producer.send(message);</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">You could refer to the full source code for this recipe at: <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-jms" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-jms</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Understanding a servlet's life cycle</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">If you are used to creating web applications using Java EE, you probably will have already realized: most of the time it is all about dealing with requests and responses and the most popular way to do it is by using the Servlet API.</p>
<p class="mce-root">This recipe will show you how the server deals with its life cycles and what you should and should not been doing in your code.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">First, add the proper dependency to your project:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Just write this simple servlet:</p>
<pre class="calibre22">@WebServlet(name = "LifecycleServlet", <br class="calibre2"/>urlPatterns = {"/LifecycleServlet"})<br class="calibre2"/>public class LifecycleServlet extends HttpServlet {<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    protected void doGet(HttpServletRequest req, <br class="calibre2"/>    HttpServletResponse resp) throws ServletException, IOException {<br class="calibre2"/>        try(PrintWriter writer = resp.getWriter()){<br class="calibre2"/>            writer.write("doGet");<br class="calibre2"/>            System.out.println("doGet");<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @Override<br class="calibre2"/>    protected void doPost(HttpServletRequest req, <br class="calibre2"/>    HttpServletResponse resp) throws ServletException, IOException {<br class="calibre2"/>        try(PrintWriter writer = resp.getWriter()){<br class="calibre2"/>            writer.write("doPost");<br class="calibre2"/>            System.out.println("doPost");<br class="calibre2"/>        }<br class="calibre2"/>    } <br class="calibre2"/>    <br class="calibre2"/>    @Override<br class="calibre2"/>    protected void doDelete(HttpServletRequest req, <br class="calibre2"/>    HttpServletResponse resp) throws ServletException, IOException {<br class="calibre2"/>        try(PrintWriter writer = resp.getWriter()){<br class="calibre2"/>            writer.write("doDelete");<br class="calibre2"/>            System.out.println("doDelete");<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @Override<br class="calibre2"/>    protected void doPut(HttpServletRequest req, <br class="calibre2"/>    HttpServletResponse resp) throws ServletException, IOException {<br class="calibre2"/>        try(PrintWriter writer = resp.getWriter()){<br class="calibre2"/>            writer.write("doPut");<br class="calibre2"/>            System.out.println("doPut");<br class="calibre2"/>        }<br class="calibre2"/>    } <br class="calibre2"/>    <br class="calibre2"/>    @Override<br class="calibre2"/>    public void init() throws ServletException {<br class="calibre2"/>        System.out.println("init()");<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Override<br class="calibre2"/>    public void destroy() {<br class="calibre2"/>        System.out.println("destroy");<br class="calibre2"/>    } <br class="calibre2"/>}</pre>
<p class="mce-root">Once it is deployed to your Java EE server, I suggest you try it using a tool such as SoapUI or similar. It will allow you to send requests using <kbd class="calibre16">GET</kbd>, <kbd class="calibre16">POST</kbd>, <kbd class="calibre16">PUT</kbd>, and <kbd class="calibre16">DELETE</kbd>. The browser would only do <kbd class="calibre16">GET</kbd>.</p>
<p class="mce-root">If you do it, your system log will look just like this:</p>
<pre class="calibre21"><strong class="calibre3">Info: init(ServletConfig config)</strong><br class="calibre2"/><strong class="calibre3"> Info: doGet</strong><br class="calibre2"/><strong class="calibre3"> Info: doPost</strong><br class="calibre2"/><strong class="calibre3"> Info: doPut</strong><br class="calibre2"/><strong class="calibre3"> Info: doDelete</strong></pre>
<p class="mce-root">And if you undeploy your application it will look as follows:</p>
<pre class="calibre21"><strong class="calibre3">Info:   destroy</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">If you pay attention, you will notice that the <kbd class="calibre16">init</kbd> log will show only after your servlet is called for the first time. That's when it is really loaded and it is the only time that this method will be called. So if you have some one-shot code for this servlet, that's the place to do it.</p>
<p class="mce-root">Talking about the <kbd class="calibre16">doGet</kbd>, <kbd class="calibre16">doPost</kbd>, <kbd class="calibre16">doPut</kbd>, and <kbd class="calibre16">doDelete</kbd> methods, note that they were all automatically called by the server based on the request received. It's possible thanks to another method implemented by the server called <kbd class="calibre16">service</kbd>.</p>
<p class="mce-root">You could override the <kbd class="calibre16">service</kbd> method if you want, but it's a bad practice and should be avoided. Do it only if you know exactly what you are doing, otherwise you could give the wrong destination to some requests. This chapter is about relying on the standards, so why wouldn't you observe them?</p>
<p class="mce-root">Finally, we have the <kbd class="calibre16">destroy</kbd> method being called when your application is undeployed. This is like the last breath of your servlet. It is also a bad practice to add some code here, as you could prevent some resource from being released, and/or run into some process errors.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">You can refer to the full source code for this recipe at: <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-lifecycle" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-lifecycle</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Transaction management</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Transaction management is one of the trickier subjects in computer science. One single wrong line, one unpredicted situation, and your data and/or your user will suffer the consequences.</p>
<p class="mce-root">So it would be nice if we could count on the server to do it for us. And most of the time we can, so let me show you how to do it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">First add the proper dependency to your project:</p>
<pre class="calibre21">        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">Let's build a bean that will perform all the transactions we need:</li>
</ol>
<pre class="mce-root2">@Stateful<br class="calibre2"/>@TransactionManagement<br class="calibre2"/>public class UserBean {<br class="calibre2"/>    <br class="calibre2"/>    private ArrayList&lt;Integer&gt; actions;<br class="calibre2"/>    <br class="calibre2"/>    @PostConstruct<br class="calibre2"/>    public void init(){<br class="calibre2"/>        actions = new ArrayList&lt;&gt;();<br class="calibre2"/>        System.out.println("UserBean initialized");<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public void add(Integer action){<br class="calibre2"/>        actions.add(action);<br class="calibre2"/>        System.out.println(action + " added");<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public void remove(Integer action){<br class="calibre2"/>        actions.remove(action);<br class="calibre2"/>        System.out.println(action + " removed");<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    public List getActions(){<br class="calibre2"/>        return actions;<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @PreDestroy<br class="calibre2"/>    public void destroy(){<br class="calibre2"/>        System.out.println("UserBean will be destroyed");<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @Remove<br class="calibre2"/>    public void logout(){<br class="calibre2"/>        System.out.println("User logout. Resources will be <br class="calibre2"/>        released.");<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @AfterBegin<br class="calibre2"/>    public void transactionStarted(){<br class="calibre2"/>        System.out.println("Transaction started");<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @BeforeCompletion<br class="calibre2"/>    public void willBeCommited(){<br class="calibre2"/>        System.out.println("Transaction will be commited");<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @AfterCompletion<br class="calibre2"/>    public void afterCommit(boolean commited){<br class="calibre2"/>        System.out.println("Transaction commited? " + commited);<br class="calibre2"/>    }   <br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">And a test class to try it:</li>
</ol>
<pre class="mce-root2">public class UserTest {<br class="calibre2"/>    <br class="calibre2"/>    private EJBContainer ejbContainer;<br class="calibre2"/>    <br class="calibre2"/>    @EJB<br class="calibre2"/>    private UserBean userBean;<br class="calibre2"/>    <br class="calibre2"/>    public UserTest() {<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @Before<br class="calibre2"/>    public void setUp() throws NamingException {<br class="calibre2"/>        ejbContainer = EJBContainer.createEJBContainer();<br class="calibre2"/>        ejbContainer.getContext().bind("inject", this); <br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @After<br class="calibre2"/>    public void tearDown() {<br class="calibre2"/>        ejbContainer.close();<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @Test<br class="calibre2"/>    public void test(){<br class="calibre2"/>        userBean.add(1);<br class="calibre2"/>        userBean.add(2);<br class="calibre2"/>        userBean.add(3);<br class="calibre2"/>        userBean.remove(2);<br class="calibre2"/>        int size = userBean.getActions().size();<br class="calibre2"/>        userBean.logout();<br class="calibre2"/>        Assert.assertEquals(2, size); <br class="calibre2"/>    }   <br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">If you try this test you should see this output:</li>
</ol>
<pre class="mce-root2"><strong class="calibre3"> UserBean initialized</strong><br class="calibre2"/><strong class="calibre3"> Transaction started</strong><br class="calibre2"/><strong class="calibre3"> 1 added</strong><br class="calibre2"/><strong class="calibre3"> Transaction will be commited</strong><br class="calibre2"/><strong class="calibre3"> Transaction commited? true</strong><br class="calibre2"/><strong class="calibre3"> Transaction started</strong><br class="calibre2"/><strong class="calibre3"> 2 added</strong><br class="calibre2"/><strong class="calibre3"> Transaction will be commited</strong><br class="calibre2"/><strong class="calibre3"> Transaction commited? true</strong><br class="calibre2"/><strong class="calibre3"> Transaction started</strong><br class="calibre2"/><strong class="calibre3"> 3 added</strong><br class="calibre2"/><strong class="calibre3"> Transaction will be commited</strong><br class="calibre2"/><strong class="calibre3"> Transaction commited? true</strong><br class="calibre2"/><strong class="calibre3"> Transaction started</strong><br class="calibre2"/><strong class="calibre3"> 2 removed</strong><br class="calibre2"/><strong class="calibre3"> Transaction will be commited</strong><br class="calibre2"/><strong class="calibre3"> Transaction commited? true</strong><br class="calibre2"/><strong class="calibre3"> Transaction started</strong><br class="calibre2"/><strong class="calibre3"> Transaction will be commited</strong><br class="calibre2"/><strong class="calibre3"> Transaction commited? true</strong><br class="calibre2"/><strong class="calibre3"> Transaction started</strong><br class="calibre2"/><strong class="calibre3"> User logout. Resources will be released.</strong><br class="calibre2"/><strong class="calibre3"> UserBean will be destroyed</strong><br class="calibre2"/><strong class="calibre3"> Transaction will be commited</strong><br class="calibre2"/><strong class="calibre3"> Transaction commited? true</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The first thing we did was mark our bean to hold states and have its transactions managed by the server:</p>
<pre class="calibre21">@Stateful<br class="calibre2"/>@TransactionManagement<br class="calibre2"/>public class UserBean {<br class="calibre2"/>    ...<br class="calibre2"/>}</pre>
<p class="mce-root">What happens then? If you note, no method that deals with adding or removing stuff does any transaction management. But they are still managed:</p>
<pre class="calibre21"><span class="calibre5"> Transaction started</span><br class="calibre2"/> <span class="calibre5">1 added</span><br class="calibre2"/> <span class="calibre5">Transaction will be commited</span><br class="calibre2"/> <span class="calibre5">Transaction commited? true</span></pre>
<p class="mce-root">So you have all the transaction intelligence without writing a single line of transaction stuff. </p>
<p class="mce-root">It will transact even when the bean would releases its resources:</p>
<pre class="calibre21"><span class="calibre5"> Transaction started</span><br class="calibre2"/> <span class="calibre5">User logout. Resources will be released.</span><br class="calibre2"/> <span class="calibre5">UserBean will be destroyed</span><br class="calibre2"/> <span class="calibre5">Transaction will be commited</span><br class="calibre2"/> <span class="calibre5">Transaction commited? true</span></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">Refer to the full source code for this recipe at: <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-transaction" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter06/ch06-transaction</a></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>