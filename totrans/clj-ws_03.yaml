- en: 3\. Functions in Depth
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take a deep dive into Clojure's functions. We discover
    destructuring techniques and advanced call signatures. We take a closer look at
    the first-class aspect of functions and learn how it enables functional composition,
    as well as advanced polymorphism techniques. This chapter teaches techniques that
    will significantly improve the conciseness and readability of your code. It lays
    down a solid basis to prepare you for the second part of this book about manipulating
    collections.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to implement features such as destructuring,
    variadic functions and multimethods when writing functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Clojure is a functional programming language, and functions are of primordial
    importance to the Clojure programmer. In functional programming, we avoid mutating
    the state of a program, which, as we have seen in the previous chapter, is greatly
    facilitated by Clojure''s immutable data structures. We also tend to do everything
    with functions, such that we need functions to be able to do pretty much everything.
    We say that Clojure functions are **first-class citizens** because we can pass
    them to other functions, store them in variables, or return them from other functions:
    we also call them first-class functions. Consider an e-commerce application, for
    example, where a user is presented with a list of items with different search
    filters and sorting options. Developing such a filtering engine with flags and
    conditions in an imperative programming way can quickly become unnecessarily complex;
    however, it can be elegantly expressed with functional programming. Functional
    composition is a great way to simply and efficiently implement such a filtering
    engine, for each filter (for example, the price, color, size of an item, and so
    on), the logic can be contained within a function and those functions could be
    simply combined or composed as a user interacts with an interface.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to master functions. We will start with
    destructuring techniques, which can notably be used in function parameters, then
    we will move on to advanced call signatures including functions with multiple
    arities and a variable number of arguments. Then, we will dive into the first-class
    aspect of functions and learn how they enable functional composition. Finally,
    we will explain advanced polymorphism techniques with multimethods and dispatch
    functions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Destructuring allows you to remove data elements from their structure or disassemble
    a structure. It is a technique that improves the readability and conciseness of
    your code by providing a better tool for a widely used pattern. There are two
    main ways of destructuring data: sequentially (with vectors) and associatively
    (with maps).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we need to write a function that prints a formatted string given
    a tuple of coordinates, for example, the tuple `[48.9615, 2.4372]`. We could write
    the following function:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This `print-coords` function takes a tuple of coordinates as a parameter and
    prints out the coordinates to the console in a nicely formatted string, for example,
    `Latitude:` `48.9615` – `Longitude:` `2.4372`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'What we are essentially doing when binding the first element to `lat` and the
    second to `lon` is destructuring: we are taking each element out of their sequential
    data structure. This use case is very common, and Clojure provides a built-in
    syntax for destructuring data structures to bind their values to symbols.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'We could rewrite the `print-coords` function with a sequential destructuring
    technique as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Observe how the preceding example is shorter and more expressive than the one
    before. We didn't need to use a function like `first` or `last`, we simply expressed
    the symbols we wanted to retrieve.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'The two functions are equivalent. `lat` is "mapped" to the first element of
    the vector and `lon` to the second. This other, simpler example might be more
    visually helpful:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how the bindings are created according to both the sequential order of
    the vector and the order of the symbols defined in vector `[a b c]`. The symbol
    values are then printed out to the console.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'A list, which is a sequential data structure, can be similarly disassembled:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Consider the same example of printing the coordinates of an airport, but this
    time we receive the data as a map rather than a tuple. The data has the following
    shape: `{:lat 48.9615, :lon 2.4372, :code ''LFPB'', :name "Paris Le Bourget Airport"}`.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'We could write the following function:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function retrieves the values from the `airport` map by using the keywords
    as functions in the `let` expression. We can spot the repetitive pattern when
    binding `lat`, `lon`, and `name`. Similarly, when the data structure we want to
    disassemble is associative (a `map`), we can use an associative *destructuring*
    technique. The function can be rewritten using associative destructuring, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this technique, we are creating bindings by mapping the symbols to the
    keys inside the map. The `lat` symbol now contains the value in the airport map
    at the key `:lat`, `lon` is mapped to the key `:lon`, and, finally, the `airport-name`
    symbol is mapped to the key `:name`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'When the keys and symbols can all have the same name, there is a shorter syntax
    available:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding destructuring syntax indicates looking for the `lat`, `lon`, and
    `name` keys inside the `airport` map and binding them to symbols with the same
    name. The syntax might look a little bit surprising, but it is a widely used technique
    in Clojure. We will use it in the next exercise so that you can learn how to use
    it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see our final function in action:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, the `print-coords` function destructures the airport
    `map` in the `let` expression and binds the values `48.9615`, `2.4372`, and `Paris
    Le Bourget Airport` to the symbols (respectively) `lat`, `lon`, and `name`. Those
    values are then printed out to the console with the `println` function (which
    returns `nil`).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've discovered the basics of destructuring and its utility, we can
    move on to the REPL, start practicing, and learn even more advanced destructuring
    techniques.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.01: Parsing Fly Vector''s Data with Sequential Destructuring'
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the purpose of this exercise, imagine that we are building a flight-booking
    platform application. For our first prototype, we just want to parse and print
    flight data that we receive from our partners. Our first partner, Fly Vector,
    has not yet discovered the power of associative data structures and they send
    us all their data in the form of Vectors. Luckily, they have comprehensive documentation.
    I have done the heavy lifting of reading the hundreds of pages of the data format
    specification for you and here is what it boils down to:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'A coordinate point is a tuple of latitude and longitude, for example: `[48.9615, 2.4372]`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A flight is a tuple of two coordinate points, for example: `[[48.9615, 2.4372],
    [37.742, -25.6976]]`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A booking consists of some information followed by one or multiple flights
    (up to three). The first item is Fly Vector''s internal ID for the booking, the
    second item is the name of the passenger, and the third is some sensitive information
    that Fly Vector asked us not to parse or even look at (they couldn''t update their
    system to remove the information). Finally, the rest of the vector consists of
    the flight coordinates data, for example:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That should be enough information for us to develop the prototype, so let''s
    get started:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a REPL and bind the sample booking data to the `booking` symbol:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Start developing our parsing function by experimenting with destructuring.
    Create a `let` block and define the binding as follows, printing out the result
    with `println`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that `flight3` was bound to the value `nil`. This is because the data
    is shorter than the bindings defined, and it is both valid and useful to be able
    to bind only values that exist.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Similarly, if the booking vector contained extra data, it would be ignored.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Remember that `conj` takes a collection and some elements as arguments and
    returns a new collection with those elements added to the collection. Add two
    flights in the booking vector with `conj` and parse the data using the same destructuring
    expression:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice how the last flight was simply ignored and not printed out. That's another
    useful trait of destructuring and another sign of Clojure's dynamism and practicality.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the data received, we don''t really care about the Fly Vector internal ID
    and we don''t want to parse the sensitive information. This can be simply ignored
    by using an underscore, `_`, instead of a symbol:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Great, we now understand how to ignore some parts of the data with destructuring.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Just printing the array of coordinates is not very readable, so until we have
    a better way of printing out flights, we would like to simply display the number
    of flights in the booking. Surely, we could test `flight1`, `flight2`, and `flight3`
    for the presence of a value but there''s another aspect of destructuring that
    we could use: the "remaining" parts of the sequence. By using the `&` character
    followed by a symbol, we can bind the remaining part of a sequence to a given
    symbol.'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Bind the `flights` sequence to a `flights` symbol by using the `&` character,
    then display the number of flights as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that `flights` is now a collection and, therefore, we can use the `count`
    function with it.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Destructuring is very powerful and can also disassemble nested data structures.
    To parse and print the flight details, let's create a separate function to keep
    the code clear and readable.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `print-flight` function that disassembles a flight path using nested
    destructuring and print out a nicely formatted flight itinerary:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice how we dug into the nested vectors contained in `flight` to retrieve
    the coordinate values inside the coordinate tuples, by simply using nested vector
    literal notation. However, the nested vectors in the `let` bindings can be slightly
    hard to read.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rewrite the `print-flight` function by decomposing the steps in multiple `let`
    bindings:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding example, we have created two intermediate bindings using sequential
    destructuring: `departure` and `arrival`. Those two bindings contain coordinates
    tuples that we can destructure further to create the latitude and longitude bindings
    `lat1`, `lon1`, `lat2`, and `lon2`.'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, let''s write the `print-booking` function by combining the code we
    have written so far:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Great job! In this exercise, we've successfully used *sequential destructuring*
    to parse and retrieve data from a vector and improve the readability and conciseness
    of our code. Now, let's move on to the next exercise, where we will use *associative
    destructuring*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.02: Parsing MapJet Data with Associative Destructuring'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's continue with our flight booking platform application. Now we would like
    to develop the same parser for another partner called MapJet. You might have guessed,
    MapJet has discovered the power of associative data structures and are sending
    us nice and intelligible data structures, which consist of both maps and vectors.
    Now, the data is self-explanatory and even if MapJet provides very detailed documentation,
    we won't even bother reading it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the data shape of a sample booking:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'First, let''s agree on the fact that maps are a great way to exchange data.
    They are very readable for us humans, and simple to parse for our programs. Now,
    let''s get back to the REPL and see how associative destructuring can help us
    manipulate the data:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Bind the sample booking map to the `mapjet-booking` symbol as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using associative destructuring, print the booking summary as we did for Fly
    Vector (the name of the customer and the number of flights):'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By using the shorter and non-repetitive syntax with `:keys`, we were able to
    fetch the keys inside the map and bind their values to symbols with the same name.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s write a `print-mapjet-flight` function to print the flight details:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that we cannot use the shorter syntax for extracting coordinates because
    the names `lat` and `lon` would conflict; therefore, we used the normal syntax,
    allowing us to explicitly declare a new binding to symbols with different names.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As with vectors, we can nest destructuring expressions, and even combine the
    two techniques.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s rewrite the `print-mapjet-flight` function, but this time we are going
    to nest our associative destructuring expressions:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding example is slightly complicated to read so don''t worry if it
    looks a bit confusing at first. Think of the key of a destructuring map as the
    target, and the source as the value, as follows: `{target1 source1 target2 source2}`.
    The target can either be a symbol, or another destructuring map like this: `{{target3
    source3} source1 {target4 source4} source2}`. Notice, in this last expression,
    how we just bind values to the symbols in the innermost map (`target3` and `target4`).
    This is what we just did in the `print-mapjet-flight` function: we extracted the
    nested values of latitude and longitude for both coordinate points.'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the final function for printing MapJet bookings, using the code to print
    the booking summary to the console. It should produce a similar output to Fly
    Vector''s `print-booking` function, first printing the number of flights and then
    printing each flight individually with `print-mapjet-flight` as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It works! We have now finished our first prototype. In this exercise, we have
    implemented a `Map` parser that prints out data that has been destructured to
    the console. Well done!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring techniques are essential because they can make our code more concise
    and more readable. Additionally, the data that our programs have to deal with
    often comes from external data sources, and we don't always own the shape of the
    data we need to handle. Having a powerful tool to dig into various data structures
    significantly improves our quality of life as programmers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: However, the code we have written in the previous exercise feels somehow repetitive;
    the two `print-booking` functions, for example, have a lot in common. With what
    we currently know, it would be difficult to refactor this code. But don't worry,
    the techniques we are going to learn in the next topics will allow you to write
    even more elegant code, with less repetition, less code, and therefore fewer bugs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Call Signatures
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been declaring functions with one arity (with only a fixed number
    of arguments), and simply binding the arguments passed to a function to some parameter
    names. However, Clojure has a few techniques to allow more flexibility when calling
    functions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用单一arity（只有固定数量的参数）声明函数，并且简单地将传递给函数的参数绑定到一些参数名上。然而，Clojure有一些技术可以在调用函数时提供更多的灵活性。
- en: Destructuring Function Parameters
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Destructuring Function Parameters
- en: 'First, everything we have just learned about destructuring applies to function
    parameters. Yes, you read that correctly – we can use destructuring techniques
    right in the function parameter declaration! As promised, here''s our first stab
    at refactoring the `print-flight` functions from the previous exercise. Observe,
    in the following example, how sequential destructuring is used directly in the
    function parameters:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们刚刚学到的关于解构的知识也适用于函数参数。是的，你读得对——我们可以在函数参数声明中使用解构技术！正如承诺的那样，以下是我们对之前练习中的`print-flight`函数进行重构的第一个尝试。观察以下示例，看看顺序解构是如何直接在函数参数中使用的：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Notice how we got rid of the `let` expression. Similarly, we can do the same
    for `print-mapjet-flight`, with associative destructuring used in the function
    parameters:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何移除了`let`表达式的。同样地，我们也可以对`print-mapjet-flight`做同样的处理，在函数参数中使用关联解构：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once again, we got rid of the `let` expression and destructured the parameter
    right away from the function arguments. Great – that is one new way of defining
    function parameters and improving our code even further.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们移除了`let`表达式，并立即从函数参数中解构参数。太好了——这是定义函数参数和进一步改进我们代码的一种新方法。
- en: Arity Overloading
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arity Overloading
- en: 'Second, Clojure supports "arity overloading," which means that we can *overload*
    a function with another function of the same name by specifying extra parameters
    to the new function. Those two functions have the same name but different implementations,
    and the function body to execute is chosen based on the number of arguments provided
    upon a function call. Here is an example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，Clojure支持“arity overloading”，这意味着我们可以通过指定新函数的额外参数来用另一个具有相同名称的函数来*overload*该函数。这两个函数具有相同的名称但不同的实现，执行函数体是根据函数调用提供的参数数量来选择的。以下是一个示例：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice how the different function implementations are defined. In the `no-overloading`
    function, which is how we are used to creating functions, there are no extra parentheses
    around the parameter declaration (which comes just after the function name). Whereas
    in the `overloading` function, each implementation is surrounded by parentheses,
    starting with the parameter declaration.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不同的函数实现是如何定义的。在`no-overloading`函数中，这是我们习惯创建函数的方式，参数声明（紧随函数名之后）周围没有额外的括号。而`overloading`函数中，每个实现都由括号包围，从参数声明开始。
- en: 'Let''s see how the multi-arity `overloading` function plays out:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看多arity的`overloading`函数是如何发挥作用的：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, no arguments were passed; therefore, the first implementation
    of the `overloading` function is called.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，没有传递任何参数；因此，调用`overloading`函数的第一个实现。
- en: 'Consider the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this case, one argument is passed to the `overloading` function, so the second
    implementation is called.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个参数被传递给`overloading`函数，因此调用第二个实现。
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, two arguments are passed, so the third implementation
    of the `overloading` function is called.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，传递了两个参数，因此调用`overloading`函数的第三个实现。
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finally, an incorrect number of arguments produce the usual arity exception.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，传递错误数量的参数会产生通常的arity异常。
- en: You might (legitimately) wonder how this is useful, and why not just declare
    different functions? In fact, when defining multiple arities for the same function,
    you are saying that the functions are essentially the same, that they are doing
    a similar job, but the execution slightly varies based on the number of arguments.
    It can also be useful to provide default values.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会（合理地）想知道这有什么用，为什么不直接声明不同的函数呢？实际上，当为同一函数定义多个arity时，你是在说这些函数本质上相同，它们在做相似的工作，但执行略有不同，这取决于参数的数量。提供默认值也可能很有用。
- en: 'Consider the following code for a new little fantasy game called `strike` function
    to compute the new state of an `enemy` entity:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，这是一个名为`strike`的新小型幻想游戏函数，用于计算`enemy`实体的新状态：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding example, we start by defining a `HashMap` and binding it to
    the `weapon-damage` symbol. The second expression is the definition of the `strike`
    function, which subtracts damage from an `enemy` entity, retrieving the amount
    of damage in the `weapon-damage` map. Observe that the `strike` function has two
    implementations. The first implementation contains only one parameter, `enemy`,
    and the second implementation has two parameters: `enemy` and `weapon`. Notice
    how the first implementation is calling the second one by providing an extra parameter.
    Therefore, when calling the `strike` function with only one argument, the default
    value, `:fists`, will be provided:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Observe that the function was called with one parameter only (the `enemy` entity),
    which therefore went through the one-parameter implementation of the function,
    using `:fists` as a default value and returning an enemy with 90 points of health
    left (because fists do 10 points worth of damage):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding example, the `strike` function was called directly with the
    two-arity implementation, because the second parameter, `weapon`, was explicitly
    provided.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Variadic Functions
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a final secret left to reveal regarding function parameters. With what
    we have learned about function arity, how would you define the parameters of the
    `str` function, for example?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'It seems to take an infinite number of parameters. You might remember using
    `str` like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: But surely, it isn't implemented with overloading like this `(defn str ([s]
    ...) ([s1 s2] ...) ([s1 s2 s3] ...) ([s1 s2 s3 s4] …))` and so on… Then, what
    is happening in this case?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: This is the destructuring technique coming back into play. Remember that we
    can use the `&` character to bind the remainder of a sequence to a data structure?
    It works similarly with function arguments, and we can create a data structure
    from the arguments passed to a function with the `&` character. This is how you
    can create variadic functions (functions that take a variable number of arguments),
    and this is how the `str` function is implemented.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at how the documentation describes the `str` function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice the declaration of its different arities. It accepts either no element,
    `[]`, one element, `[x]`, or any number of elements, `[x & ys]`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to use this new knowledge to create a function that prints a welcome
    message to the new player of `Parenthmazes`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Observe how we used the destructuring technique right in the function parameters,
    binding any arguments that come after `player` to the `friends` collection. Now,
    let''s try to use our function with one and multiple arguments:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice that when more than one argument is passed to the `welcome` function,
    the `friends` symbol is bound to a sequence containing the rest of the arguments.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The `seq` function can be used to get a sequence from a collection. In the `welcome`
    function, we use the `seq` function to test whether a collection contains elements.
    That's because `seq` returns `nil` when the collection passed as a parameter is
    empty. `(if (seq (coll))` is a commonly used pattern that you should use instead
    of `(if (not (empty? coll)))`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`seq`函数可以用来从集合中获取序列。在`welcome`函数中，我们使用`seq`函数来测试集合是否包含元素。这是因为`seq`在作为参数传递的集合为空时返回`nil`。`(if
    (seq (coll)))`是一个常用的模式，你应该用它来代替`(if (not (empty? coll)))`。'
- en: 'We could improve this function slightly. Instead of testing whether `friends`
    is empty, we could also take advantage of the multi-arity technique:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍微改进这个函数。我们不仅可以测试`friends`是否为空，还可以利用多重参数技术：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice how, this time, two `welcome` functions were defined, one with only one
    `player` parameter, and a second one with an unlimited number of parameters that
    will be bound to the `friends` symbol. Separating the functions like this improves
    the clarity of the code by being more explicit about the intent of the function
    as well as removing the conditional expression with `when`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次，定义了两个`welcome`函数，一个只有一个`player`参数，另一个有无限数量的参数，这些参数将被绑定到`friends`符号。以这种方式分离函数可以提高代码的清晰度，更明确地表达函数的意图，并移除带有`when`的条件表达式。
- en: 'Let''s try the `welcome` function one last time:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们最后一次尝试`welcome`函数：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Great – the function call was dispatched to the right function according to
    the number of parameters.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——根据参数的数量，函数调用被调度到了正确的函数。
- en: 'Exercise 3.03: Multi-arity and Destructuring with Parenthmazes'
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.03：使用括号迷宫的多重参数和结构化
- en: In this exercise, we will continue working on the `Parenthmazes` game by adding
    new features, notably improving our `strike` function to implement a healing mechanism.
    We would also like to add the concept of armor, which can reduce the damage suffered.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将继续通过添加新功能来完善`Parenthmazes`游戏，特别是改进我们的`strike`函数以实现治疗机制。我们还想添加护甲的概念，它可以减少受到的伤害。
- en: Get ready for the great battle between Gnomes and Trolls in this new version
    of `Parenthmazes`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 准备在这个`Parenthmazes`新版本中，迎接侏儒和巨魔之间伟大战斗的到来。
- en: 'To begin, start a REPL and your favorite code editor next to it, and create
    the `weapon-damage` map, which contains damage information for each weapon:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，启动REPL和旁边的你最喜欢的代码编辑器，创建`weapon-damage`映射，其中包含每种武器的伤害信息：
- en: '[PRE40]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We need this map to look up the amount of damage done when a player strikes
    an enemy.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要这个映射来查找玩家打击敌人时所造成的伤害量。
- en: 'Now, let''s create the `strike` function, which will handle healing when the
    enemy is in the same camp as us (let''s assume for now that we picked the Gnomes''
    side):'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建`strike`函数，该函数将处理当敌人与我们处于同一阵营时（现在我们假设我们选择了侏儒阵营）的治疗：
- en: '[PRE41]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding function, the new code of the `strike` function is to retrieve
    which side the target is on by looking up the `:camp` key in the `target` entity.
    If the `target` belongs to the Gnomes camp, we use the `+` function to increase
    the health in the `target` entity by x number of `points`. Otherwise, we use `-`
    to decrease the number of health points in the `target` entity.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的函数中，`strike`函数的新代码是通过查找`target`实体的`:camp`键来检索目标所在的阵营。如果`target`属于侏儒阵营，我们使用`+`函数在`target`实体中增加x个`points`的健康值。否则，我们使用`-`来减少`target`实体中的健康点数。
- en: 'Create an `enemy` entity and test our newly created `strike` function as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`enemy`实体，并按照以下方式测试我们新创建的`strike`函数：
- en: '[PRE42]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Health points were subtracted successfully. Let's see what happens with a friendly
    player.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 健康点数已成功扣除。让我们看看友军玩家会发生什么。
- en: 'Create an `ally` entity that belongs to the `:gnomes` camp, and test our newly
    created `strike` function as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个属于`:gnomes`阵营的`ally`实体，并按照以下方式测试我们新创建的`strike`函数：
- en: '[PRE43]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Health points were added successfully!
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 健康点数已成功添加！
- en: Now that we have got the shell of our `strike` function, let's amend it to implement
    the armor functionality. The `target` entity can contain an `:armor` key, which
    contains a coefficient used to calculate the final amount of damage. The bigger
    the number, the better the armor. For example, an armor value of 0.8 for a strike
    of 100 points results in 20 damage points being inflicted. An armor value of 0.1
    results in 90 damage points being inflicted, 0 means no armor, and 1 means invincible.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the amount of damage inflicted on the target by calculating the damage
    with the `:armor` value in the `target` entity. If the target has no armor value,
    set it to `0`. To improve readability, we will use a `let` binding to decompose
    the damage calculation:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the second branching of the `if` expression, we used a `let` expression to
    assign a default value to `armor` by using `or`. If `(:armor target)` is nil,
    the value of armor is 0\. The second binding contains the reduced damage based
    on the armor value.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test the `strike` function to see if it still works with no armor:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: A cast-iron saucepan does 150 damage, and 250 minus 150 is indeed `100`. Great
    – it works. Let's move on.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Redefine the `enemy` binding to add an armor value and test our `strike` function
    once again:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Great – the damage seems to be reduced according to the armor coefficient. Now
    we would like to use our associative destructuring technique to retrieve the `camp`
    and `armor` values directly from the function parameters, and reduce the amount
    of code in the function's body. The only problem we have is that we still need
    to return an updated version of the `target` entity, but how could we both destructure
    the `target` entity and keep a reference of the `target` parameter? Clojure has
    your back – you can use the special key `:as` to bind the destructured map to
    a specific name.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the `strike` function to use associative destructuring in the function''s
    parameters. Use the special key `:as` to bind the map passed as an argument to
    the symbol target:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'There is one other useful feature in associative destructuring that we could
    take advantage of: the special key `:or`. It permits us to provide a default value
    for when a key that we want to extract isn''t found (instead of binding to `nil`).'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the special key `:or` in the destructured map to provide a default value
    to the armor key in the target map, add an extra arity to make the `weapon` parameter
    optional, and finally add some documentation, as follows. Don''t forget to wrap
    each function definition with its own set of parentheses:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Ensure that your function still works as expected by testing the different
    scenarios as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: That concludes this exercise. If you look again at the `strike` function you've
    just written, it is using some advanced Clojure features, including destructuring,
    multi-arity functions, and reading and updating maps. By passing a function as
    an argument in the `update` function, we also used the concept of higher-order
    functions, which we will explain further in the next section.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Higher-Order Programming
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Higher-order programming means that programs, and specifically functions, can
    operate on other programs or functions, as opposed to first-order programming,
    where functions operate on data elements such as strings, numbers, and data structures.
    In practice, it means that a function can take some programming logic as a parameter
    (another function) and/or return some programming logic to be eventually executed.
    It is a powerful feature that allows us to compose single, modular units of logic
    in our programs to reduce duplication and promote the reusability of code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Writing simpler functions increases their modularity. We want to create simple
    units of functionality that can be used as small bricks to build our programs
    with. Writing pure functions reduces the complexity of those bricks, and allows
    us to craft better, sturdier programs. Pure functions are functions that don't
    alter the state of our program – they produce no side effects; a pure function
    also always returns the same value when given the exact same parameters. This
    combination makes pure functions easy to reason about, build upon, and test. Although
    Clojure offers ways to modify the state of our program, we should write and use
    pure functions as much as possible.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: First-Class Functions
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s demonstrate the use of functions as parameters. We used functions as
    parameters in *Exercise 2.01*, *The Obfuscation Machine* of *Chapter 2*, *Data
    Types and Immutability*, with the `clojure.string/replace` function, and also
    in the preceding exercise, with the `update` function. For example, to divide
    a value by `2` in a `HashMap`, you can pass an anonymous function that does the
    division as an argument to the `update` function:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Even better, you could simply pass the divide function, `/`, with the argument
    `2`, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Notice that `update` will pass the old value as the first argument to the `/`
    function (here, the old value is `1.0`) as well as all the extra arguments (here,
    `2`).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'You can operate on any kind of value. For example, to invert the value of a
    Boolean, use the `not` function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As we''ve just seen, `update` can take a function as a parameter, but we could
    also define our own function that takes a function and applies it to a given parameter:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the preceding example, `operate` takes a function, `f`, as a parameter and
    calls it with the second parameter, `x`. Not very useful, but it shows how simple
    it is to pass and call a function passed as a parameter. If we wanted to pass
    any number of arguments, we could use the `&` character as we learned in the previous
    topic about destructuring:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This time, `operate` seems to accept any number of arguments, but the function
    call fails because `args` is a sequence. That''s because we applied the `f` function
    to the `args` sequence directly, when what we really wanted was to apply `f` using
    each element of the sequence as an argument. There is a special function to disassemble
    a sequence and apply a function to that sequence''s elements – the `apply` function:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Notice how `+` does not work on a vector, but by using apply, we call `+`, passing
    each element of the vector as an argument to `+`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, therefore, use `apply` in our `operate` function to have a fully working
    function that takes a function, `f`, as a parameter and calls `f` with the rest
    of the parameters, `args`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It works! The `str` function was applied to the arguments passed to `str`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability to pass a function as a parameter is one aspect of higher-order
    functions, but another aspect is the ability of functions to *return* other functions.
    Consider the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `shuffle` function shuffles an array by sorting its elements randomly,
    and we then take the first element out of it. In other words, the `random-fn`
    function returns a random function from the `[+ - * /]` collection. Notice that
    the `random-fn` function does not take any parameters:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'But the function returned by `random-fn` expects parameters:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the preceding code, `(random-fn)` returned `-` so `3` was subtracted from
    `2`, which results in `-1`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `fn?` function to check whether a value passed as a parameter
    is a function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In this case, observe that both `random-fn` and the value returned by `random-fn`
    are functions. So, we can call the function returned by `random-fn`, and even
    bind it to a symbol, as in the example that follows, where we bind the function
    to the `mysterious-fn` symbol:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Notice how every call to `random-fn` returned a different function. On each
    step, calling `mysterious-fn` with the same arguments is processed by a different
    function. Based on the returned values, we can guess that the functions are respectively
    `*`, `/`, `*`, and `+`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: It is conceivable but not very common to write functions that return other functions.
    However, you will often use some of Clojure's core utility functions, which return
    other functions, and which we are going to present next. Those are worth exploring
    because they enable functional composition, reusability, and conciseness.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Partial Functions
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first of those core utility functions is `partial`, which takes a function,
    `f`, as a parameter and any number of arguments, `args1`. It returns a new function,
    `g`, that can take extra arguments, `args2`. When calling `g` with `args2`, `f`
    is called with `args1` + `args2`. It may sound complicated, but consider the following
    example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Calling `(partial + 0.99)` returns a new function that we bind to the `marketing-adder`
    symbol. When `marketing-adder` is called, it will call `+` with `0.99` and any
    extra arguments passed to the function. Notice that we used `def` and not `defn`,
    because we don't need to build a new function – `partial` does it for us.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Calling `format-price` will call the `str` function with the first parameter,
    `"€"`, and then the rest of the parameters. Of course, you could write the same
    function like this: `(fn [x] (str "€" x))`, but using `partial` is a nice and
    expressive way of defining functions as functions of other functions.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Composing Functions
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another core utility function is `comp`, short for compose. Take, for example,
    our `random-fn` function. To retrieve a random number from the collection, we
    call the `shuffle` function and then the `first` function. If we wanted to implement
    a `sample` function that does exactly that, we could write the following function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'But more elegantly, we could implement the `sample` function with the functional
    composition utility, `comp`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`comp` is a utility that takes any number of functions as a parameter and returns
    a new function that calls those functions in order, passing the result of each
    to the other. Observe that the functions are composed from right to left, so in
    the preceding example, `shuffle` will be applied before `first`. This is important
    because the number and types of arguments passed to the chain of functions is
    often meaningful. For example, if you wanted to compose a function that multiplies
    numbers and increments the result by one, you would need to pass the `inc` function
    (increment) as a first argument of the function as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Notice that when providing `inc` as the last argument of the `comp` function,
    it calls `(inc 2 2)`, which does not work because `inc` takes only one argument.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how we can combine the use of `partial` and `comp` to compose
    a `checkout` function with the `format-price` and `marketing-adder` functions
    that we defined previously. The `checkout` function will first add its parameters
    by reusing `marketing-adder`, then format the price with `format-price` and return
    the string concatenated with `"Only"` in front of it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In the preceding example, we defined a `checkout` function as a composition
    of `marketing-adder`, `format-price`, and an anonymous function returned by `partial`
    to add the text `"Only"` before the price. This example shows the outstanding
    dynamism and expressivity of composing related functions in Clojure. The programmer's
    intent is clear and concise, skipping the technicality of defining functions and
    naming parameters.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we jump into the exercise, let''s present a new way of writing anonymous
    functions: the `#()` literal. `#()` is a shorter way of writing an anonymous function.
    Parameters are not named and therefore parameter values can be accessed in order
    with `%1`, `%2`, `%3`, and so on. When only one argument is provided, you can
    simply use `%` (omitting the argument number) to retrieve the value of the argument.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the two following expressions are equivalent:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'And the two following expressions are equivalent as well:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`#()` literal functions are just functions, called in the same way as other
    functions:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Observe that when more than one argument is provided, we need to use the `%1`
    and `%2` to refer to the values passed as a parameter.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The short literal notation of the `#()` function is convenient but should be
    used sparingly because numbered parameters can be hard to read. The rule of thumb
    is to use only short anonymous functions with a single argument and a single function
    call. For anything else, you should stick with the standard `fn` notation with
    named parameters to improve readability.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Let's put these new techniques into practice in an exercise with `Parenthmazes`
    version 3.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.04: High-Order Functions with Parenthmazes'
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will demonstrate the benefit of functions being first-class
    citizens. We will use functions as values and compose them together.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: We would like to improve our fantasy game, Parenthmazes, even more, this time
    by changing weapons' mechanics to allow each weapon to have different behavior.
    For example, we would like "fists" to inflict damage only if an enemy is weak
    or has been weakened. Instead of implementing conditional branches in our `strike`
    function, we are going to implement a *dispatch table* using the `weapon-damage`
    `HashMap`, which we are going to rename `weapon-fn-map`, because this time each
    weapon will have an associated function (rather than a numeric value). A dispatch
    table is a table of pointers to functions. We can implement it with a `HashMap`
    where the pointers are keys and the functions are values.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow our weapon functions to compose nicely, they will take a numeric value
    for health as a parameter and return a numeric value for health after the damage
    has been deducted. For the sake of simplicity, we will leave out the concept of
    armor this time. Let''s start with the `fist` weapon:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a REPL next to your favorite code editor. Create a new `HashMap` with
    a `:fists` key and its associated function, which inflicts `10` damage only if
    the health of the enemy is less than `100`, and otherwise returns the `health`
    parameter. Bind the newly created function to the `weapon-fn-map` symbol as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: A `HashMap` can have any type of value as a key or parameter, so a function
    as a value is perfectly fine.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Try the function by retrieving it from `weapon-fn-map` and call it with `150`
    and then `50` as a parameter:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Observe that the function returned the new health correctly. It subtracted `10`
    when the `health` parameter was less than `100`.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now to the `staff` weapon. The `staff` is the only weapon that can be used
    to heal (`35` health points), so the associated function should simply call `+`
    instead of `-`. It seems like a good opportunity to generate this function using
    `partial`:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The value at the `:staff` key is now a function that will call `+` with `35`
    and any extra argument supplied.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Try the function associated with `staff`, as follows:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: For the `sword` weapon, we need to simply subtract `100` points from the health
    points passed as an argument. However, `partial` won't work because the parameters
    would not be in the correct order. For example, `((partial - 100) 150)` returns
    `-50`, because the function call is equivalent to `(- 100 150)`, but we need `(-
    150 100)`.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an anonymous function subtracting `100` from its argument and associate
    it with the `sword` key, as follows:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Notice that we used `%` to retrieve the argument passed to the anonymous function,
    because we used the short literal syntax, `#()`, expecting only one argument.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test your newly created weapon function as follows:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: It works!
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next weapon to add is `cast-iron-saucepan`. To spice things up, let's add
    a bit of randomness to the mix (a saucepan is not a very accurate weapon anyway).
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `cast-iron-saucepan` function to the `HashMap` that subtracts `100`
    health points and a random number between `0` and `50` from the health points,
    as follows:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In the preceding example, we used the `rand-int` function, which generates a
    random integer between `0` and the supplied argument.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test the newly created function as follows:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Two subsequent calls might return a different value because of the `rand-int`
    function.
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we would like to introduce a new weapon (for the unfortunate adventurers)
    that doesn''t do any damage: the sweet potato. For that purpose, we need a function
    that returns its argument (the health). We don''t need to implement it as it already
    exists: `identity`. First, let''s check out the source code of the function identity
    with the `source` function:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Observe how `identity` simply returns its argument. The `source` function is
    another handy tool to use interactively in the REPL, as it prints out a function
    definition to the console, which is sometimes more helpful than a function's documentation.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s redefine our `weapon-fn-map` `HashMap` one last time by associating
    the function identity with the `:sweet-potato` key, as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Now that we have our `weapon-fn-map` finalized, we should modify our `strike`
    function to handle the weapon functions stored as values in our `HashMap`. Remember
    that the `strike` function takes a `target` entity as a parameter and returns
    this entity with a new value for the health key. Therefore, updating the entity's
    health should be as simple as passing a `weapon` function to the `update` function,
    because our `weapon` functions take the health as a parameter and return the new
    health value.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rewrite the `strike` function from the previous exercise to use the weapon
    functions stored in the `weapon-fn-map`, as follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now test your `strike` function by passing various weapons as a parameter.
    For convenience, you might want to create an `enemy` entity as well:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'If we wanted to strike with more than one weapon at a time, instead of nesting
    a strike call like this:'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We could simply compose our weapon functions and just use the core update function.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write an `update` expression to strike with two weapons at a time using `comp`,
    as follows:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Because the weapon functions that we wrote have a consistent interface (taking
    `health` as a parameter and returning the health), it is straightforward to compose
    them with `comp`. To finish this exercise, let's create a `mighty-strike` function
    that strikes with all of the weapons at once, also known as composing all the
    weapon functions. The `keys` and `vals` functions can be used on `HashMaps` to
    retrieve a collection of the map's keys or values. To retrieve all the weapon
    functions, we can simply retrieve all the values from `weapon-fn-map` using the
    `vals` function. Now that we have a collection of functions, how do we compose
    them? We need to pass each function of the collection to the `comp` function.
    Remember, to pass each element of a collection as a parameter of a function, we
    can use `apply`.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write a new function named `mighty-strike`, which takes a `target` entity as
    a parameter and uses all of the weapons on it. It should apply the `comp` function
    to the values of `weapon-fn-map` as follows:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now, if we pause to reflect on the `mighty-strike` function and think about
    how we would have to implement that without higher-order functions, we'll realize
    how simple and powerful the concept of functional composition is.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've learned how to use functions as simple values and as
    parameters or return values of other functions, as well as creating shorter anonymous
    functions with `#()`. We also explained how to use `partial`, `comp`, and `apply`
    to generate, compose, and discover new ways of using functions.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Multimethods
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clojure offers a way to implement polymorphism with multimethods. Polymorphism
    is the ability of a unit of code (in our case, functions) to behave differently
    in different contexts, for example, based on the shape of the data received by
    the code. In Clojure, we also call it *runtime polymorphism* because the method
    to call is determined at runtime rather than at compile time. A multimethod is
    a combination of a dispatch function and of one or more methods. The two main
    operators for creating those multimethods are `defmulti` and `defmethod`. `defmulti`
    declares a multimethod and defines how the method is chosen with the dispatch
    function. `defmethod` creates the different implementations that will be chosen
    by the dispatch function. The dispatch function receives the arguments of the
    function call and returns a dispatch value. This dispatch value is used to determine
    which function, defined with `defmethod`, to invoke. Those are a lot of new terms
    but don't worry, the following examples will help you understand the new concepts.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we could implement Parenthmazes'' `strike` function with multimethods.
    This time, the weapon is in the `HashMap` passed as a parameter:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In the preceding code, we''ve created a multimethod called `strike`. The second
    argument is the dispatch function, which simply retrieves a weapon in a map passed
    as a parameter. Remember that keywords can be used as functions of a `HashMap`,
    so we can simply write `defmulti` as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Notice that, this time, the expression returned `nil`. This is because the
    multimethod was already defined. In that case, we need to `unmap` the `strike`
    var from the `user` namespace and re-evaluate the same expression again:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now that we have our multimethod and our dispatch function defined (which is
    simply the `:weapon` keyword), let''s create our `strike` functions for a couple
    of weapons, to demonstrate the usage of `defmethod`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Observe how we called `defmethod` with the function named `strike`, the second
    argument to `defmethod` is the dispatch value: `:sword`. When `strike` is called
    with a map containing a weapon key, the weapon value is retrieved from the arguments
    and then returned by the dispatch function (the `:weapon` keyword). Similarly,
    let''s create another strike implementation for the `:cast-iron-saucepan` dispatch
    value:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This time, `strike` is called with a map containing `:cast-iron-saucepan` at
    the `:weapon` key. The function defined previously will be invoked. Let''s test
    our newly created multimethod with the two different weapons:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Notice how calling `strike` with different arguments lets us invoke two different
    functions.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'When the dispatch value doesn''t map to any registered function, an exception
    is thrown:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If we need to handle that case, we can add a method with the `:default` dispatch
    value:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'In this case, we decided to handle any other weapon by simply returning the
    unmodified health value, inflicting no damage:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Notice that, this time, no exception was thrown, and the original health value
    was returned. The dispatch function can be more elaborate. We could imagine a
    special behavior when the enemy''s health is below 50 points and instantly eliminate
    it, no matter what weapon was used:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The preceding code first unmaps `strike` from the `user` namespace so that it
    can be redefined. We then redefine the dispatching function by looking in the
    parameter and dispatching to a `:finisher` function if the health of the enemy
    is below `50`. We then define the `:finisher` function (the `strike` function
    with the dispatch value finisher) to return, simply ignore its arguments, and
    return `0`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we''ve unmapped `strike`, we must add `defmethods` as they would have
    been removed too. Let''s re-add a sword and the default method:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now let''s see our multimethod in action:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Great – our function still works as expected. Now let''s see what happens when
    the health is below `50`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The `finisher` function has been called and the strike multimethod successfully
    returned `0`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Multimethods can do a few more things, such as dispatching on multiple values
    (using a vector as the dispatch value) or dispatching on types and hierarchies.
    This is useful but maybe a bit much to take on for now. Let's move on to the exercise
    and practice using multimethods by dispatching on values.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.05: Using Multimethods'
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we want to extend our little game, Parenthmazes, with the
    ability to move a player. The game board is a simple two-dimensional space with
    the coordinates x and y. We will not implement any rendering or maintain any state
    of the game at this point as we simply want to practice the use of multimethods,
    so you will have to use your imagination.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Players'' entities are now given an extra key, `:position`, which contains
    a `HashMap` with the coordinates at key x and y as well as the `:facing` key,
    which contains the direction in which the player is facing. The following code
    is an example of a player entity:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Moving north or south should change the y coordinate, and moving east and west
    should change the x coordinate. We will implement this with a new `move` function.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start a REPL and create the player entity as follows:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Create the `move` multimethod. The dispatch function should determine the dispatch
    value by retrieving the `:facing` value in the `:position` map of a player entity.
    The `:facing` value could be one of the following values `:north`, `:south`, `:west`,
    and `:east`:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: You might have noticed that the two successive keyword function calls could
    be more elegantly expressed with functional composition.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Redefine the `move` multimethod by first unmapping the var from the `user`
    namespace and then using `comp` to simplify its definition:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Create the first implementation of the `move` function with the `:north` dispatch
    value. It should increment `:y` in the `:position` map:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Try your newly created function by calling `move` with the `player` entity
    and observe the result:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Observe that the value at `y` successfully increased by 1.
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the other functions for the rest of the dispatch values `:south`, `:west`,
    and `:east`:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Test your newly created functions by providing `player` entities facing different
    directions:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Observe how the coordinates changed correctly when moving the players in different
    directions.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an extra function for when the value at `:facing` is different from
    `:north`, `:south`, `:west`, and `:east`, using the `:default` dispatch value:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Try your function and make sure it handles unexpected values by returning the
    original entity map:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Observe that the multimethod was dispatched to the default function, and that
    the position remained unchanged when the player was facing a `:wall`.
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this section, we've learned how to use Clojure's polymorphism feature with
    multimethods.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3.01: Building a Distance and Cost Calculator'
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go back to the flight-booking platform application that we worked on
    in *Exercise 3.01*, *Parsing Fly Vector''s Data with Sequential Destructuring*,
    and *Exercise 3.02*, *Parsing MapJet Data with Associative Destructuring*. In
    the time it took you to arrive at the end of this chapter, we have now developed
    the company into a proper start-up called WingIt, with serious investors, a weekly
    board meeting, and a ping pong table, which means that we now need to build the
    core services of the app: the itinerary and cost calculations between two locations.
    However, after looking into routing airways, airport fees, and complicated fuel
    calculations, we''ve come to realize that the algorithms that we need to develop
    might be too complicated for us at this stage. We''ve decided that for our **Minimal
    Viable Product** (**MVP**), we are just going to "wing it" and offer simpler modes
    of transportation such as driving and even walking. However, we want to keep the
    code easily extensible, because we''ll eventually need to add flying (some employees
    even overheard the CEO talking about adding space flights to the roadmap soon!).'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirement of the WingIt MVP are as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: For the prototype, we will interact with a Clojure REPL. The interface is an
    itinerary function taking a `HashMap` as a parameter. For now, the users will
    have to enter coordinates. It might not be very user-friendly but the user can
    look up coordinates on their own globe or map!
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The itinerary function returns a `HashMap` with the keys, `:distance`, `:cost`,
    and `:duration`. `:distance` is expressed in kilometers, `:cost` in euros, and
    `:duration` in hours.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only parameter to the itinerary function is a `HashMap` containing `:from`,
    `:to`, `:transport`, and `:vehicle`. `:from` and `:to` contain a `HashMap` with
    the `:lat` and `:lon` keys, representing the latitude and longitude of a location
    on our planet.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:transport` can be either `:walking` or `:driving`.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:vehicle` is only useful when `:transport` is `:driving`, and can be one of
    `:sporche`, `:sleta`, or `:tayato`.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To compute the distance**, we are going to use the "Euclidian distance,"
    which is normally used to calculate the distance between two points on a plan.
    For flying, we would have to use at least the haversine formula, and technically,
    for driving, we would need to use routes, but we just want rough estimates on
    relatively short distances, so the much simpler Euclidian distance should be enough
    for now. The only complicated bit in this calculation is that the length of a
    degree of longitude depends on the latitude, so we''ll need to multiply the longitude
    by the cosine of the latitude. The final equation to compute the distance between
    two points (lat1, lon1) and (lat2, lon2) looks like this:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: Calculating the Euclidean distance'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_03_01.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.1: Calculating the Euclidean distance'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '`:driving`, we will look at the `:vehicle` chosen by the user in the `HashMap`
    parameter. The cost of each vehicle should be a function of the distance:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '`:sporche` consumes, on average, 0.12 liters of petrol per kilometer, costing
    €1.5 per liter.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:tayato` consumes, on average, 0.07 liters of petrol per kilometer, costing
    €1.5 per liter.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:sleta` consumes, on average, 0.2 kilowatt hour (kwh) of electricity per kilometer,
    costing €0.1 per kwh.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cost should be 0 when transport is `:walking`.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To compute the duration**, we consider an average driving speed of 70 km
    per hour, and an average walking speed of 5 km per hour.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a couple of examples of calls to the itinerary function, and the expected
    output:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'These steps will help you complete this activity:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Start by defining the `walking-speed` and `driving-speed` constants.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two other constants representing two locations with the coordinates,
    `:lat` and `:lon`. You can use the previous example with Paris and Bordeaux or
    look up your own. You will be using them to test your distance and itinerary functions.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `distance` function. It should take two parameters representing the
    two locations for which we need to calculate the distance. You can use a combination
    of sequential and associative destructuring right in the function parameters to
    disassemble the latitude and longitude from both locations. You can decompose
    the steps of the calculation in a `let` expression and use the `Math/cos` function
    to calculate the cosine of a number and `Math/sqrt` to calculate the square root
    of a number; for example, `(Math/cos 0)`, `(Math/sqrt 9)`.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a *multimethod* called `itinerary`. It will offer the flexibility of
    adding more types of transport in the future. It should use the value at `:transport`
    as a *dispatch value*.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the itinerary function for the `:walking` dispatch value. You can use
    associative destructuring in the function parameters to retrieve the `:from` and
    `:to` keys from the `HashMap` parameter. You can use a `let` expression to decompose
    the calculations of the distance and duration. The distance should simply use
    the `distance` function you created before. To calculate the duration, you should
    use the `walking-speed` constant that you defined in *Step 1*.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the `:driving` itinerary function, you could use a dispatch table that contains
    the vehicle associated with the costing function. Create a `vehicle-cost-fns`
    dispatch table. It should be a `HashMap` with the keys being the types of vehicles,
    and the values being cost calculation functions based on the distance.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the itinerary function for the `:driving` dispatch value. You can use
    associative destructuring in the function parameters to retrieve the `:from`,
    `:to`, and `:vehicle` keys from the `HashMap` parameter. The driving distance
    and duration can be calculated similarly to the walking distance and duration.
    The cost can be calculated by retrieving the cost function from the dispatch table
    using the `:vehicle` key.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expected Output:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Note
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 686.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we took a closer look at Clojure''s powerful functions. We
    learned how to simplify our functions with destructuring techniques, and then
    discovered the great benefits of higher-order functions: modularity, simplicity,
    and composability. We also introduced an advanced concept to write code that is
    more extensible with Clojure''s polymorphism mechanism: multimethods. Now that
    you are familiar with the REPL, data types, and functions, you can move on to
    learning about tools and functional techniques to manipulate collections.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will explore sequential collections in Clojure and
    take a look at two of the most useful patterns: mapping and filtering.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
