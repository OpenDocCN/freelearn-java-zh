- en: 3\. Functions in Depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take a deep dive into Clojure's functions. We discover
    destructuring techniques and advanced call signatures. We take a closer look at
    the first-class aspect of functions and learn how it enables functional composition,
    as well as advanced polymorphism techniques. This chapter teaches techniques that
    will significantly improve the conciseness and readability of your code. It lays
    down a solid basis to prepare you for the second part of this book about manipulating
    collections.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to implement features such as destructuring,
    variadic functions and multimethods when writing functions.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Clojure is a functional programming language, and functions are of primordial
    importance to the Clojure programmer. In functional programming, we avoid mutating
    the state of a program, which, as we have seen in the previous chapter, is greatly
    facilitated by Clojure''s immutable data structures. We also tend to do everything
    with functions, such that we need functions to be able to do pretty much everything.
    We say that Clojure functions are **first-class citizens** because we can pass
    them to other functions, store them in variables, or return them from other functions:
    we also call them first-class functions. Consider an e-commerce application, for
    example, where a user is presented with a list of items with different search
    filters and sorting options. Developing such a filtering engine with flags and
    conditions in an imperative programming way can quickly become unnecessarily complex;
    however, it can be elegantly expressed with functional programming. Functional
    composition is a great way to simply and efficiently implement such a filtering
    engine, for each filter (for example, the price, color, size of an item, and so
    on), the logic can be contained within a function and those functions could be
    simply combined or composed as a user interacts with an interface.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to master functions. We will start with
    destructuring techniques, which can notably be used in function parameters, then
    we will move on to advanced call signatures including functions with multiple
    arities and a variable number of arguments. Then, we will dive into the first-class
    aspect of functions and learn how they enable functional composition. Finally,
    we will explain advanced polymorphism techniques with multimethods and dispatch
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Destructuring allows you to remove data elements from their structure or disassemble
    a structure. It is a technique that improves the readability and conciseness of
    your code by providing a better tool for a widely used pattern. There are two
    main ways of destructuring data: sequentially (with vectors) and associatively
    (with maps).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we need to write a function that prints a formatted string given
    a tuple of coordinates, for example, the tuple `[48.9615, 2.4372]`. We could write
    the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This `print-coords` function takes a tuple of coordinates as a parameter and
    prints out the coordinates to the console in a nicely formatted string, for example,
    `Latitude:` `48.9615` – `Longitude:` `2.4372`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we are essentially doing when binding the first element to `lat` and the
    second to `lon` is destructuring: we are taking each element out of their sequential
    data structure. This use case is very common, and Clojure provides a built-in
    syntax for destructuring data structures to bind their values to symbols.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could rewrite the `print-coords` function with a sequential destructuring
    technique as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Observe how the preceding example is shorter and more expressive than the one
    before. We didn't need to use a function like `first` or `last`, we simply expressed
    the symbols we wanted to retrieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two functions are equivalent. `lat` is "mapped" to the first element of
    the vector and `lon` to the second. This other, simpler example might be more
    visually helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the bindings are created according to both the sequential order of
    the vector and the order of the symbols defined in vector `[a b c]`. The symbol
    values are then printed out to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'A list, which is a sequential data structure, can be similarly disassembled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the same example of printing the coordinates of an airport, but this
    time we receive the data as a map rather than a tuple. The data has the following
    shape: `{:lat 48.9615, :lon 2.4372, :code ''LFPB'', :name "Paris Le Bourget Airport"}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could write the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This function retrieves the values from the `airport` map by using the keywords
    as functions in the `let` expression. We can spot the repetitive pattern when
    binding `lat`, `lon`, and `name`. Similarly, when the data structure we want to
    disassemble is associative (a `map`), we can use an associative *destructuring*
    technique. The function can be rewritten using associative destructuring, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With this technique, we are creating bindings by mapping the symbols to the
    keys inside the map. The `lat` symbol now contains the value in the airport map
    at the key `:lat`, `lon` is mapped to the key `:lon`, and, finally, the `airport-name`
    symbol is mapped to the key `:name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the keys and symbols can all have the same name, there is a shorter syntax
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding destructuring syntax indicates looking for the `lat`, `lon`, and
    `name` keys inside the `airport` map and binding them to symbols with the same
    name. The syntax might look a little bit surprising, but it is a widely used technique
    in Clojure. We will use it in the next exercise so that you can learn how to use
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see our final function in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `print-coords` function destructures the airport
    `map` in the `let` expression and binds the values `48.9615`, `2.4372`, and `Paris
    Le Bourget Airport` to the symbols (respectively) `lat`, `lon`, and `name`. Those
    values are then printed out to the console with the `println` function (which
    returns `nil`).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've discovered the basics of destructuring and its utility, we can
    move on to the REPL, start practicing, and learn even more advanced destructuring
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.01: Parsing Fly Vector''s Data with Sequential Destructuring'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the purpose of this exercise, imagine that we are building a flight-booking
    platform application. For our first prototype, we just want to parse and print
    flight data that we receive from our partners. Our first partner, Fly Vector,
    has not yet discovered the power of associative data structures and they send
    us all their data in the form of Vectors. Luckily, they have comprehensive documentation.
    I have done the heavy lifting of reading the hundreds of pages of the data format
    specification for you and here is what it boils down to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A coordinate point is a tuple of latitude and longitude, for example: `[48.9615, 2.4372]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A flight is a tuple of two coordinate points, for example: `[[48.9615, 2.4372],
    [37.742, -25.6976]]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A booking consists of some information followed by one or multiple flights
    (up to three). The first item is Fly Vector''s internal ID for the booking, the
    second item is the name of the passenger, and the third is some sensitive information
    that Fly Vector asked us not to parse or even look at (they couldn''t update their
    system to remove the information). Finally, the rest of the vector consists of
    the flight coordinates data, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That should be enough information for us to develop the prototype, so let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a REPL and bind the sample booking data to the `booking` symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start developing our parsing function by experimenting with destructuring.
    Create a `let` block and define the binding as follows, printing out the result
    with `println`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `flight3` was bound to the value `nil`. This is because the data
    is shorter than the bindings defined, and it is both valid and useful to be able
    to bind only values that exist.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Similarly, if the booking vector contained extra data, it would be ignored.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Remember that `conj` takes a collection and some elements as arguments and
    returns a new collection with those elements added to the collection. Add two
    flights in the booking vector with `conj` and parse the data using the same destructuring
    expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the last flight was simply ignored and not printed out. That's another
    useful trait of destructuring and another sign of Clojure's dynamism and practicality.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the data received, we don''t really care about the Fly Vector internal ID
    and we don''t want to parse the sensitive information. This can be simply ignored
    by using an underscore, `_`, instead of a symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great, we now understand how to ignore some parts of the data with destructuring.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Just printing the array of coordinates is not very readable, so until we have
    a better way of printing out flights, we would like to simply display the number
    of flights in the booking. Surely, we could test `flight1`, `flight2`, and `flight3`
    for the presence of a value but there''s another aspect of destructuring that
    we could use: the "remaining" parts of the sequence. By using the `&` character
    followed by a symbol, we can bind the remaining part of a sequence to a given
    symbol.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Bind the `flights` sequence to a `flights` symbol by using the `&` character,
    then display the number of flights as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `flights` is now a collection and, therefore, we can use the `count`
    function with it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Destructuring is very powerful and can also disassemble nested data structures.
    To parse and print the flight details, let's create a separate function to keep
    the code clear and readable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `print-flight` function that disassembles a flight path using nested
    destructuring and print out a nicely formatted flight itinerary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how we dug into the nested vectors contained in `flight` to retrieve
    the coordinate values inside the coordinate tuples, by simply using nested vector
    literal notation. However, the nested vectors in the `let` bindings can be slightly
    hard to read.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rewrite the `print-flight` function by decomposing the steps in multiple `let`
    bindings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding example, we have created two intermediate bindings using sequential
    destructuring: `departure` and `arrival`. Those two bindings contain coordinates
    tuples that we can destructure further to create the latitude and longitude bindings
    `lat1`, `lon1`, `lat2`, and `lon2`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, let''s write the `print-booking` function by combining the code we
    have written so far:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great job! In this exercise, we've successfully used *sequential destructuring*
    to parse and retrieve data from a vector and improve the readability and conciseness
    of our code. Now, let's move on to the next exercise, where we will use *associative
    destructuring*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.02: Parsing MapJet Data with Associative Destructuring'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's continue with our flight booking platform application. Now we would like
    to develop the same parser for another partner called MapJet. You might have guessed,
    MapJet has discovered the power of associative data structures and are sending
    us nice and intelligible data structures, which consist of both maps and vectors.
    Now, the data is self-explanatory and even if MapJet provides very detailed documentation,
    we won't even bother reading it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the data shape of a sample booking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let''s agree on the fact that maps are a great way to exchange data.
    They are very readable for us humans, and simple to parse for our programs. Now,
    let''s get back to the REPL and see how associative destructuring can help us
    manipulate the data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bind the sample booking map to the `mapjet-booking` symbol as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using associative destructuring, print the booking summary as we did for Fly
    Vector (the name of the customer and the number of flights):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By using the shorter and non-repetitive syntax with `:keys`, we were able to
    fetch the keys inside the map and bind their values to symbols with the same name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s write a `print-mapjet-flight` function to print the flight details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we cannot use the shorter syntax for extracting coordinates because
    the names `lat` and `lon` would conflict; therefore, we used the normal syntax,
    allowing us to explicitly declare a new binding to symbols with different names.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As with vectors, we can nest destructuring expressions, and even combine the
    two techniques.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s rewrite the `print-mapjet-flight` function, but this time we are going
    to nest our associative destructuring expressions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding example is slightly complicated to read so don''t worry if it
    looks a bit confusing at first. Think of the key of a destructuring map as the
    target, and the source as the value, as follows: `{target1 source1 target2 source2}`.
    The target can either be a symbol, or another destructuring map like this: `{{target3
    source3} source1 {target4 source4} source2}`. Notice, in this last expression,
    how we just bind values to the symbols in the innermost map (`target3` and `target4`).
    This is what we just did in the `print-mapjet-flight` function: we extracted the
    nested values of latitude and longitude for both coordinate points.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the final function for printing MapJet bookings, using the code to print
    the booking summary to the console. It should produce a similar output to Fly
    Vector''s `print-booking` function, first printing the number of flights and then
    printing each flight individually with `print-mapjet-flight` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It works! We have now finished our first prototype. In this exercise, we have
    implemented a `Map` parser that prints out data that has been destructured to
    the console. Well done!
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring techniques are essential because they can make our code more concise
    and more readable. Additionally, the data that our programs have to deal with
    often comes from external data sources, and we don't always own the shape of the
    data we need to handle. Having a powerful tool to dig into various data structures
    significantly improves our quality of life as programmers.
  prefs: []
  type: TYPE_NORMAL
- en: However, the code we have written in the previous exercise feels somehow repetitive;
    the two `print-booking` functions, for example, have a lot in common. With what
    we currently know, it would be difficult to refactor this code. But don't worry,
    the techniques we are going to learn in the next topics will allow you to write
    even more elegant code, with less repetition, less code, and therefore fewer bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Call Signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been declaring functions with one arity (with only a fixed number
    of arguments), and simply binding the arguments passed to a function to some parameter
    names. However, Clojure has a few techniques to allow more flexibility when calling
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring Function Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, everything we have just learned about destructuring applies to function
    parameters. Yes, you read that correctly – we can use destructuring techniques
    right in the function parameter declaration! As promised, here''s our first stab
    at refactoring the `print-flight` functions from the previous exercise. Observe,
    in the following example, how sequential destructuring is used directly in the
    function parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we got rid of the `let` expression. Similarly, we can do the same
    for `print-mapjet-flight`, with associative destructuring used in the function
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we got rid of the `let` expression and destructured the parameter
    right away from the function arguments. Great – that is one new way of defining
    function parameters and improving our code even further.
  prefs: []
  type: TYPE_NORMAL
- en: Arity Overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Second, Clojure supports "arity overloading," which means that we can *overload*
    a function with another function of the same name by specifying extra parameters
    to the new function. Those two functions have the same name but different implementations,
    and the function body to execute is chosen based on the number of arguments provided
    upon a function call. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the different function implementations are defined. In the `no-overloading`
    function, which is how we are used to creating functions, there are no extra parentheses
    around the parameter declaration (which comes just after the function name). Whereas
    in the `overloading` function, each implementation is surrounded by parentheses,
    starting with the parameter declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how the multi-arity `overloading` function plays out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, no arguments were passed; therefore, the first implementation
    of the `overloading` function is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this case, one argument is passed to the `overloading` function, so the second
    implementation is called.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, two arguments are passed, so the third implementation
    of the `overloading` function is called.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Finally, an incorrect number of arguments produce the usual arity exception.
  prefs: []
  type: TYPE_NORMAL
- en: You might (legitimately) wonder how this is useful, and why not just declare
    different functions? In fact, when defining multiple arities for the same function,
    you are saying that the functions are essentially the same, that they are doing
    a similar job, but the execution slightly varies based on the number of arguments.
    It can also be useful to provide default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code for a new little fantasy game called `strike` function
    to compute the new state of an `enemy` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we start by defining a `HashMap` and binding it to
    the `weapon-damage` symbol. The second expression is the definition of the `strike`
    function, which subtracts damage from an `enemy` entity, retrieving the amount
    of damage in the `weapon-damage` map. Observe that the `strike` function has two
    implementations. The first implementation contains only one parameter, `enemy`,
    and the second implementation has two parameters: `enemy` and `weapon`. Notice
    how the first implementation is calling the second one by providing an extra parameter.
    Therefore, when calling the `strike` function with only one argument, the default
    value, `:fists`, will be provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe that the function was called with one parameter only (the `enemy` entity),
    which therefore went through the one-parameter implementation of the function,
    using `:fists` as a default value and returning an enemy with 90 points of health
    left (because fists do 10 points worth of damage):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `strike` function was called directly with the
    two-arity implementation, because the second parameter, `weapon`, was explicitly
    provided.
  prefs: []
  type: TYPE_NORMAL
- en: Variadic Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a final secret left to reveal regarding function parameters. With what
    we have learned about function arity, how would you define the parameters of the
    `str` function, for example?
  prefs: []
  type: TYPE_NORMAL
- en: 'It seems to take an infinite number of parameters. You might remember using
    `str` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: But surely, it isn't implemented with overloading like this `(defn str ([s]
    ...) ([s1 s2] ...) ([s1 s2 s3] ...) ([s1 s2 s3 s4] …))` and so on… Then, what
    is happening in this case?
  prefs: []
  type: TYPE_NORMAL
- en: This is the destructuring technique coming back into play. Remember that we
    can use the `&` character to bind the remainder of a sequence to a data structure?
    It works similarly with function arguments, and we can create a data structure
    from the arguments passed to a function with the `&` character. This is how you
    can create variadic functions (functions that take a variable number of arguments),
    and this is how the `str` function is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at how the documentation describes the `str` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Notice the declaration of its different arities. It accepts either no element,
    `[]`, one element, `[x]`, or any number of elements, `[x & ys]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to use this new knowledge to create a function that prints a welcome
    message to the new player of `Parenthmazes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe how we used the destructuring technique right in the function parameters,
    binding any arguments that come after `player` to the `friends` collection. Now,
    let''s try to use our function with one and multiple arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when more than one argument is passed to the `welcome` function,
    the `friends` symbol is bound to a sequence containing the rest of the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `seq` function can be used to get a sequence from a collection. In the `welcome`
    function, we use the `seq` function to test whether a collection contains elements.
    That's because `seq` returns `nil` when the collection passed as a parameter is
    empty. `(if (seq (coll))` is a commonly used pattern that you should use instead
    of `(if (not (empty? coll)))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could improve this function slightly. Instead of testing whether `friends`
    is empty, we could also take advantage of the multi-arity technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Notice how, this time, two `welcome` functions were defined, one with only one
    `player` parameter, and a second one with an unlimited number of parameters that
    will be bound to the `friends` symbol. Separating the functions like this improves
    the clarity of the code by being more explicit about the intent of the function
    as well as removing the conditional expression with `when`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try the `welcome` function one last time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Great – the function call was dispatched to the right function according to
    the number of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.03: Multi-arity and Destructuring with Parenthmazes'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will continue working on the `Parenthmazes` game by adding
    new features, notably improving our `strike` function to implement a healing mechanism.
    We would also like to add the concept of armor, which can reduce the damage suffered.
  prefs: []
  type: TYPE_NORMAL
- en: Get ready for the great battle between Gnomes and Trolls in this new version
    of `Parenthmazes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, start a REPL and your favorite code editor next to it, and create
    the `weapon-damage` map, which contains damage information for each weapon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need this map to look up the amount of damage done when a player strikes
    an enemy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s create the `strike` function, which will handle healing when the
    enemy is in the same camp as us (let''s assume for now that we picked the Gnomes''
    side):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding function, the new code of the `strike` function is to retrieve
    which side the target is on by looking up the `:camp` key in the `target` entity.
    If the `target` belongs to the Gnomes camp, we use the `+` function to increase
    the health in the `target` entity by x number of `points`. Otherwise, we use `-`
    to decrease the number of health points in the `target` entity.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an `enemy` entity and test our newly created `strike` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Health points were subtracted successfully. Let's see what happens with a friendly
    player.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an `ally` entity that belongs to the `:gnomes` camp, and test our newly
    created `strike` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Health points were added successfully!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have got the shell of our `strike` function, let's amend it to implement
    the armor functionality. The `target` entity can contain an `:armor` key, which
    contains a coefficient used to calculate the final amount of damage. The bigger
    the number, the better the armor. For example, an armor value of 0.8 for a strike
    of 100 points results in 20 damage points being inflicted. An armor value of 0.1
    results in 90 damage points being inflicted, 0 means no armor, and 1 means invincible.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the amount of damage inflicted on the target by calculating the damage
    with the `:armor` value in the `target` entity. If the target has no armor value,
    set it to `0`. To improve readability, we will use a `let` binding to decompose
    the damage calculation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the second branching of the `if` expression, we used a `let` expression to
    assign a default value to `armor` by using `or`. If `(:armor target)` is nil,
    the value of armor is 0\. The second binding contains the reduced damage based
    on the armor value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test the `strike` function to see if it still works with no armor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A cast-iron saucepan does 150 damage, and 250 minus 150 is indeed `100`. Great
    – it works. Let's move on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Redefine the `enemy` binding to add an armor value and test our `strike` function
    once again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great – the damage seems to be reduced according to the armor coefficient. Now
    we would like to use our associative destructuring technique to retrieve the `camp`
    and `armor` values directly from the function parameters, and reduce the amount
    of code in the function's body. The only problem we have is that we still need
    to return an updated version of the `target` entity, but how could we both destructure
    the `target` entity and keep a reference of the `target` parameter? Clojure has
    your back – you can use the special key `:as` to bind the destructured map to
    a specific name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the `strike` function to use associative destructuring in the function''s
    parameters. Use the special key `:as` to bind the map passed as an argument to
    the symbol target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is one other useful feature in associative destructuring that we could
    take advantage of: the special key `:or`. It permits us to provide a default value
    for when a key that we want to extract isn''t found (instead of binding to `nil`).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the special key `:or` in the destructured map to provide a default value
    to the armor key in the target map, add an extra arity to make the `weapon` parameter
    optional, and finally add some documentation, as follows. Don''t forget to wrap
    each function definition with its own set of parentheses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure that your function still works as expected by testing the different
    scenarios as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That concludes this exercise. If you look again at the `strike` function you've
    just written, it is using some advanced Clojure features, including destructuring,
    multi-arity functions, and reading and updating maps. By passing a function as
    an argument in the `update` function, we also used the concept of higher-order
    functions, which we will explain further in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-Order Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Higher-order programming means that programs, and specifically functions, can
    operate on other programs or functions, as opposed to first-order programming,
    where functions operate on data elements such as strings, numbers, and data structures.
    In practice, it means that a function can take some programming logic as a parameter
    (another function) and/or return some programming logic to be eventually executed.
    It is a powerful feature that allows us to compose single, modular units of logic
    in our programs to reduce duplication and promote the reusability of code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing simpler functions increases their modularity. We want to create simple
    units of functionality that can be used as small bricks to build our programs
    with. Writing pure functions reduces the complexity of those bricks, and allows
    us to craft better, sturdier programs. Pure functions are functions that don't
    alter the state of our program – they produce no side effects; a pure function
    also always returns the same value when given the exact same parameters. This
    combination makes pure functions easy to reason about, build upon, and test. Although
    Clojure offers ways to modify the state of our program, we should write and use
    pure functions as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: First-Class Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s demonstrate the use of functions as parameters. We used functions as
    parameters in *Exercise 2.01*, *The Obfuscation Machine* of *Chapter 2*, *Data
    Types and Immutability*, with the `clojure.string/replace` function, and also
    in the preceding exercise, with the `update` function. For example, to divide
    a value by `2` in a `HashMap`, you can pass an anonymous function that does the
    division as an argument to the `update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Even better, you could simply pass the divide function, `/`, with the argument
    `2`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `update` will pass the old value as the first argument to the `/`
    function (here, the old value is `1.0`) as well as all the extra arguments (here,
    `2`).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can operate on any kind of value. For example, to invert the value of a
    Boolean, use the `not` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ve just seen, `update` can take a function as a parameter, but we could
    also define our own function that takes a function and applies it to a given parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, `operate` takes a function, `f`, as a parameter and
    calls it with the second parameter, `x`. Not very useful, but it shows how simple
    it is to pass and call a function passed as a parameter. If we wanted to pass
    any number of arguments, we could use the `&` character as we learned in the previous
    topic about destructuring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, `operate` seems to accept any number of arguments, but the function
    call fails because `args` is a sequence. That''s because we applied the `f` function
    to the `args` sequence directly, when what we really wanted was to apply `f` using
    each element of the sequence as an argument. There is a special function to disassemble
    a sequence and apply a function to that sequence''s elements – the `apply` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Notice how `+` does not work on a vector, but by using apply, we call `+`, passing
    each element of the vector as an argument to `+`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, therefore, use `apply` in our `operate` function to have a fully working
    function that takes a function, `f`, as a parameter and calls `f` with the rest
    of the parameters, `args`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: It works! The `str` function was applied to the arguments passed to `str`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability to pass a function as a parameter is one aspect of higher-order
    functions, but another aspect is the ability of functions to *return* other functions.
    Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `shuffle` function shuffles an array by sorting its elements randomly,
    and we then take the first element out of it. In other words, the `random-fn`
    function returns a random function from the `[+ - * /]` collection. Notice that
    the `random-fn` function does not take any parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'But the function returned by `random-fn` expects parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `(random-fn)` returned `-` so `3` was subtracted from
    `2`, which results in `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `fn?` function to check whether a value passed as a parameter
    is a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, observe that both `random-fn` and the value returned by `random-fn`
    are functions. So, we can call the function returned by `random-fn`, and even
    bind it to a symbol, as in the example that follows, where we bind the function
    to the `mysterious-fn` symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Notice how every call to `random-fn` returned a different function. On each
    step, calling `mysterious-fn` with the same arguments is processed by a different
    function. Based on the returned values, we can guess that the functions are respectively
    `*`, `/`, `*`, and `+`.
  prefs: []
  type: TYPE_NORMAL
- en: It is conceivable but not very common to write functions that return other functions.
    However, you will often use some of Clojure's core utility functions, which return
    other functions, and which we are going to present next. Those are worth exploring
    because they enable functional composition, reusability, and conciseness.
  prefs: []
  type: TYPE_NORMAL
- en: Partial Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first of those core utility functions is `partial`, which takes a function,
    `f`, as a parameter and any number of arguments, `args1`. It returns a new function,
    `g`, that can take extra arguments, `args2`. When calling `g` with `args2`, `f`
    is called with `args1` + `args2`. It may sound complicated, but consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Calling `(partial + 0.99)` returns a new function that we bind to the `marketing-adder`
    symbol. When `marketing-adder` is called, it will call `+` with `0.99` and any
    extra arguments passed to the function. Notice that we used `def` and not `defn`,
    because we don't need to build a new function – `partial` does it for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `format-price` will call the `str` function with the first parameter,
    `"€"`, and then the rest of the parameters. Of course, you could write the same
    function like this: `(fn [x] (str "€" x))`, but using `partial` is a nice and
    expressive way of defining functions as functions of other functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Composing Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another core utility function is `comp`, short for compose. Take, for example,
    our `random-fn` function. To retrieve a random number from the collection, we
    call the `shuffle` function and then the `first` function. If we wanted to implement
    a `sample` function that does exactly that, we could write the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'But more elegantly, we could implement the `sample` function with the functional
    composition utility, `comp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`comp` is a utility that takes any number of functions as a parameter and returns
    a new function that calls those functions in order, passing the result of each
    to the other. Observe that the functions are composed from right to left, so in
    the preceding example, `shuffle` will be applied before `first`. This is important
    because the number and types of arguments passed to the chain of functions is
    often meaningful. For example, if you wanted to compose a function that multiplies
    numbers and increments the result by one, you would need to pass the `inc` function
    (increment) as a first argument of the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when providing `inc` as the last argument of the `comp` function,
    it calls `(inc 2 2)`, which does not work because `inc` takes only one argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how we can combine the use of `partial` and `comp` to compose
    a `checkout` function with the `format-price` and `marketing-adder` functions
    that we defined previously. The `checkout` function will first add its parameters
    by reusing `marketing-adder`, then format the price with `format-price` and return
    the string concatenated with `"Only"` in front of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we defined a `checkout` function as a composition
    of `marketing-adder`, `format-price`, and an anonymous function returned by `partial`
    to add the text `"Only"` before the price. This example shows the outstanding
    dynamism and expressivity of composing related functions in Clojure. The programmer's
    intent is clear and concise, skipping the technicality of defining functions and
    naming parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we jump into the exercise, let''s present a new way of writing anonymous
    functions: the `#()` literal. `#()` is a shorter way of writing an anonymous function.
    Parameters are not named and therefore parameter values can be accessed in order
    with `%1`, `%2`, `%3`, and so on. When only one argument is provided, you can
    simply use `%` (omitting the argument number) to retrieve the value of the argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the two following expressions are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'And the two following expressions are equivalent as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '`#()` literal functions are just functions, called in the same way as other
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Observe that when more than one argument is provided, we need to use the `%1`
    and `%2` to refer to the values passed as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The short literal notation of the `#()` function is convenient but should be
    used sparingly because numbered parameters can be hard to read. The rule of thumb
    is to use only short anonymous functions with a single argument and a single function
    call. For anything else, you should stick with the standard `fn` notation with
    named parameters to improve readability.
  prefs: []
  type: TYPE_NORMAL
- en: Let's put these new techniques into practice in an exercise with `Parenthmazes`
    version 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.04: High-Order Functions with Parenthmazes'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will demonstrate the benefit of functions being first-class
    citizens. We will use functions as values and compose them together.
  prefs: []
  type: TYPE_NORMAL
- en: We would like to improve our fantasy game, Parenthmazes, even more, this time
    by changing weapons' mechanics to allow each weapon to have different behavior.
    For example, we would like "fists" to inflict damage only if an enemy is weak
    or has been weakened. Instead of implementing conditional branches in our `strike`
    function, we are going to implement a *dispatch table* using the `weapon-damage`
    `HashMap`, which we are going to rename `weapon-fn-map`, because this time each
    weapon will have an associated function (rather than a numeric value). A dispatch
    table is a table of pointers to functions. We can implement it with a `HashMap`
    where the pointers are keys and the functions are values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow our weapon functions to compose nicely, they will take a numeric value
    for health as a parameter and return a numeric value for health after the damage
    has been deducted. For the sake of simplicity, we will leave out the concept of
    armor this time. Let''s start with the `fist` weapon:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a REPL next to your favorite code editor. Create a new `HashMap` with
    a `:fists` key and its associated function, which inflicts `10` damage only if
    the health of the enemy is less than `100`, and otherwise returns the `health`
    parameter. Bind the newly created function to the `weapon-fn-map` symbol as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A `HashMap` can have any type of value as a key or parameter, so a function
    as a value is perfectly fine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Try the function by retrieving it from `weapon-fn-map` and call it with `150`
    and then `50` as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Observe that the function returned the new health correctly. It subtracted `10`
    when the `health` parameter was less than `100`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now to the `staff` weapon. The `staff` is the only weapon that can be used
    to heal (`35` health points), so the associated function should simply call `+`
    instead of `-`. It seems like a good opportunity to generate this function using
    `partial`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The value at the `:staff` key is now a function that will call `+` with `35`
    and any extra argument supplied.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Try the function associated with `staff`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the `sword` weapon, we need to simply subtract `100` points from the health
    points passed as an argument. However, `partial` won't work because the parameters
    would not be in the correct order. For example, `((partial - 100) 150)` returns
    `-50`, because the function call is equivalent to `(- 100 150)`, but we need `(-
    150 100)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an anonymous function subtracting `100` from its argument and associate
    it with the `sword` key, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we used `%` to retrieve the argument passed to the anonymous function,
    because we used the short literal syntax, `#()`, expecting only one argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test your newly created weapon function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It works!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next weapon to add is `cast-iron-saucepan`. To spice things up, let's add
    a bit of randomness to the mix (a saucepan is not a very accurate weapon anyway).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `cast-iron-saucepan` function to the `HashMap` that subtracts `100`
    health points and a random number between `0` and `50` from the health points,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, we used the `rand-int` function, which generates a
    random integer between `0` and the supplied argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test the newly created function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Two subsequent calls might return a different value because of the `rand-int`
    function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we would like to introduce a new weapon (for the unfortunate adventurers)
    that doesn''t do any damage: the sweet potato. For that purpose, we need a function
    that returns its argument (the health). We don''t need to implement it as it already
    exists: `identity`. First, let''s check out the source code of the function identity
    with the `source` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Observe how `identity` simply returns its argument. The `source` function is
    another handy tool to use interactively in the REPL, as it prints out a function
    definition to the console, which is sometimes more helpful than a function's documentation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s redefine our `weapon-fn-map` `HashMap` one last time by associating
    the function identity with the `:sweet-potato` key, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have our `weapon-fn-map` finalized, we should modify our `strike`
    function to handle the weapon functions stored as values in our `HashMap`. Remember
    that the `strike` function takes a `target` entity as a parameter and returns
    this entity with a new value for the health key. Therefore, updating the entity's
    health should be as simple as passing a `weapon` function to the `update` function,
    because our `weapon` functions take the health as a parameter and return the new
    health value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rewrite the `strike` function from the previous exercise to use the weapon
    functions stored in the `weapon-fn-map`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now test your `strike` function by passing various weapons as a parameter.
    For convenience, you might want to create an `enemy` entity as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we wanted to strike with more than one weapon at a time, instead of nesting
    a strike call like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We could simply compose our weapon functions and just use the core update function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write an `update` expression to strike with two weapons at a time using `comp`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because the weapon functions that we wrote have a consistent interface (taking
    `health` as a parameter and returning the health), it is straightforward to compose
    them with `comp`. To finish this exercise, let's create a `mighty-strike` function
    that strikes with all of the weapons at once, also known as composing all the
    weapon functions. The `keys` and `vals` functions can be used on `HashMaps` to
    retrieve a collection of the map's keys or values. To retrieve all the weapon
    functions, we can simply retrieve all the values from `weapon-fn-map` using the
    `vals` function. Now that we have a collection of functions, how do we compose
    them? We need to pass each function of the collection to the `comp` function.
    Remember, to pass each element of a collection as a parameter of a function, we
    can use `apply`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write a new function named `mighty-strike`, which takes a `target` entity as
    a parameter and uses all of the weapons on it. It should apply the `comp` function
    to the values of `weapon-fn-map` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, if we pause to reflect on the `mighty-strike` function and think about
    how we would have to implement that without higher-order functions, we'll realize
    how simple and powerful the concept of functional composition is.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've learned how to use functions as simple values and as
    parameters or return values of other functions, as well as creating shorter anonymous
    functions with `#()`. We also explained how to use `partial`, `comp`, and `apply`
    to generate, compose, and discover new ways of using functions.
  prefs: []
  type: TYPE_NORMAL
- en: Multimethods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clojure offers a way to implement polymorphism with multimethods. Polymorphism
    is the ability of a unit of code (in our case, functions) to behave differently
    in different contexts, for example, based on the shape of the data received by
    the code. In Clojure, we also call it *runtime polymorphism* because the method
    to call is determined at runtime rather than at compile time. A multimethod is
    a combination of a dispatch function and of one or more methods. The two main
    operators for creating those multimethods are `defmulti` and `defmethod`. `defmulti`
    declares a multimethod and defines how the method is chosen with the dispatch
    function. `defmethod` creates the different implementations that will be chosen
    by the dispatch function. The dispatch function receives the arguments of the
    function call and returns a dispatch value. This dispatch value is used to determine
    which function, defined with `defmethod`, to invoke. Those are a lot of new terms
    but don't worry, the following examples will help you understand the new concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we could implement Parenthmazes'' `strike` function with multimethods.
    This time, the weapon is in the `HashMap` passed as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we''ve created a multimethod called `strike`. The second
    argument is the dispatch function, which simply retrieves a weapon in a map passed
    as a parameter. Remember that keywords can be used as functions of a `HashMap`,
    so we can simply write `defmulti` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that, this time, the expression returned `nil`. This is because the
    multimethod was already defined. In that case, we need to `unmap` the `strike`
    var from the `user` namespace and re-evaluate the same expression again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our multimethod and our dispatch function defined (which is
    simply the `:weapon` keyword), let''s create our `strike` functions for a couple
    of weapons, to demonstrate the usage of `defmethod`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe how we called `defmethod` with the function named `strike`, the second
    argument to `defmethod` is the dispatch value: `:sword`. When `strike` is called
    with a map containing a weapon key, the weapon value is retrieved from the arguments
    and then returned by the dispatch function (the `:weapon` keyword). Similarly,
    let''s create another strike implementation for the `:cast-iron-saucepan` dispatch
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, `strike` is called with a map containing `:cast-iron-saucepan` at
    the `:weapon` key. The function defined previously will be invoked. Let''s test
    our newly created multimethod with the two different weapons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Notice how calling `strike` with different arguments lets us invoke two different
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the dispatch value doesn''t map to any registered function, an exception
    is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to handle that case, we can add a method with the `:default` dispatch
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we decided to handle any other weapon by simply returning the
    unmodified health value, inflicting no damage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that, this time, no exception was thrown, and the original health value
    was returned. The dispatch function can be more elaborate. We could imagine a
    special behavior when the enemy''s health is below 50 points and instantly eliminate
    it, no matter what weapon was used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code first unmaps `strike` from the `user` namespace so that it
    can be redefined. We then redefine the dispatching function by looking in the
    parameter and dispatching to a `:finisher` function if the health of the enemy
    is below `50`. We then define the `:finisher` function (the `strike` function
    with the dispatch value finisher) to return, simply ignore its arguments, and
    return `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we''ve unmapped `strike`, we must add `defmethods` as they would have
    been removed too. Let''s re-add a sword and the default method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s see our multimethod in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Great – our function still works as expected. Now let''s see what happens when
    the health is below `50`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The `finisher` function has been called and the strike multimethod successfully
    returned `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Multimethods can do a few more things, such as dispatching on multiple values
    (using a vector as the dispatch value) or dispatching on types and hierarchies.
    This is useful but maybe a bit much to take on for now. Let's move on to the exercise
    and practice using multimethods by dispatching on values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.05: Using Multimethods'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we want to extend our little game, Parenthmazes, with the
    ability to move a player. The game board is a simple two-dimensional space with
    the coordinates x and y. We will not implement any rendering or maintain any state
    of the game at this point as we simply want to practice the use of multimethods,
    so you will have to use your imagination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Players'' entities are now given an extra key, `:position`, which contains
    a `HashMap` with the coordinates at key x and y as well as the `:facing` key,
    which contains the direction in which the player is facing. The following code
    is an example of a player entity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Moving north or south should change the y coordinate, and moving east and west
    should change the x coordinate. We will implement this with a new `move` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start a REPL and create the player entity as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `move` multimethod. The dispatch function should determine the dispatch
    value by retrieving the `:facing` value in the `:position` map of a player entity.
    The `:facing` value could be one of the following values `:north`, `:south`, `:west`,
    and `:east`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You might have noticed that the two successive keyword function calls could
    be more elegantly expressed with functional composition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Redefine the `move` multimethod by first unmapping the var from the `user`
    namespace and then using `comp` to simplify its definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the first implementation of the `move` function with the `:north` dispatch
    value. It should increment `:y` in the `:position` map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try your newly created function by calling `move` with the `player` entity
    and observe the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Observe that the value at `y` successfully increased by 1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the other functions for the rest of the dispatch values `:south`, `:west`,
    and `:east`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test your newly created functions by providing `player` entities facing different
    directions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Observe how the coordinates changed correctly when moving the players in different
    directions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an extra function for when the value at `:facing` is different from
    `:north`, `:south`, `:west`, and `:east`, using the `:default` dispatch value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try your function and make sure it handles unexpected values by returning the
    original entity map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Observe that the multimethod was dispatched to the default function, and that
    the position remained unchanged when the player was facing a `:wall`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this section, we've learned how to use Clojure's polymorphism feature with
    multimethods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3.01: Building a Distance and Cost Calculator'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go back to the flight-booking platform application that we worked on
    in *Exercise 3.01*, *Parsing Fly Vector''s Data with Sequential Destructuring*,
    and *Exercise 3.02*, *Parsing MapJet Data with Associative Destructuring*. In
    the time it took you to arrive at the end of this chapter, we have now developed
    the company into a proper start-up called WingIt, with serious investors, a weekly
    board meeting, and a ping pong table, which means that we now need to build the
    core services of the app: the itinerary and cost calculations between two locations.
    However, after looking into routing airways, airport fees, and complicated fuel
    calculations, we''ve come to realize that the algorithms that we need to develop
    might be too complicated for us at this stage. We''ve decided that for our **Minimal
    Viable Product** (**MVP**), we are just going to "wing it" and offer simpler modes
    of transportation such as driving and even walking. However, we want to keep the
    code easily extensible, because we''ll eventually need to add flying (some employees
    even overheard the CEO talking about adding space flights to the roadmap soon!).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirement of the WingIt MVP are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For the prototype, we will interact with a Clojure REPL. The interface is an
    itinerary function taking a `HashMap` as a parameter. For now, the users will
    have to enter coordinates. It might not be very user-friendly but the user can
    look up coordinates on their own globe or map!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The itinerary function returns a `HashMap` with the keys, `:distance`, `:cost`,
    and `:duration`. `:distance` is expressed in kilometers, `:cost` in euros, and
    `:duration` in hours.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only parameter to the itinerary function is a `HashMap` containing `:from`,
    `:to`, `:transport`, and `:vehicle`. `:from` and `:to` contain a `HashMap` with
    the `:lat` and `:lon` keys, representing the latitude and longitude of a location
    on our planet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:transport` can be either `:walking` or `:driving`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:vehicle` is only useful when `:transport` is `:driving`, and can be one of
    `:sporche`, `:sleta`, or `:tayato`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To compute the distance**, we are going to use the "Euclidian distance,"
    which is normally used to calculate the distance between two points on a plan.
    For flying, we would have to use at least the haversine formula, and technically,
    for driving, we would need to use routes, but we just want rough estimates on
    relatively short distances, so the much simpler Euclidian distance should be enough
    for now. The only complicated bit in this calculation is that the length of a
    degree of longitude depends on the latitude, so we''ll need to multiply the longitude
    by the cosine of the latitude. The final equation to compute the distance between
    two points (lat1, lon1) and (lat2, lon2) looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: Calculating the Euclidean distance'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_03_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.1: Calculating the Euclidean distance'
  prefs: []
  type: TYPE_NORMAL
- en: '`:driving`, we will look at the `:vehicle` chosen by the user in the `HashMap`
    parameter. The cost of each vehicle should be a function of the distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`:sporche` consumes, on average, 0.12 liters of petrol per kilometer, costing
    €1.5 per liter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:tayato` consumes, on average, 0.07 liters of petrol per kilometer, costing
    €1.5 per liter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:sleta` consumes, on average, 0.2 kilowatt hour (kwh) of electricity per kilometer,
    costing €0.1 per kwh.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cost should be 0 when transport is `:walking`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To compute the duration**, we consider an average driving speed of 70 km
    per hour, and an average walking speed of 5 km per hour.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a couple of examples of calls to the itinerary function, and the expected
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'These steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by defining the `walking-speed` and `driving-speed` constants.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two other constants representing two locations with the coordinates,
    `:lat` and `:lon`. You can use the previous example with Paris and Bordeaux or
    look up your own. You will be using them to test your distance and itinerary functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `distance` function. It should take two parameters representing the
    two locations for which we need to calculate the distance. You can use a combination
    of sequential and associative destructuring right in the function parameters to
    disassemble the latitude and longitude from both locations. You can decompose
    the steps of the calculation in a `let` expression and use the `Math/cos` function
    to calculate the cosine of a number and `Math/sqrt` to calculate the square root
    of a number; for example, `(Math/cos 0)`, `(Math/sqrt 9)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a *multimethod* called `itinerary`. It will offer the flexibility of
    adding more types of transport in the future. It should use the value at `:transport`
    as a *dispatch value*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the itinerary function for the `:walking` dispatch value. You can use
    associative destructuring in the function parameters to retrieve the `:from` and
    `:to` keys from the `HashMap` parameter. You can use a `let` expression to decompose
    the calculations of the distance and duration. The distance should simply use
    the `distance` function you created before. To calculate the duration, you should
    use the `walking-speed` constant that you defined in *Step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the `:driving` itinerary function, you could use a dispatch table that contains
    the vehicle associated with the costing function. Create a `vehicle-cost-fns`
    dispatch table. It should be a `HashMap` with the keys being the types of vehicles,
    and the values being cost calculation functions based on the distance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the itinerary function for the `:driving` dispatch value. You can use
    associative destructuring in the function parameters to retrieve the `:from`,
    `:to`, and `:vehicle` keys from the `HashMap` parameter. The driving distance
    and duration can be calculated similarly to the walking distance and duration.
    The cost can be calculated by retrieving the cost function from the dispatch table
    using the `:vehicle` key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expected Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 686.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we took a closer look at Clojure''s powerful functions. We
    learned how to simplify our functions with destructuring techniques, and then
    discovered the great benefits of higher-order functions: modularity, simplicity,
    and composability. We also introduced an advanced concept to write code that is
    more extensible with Clojure''s polymorphism mechanism: multimethods. Now that
    you are familiar with the REPL, data types, and functions, you can move on to
    learning about tools and functional techniques to manipulate collections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will explore sequential collections in Clojure and
    take a look at two of the most useful patterns: mapping and filtering.'
  prefs: []
  type: TYPE_NORMAL
