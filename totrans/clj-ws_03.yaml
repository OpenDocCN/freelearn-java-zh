- en: 3\. Functions in Depth
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 深入了解函数
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will take a deep dive into Clojure's functions. We discover
    destructuring techniques and advanced call signatures. We take a closer look at
    the first-class aspect of functions and learn how it enables functional composition,
    as well as advanced polymorphism techniques. This chapter teaches techniques that
    will significantly improve the conciseness and readability of your code. It lays
    down a solid basis to prepare you for the second part of this book about manipulating
    collections.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨 Clojure 的函数。我们发现了解构技术和高级调用签名。我们更深入地研究了函数的一等特性，了解它如何实现函数组合，以及高级多态技术。本章教授的技术将显著提高您代码的简洁性和可读性。它为您准备本书的第二部分，即操作集合的部分奠定了坚实的基础。
- en: By the end of this chapter, you will be able to implement features such as destructuring,
    variadic functions and multimethods when writing functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够在编写函数时实现解构、可变参数和多方法等特性。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'Clojure is a functional programming language, and functions are of primordial
    importance to the Clojure programmer. In functional programming, we avoid mutating
    the state of a program, which, as we have seen in the previous chapter, is greatly
    facilitated by Clojure''s immutable data structures. We also tend to do everything
    with functions, such that we need functions to be able to do pretty much everything.
    We say that Clojure functions are **first-class citizens** because we can pass
    them to other functions, store them in variables, or return them from other functions:
    we also call them first-class functions. Consider an e-commerce application, for
    example, where a user is presented with a list of items with different search
    filters and sorting options. Developing such a filtering engine with flags and
    conditions in an imperative programming way can quickly become unnecessarily complex;
    however, it can be elegantly expressed with functional programming. Functional
    composition is a great way to simply and efficiently implement such a filtering
    engine, for each filter (for example, the price, color, size of an item, and so
    on), the logic can be contained within a function and those functions could be
    simply combined or composed as a user interacts with an interface.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 是一种函数式编程语言，对于 Clojure 程序员来说，函数具有根本的重要性。在函数式编程中，我们避免改变程序的状态，正如我们在上一章所看到的，Clojure
    的不可变数据结构极大地促进了这一点。我们还倾向于用函数做所有事情，因此我们需要函数能够做几乎所有的事情。我们说 Clojure 函数是**一等公民**，因为我们可以将它们传递给其他函数，将它们存储在变量中，或者从其他函数中返回：我们也将它们称为一等函数。以一个电子商务应用程序为例，用户可以看到一个包含不同搜索过滤器和排序选项的商品列表。以命令式编程方式使用标志和条件开发这样的过滤引擎可能会迅速变得过于复杂；然而，使用函数式编程可以优雅地表达这一点。函数组合是一种简单而有效地实现此类过滤引擎的绝佳方式，对于每个过滤器（例如，商品的价格、颜色、尺寸等），逻辑可以包含在一个函数中，并且这些函数可以简单地组合或组合，当用户与界面交互时。
- en: In this chapter, you will learn how to master functions. We will start with
    destructuring techniques, which can notably be used in function parameters, then
    we will move on to advanced call signatures including functions with multiple
    arities and a variable number of arguments. Then, we will dive into the first-class
    aspect of functions and learn how they enable functional composition. Finally,
    we will explain advanced polymorphism techniques with multimethods and dispatch
    functions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何掌握函数。我们将从解构技术开始，这些技术特别适用于函数参数，然后我们将继续探讨高级调用签名，包括具有多个可变参数和可变数量参数的函数。接着，我们将深入研究函数的一等特性，了解它们如何实现函数组合。最后，我们将解释使用多方法和解派函数的高级多态技术。
- en: Destructuring
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构
- en: 'Destructuring allows you to remove data elements from their structure or disassemble
    a structure. It is a technique that improves the readability and conciseness of
    your code by providing a better tool for a widely used pattern. There are two
    main ways of destructuring data: sequentially (with vectors) and associatively
    (with maps).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 解构允许您从结构中移除数据元素或分解结构。这是一种通过提供更好的工具来改进广泛使用模式的可读性和简洁性的技术。解构数据有两种主要方式：顺序性（使用向量）和关联性（使用映射）。
- en: 'Imagine that we need to write a function that prints a formatted string given
    a tuple of coordinates, for example, the tuple `[48.9615, 2.4372]`. We could write
    the following function:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们需要编写一个函数，根据坐标元组打印格式化的字符串，例如，坐标元组 `[48.9615, 2.4372]`。我们可以编写以下函数：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This `print-coords` function takes a tuple of coordinates as a parameter and
    prints out the coordinates to the console in a nicely formatted string, for example,
    `Latitude:` `48.9615` – `Longitude:` `2.4372`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `print-coords` 函数接受一个坐标元组作为参数，并以格式化的字符串形式将坐标打印到控制台，例如，`纬度:` `48.9615` – `经度:`
    `2.4372`。
- en: 'What we are essentially doing when binding the first element to `lat` and the
    second to `lon` is destructuring: we are taking each element out of their sequential
    data structure. This use case is very common, and Clojure provides a built-in
    syntax for destructuring data structures to bind their values to symbols.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将第一个元素绑定到 `lat` 并将第二个元素绑定到 `lon` 时，我们实际上在进行解构：我们正在从它们的顺序数据结构中取出每个元素。这种用法非常常见，Clojure
    提供了一种内置语法来解构数据结构并将它们的值绑定到符号。
- en: 'We could rewrite the `print-coords` function with a sequential destructuring
    technique as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下方式使用顺序解构技术重写 `print-coords` 函数：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Observe how the preceding example is shorter and more expressive than the one
    before. We didn't need to use a function like `first` or `last`, we simply expressed
    the symbols we wanted to retrieve.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前面的例子，它比之前的例子更短、更简洁。我们不需要使用像 `first` 或 `last` 这样的函数，我们只需表达我们想要检索的符号。
- en: 'The two functions are equivalent. `lat` is "mapped" to the first element of
    the vector and `lon` to the second. This other, simpler example might be more
    visually helpful:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数是等价的。`lat` 被映射到向量的第一个元素，而 `lon` 被映射到第二个元素。这个其他、更简单的例子可能更直观地有帮助：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how the bindings are created according to both the sequential order of
    the vector and the order of the symbols defined in vector `[a b c]`. The symbol
    values are then printed out to the console.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意绑定是如何根据向量的顺序和定义在向量 `[a b c]` 中的符号顺序创建的。然后，符号值被打印到控制台。
- en: 'A list, which is a sequential data structure, can be similarly disassembled:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表，作为一种顺序数据结构，可以类似地分解：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Consider the same example of printing the coordinates of an airport, but this
    time we receive the data as a map rather than a tuple. The data has the following
    shape: `{:lat 48.9615, :lon 2.4372, :code ''LFPB'', :name "Paris Le Bourget Airport"}`.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑打印机场坐标的相同例子，但这次我们接收到的数据是一个映射而不是元组。数据具有以下形状：`{:lat 48.9615, :lon 2.4372, :code
    'LFPB', :name "Paris Le Bourget Airport"}`。
- en: 'We could write the following function:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写以下函数：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function retrieves the values from the `airport` map by using the keywords
    as functions in the `let` expression. We can spot the repetitive pattern when
    binding `lat`, `lon`, and `name`. Similarly, when the data structure we want to
    disassemble is associative (a `map`), we can use an associative *destructuring*
    technique. The function can be rewritten using associative destructuring, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数通过在 `let` 表达式中使用关键字作为函数来从 `airport` 映射中检索值。我们可以看到在绑定 `lat`、`lon` 和 `name`
    时出现的重复模式。同样，当我们想要分解的数据结构是关联的（一个 `map`）时，我们可以使用关联解构技术。函数可以用关联解构重写，如下所示：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this technique, we are creating bindings by mapping the symbols to the
    keys inside the map. The `lat` symbol now contains the value in the airport map
    at the key `:lat`, `lon` is mapped to the key `:lon`, and, finally, the `airport-name`
    symbol is mapped to the key `:name`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，我们通过将符号映射到映射中的键来创建绑定。现在 `lat` 符号包含机场映射中 `:lat` 键的值，`lon` 被映射到 `:lon`
    键，最后，`airport-name` 符号被映射到 `:name` 键。
- en: 'When the keys and symbols can all have the same name, there is a shorter syntax
    available:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当键和符号都可以有相同的名称时，有一个更短的语法可用：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding destructuring syntax indicates looking for the `lat`, `lon`, and
    `name` keys inside the `airport` map and binding them to symbols with the same
    name. The syntax might look a little bit surprising, but it is a widely used technique
    in Clojure. We will use it in the next exercise so that you can learn how to use
    it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的解构语法表示在 `airport` 映射中查找 `lat`、`lon` 和 `name` 键，并将它们绑定到具有相同名称的符号。语法可能看起来有点令人惊讶，但这在
    Clojure 中是一种广泛使用的技术。我们将在下一个练习中使用它，以便您可以学习如何使用它。
- en: 'Let''s see our final function in action:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的最终函数是如何工作的：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, the `print-coords` function destructures the airport
    `map` in the `let` expression and binds the values `48.9615`, `2.4372`, and `Paris
    Le Bourget Airport` to the symbols (respectively) `lat`, `lon`, and `name`. Those
    values are then printed out to the console with the `println` function (which
    returns `nil`).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`print-coords` 函数在 `let` 表达式中解构了机场 `map`，并将值 `48.9615`、`2.4372` 和 `Paris
    Le Bourget Airport` 分别绑定到符号（分别）`lat`、`lon` 和 `name`。然后，这些值通过 `println` 函数（它返回
    `nil`）打印到控制台。
- en: Now that we've discovered the basics of destructuring and its utility, we can
    move on to the REPL, start practicing, and learn even more advanced destructuring
    techniques.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经发现了解构的基础及其用途，我们可以继续学习到 REPL，开始练习，并学习更多高级的解构技术。
- en: 'Exercise 3.01: Parsing Fly Vector''s Data with Sequential Destructuring'
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.01：使用顺序解构解析 Fly Vector 的数据
- en: 'For the purpose of this exercise, imagine that we are building a flight-booking
    platform application. For our first prototype, we just want to parse and print
    flight data that we receive from our partners. Our first partner, Fly Vector,
    has not yet discovered the power of associative data structures and they send
    us all their data in the form of Vectors. Luckily, they have comprehensive documentation.
    I have done the heavy lifting of reading the hundreds of pages of the data format
    specification for you and here is what it boils down to:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个练习的目的，假设我们正在构建一个航班预订平台应用程序。对于我们的第一个原型，我们只想解析和打印我们从合作伙伴那里收到的航班数据。我们的第一个合作伙伴
    Fly Vector 尚未发现关联数据结构的威力，他们以向量的形式发送给我们所有数据。幸运的是，他们有全面的文档。我已经为你阅读了数百页的数据格式规范，以下是总结：
- en: 'A coordinate point is a tuple of latitude and longitude, for example: `[48.9615, 2.4372]`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坐标点是由纬度和经度组成的元组，例如：`[48.9615, 2.4372]`。
- en: 'A flight is a tuple of two coordinate points, for example: `[[48.9615, 2.4372],
    [37.742, -25.6976]]`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 航班是由两个坐标点组成的元组，例如：`[[48.9615, 2.4372], [37.742, -25.6976]]`。
- en: 'A booking consists of some information followed by one or multiple flights
    (up to three). The first item is Fly Vector''s internal ID for the booking, the
    second item is the name of the passenger, and the third is some sensitive information
    that Fly Vector asked us not to parse or even look at (they couldn''t update their
    system to remove the information). Finally, the rest of the vector consists of
    the flight coordinates data, for example:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预订由一些信息后跟一个或多个航班（最多三个）组成。第一个项目是 Fly Vector 的预订内部 ID，第二个项目是乘客的名字，第三个是 Fly Vector
    要求我们不要解析或甚至查看的敏感信息（他们无法更新他们的系统以删除信息）。最后，向量中的其余部分是航班坐标数据，例如：
- en: '[PRE8]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That should be enough information for us to develop the prototype, so let''s
    get started:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该足够我们开发原型了，所以让我们开始吧：
- en: 'Open a REPL and bind the sample booking data to the `booking` symbol:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个 REPL，并将样本预订数据绑定到 `booking` 符号：
- en: '[PRE9]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Start developing our parsing function by experimenting with destructuring.
    Create a `let` block and define the binding as follows, printing out the result
    with `println`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实验解构来开始开发我们的解析函数。创建一个 `let` 块，并定义如下绑定，使用 `println` 打印结果：
- en: '[PRE10]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that `flight3` was bound to the value `nil`. This is because the data
    is shorter than the bindings defined, and it is both valid and useful to be able
    to bind only values that exist.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `flight3` 被绑定到值 `nil`。这是因为数据比定义的绑定短，能够只绑定存在的值是既有效又有用的。
- en: Similarly, if the booking vector contained extra data, it would be ignored.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似地，如果预订向量包含额外数据，它将被忽略。
- en: 'Remember that `conj` takes a collection and some elements as arguments and
    returns a new collection with those elements added to the collection. Add two
    flights in the booking vector with `conj` and parse the data using the same destructuring
    expression:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住 `conj` 函数接受一个集合和一些元素作为参数，并返回一个新集合，其中包含那些添加到集合中的元素。使用 `conj` 在预订向量中添加两个航班，并使用相同的解构表达式解析数据：
- en: '[PRE11]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice how the last flight was simply ignored and not printed out. That's another
    useful trait of destructuring and another sign of Clojure's dynamism and practicality.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到最后一次航班被简单地忽略而没有打印出来。这是解构的另一个有用特性，也是 Clojure 动态性和实用性的另一个标志。
- en: 'In the data received, we don''t really care about the Fly Vector internal ID
    and we don''t want to parse the sensitive information. This can be simply ignored
    by using an underscore, `_`, instead of a symbol:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接收到的数据中，我们并不关心 Fly Vector 的内部 ID，我们也不希望解析敏感信息。这可以通过使用下划线 `_` 而不是符号来简单地忽略：
- en: '[PRE12]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Great, we now understand how to ignore some parts of the data with destructuring.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太好了，我们现在理解了如何使用解构忽略数据的一些部分。
- en: 'Just printing the array of coordinates is not very readable, so until we have
    a better way of printing out flights, we would like to simply display the number
    of flights in the booking. Surely, we could test `flight1`, `flight2`, and `flight3`
    for the presence of a value but there''s another aspect of destructuring that
    we could use: the "remaining" parts of the sequence. By using the `&` character
    followed by a symbol, we can bind the remaining part of a sequence to a given
    symbol.'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仅打印坐标数组并不是很易读，所以直到我们找到更好的打印航班的方法，我们只想简单地显示预订中的航班数量。当然，我们可以测试`flight1`、`flight2`和`flight3`是否存在值，但解构还有另一个我们可以使用的方面：序列的“剩余”部分。通过使用`&`字符后跟一个符号，我们可以将序列的剩余部分绑定到给定的符号。
- en: 'Bind the `flights` sequence to a `flights` symbol by using the `&` character,
    then display the number of flights as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`&`字符将`flights`序列绑定到`flights`符号，然后按以下方式显示航班数量：
- en: '[PRE13]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that `flights` is now a collection and, therefore, we can use the `count`
    function with it.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`flights`现在是一个集合，因此我们可以使用`count`函数与它一起使用。
- en: Destructuring is very powerful and can also disassemble nested data structures.
    To parse and print the flight details, let's create a separate function to keep
    the code clear and readable.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解构非常强大，也可以解构嵌套的数据结构。为了解析和打印航班详情，让我们创建一个单独的函数来保持代码的清晰和可读性。
- en: 'Create a `print-flight` function that disassembles a flight path using nested
    destructuring and print out a nicely formatted flight itinerary:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`print-flight`函数，使用嵌套解构解构航班路径，并打印出一个格式良好的航班行程单：
- en: '[PRE14]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice how we dug into the nested vectors contained in `flight` to retrieve
    the coordinate values inside the coordinate tuples, by simply using nested vector
    literal notation. However, the nested vectors in the `let` bindings can be slightly
    hard to read.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们是如何通过简单地使用嵌套向量字面量表示法来挖掘`flight`中包含的嵌套向量，以检索坐标元组内的坐标值。然而，`let`绑定中的嵌套向量稍微有点难以阅读。
- en: 'Rewrite the `print-flight` function by decomposing the steps in multiple `let`
    bindings:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过分解多个`let`绑定来重写`print-flight`函数：
- en: '[PRE15]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding example, we have created two intermediate bindings using sequential
    destructuring: `departure` and `arrival`. Those two bindings contain coordinates
    tuples that we can destructure further to create the latitude and longitude bindings
    `lat1`, `lon1`, `lat2`, and `lon2`.'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用顺序解构创建了两个中间绑定：`departure`和`arrival`。这两个绑定包含坐标元组，我们可以进一步解构以创建纬度和经度绑定`lat1`、`lon1`、`lat2`和`lon2`。
- en: 'Finally, let''s write the `print-booking` function by combining the code we
    have written so far:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们通过组合我们迄今为止编写的代码来编写`print-booking`函数：
- en: '[PRE16]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Great job! In this exercise, we've successfully used *sequential destructuring*
    to parse and retrieve data from a vector and improve the readability and conciseness
    of our code. Now, let's move on to the next exercise, where we will use *associative
    destructuring*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！在这个练习中，我们成功地使用了*顺序解构*来解析和检索向量中的数据，并提高了我们代码的可读性和简洁性。现在，让我们继续进行下一个练习，我们将使用*关联解构*。
- en: 'Exercise 3.02: Parsing MapJet Data with Associative Destructuring'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.02：使用关联解构解析MapJet数据
- en: Let's continue with our flight booking platform application. Now we would like
    to develop the same parser for another partner called MapJet. You might have guessed,
    MapJet has discovered the power of associative data structures and are sending
    us nice and intelligible data structures, which consist of both maps and vectors.
    Now, the data is self-explanatory and even if MapJet provides very detailed documentation,
    we won't even bother reading it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续我们的航班预订平台应用程序。现在我们想要为另一个名为MapJet的合作伙伴开发相同的解析器。你可能已经猜到了，MapJet发现了关联数据结构的威力，并正在向我们发送既好又易于理解的数据结构，这些数据结构由地图和向量组成。现在，数据是自我解释的，即使MapJet提供了非常详细的文档，我们也不会费心去阅读它。
- en: 'Let''s have a look at the data shape of a sample booking:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个样本预订的数据形状：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'First, let''s agree on the fact that maps are a great way to exchange data.
    They are very readable for us humans, and simple to parse for our programs. Now,
    let''s get back to the REPL and see how associative destructuring can help us
    manipulate the data:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们同意地图是交换数据的好方法。对我们人类来说，它们非常易读，并且对我们的程序来说解析起来很简单。现在，让我们回到REPL，看看关联解构如何帮助我们操作数据：
- en: 'Bind the sample booking map to the `mapjet-booking` symbol as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将样本预订映射绑定到 `mapjet-booking` 符号，如下所示：
- en: '[PRE18]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using associative destructuring, print the booking summary as we did for Fly
    Vector (the name of the customer and the number of flights):'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用关联解构，以与 Fly Vector 相同的方式打印预订摘要（客户名称和航班数量）：
- en: '[PRE19]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By using the shorter and non-repetitive syntax with `:keys`, we were able to
    fetch the keys inside the map and bind their values to symbols with the same name.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过使用较短的、非重复的 `:keys` 语法，我们能够获取映射中的键并将它们的值绑定到具有相同名称的符号。
- en: 'Let''s write a `print-mapjet-flight` function to print the flight details:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个 `print-mapjet-flight` 函数来打印航班详情：
- en: '[PRE20]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that we cannot use the shorter syntax for extracting coordinates because
    the names `lat` and `lon` would conflict; therefore, we used the normal syntax,
    allowing us to explicitly declare a new binding to symbols with different names.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们无法使用较短的语法来提取坐标，因为 `lat` 和 `lon` 名称会冲突；因此，我们使用了正常的语法，允许我们显式地声明具有不同名称的新绑定。
- en: As with vectors, we can nest destructuring expressions, and even combine the
    two techniques.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与向量一样，我们可以嵌套解构表达式，甚至可以将两种技术结合起来。
- en: 'Let''s rewrite the `print-mapjet-flight` function, but this time we are going
    to nest our associative destructuring expressions:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重写 `print-mapjet-flight` 函数，但这次我们将嵌套我们的关联解构表达式：
- en: '[PRE21]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding example is slightly complicated to read so don''t worry if it
    looks a bit confusing at first. Think of the key of a destructuring map as the
    target, and the source as the value, as follows: `{target1 source1 target2 source2}`.
    The target can either be a symbol, or another destructuring map like this: `{{target3
    source3} source1 {target4 source4} source2}`. Notice, in this last expression,
    how we just bind values to the symbols in the innermost map (`target3` and `target4`).
    This is what we just did in the `print-mapjet-flight` function: we extracted the
    nested values of latitude and longitude for both coordinate points.'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的例子稍微有点复杂，所以如果一开始看起来有点混乱，请不要担心。将解构映射的键视为目标，将源视为值，如下所示：`{target1 source1 target2
    source2}`。目标可以是符号，也可以是另一个类似这样的解构映射：`{{target3 source3} source1 {target4 source4}
    source2}`。注意，在最后一个表达式中，我们是如何仅将值绑定到最内层映射中的符号（`target3` 和 `target4`）。这正是我们在 `print-mapjet-flight`
    函数中所做的：我们提取了两个坐标点的纬度和经度的嵌套值。
- en: 'Write the final function for printing MapJet bookings, using the code to print
    the booking summary to the console. It should produce a similar output to Fly
    Vector''s `print-booking` function, first printing the number of flights and then
    printing each flight individually with `print-mapjet-flight` as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写用于打印 MapJet 预订的最终函数，使用代码将预订摘要打印到控制台。它应该产生与 Fly Vector 的 `print-booking` 函数类似的输出，首先打印航班数量，然后逐个打印每个航班，如下所示：
- en: '[PRE22]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE23]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It works! We have now finished our first prototype. In this exercise, we have
    implemented a `Map` parser that prints out data that has been destructured to
    the console. Well done!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它工作了！我们现在已经完成了第一个原型。在这个练习中，我们实现了一个 `Map` 解析器，将解构后的数据打印到控制台。做得好！
- en: Destructuring techniques are essential because they can make our code more concise
    and more readable. Additionally, the data that our programs have to deal with
    often comes from external data sources, and we don't always own the shape of the
    data we need to handle. Having a powerful tool to dig into various data structures
    significantly improves our quality of life as programmers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 解构技术是必不可少的，因为它们可以使我们的代码更加简洁和易于阅读。此外，我们的程序必须处理的数据通常来自外部数据源，我们并不总是拥有我们需要处理的数据的形状。拥有一个强大的工具来深入各种数据结构，可以显著提高我们作为程序员的生存质量。
- en: However, the code we have written in the previous exercise feels somehow repetitive;
    the two `print-booking` functions, for example, have a lot in common. With what
    we currently know, it would be difficult to refactor this code. But don't worry,
    the techniques we are going to learn in the next topics will allow you to write
    even more elegant code, with less repetition, less code, and therefore fewer bugs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在上一个练习中编写的代码感觉有点重复；例如，两个 `print-booking` 函数有很多共同之处。根据我们目前所知，重构此代码会有点困难。但不要担心，我们将在下一主题中学习的技巧将允许你编写更加优雅的代码，更少重复，更少代码，因此更少错误。
- en: Advanced Call Signatures
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级调用签名
- en: So far, we have been declaring functions with one arity (with only a fixed number
    of arguments), and simply binding the arguments passed to a function to some parameter
    names. However, Clojure has a few techniques to allow more flexibility when calling
    functions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用单一arity（只有固定数量的参数）声明函数，并且简单地将传递给函数的参数绑定到一些参数名上。然而，Clojure有一些技术可以在调用函数时提供更多的灵活性。
- en: Destructuring Function Parameters
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Destructuring Function Parameters
- en: 'First, everything we have just learned about destructuring applies to function
    parameters. Yes, you read that correctly – we can use destructuring techniques
    right in the function parameter declaration! As promised, here''s our first stab
    at refactoring the `print-flight` functions from the previous exercise. Observe,
    in the following example, how sequential destructuring is used directly in the
    function parameters:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们刚刚学到的关于解构的知识也适用于函数参数。是的，你读得对——我们可以在函数参数声明中使用解构技术！正如承诺的那样，以下是我们对之前练习中的`print-flight`函数进行重构的第一个尝试。观察以下示例，看看顺序解构是如何直接在函数参数中使用的：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Notice how we got rid of the `let` expression. Similarly, we can do the same
    for `print-mapjet-flight`, with associative destructuring used in the function
    parameters:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何移除了`let`表达式的。同样地，我们也可以对`print-mapjet-flight`做同样的处理，在函数参数中使用关联解构：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once again, we got rid of the `let` expression and destructured the parameter
    right away from the function arguments. Great – that is one new way of defining
    function parameters and improving our code even further.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们移除了`let`表达式，并立即从函数参数中解构参数。太好了——这是定义函数参数和进一步改进我们代码的一种新方法。
- en: Arity Overloading
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arity Overloading
- en: 'Second, Clojure supports "arity overloading," which means that we can *overload*
    a function with another function of the same name by specifying extra parameters
    to the new function. Those two functions have the same name but different implementations,
    and the function body to execute is chosen based on the number of arguments provided
    upon a function call. Here is an example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，Clojure支持“arity overloading”，这意味着我们可以通过指定新函数的额外参数来用另一个具有相同名称的函数来*overload*该函数。这两个函数具有相同的名称但不同的实现，执行函数体是根据函数调用提供的参数数量来选择的。以下是一个示例：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice how the different function implementations are defined. In the `no-overloading`
    function, which is how we are used to creating functions, there are no extra parentheses
    around the parameter declaration (which comes just after the function name). Whereas
    in the `overloading` function, each implementation is surrounded by parentheses,
    starting with the parameter declaration.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不同的函数实现是如何定义的。在`no-overloading`函数中，这是我们习惯创建函数的方式，参数声明（紧随函数名之后）周围没有额外的括号。而`overloading`函数中，每个实现都由括号包围，从参数声明开始。
- en: 'Let''s see how the multi-arity `overloading` function plays out:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看多arity的`overloading`函数是如何发挥作用的：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, no arguments were passed; therefore, the first implementation
    of the `overloading` function is called.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，没有传递任何参数；因此，调用`overloading`函数的第一个实现。
- en: 'Consider the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this case, one argument is passed to the `overloading` function, so the second
    implementation is called.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个参数被传递给`overloading`函数，因此调用第二个实现。
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, two arguments are passed, so the third implementation
    of the `overloading` function is called.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，传递了两个参数，因此调用`overloading`函数的第三个实现。
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finally, an incorrect number of arguments produce the usual arity exception.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，传递错误数量的参数会产生通常的arity异常。
- en: You might (legitimately) wonder how this is useful, and why not just declare
    different functions? In fact, when defining multiple arities for the same function,
    you are saying that the functions are essentially the same, that they are doing
    a similar job, but the execution slightly varies based on the number of arguments.
    It can also be useful to provide default values.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会（合理地）想知道这有什么用，为什么不直接声明不同的函数呢？实际上，当为同一函数定义多个arity时，你是在说这些函数本质上相同，它们在做相似的工作，但执行略有不同，这取决于参数的数量。提供默认值也可能很有用。
- en: 'Consider the following code for a new little fantasy game called `strike` function
    to compute the new state of an `enemy` entity:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，这是一个名为`strike`的新小型幻想游戏函数，用于计算`enemy`实体的新状态：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding example, we start by defining a `HashMap` and binding it to
    the `weapon-damage` symbol. The second expression is the definition of the `strike`
    function, which subtracts damage from an `enemy` entity, retrieving the amount
    of damage in the `weapon-damage` map. Observe that the `strike` function has two
    implementations. The first implementation contains only one parameter, `enemy`,
    and the second implementation has two parameters: `enemy` and `weapon`. Notice
    how the first implementation is calling the second one by providing an extra parameter.
    Therefore, when calling the `strike` function with only one argument, the default
    value, `:fists`, will be provided:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们首先定义了一个 `HashMap` 并将其绑定到 `weapon-damage` 符号。第二个表达式是 `strike` 函数的定义，它从
    `enemy` 实体中减去伤害，并在 `weapon-damage` 映射中检索伤害量。注意 `strike` 函数有两个实现。第一个实现只包含一个参数 `enemy`，第二个实现有两个参数：`enemy`
    和 `weapon`。注意第一个实现是如何通过提供一个额外的参数来调用第二个实现的。因此，当只传递一个参数调用 `strike` 函数时，将提供默认值 `:fists`：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Observe that the function was called with one parameter only (the `enemy` entity),
    which therefore went through the one-parameter implementation of the function,
    using `:fists` as a default value and returning an enemy with 90 points of health
    left (because fists do 10 points worth of damage):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到函数只使用了一个参数（`enemy` 实体），因此它通过了函数的单参数实现，使用 `:fists` 作为默认值，并返回一个剩余90点生命值的敌人（因为拳头造成了10点伤害）：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding example, the `strike` function was called directly with the
    two-arity implementation, because the second parameter, `weapon`, was explicitly
    provided.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`strike` 函数直接使用了双参数实现，因为第二个参数 `weapon` 被明确提供。
- en: Variadic Functions
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变参数函数
- en: There is a final secret left to reveal regarding function parameters. With what
    we have learned about function arity, how would you define the parameters of the
    `str` function, for example?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 关于函数参数，还有一个最后的秘密要揭示。根据我们关于函数参数的知识，你将如何定义 `str` 函数的参数，例如？
- en: 'It seems to take an infinite number of parameters. You might remember using
    `str` like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它似乎可以接受无限数量的参数。你可能记得这样使用 `str`：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: But surely, it isn't implemented with overloading like this `(defn str ([s]
    ...) ([s1 s2] ...) ([s1 s2 s3] ...) ([s1 s2 s3 s4] …))` and so on… Then, what
    is happening in this case?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但当然，它并不是通过这样的重载来实现的 `(defn str ([s] ...) ([s1 s2] ...) ([s1 s2 s3] ...) ([s1
    s2 s3 s4] …))` 等等……那么，在这种情况下发生了什么？
- en: This is the destructuring technique coming back into play. Remember that we
    can use the `&` character to bind the remainder of a sequence to a data structure?
    It works similarly with function arguments, and we can create a data structure
    from the arguments passed to a function with the `&` character. This is how you
    can create variadic functions (functions that take a variable number of arguments),
    and this is how the `str` function is implemented.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是解构技术再次发挥作用。记住，我们可以使用 `&` 字符将序列的其余部分绑定到数据结构？这与函数参数的工作方式类似，我们可以使用 `&` 字符从传递给函数的参数中创建数据结构。这就是如何创建可变参数函数（接受可变数量参数的函数），这也是
    `str` 函数是如何实现的。
- en: 'Look at how the documentation describes the `str` function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 看看文档是如何描述 `str` 函数的：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice the declaration of its different arities. It accepts either no element,
    `[]`, one element, `[x]`, or any number of elements, `[x & ys]`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意其不同参数的声明。它接受零个元素 `[]`，一个元素 `[x]` 或任意数量的元素 `[x & ys]`。
- en: 'Let''s try to use this new knowledge to create a function that prints a welcome
    message to the new player of `Parenthmazes`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用这些新知识来创建一个函数，用于向 `Parenthmazes` 的新玩家打印欢迎信息：
- en: '[PRE36]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Observe how we used the destructuring technique right in the function parameters,
    binding any arguments that come after `player` to the `friends` collection. Now,
    let''s try to use our function with one and multiple arguments:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 观察我们如何在函数参数中直接使用解构技术，将 `player` 之后的所有参数绑定到 `friends` 集合。现在，让我们尝试使用我们的函数，传入一个或多个参数：
- en: '[PRE37]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice that when more than one argument is passed to the `welcome` function,
    the `friends` symbol is bound to a sequence containing the rest of the arguments.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当向 `welcome` 函数传递多个参数时，`friends` 符号被绑定到一个包含其余参数的序列中。
- en: Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `seq` function can be used to get a sequence from a collection. In the `welcome`
    function, we use the `seq` function to test whether a collection contains elements.
    That's because `seq` returns `nil` when the collection passed as a parameter is
    empty. `(if (seq (coll))` is a commonly used pattern that you should use instead
    of `(if (not (empty? coll)))`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`seq`函数可以用来从集合中获取序列。在`welcome`函数中，我们使用`seq`函数来测试集合是否包含元素。这是因为`seq`在作为参数传递的集合为空时返回`nil`。`(if
    (seq (coll)))`是一个常用的模式，你应该用它来代替`(if (not (empty? coll)))`。'
- en: 'We could improve this function slightly. Instead of testing whether `friends`
    is empty, we could also take advantage of the multi-arity technique:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍微改进这个函数。我们不仅可以测试`friends`是否为空，还可以利用多重参数技术：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice how, this time, two `welcome` functions were defined, one with only one
    `player` parameter, and a second one with an unlimited number of parameters that
    will be bound to the `friends` symbol. Separating the functions like this improves
    the clarity of the code by being more explicit about the intent of the function
    as well as removing the conditional expression with `when`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次，定义了两个`welcome`函数，一个只有一个`player`参数，另一个有无限数量的参数，这些参数将被绑定到`friends`符号。以这种方式分离函数可以提高代码的清晰度，更明确地表达函数的意图，并移除带有`when`的条件表达式。
- en: 'Let''s try the `welcome` function one last time:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们最后一次尝试`welcome`函数：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Great – the function call was dispatched to the right function according to
    the number of parameters.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——根据参数的数量，函数调用被调度到了正确的函数。
- en: 'Exercise 3.03: Multi-arity and Destructuring with Parenthmazes'
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.03：使用括号迷宫的多重参数和结构化
- en: In this exercise, we will continue working on the `Parenthmazes` game by adding
    new features, notably improving our `strike` function to implement a healing mechanism.
    We would also like to add the concept of armor, which can reduce the damage suffered.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将继续通过添加新功能来完善`Parenthmazes`游戏，特别是改进我们的`strike`函数以实现治疗机制。我们还想添加护甲的概念，它可以减少受到的伤害。
- en: Get ready for the great battle between Gnomes and Trolls in this new version
    of `Parenthmazes`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 准备在这个`Parenthmazes`新版本中，迎接侏儒和巨魔之间伟大战斗的到来。
- en: 'To begin, start a REPL and your favorite code editor next to it, and create
    the `weapon-damage` map, which contains damage information for each weapon:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，启动REPL和旁边的你最喜欢的代码编辑器，创建`weapon-damage`映射，其中包含每种武器的伤害信息：
- en: '[PRE40]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We need this map to look up the amount of damage done when a player strikes
    an enemy.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要这个映射来查找玩家打击敌人时所造成的伤害量。
- en: 'Now, let''s create the `strike` function, which will handle healing when the
    enemy is in the same camp as us (let''s assume for now that we picked the Gnomes''
    side):'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建`strike`函数，该函数将处理当敌人与我们处于同一阵营时（现在我们假设我们选择了侏儒阵营）的治疗：
- en: '[PRE41]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding function, the new code of the `strike` function is to retrieve
    which side the target is on by looking up the `:camp` key in the `target` entity.
    If the `target` belongs to the Gnomes camp, we use the `+` function to increase
    the health in the `target` entity by x number of `points`. Otherwise, we use `-`
    to decrease the number of health points in the `target` entity.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的函数中，`strike`函数的新代码是通过查找`target`实体的`:camp`键来检索目标所在的阵营。如果`target`属于侏儒阵营，我们使用`+`函数在`target`实体中增加x个`points`的健康值。否则，我们使用`-`来减少`target`实体中的健康点数。
- en: 'Create an `enemy` entity and test our newly created `strike` function as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`enemy`实体，并按照以下方式测试我们新创建的`strike`函数：
- en: '[PRE42]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Health points were subtracted successfully. Let's see what happens with a friendly
    player.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 健康点数已成功扣除。让我们看看友军玩家会发生什么。
- en: 'Create an `ally` entity that belongs to the `:gnomes` camp, and test our newly
    created `strike` function as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个属于`:gnomes`阵营的`ally`实体，并按照以下方式测试我们新创建的`strike`函数：
- en: '[PRE43]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Health points were added successfully!
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 健康点数已成功添加！
- en: Now that we have got the shell of our `strike` function, let's amend it to implement
    the armor functionality. The `target` entity can contain an `:armor` key, which
    contains a coefficient used to calculate the final amount of damage. The bigger
    the number, the better the armor. For example, an armor value of 0.8 for a strike
    of 100 points results in 20 damage points being inflicted. An armor value of 0.1
    results in 90 damage points being inflicted, 0 means no armor, and 1 means invincible.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经得到了`strike`函数的框架，让我们修改它以实现护甲功能。`target`实体可以包含一个`:armor`键，该键包含一个用于计算最终伤害量的系数。数字越大，护甲越好。例如，100点打击的护甲值为0.8会导致造成20点伤害。护甲值为0.1会导致造成90点伤害，0表示没有护甲，1表示无敌。
- en: 'Change the amount of damage inflicted on the target by calculating the damage
    with the `:armor` value in the `target` entity. If the target has no armor value,
    set it to `0`. To improve readability, we will use a `let` binding to decompose
    the damage calculation:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过计算`target`实体中的`:armor`值来改变对目标造成的伤害量。如果目标没有护甲值，将其设置为`0`。为了提高可读性，我们将使用`let`绑定来分解伤害计算：
- en: '[PRE44]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the second branching of the `if` expression, we used a `let` expression to
    assign a default value to `armor` by using `or`. If `(:armor target)` is nil,
    the value of armor is 0\. The second binding contains the reduced damage based
    on the armor value.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`if`表达式的第二个分支中，我们使用`let`表达式通过`or`为`armor`分配一个默认值。如果`(:armor target)`是`nil`，则护甲的值为0。第二个绑定包含基于护甲值的减少伤害。
- en: 'Test the `strike` function to see if it still works with no armor:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试`strike`函数以查看它是否在没有护甲的情况下仍然工作：
- en: '[PRE45]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: A cast-iron saucepan does 150 damage, and 250 minus 150 is indeed `100`. Great
    – it works. Let's move on.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 铸铁锅会造成150点伤害，250减去150确实等于`100`。太好了，它起作用了。我们继续吧。
- en: 'Redefine the `enemy` binding to add an armor value and test our `strike` function
    once again:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新定义`enemy`绑定以添加护甲值，并再次测试我们的`strike`函数：
- en: '[PRE46]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Great – the damage seems to be reduced according to the armor coefficient. Now
    we would like to use our associative destructuring technique to retrieve the `camp`
    and `armor` values directly from the function parameters, and reduce the amount
    of code in the function's body. The only problem we have is that we still need
    to return an updated version of the `target` entity, but how could we both destructure
    the `target` entity and keep a reference of the `target` parameter? Clojure has
    your back – you can use the special key `:as` to bind the destructured map to
    a specific name.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太好了，伤害似乎根据护甲系数减少了。现在我们想使用我们的关联解构技术直接从函数参数中检索`camp`和`armor`值，并减少函数体内的代码量。我们唯一的问题是，我们仍然需要返回一个更新后的`target`实体，但我们如何同时解构`target`实体并保持对`target`参数的引用？Clojure会支持你——你可以使用特殊键`:as`将解构的映射绑定到特定的名称。
- en: 'Modify the `strike` function to use associative destructuring in the function''s
    parameters. Use the special key `:as` to bind the map passed as an argument to
    the symbol target:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`strike`函数以在函数参数中使用关联解构。使用特殊键`:as`将传递给函数的映射绑定到符号`target`：
- en: '[PRE47]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'There is one other useful feature in associative destructuring that we could
    take advantage of: the special key `:or`. It permits us to provide a default value
    for when a key that we want to extract isn''t found (instead of binding to `nil`).'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关联解构中还有一个有用的特性我们可以利用：特殊键`:or`。它允许我们在想要提取的键找不到时提供一个默认值（而不是绑定到`nil`）。
- en: 'Add the special key `:or` in the destructured map to provide a default value
    to the armor key in the target map, add an extra arity to make the `weapon` parameter
    optional, and finally add some documentation, as follows. Don''t forget to wrap
    each function definition with its own set of parentheses:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解构映射中添加特殊键`:or`，为目标映射中的护甲键提供一个默认值，增加一个额外的参数来使`weapon`参数可选，最后添加一些文档说明，如下。别忘了用自己的一组括号包裹每个函数定义：
- en: '[PRE48]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Ensure that your function still works as expected by testing the different
    scenarios as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下方式测试不同的场景以确保你的函数仍然按预期工作：
- en: '[PRE49]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: That concludes this exercise. If you look again at the `strike` function you've
    just written, it is using some advanced Clojure features, including destructuring,
    multi-arity functions, and reading and updating maps. By passing a function as
    an argument in the `update` function, we also used the concept of higher-order
    functions, which we will explain further in the next section.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了这个练习。如果你再次看看你刚才编写的`strike`函数，它使用了Clojure的一些高级功能，包括解构、多态函数以及读取和更新映射。通过在`update`函数中传递一个函数作为参数，我们也使用了高阶函数的概念，我们将在下一节中进一步解释。
- en: Higher-Order Programming
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶编程
- en: Higher-order programming means that programs, and specifically functions, can
    operate on other programs or functions, as opposed to first-order programming,
    where functions operate on data elements such as strings, numbers, and data structures.
    In practice, it means that a function can take some programming logic as a parameter
    (another function) and/or return some programming logic to be eventually executed.
    It is a powerful feature that allows us to compose single, modular units of logic
    in our programs to reduce duplication and promote the reusability of code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶编程意味着程序，特别是函数，可以操作其他程序或函数，这与一阶编程相反，在一阶编程中，函数操作的是诸如字符串、数字和数据结构这样的数据元素。在实践中，这意味着一个函数可以接受一些编程逻辑（另一个函数）作为参数，并/或返回一些编程逻辑以供最终执行。这是一个强大的功能，它允许我们在程序中组合单个、模块化的逻辑单元，以减少重复并提高代码的可重用性。
- en: Writing simpler functions increases their modularity. We want to create simple
    units of functionality that can be used as small bricks to build our programs
    with. Writing pure functions reduces the complexity of those bricks, and allows
    us to craft better, sturdier programs. Pure functions are functions that don't
    alter the state of our program – they produce no side effects; a pure function
    also always returns the same value when given the exact same parameters. This
    combination makes pure functions easy to reason about, build upon, and test. Although
    Clojure offers ways to modify the state of our program, we should write and use
    pure functions as much as possible.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 编写更简单的函数可以增加它们的模块化。我们希望创建简单的功能单元，可以用作小砖块来构建我们的程序。编写纯函数可以降低这些砖块的复杂性，并允许我们构建更好、更坚固的程序。纯函数是不改变我们程序状态的函数——它们不会产生副作用；纯函数在给出完全相同的参数时也总是返回相同的值。这种组合使得纯函数易于推理、构建和测试。尽管Clojure提供了修改我们程序状态的方法，但我们应尽可能多地编写和使用纯函数。
- en: First-Class Functions
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 首等函数
- en: 'Let''s demonstrate the use of functions as parameters. We used functions as
    parameters in *Exercise 2.01*, *The Obfuscation Machine* of *Chapter 2*, *Data
    Types and Immutability*, with the `clojure.string/replace` function, and also
    in the preceding exercise, with the `update` function. For example, to divide
    a value by `2` in a `HashMap`, you can pass an anonymous function that does the
    division as an argument to the `update` function:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们演示将函数作为参数的使用。我们在*第二章*的*练习2.01*，*混淆机*中使用了函数作为参数，这是关于*数据类型和不可变性*的章节，使用了`clojure.string/replace`函数，也在前面的练习中使用了`update`函数。例如，要在`HashMap`中除以`2`，你可以传递一个匿名函数作为`update`函数的参数来进行除法：
- en: '[PRE50]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Even better, you could simply pass the divide function, `/`, with the argument
    `2`, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，你可以简单地传递除法函数`/`，并带上参数`2`，如下所示：
- en: '[PRE51]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Notice that `update` will pass the old value as the first argument to the `/`
    function (here, the old value is `1.0`) as well as all the extra arguments (here,
    `2`).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`update`将把旧值作为第一个参数传递给`/`函数（在这里，旧值是`1.0`），以及所有额外的参数（在这里，`2`）。
- en: 'You can operate on any kind of value. For example, to invert the value of a
    Boolean, use the `not` function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以操作任何类型的值。例如，要反转布尔值的值，使用`not`函数：
- en: '[PRE52]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As we''ve just seen, `update` can take a function as a parameter, but we could
    also define our own function that takes a function and applies it to a given parameter:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，`update`可以接受一个函数作为参数，但我们也可以定义自己的函数，该函数接受一个函数并将其应用于给定的参数：
- en: '[PRE53]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the preceding example, `operate` takes a function, `f`, as a parameter and
    calls it with the second parameter, `x`. Not very useful, but it shows how simple
    it is to pass and call a function passed as a parameter. If we wanted to pass
    any number of arguments, we could use the `&` character as we learned in the previous
    topic about destructuring:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`operate` 函数接受一个函数 `f` 作为参数，并用第二个参数 `x` 调用它。虽然不是很实用，但它展示了传递和调用作为参数传递的函数是多么简单。如果我们想传递任意数量的参数，我们可以使用我们在之前关于解构的章节中学到的
    `&` 字符：
- en: '[PRE54]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This time, `operate` seems to accept any number of arguments, but the function
    call fails because `args` is a sequence. That''s because we applied the `f` function
    to the `args` sequence directly, when what we really wanted was to apply `f` using
    each element of the sequence as an argument. There is a special function to disassemble
    a sequence and apply a function to that sequence''s elements – the `apply` function:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`operate` 似乎可以接受任意数量的参数，但函数调用失败，因为 `args` 是一个序列。这是因为我们直接将 `f` 函数应用于 `args`
    序列，而我们真正想要的是使用序列的每个元素作为参数来应用 `f`。有一个特殊函数可以解包序列并将函数应用于该序列的元素——那就是 `apply` 函数：
- en: '[PRE55]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Notice how `+` does not work on a vector, but by using apply, we call `+`, passing
    each element of the vector as an argument to `+`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `+` 在向量上不工作，但通过使用 `apply`，我们调用 `+`，将向量的每个元素作为参数传递给 `+`。
- en: 'We can, therefore, use `apply` in our `operate` function to have a fully working
    function that takes a function, `f`, as a parameter and calls `f` with the rest
    of the parameters, `args`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在 `operate` 函数中使用 `apply` 来拥有一个完全工作的函数，该函数接受一个函数 `f` 作为参数，并用剩余的参数 `args`
    调用 `f`：
- en: '[PRE56]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It works! The `str` function was applied to the arguments passed to `str`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 它成功了！`str` 函数被应用于传递给 `str` 的参数。
- en: 'The ability to pass a function as a parameter is one aspect of higher-order
    functions, but another aspect is the ability of functions to *return* other functions.
    Consider the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将函数作为参数传递是高阶函数的一个方面，但另一个方面是函数能够 *返回* 其他函数。考虑以下代码：
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `shuffle` function shuffles an array by sorting its elements randomly,
    and we then take the first element out of it. In other words, the `random-fn`
    function returns a random function from the `[+ - * /]` collection. Notice that
    the `random-fn` function does not take any parameters:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`shuffle` 函数通过随机排序数组元素来打乱数组，然后我们从其中取出第一个元素。换句话说，`random-fn` 函数从 `[+ - * /]`
    集合中返回一个随机函数。请注意，`random-fn` 函数不接收任何参数：'
- en: '[PRE58]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'But the function returned by `random-fn` expects parameters:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `random-fn` 返回的函数期望参数：
- en: '[PRE59]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the preceding code, `(random-fn)` returned `-` so `3` was subtracted from
    `2`, which results in `-1`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`(random-fn)` 返回了 `-`，所以从 `2` 中减去 `3`，结果是 `-1`。
- en: 'You can use the `fn?` function to check whether a value passed as a parameter
    is a function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `fn?` 函数来检查传递给参数的值是否是函数：
- en: '[PRE60]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In this case, observe that both `random-fn` and the value returned by `random-fn`
    are functions. So, we can call the function returned by `random-fn`, and even
    bind it to a symbol, as in the example that follows, where we bind the function
    to the `mysterious-fn` symbol:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，观察 `random-fn` 和 `random-fn` 返回的值都是函数。因此，我们可以调用 `random-fn` 返回的函数，甚至将其绑定到一个符号上，如下面的例子所示，我们将函数绑定到
    `mysterious-fn` 符号：
- en: '[PRE61]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Notice how every call to `random-fn` returned a different function. On each
    step, calling `mysterious-fn` with the same arguments is processed by a different
    function. Based on the returned values, we can guess that the functions are respectively
    `*`, `/`, `*`, and `+`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到每次调用 `random-fn` 都返回了一个不同的函数。在每一步中，使用相同的参数调用 `mysterious-fn` 都由不同的函数处理。根据返回的值，我们可以猜测这些函数分别是
    `*`、`/`、`*` 和 `+`。
- en: It is conceivable but not very common to write functions that return other functions.
    However, you will often use some of Clojure's core utility functions, which return
    other functions, and which we are going to present next. Those are worth exploring
    because they enable functional composition, reusability, and conciseness.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以想象，但并不常见，编写返回其他函数的函数。然而，您将经常使用一些 Clojure 的核心实用函数，这些函数返回其他函数，我们将在下面介绍。这些函数值得探索，因为它们使得函数组合、可重用性和简洁性成为可能。
- en: Partial Functions
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分函数
- en: 'The first of those core utility functions is `partial`, which takes a function,
    `f`, as a parameter and any number of arguments, `args1`. It returns a new function,
    `g`, that can take extra arguments, `args2`. When calling `g` with `args2`, `f`
    is called with `args1` + `args2`. It may sound complicated, but consider the following
    example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这些核心实用函数中的第一个是 `partial`，它接受一个函数 `f` 作为参数和任意数量的参数 `args1`。它返回一个新的函数 `g`，该函数可以接受额外的参数
    `args2`。当用 `args2` 调用 `g` 时，`f` 将使用 `args1` + `args2` 被调用。这可能听起来很复杂，但考虑以下示例：
- en: '[PRE62]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Calling `(partial + 0.99)` returns a new function that we bind to the `marketing-adder`
    symbol. When `marketing-adder` is called, it will call `+` with `0.99` and any
    extra arguments passed to the function. Notice that we used `def` and not `defn`,
    because we don't need to build a new function – `partial` does it for us.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `(partial + 0.99)` 返回一个新的函数，我们将它绑定到 `marketing-adder` 符号。当调用 `marketing-adder`
    时，它将使用 `0.99` 和传递给函数的任何额外参数调用 `+`。请注意，我们使用了 `def` 而不是 `defn`，因为我们不需要构建一个新的函数——`partial`
    会为我们做这件事。
- en: 'Here is another example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个示例：
- en: '[PRE63]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Calling `format-price` will call the `str` function with the first parameter,
    `"€"`, and then the rest of the parameters. Of course, you could write the same
    function like this: `(fn [x] (str "€" x))`, but using `partial` is a nice and
    expressive way of defining functions as functions of other functions.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `format-price` 将调用 `str` 函数的第一个参数 `"€"`，然后是其余的参数。当然，你可以像这样编写相同的函数：`(fn [x]
    (str "€" x))`，但使用 `partial` 是定义函数作为其他函数的函数的一种优雅且表达性强的方法。
- en: Composing Functions
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数组合
- en: 'Another core utility function is `comp`, short for compose. Take, for example,
    our `random-fn` function. To retrieve a random number from the collection, we
    call the `shuffle` function and then the `first` function. If we wanted to implement
    a `sample` function that does exactly that, we could write the following function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个核心实用函数是 `comp`，即组合。以我们的 `random-fn` 函数为例。要从集合中检索一个随机数，我们调用 `shuffle` 函数然后调用
    `first` 函数。如果我们想实现一个 `sample` 函数，它正好做这件事，我们可以编写以下函数：
- en: '[PRE64]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'But more elegantly, we could implement the `sample` function with the functional
    composition utility, `comp`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 但更优雅的是，我们可以使用函数组合实用工具 `comp` 来实现 `sample` 函数：
- en: '[PRE65]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`comp` is a utility that takes any number of functions as a parameter and returns
    a new function that calls those functions in order, passing the result of each
    to the other. Observe that the functions are composed from right to left, so in
    the preceding example, `shuffle` will be applied before `first`. This is important
    because the number and types of arguments passed to the chain of functions is
    often meaningful. For example, if you wanted to compose a function that multiplies
    numbers and increments the result by one, you would need to pass the `inc` function
    (increment) as a first argument of the function as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`comp` 是一个实用工具，它接受任意数量的函数作为参数，并返回一个新的函数，该函数按顺序调用这些函数，并将每个函数的结果传递给下一个函数。请注意，函数是从右到左组合的，所以在前面的例子中，`shuffle`
    将在 `first` 之前被应用。这很重要，因为传递给函数链的参数的数量和类型通常是有意义的。例如，如果你想组合一个乘以数字并将结果增加一的函数，你需要将
    `inc` 函数（增加）作为函数的第一个参数传递，如下所示：'
- en: '[PRE66]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Notice that when providing `inc` as the last argument of the `comp` function,
    it calls `(inc 2 2)`, which does not work because `inc` takes only one argument.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当将 `inc` 作为 `comp` 函数的最后一个参数提供时，它调用 `(inc 2 2)`，这不起作用，因为 `inc` 只接受一个参数。
- en: 'Now, let''s see how we can combine the use of `partial` and `comp` to compose
    a `checkout` function with the `format-price` and `marketing-adder` functions
    that we defined previously. The `checkout` function will first add its parameters
    by reusing `marketing-adder`, then format the price with `format-price` and return
    the string concatenated with `"Only"` in front of it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何结合使用 `partial` 和 `comp` 来组合一个 `checkout` 函数，该函数使用我们之前定义的 `format-price`
    和 `marketing-adder` 函数。`checkout` 函数将首先通过重用 `marketing-adder` 来添加其参数，然后使用 `format-price`
    格式化价格，并返回在前面加上 `"Only"` 的字符串连接：
- en: '[PRE67]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In the preceding example, we defined a `checkout` function as a composition
    of `marketing-adder`, `format-price`, and an anonymous function returned by `partial`
    to add the text `"Only"` before the price. This example shows the outstanding
    dynamism and expressivity of composing related functions in Clojure. The programmer's
    intent is clear and concise, skipping the technicality of defining functions and
    naming parameters.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了一个`checkout`函数，作为`marketing-adder`、`format-price`和一个由`partial`返回的匿名函数的组合，在价格前添加文本`"Only"`。这个例子展示了Clojure中组合相关函数的卓越动态性和表现力。程序员的意图清晰简洁，跳过了定义函数和命名参数的技术细节。
- en: 'Before we jump into the exercise, let''s present a new way of writing anonymous
    functions: the `#()` literal. `#()` is a shorter way of writing an anonymous function.
    Parameters are not named and therefore parameter values can be accessed in order
    with `%1`, `%2`, `%3`, and so on. When only one argument is provided, you can
    simply use `%` (omitting the argument number) to retrieve the value of the argument.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始练习之前，让我们介绍一种编写匿名函数的新方法：`#()`字面量。`#()`是编写匿名函数的一种更简短的方式。参数没有命名，因此可以按顺序使用`%1`、`%2`、`%3`等来访问参数值。当只提供一个参数时，你可以简单地使用`%`（省略参数编号）来检索参数值。
- en: 'For example, the two following expressions are equivalent:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下两个表达式是等价的：
- en: '[PRE68]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'And the two following expressions are equivalent as well:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以及以下两个表达式也是等价的：
- en: '[PRE69]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`#()` literal functions are just functions, called in the same way as other
    functions:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`#()`字面量函数只是函数，调用方式与其他函数相同：'
- en: '[PRE70]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Observe that when more than one argument is provided, we need to use the `%1`
    and `%2` to refer to the values passed as a parameter.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当提供多个参数时，我们需要使用`%1`和`%2`来引用作为参数传递的值。
- en: Note
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The short literal notation of the `#()` function is convenient but should be
    used sparingly because numbered parameters can be hard to read. The rule of thumb
    is to use only short anonymous functions with a single argument and a single function
    call. For anything else, you should stick with the standard `fn` notation with
    named parameters to improve readability.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`#()`函数的简短字面量表示法很方便，但应该谨慎使用，因为编号参数可能难以阅读。一般来说，只应使用具有单个参数和单个函数调用的简短匿名函数。对于其他任何情况，你应该坚持使用带有命名参数的标准`fn`表示法以提高可读性。'
- en: Let's put these new techniques into practice in an exercise with `Parenthmazes`
    version 3.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Parenthmazes`版本3的练习中应用这些新技术。
- en: 'Exercise 3.04: High-Order Functions with Parenthmazes'
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.04：使用Parenthmazes的高阶函数
- en: In this exercise, we will demonstrate the benefit of functions being first-class
    citizens. We will use functions as values and compose them together.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将展示函数作为一等公民的好处。我们将使用函数作为值并将它们组合在一起。
- en: We would like to improve our fantasy game, Parenthmazes, even more, this time
    by changing weapons' mechanics to allow each weapon to have different behavior.
    For example, we would like "fists" to inflict damage only if an enemy is weak
    or has been weakened. Instead of implementing conditional branches in our `strike`
    function, we are going to implement a *dispatch table* using the `weapon-damage`
    `HashMap`, which we are going to rename `weapon-fn-map`, because this time each
    weapon will have an associated function (rather than a numeric value). A dispatch
    table is a table of pointers to functions. We can implement it with a `HashMap`
    where the pointers are keys and the functions are values.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望进一步提高我们的幻想游戏，Parenthmazes，这次通过改变武器机制，使每种武器都能有不同的行为。例如，我们希望“拳头”只有在敌人虚弱或已被削弱时才造成伤害。而不是在我们的`strike`函数中实现条件分支，我们将使用`weapon-damage`
    `HashMap`实现一个*调度表*，我们将它重命名为`weapon-fn-map`，因为这次每种武器都将有一个相关的函数（而不是一个数值）。调度表是一个指向函数的指针表。我们可以通过一个`HashMap`来实现它，其中指针是键，函数是值。
- en: 'To allow our weapon functions to compose nicely, they will take a numeric value
    for health as a parameter and return a numeric value for health after the damage
    has been deducted. For the sake of simplicity, we will leave out the concept of
    armor this time. Let''s start with the `fist` weapon:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的武器功能能够很好地组合，它们将接受一个表示健康的数值作为参数，并在扣除伤害后返回一个表示健康的数值。为了简化，这次我们将省略护甲的概念。让我们从`拳头`武器开始：
- en: 'Start a REPL next to your favorite code editor. Create a new `HashMap` with
    a `:fists` key and its associated function, which inflicts `10` damage only if
    the health of the enemy is less than `100`, and otherwise returns the `health`
    parameter. Bind the newly created function to the `weapon-fn-map` symbol as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您最喜欢的代码编辑器旁边启动一个REPL。创建一个新的`HashMap`，其中包含`:fists`键及其相关联的函数，该函数仅在敌人的生命值小于`100`时造成`10`点伤害，否则返回`health`参数。将新创建的函数绑定到`weapon-fn-map`符号，如下所示：
- en: '[PRE71]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: A `HashMap` can have any type of value as a key or parameter, so a function
    as a value is perfectly fine.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`HashMap`可以作为键或参数具有任何类型的值，因此将函数作为值是完全可以接受的。'
- en: 'Try the function by retrieving it from `weapon-fn-map` and call it with `150`
    and then `50` as a parameter:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从`weapon-fn-map`检索该函数并使用`150`和`50`作为参数来尝试该函数：
- en: '[PRE72]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Observe that the function returned the new health correctly. It subtracted `10`
    when the `health` parameter was less than `100`.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 观察到函数正确地返回了新的生命值。当`health`参数小于`100`时，它减去了`10`。
- en: 'Now to the `staff` weapon. The `staff` is the only weapon that can be used
    to heal (`35` health points), so the associated function should simply call `+`
    instead of `-`. It seems like a good opportunity to generate this function using
    `partial`:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到`staff`武器。`staff`是唯一可以用来恢复生命值（`35`点生命值）的武器，因此相关联的函数应该简单地调用`+`而不是`-`。这似乎是一个使用`partial`生成这个函数的好机会：
- en: '[PRE73]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The value at the `:staff` key is now a function that will call `+` with `35`
    and any extra argument supplied.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`:staff`键的值现在是一个函数，它将调用`+`并带有`35`以及任何额外的参数。'
- en: 'Try the function associated with `staff`, as follows:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用与`staff`相关联的函数，如下所示：
- en: '[PRE74]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: For the `sword` weapon, we need to simply subtract `100` points from the health
    points passed as an argument. However, `partial` won't work because the parameters
    would not be in the correct order. For example, `((partial - 100) 150)` returns
    `-50`, because the function call is equivalent to `(- 100 150)`, but we need `(-
    150 100)`.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`sword`武器，我们需要简单地从传入的参数中减去`100`点生命值。然而，`partial`不会起作用，因为参数的顺序不正确。例如，`((partial
    - 100) 150)`返回`-50`，因为函数调用相当于`(- 100 150)`，但我们需要`(- 150 100)`。
- en: 'Create an anonymous function subtracting `100` from its argument and associate
    it with the `sword` key, as follows:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个匿名函数，从其参数中减去`100`，并将其与`sword`键相关联，如下所示：
- en: '[PRE75]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Notice that we used `%` to retrieve the argument passed to the anonymous function,
    because we used the short literal syntax, `#()`, expecting only one argument.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用了`%`来检索传递给匿名函数的参数，因为我们使用了简短的文字语法`#()`，期望只有一个参数。
- en: 'Test your newly created weapon function as follows:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤测试您新创建的武器函数：
- en: '[PRE76]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: It works!
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它工作得很好！
- en: The next weapon to add is `cast-iron-saucepan`. To spice things up, let's add
    a bit of randomness to the mix (a saucepan is not a very accurate weapon anyway).
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一个要添加的武器是`cast-iron-saucepan`。为了增加趣味性，让我们在混合中加入一点随机性（毕竟锅不是一把非常精确的武器）。
- en: 'Add the `cast-iron-saucepan` function to the `HashMap` that subtracts `100`
    health points and a random number between `0` and `50` from the health points,
    as follows:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`cast-iron-saucepan`函数添加到`HashMap`中，从生命值中减去`100`点以及`0`到`50`之间的随机数，如下所示：
- en: '[PRE77]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In the preceding example, we used the `rand-int` function, which generates a
    random integer between `0` and the supplied argument.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了`rand-int`函数，它生成一个介于`0`和提供的参数之间的随机整数。
- en: 'Test the newly created function as follows:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤测试新创建的函数：
- en: '[PRE78]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Two subsequent calls might return a different value because of the `rand-int`
    function.
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于`rand-int`函数，两次后续调用可能会返回不同的值。
- en: 'Finally, we would like to introduce a new weapon (for the unfortunate adventurers)
    that doesn''t do any damage: the sweet potato. For that purpose, we need a function
    that returns its argument (the health). We don''t need to implement it as it already
    exists: `identity`. First, let''s check out the source code of the function identity
    with the `source` function:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们想介绍一种新的武器（给不幸的冒险者），它不会造成任何伤害：红薯。为此，我们需要一个返回其参数（生命值）的函数。我们不需要实现它，因为它已经存在：`identity`。首先，让我们使用`source`函数查看`identity`函数的源代码：
- en: '[PRE79]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Observe how `identity` simply returns its argument. The `source` function is
    another handy tool to use interactively in the REPL, as it prints out a function
    definition to the console, which is sometimes more helpful than a function's documentation.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 观察到`identity`只是返回其参数。`source`函数是REPL中交互式使用的一个很有用的工具，因为它将函数定义打印到控制台，这有时比函数的文档更有帮助。
- en: 'Let''s redefine our `weapon-fn-map` `HashMap` one last time by associating
    the function identity with the `:sweet-potato` key, as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们最后一次重新定义我们的 `weapon-fn-map` `HashMap`，通过将函数标识符与 `:sweet-potato` 键关联，如下所示：
- en: '[PRE80]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Now that we have our `weapon-fn-map` finalized, we should modify our `strike`
    function to handle the weapon functions stored as values in our `HashMap`. Remember
    that the `strike` function takes a `target` entity as a parameter and returns
    this entity with a new value for the health key. Therefore, updating the entity's
    health should be as simple as passing a `weapon` function to the `update` function,
    because our `weapon` functions take the health as a parameter and return the new
    health value.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经最终确定了 `weapon-fn-map`，我们应该修改 `strike` 函数以处理存储在 `HashMap` 中的武器函数值。记住，`strike`
    函数接受一个 `target` 实体作为参数，并返回具有新的健康键值的该实体。因此，更新实体的健康值应该像将 `weapon` 函数传递给 `update`
    函数那样简单，因为我们的 `weapon` 函数接受健康值作为参数并返回新的健康值。
- en: 'Rewrite the `strike` function from the previous exercise to use the weapon
    functions stored in the `weapon-fn-map`, as follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上一练习中的 `strike` 函数重写，使其使用存储在 `weapon-fn-map` 中的武器函数，如下所示：
- en: '[PRE81]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now test your `strike` function by passing various weapons as a parameter.
    For convenience, you might want to create an `enemy` entity as well:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过传递各种武器作为参数来测试你的 `strike` 函数。为了方便，你可能还想创建一个 `enemy` 实体：
- en: '[PRE82]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'If we wanted to strike with more than one weapon at a time, instead of nesting
    a strike call like this:'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们想同时使用多个武器进行打击，而不是像这样嵌套调用 `strike`：
- en: '[PRE83]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We could simply compose our weapon functions and just use the core update function.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以简单地组合我们的武器函数，并直接使用核心更新函数。
- en: 'Write an `update` expression to strike with two weapons at a time using `comp`,
    as follows:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 `update` 表达式，使用 `comp` 函数同时使用两个武器进行打击，如下所示：
- en: '[PRE84]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Because the weapon functions that we wrote have a consistent interface (taking
    `health` as a parameter and returning the health), it is straightforward to compose
    them with `comp`. To finish this exercise, let's create a `mighty-strike` function
    that strikes with all of the weapons at once, also known as composing all the
    weapon functions. The `keys` and `vals` functions can be used on `HashMaps` to
    retrieve a collection of the map's keys or values. To retrieve all the weapon
    functions, we can simply retrieve all the values from `weapon-fn-map` using the
    `vals` function. Now that we have a collection of functions, how do we compose
    them? We need to pass each function of the collection to the `comp` function.
    Remember, to pass each element of a collection as a parameter of a function, we
    can use `apply`.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为我们编写的武器函数具有一致的接口（以 `health` 作为参数并返回健康值），因此使用 `comp` 函数组合它们非常简单。为了完成这个练习，让我们创建一个
    `mighty-strike` 函数，该函数一次性使用所有武器进行打击，也称为组合所有武器函数。`keys` 和 `vals` 函数可以用于 `HashMaps`
    来检索地图的键或值的集合。要检索所有武器函数，我们可以简单地使用 `vals` 函数从 `weapon-fn-map` 中检索所有值。现在我们有了函数集合，我们如何组合它们呢？我们需要将集合中的每个函数传递给
    `comp` 函数。记住，为了将集合中的每个元素作为函数的参数传递，我们可以使用 `apply`。
- en: 'Write a new function named `mighty-strike`, which takes a `target` entity as
    a parameter and uses all of the weapons on it. It should apply the `comp` function
    to the values of `weapon-fn-map` as follows:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `mighty-strike` 的新函数，该函数接受一个 `target` 实体作为参数，并使用所有武器对其发动攻击。它应该将 `weapon-fn-map`
    的值应用于 `comp` 函数，如下所示：
- en: '[PRE85]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now, if we pause to reflect on the `mighty-strike` function and think about
    how we would have to implement that without higher-order functions, we'll realize
    how simple and powerful the concept of functional composition is.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们停下来反思 `mighty-strike` 函数，并思考在没有高阶函数的情况下如何实现它，我们会意识到函数组合的概念是多么简单和强大。
- en: In this section, we've learned how to use functions as simple values and as
    parameters or return values of other functions, as well as creating shorter anonymous
    functions with `#()`. We also explained how to use `partial`, `comp`, and `apply`
    to generate, compose, and discover new ways of using functions.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何将函数用作简单的值，以及作为其他函数的参数或返回值，以及如何使用 `#()` 创建更短的匿名函数。我们还解释了如何使用 `partial`、`comp`
    和 `apply` 来生成、组合和发现函数的新用法。
- en: Multimethods
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多方法
- en: Clojure offers a way to implement polymorphism with multimethods. Polymorphism
    is the ability of a unit of code (in our case, functions) to behave differently
    in different contexts, for example, based on the shape of the data received by
    the code. In Clojure, we also call it *runtime polymorphism* because the method
    to call is determined at runtime rather than at compile time. A multimethod is
    a combination of a dispatch function and of one or more methods. The two main
    operators for creating those multimethods are `defmulti` and `defmethod`. `defmulti`
    declares a multimethod and defines how the method is chosen with the dispatch
    function. `defmethod` creates the different implementations that will be chosen
    by the dispatch function. The dispatch function receives the arguments of the
    function call and returns a dispatch value. This dispatch value is used to determine
    which function, defined with `defmethod`, to invoke. Those are a lot of new terms
    but don't worry, the following examples will help you understand the new concepts.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 提供了一种使用多方法实现多态的方法。多态是指代码单元（在我们的例子中是函数）在不同上下文中表现不同的能力，例如，根据代码接收到的数据形状。在
    Clojure 中，我们也称其为 *运行时多态*，因为调用方法是在运行时而不是在编译时确定的。多方法是由一个分派函数和一个或多个方法组合而成的。创建这些多方法的两个主要操作符是
    `defmulti` 和 `defmethod`。`defmulti` 声明一个多方法并定义了如何通过分派函数选择方法。`defmethod` 创建了将被分派函数选择的不同的实现。分派函数接收函数调用的参数并返回一个分派值。这个分派值用于确定调用哪个由
    `defmethod` 定义的函数。这些术语很多，但不用担心，下面的示例将帮助您理解这些新概念。
- en: 'Let''s see how we could implement Parenthmazes'' `strike` function with multimethods.
    This time, the weapon is in the `HashMap` passed as a parameter:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用多方法实现 Parenthmazes 的 `strike` 函数。这次，武器是在作为参数传递的 `HashMap` 中：
- en: '[PRE86]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In the preceding code, we''ve created a multimethod called `strike`. The second
    argument is the dispatch function, which simply retrieves a weapon in a map passed
    as a parameter. Remember that keywords can be used as functions of a `HashMap`,
    so we can simply write `defmulti` as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名为 `strike` 的多方法。第二个参数是分派函数，它简单地从作为参数传递的映射中检索武器。记住，关键字可以用作 `HashMap`
    的函数，所以我们可以简单地写出 `defmulti` 如下：
- en: '[PRE87]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Notice that, this time, the expression returned `nil`. This is because the
    multimethod was already defined. In that case, we need to `unmap` the `strike`
    var from the `user` namespace and re-evaluate the same expression again:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次表达式返回了 `nil`。这是因为多方法已经被定义了。在这种情况下，我们需要从 `user` 命名空间中 `unmap` `strike` 变量，然后再次评估相同的表达式：
- en: '[PRE88]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now that we have our multimethod and our dispatch function defined (which is
    simply the `:weapon` keyword), let''s create our `strike` functions for a couple
    of weapons, to demonstrate the usage of `defmethod`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的多方法和我们的分派函数（它简单地是 `:weapon` 关键字），让我们为几种武器创建 `strike` 函数，以演示 `defmethod`
    的用法：
- en: '[PRE89]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Observe how we called `defmethod` with the function named `strike`, the second
    argument to `defmethod` is the dispatch value: `:sword`. When `strike` is called
    with a map containing a weapon key, the weapon value is retrieved from the arguments
    and then returned by the dispatch function (the `:weapon` keyword). Similarly,
    let''s create another strike implementation for the `:cast-iron-saucepan` dispatch
    value:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 观察我们如何使用名为 `strike` 的函数调用 `defmethod`，`defmethod` 的第二个参数是分派值：`:sword`。当 `strike`
    被调用时，包含武器键的映射中的武器值将被从参数中检索，然后由分派函数（`:weapon` 关键字）返回。同样，让我们为 `:cast-iron-saucepan`
    分派值创建另一个 `strike` 实现方案：
- en: '[PRE90]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This time, `strike` is called with a map containing `:cast-iron-saucepan` at
    the `:weapon` key. The function defined previously will be invoked. Let''s test
    our newly created multimethod with the two different weapons:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`strike` 是在包含 `:cast-iron-saucepan` 在 `:weapon` 键的映射中调用的。之前定义的函数将被调用。让我们用两种不同的武器测试我们新创建的多方法：
- en: '[PRE91]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Notice how calling `strike` with different arguments lets us invoke two different
    functions.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，调用 `strike` 时使用不同的参数可以调用两个不同的函数。
- en: 'When the dispatch value doesn''t map to any registered function, an exception
    is thrown:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当分派值不映射到任何已注册的函数时，会抛出异常：
- en: '[PRE92]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If we need to handle that case, we can add a method with the `:default` dispatch
    value:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要处理这种情况，我们可以添加一个具有 `:default` 分派值的函数：
- en: '[PRE93]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'In this case, we decided to handle any other weapon by simply returning the
    unmodified health value, inflicting no damage:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们决定通过简单地返回未修改的健康值来处理任何其他武器，不造成伤害：
- en: '[PRE94]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Notice that, this time, no exception was thrown, and the original health value
    was returned. The dispatch function can be more elaborate. We could imagine a
    special behavior when the enemy''s health is below 50 points and instantly eliminate
    it, no matter what weapon was used:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次没有抛出异常，并返回了原始的健康值。调度函数可以更加详细。我们可以想象当敌人的健康值低于50点时，无论使用什么武器，都会立即将其消除：
- en: '[PRE95]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The preceding code first unmaps `strike` from the `user` namespace so that it
    can be redefined. We then redefine the dispatching function by looking in the
    parameter and dispatching to a `:finisher` function if the health of the enemy
    is below `50`. We then define the `:finisher` function (the `strike` function
    with the dispatch value finisher) to return, simply ignore its arguments, and
    return `0`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码首先从`user`命名空间中取消映射`strike`，以便可以重新定义。然后，通过查找参数并当敌人的健康值低于`50`时调度到`:finisher`函数来重新定义调度函数。然后定义`:finisher`函数（具有调度值finisher的`strike`函数）以返回，简单地忽略其参数，并返回`0`。
- en: 'Because we''ve unmapped `strike`, we must add `defmethods` as they would have
    been removed too. Let''s re-add a sword and the default method:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们取消了`strike`，我们必须添加`defmethods`，因为它们也会被移除。让我们重新添加一把剑和默认方法：
- en: '[PRE96]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now let''s see our multimethod in action:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们的多方法是如何工作的：
- en: '[PRE97]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Great – our function still works as expected. Now let''s see what happens when
    the health is below `50`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——我们的函数仍然按预期工作。现在让我们看看当健康值低于`50`时会发生什么：
- en: '[PRE98]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The `finisher` function has been called and the strike multimethod successfully
    returned `0`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 已经调用了`finisher`函数，并且打击多方法成功返回了`0`。
- en: Multimethods can do a few more things, such as dispatching on multiple values
    (using a vector as the dispatch value) or dispatching on types and hierarchies.
    This is useful but maybe a bit much to take on for now. Let's move on to the exercise
    and practice using multimethods by dispatching on values.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 多方法可以做更多的事情，例如使用向量作为调度值进行多值调度或根据类型和层次结构进行调度。这很有用，但可能现在承担得有点多。让我们继续练习，通过值调度来练习使用多方法。
- en: 'Exercise 3.05: Using Multimethods'
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.05：使用多方法
- en: In this exercise, we want to extend our little game, Parenthmazes, with the
    ability to move a player. The game board is a simple two-dimensional space with
    the coordinates x and y. We will not implement any rendering or maintain any state
    of the game at this point as we simply want to practice the use of multimethods,
    so you will have to use your imagination.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们想要扩展我们的小游戏Parenthmazes，使其具有移动玩家的能力。游戏板是一个简单的二维空间，具有x和y坐标。我们目前不会实现任何渲染或维护游戏状态，因为我们只想练习使用多方法，所以你必须发挥想象力。
- en: 'Players'' entities are now given an extra key, `:position`, which contains
    a `HashMap` with the coordinates at key x and y as well as the `:facing` key,
    which contains the direction in which the player is facing. The following code
    is an example of a player entity:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家的实体现在被赋予了一个额外的键`:position`，它包含一个`HashMap`，其中包含x和y坐标以及`:facing`键，它包含玩家面对的方向。以下是一个玩家实体的示例代码：
- en: '[PRE99]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Moving north or south should change the y coordinate, and moving east and west
    should change the x coordinate. We will implement this with a new `move` function.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 向北或向南应该改变y坐标，向东或向西应该改变x坐标。我们将通过一个新的`move`函数来实现这一点。
- en: 'Start a REPL and create the player entity as follows:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动REPL并按照以下方式创建玩家实体：
- en: '[PRE100]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Create the `move` multimethod. The dispatch function should determine the dispatch
    value by retrieving the `:facing` value in the `:position` map of a player entity.
    The `:facing` value could be one of the following values `:north`, `:south`, `:west`,
    and `:east`:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`move`多方法。调度函数应该通过检索玩家实体的`:position`映射中的`:facing`值来确定调度值。`:facing`值可以是以下值之一：`:north`、`:south`、`:west`和`:east`：
- en: '[PRE101]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: You might have noticed that the two successive keyword function calls could
    be more elegantly expressed with functional composition.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能已经注意到，连续的两个关键字函数调用可以用函数组合更优雅地表达。
- en: 'Redefine the `move` multimethod by first unmapping the var from the `user`
    namespace and then using `comp` to simplify its definition:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过首先从`user`命名空间中取消映射var并使用`comp`来简化其定义来重新定义`move`多方法：
- en: '[PRE102]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Create the first implementation of the `move` function with the `:north` dispatch
    value. It should increment `:y` in the `:position` map:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`:north`调度值创建`move`函数的第一个实现。它应该在`:position`映射中增加`:y`：
- en: '[PRE103]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Try your newly created function by calling `move` with the `player` entity
    and observe the result:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 `player` 实体调用 `move` 并观察结果来尝试你新创建的函数：
- en: '[PRE104]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Observe that the value at `y` successfully increased by 1.
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 `y` 位置的值成功增加了 1。
- en: 'Create the other functions for the rest of the dispatch values `:south`, `:west`,
    and `:east`:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为其余的分派值 `:south`、`:west` 和 `:east` 创建其他函数：
- en: '[PRE105]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Test your newly created functions by providing `player` entities facing different
    directions:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提供面向不同方向的 `player` 实体来测试你新创建的函数：
- en: '[PRE106]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Observe how the coordinates changed correctly when moving the players in different
    directions.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 观察当将玩家向不同方向移动时，坐标是否正确改变。
- en: 'Create an extra function for when the value at `:facing` is different from
    `:north`, `:south`, `:west`, and `:east`, using the `:default` dispatch value:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为当 `:facing` 的值不同于 `:north`、`:south`、`:west` 和 `:east` 时创建一个额外的函数，使用 `:default`
    分派值：
- en: '[PRE107]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Try your function and make sure it handles unexpected values by returning the
    original entity map:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试你的函数并确保它能够处理意外值，通过返回原始实体映射来处理：
- en: '[PRE108]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Observe that the multimethod was dispatched to the default function, and that
    the position remained unchanged when the player was facing a `:wall`.
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到多方法被分配到了默认函数，并且当玩家面对 `:wall` 时，位置保持不变。
- en: In this section, we've learned how to use Clojure's polymorphism feature with
    multimethods.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用 Clojure 的多态特性与多方法。
- en: 'Activity 3.01: Building a Distance and Cost Calculator'
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 3.01：构建距离和成本计算器
- en: 'Let''s go back to the flight-booking platform application that we worked on
    in *Exercise 3.01*, *Parsing Fly Vector''s Data with Sequential Destructuring*,
    and *Exercise 3.02*, *Parsing MapJet Data with Associative Destructuring*. In
    the time it took you to arrive at the end of this chapter, we have now developed
    the company into a proper start-up called WingIt, with serious investors, a weekly
    board meeting, and a ping pong table, which means that we now need to build the
    core services of the app: the itinerary and cost calculations between two locations.
    However, after looking into routing airways, airport fees, and complicated fuel
    calculations, we''ve come to realize that the algorithms that we need to develop
    might be too complicated for us at this stage. We''ve decided that for our **Minimal
    Viable Product** (**MVP**), we are just going to "wing it" and offer simpler modes
    of transportation such as driving and even walking. However, we want to keep the
    code easily extensible, because we''ll eventually need to add flying (some employees
    even overheard the CEO talking about adding space flights to the roadmap soon!).'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们在 *练习 3.01*、*使用顺序解构解析 Fly Vector 的数据* 和 *练习 3.02*、*使用关联解构解析 MapJet 数据*
    中所工作的飞行预订平台应用程序。在你到达本章末尾所花费的时间内，我们现在已经将公司发展成为一个名为 WingIt 的正规初创公司，拥有严肃的投资者、每周的董事会会议和一张乒乓球桌，这意味着我们现在需要构建应用程序的核心服务：两个地点之间的行程和成本计算。然而，在研究了航线、机场费用和复杂的燃料计算后，我们意识到我们需要开发的算法可能对我们这个阶段来说过于复杂。我们决定，对于我们的
    **最小可行产品**（**MVP**），我们只是“临时应对”并提供更简单的交通方式，如驾驶甚至步行。然而，我们希望代码易于扩展，因为最终我们需要添加飞行（一些员工甚至无意中听到首席执行官在谈论不久后将在路线图中添加太空旅行！）。
- en: 'The requirement of the WingIt MVP are as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: WingIt MVP 的要求如下：
- en: For the prototype, we will interact with a Clojure REPL. The interface is an
    itinerary function taking a `HashMap` as a parameter. For now, the users will
    have to enter coordinates. It might not be very user-friendly but the user can
    look up coordinates on their own globe or map!
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于原型，我们将与 Clojure REPL 交互。界面是一个接受 `HashMap` 作为参数的行程函数。目前，用户必须输入坐标。这可能不是非常用户友好，但用户可以在自己的地球仪或地图上查找坐标！
- en: The itinerary function returns a `HashMap` with the keys, `:distance`, `:cost`,
    and `:duration`. `:distance` is expressed in kilometers, `:cost` in euros, and
    `:duration` in hours.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行程函数返回一个包含键 `:distance`、`:cost` 和 `:duration` 的 `HashMap`。`:distance` 以公里为单位表示，`:cost`
    以欧元表示，`:duration` 以小时表示。
- en: The only parameter to the itinerary function is a `HashMap` containing `:from`,
    `:to`, `:transport`, and `:vehicle`. `:from` and `:to` contain a `HashMap` with
    the `:lat` and `:lon` keys, representing the latitude and longitude of a location
    on our planet.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行程函数的唯一参数是一个包含 `:from`、`:to`、`:transport` 和 `:vehicle` 的 `HashMap`。`:from` 和
    `:to` 包含一个具有 `:lat` 和 `:lon` 键的 `HashMap`，代表我们星球上某个位置的纬度和经度。
- en: '`:transport` can be either `:walking` or `:driving`.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:transport` 可以是 `:walking` 或 `:driving`。'
- en: '`:vehicle` is only useful when `:transport` is `:driving`, and can be one of
    `:sporche`, `:sleta`, or `:tayato`.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To compute the distance**, we are going to use the "Euclidian distance,"
    which is normally used to calculate the distance between two points on a plan.
    For flying, we would have to use at least the haversine formula, and technically,
    for driving, we would need to use routes, but we just want rough estimates on
    relatively short distances, so the much simpler Euclidian distance should be enough
    for now. The only complicated bit in this calculation is that the length of a
    degree of longitude depends on the latitude, so we''ll need to multiply the longitude
    by the cosine of the latitude. The final equation to compute the distance between
    two points (lat1, lon1) and (lat2, lon2) looks like this:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: Calculating the Euclidean distance'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_03_01.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.1: Calculating the Euclidean distance'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '`:driving`, we will look at the `:vehicle` chosen by the user in the `HashMap`
    parameter. The cost of each vehicle should be a function of the distance:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '`:sporche` consumes, on average, 0.12 liters of petrol per kilometer, costing
    €1.5 per liter.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:tayato` consumes, on average, 0.07 liters of petrol per kilometer, costing
    €1.5 per liter.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:sleta` consumes, on average, 0.2 kilowatt hour (kwh) of electricity per kilometer,
    costing €0.1 per kwh.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cost should be 0 when transport is `:walking`.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To compute the duration**, we consider an average driving speed of 70 km
    per hour, and an average walking speed of 5 km per hour.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a couple of examples of calls to the itinerary function, and the expected
    output:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'These steps will help you complete this activity:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Start by defining the `walking-speed` and `driving-speed` constants.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two other constants representing two locations with the coordinates,
    `:lat` and `:lon`. You can use the previous example with Paris and Bordeaux or
    look up your own. You will be using them to test your distance and itinerary functions.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `distance` function. It should take two parameters representing the
    two locations for which we need to calculate the distance. You can use a combination
    of sequential and associative destructuring right in the function parameters to
    disassemble the latitude and longitude from both locations. You can decompose
    the steps of the calculation in a `let` expression and use the `Math/cos` function
    to calculate the cosine of a number and `Math/sqrt` to calculate the square root
    of a number; for example, `(Math/cos 0)`, `(Math/sqrt 9)`.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a *multimethod* called `itinerary`. It will offer the flexibility of
    adding more types of transport in the future. It should use the value at `:transport`
    as a *dispatch value*.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the itinerary function for the `:walking` dispatch value. You can use
    associative destructuring in the function parameters to retrieve the `:from` and
    `:to` keys from the `HashMap` parameter. You can use a `let` expression to decompose
    the calculations of the distance and duration. The distance should simply use
    the `distance` function you created before. To calculate the duration, you should
    use the `walking-speed` constant that you defined in *Step 1*.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于`:walking`调度值的行程函数。你可以在函数参数中使用关联解构来从`HashMap`参数中检索`:from`和`:to`键。你可以使用`let`表达式来分解距离和持续时间的计算。距离应简单地使用你之前创建的`distance`函数。为了计算持续时间，你应该使用在*步骤1*中定义的`walking-speed`常量。
- en: For the `:driving` itinerary function, you could use a dispatch table that contains
    the vehicle associated with the costing function. Create a `vehicle-cost-fns`
    dispatch table. It should be a `HashMap` with the keys being the types of vehicles,
    and the values being cost calculation functions based on the distance.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`:driving`行程函数，你可以使用包含与成本函数关联的车辆的调度表。创建一个`vehicle-cost-fns`调度表。它应该是一个`HashMap`，键是车辆类型，值是基于距离的成本计算函数。
- en: Create the itinerary function for the `:driving` dispatch value. You can use
    associative destructuring in the function parameters to retrieve the `:from`,
    `:to`, and `:vehicle` keys from the `HashMap` parameter. The driving distance
    and duration can be calculated similarly to the walking distance and duration.
    The cost can be calculated by retrieving the cost function from the dispatch table
    using the `:vehicle` key.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于`:driving`调度值的行程函数。你可以在函数参数中使用关联解构来从`HashMap`参数中检索`:from`、`:to`和`:vehicle`键。行驶距离和持续时间可以类似于步行距离和持续时间进行计算。成本可以通过使用`:vehicle`键从调度表中检索成本函数来计算。
- en: 'Expected Output:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出：
- en: '[PRE110]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Note
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 686.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第686页找到。
- en: Summary
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we took a closer look at Clojure''s powerful functions. We
    learned how to simplify our functions with destructuring techniques, and then
    discovered the great benefits of higher-order functions: modularity, simplicity,
    and composability. We also introduced an advanced concept to write code that is
    more extensible with Clojure''s polymorphism mechanism: multimethods. Now that
    you are familiar with the REPL, data types, and functions, you can move on to
    learning about tools and functional techniques to manipulate collections.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更深入地了解了Clojure的强大函数。我们学习了如何通过解构技术简化我们的函数，然后发现了高阶函数的巨大好处：模块化、简单性和可组合性。我们还介绍了一个高级概念，即使用Clojure的多态机制编写更可扩展的代码：多方法。现在你已经熟悉了REPL、数据类型和函数，你可以继续学习关于工具和函数式技术来操作集合。
- en: 'In the next chapter, we will explore sequential collections in Clojure and
    take a look at two of the most useful patterns: mapping and filtering.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Clojure的顺序集合，并查看两个最有用的模式：映射和过滤。
