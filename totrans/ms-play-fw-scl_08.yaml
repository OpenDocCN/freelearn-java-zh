- en: Chapter 8. WebSockets and Actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to WebSockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actor Model and Akka Actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WebSockets in Play: using Iteratees and Actors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FrameFormatters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Picture this:'
  prefs: []
  type: TYPE_NORMAL
- en: A moviegoer is trying to purchase movie tickets online. He or she has selected
    the seats, entered the payment details, and submitted. He or she gets an error
    message saying that the tickets they tried to book have sold out.
  prefs: []
  type: TYPE_NORMAL
- en: Consider an application, which gives detailed information about the stock market
    and allows purchasing/selling stocks. When someone enters payment details and
    submits these details, they get an error saying that the purchase has been rejected
    as the price of the stock has now changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, in applications where real-time data was required over HTTP, developers
    realized that they needed bidirectional communication between the client side
    and server side. It was generally implemented using one of the following approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Polling**: Requests are sent from the client side at fixed and regular intervals.
    The server responds within a short span (less than 1 second or so) with a result
    for each request made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long-polling**: When a request is sent, the server does not respond with
    a result unless there has been a change in the state within a specified time period.
    A request is fired after a response is received from the server. Therefore, the
    client side makes repeated requests as and when it gets the response for the previous
    one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Streaming**: A request to the server results in an open response, which is
    continuously updated and kept open indefinitely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although these approaches worked, using them led to some problems:'
  prefs: []
  type: TYPE_NORMAL
- en: It led to an increase in the number of TCP connections per client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There was a high overhead of HTTP Header Overhead while mapping a response to
    its corresponding request on the client side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In 2011, a protocol that uses a single TCP connection for bidirectional traffic,
    WebSocket (RFC6455), was standardized by the **Internet Engineering Task Force**
    (**IETF**). By September 20, 2012, the **World Wide Web Consortium** (**W3C**)
    came up with the specifications for a WebSocket API.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike HTTP, there is no request-response cycle in a WebSocket. Once connected,
    the client and server can send messages to each other. The communication can be
    by server and by client, that is, a two-way full duplex communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the WebSocket API:'
  prefs: []
  type: TYPE_NORMAL
- en: A WebSocket connection can be established by invoking the constructor, such
    as `WebSocket(url, protocols)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data can be sent to the server via a connection using the `send(data)` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `close()` will result in closing the connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following event handlers can be defined on the client side:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onopen`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onmessage`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onerror`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onclose`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A snippet using JavaScript is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: WebSockets in Play
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**WebSockets** cannot be defined using Action since they should be bidirectional.
    Play provides a helper to assist with WebSockets, which is documented at [https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.mvc.WebSocket$](https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.mvc.WebSocket$).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WebSockets, which are defined using the helper, use the Play server's underlying
    TCP port.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets can be defined similarly to Actions in Play applications. Starting
    from Play 2.3, a WebSocket helper finds a method to define WebSocket interactions
    using an Actor. However, before we learn more about the methods provided by the
    helper, let's take a small detour and get a little familiar with the **Actor Model**
    and **Akka Actors**.
  prefs: []
  type: TYPE_NORMAL
- en: Actor Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency in programming can be achieved by using *Threads* which may include
    the risk of a lost update or a deadlock. The Actor Model facilitates concurrency
    by utilizing asynchronous communication.
  prefs: []
  type: TYPE_NORMAL
- en: According to the Actor Model, an actor is the fundamental unit of computation.
    It cannot exist independently, that is, it is always part of a specific actor
    system. An actor can send messages to one or more actors within its actor system
    if it knows the address of the other actor. It can also send messages to itself.
    The order in which the messages are sent or received cannot be guaranteed since
    the communication is asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an actor receives a message, it can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Forward it to another actor whose address is known to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create more actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designate the action it will take for the next message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Actor Model was first described in August 1973 in a publication by Carl
    Hewitt, Peter Bishop and Richard Steiger in the paper *A Universal Modular ACTOR
    Formalism for Artificial Intelligence*, which was a part of the International
    Joint Conference on Artificial Intelligence (IJCAI'73).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Akka Actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Akka** is a part of the Typesafe Reactive Platform, which is similar to the
    Play Framework. According to their website:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Akka is a toolkit and runtime used to build highly concurrent, distributed,
    and fault-tolerant event-driven applications on the JVM.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Akka implements a version of the Actor Model, which is commonly called Akka
    Actors and is available for both Java and Scala. According to the Akka documentation,
    Actors give you:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple and high-level abstractions for concurrency and parallelism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous, nonblocking, and highly performant event-driven programming model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very lightweight event-driven processes (several million actors per GB of heap
    memory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Akka Actors are available as a library and can be used within a project by
    adding them into the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding a dependency in Akka explicitly is not required in a Play project as
    Play uses Akka internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then define an actor by extending the Actor trait and defining the behavior
    in the `receive` method. Let''s build an Actor, which reverses any string message
    it receives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the actor, we first need to initialize `ActorSystem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can get a reference of the actor by using the `actorOf` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This reference can then be used to send messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s run the application and see what the actor does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we wanted to define an Actor that accepted `minLength` and `MaxLength`
    as arguments, we would need to modify the `Reverser` class and its companion as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For more details on Akka actors, refer to [http://akka.io/docs/](http://akka.io/docs/).
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket using Iteratee
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s define a WebSocket connection, which accepts strings and sends back
    the reverse of a string using **Iteratee**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `WebSocket.using` method creates a WebSocket of a specific type using an
    Iteratee (inbound channel) and its corresponding enumerator (outbound channel).
    In the preceding code snippet, we return a tuple of the Iteratee in and the Enumerator
    out.
  prefs: []
  type: TYPE_NORMAL
- en: The `Concurrent` object is also a helper, which provides utilities to use Iteratees,
    Enumerators, and Enumeratees concurrently. The `broadcast[E]` method creates an
    Enumerator and a channel and returns a `(Enumerator[E], Channel[E])` tuple. The
    Enumerator and channel, thus obtained, can be used to broadcast data to multiple
    Iteratees.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we need to bind it to a path in the routes file, which is similar
    to what we do for an Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, using a browser plugin, such as simple WebSocket client for Chrome (refer
    to [https://chrome.google.com/webstore/detail/simple-websocket-client/pfdhoblngboilpfeibdedpjgfnlcodoo](https://chrome.google.com/webstore/detail/simple-websocket-client/pfdhoblngboilpfeibdedpjgfnlcodoo)),
    we can send messages through the WebSocket when an application is running, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WebSocket using Iteratee](img/3803OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we do not use multiple Iteratees in our application, we can use `Concurrent.unicast`.
    This will require us to modify our code slightly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, unlike the `broadcast` method, the `unicast` method does not return
    a tuple of enumerators and channels, but instead only provides an enumerator.
    We have to declare a channel variable and initialize it with null, so that it
    is accessible within the Iteratee. When the `unicast` method is called, it is
    set to the channel generated within the `unicast` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `unicast` method also allows us to define the `onComplete` and `onError`
    methods, but they are not aware of the Iteratee, that is, we cannot refer to the
    Iteratee within these methods.
  prefs: []
  type: TYPE_NORMAL
- en: This example is overtly simple and does not highlight the complications involved
    in defining and using Iteratees. Let's try a more challenging use case. Now, we
    might need to build a web application that lets users connect to their database
    and load/view data over a WebSocket. Given this condition, the frontend sends
    JSON messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the WebSocket can get any of the following messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connection request**: It is a message that shows the information required
    to connect to a database (such as a host, port, user ID, and password)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query string**: It is the query to be executed in the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disconnect request**: It is a message that closes a connection with the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this, the message is translated and sent to the **DBActor**, which sends
    back a status message or a result with row data, and is then translated to JSON
    and sent back by the WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response received from the DBActor can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A successful connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connection failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invalid query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disconnected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can define a WebSocket handler for this scenario in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `WebSocketChannel` is an actor, which communicates with the DBActor and
    its companion object and is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`WebSocketChannel` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `convertJson` translates `JsValue` to the format that
    is understood by the DBActor.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will implement the same application using the new
    WebSocket methods available in Play since the 2.3.x version.
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket using Actors without Iteratees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Play WebSocket API allows the use of Actors to define the behavior. Let''s
    build the WebSocket application that replies with the reverse of a given String
    once it''s connected. We can do this by slightly modifying our Reverser Actor
    to have an argument as the reference of the Actor to which it can/must send messages,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `websocket` can then be defined in a controller as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we make an entry in the routes file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can now send messages through the WebSocket when the application is running
    using a browser plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, lets try to implement `dbWebSocket` using this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `WebSocketChannel` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `convertJsonToMsg` method is responsible for translating JSON to a format
    that is accepted by the DBActor.
  prefs: []
  type: TYPE_NORMAL
- en: Closing a WebSocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the WebSocket is closed, Play automatically stops the actor bound to it.
    This binding works in two ways: the WebSocket connection is closed when the underlying
    actor is killed. If there is a need to free any resources once the connection
    is closed, we can do so by overriding the actor''s `postStop` method. In our example,
    we have initialized a DBActor within `WebSocketChannel`. We will need to ensure
    that it''s killed once the WebSocket is closed, since each connection to the WebSocket
    will lead to the initialization of a DBActor. We can do so by sending it a poison
    pill, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Using FrameFormatter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose that an incoming JSON has the same fields for every request, instead
    of parsing it every time; we can define an equivalent class in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define our WebSocket to translate the JSON message to a `WebSocketRequest`
    automatically. This is possible by specifying the data type for the `acceptWithActor`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'However, for this to work as expected, we need two implicit values. The first
    is for translating incoming frames to `WebsocketRequest`, which requires a `JsValue`
    to the `WebSocketRequest` formatter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can specify the types of the outgoing messages as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FrameFormatter` is a helper and can convert `org.jboss.netty.handler.codec.http.websocketx.WebSocketFrame`
    to `play.core.server.websocket.Frames`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The WebSocket methods do not validate the format of data received automatically
    in the same manner as Action parsers. We will need to do this additionally, if
    required.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is the equivalent of interrupting `Actions` in `GlobalSettings` for `WebSockets`?
    What if we want to refuse a WebSocket connection when certain headers are missing?
    Something similar to the following code snippet didn''t work as expected:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Interrupting WebSocket from the global object does not work as it does for
    Actions. However, there are other means of doing so: by using the `tryAccept`
    and `tryAcceptWithActor` methods. A WebSocket definition can be replaced by the
    following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When using an Actor, define a WebSocket with the `tryAcceptWithActor` method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding examples, we are only checking to see if there is a token header,
    but this can be updated to any other criteria.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Does Play support wss?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As of 2.3.x, there is no built-in support for wss. However, it's possible to
    use proxies, such as Nginx or HAProxy as the secure WebSocket (wss) endpoint and
    forward to an internal Play app with an insecure WebSocket endpoint.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have learned a couple of things in this chapter. This chapter briefly covered
    the Actor Model and usage of Akka Actors in an application. In addition to this,
    we defined a WebSocket connection in a Play application with various constraints
    and requirements using two different approaches: the first one where we use Iteratees
    and Enumerators, and the second where we use Akka Actors.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see the different ways in which we can test a Play
    application using **Specs2** and **ScalaTest**.
  prefs: []
  type: TYPE_NORMAL
