- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter describes the basics of React programming. We will cover the skills
    that are required to create basic functionalities for our React frontend. In JavaScript,
    ­we use the **ECMAScript 2015** (**ES6**) syntax because it provides many features
    that make coding cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating React components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Useful ES6 features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSX and styling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Props and state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Context API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling lists, events, and forms with React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our work, React version 18 or higher will be required. We set up our environment
    correctly in *Chapter 7*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more resources at the GitHub link for this chapter: [https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Full-Stack-Development-with-Spring-Boot-3-and-React-Fourth-Edition/tree/main/Chapter08).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating React components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React is a JavaScript library for **user interfaces** (**UIs**). Since version
    15, React has been developed under the MIT license. React is component-based,
    and the components are independent and reusable. Components are the basic building
    blocks of React. When you start to develop a UI with React, it is good to start
    by creating **mock interfaces**. That way, it will be easy to identify what kinds
    of components you have to create and how they interact.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the following mock UI, we can see how the UI can be split into components.
    In this case, there will be an application root component, a search bar component,
    a table component, and a table row component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_08_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: React components'
  prefs: []
  type: TYPE_NORMAL
- en: 'The components can then be arranged in a **tree hierarchy**, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Component tree ](img/B19818_08_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Component tree'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **root component** has two **child components**: the search component and
    the table component. The table component has one child component: the table row
    component. The important thing to understand with React is that the data flow
    goes from a parent component to a child component. We will learn later how data
    can be passed from a parent component to a child component using props.'
  prefs: []
  type: TYPE_NORMAL
- en: React uses the **virtual document object model** (**VDOM**) for selective re-rendering
    of the UI, which makes it more cost-effective. The **document object model** (**DOM**)
    is a programming interface for web documents that represents the web page as a
    structured tree of objects. Each object in a tree corresponds to a part of the
    document. Using the DOM, programmers can create documents, navigate their structure,
    and add, modify, or delete elements and content. The VDOM is a lightweight copy
    of the DOM, and manipulation of the VDOM is much faster than it is with the real
    DOM. After the VDOM is updated, React compares it to a snapshot that was taken
    of the VDOM before updates were run. After the comparison, React will know which
    parts have been changed, and only these parts will be updated to the real DOM.
  prefs: []
  type: TYPE_NORMAL
- en: A React component can be defined either by using a JavaScript function – a **functional
    component** – or the ES6 JavaScript class – a **class component**. We will go
    more deeply into ES6 in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is some simple component source code that renders the `Hello World` text.
    This first code block uses a JavaScript function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The mandatory `return` statement in the React function component defines what
    the component looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, the following code uses the ES6 class to create a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The class component contains the required `render()` method, which shows and
    updates the rendered output of the component. If you compare the functional and
    class `App` components, you can see that the `render()` method is not needed in
    the functional component. Before React version 16.8, you had to use class components
    to be able to use states. Now, you can use hooks to create states with functional
    components as well. We will learn about states and hooks later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will create components using functions, which means we have
    to write less code. Functional components are a modern way to write React components,
    and we recommend avoiding using classes.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the React component should start with a capital letter. It is also
    recommended to use the PascalCase naming convention, whereby each word starts
    with a capital letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we are making changes to our example component’s `return` statement
    and adding a new `<h2>` element to it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if the app is run, we will see an **Adjacent JSX elements must be wrapped
    in an enclosing tag** error, as indicated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_08_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Adjacent JSX elements error'
  prefs: []
  type: TYPE_NORMAL
- en: 'If your component returns multiple elements, you have to wrap these inside
    one parent element. To fix this error, we have to wrap the header elements in
    one element, such as a `div`, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use a React **fragment**, as shown in the following code snippet.
    Fragments don’t add any extra nodes to the DOM tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also shorter syntax for fragments, which looks like empty JSX tags.
    This is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Examining our first React app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look more carefully at the first React app we created in *Chapter 7*,
    *Setting Up the Environment and Tools – Frontend*, using Vite.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code of the `main.jsx` file in the root folder looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of the file, there are `import` statements that load components
    and assets to our file. For example, the second line imports the `react-dom` package
    from the `node_modules` folder, and the third line imports the `App` component
    (the `App.jsx` file in the `src` folder). The fourth line imports the `index.css`
    style sheet that is in the same folder as the `main.jsx` file.
  prefs: []
  type: TYPE_NORMAL
- en: The `react-dom` package provides DOM-specific methods for us. To render the
    React component to the DOM, we can use the `render` method from the `react-dom`
    package. `React.StrictMode` is used to find potential problems in your React app
    and these are printed in the browser console. Strict Mode only runs in development
    mode and renders your components extra time, so it has time to find bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **root API** is used to render React components inside a browser DOM node.
    In the following example, we first create a root by passing the DOM element to
    the `createRoot` method. The root calls the `render` method to render an element
    to the root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `container` in the root API is the `<div id="root"></div>` element, which
    can be found in the `index.html` file inside the project root folder. Look at
    the following `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following source code shows the `App.jsx` component from our first React
    app. You can see that `import` also applies to assets, such as images and style
    sheets. At the end of the source code, there is an `export default` statement
    that exports the component, and it can be made available to other components by
    using the `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can see that in the `App` component that Vite has created, we don’t have
    semicolons at the end of statements. It is optional in JavaScript but, in this
    book, we will use semicolons to terminate statements when we start to create our
    own React components.
  prefs: []
  type: TYPE_NORMAL
- en: There can only be one `export default` statement per file, but there can be
    multiple named `export` statements. Default exports are commonly used to export
    React components. Named exports are commonly used to export specific functions
    or objects from a module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to import default and named exports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The exports look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have covered the basics of React components, let’s take a look at
    the basic features of ES6.
  prefs: []
  type: TYPE_NORMAL
- en: Useful ES6 features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ES6** was released in 2015, and it introduced a lot of new features. ECMAScript
    is a standardized scripting language, and JavaScript is one implementation of
    it. In this section, we will go through the most important features released in
    ES6 that we will be using in the following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Constants and variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you will get an error if you try to reassign the `PI` value, as indicated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Assignment to constant variable ](img/B19818_08_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Assignment to constant variable'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `const` is block-scoped. This means that the `const` variable can only
    be used inside the block in which it is defined. In practice, the block is the
    area between curly brackets `{}`. If `const` is defined outside of any function
    or block, it becomes a global variable, and you should try to avoid this situation.
    Global variables make code harder to understand, maintain, and debug. The following
    sample code shows how the scope works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The second `console.log` statement gives an error because we are trying to use
    the `total` variable outside its scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates what happens when `const` is an object or
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When `const` is an object or array, its properties or elements can be updated.
  prefs: []
  type: TYPE_NORMAL
- en: The `let` keyword allows you to declare *mutable* block-scoped variables. The
    variable declared using `let` can be used inside the block in which it is declared
    (it can also be used inside sub-blocks).
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The traditional way of defining a function in JavaScript is by using a `function`
    keyword. The following function takes one argument and returns the argument value
    multiplied by `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use the ES6 arrow function, the function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, by using the arrow function, we have made the declaration of
    the same function more compact. The function is a so-called **anonymous function**,
    and we can’t call it. Anonymous functions are often used as an argument for other
    functions. In JavaScript, functions are *first-class citizens* and you can store
    functions in variables, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can use the variable name to call the function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have more than one argument, you have to wrap the arguments in parentheses
    and separate the arguments with a comma to use the arrow function effectively.
    For example, the following function takes two parameters and returns their sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If the function body is an expression, then you don’t need to use the `return`
    keyword. The expression is always implicitly returned from the function. When
    you have multiple lines in the function body, you have to use curly brackets and
    a `return` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If the function doesn’t have any arguments, then you should use empty parentheses,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We are going to use lots of arrow functions later in our frontend implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Template literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Template literals can be used to concatenate strings. The traditional way to
    concatenate strings is to use the `+` operator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With template literals, the syntax looks like this. You have to use backticks
    ([PRE24]) instead of single or double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will learn how to use object destructuring.
  prefs: []
  type: TYPE_NORMAL
- en: Object destructuring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The object destructuring feature allows you to extract values from an object
    and assign them to a variable. You can use a single statement to assign multiple
    properties of an object to individual variables. For example, if you have this
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can destructure it using the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It creates three variables, `firstName`, `lastName`, and `email`, which get
    their values from the `person` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without object destructuring, you have to access each property individually,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will learn how to create classes using JavaScript ES6 syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Class definition in ES6 is similar to other object-oriented languages such as
    Java or C#. We saw an ES6 class when we looked at how to create React class components
    earlier. But, as we said earlier, classes are no longer recommended for creating
    React components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keyword for defining classes is `class`. A class can have fields, constructors,
    and class methods. The following sample code shows an ES6 class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Inheritance is performed with an `extends` keyword. The following sample code
    shows an `Employee` class that inherits a `Person` class. This means that it inherits
    all fields from the parent class and can have its own fields that are specific
    to `Employee`. In the constructor, we first call the parent class constructor
    by using the `super` keyword. That call is required by the rest of the code, and
    you will get an error if it is missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Although ES6 is already quite old, some of its features are still only partially
    supported by modern web browsers. **Babel** is a JavaScript compiler that is used
    to compile ES6 (or newer versions) to an older version that is compatible with
    all browsers. You can test the compiler on the Babel website ([https://babeljs.io](https://babeljs.io)).
    The following screenshot shows the arrow function compiling back to the older
    JavaScript syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Babel ](img/B19818_08_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Babel'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about the basics of ES6, let’s take a look at what
    JSX and styling are all about.
  prefs: []
  type: TYPE_NORMAL
- en: JSX and styling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JavaScript XML** (**JSX**) is the syntax extension for JavaScript. It is
    not mandatory to use JSX with React, but there are some benefits that make development
    easier. For example, JSX prevents injection attacks because all values are escaped
    in JSX before they are rendered. The most useful feature is that you can embed
    JavaScript expressions in JSX by wrapping them with curly brackets; this technique
    will be used a lot in the following chapters. JSX is compiled into regular JavaScript
    by Babel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we can access a component’s props when using JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Component props are covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also pass a JavaScript expression as props, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use both inline and external styling with React JSX elements. Here
    are two examples of inline styling. This first one defines the style inside the
    `div` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The second example creates a style object first, which is then used in the
    `div` element. The object name should use the *camelCase* naming convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in a previous section, you can import a style sheet into a React component.
    To reference classes from an external **CSS** file, you should use a `className`
    attribute, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will learn about React props and state.
  prefs: []
  type: TYPE_NORMAL
- en: Props and state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Props** and **state** are the input data for rendering a component. The component
    is re-rendered when the props or state change.'
  prefs: []
  type: TYPE_NORMAL
- en: Props
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Props** are inputs to components, and they are a mechanism to pass data from
    a parent component to its child component. Props are JavaScript objects, so they
    can contain multiple key-value pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Props are immutable, so a component cannot change its props. Props are received
    from the parent component. A component can access props through the `props` object
    that is passed to the function component as a parameter. For example, let’s take
    a look at the following component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The component just renders a static message, and it is not reusable. Instead
    of using a hardcoded name, we can pass a name to the `Hello` component by using
    props, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The parent component can send props to the `Hello` component in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the `Hello` component is rendered, it shows the `Hello John` text.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also pass multiple props to a component, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can access both props in the component using the `props` object, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, the component output is `Hello John Johnson`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use object destructuring to destructure a `props` object in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In React, the component **state** is an internal data store that holds information
    that can change over time. The state also affects the rendering of the component.
    When the state is updated, React schedules a re-render of the component. When
    the component re-renders, the state retains its latest values. State allows components
    to be dynamic and responsive to user interactions or other events.
  prefs: []
  type: TYPE_NORMAL
- en: It’s generally a good practice to avoid introducing unnecessary states in your
    React components. Unnecessary states increase the complexity of your components
    and can cause unwanted side effects. Sometimes, a local variable can be a better
    option. But you have to understand that *changes to local variables won’t trigger
    re-rendering*. Each time a component re-renders, local variables are reinitialized,
    and their values don’t persist between renders.
  prefs: []
  type: TYPE_NORMAL
- en: 'The state is created using the `useState` hook function. It takes one argument,
    which is the initial value of the state, and returns an array of two elements.
    The first element is the name of the state, and the second element is a function
    that is used to update the state value. The syntax of the `useState` function
    is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The next code example creates a state variable called `name`, and the initial
    value is `Jim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also import the `useState` function from React, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you don’t need to type the `React` keyword, as indicated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of the state can now be updated by using the `setName` function,
    as illustrated in the following code snippet. This is the only way to modify the
    state value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You should never update the state value directly using the `=` operator. If
    you update the state directly, as shown next, React won’t re-render the component
    and you will also get an error because you cannot reassign the `const` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have multiple states, you can call the `useState` function multiple
    times, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can update states using the `setFirstName` and `setLastName` functions,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also define state using an object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can update both the `firstName` and `lastName` state object parameters
    using the `setName` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to do a partial update of the object, you can use the **spread
    operator**. In the following example, we use the object spread syntax (`...`)
    that was introduced in ES2018\. It clones the `name` state object and updates
    the `firstName` value to be `Jim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'A state can be accessed by using the state name, as shown in the next example.
    The scope of the state is the component, so it cannot be used outside the component
    in which it is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If your state is an object, then you can access it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We have now learned the basics of state and props, and we will learn more about
    states later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The React **stateless component** is just a pure JavaScript function that takes
    props as an argument and returns a React element. Here’s an example of a stateless
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now, the component is rendered and **memoized**. In the next render, React renders
    a memoized result if the props are not changed. The `React.memo()` phrase also
    has a second argument, `arePropsEqual()`, which you can use to customize rendering
    conditions, but we will not cover that here. The one benefit of using functional
    components is unit testing, which is straightforward because their return values
    are always the same for the same input values.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use a conditional statement to render different UIs if a condition is
    `true` or `false`. This feature can be used, for example, to show or hide some
    elements, handle authentication, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will check if `props.isLoggedin` is `true`. If
    so, we will render the `<Logout />` component; otherwise, we render the `<Login
    />` component. This is now implemented using two separate `return` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also implement this by using `condition ? true : false` logical operators,
    and then you need only one `return` statement, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: React hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Hooks** were introduced in React version 16.8\. Hooks allow you to use state
    and some other React features in functional components. Before hooks, you had
    to write class components if states or complex component logic were needed.'
  prefs: []
  type: TYPE_NORMAL
- en: There are certain important rules for using hooks in React. You should always
    call hooks at the top level in your React function component. You shouldn’t call
    hooks inside loops, conditional statements, or nested functions. Hook names begin
    with the word `use`, followed by the purpose they serve.
  prefs: []
  type: TYPE_NORMAL
- en: useState
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are already familiar with the `useState` hook function that is used to declare
    states. Let’s look at one more example of using the `useState` hook. We will create
    an example counter that contains a button, and when it is pressed, the counter
    is increased by `1`, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_08_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Counter component'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a `Counter` component and declare a state called `count` with
    the initial value `0`. The value of the counter state can be updated using the
    `setCount` function. The code is illustrated in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we render a button element that increments the state by `1`. We use the
    `onClick` event attribute to call the `setCount` function, and the new value is
    the current value plus `1`. We will also render the counter state value. The code
    is illustrated in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, our `Counter` component is ready, and the counter is incremented by `1`
    each time the button is pressed. When the state is updated, React re-renders the
    component and we can see the new `count` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In React, events are named using camelCase, for example, **onClick**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the function must be *passed* to an event handler, and then React
    will call the function only when the user clicks the button. We use an arrow function
    in the following example because it is more compact to write and improves code
    readability. If you call the function *in* the event handler, then the function
    is called when the component is rendered, which can cause an infinite loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'State updates are asynchronous, so you have to be careful when a new state
    value depends on the current state value. To be sure that the latest value is
    used, you can pass a function to the update function. You can see an example of
    this here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Now, the previous value is passed to the function, and the updated value is
    returned and saved to the `count` state.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a hook function called `useReducer` that is recommended when you
    have a complex state, but we won’t cover that in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Batching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'React uses **batching** in state updates to reduce re-renders. Before React
    version 18, batching only worked in states updated during browser events – for
    example, a button click. The following example demonstrates the idea of batch
    updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: From React version 18 onward, all state updates will be batched. If you don’t
    want to use batch updates in some cases, you can use the `react-dom` library’s
    `flushSync` API to avoid batching. For example, you might have a case where you
    want to update some state before updating the next one. It can be useful when
    incorporating third-party code, such as browser APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code you’d need to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: You should use `flushSync` only if it is needed, because it can affect the performance
    of your React app.
  prefs: []
  type: TYPE_NORMAL
- en: useEffect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `useEffect` hook function can be used to perform side effects in the React
    function component. The side effect can be, for example, a `fetch` request. The
    `useEffect` hook takes two arguments, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `callback` function contains side-effect logic, and `[dependencies]` is
    an optional array of dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, we can see what the console now looks like, and
    we can see that the `useEffect` callback is invoked after each render. The first
    log row is printed after the initial render, and the rest are printed after the
    button is pressed two times and the component is re-rendered due to state updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_08_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: useEffect'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass an empty array as the second argument, the `useEffect` callback
    function runs only after the first render, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can see that **Hello from useEffect** is printed only once after the
    initial render, and if you press the button, the text is not printed. The message
    is printed twice after the first render due to React Strict Mode. Strict Mode
    renders your component twice in development mode to find bugs and does not impact
    the production build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_08_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: useEffect with an empty array'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the counter app with these changes, you can see what happens in
    the console, as shown in the following screenshot. The component is rendered twice
    at the beginning due to Strict Mode. After the initial render, the component is
    unmounted (removed from the DOM), and therefore, the cleanup function is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_08_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: Cleanup function'
  prefs: []
  type: TYPE_NORMAL
- en: useRef
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `useRef` hook returns a mutable `ref` object that can be used, for example,
    to access DOM nodes. You can see it in action here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ref` object returned has a `current` property that is initialized with
    the argument passed (`initialValue`). In the next example, we create a `ref` object
    called `inputRef` and initialize it to `null`. Then, we use the JSX element’s
    `ref` property and pass our `ref` object to it. Now, it contains our `input` element,
    and we can use the `current` property to execute the `input` element’s `focus`
    function. Now, when the button is pressed, the input element is focused:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have learned the basics of React hooks, and we will use
    them in practice when we start to implement our frontend. There are other useful
    hook functions available in React, and next you will learn how to create your
    own hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Custom hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can build your own hooks in React. As we have seen already, hooks’ names
    should start with the `use` word, and they are JavaScript functions. Custom hooks
    can also call other hooks. With custom hooks, you can reduce your component code
    complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go through a simple example of creating a custom hook:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a `useTitle` hook that can be used to update a document title.
    We will define it in its own file called `useTitle.js`. First, we define a function,
    and it gets one argument named `title`. The code is illustrated in the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will use a `useEffect` hook to update the document title each time
    the `title` argument is changed, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can start to use our custom hook. Let’s use it in our counter example
    and print the current counter value into the document title. First, we have to
    import the `useTitle` hook into our `Counter` component, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will use the `useTitle` hook to print the `count` state value into
    the document title. We can call our hook function in the top level of the `Counter`
    component function, and every time the component is rendered, the `useTitle` hook
    function is called and we can see the current count value in the document title.
    The code is illustrated in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if you click the button, the `count` state value is also shown in the
    document title using our custom hook, as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19818_08_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: Custom hook'
  prefs: []
  type: TYPE_NORMAL
- en: You now have basic knowledge of React hooks and how you can create your own
    custom hooks.
  prefs: []
  type: TYPE_NORMAL
- en: The Context API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Passing data using props can be cumbersome if your component tree is deep and
    complex. You have to pass data through all components down the component tree.
    **The Context API** solves this problem, and it is recommended for use with *global*
    data that you might need in multiple components throughout your component tree
    – for example, a theme or authenticated user.
  prefs: []
  type: TYPE_NORMAL
- en: '**Context** is created using the `createContext` method, which takes an argument
    that defines the default value. You can create your own file for the context,
    and the code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will use a context provider component, which makes our context available
    for other components. The context provider component has a `value` prop that will
    be passed to consuming components. In the following example, we have wrapped `<MyComponent
    />` using the context provider component, so the `userName` value is available
    in our component tree under `<MyComponent />`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can access the value provided in any component in the component tree
    by using the `useContext()` hook, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The component now renders the `Welcome` `john` text.
  prefs: []
  type: TYPE_NORMAL
- en: Handling lists with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For list handling, we will learn about the JavaScript `map()` method, which
    is useful when you have to manipulate a list. The `map()` method creates a new
    array containing the results of calling a function on each element in the original
    array. In the following example, each array element is multiplied by `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example code demonstrates a component that transforms an array
    of integers into an array of list items and renders these inside the `ul` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows what the component looks like when it is rendered.
    If you open the console, you can see a warning (**Each child in a list should
    have a unique** **"****key****"** **prop**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_08_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: React list component'
  prefs: []
  type: TYPE_NORMAL
- en: 'List items in React need a **unique key** that is used to detect rows that
    have been updated, added, or deleted. The `map()` method also has `index` as a
    second argument, which we use to handle the warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Now, after adding the key, there is no warning in the console.
  prefs: []
  type: TYPE_NORMAL
- en: The usage of `index` is not recommended because it can cause bugs if the list
    is reordered or if you add or delete list items. Instead of that, you should use
    a unique key from the data if that exists. There are also libraries available
    that you can use to generate unique IDs, like **uuid** ([https://github.com/uuidjs/uuid](https://github.com/uuidjs/uuid)).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the data is an array of objects, it would be nicer to present it in table
    format. We do this in roughly the same way as we did with the list, but now we
    just map the array to table rows (`tr` elements) and render these inside the `table`
    element, as shown in the following component code. Now we have a unique ID in
    the data so we can use it as a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows what the component looks like when it is rendered.
    You should see the data in the HTML table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_08_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: React table'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have learned how to handle list data using the `map()` method and how
    to render it using, for example, an HTML `table` element.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Event handling in React is similar to handling DOM element events. The difference
    compared to HTML event handling is that event naming uses *camelCase* in React.
    The following sample component code adds an event listener to a button and shows
    an alert message when the button is pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'As we learned earlier in the counter example, you have to pass a function to
    the event handler instead of calling it. Now, the `handleClick` function is defined
    outside the `return` statement, and we can refer to it using the function name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'In React, you cannot return `false` from the event handler to prevent the default
    behavior. Instead, you should call the event object’s `preventDefault()` method.
    In the following example, we are using a `form` element, and we want to prevent
    form submission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you press the **Submit** button, you can see the alert and the form
    will not be submitted.
  prefs: []
  type: TYPE_NORMAL
- en: Handling forms with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Form handling is a little bit different with React. An HTML `form` will navigate
    to the next page when it is submitted. In React, often, we want to invoke a JavaScript
    function that has access to form data after submission, and avoid navigating to
    the next page. We already covered how to avoid submission in the previous section
    using `preventDefault()`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first create a minimalistic form with one input field and a **Submit**
    button. In order to get the value of the input field, we use the `onChange` event
    handler. We use the `useState` hook to create a state variable called `text`.
    When the value of the input field is changed, the new value will be saved to the
    state. This component is called a **controlled component** because form data is
    handled by React. In an uncontrolled component, the form data is handled only
    by the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setText(event.target.value)` statement gets the value from the `input`
    field and saves it to the state. Finally, we will show the typed value when a
    user presses the **Submit** button. Here is the source code for our first form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a screenshot of our form component after the **Submit** button has
    been pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_08_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.13: Form component'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also write an inline `onChange` handler function using JSX, as shown
    in the following example. This is quite common practice if you have a simple event
    handler function, and it makes your code more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Now is a good time to look at React Developer Tools, which are useful for debugging
    React apps.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t installed React Developer Tools yet, you can find the instructions
    in *Chapter 7*, *Setting Up the Environment and Tools – Frontend*.
  prefs: []
  type: TYPE_NORMAL
- en: If we open the React Developer Tools **Components** tab with our React form
    app and type something into the input field, we can see how the value of the state
    changes, and we can inspect the current value of both the props and the state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the state changes when we type something
    into the input field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_08_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.14: React Developer Tools'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'One way to handle multiple input fields is to add as many change handlers as
    we have input fields, but this creates a lot of boilerplate code, which we want
    to avoid. Therefore, we add `name` attributes to our input fields. We can utilize
    these in the change handler to identify which input field triggers the change
    handler. The `name` attribute value of the `input` element must be the same as
    the name of the state object property in which we want to save the value, and
    the value attribute should be `object.property`, for example, in the last name
    input element. The code is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if the input field that triggers the handler is the last name field, then
    `event.target.name` is `lastName`, and the typed value will be saved to the state
    object’s `lastName` field. Here, we will also use the object spread notation that
    was introduced in the *Props and state* section. In this way, we can handle all
    input fields with the one change handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the full source code for the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a screenshot of our form component after the **Submit** button has
    been pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19818_08_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.15: React form component'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: We now know how to handle forms with React, and we will use these skills later
    when we implement our frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started to learn about React, which we will be using to
    build our frontend. In our frontend development, we will use ES6, which makes
    our code cleaner, as we saw in the chapter. Before starting to develop with React,
    we covered the basics, such as the React component, JSX, props, state, and hooks.
    We then went through the features we need for further development. We learned
    about conditional rendering and context, as well as how to handle lists, forms,
    and events with React.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on TypeScript with React. We will learn the
    basics of TypeScript and how to use it in our React projects.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a React component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are states and props?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does data flow in a React app?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between stateless and stateful components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is JSX?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are React hooks named?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does context work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some other good resources for learning about React:'
  prefs: []
  type: TYPE_NORMAL
- en: '*React – The Complete Guide*, by Maximilian Schwarzmüller ([https://www.packtpub.com/product/react-the-complete-guide-includes-hooks-react-router-and-redux-2021-updated-second-edition-video/9781801812603](https://www.packtpub.com/product/react-the-complete-guide-includes-hooks-react-router-and-redux-2021-updated-second-edition-video/9781801812603))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Ultimate React Course 2023*, by Jonas Schmedtmann ([https://www.udemy.com/course/the-ultimate-react-course/](https://www.udemy.com/course/the-ultimate-react-course/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask the author questions, and learn about new releases – follow the QR code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/FullStackSpringBootReact4e](https://packt.link/FullStackSpringBootReact4e)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code10796108009382640.png)'
  prefs: []
  type: TYPE_IMG
