- en: Chapter 7. Configuring mod_cluster with SSL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 使用SSL配置mod_cluster
- en: In the previous chapter, we learned how to use SSL with JK (mod_jk). In this
    chapter, we will check the design of mod_cluster first, and discuss how it can
    be used with SSL. Then we will learn how to configure the httpd and EAP6 servers
    so that they can use SSL.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用SSL与JK（mod_jk）一起使用。在本章中，我们将首先检查mod_cluster的设计，并讨论如何与SSL一起使用。然后我们将学习如何配置httpd和EAP6服务器，以便它们可以使用SSL。
- en: First, let's check the design of mod_cluster.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们检查mod_cluster的设计。
- en: The design of mod_cluster
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mod_cluster的设计
- en: As we have seen in the last chapter, JK uses the AJP13 protocol between the
    load balancer and worker nodes. In comparison to JK, mod_cluster allows us to
    secure its communication channels.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，JK在负载均衡器和工作节点之间使用AJP13协议。与JK相比，mod_cluster允许我们确保其通信通道的安全性。
- en: 'In design, mod_cluster uses three channels for communication: the advertising
    channel, the management channel, and the proxy channel. mod_cluster allows us
    to secure the communication in the management and proxy channels.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计中，mod_cluster使用三个通道进行通信：广告通道、管理通道和代理通道。mod_cluster允许我们在管理通道和代理通道中确保通信的安全性。
- en: 'The following is the deployment diagram:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的部署图：
- en: '![The design of mod_cluster](img/2432OS_07_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![mod_cluster的设计](img/2432OS_07_01.jpg)'
- en: 'As we can see from the preceding diagram, SSL communications can be enabled
    in the following three places:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，SSL通信可以在以下三个地方启用：
- en: Communication between users and httpd
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户与httpd之间的通信
- en: The mod_cluster management channel communication between httpd and EAP6
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: httpd和EAP6之间的mod_cluster管理通道通信
- en: The mod_cluster proxy channel communication between httpd and EAP6
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: httpd和EAP6之间的mod_cluster代理通道通信
- en: 'We learned how to enable SSL communication between users and httpd in the previous
    chapter. We need to generate a self-signed certificate and configure mod_ssl in
    httpd to use the certificate. The following is the configuration that we used
    in the previous chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用SSL在用户和httpd之间启用通信。我们需要生成一个自签名证书，并在httpd中配置mod_ssl以使用该证书。以下是我们上一章使用的配置：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding configuration is actually for mod_ssl; so, it remains unchanged
    when we switch our load balancer component from JK to mod_cluster.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配置实际上是针对mod_ssl的；因此，当我们从JK切换到mod_cluster的负载均衡器组件时，它保持不变。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please check the `mod-cluster-ssl.conf` file in this chapter's code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请检查本章代码中的`mod-cluster-ssl.conf`文件。
- en: In addition to the pure mod_ssl support of httpd to enable SSL communication
    between users and httpd, mod_cluster provides additional functions to secure data
    transmission between the httpd and EAP6 servers. In the following sections, we
    will have a look at how to enable secure communication for the other two places
    that are mentioned. First, we'll learn how to enable SSL in the mod_cluster management
    channel.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了httpd对纯mod_ssl的支持以启用用户和httpd之间的SSL通信外，mod_cluster还提供了额外的功能，以确保httpd和EAP6服务器之间数据传输的安全性。在接下来的章节中，我们将探讨如何为提到的其他两个地方启用安全通信。首先，我们将学习如何在mod_cluster管理通道中启用SSL。
- en: Enabling SSL for the mod_cluster management channel
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用mod_cluster管理通道的SSL
- en: In this section, we will learn how to secure the MCMP channel. This means that
    the MCMP messages will be transferred over SSL.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何保护MCMP通道。这意味着MCMP消息将通过SSL传输。
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In the mod_cluster documentation, we named the protocol MCMP, which stands for
    **Mod-Cluster Management Protocol**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在mod_cluster文档中，我们称该协议为MCMP，代表**Mod-Cluster Management Protocol**。
- en: In design, mod_cluster uses SSL mutual authentication to secure the MCMP channel.
    This means that we must create certificates for both the servers. EAP6 needs to
    trust the certificate provided by httpd; meanwhile, httpd must trust the certificate
    from the EAP6 server. So, we need two certificates instead of just one.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计中，mod_cluster使用SSL双向认证来保护MCMP通道。这意味着我们必须为服务器创建证书。EAP6需要信任httpd提供的证书；同时，httpd必须信任来自EAP6服务器的证书。因此，我们需要两个证书而不是一个。
- en: An introduction to SSL mutual authentication
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSL双向认证简介
- en: In the previous chapter, we created a self-signed certificate for httpd to enable
    HTTPS communication with users. When users use the web browser to access our website,
    httpd will provide its certificate to the web browser. If a user chooses to trust
    the certificate, the web browser will establish a secure connection with our server.
    This is called one-way authentication. It means that the user will verify the
    identity of the website, but the website won't verify the identity of the user.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们为httpd创建了一个自签名证书，以启用与用户的HTTPS通信。当用户使用网络浏览器访问我们的网站时，httpd将向网络浏览器提供其证书。如果用户选择信任该证书，网络浏览器将与我们的服务器建立安全连接。这被称为单向认证。这意味着用户将验证网站的标识，但网站不会验证用户的身份。
- en: Since our certificate is self-signed, the web browser will pop up a warning
    to tell the user that it cannot verify the identity of this certificate, and the
    user will need to decide whether to trust it or not. But if our certificate is
    signed by an authority, the web browser will trust our certificate without any
    pop-up warning messages. This is because every web browser contains a default
    list of authorities. The certificates signed by these authorities will be trusted
    by default.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的证书是自签名的，网络浏览器将弹出警告，告知用户它无法验证此证书的身份，用户需要决定是否信任它。但如果我们的证书由权威机构签发，网络浏览器将信任我们的证书而不会弹出任何警告信息。这是因为每个网络浏览器都包含一个默认的权威机构列表。这些权威机构签发的证书将被默认信任。
- en: 'For example, I can see the following list of default CAs in my Firefox browser:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我可以在我的Firefox浏览器中看到以下默认CA列表：
- en: '![An introduction to SSL mutual authentication](img/2432OS_07_29.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![SSL双向认证简介](img/2432OS_07_29.jpg)'
- en: Firefox will trust the certificates signed by these authorities only. JDK also
    contains one such list that is usually the `$JAVA_HOME/jre/lib/security/cacerts`
    file.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox只会信任这些权威机构签发的证书。JDK也包含这样一个列表，通常是`$JAVA_HOME/jre/lib/security/cacerts`文件。
- en: 'Now, let''s talk about encrypting the communication between httpd and EAP6\.
    First, we will learn about one-way authentication. This scenario is shown in the
    following diagram:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈加密httpd和EAP6之间的通信。首先，我们将了解单向认证。这种情况在下面的图中展示：
- en: '![An introduction to SSL mutual authentication](img/2432OS_07_06.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![SSL双向认证简介](img/2432OS_07_06.jpg)'
- en: Since EAP6 is running in JVM, it trusts a default list of CAs. Our self-signed
    certificate is obviously not signed by these authorities; so, by default, EAP6
    won't trust it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于EAP6运行在JVM中，它信任一组默认的CA。我们的自签名证书显然不是由这些机构签发的；因此，默认情况下，EAP6不会信任它。
- en: 'To solve this problem, we can create an authority ourselves, and sign the certificate
    using this authority. Then we can place the authority in EAP6 to override the
    default trust list so that EAP6 trusts the certificate signed by it. This scenario
    is shown in the following diagram:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以自己创建一个权威机构，并使用这个权威机构来签发证书。然后，我们可以将这个权威机构放置在EAP6中，以覆盖默认的信任列表，这样EAP6就会信任它所签发的证书。这种情况在下面的图中展示：
- en: '![An introduction to SSL mutual authentication](img/2432OS_07_07.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![SSL双向认证简介](img/2432OS_07_07.jpg)'
- en: 'With the previous method, we can establish a one-way authentication from httpd
    to EAP6\. If we want to establish a mutual SSL authentication, we need to additionally
    create a certificate for EAP6, and sign it with myca. Then, we need to configure
    httpd to put myca in its trust list so that it trusts the EAP6 certificate. The
    following diagram shows this scenario:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前的方法，我们可以从httpd到EAP6建立单向认证。如果我们想建立双向SSL认证，我们需要为EAP6额外创建一个证书，并用myca签发它。然后，我们需要配置httpd将myca放入其信任列表，以便它信任EAP6的证书。下面的图展示了这种情况：
- en: '![An introduction to SSL mutual authentication](img/2432OS_07_09.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![SSL双向认证简介](img/2432OS_07_09.jpg)'
- en: As we can see from this diagram, **httpd** will show its certificate to **EAP6**,
    and **EAP6** will show its certificate to **httpd.** Only then will they trust
    each other because their certificates are signed by myca as myca is in their trust
    list. mod_cluster enforces this mutual SSL authentication. In the following sections,
    we will learn how to configure httpd and EAP6 properly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个图中我们可以看到，**httpd**将向**EAP6**展示其证书，**EAP6**也将向**httpd**展示其证书。只有在他们的证书由myca签发，并且myca在他们的信任列表中时，他们才会相互信任。mod_cluster强制执行这种双向SSL认证。在接下来的章节中，我们将学习如何正确配置httpd和EAP6。
- en: Configuring SSL mutual authentication
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置SSL双向认证
- en: 'As we have learned the concepts of SSL mutual authentication, let''s now configure
    our environment to enable it. We need to create the following three certificates:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经学习了 SSL 互信认证的概念，现在让我们配置我们的环境以启用它。我们需要创建以下三个证书：
- en: One self-signed certificate as the authority. Let's name it `myca.crt`.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个作为权威机构的自签名证书。让我们称它为 `myca.crt`。
- en: One certificate for httpd, signed by myca. Let's name it `httpd.crt`.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 httpd 创建一个由 myca 签署的证书。让我们称它为 `httpd.crt`。
- en: One certificate for EAP6, signed by myca. Let's name it `eap6.crt`.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 EAP6 创建一个由 myca 签署的证书。让我们称它为 `eap6.crt`。
- en: Let's create them one by one.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个创建它们。
- en: Creating a CA certificate
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 CA 证书
- en: First, we will create a CA certificate. The term **CA** stands for **Certificate
    Authority**; it's actually a self-signed certificate that will be used to sign
    the other certificates. If one application puts this CA into its trust list, the
    certificates that are signed by it will be trusted.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个 CA 证书。术语 **CA** 代表 **证书授权机构**；它实际上是一个自签名证书，将用于签署其他证书。如果一个应用程序将其 CA
    放入其信任列表中，由它签署的证书将被信任。
- en: We'll create a self-signed certificate named `myca` and use it as our CA. Before
    we create it, please prepare a directory called `certs` and place it appropriately.
    Since we'll create three certificates along with their key files, it's better
    to put them together. For me, I'll put it in `/packt/certs`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `myca` 的自签名证书，并将其用作我们的 CA。在我们创建它之前，请准备一个名为 `certs` 的目录，并将其放置在适当的位置。由于我们将创建三个证书及其密钥文件，最好将它们放在一起。对我来说，我会将其放在
    `/packt/certs`。
- en: 'Please use the following command to create a self-signed certificate together
    with its key file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用以下命令创建一个自签名证书及其密钥文件：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the preceding command, I have generated a key pair with its self-signed
    certificate, and the `CN` of this certificate is `myca`. We can see this by checking
    the content of the certificate as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命令，我已经生成了一对密钥及其自签名证书，该证书的 `CN` 是 `myca`。我们可以通过以下方式检查证书内容来查看这一点：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see, the `Owner` and `Issuer` are the same. Now, let's create a certificate
    for httpd, and sign it with myca.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`Owner` 和 `Issuer` 是相同的。现在，让我们为 httpd 创建一个证书，并用 myca 签署它。
- en: Creating a certificate for httpd
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为 httpd 创建证书
- en: 'As we have the authority myca now, let''s create a certificate for httpd and
    then sign it with myca. We first need to create a key pair for httpd with the
    following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在有了 myca 权威机构，让我们为 httpd 创建一个证书，然后用 myca 签署它。我们首先需要使用以下命令为 httpd 创建一个密钥对：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we can see from the preceding command, the key file is named `httpd.key`.
    Next, we''ll create a certificate related to the key pair; the following command
    does this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述命令所示，密钥文件名为 `httpd.key`。接下来，我们将创建与密钥对相关的证书；以下命令执行此操作：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Please note that the `CN` value of our certificate is `httpd`. As a result of
    running the previous command, we get the `http.csr` file that waits to be signed.
    Now, we need to use the tools provided by OpenSSL to sign this certificate with
    myca, but before that we need to set up OpenSSL properly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们证书的 `CN` 值是 `httpd`。运行前面的命令后，我们得到等待签署的 `http.csr` 文件。现在，我们需要使用 OpenSSL
    提供的工具使用 myca 签署此证书，但在那之前，我们需要正确设置 OpenSSL。
- en: Setting up OpenSSL
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 OpenSSL
- en: 'OpenSSL has its own workflow for signing the certificate. Please run the following
    command to set up the working environment for OpenSSL:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL 有自己的证书签名工作流程。请运行以下命令以设置 OpenSSL 的工作环境：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our signed certificate will be placed in the `newcerts` directory and named
    `01.pem`. Please make sure that you have run the previous command from the `certs`
    directory that contains the myca and httpd certificates.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们签署的证书将被放置在 `newcerts` 目录中，并命名为 `01.pem`。请确保您已从包含 myca 和 httpd 证书的 `certs`
    目录运行了前面的命令。
- en: 'The next step is to loosen the signing policy in OpenSSL. First, we need to
    locate the configuration file that OpenSSL is using. Please run the following
    command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是放宽 OpenSSL 的签名策略。首先，我们需要定位 OpenSSL 使用的配置文件。请运行以下命令：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can see the location of the configuration file used by OpenSSL from the
    previous command. Let''s open `openssl.cnf` and find the `policy_match` section.
    Other than `commonName`, we need to change all the items in this section to `optional`.
    The following screenshot lists the details:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从之前的命令中看到 OpenSSL 使用的配置文件的位置。让我们打开 `openssl.cnf` 并找到 `policy_match` 部分。除了
    `commonName` 之外，我们需要将此部分的所有项更改为 `optional`。以下截图列出了详细信息：
- en: '![Setting up OpenSSL](img/2432OS_07_16.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![设置 OpenSSL](img/2432OS_07_16.jpg)'
- en: 'In addition, we need to change the default directory that OpenSSL will use
    to sign the certificates; this is done as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要更改OpenSSL默认使用的目录来签署证书；以下是操作步骤：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are changing the OpenSSL defaults merely for testing purposes. In practice,
    this will loosen the security of the certificates.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更改OpenSSL默认设置只是为了测试目的。实际上，这将降低证书的安全性。
- en: We should always use the default positions for signing certificates and carefully
    manage their permissions in production environment.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在生产环境中签署证书时应该始终使用默认位置，并仔细管理它们的权限。
- en: In addition, a real CA faculty will usually require you to provide a certificate
    with the valid information that it requires. For example, a requirement could
    be that your certificate's CN must match your DNS hostname, and your country's
    name must match your host location.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，真正的CA机构通常会要求你提供包含它所需有效信息的证书。例如，可能的要求是，你的证书的CN必须匹配你的DNS主机名，而你所在国家的名称必须匹配你的主机位置。
- en: Signing the httpd.csr file
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 签署httpd.csr文件
- en: 'Since we have set OpenSSL properly, we can now start signing our httpd certificate.
    Please make sure that you are in the `certs` directory, and that it includes a
    `demoCA` directory with the necessary file contents. Please run the following
    command to sign the httpd certificate:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经正确设置了OpenSSL，我们现在可以开始签署我们的httpd证书。请确保您位于`certs`目录中，并且它包含一个包含必要文件内容的`demoCA`目录。请运行以下命令来签署httpd证书：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we have signed `httpd.csr`; this signed certificate is located in `demoCA/newcerts`,
    and is named `01.pem`. Let''s check the content of this certificate:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经签署了`httpd.csr`；这个已签名的证书位于`demoCA/newcerts`中，名称为`01.pem`。让我们检查此证书的内容：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can see that the `Subject` value is `httpd` and the `Issuer` value is `myca`.
    So we''ve used our own CA to sign our certificate. Let''s copy this certificate
    into the `certs` directory and rename it to `httpd.crt`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`Subject`值为`httpd`，`Issuer`值为`myca`。因此，我们使用了我们自己的CA来签署我们的证书。让我们将此证书复制到`certs`目录，并将其重命名为`httpd.crt`：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That's all for the httpd certificate. Now, let's work on the EAP6 server, create
    a certificate for it, and also sign this with myca.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 关于httpd证书的内容就到这里。现在，我们来处理EAP6服务器，为它创建一个证书，并且使用myca进行签名。
- en: Creating a certificate for EAP6
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为EAP6创建证书
- en: The processes in the EAP6 server are different; first, we need to use the `keytool`
    command to create a keystore with a self-signed certificate. Then, we will export
    the certificate from the keystore, and sign it with myca. Later, we'll import
    `myca.crt` into the keystore to act as a trust authority. So, all the certificates
    signed by myca will be trusted and accepted by JVM. After that, we'll import the
    signed EAP6 certificate back to the keystore.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: EAP6服务器中的过程有所不同；首先，我们需要使用`keytool`命令创建一个带有自签名证书的密钥库。然后，我们将从密钥库中导出证书，并使用myca进行签名。之后，我们将`myca.crt`导入密钥库，作为信任权威。因此，所有由myca签名的证书都将被JVM信任和接受。之后，我们将已签名的EAP6证书重新导入密钥库。
- en: 'First, let''s create a keystore. The keystore file `eap6.ks` will have the
    default key pair and a self-signed certificate that is related to the key pair.
    The following is the command for creating the keystore:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个密钥库。密钥库文件`eap6.ks`将包含默认密钥对和一个与密钥对相关的自签名证书。以下是创建密钥库的命令：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'From the preceding command, we can see that the keystore is named `eap6.ks`,
    and the alias of the certificate is `eap6cert`. The `cn` field of the certificate
    has a value of `eap6`, and this certificate is self-signed by default. We can
    check this with the `keytool` command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的命令中，我们可以看到密钥库的名称为`eap6.ks`，证书的别名为`eap6cert`。证书的`cn`字段值为`eap6`，并且该证书默认为自签名。我们可以使用`keytool`命令来检查这一点：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s export `eap6cert` for the signing request using the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令导出用于签名的`eap6cert`：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the preceding command, we get the **Certificate Signing Request** (**CSR**)
    file, `eap6cert.csr`. We need to sign this certificate with myca. The process
    is exactly the same as it was for the signing of the `httpd.csr` file. We need
    to place `eap6cert.csr` in the `certs` directory, and we need to reuse the `demoCA`
    directory that is created for signing the httpd certificate. Please note that
    we don''t need to reset the serial number in `./demoCA/serial`, and don''t delete
    the httpd certificate `01.pem` from the `newcerts` directory. OpenSSL will automatically
    increase the serial number, and the signed EAP6 certificate will be named `02.pem`.
    The following code snippet denotes the signing process:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命令，我们得到了 **证书签名请求**（**CSR**）文件，`eap6cert.csr`。我们需要用 myca 签署此证书。过程与签署 `httpd.csr`
    文件时完全相同。我们需要将 `eap6cert.csr` 放入 `certs` 目录，并且需要重新使用为签署 httpd 证书而创建的 `demoCA` 目录。请注意，我们不需要在
    `./demoCA/serial` 中重置序列号，也不要从 `newcerts` 目录中删除 httpd 证书 `01.pem`。OpenSSL 将自动增加序列号，签署的
    EAP6 证书将被命名为 `02.pem`。以下代码片段表示签署过程：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With this process, the EAP6 certificate is signed and stored in `demoCA/serial/02.pem`.
    Now, let''s copy `02.pem` to `eap6raw.crt`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个过程，EAP6 证书被签署并存储在 `demoCA/serial/02.pem` 中。现在，让我们将 `02.pem` 复制到 `eap6raw.crt`：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can check the contents of this certificate as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式检查此证书的内容：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'From the `Issuer` and `Subject` fields, we can see that the certificate is
    signed. In addition, we can see the encoded certificate data at the bottom of
    this file. Let''s use the following command to extract the encoded certificate
    text from `eap6raw.crt`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Issuer` 和 `Subject` 字段，我们可以看到证书已被签署。此外，我们可以在文件底部看到编码的证书数据。让我们使用以下命令从 `eap6raw.crt`
    中提取编码的证书文本：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The Java security library can only read the certificate in the previously encoded
    format, and doesn''t allow any extra text in the certificate file. So, we need
    to extract the encoded certificate data to another file using the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Java 安全库只能读取之前编码格式的证书，并且不允许证书文件中有任何额外的文本。因此，我们需要使用以下命令将编码的证书数据提取到另一个文件中：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the preceding command, we have extracted the encoded certificate data
    to `eap6cert.crt`; only then can the `keytool` command read it correctly. The
    following is the command to be used:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命令，我们已经将编码的证书数据提取到 `eap6cert.crt`；只有在那时，`keytool` 命令才能正确读取它。以下是要使用的命令：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we need to import this signed certificate back to our keystore; the `keytool`
    command will help us to update the self-signed certificate in the keystore with
    this signed one. Before doing this, we need to import myca into the keystore.
    Since our EAP6 certificate is signed by myca and our keystore currently doesn''t
    contain myca, it will reject any certificate that is signed by it. The following
    command imports myca into the keystore:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将此已签署的证书重新导入到我们的 keystore 中；`keytool` 命令将帮助我们使用此已签署的证书更新 keystore 中的自签名证书。在这样做之前，我们需要将
    myca 导入到 keystore 中。由于我们的 EAP6 证书是由 myca 签署的，并且我们的 keystore 当前不包含 myca，它将拒绝任何由它签署的证书。以下命令将
    myca 导入到 keystore：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Please note the `-trustcacerts` option in the preceding command. We use this
    option to mark `myca` as a trusted signing authority. Now we can import the `eap6cert.crt`
    file so that it is accepted by the keystore; we use the following command to do
    so:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前面命令中的 `-trustcacerts` 选项。我们使用此选项将 `myca` 标记为受信任的签名机构。现在我们可以导入 `eap6cert.crt`
    文件，使其被 keystore 接受；我们使用以下命令来完成此操作：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s have a look at the certificates in the keystore:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 keystore 中的证书：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'From the preceding command output, we can see that there are two entries in
    the keystore. These two entries have different types: `eap6cert` is a `PrivateKeyEntry`,
    which means it is a certificate that can be used for identification, and `myca`
    is a `trustedCertEntry`, which means that it is an authority, and all the other
    certificates signed by it will be trusted.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的命令输出中，我们可以看到 keystore 中有两个条目。这两个条目有不同的类型：`eap6cert` 是 `PrivateKeyEntry`，这意味着它是一张可以用于身份验证的证书，而
    `myca` 是 `trustedCertEntry`，这意味着它是一个权威机构，并且它签署的所有其他证书都将被信任。
- en: We have prepared all the certificates properly. Next, we'll configure httpd
    and EAP6 so that we can use these certificates properly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经正确地准备好了所有证书。接下来，我们将配置 httpd 和 EAP6，以便我们可以正确地使用这些证书。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please check the code provided with this chapter. In the `certs` directory,
    you can see all of the sample certificates that we've generated in this section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请检查本章提供的代码。在 `certs` 目录中，你可以看到我们在此部分生成的所有示例证书。
- en: Configuring httpd
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置httpd
- en: 'To enable secure communication in the management channel, we''ll need to add
    several SSL directives to the virtual host that is relative to the surrounding
    `<VirtualHost>`, as shown in the following configuration:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在管理通道中启用安全通信，我们需要向与周围`<VirtualHost>`相关的虚拟主机添加几个SSL指令，如下面的配置所示：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `httpd.crt` file is used by httpd to identify itself, and will be sent to
    EAP6 for authentication. The `myca.crt` file will be used to authenticate the
    certificate that EAP6 sends to httpd. As we know, the certificate of EAP6 is signed
    by `myca`; so, httpd will trust it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`httpd.crt`文件由httpd用于标识自身，并将发送到EAP6进行认证。`myca.crt`文件将用于认证EAP6发送给httpd的证书。正如我们所知，EAP6的证书由`myca`签名；因此，httpd将信任它。'
- en: That's all that we need to do for the httpd configuration.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们为httpd配置需要做的所有事情。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please check the `mod-cluster-ssl-mcmp.conf` configuration in this chapter's
    code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请检查本章代码中的`mod-cluster-ssl-mcmp.conf`配置。
- en: Now let's configure the EAP6 part.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置EAP6部分。
- en: Configuring EAP6
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置EAP6
- en: 'In EAP6, we need to place our certificate and truststore in the configuration
    file of the `mod_cluster` subsystem of `domain.xml`. The following are its contents:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在EAP6中，我们需要将我们的证书和truststore放置在`domain.xml`的`mod_cluster`子系统的配置文件中。以下是其内容：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since both the server certificate `eap6cert` and the CA certificate `myca` are
    in the keystore `eap6.ks`, we will use them as `certificate-key-file` and `ca-certificate-file`
    respectively. EAP6 will show the `eap6cert` certificate to httpd, and it will
    be trusted by httpd because it's signed by myca.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器证书`eap6cert`和CA证书`myca`都在密钥库`eap6.ks`中，我们将分别使用它们作为`certificate-key-file`和`ca-certificate-file`。EAP6将向httpd展示`eap6cert`证书，并且由于它由myca签名，httpd将信任它。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please check the `domain-ssl-mcmp.xml` file in this chapter's code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请检查本章代码中的`domain-ssl-mcmp.xml`文件。
- en: 'At last, we have a very important step left: we need to copy the `eap6.ks`
    keystore on both the master and slave servers, and place it in the position `/packt/certs/eap6.ks`,
    just as we''ve done in the previous code snippet. Since all the worker nodes are
    using the configuration from `domain.xml`, all the EAP6 servers need this keystore
    file.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还有一个非常重要的步骤：我们需要在主服务器和从服务器上复制`eap6.ks`密钥库，并将其放置在`/packt/certs/eap6.ks`的位置，就像我们在前面的代码片段中所做的那样。由于所有工作节点都使用来自`domain.xml`的配置，所有EAP6服务器都需要这个密钥库文件。
- en: Finally, all the configurations are done. Now let's test the cluster.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有配置都已完成。现在让我们测试集群。
- en: Testing the configuration
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试配置
- en: 'To test our configuration, let''s start httpd and two EAP6 servers. Then we
    can use `cURL` to access our cluster:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的配置，让我们启动httpd和两个EAP6服务器。然后我们可以使用`cURL`访问我们的集群：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding code snippet shows that the load balancer is working. If we use
    Wireshark to monitor the management channel, we can see the SSL protocol in action:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段显示负载均衡器正在工作。如果我们使用Wireshark监控管理通道，我们可以看到SSL协议正在运行：
- en: '![Testing the configuration](img/2432OS_07_25.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![测试配置](img/2432OS_07_25.jpg)'
- en: 'This verifies that the management channel is secured. If we check the data
    transmission in the proxy channel, we can see that it is still using the plaintext
    AJP13 protocol:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这验证了管理通道的安全性。如果我们检查代理通道中的数据传输，我们可以看到它仍在使用明文AJP13协议：
- en: '![Testing the configuration](img/2432OS_07_26.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![测试配置](img/2432OS_07_26.jpg)'
- en: In the following section, we'll see how to enable SSL in the proxy channel.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将看到如何启用代理通道中的SSL。
- en: Enabling SSL in the proxy channel
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在代理通道中启用SSL
- en: In this section, we'll configure mod_cluster to use HTTPS instead of AJP13 for
    the proxy channel.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将配置mod_cluster以使用HTTPS而不是AJP13作为代理通道。
- en: 'Since we have prepared the necessary certificates in the previous sections,
    enabling HTTPS for the proxy channel won''t be a difficult task. First, let''s
    check the configuration in the httpd server. We need to add an `SSLProxyEngine
    On` configuration to the virtual host to enable public access:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在前面的章节中已经准备好了必要的证书，因此为代理通道启用HTTPS不会是一项困难的任务。首先，让我们检查httpd服务器中的配置。我们需要向虚拟主机添加一个`SSLProxyEngine
    On`配置以启用公共访问：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we can see from the preceding configuration, it tells httpd that we need
    to use an SSL connection for the proxy channel, and that's all that we need to
    configure httpd.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从前面的配置中可以看到，它告诉httpd我们需要为代理通道使用SSL连接，这就是我们需要配置httpd的所有内容。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The sample configuration file is `mod-cluster-ssl-full.conf`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 样本配置文件是`mod-cluster-ssl-full.conf`。
- en: 'Now we need to configure the EAP6 server. In `domain.xml`, we need to change
    the mod_cluster connector from `ajp` to `https`, as shown in the following code
    snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要配置 EAP6 服务器。在 `domain.xml` 中，我们需要将 mod_cluster 连接器从 `ajp` 更改为 `https`，如下代码片段所示：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we need to turn off the `ajp` connector, and add the `https` connector,
    as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要关闭 `ajp` 连接器，并添加 `https` 连接器，如下所示：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since we are enforcing the SSL connection, we need to turn off the `ajp` connector
    to prevent the others from using this plaintext communication port.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在强制执行 SSL 连接，我们需要关闭 `ajp` 连接器以防止其他人使用这个明文通信端口。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The sample configuration file is `domain-ssl-full.xml`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 样本配置文件是 `domain-ssl-full.xml`。
- en: 'After restarting the EAP6 server, we can see that the proxy channel starts
    using HTTPS for communication. The Wireshark analysis is shown in the following
    screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在重启 EAP6 服务器后，我们可以看到代理通道开始使用 HTTPS 进行通信。Wireshark 分析的截图如下：
- en: '![Enabling SSL in the proxy channel](img/2432OS_07_28.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![在代理通道中启用 SSL](img/2432OS_07_28.jpg)'
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the different ways to use SSL with mod_cluster.
    We usually just need to secure the transportation layer for public access, and
    use plaintext communication between httpd and EAP6 because we protect the worker
    nodes by placing them in a local network. Please choose a proper solution to meet
    your requirements. In the next chapter, we will learn how to develop and deploy
    a distributed project to a cluster.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了使用 mod_cluster 与 SSL 的不同方法。我们通常只需要为公共访问加密传输层，并在 httpd 和 EAP6 之间使用明文通信，因为我们通过将工作节点放置在本地网络中来保护它们。请选择一个合适的解决方案以满足您的需求。在下一章中，我们将学习如何开发和部署分布式项目到集群中。
