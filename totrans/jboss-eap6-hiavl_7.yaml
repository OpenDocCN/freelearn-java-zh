- en: Chapter 7. Configuring mod_cluster with SSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to use SSL with JK (mod_jk). In this
    chapter, we will check the design of mod_cluster first, and discuss how it can
    be used with SSL. Then we will learn how to configure the httpd and EAP6 servers
    so that they can use SSL.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's check the design of mod_cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The design of mod_cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the last chapter, JK uses the AJP13 protocol between the
    load balancer and worker nodes. In comparison to JK, mod_cluster allows us to
    secure its communication channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'In design, mod_cluster uses three channels for communication: the advertising
    channel, the management channel, and the proxy channel. mod_cluster allows us
    to secure the communication in the management and proxy channels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the deployment diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The design of mod_cluster](img/2432OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see from the preceding diagram, SSL communications can be enabled
    in the following three places:'
  prefs: []
  type: TYPE_NORMAL
- en: Communication between users and httpd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mod_cluster management channel communication between httpd and EAP6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mod_cluster proxy channel communication between httpd and EAP6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We learned how to enable SSL communication between users and httpd in the previous
    chapter. We need to generate a self-signed certificate and configure mod_ssl in
    httpd to use the certificate. The following is the configuration that we used
    in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding configuration is actually for mod_ssl; so, it remains unchanged
    when we switch our load balancer component from JK to mod_cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please check the `mod-cluster-ssl.conf` file in this chapter's code.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the pure mod_ssl support of httpd to enable SSL communication
    between users and httpd, mod_cluster provides additional functions to secure data
    transmission between the httpd and EAP6 servers. In the following sections, we
    will have a look at how to enable secure communication for the other two places
    that are mentioned. First, we'll learn how to enable SSL in the mod_cluster management
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling SSL for the mod_cluster management channel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to secure the MCMP channel. This means that
    the MCMP messages will be transferred over SSL.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the mod_cluster documentation, we named the protocol MCMP, which stands for
    **Mod-Cluster Management Protocol**.
  prefs: []
  type: TYPE_NORMAL
- en: In design, mod_cluster uses SSL mutual authentication to secure the MCMP channel.
    This means that we must create certificates for both the servers. EAP6 needs to
    trust the certificate provided by httpd; meanwhile, httpd must trust the certificate
    from the EAP6 server. So, we need two certificates instead of just one.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to SSL mutual authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we created a self-signed certificate for httpd to enable
    HTTPS communication with users. When users use the web browser to access our website,
    httpd will provide its certificate to the web browser. If a user chooses to trust
    the certificate, the web browser will establish a secure connection with our server.
    This is called one-way authentication. It means that the user will verify the
    identity of the website, but the website won't verify the identity of the user.
  prefs: []
  type: TYPE_NORMAL
- en: Since our certificate is self-signed, the web browser will pop up a warning
    to tell the user that it cannot verify the identity of this certificate, and the
    user will need to decide whether to trust it or not. But if our certificate is
    signed by an authority, the web browser will trust our certificate without any
    pop-up warning messages. This is because every web browser contains a default
    list of authorities. The certificates signed by these authorities will be trusted
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I can see the following list of default CAs in my Firefox browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An introduction to SSL mutual authentication](img/2432OS_07_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Firefox will trust the certificates signed by these authorities only. JDK also
    contains one such list that is usually the `$JAVA_HOME/jre/lib/security/cacerts`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s talk about encrypting the communication between httpd and EAP6\.
    First, we will learn about one-way authentication. This scenario is shown in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An introduction to SSL mutual authentication](img/2432OS_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since EAP6 is running in JVM, it trusts a default list of CAs. Our self-signed
    certificate is obviously not signed by these authorities; so, by default, EAP6
    won't trust it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, we can create an authority ourselves, and sign the certificate
    using this authority. Then we can place the authority in EAP6 to override the
    default trust list so that EAP6 trusts the certificate signed by it. This scenario
    is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An introduction to SSL mutual authentication](img/2432OS_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With the previous method, we can establish a one-way authentication from httpd
    to EAP6\. If we want to establish a mutual SSL authentication, we need to additionally
    create a certificate for EAP6, and sign it with myca. Then, we need to configure
    httpd to put myca in its trust list so that it trusts the EAP6 certificate. The
    following diagram shows this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An introduction to SSL mutual authentication](img/2432OS_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from this diagram, **httpd** will show its certificate to **EAP6**,
    and **EAP6** will show its certificate to **httpd.** Only then will they trust
    each other because their certificates are signed by myca as myca is in their trust
    list. mod_cluster enforces this mutual SSL authentication. In the following sections,
    we will learn how to configure httpd and EAP6 properly.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring SSL mutual authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have learned the concepts of SSL mutual authentication, let''s now configure
    our environment to enable it. We need to create the following three certificates:'
  prefs: []
  type: TYPE_NORMAL
- en: One self-signed certificate as the authority. Let's name it `myca.crt`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One certificate for httpd, signed by myca. Let's name it `httpd.crt`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One certificate for EAP6, signed by myca. Let's name it `eap6.crt`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's create them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CA certificate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we will create a CA certificate. The term **CA** stands for **Certificate
    Authority**; it's actually a self-signed certificate that will be used to sign
    the other certificates. If one application puts this CA into its trust list, the
    certificates that are signed by it will be trusted.
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a self-signed certificate named `myca` and use it as our CA. Before
    we create it, please prepare a directory called `certs` and place it appropriately.
    Since we'll create three certificates along with their key files, it's better
    to put them together. For me, I'll put it in `/packt/certs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please use the following command to create a self-signed certificate together
    with its key file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding command, I have generated a key pair with its self-signed
    certificate, and the `CN` of this certificate is `myca`. We can see this by checking
    the content of the certificate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `Owner` and `Issuer` are the same. Now, let's create a certificate
    for httpd, and sign it with myca.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a certificate for httpd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we have the authority myca now, let''s create a certificate for httpd and
    then sign it with myca. We first need to create a key pair for httpd with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the preceding command, the key file is named `httpd.key`.
    Next, we''ll create a certificate related to the key pair; the following command
    does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the `CN` value of our certificate is `httpd`. As a result of
    running the previous command, we get the `http.csr` file that waits to be signed.
    Now, we need to use the tools provided by OpenSSL to sign this certificate with
    myca, but before that we need to set up OpenSSL properly.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up OpenSSL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'OpenSSL has its own workflow for signing the certificate. Please run the following
    command to set up the working environment for OpenSSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Our signed certificate will be placed in the `newcerts` directory and named
    `01.pem`. Please make sure that you have run the previous command from the `certs`
    directory that contains the myca and httpd certificates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to loosen the signing policy in OpenSSL. First, we need to
    locate the configuration file that OpenSSL is using. Please run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the location of the configuration file used by OpenSSL from the
    previous command. Let''s open `openssl.cnf` and find the `policy_match` section.
    Other than `commonName`, we need to change all the items in this section to `optional`.
    The following screenshot lists the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up OpenSSL](img/2432OS_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition, we need to change the default directory that OpenSSL will use
    to sign the certificates; this is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are changing the OpenSSL defaults merely for testing purposes. In practice,
    this will loosen the security of the certificates.
  prefs: []
  type: TYPE_NORMAL
- en: We should always use the default positions for signing certificates and carefully
    manage their permissions in production environment.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, a real CA faculty will usually require you to provide a certificate
    with the valid information that it requires. For example, a requirement could
    be that your certificate's CN must match your DNS hostname, and your country's
    name must match your host location.
  prefs: []
  type: TYPE_NORMAL
- en: Signing the httpd.csr file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since we have set OpenSSL properly, we can now start signing our httpd certificate.
    Please make sure that you are in the `certs` directory, and that it includes a
    `demoCA` directory with the necessary file contents. Please run the following
    command to sign the httpd certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have signed `httpd.csr`; this signed certificate is located in `demoCA/newcerts`,
    and is named `01.pem`. Let''s check the content of this certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the `Subject` value is `httpd` and the `Issuer` value is `myca`.
    So we''ve used our own CA to sign our certificate. Let''s copy this certificate
    into the `certs` directory and rename it to `httpd.crt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: That's all for the httpd certificate. Now, let's work on the EAP6 server, create
    a certificate for it, and also sign this with myca.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a certificate for EAP6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The processes in the EAP6 server are different; first, we need to use the `keytool`
    command to create a keystore with a self-signed certificate. Then, we will export
    the certificate from the keystore, and sign it with myca. Later, we'll import
    `myca.crt` into the keystore to act as a trust authority. So, all the certificates
    signed by myca will be trusted and accepted by JVM. After that, we'll import the
    signed EAP6 certificate back to the keystore.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a keystore. The keystore file `eap6.ks` will have the
    default key pair and a self-signed certificate that is related to the key pair.
    The following is the command for creating the keystore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding command, we can see that the keystore is named `eap6.ks`,
    and the alias of the certificate is `eap6cert`. The `cn` field of the certificate
    has a value of `eap6`, and this certificate is self-signed by default. We can
    check this with the `keytool` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s export `eap6cert` for the signing request using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding command, we get the **Certificate Signing Request** (**CSR**)
    file, `eap6cert.csr`. We need to sign this certificate with myca. The process
    is exactly the same as it was for the signing of the `httpd.csr` file. We need
    to place `eap6cert.csr` in the `certs` directory, and we need to reuse the `demoCA`
    directory that is created for signing the httpd certificate. Please note that
    we don''t need to reset the serial number in `./demoCA/serial`, and don''t delete
    the httpd certificate `01.pem` from the `newcerts` directory. OpenSSL will automatically
    increase the serial number, and the signed EAP6 certificate will be named `02.pem`.
    The following code snippet denotes the signing process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With this process, the EAP6 certificate is signed and stored in `demoCA/serial/02.pem`.
    Now, let''s copy `02.pem` to `eap6raw.crt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the contents of this certificate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'From the `Issuer` and `Subject` fields, we can see that the certificate is
    signed. In addition, we can see the encoded certificate data at the bottom of
    this file. Let''s use the following command to extract the encoded certificate
    text from `eap6raw.crt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The Java security library can only read the certificate in the previously encoded
    format, and doesn''t allow any extra text in the certificate file. So, we need
    to extract the encoded certificate data to another file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding command, we have extracted the encoded certificate data
    to `eap6cert.crt`; only then can the `keytool` command read it correctly. The
    following is the command to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to import this signed certificate back to our keystore; the `keytool`
    command will help us to update the self-signed certificate in the keystore with
    this signed one. Before doing this, we need to import myca into the keystore.
    Since our EAP6 certificate is signed by myca and our keystore currently doesn''t
    contain myca, it will reject any certificate that is signed by it. The following
    command imports myca into the keystore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note the `-trustcacerts` option in the preceding command. We use this
    option to mark `myca` as a trusted signing authority. Now we can import the `eap6cert.crt`
    file so that it is accepted by the keystore; we use the following command to do
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at the certificates in the keystore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding command output, we can see that there are two entries in
    the keystore. These two entries have different types: `eap6cert` is a `PrivateKeyEntry`,
    which means it is a certificate that can be used for identification, and `myca`
    is a `trustedCertEntry`, which means that it is an authority, and all the other
    certificates signed by it will be trusted.'
  prefs: []
  type: TYPE_NORMAL
- en: We have prepared all the certificates properly. Next, we'll configure httpd
    and EAP6 so that we can use these certificates properly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please check the code provided with this chapter. In the `certs` directory,
    you can see all of the sample certificates that we've generated in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring httpd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable secure communication in the management channel, we''ll need to add
    several SSL directives to the virtual host that is relative to the surrounding
    `<VirtualHost>`, as shown in the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `httpd.crt` file is used by httpd to identify itself, and will be sent to
    EAP6 for authentication. The `myca.crt` file will be used to authenticate the
    certificate that EAP6 sends to httpd. As we know, the certificate of EAP6 is signed
    by `myca`; so, httpd will trust it.
  prefs: []
  type: TYPE_NORMAL
- en: That's all that we need to do for the httpd configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please check the `mod-cluster-ssl-mcmp.conf` configuration in this chapter's
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's configure the EAP6 part.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring EAP6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In EAP6, we need to place our certificate and truststore in the configuration
    file of the `mod_cluster` subsystem of `domain.xml`. The following are its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Since both the server certificate `eap6cert` and the CA certificate `myca` are
    in the keystore `eap6.ks`, we will use them as `certificate-key-file` and `ca-certificate-file`
    respectively. EAP6 will show the `eap6cert` certificate to httpd, and it will
    be trusted by httpd because it's signed by myca.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please check the `domain-ssl-mcmp.xml` file in this chapter's code.
  prefs: []
  type: TYPE_NORMAL
- en: 'At last, we have a very important step left: we need to copy the `eap6.ks`
    keystore on both the master and slave servers, and place it in the position `/packt/certs/eap6.ks`,
    just as we''ve done in the previous code snippet. Since all the worker nodes are
    using the configuration from `domain.xml`, all the EAP6 servers need this keystore
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, all the configurations are done. Now let's test the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test our configuration, let''s start httpd and two EAP6 servers. Then we
    can use `cURL` to access our cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet shows that the load balancer is working. If we use
    Wireshark to monitor the management channel, we can see the SSL protocol in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the configuration](img/2432OS_07_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This verifies that the management channel is secured. If we check the data
    transmission in the proxy channel, we can see that it is still using the plaintext
    AJP13 protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the configuration](img/2432OS_07_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the following section, we'll see how to enable SSL in the proxy channel.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling SSL in the proxy channel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll configure mod_cluster to use HTTPS instead of AJP13 for
    the proxy channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have prepared the necessary certificates in the previous sections,
    enabling HTTPS for the proxy channel won''t be a difficult task. First, let''s
    check the configuration in the httpd server. We need to add an `SSLProxyEngine
    On` configuration to the virtual host to enable public access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the preceding configuration, it tells httpd that we need
    to use an SSL connection for the proxy channel, and that's all that we need to
    configure httpd.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sample configuration file is `mod-cluster-ssl-full.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to configure the EAP6 server. In `domain.xml`, we need to change
    the mod_cluster connector from `ajp` to `https`, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to turn off the `ajp` connector, and add the `https` connector,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Since we are enforcing the SSL connection, we need to turn off the `ajp` connector
    to prevent the others from using this plaintext communication port.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sample configuration file is `domain-ssl-full.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After restarting the EAP6 server, we can see that the proxy channel starts
    using HTTPS for communication. The Wireshark analysis is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling SSL in the proxy channel](img/2432OS_07_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the different ways to use SSL with mod_cluster.
    We usually just need to secure the transportation layer for public access, and
    use plaintext communication between httpd and EAP6 because we protect the worker
    nodes by placing them in a local network. Please choose a proper solution to meet
    your requirements. In the next chapter, we will learn how to develop and deploy
    a distributed project to a cluster.
  prefs: []
  type: TYPE_NORMAL
