- en: Chapter 1. Let's Dive Right in…
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。让我们直接进入…
- en: '|   | *"It does not matter how slowly you go as long as you do not stop."*
    |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|    | *"无论你走得有多慢，只要你不停止。" |    |'
- en: '|   | --*Confucius* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|    | --*孔子* |'
- en: 'In this chapter, you will build a simple game where the player controls a character
    using the mouse to try to avoid oncoming enemies. As the game progresses, the
    enemies become harder to avoid. This game contains many of the basic elements
    needed to create interactive Greenfoot applications. Specifically, in this chapter,
    you will learn how to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将构建一个简单的游戏，玩家通过鼠标控制角色，尝试躲避迎面而来的敌人。随着游戏的进行，敌人变得越来越难以躲避。这个游戏包含了创建交互式Greenfoot应用程序所需的基本元素。具体来说，在本章中，你将学习如何：
- en: Create introduction and game-over screens
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建介绍和游戏结束屏幕
- en: Display a user score
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示用户得分
- en: Use the mouse to control the movement of an actor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用鼠标控制角色的移动
- en: Play background music
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放背景音乐
- en: Dynamically spawn enemies and remove them when appropriate
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态生成敌人并在适当的时候移除它们
- en: Create game levels
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建游戏关卡
- en: Throughout this chapter, we'll learn basic programming concepts and gain familiarity
    with the Greenfoot development environment. As you proceed, think about the concepts
    presented and how you would use them in your own projects. If you are new to Java,
    or it's been a while since you've programmed in Java, be sure to take the time
    to look up things that may be confusing to you. Java is a well-established programming
    language, and there are endless online resources you can consult. Similarly, this
    book assumes a minimal understanding of Greenfoot. Be sure to look at the simple
    tutorials and documentation at [www.greenfoot.org](http://www.greenfoot.org) when
    needed. *Experiment with the code and try new things—you'll be glad you did*.
    In other words, follow the advice of Confucius, quoted in the first line of this
    chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习基本的编程概念，并熟悉Greenfoot开发环境。随着你的学习，思考所提出的概念以及你如何在你的项目中使用它们。如果你是Java的新手，或者有一段时间没有编写Java程序了，请确保花时间查阅可能让你感到困惑的内容。Java是一种成熟的编程语言，有无数的在线资源可以查阅。同样，本书假设对Greenfoot有最低限度的了解。在需要时，请务必查看[www.greenfoot.org](http://www.greenfoot.org)上的简单教程和文档。*尝试代码并尝试新事物——你会很高兴你这么做的*。换句话说，遵循本章第一行引用的孔子的建议。
- en: Many of the chapters in this book are independent; however, most are dependent
    on this chapter. This chapter provides the framework to create Greenfoot applications
    that we will continue to use, and refer to, in later chapters.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的许多章节都是独立的；然而，大多数章节都依赖于本章。本章提供了创建我们将继续使用并在后续章节中参考的Greenfoot应用程序的框架。
- en: The Avoider Game tutorial
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Avoider游戏教程
- en: This tutorial is heavily based on *AS3 Avoider Game Tutorial* by Michael James
    Williams ([http://gamedev.michaeljameswilliams.com/as3-avoider-game-tutorial-base/](http://gamedev.michaeljameswilliams.com/as3-avoider-game-tutorial-base/)).
    In that tutorial, you build a game that creates smiley-faced enemies that rain
    down from the top of the screen. The goal for the player is to avoid these enemies.
    The longer you avoid them, the higher your score. We will build the same game
    in Greenfoot, instead of Flash and ActionScript. As with Michael James Williams'
    tutorial, we will start small and slowly layer on functionality. We will pause
    frequently to consider best practices and good programming practice. Enjoy these
    learning opportunities!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程主要基于Michael James Williams的*AS3 Avoider游戏教程*。在那个教程中，你将构建一个游戏，游戏会从屏幕顶部生成笑脸敌人。玩家的目标是避开这些敌人。你避开它们的时间越长，你的得分就越高。我们将使用Greenfoot构建相同的游戏，而不是Flash和ActionScript。与Michael
    James Williams的教程一样，我们将从小处着手，逐渐添加功能。我们将经常暂停以考虑最佳实践和良好的编程实践。享受这些学习机会！
- en: We will first build the basic components of the Avoider game, including the
    initial scenario, the game environment, the enemies, and the hero. Then, we will
    layer on additional functionality, such as scoring, introduction and game-over
    screens, and the notion of levels.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先构建Avoider游戏的基本组件，包括初始场景、游戏环境、敌人和英雄。然后，我们将添加额外的功能，例如得分、介绍和游戏结束屏幕以及关卡的概念。
- en: As mentioned in the preface, we'll assume you have downloaded Greenfoot and
    have it installed. If you still haven't, do so now. Go to [www.greenfoot.org](http://www.greenfoot.org)
    for easy-to-follow instructions on downloading and installing Greenfoot. While
    you are there, make sure you are minimally familiar with all the tutorials provided
    on [http://www.greenfoot.org/doc](http://www.greenfoot.org/doc).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前言所述，我们假设你已经下载了Greenfoot并已安装。如果你还没有，请现在就做。前往[www.greenfoot.org](http://www.greenfoot.org)获取下载和安装Greenfoot的简单说明。当你在那里时，确保你至少熟悉[http://www.greenfoot.org/doc](http://www.greenfoot.org/doc)上提供的所有教程。
- en: Basic game elements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本游戏元素
- en: All games have an environment in which the game takes place and objects interact.
    In Greenfoot, the environment is represented by the `World` class, and objects
    that interact in the environment are represented by the `Actor` class. In this
    section of the chapter, we will create a world, add enemies to the world, and
    add a hero that will be controlled by the player.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有游戏都有一个游戏发生的环境，其中对象进行交互。在Greenfoot中，环境由`World`类表示，而在环境中交互的对象由`Actor`类表示。在本章的这一部分，我们将创建一个世界，向世界添加敌人，并添加一个将由玩家控制的英雄。
- en: Creating a scenario
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建场景
- en: Start Greenfoot and create a new scenario by clicking on **Scenario** in Greenfoot's
    Menu bar and then clicking on **New…**. You will see the window shown in *Figure
    1*. Type `AvoiderGame` as the name of the file, and then hit the **Create** button.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Greenfoot，通过点击Greenfoot菜单栏中的**场景**然后点击**新建…**来创建一个新的场景。你会看到*图1*中显示的窗口。将文件名输入为`AvoiderGame`，然后点击**创建**按钮。
- en: '![Creating a scenario](img/image00238.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![创建场景](img/image00238.jpeg)'
- en: 'Figure 1: Here''s Greenfoot''s New Scenario window'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：这是Greenfoot的新场景窗口
- en: Creating our world
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建我们的世界
- en: Next, we need to create a world for our game. We do this by right-clicking (or
    ctrl-clicking on Mac) on the **World** class in the scenario window (see *Figure
    2*) and choosing **New subclass...** in the pop-up menu that appears.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为我们的游戏创建一个世界。我们通过在场景窗口中右键单击（或在Mac上按ctrl键单击）**世界**类，并在出现的弹出菜单中选择**新建子类...**来完成此操作（参见*图2*）。
- en: '![Creating our world](img/image00239.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的世界](img/image00239.jpeg)'
- en: 'Figure 2: This is about right-clicking on the World class in order to subclass
    it'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：这是关于在**世界类**上右键单击以创建子类
- en: In the **New class** pop-up window, name the class `AvoiderWorld`, select the
    **backgrounds** image category, and then select the `space1.jpg` library image
    as the new class image. Once this is done, the pop-up window should resemble *Figure
    3*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在**新建类**弹出窗口中，将类命名为`AvoiderWorld`，选择**背景**图像类别，然后选择`space1.jpg`库图像作为新类的图像。完成这些操作后，弹出窗口应类似于*图3*。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Once you associate an image with a new `World` class or `Actor` class, that
    image will be copied to the `images` directory in your Greenfoot project. We will
    count on this in later chapters.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将一个图像与新的`World`类或`Actor`类关联，该图像将被复制到Greenfoot项目的`images`目录中。我们将在后面的章节中依赖这一点。
- en: '![Creating our world](img/image00240.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的世界](img/image00240.jpeg)'
- en: 'Figure 3: This shows the New class pop-up window'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：这显示了新建类弹出窗口
- en: Hit the **Ok** button in the **New class** pop-up window, and then, in the main
    scenario window, hit the **Compile** button. You should now have a scenario that
    looks like that shown in *Figure 4*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在**新建类**弹出窗口中点击**确定**按钮，然后在主场景窗口中点击**编译**按钮。现在你应该有一个看起来像*图4*中所示的场景。
- en: '![Creating our world](img/image00241.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的世界](img/image00241.jpeg)'
- en: 'Figure 4: This shows our AvoiderGame scenario after compiling the AvoiderWorld
    class'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：这显示了编译了AvoiderWorld类的AvoiderGame场景
- en: We now have our own world, named `AvoiderWorld`, which we will soon populate
    with actors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了自己的世界，名为`AvoiderWorld`，我们将很快在其中添加演员。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Later in this chapter, we will add two subclasses of `World` to our game—one
    for our introduction screen and one for our game-over screen. Those instructions
    will be abbreviated. Be sure to refer back to this section if you need detailed
    instructions on subclassing the `World` class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将向我们的游戏添加两个`World`类的子类——一个用于我们的介绍屏幕，另一个用于我们的游戏结束屏幕。那些说明将被简略。如果你需要关于子类化`World`类的详细说明，请务必参考本节。
- en: Creating our hero
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建我们的英雄
- en: Let's create the character our players will control when they play our game.
    Greenfoot makes this really easy. We will just follow the same steps we used to
    create the `World` class earlier. Start by right-clicking on the `Actor` class
    in the scenario window (see *Figure 5*) and choose the **New subclass...** menu
    item.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建玩家在玩游戏时将控制的角色。Greenfoot使这变得非常简单。我们将遵循之前创建`World`类时使用的相同步骤。首先，在场景窗口中右键单击`Actor`类（见*图5*），然后选择**新建子类...**菜单项。
- en: '![Creating our hero](img/image00242.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的英雄](img/image00242.jpeg)'
- en: 'Figure 5: This shows right-clicking on the Actor class in order to subclass
    it'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：此图显示了在Actor类上右键单击以继承它
- en: In the **New class** pop-up window, name the class `Avatar` and select `symbols->skull.png`
    as the new class image. In the main scenario window, hit the **Compile** button.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在**新类**弹出窗口中，将类命名为`Avatar`，并选择`symbols->skull.png`作为新的类图像。在主场景窗口中，点击**编译**按钮。
- en: Now, to create an enemy, you perform the same steps you just did for the hero,
    except choose `symbols->Smiley1.png` as the image and `Enemy` as the class name.
    Again, hit the **Compile** button when this is done.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要创建一个敌人，您只需执行与英雄相同的步骤，只是选择`symbols->Smiley1.png`作为图像，并将类名选择为`Enemy`。同样，完成此操作后，再次点击**编译**按钮。
- en: You should now have a scenario that looks like the one shown in *Figure 6*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该有一个看起来像*图6*所示的场景。
- en: '![Creating our hero](img/image00243.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的英雄](img/image00243.jpeg)'
- en: 'Figure 6: This shows the Avoider Game scenario after creating the world and
    adding two actors'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：此图显示了创建世界并添加两个演员后的Avoider Game场景
- en: What have we just done?
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们刚才做了什么？
- en: Greenfoot views a scenario as `World` that contains `Actor`. The main responsibilities
    of `World` is to add and remove `each Actor` from the screen and to periodically
    call the `act()` method of each `Actor`. It is the responsibility of each `Actor`
    to implement their `act()` method to describe their actions. Greenfoot provides
    you with the code that implements general `World` and `Actor` behavior. (You right-clicked
    on those implementations previously.) As a game programmer, you must code specific
    behaviors for `World` and `Actor`. You do this by subclassing the provided `World`
    and `Actor` classes to create new classes and writing code in them. You have already
    done the subclassing, and now it is time to add the code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Greenfoot将场景视为包含`Actor`的`World`。`World`的主要职责是从屏幕上添加和删除`每个Actor`，并定期调用每个`Actor`的`act()`方法。每个`Actor`的职责是实现它们的`act()`方法来描述它们的行为。Greenfoot为您提供了实现通用`World`和`Actor`行为的代码。（您之前已经右键点击过这些实现。）作为一名游戏程序员，您必须为`World`和`Actor`编写特定的行为代码。您通过继承提供的`World`和`Actor`类来创建新类，并在其中编写代码。您已经完成了继承，现在是时候添加代码了。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Look at [http://www.greenfoot.org/files/javadoc/](http://www.greenfoot.org/files/javadoc/)
    to learn more about the `World` and `Actor` classes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[http://www.greenfoot.org/files/javadoc/](http://www.greenfoot.org/files/javadoc/)以了解更多关于`World`和`Actor`类的信息。
- en: Oracle provides an excellent overview of object-oriented programming concepts
    at [http://docs.oracle.com/javase/tutorial/java/concepts/](http://docs.oracle.com/javase/tutorial/java/concepts/).
    If you are serious about learning Java and writing good Greenfoot scenarios, you
    should read that material.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle在[http://docs.oracle.com/javase/tutorial/java/concepts/](http://docs.oracle.com/javase/tutorial/java/concepts/)提供了关于面向对象编程概念的优秀概述。如果您认真学习Java并编写好的Greenfoot场景，您应该阅读这些材料。
- en: Adding our hero
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加我们的英雄
- en: Last, we need to add our hero to the game. To do this, right-click on the `Avatar`
    class, select `new Avatar()` from the pop-up menu, drag the picture of the skull
    that appears collocated with your mouse pointer to the center of the screen and
    then click the left mouse button. Now, right-click anywhere on the black space
    background (do not right-click on the skull) and choose **Save the world** in
    the pop-up menu that appears.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将我们的英雄添加到游戏中。为此，右键单击`Avatar`类，从弹出菜单中选择`new Avatar()`，将鼠标指针旁边出现的头骨图片拖到屏幕中央，然后点击鼠标左键。现在，在任何黑色背景上右键单击（不要在头骨上右键单击）并选择弹出菜单中的**保存世界**。
- en: Doing this will permanently add our hero to the game. If you hit the **Reset**
    button on Greenfoot's scenario window, you should still see the skull you placed
    in the middle of the screen.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作将永久将我们的英雄添加到游戏中。如果您在Greenfoot的场景窗口中点击**重置**按钮，您应该仍然看到您放置在屏幕中间的头骨。
- en: Using the mouse as a game controller
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用鼠标作为游戏控制器
- en: Let's add some code to the `Avatar` class that will allow us to control its
    movement using the mouse. Double-click on `Avatar` to pull up the code editor
    (You can also right-click on the class and select **Open editor**).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Avatar`类中添加一些代码，这样我们就可以使用鼠标来控制它的移动。双击`Avatar`以打开代码编辑器（你也可以右键单击类并选择**打开编辑器**）。
- en: You will see a code-editing window appear that looks as shown in *Figure 7*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个代码编辑窗口出现，其外观如图7所示。
- en: '![Using the mouse as a game controller](img/image00244.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![使用鼠标作为游戏控制器](img/image00244.jpeg)'
- en: 'Figure 7: This is the code for our Avatar class'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：这是我们Avatar类的代码
- en: You can see the `act()` method we discussed earlier. Because there is no code
    in it, `Avatar` will not move or display any other behavior when we run our scenario.
    What we would like, is to have `Avatar` follow the mouse. Wouldn't it be nice
    if there was a `followMouse()` method we could use? *Let's pretend there is!*
    Inside the `act()` method, type `followMouse();`. Your `act()` method should look
    like *Figure 8*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们之前讨论过的`act()`方法。因为里面没有代码，所以当我们运行场景时，`Avatar`不会移动或显示任何其他行为。我们希望的是让`Avatar`跟随鼠标。如果有一个我们可以使用的`followMouse()`方法会怎么样？*让我们假装有！*
    在`act()`方法中，输入`followMouse();`。你的`act()`方法应该看起来像图8。
- en: '![Using the mouse as a game controller](img/image00245.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![使用鼠标作为游戏控制器](img/image00245.jpeg)'
- en: 'Figure 8: This shows the act() method with the followMouse() function added'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：显示了添加了followMouse()函数的act()方法
- en: Just for fun, let's compile this and see what happens. What do you think will
    happen? Click the **Compile** button to find out. Did you see something like what
    is shown in *Figure 9*?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩，让我们编译一下看看会发生什么。你认为会发生什么？点击**编译**按钮来找出答案。你看到了像图9中显示的那样的事情吗？
- en: '![Using the mouse as a game controller](img/image00246.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![使用鼠标作为游戏控制器](img/image00246.jpeg)'
- en: 'Figure 9: This is about viewing a compilation error in Greenfoot'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：这是关于在Greenfoot中查看编译错误
- en: If you look at the bottom of the window in *Figure 9*, you'll see that Greenfoot
    has provided us with a useful error message and has even highlighted the code
    that has the problem. As we know, we were pretending that the method `followMouse()`
    existed. Of course, it does not. We will, however, write it soon. Throughout the
    course of this manual (and during any Java coding), you are going to make errors.
    Sometimes, you'll make a "typo" and at other times, you'll use a symbol that doesn't
    exist (just as we did earlier). There are other common errors you will make as
    well.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看图9的底部，你会看到Greenfoot为我们提供了一个有用的错误信息，甚至突出显示了有问题的代码。正如我们所知，我们假装方法`followMouse()`存在。当然，它不存在。然而，我们很快就会编写它。在整个手册的编写过程中（以及任何Java编码过程中），你都会犯错误。有时，你会犯一个“打字错误”，有时，你会使用一个不存在的符号（就像我们之前做的那样）。你还会犯其他一些常见的错误。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Help! I just made a programming error!**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**帮助！我刚刚犯了一个编程错误！**'
- en: 'Don''t panic! There are a number of things you can do to remedy the situation.
    I will list some here. First and foremost, the process you use to code can greatly
    aid you in debugging code (finding errors). The process you should follow is called
    *Incremental Development*. Simply follow these steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 不要慌张！你可以做很多事情来解决这个问题。我会在这里列出一些。首先，你使用的编码过程可以大大帮助你调试代码（查找错误）。你应该遵循的过程被称为**增量开发**。只需遵循以下步骤：
- en: Code a couple of lines of code. *(Really!! Don't code any more!)*
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写几行代码。（真的！！不要编写更多代码！）
- en: Save and compile.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存并编译。
- en: Run and test your code. *(Really!! Try it out!)*
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行并测试你的代码。（真的！！试试看！）
- en: Repeat.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复。
- en: 'Now, if you get an error, *it has to be due to the last 2-5 lines of code*
    you just wrote. You know exactly where to look. Compare this to writing 30 lines
    of code and then testing them out. You will have compounding bugs that are hard
    to find. Here are some other debugging tips:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你遇到错误，*它一定是由于你刚刚编写的最后2-5行代码造成的*。你知道确切的位置在哪里。将此与编写30行代码然后测试它们进行比较。你将会有累积的难以找到的错误。以下是一些其他调试技巧：
- en: Very carefully read the error message you get. While they can be cryptic, they
    really do point you to the location of the bug (sometimes even giving line numbers).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常仔细地阅读你得到的错误信息。虽然它们可能很晦涩，但它们确实会指向错误的位置（有时甚至给出行号）。
- en: Sometimes, you get multiple, long error messages. Don't worry. Just go to the
    top and read and deal with only the first one. Often, by fixing the first one,
    many others will be taken care of too.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，你会得到多个、长篇的错误信息。不用担心。只需从顶部开始阅读并处理第一个。通常，通过修复第一个，许多其他问题也会得到解决。
- en: If you just can't find it, have someone else read your code. It's amazing how
    fast someone else can spot your error.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print some information out. You can use `System.out.println()` to print out
    variables and check that the code you are looking at is actually running.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use a debugger. This is a very useful tool, but beyond the scope
    of this book. Learn what a debugger is and use it. *Greenfoot has a nice, built-in
    debugger you can use.*
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the extremely rare case that there is an error in the Greenfoot program,
    report it by following the instructions found at [http://www.greenfoot.org/support](http://www.greenfoot.org/support).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Creating the followMouse function
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Ok, let''s get back to our hero. We last left our hero (the `Avatar` class)
    with an error, because there was actually no `followMouse()` method. Let''s fix
    that. Add the method shown in the following code after the `act()` method in the
    `Avatar` class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We now have an implementation of `followMouse()`. Save the file, compile the
    Greenfoot scenario, and try the code out. The picture of the skull should follow
    your mouse. If something went wrong, look closely at the debugging window (shown
    in Figure 9) to see the clues Java is giving you about your error. Did you mistype
    something? Verify that the code in your `Avatar` class looks exactly like the
    code in Figure 10\. *Follow the debugging tips provided earlier*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the followMouse function](img/image00247.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10: This shows the Avatar class with completed followMouse() method'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Hey, wait! How did I come up with the code for the `followMouse()` method? Was
    I born with that information? No, I actually just looked over the Greenfoot documentation
    ([http://www.greenfoot.org/files/javadoc/](http://www.greenfoot.org/files/javadoc/))
    and saw there was a class named `MouseInfo`. I clicked on that and read about
    all of its methods.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go read the Greenfoot documentation now. It's actually pretty short. There are
    only seven classes and each only has around 20, or fewer, methods.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down the code
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's break down this code. First, we get access to an object that represents
    mouse data via `Greenfoot.getMouseInfo()`. We then use that object to get the
    location of the mouse, via `getX()` and `getY()`, and then set the *x* and *y*
    locations of our hero using `setLocation(x,y)`. How did I know to use `setLocation()`?
    Again, it is in the Greenfoot documentation for the `Actor` class. It is a method
    that Greenfoot provides for all actors. Last, we had to include the `if(mi !=
    null)` part because if you accidentally move the mouse outside the Greenfoot window,
    there will be no mouse information, so trying to access it will cause an error
    (check out the comment in the code in *Figure 10*, *line 22*).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Since the `followMouse()` method is called in the `act()` method, our hero will
    continually be moved to the location of the mouse.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When typing a method in Greenfoot, you can hit *Ctrl* + space bar and Greenfoot
    will display a list of potential methods you may have been trying to write. Select
    a method from the list and Greenfoot will autocomplete the method for you, including
    space holders for method parameters.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Greenfoot中输入方法时，你可以按*Ctrl* + 空格键，Greenfoot将显示一个可能尝试编写的潜在方法的列表。从列表中选择一个方法，Greenfoot将为你自动完成该方法，包括方法参数的占位符。
- en: Adding enemies
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加敌人
- en: We're going to add enemies to our game in two steps. First, we need to write
    the code for the `Enemy` class, and then we will add code to our world, `AvoiderWorld`,
    to create a never-ending army of enemies. Both steps are surprisingly simple.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两步向我们的游戏添加敌人。首先，我们需要编写`Enemy`类的代码，然后我们将向我们的世界`AvoiderWorld`添加代码来创建一支永无止境的敌人军队。这两个步骤都非常简单。
- en: Enemy code
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 敌人代码
- en: 'Double-click on the `Enemy` class and change its `act()` method to look like
    the following code snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 双击`Enemy`类并更改其`act()`方法，使其看起来像以下代码片段：
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Remember using `setLocation()` earlier in the `Avatar` class? We use it again
    here to move an enemy down one pixel every time the `act()` method is called.
    In Greenfoot, the upper-left corner of the screen is the coordinate (0,0). The
    *x* coordinate increases as you move to the right and the *y* coordinate increases
    as you move down. That is why we set the *x* location of the enemy to be its current
    *x* coordinate value (we are not moving to the left or the right) and its *y*
    location to be its current *y* coordinate plus one (we are moving down one pixel.)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在`Avatar`类中使用过`setLocation()`吗？我们在这里再次使用它，每次调用`act()`方法时将敌人向下移动一个像素。在Greenfoot中，屏幕的左上角是坐标(0,0)。*x*坐标随着向右移动而增加，*y*坐标随着向下移动而增加。这就是为什么我们将敌人的*x*位置设置为当前的*x*坐标值（我们不会向左或向右移动）以及其*y*位置设置为当前的*y*坐标加一（我们向下移动一个像素。）
- en: Save your `Enemy` class, and then compile your scenario. Run the scenario, right-click
    on the `Enemy` class, and choose `new Enemy()` in the pop-up menu. Add this enemy
    to the screen and watch it move down.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的`Enemy`类，然后编译你的场景。运行场景，右键单击`Enemy`类，并在弹出菜单中选择`new Enemy()`。将这个敌人添加到屏幕上，并观察它向下移动。
- en: Creating an army
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一支军队
- en: 'Now that we have completed our `Enemy` class, we can use it to create an army.
    To do this, we are going to add code to the `act()` method in our `AvoiderWorld`
    class. Open the editor for `AvoiderWorld` by double-clicking on it, or right-clicking
    on it and selecting **Open editor** in the pop-up menu. If you look around the
    code for `AvoiderWorld`, you''ll notice that Greenfoot does not automatically
    create an `act()` method for you. No problem, we''ll just add it. Put the following
    code in `AvoiderWorld`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`Enemy`类的编写，我们可以用它来创建一支军队。为此，我们将向`AvoiderWorld`类的`act()`方法中添加代码。通过双击`AvoiderWorld`或右键单击它并在弹出菜单中选择**打开编辑器**来打开`AvoiderWorld`的编辑器。如果你查看`AvoiderWorld`的代码，你会注意到Greenfoot不会自动为你创建`act()`方法。没问题，我们只需添加它。在`AvoiderWorld`中放入以下代码：
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `act()` method starts by checking whether a randomly generated number between
    0 and 1000, including 0 but not 1000, was less than 20\. In the long run, this
    code will run 2 percent of the times the `act()` method is called. Is this enough?
    Well, the `act()` method is typically called 50 times per second (ranges from
    1 to 100, depending on the position of the speed slider bar), so 2 percent of
    50 is 1\. Therefore, on average one enemy will be created per second. This feels
    about right for the starting level of our game.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`act()`方法首先检查一个在0到1000之间（包括0但不包括1000）随机生成的数字是否小于20。从长远来看，这段代码将在`act()`方法被调用的2%的时间内运行。这足够了吗？嗯，`act()`方法通常每秒调用50次（范围从1到100，取决于速度滑块的位置），所以2%的50次是1。因此，平均每秒将创建一个敌人。这对于我们游戏的起始级别来说感觉是合适的。'
- en: 'Inside the `if` statement, we create an enemy and place it at a specific location
    in the world using the method `addObject()`. The `addObject()` method takes three
    parameters: the object to add, the *x* coordinate of the object, and the *y* coordinate
    of the object. The *y* coordinate is constant and chosen so that the newly created
    enemy starts off at the top of the screen and will appear as it slowly moves down.
    The *x* coordinate is trickier. It is dynamically generated so that the enemy
    could appear on any valid *x* coordinate on the screen. The following is the code
    we are talking about:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`语句内部，我们创建一个敌人并将其放置在世界的特定位置，使用`addObject()`方法。`addObject()`方法接受三个参数：要添加的对象、对象的*x*坐标和对象的*y*坐标。*y*坐标是恒定的，选择它使得新创建的敌人从屏幕顶部开始，并随着它缓慢向下移动而出现。*x*坐标更复杂。它是动态生成的，以便敌人可以出现在屏幕上的任何有效的*x*坐标。以下是我们正在讨论的代码：
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Figure 11* demonstrates the range of *x* coordinate values that are generated.
    In this figure, the rectangles represent the possible set of values for the *x*
    coordinate for the given code. This method of generating ranges of values for
    screen coordinates is common in Greenfoot.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11*展示了生成的*x*坐标值的范围。在这个图中，矩形代表给定代码的*x*坐标可能值的集合。在Greenfoot中，为屏幕坐标生成值范围的这种方法是常见的。'
- en: '![Creating an army](img/image00248.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![创建一支军队](img/image00248.jpeg)'
- en: 'Figure 11: This is the range of x coordinate values generated by the code'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图11：这是代码生成的x坐标值的范围
- en: Compile and run the scenario; you should see a continuous stream of enemy hordes
    moving down the screen.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行场景；你应该会看到一个连续的敌人洪流沿着屏幕向下移动。
- en: Unbounding the world
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无界世界
- en: 'After running the scenario, you''ll notice that the enemies end up piling up
    at the bottom of the screen. In Greenfoot, you can create worlds that are bounded
    (where actors are not allowed to go past the screen borders) and unbounded (where
    actors are allow to exit the screen.) By default, Greenfoot creates bounded worlds.
    However, changing the world to unbounded is extremely easy. Double-click on `AvoiderWorld`
    to open the code editor. Take this line of code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 运行场景后，你会注意到敌人最终会堆积在屏幕底部。在Greenfoot中，你可以创建有界（演员不允许穿过屏幕边界）和无界（演员允许退出屏幕）的世界。默认情况下，Greenfoot创建的是有界世界。然而，将世界改为无界非常容易。双击`AvoiderWorld`以打开代码编辑器。找到以下代码行：
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Change the preceding code to the following line of code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码更改为以下代码行：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Looking at the Greenfoot documentation for the `World` class, we notice there
    are two constructors (see [http://www.greenfoot.org/files/javadoc/greenfoot/World.html](http://www.greenfoot.org/files/javadoc/greenfoot/World.html)
    for detailed information on these constructors): one that takes three parameters
    and another that takes four. The constructor with four parameters has the same
    parameters as the one that takes three, plus one additional `boolean` parameter
    that indicates whether the world is bounded or not. Our code change added the
    fourth Boolean parameter and set it to `false` (no bounds in the world.)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Greenfoot文档中的`World`类，我们会注意到有两个构造函数（有关这些构造函数的详细信息，请参阅[http://www.greenfoot.org/files/javadoc/greenfoot/World.html](http://www.greenfoot.org/files/javadoc/greenfoot/World.html)）：一个接受三个参数，另一个接受四个。具有四个参数的构造函数与接受三个参数的构造函数具有相同的参数，再加上一个额外的`boolean`参数，表示世界是有界还是无界。我们的代码更改添加了第四个布尔参数并将其设置为`false`（世界中没有边界。）
- en: Now, compile and run the scenario. The enemies fall off the bottom of the screen
    as required.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译并运行场景。敌人会按照要求从屏幕底部掉落。
- en: Where do all those enemies go? We'll deal with that next.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些敌人都去哪里了？我们将在下一节中处理这个问题。
- en: Memory management
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存管理
- en: In Greenfoot applications, you'll create hundreds and thousands of actors. When
    we are done with an actor, such as when it is killed or goes off screen, we would
    like to remove that object and not have it consume any more system resources.
    Java manages memory resources via a method called **garbage collection**. With
    this method, Java tries to automatically determine whether you no longer need
    an actor, and if you don't, it deletes that actor and frees up all resources associated
    with it. In Greenfoot, you can let Java know you are done with the actor by removing
    it from `World` using the `removeObject()` method. This is what we want to do
    to an `Enemy` actor, after we have successfully avoided it and it has moved off
    the screen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在Greenfoot应用程序中，你会创建成百上千的演员。当我们完成一个演员，比如当它被杀死或离开屏幕时，我们希望移除该对象，并且它不再消耗任何系统资源。Java通过一个称为**垃圾回收**的方法来管理内存资源。使用此方法，Java试图自动确定你是否不再需要演员，如果你不需要，它将删除该演员并释放与其相关的所有资源。在Greenfoot中，你可以通过使用`removeObject()`方法从`World`中移除演员来让Java知道你已经完成了演员。这就是我们在成功避开它并且它已经离开屏幕后想要对`Enemy`演员做的事情。
- en: 'The most convenient place to remove an `Enemy`, after it has gone off the screen,
    is within the `Enemy` class itself. Add the following code as the last line of
    code inside the `act()` method in the `Enemy` class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在敌人离开屏幕后，移除`Enemy`的最方便的地方是在`Enemy`类本身中。将以下代码作为`Enemy`类中`act()`方法内的最后一行代码添加：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we need to add the `checkRemove()` method. Put the definition of this
    method below the `act()` method. Here is the definition:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加`checkRemove()`方法。将此方法的定义放在`act()`方法下方。以下是定义：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code for your `Enemy` class should look like that shown in *Figure 12*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`Enemy`类的代码应该看起来像*图12*中所示的那样。
- en: '![Memory management](img/image00249.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![内存管理](img/image00249.jpeg)'
- en: 'Figure 12: This shows the adding of code to remove the enemy if it goes off
    the bottom of the screen'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图12：这显示了如何添加代码以移除如果敌人从屏幕底部移出
- en: Now, compile and run the scenario. The enemies fall of the bottom of the screen,
    as before, but you can feel good knowing that they are soon removed from the world
    and the garbage is collected.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译并运行场景。敌人像以前一样从屏幕底部落下，但你可以放心，它们很快就会从世界中移除，垃圾回收也会进行。
- en: Your assignment
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你的作业
- en: 'Learning is not passive, and you really need to engage in the process. Before
    moving on to the next section of this chapter, you should:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 学习不是被动的，你真的需要参与这个过程。在继续本章的下一部分之前，你应该：
- en: Make sure your version of our Avoider Game works, click on **Scenario** in Greenfoot's
    main application menu, and then choose **Save as…** to create an experimental
    copy of Avoider Game. Let's name this experimental copy `AvoiderGameIExperimentation`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的Avoider Game版本可以正常工作，在Greenfoot的主应用程序菜单中点击**场景**，然后选择**另存为…**来创建Avoider
    Game的实验副本。让我们把这个实验副本命名为`AvoiderGameIExperimentation`。
- en: Play around with your experimental copy. Change the spawn rates of the enemies.
    Change how fast the enemies descend.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的实验副本上玩玩。改变敌人的出生率。改变敌人下降的速度。
- en: Add `turn(5);` to the `act()` method of the Enemy class. Compile and run. What's
    going on? Try different values instead of `5` as the input parameter to `turn()`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`turn(5);`添加到`Enemy`类的`act()`方法中。编译并运行。发生了什么？尝试用不同的值代替`5`作为`turn()`的输入参数。
- en: If things get too crazy, delete your experimental copy and make a new copy to
    play with from our original Avoider Game. There's no harm done, nor any foul.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事情变得太疯狂，删除你的实验副本，并从我们的原始Avoider Game创建一个新的副本来玩耍。没有造成伤害，也没有任何不当行为。
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Throughout this book, take this approach of experimenting with the code. Much
    learning will happen during the playing. The very act of thinking about how to
    change the code provides your brain with a new way to process and understand it.
    Making mistakes in a controlled environment will better prepare you to handle
    mistakes later on. You will start to become familiar with Greenfoot's error messages.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，采取这种通过实验代码的方法。在玩耍的过程中会发生很多学习。思考如何更改代码的行为本身就会给你的大脑提供一种新的处理和理解它的方式。在受控环境中犯错误将更好地为你准备以后处理错误。你将开始熟悉Greenfoot的错误信息。
- en: Next…
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 接下来...
- en: Great work until now! We have built the basics of our game and will next add
    some things, such as an introduction screen, game-over screen, and a score, to
    make it look and feel more like a game.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止做得很好！我们已经建立了游戏的基础，接下来我们将添加一些东西，比如介绍屏幕、游戏结束屏幕和分数，使它看起来和感觉更像一个游戏。
- en: Making it a game
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使其成为一个游戏
- en: In this section, we will add a game-over screen, an introduction screen, and
    some background music. But, before we do all that, we need to know when our hero
    touches one of the enemies. This will be our cue to end the game. The act of determining
    when two actors touch is called **collision detection**. Collision detection is
    used to tell whether a bullet hit an enemy, whether the player landed on a platform
    after jumping, or to tell whether a falling leaf landed on a surface. We will
    discuss this important topic next and spend considerable time on it in the upcoming
    chapters.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Detecting collisions
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Greenfoot provides several `Actor` methods you can use to determine whether
    you are touching another `Actor`. These methods, in no particular order, are:
    `getIntersectingObjects()`, `getNeighbors()`, `getObjectsAtOffset()`, `getObjectsInRange()`,
    `getOneIntersectingObject()`, and `getOneObjectAtOffset()`. They all provide slightly
    different ways of determining collision. For our game, we are going to use `getOneIntersectingObject()`.
    The prototype of this method is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This method takes one parameter, which is the class of the objects you want
    to check for collision. This method defines collision in terms of **bounding boxes**;
    a bounding box is the minimal rectangle that can surround all pixels in the graphic.
    This method is efficient and fast, but not the most accurate. In *Figure 12*,
    we can see a picture of a skull and a picture of a smiley face. Even though the
    pixels of the two pictures are not overlapping, we can see that their bounding
    boxes are overlapping; therefore, `getOneIntersectingObject()` would report that
    these two actors are touching. In [Chapter 3](part0024.xhtml "Chapter 3. Collision
    Detection"), *Collision Detection*, we will explore more advanced methods of collision
    detection.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting collisions](img/image00250.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13: This shows the bounding boxes of two actors'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Armed with this new information, we are going to add collision detection to
    our `Avatar` class. We will remove our hero from the game if it touches one of
    the enemies. (Later in this chapter, we will display a game-over screen after
    removing our hero.) Double-click on the `Avatar` class to bring up its editing
    window. Change its `act()` method to this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, add this `checkForCollisions()` method''s definition under the `act()`
    method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Avatar` class should look like the code shown in Figure 14.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting collisions](img/image00251.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14: The Avatar class with collision detection added.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine exactly what's going on in the `checkForCollisions()` method.
    The first thing we do is call `getOneIntersectionObject()` and save its return
    value in the variable `enemy`. This variable will be `null` if this object is
    not touching any enemies, in which case, the expression in the `if` statement
    will evaluate to `false`, and we will not execute the statements inside. Otherwise,
    we are touching an object of the type `Enemy` and do execute the contents of the
    `if` statement.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: There are only two lines of code in the `if` statement. In the first line, we
    use the method `getWorld()`, implemented in the `Actor` class, to get a reference
    to the instance of the `World` we are in. Instead of saving the reference in a
    variable, we immediately invoke the `World` method `removeObject()` supplying
    the keyword `this` as the argument to remove our hero. Lastly, we use the `stop()`
    method in the `Greenfoot` utility class to pause our game.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Now, compile and run the scenario. Enemies should stream down from the top of
    the screen and exit out at the bottom. You should be able to control the hero,
    an instance of the `Avatar` class, by moving your mouse. If our hero touches one
    of the enemies, the game should stop.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Adding a game-over screen
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you need to draw an entire game-over screen in your favorite graphic
    design/drawing program, such as GIMP, CorelDRAW, Inkscape, Greenfoot's built-in
    graphic editor, or even Windows Paint. I used Adobe Illustrator to create the
    screen shown in *Figure 15*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a game-over screen](img/image00252.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15: My AvoiderGame game-over screen; try designing your own.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Whatever you use to draw your image, make sure you can save it in either `PNG`
    or `JPG` format. Its size should be 600 x 400 (the same size as your world). Save
    this image in the `images` folder in your `AvoiderGame` scenario.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Using the same steps that you used to create `AvoiderWorld` (*The Avoider Game
    tutorial* section), create another world; call it `AvoiderGameOverWorld` and associate
    the image you created earlier with it. In the **World classes** area of your scenario,
    you should see what is shown in *Figure 16*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a game-over screen](img/image00253.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16: The World classes section after adding AvoiderGameOverWorld'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Switching scenes
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, we want to display the game-over screen if our hero touches an enemy.
    To do this, we need to perform the following three steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Detect when we collide with an enemy and then tell (by calling a method) our
    world, `AvoiderWorld`, that the game is over.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our `AvoiderWorld` class, we need to implement the game-over method that
    the `Avatar` will use to signal the end of days.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our game-over method, set the world to be `AvoiderGameOverWorld`, instead
    of `AvoiderWorld`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start with step 1\. Previously, in the *Detecting collisions* subsection
    of this section, you wrote code to remove the hero from the game if it touches
    one of the enemies. This code was contained in the method `checkForCollisions()`.
    To implement step 1, we need to change that method to the following method:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The only difference is the code inside the `if` statement. I hope it makes sense
    that we are now asking the world to end the game, as opposed to removing the hero
    object. The part that could be confusing is the substitution of `AvoiderWorld`
    for `World` and the addition of the `(AvoiderWorld)` part. The problem, is that
    we are going to implement `endGame()` in `AvoiderWorld`, not `World`. So, we need
    some way of specifying that the return value of `getWorld()` will be treated as
    `AvoiderWorld` and not just plain old ordinary `World`. In Java terms, this is
    called **casting**.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at steps 2 and 3\. Here's the code you need to add to `AvoiderWorld`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![Switching scenes](img/image00254.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17: This shows the endGame() method added to AvoiderWorld'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: We have changed, and added, a minimal amount of code, but if you have followed
    along carefully, you should be able to save, compile, and run the code. See the
    game-over screen when our hero touches an enemy? (If not, go back and retrace
    your steps. Something you typed in is wrong.)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The three Ps: Plan, Plan, and Plan**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Coding is complicated stuff. When you have a problem to solve, you don't just
    want to sit down and start hacking away at the computer until you bang out a solution.
    You want to sit down with a stylus and ePad (used to be pen and paper in my day)
    and plan. I gave you a small example when I wrote out the three steps needed to
    display the game-over screen. One of the best methods to help you design a solution
    is a **top-down design** (also know as divide and conquer).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: In the top-down design, you start thinking of a solution to a problem at a very
    high level and then repeatedly break down this solution into subsolutions until
    the subsolutions are small and manageable
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Adding a "play again" button
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The game-over screen is great and all, but we don''t want to just stare at
    it all day. OK, so let''s make it so that you can restart the game by clicking
    on the game-over screen. `AvoiderGameOverWorld` needs to keep checking whether
    the mouse has been clicked and then set the world back to `AvoiderWorld`, so that
    we can play the game again. Looking at the Greenfoot documentation, we can see
    the `mouseClicked()` function. Let''s use that method in the `act()` method of
    `AvoiderGameOverWorld`, along with the change world code. Add the following code
    to `AvoiderGameOverWorld`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code should look very familiar to you. The code inside the `if` statement
    is nearly identical to the code we added to the `endGame()` method in the `AvoiderWorld`
    class, except this time we are creating and switching to `AvoiderWorld`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The new part is to check to see whether the user clicked the mouse anywhere
    on the screen. The `Greenfoot.mouseClicked()` method returns true if the user
    just clicked on the object supplied in its parameter. We supplied the `this` variable,
    which represents the whole instance of the `AvoiderGameOverWorld` world.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Compile and run. Great job! Our game is coming along nicely!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Adding an introduction screen
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding an introduction screen is really easy, and we just need to perform many
    of the same steps we did in creating a game-over screen. First, we need to create
    an introduction screen image in whatever graphics editor program you want. The
    one I created is shown in *Figure 18*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding an introduction screen](img/image00255.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18: The image of the introduction screen for our game.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the image is either in PNG or JPG format and has a pixel size of 600
    x 400\. Save this image in the `images` folder in your `AvoiderGame` scenario.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Create a new world (by subclassing `World`), call it `AvoiderGameIntroScreen`,
    and associate the image you just created with it. When you are done with this,
    the **World classes** area of your scenario should look like the screenshot shown
    in *Figure 19*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding an introduction screen](img/image00256.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19: These are all the worlds you created in your AvoiderGame'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Setting the initial screen
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We obviously want our new introduction screen to display first when the player
    first starts the game. To select `AvoiderGameIntroScreen` world as our starting
    `World`, we need to right-click on it in the **World classes** area and select
    the `new AvoiderGameIntroScreen()` menu option in the pop-up window that appears
    (see *Figure 20*).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting the initial screen](img/image00257.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20: This is about selecting our starting world'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Let's make sure everything is hooked up correctly. Compile and run your Greenfoot
    application. You should start with the introduction screen you just created, but
    can't do much else. We'll fix that now.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Adding a "play" button
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We are going to repeat exactly the same steps we did in implementing the restarting
    of the game from the game-over screen.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `AvoiderGameIntroScreen`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code should look very familiar to you. This is exactly the same code we
    added to the `AvoiderGameOverWorld` class.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Compile and run. Have some fun. See how long you can last!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: So far so good, but it is definitely missing some key gaming elements.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Adding background music
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this part of the tutorial, you need to search the Web for a song (`.mp3`)
    you would like to play during the game.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Acquiring music**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you are adding assets (music or graphics) to your game, make sure you
    do so legally. There are many sites on the Internet that offer free use of the
    music or pictures provided. Never use proprietary music, and always cite the sources
    from which you acquired assets. I got the music I added to the game from [newgrounds.com](http://newgrounds.com),
    and I gave credit to the author in my code.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: We only want the music to play when we start playing the game, not during the
    introduction or game-over screens. Therefore, we'll start the music when we display
    `AvoiderWorld` and turn it off before we display `AvoiderGameOverWorld`. We only
    want to start the music once, so we don't want to add the code to play the music
    in the `act()` method—imagine the noise from doing that! What we need is a method
    that is only called once at the creation of the object. That's what the **constructors**
    of a class provide. (If you need to review what a class and an object are, see
    the information box in the *What have we just done?* section)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What is a constructor?**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: In programming in Java (and other object-oriented languages), we write code
    in classes. A **class** describes the methods and attributes of objects we want
    to create in our program. You can think of a class as a blueprint for building
    objects. For example, our `Enemy` class describes the behavior and attributes
    of every enemy object that appears in our Avoider Game. Each *class* has a *constructor*
    that performs all initialization needed for each object created. You can identify
    the constructor of a class easily. Constructors have exactly the same name as
    the class they are in and have no return type. As a quick test, find the constructor
    in our `AvoiderWorld` class. Found it?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: We call the constructor every time we create a new object. In Greenfoot, right-click
    on the Enemy class and you'll see that the top-menu choice is `new Enemy()`. The
    `Enemy()` part is the constructor. The `new` keyword creates the new object and
    the `Enemy()` initializes that new object. Got it?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some good resources you should read to learn more about constructor
    functions:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html](http://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[http://java.about.com/od/workingwithobjects/a/constructor.htm](http://java.about.com/od/workingwithobjects/a/constructor.htm)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Writing the music code
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we know where to put the code (everyone say `constructor`), we need
    to know what code to write. Greenfoot provides a class for playing and managing
    music called `GreenfootSound`. This class makes playing music really easy. Before
    I show you the code to put in the constructor, you should take a look at the documentation
    for `GreenfootSound` and see if you can figure out what to write.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No, really! Go read the documentation! Trying to do it on your own will really
    help you.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Here's the code you need to add to the constructor of `AvoiderWorld`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing the music code](img/image00258.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21: Here''s the constructor for AvoiderWorld'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the music code
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s look at every line of code in the `AvoiderWorld` constructor. First,
    you have the call to the superclass''s constructor, which is needed, as described
    earlier, to properly initialize your game world. Next, we have this line:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This creates a new `GreenfootSound` object and saves a reference to it in the
    `bkgMusic` variable. You need to change the preceding code, so that instead of
    `sounds/UFO_T-Balt.mp3`, you use a string that gives the name of the music file
    you downloaded to play (you need to save the music in your `sounds` folder in
    your Greenfoot project's folder). We also need to declare the `bkgMusic` variable
    we are using in the constructor. To do that, you need to add a variable declaration
    at the top of your class, as shown in *Figure 22*. By declaring the variable at
    the top of your class, it will be accessible to all the methods in your class.
    This will be important when we add code to stop playing the music.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![Analyzing the music code](img/image00259.jpeg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22: This shows the variable declaration for bkgMusic in the AvoiderWorld
    class'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line of code we have to discuss is this one:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This line starts playing the music and will start it over once it finishes.
    If we would have only done `bkgMusic.play()`, then the song would have played
    through only once.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The last line in the constructor is a very important one, and it was added automatically
    by Greenfoot. Remember when, back in the *Adding our hero* section of this chapter,
    I instructed you to place an instance of the `Avatar` class (our hero) in the
    center of the **screen**, right-click, and choose the menu option **Save the World**?
    When you did this, Greenfoot created this `prepare()` method. If you look at the
    contents of this method, you will see that it contains the code to create an `Avatar`
    object and add it to the **screen**. Then, it added the call to use `prepare()`
    in the constructor. If you choose the menu option **Save the World** again, this
    `prepare()` method will be updated.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: OK, save, compile, and run. Did it work? If not, go back and find the typo.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Stop the music
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you ran your code, you had music during the game, but it did not turn off
    when you died and went to the game-over screen. We have to explicitly turn off
    the music before displaying `AvoiderGameOverWorld`. This is super easy! All we
    need to do is add the following line of code at the beginning of the `endGame()`
    method you added to `AvoiderWorld` earlier:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, save, compile, and run. It should all work according to plan.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Private, Protected, and Public**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java keywords `private`, `protected`, and `public` modify how a variable,
    method, or class is accessed in Java. Good programming practice dictates that
    you make all of your class instance variables `private` and require access to
    that variable to only occur through methods. For methods, you want to make ones
    you only access within the `private` class; otherwise, make it `public`. The keyword
    `protected` is used to a method available to subclasses of the class but not to
    external classes. For more information, refer to the following links:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html](http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.tutorialspoint.com/java/java_access_modifiers.htm](http://www.tutorialspoint.com/java/java_access_modifiers.htm)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your assignment
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Perform the following actions before continuing:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Once the game-over screen is displayed, play music. Are you going to make it
    peppy music to lift the spirits of your player or sad and morose to really rub
    it in? Make sure you turn it off before switching to `AvoiderWorld`.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our enemy's movements are pretty vanilla. Can you spice it up? Some ideas are
    to have the enemy characters have variable speed, drift left or right, or enter
    from the top or bottom. What will you come up with?
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember to create a backup copy of `AvoiderGame` before trying these challenges.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Next…
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Almost done! We have built the basics of our game and will next add some things
    to make it challenging.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing playability
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the final section of this chapter, we will add code to increase the game's
    playability. First, we will add a score. Next, we need to increase the challenge
    of the game over time. As the player gets better at the game, we want to ramp
    up the challenge; we will add a leveling system to do this.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Game scoring
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our game is evolving; however, we need a way to judge how well we are doing
    in the game. There are many ways to judge game performance, for example, levels
    completed, time, progression, and so on—but the most common method is to assign
    the player a score. We are going to add a scoring system to the game that rewards
    players for the number of enemies they avoid.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Counter class
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Keeping a count of things and displaying that count is so common in games that
    Greenfoot provides you with a **Counter** class. To get access to this class,
    you need to import it into your scenario. To do this, select **Edit** in Greenfoot's
    main menu, and then select the **Import Class…** submenu choice. You will see
    a window, like the one shown in *Figure 23*. Make sure the **Counter** box is
    selected on the left-hand side and then click on the **Import** button.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the Counter class](img/image00260.jpeg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: 'Figure 23: Here''s Greenfoot''s Import Class window'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: This will add the `Counter` class to your list of **Actor classes** available
    for use in our game as shown in *Figure 24*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the Counter class](img/image00261.jpeg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: 'Figure 24: The Actor classes section of your scenario window now includes the
    Counter class'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: We want the score to appear immediately in the game. In tutorial 4 ([http://www.greenfoot.org/doc/tut-4](http://www.greenfoot.org/doc/tut-4))
    on the Greenfoot site, you were introduced to "Saving the World" to have the `World`
    class automatically place `Actor` in your world. I'm going to describe how to
    place `Actor` in your world manually; specifically, you are going to add an instance
    of the `Counter` class to your `AvoiderWorld` world.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'We discussed that Greenfoot already added the call to the `prepare()` method
    in your `AvoiderWorld()` constructor. Locate the definition of this method in
    the `AvoiderWorld` class. Change this method to look like the following code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first two lines of this method were already present. The last two lines
    put a score display on our game screen. The `scoreBoard = new Counter("Score:
    ");` code creates a new Counter object with a label `Score:` and stores a reference
    to it in the `scoreBoard` variable (we haven''t declared this variable yet, but
    will soon.) The next line of code adds our `Counter` to the upper-left corner
    of our game screen.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need to declare the `scoreBoard` variable at the top of our class.
    Add `private Counter scoreBoard;` above the constructor, as shown in *Figure 25*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the Counter class](img/image00262.jpeg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: 'Figure 25: The declaration of the scoreBoard variable in the class AvoiderWorld.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Compile, run, and test your scenario.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the score over time
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to do just one more thing. We need to call `setValue()` on our `scoreBoard`
    variable to increase our score over time. One place we could do this is where
    we create the enemies in `AvoiderWorld`. The thinking, is that you get some points
    for every enemy created, because you will ultimately have to avoid it. Here''s
    how you should change the `act()` method in `AvoiderWorld`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The only thing I changed was adding the comment about points and adding the
    call to `setValue()` on `scoreBoard`. This line of code retrieves the current
    score using `getValue()`, adds 1 to it, and then sets the new value using `setValue()`.
    The typical usage of the `Counter` class is also provided in a comment at the
    top of the `Counter` class. Check it out!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Compile your `AvoiderGame` scenario and try it out. Are you getting an increased
    score?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Adding levels
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our game isn't very challenging at this point. One thing we could do, is make
    the game become more challenging over time. To do this, we are going to add the
    notion of levels to Avoider Game. We are going to increase the challenge of the
    game by periodically increasing the rate at which enemies spawn and the speed
    at which they travel.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Increasing spawn rates and enemy speed
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In `AvoiderWorld`, add two variables, `enemySpawnRate` and `enemySpeed`, and
    give them initial values; we will use these two variables to increase difficulty.
    The top of your `AvoiderWorld` class should look like *Figure 26*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![Increasing spawn rates and enemy speed](img/image00263.jpeg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: 'Figure 26: This shows the variables in AvoiderWorld'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Increasing difficulty based on the score
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we need to add a method that increases the difficulty of the game based
    on the player''s score. To do this, we need to add the following method to `AvoiderWorld`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We introduced a new variable, `nextLevel`, in `increaseLevel()`, and we need
    to add its declaration at the top of the `AvoiderWorld` class. Here is the declaration
    you need to add next to the variable declarations of `enemySpawnRate` and `enemySpeed`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As evident from the code in `increaseLevel()`, we increase both `enemySpawnRate`
    and `enemySpeed` as the player''s score increases. The last thing we need to do
    is use the `enemySpawnRate` and `enemySpeed` variables in the creation of enemies
    and call `increaseLevel()` from the `act()` method in `AvoiderWorld`. Here is
    the new `act()` method:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Implementing enemy speed increases
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I'd love to yell *compile and run!* at this point, but there is one last detail.
    In the `act()` method, we use the line `e.setSpeed(enemySpeed);` to change the
    speed of the enemy; however, we never have implemented that method in the `Enemy`
    class. In addition, we need to change the `Enemy` class a bit to use the newly
    set speed.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 27* gives the complete code for the `Enemy` class.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing enemy speed increases](img/image00264.jpeg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
- en: 'Figure 27: This shows the finished Enemy class'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we made some really simple changes to the `Enemy` class. We
    added the `setSpeed()` method, which simply accepts an integer parameter and uses
    that value to set the `speed` variable that has been declared at the top of the
    class. In the `act()` method, we use the value of the `speed` variable in the
    `setLocation()` call; we continually add `speed` to the current *y* coordinate.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '*Compile and run and enjoy your new game!*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Your assignment
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since this is the end of the Avoider Game instruction. I''m going to give you
    a few challenge assignments. Good luck! Try to implement the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Once the player's score is above 600, add a new enemy that spawns in addition
    to the enemies we have now. The new enemy should visually be very distinct from
    our existing enemies. If you are feeling up to it, have the new enemy move differently
    from the existing enemies too.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Periodically, spawn a power-up that gives our hero a special ability. For example,
    the power-up could make our hero temporarily invincible, allow our hero to kill
    three enemies, or shrink the size of the avatar making it easier to avoid enemies.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the player's final score on the game-over screen.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These challenges will definitely take some time and you should not feel compelled
    to try them. I just wanted to give those who are really interested a way to continue
    working on the Avoider Game. You will not need to have completed these challenges
    to move on to the next chapter.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Next…
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Congratulations! You did it! Have fun. Play your new game.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter demonstrated how to make a fun and engaging game. We have mouse
    control, a hero, enemies, a score, and introduction and game-over screens.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: As this book assumes you have some experience working in Greenfoot, this chapter
    also served the purpose of refreshing your memory of how to program in Greenfoot.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapters, we'll look at advanced programming concepts in Greenfoot
    that will allow you to create fun, innovative, and engaging applications. These
    chapters will assume that you have mastered the material in this one.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
