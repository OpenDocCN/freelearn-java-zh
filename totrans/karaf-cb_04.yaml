- en: Chapter 4. Hosting a Web Server with Pax Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Pax modules in Apache Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing extended Http Service in Apache Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Pax Web modules deployed in Apache Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Http Service project to host in Apache Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Http Service with the Whiteboard pattern in Apache Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an application with custom HttpContext with Apache Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a standard web project to host in Apache Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring security for a web application in Apache Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding a web project to a specific host in Apache Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Servlet 3.0 annotated web application with Apache Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a CDI web application with Apache Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explains how to enhance your Apache Karaf with Pax Web to serve
    as a web container. The OPS4j Pax Web project is an OSGi R4 Http Service and Web
    Application (refer to *Chapter 128*, *OSGi Enterprise Release 4*) implementation.
    It extends the Http Service with better support for servlet, filters, listeners,
    error pages, JavaServer Pages (JSPs), and more in order to support the latest
    Java Servlet spec.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard features of Karaf contain a set of options to install Pax Web
    in different flavors. There are options for:'
  prefs: []
  type: TYPE_NORMAL
- en: A basic Http Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An enhanced Http Service with support for the Whiteboard pattern and JSPs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A full-blown web container configuration with support for **Web Application
    Archive** (**WAR**) and **Web Application Bundle** (**WAB**) files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Readers interested in obtaining a deeper understanding of Apache Karaf in combination
    with Pax Web should consult the OPS4j community. You'll find a lot more samples
    concerning the usage of Pax Web in general and Apache Karaf specialties as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Pax modules in Apache Karaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start with Http Service, you will need to install one of the features mentioned
    earlier. This recipe will guide you through the installation of the different
    extensions of Pax Web and how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install the basic Http Service, start your Apache Karaf server and install
    the Http Service feature via the console using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After installing this feature, list the bundles with an `la` command. This
    will show you the following additional bundles to your Karaf instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Of course, it will install the needed Jetty server to serve the web content
    and the four basic Pax Web bundles needed to have a minimal Http Service. These
    four bundles contain the API, Services SPI, runtime, and the Jetty server wrapper,
    which takes care of starting the underlying Jetty instance. All of these bundles
    installed by the HTTP feature give you a few possible ways to use the Http Service,
    but nothing else. This scenario is usually good enough for running simple servlets
    and the Felix Web Console.
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of this basic installation, Karaf already provides a simple command
    to inspect the currently installed servlets. It will give you an overview of the
    servlets and the registered aliases. The following is the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Building a Http Service project to host in Apache Karaf* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing extended Http Service in Apache Karaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, just using the basic Http Service is not enough anymore these days,
    especially when it comes to serving JSP or complete web applications. So, a better
    usable container is needed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install the HTTP Whiteboard feature, start your Apache Karaf server and
    install the HTTP Whiteboard feature via the console using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Transform your Apache Karaf server into a full-featured web container using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Whiteboard feature installs another two Pax Web bundles. These bundles
    give you JSP and Whiteboard support. These two bundles are shown in the following
    command-line output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This enables Pax Web to deploy and serve JSPs registered to the now available
    WebContainer interface. This interface is an extension to the standardized Http
    Service. The Whiteboard extender is another approach to register services in OSGi.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More details about the Whiteboard pattern can be found at [http://www.osgi.org/wiki/uploads/Links/whiteboard.pdf](http://www.osgi.org/wiki/uploads/Links/whiteboard.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'With the WAR feature, the installation of Pax Web is complete. This includes
    the WAR extender, which is used to install OSGi WAB files, and the Pax URL WAR
    handler, which takes care of transforming WAR archives into WAB files. These additional
    bundles are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With the Karaf WAR feature comes another command; the `web:*` commands help
    to analyze the state of the installed WARs. An example command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands also help to control the status of a web bundle. Consider the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `web:list` command shows a list of the installed WAR files and gives a listing
    of the state and `Web-ContextPath`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Building a Http Service with the Whiteboard pattern in Apache Karaf* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Building a standard web project to host in Apache Karaf* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more details on how the WAR URL handler works, visit [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Pax Web modules deployed in Apache Karaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pax Web uses Jetty as the underlying web container. The OSGi Http Service specification
    defines a set of parameters for configuration of the Http Service. In addition
    to these standard configuration parameters, the Pax Web-specific parameters are
    configurable. On top of those configuration parameters, it's also possible to
    configure Jetty itself for further needs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The configuration of the Http Service is done through the Configuration Admin
    service. During the installation of the Http Service, the configuration is also
    set for the service PID `org.ops4j.pax.web`, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This basic set of configuration defines the HTTP port the Jetty server is listening
    to, the servlet `temp` directory to create JSP servlet files, and the location
    of the optional `jetty.xml` file for enhanced Jetty configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Documentation on how to configure the `jetty.xml` file can be found at [http://wiki.eclipse.org/Jetty/Reference/jetty.xml](http://wiki.eclipse.org/Jetty/Reference/jetty.xml).
    Make sure that you also take a look at the specialties of running Jetty with Pax
    Web at [https://ops4j1.jira.com/wiki/display/paxweb/Advanced+Jetty+Configuration](https://ops4j1.jira.com/wiki/display/paxweb/Advanced+Jetty+Configuration).
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Additionally, a configuration file for all configuration parameters can be placed
    in the `etc` folder. It's named like the service PID appended by the `.cfg` suffix.
    The following is an excerpt from the `org.ops4j.pax.web.cfg` configuration file.
    This complete configuration file and also the `jetty.xml` file can be found at
    [https://github.com/jgoodyear/ApacheKarafCookbook/blob/master/chapter4/chapter4-recipe2](https://github.com/jgoodyear/ApacheKarafCookbook/blob/master/chapter4/chapter4-recipe2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code configures extra JSP parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the configuration for the NCSA log format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For details about the NCSA log format, refer to [http://en.wikipedia.org/wiki/Common_Log_Format](http://en.wikipedia.org/wiki/Common_Log_Format).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following configuration is used to have different virtual hosts and connectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For more details, see the *Binding a web project to a specific host in Apache
    Karaf* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This configuration excerpt shows you the default configuration that is already
    internally used by Pax Web. If needed, some or all of these configuration parameters
    can be set either in the Karaf shell or be placed in the `org.ops4j.pax.web.cfg`
    file in the `etc` folder. A quick example of how to set the HTTP port via shell
    commands is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: More details on how to use the `config` commands can be found in *Learning Apache
    Karaf*, *Jamie Goodyear, Johan Edstrom, and Heath Kesler*, *Packt Publishing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is best practice to use the `karaf.data` environment variable when referencing
    external directories, for example, when enabling the NCSA logger by switching
    the `org.ops4j.pax.web.log.ncsa.enabled` option to `true`. It is necessary to
    also configure the directory to a specific folder, as described in the following
    code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The same is true for the `scratch` directory for JSP compilation—it is best
    to be configured as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Building a Http Service project to host in Apache Karaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building web applications only with the Http Service also means a reduction
    to servlet only services, as Http Service supports only servlets and no further
    web elements like filters and JSPs. With this reduced set, it is still possible
    to build modern web applications. For example, it just needs some JavaScript code
    and a servlet generating JSON to build a modern web application. Using these elements,
    along with OSGi, you get the perfect mixture for µ-services. The focus of this
    recipe, and the following ones, lies only on the usage of the Http Service; so,
    don''t expect to create a fancy web application. After you''re through, you will
    be able to build a single servlet application like the one in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a Http Service project to host in Apache Karaf](img/5081OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To precondition the Http Service installed in Apache Karaf, see the *Installing
    Pax modules in Apache Karaf* recipe. The sources can be found at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe3](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe3).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is best to always have a look at the complete sources, due to the limited
    amount of pages for this book and to spare you of the boilerplate code. This is
    why only the critical section is referenced here in this recipe. The example application
    used in this recipe can be installed and started with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we are using Http Service with this recipe, we need to get hold of the `HttpService`
    service. For this, it is very common to use a ServiceTracker mechanism. The steps
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is referencing the Http Service. In the activator of our sample
    application, a `ServiceTracker` object is created with a reference to the bundle
    creating this tracker and declaring the class of the service to be tracked. The
    third parameter is an implementation of the ServiceTrackerCustomizer interface.
    A default implementation is provided by the ServiceTracker itself, and therefore
    we use it as is. All of this takes place in the bundle activator code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second step is registering the servlet as a service. The moment the service
    is available, the ServiceTracker will kick in and the `addingService` method of
    the bundle activator will be called. Here, the `HttpContext` function for the
    servlet is created together with the `init` parameter for the servlet to register,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After this, we are ready to register the servlet as a service with the Http
    Service. This is done by the following simple API call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Http Service also supports registering of resources, for example, images
    and CSS files. The Felix Web Console is based on these two mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'To register resources, the Http Service API provides another method for registration,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The image should be contained within a JAR file in the `images` folder (as
    shown in the following screenshot), which is used when registering the image''s
    alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/5081OS_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The corresponding API can be found at [http://www.osgi.org/javadoc/r4v42/org/osgi/service/http/HttpService.html](http://www.osgi.org/javadoc/r4v42/org/osgi/service/http/HttpService.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this image, create a second servlet that uses this image and register
    it with a different alias, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The servlet refers to the image as a resource from the root context, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Http Service configures and registers the HelloServlet with the underlying
    Jetty server. From this point on, it is regarded as a classic servlet and handled
    accordingly. The resources take some extra handling, as the ResourceServlet needs
    to be aware of the OSGi class loading, and thus needs to know where to look for
    the resources in the bundle's class path.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Http Service only provides basic HTTP services, such as to serve servlets
    and resources. If you want to serve dynamic content like JSPs, you'll need the
    Pax Web extension to the OSGi Http Service—the Pax Web web container. This is
    available together with the Whiteboard extender and is used in the *Building a
    Http Service with the Whiteboard pattern in Apache Karaf* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Http Service with the Whiteboard pattern in Apache Karaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Whiteboard pattern is a much easier approach to registering servlets, resources,
    JSPs, or filters. With the Whiteboard extender, the registration of services works
    in the opposite way to the last recipe. The bundle activator doesn't wait for
    the Http Service to show up; it just registers the servlets and the other resources
    as services while the Whiteboard extender picks up those services and makes sure
    that everything is ready to be served. With the Whiteboard feature, it is possible
    to use all web technologies available to the underlying Jetty server, as we are
    not bound to the restricted Http Service interface anymore. This recipe will guide
    you through this by using two different technologies; first, the standard way,
    which is via a bundle activator, and second, via Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is registering a servlet as a service. First, register your servlet
    via the activator using the bundle context. As the servlet is registered as an
    OSGi service, the alias needs to be placed in the service properties. These properties
    are interpreted and partially used for a servlet's `init` parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The servlet itself is registered as any usual OSGi service, as shown in the
    following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second step is registering resources. As this is not a standardized OSGi
    Http Service, a special Pax Web `ResourceMapping` class is needed to register
    a resource as a service, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the registration, it is possible to use these resources by the servlet,
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This pattern to register web components as services will repeat itself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is registering a servlet with Blueprint. Instead of using an
    activator for registration, the Whiteboard pattern also gives you the freedom
    to use other means of registering services, like Blueprint or DS. With a Blueprint
    XML file, it is now only a configuration for the wiring of services, instead of
    creating the boilerplate code contained in the activator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This registers the servlet with the alias `/filtered`, which is used as the
    URL pattern for the matching filter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last step is registering the filter with Blueprint. Registering a filter
    is just as easy as registering a servlet. Using Blueprint for this kind of registration
    uses less boilerplate code. This can be done using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As a result, the filtered call of Hello Servlet can be seen when navigating
    to `/filtered`, as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/5081OS_04_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: There is more to the Whiteboard approach. It is possible to configure a complete
    web application just by registering services.
  prefs: []
  type: TYPE_NORMAL
- en: Registering error pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Registering `DefaultErrorPageMapping`, for example, easily configures an error
    page. The corresponding class is provided by Pax Web and is available through
    the Apache Karaf Http Whiteboard feature. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This error page mapping defines that any exception thrown in the container
    will result in serving the `uncaughtException.html` page, as shown here in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering error pages](img/5081OS_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Defining error page mapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While at it, a custom 404 error code handling page can be registered with extra
    mapping, which again is registered as a service, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`DefaultErrorPageMapping` provided by Pax Web just needs the HTTP error code
    and the location of the custom error code page.'
  prefs: []
  type: TYPE_NORMAL
- en: Registering a welcome page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The configuration and registration of a service for welcome pages is as easy
    as the previous registrations have been. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The Whiteboard extender bundle provides a default implementation of `WelcomeFileMapping`.
    The following screenshot shows the welcome page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering a welcome page](img/5081OS_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Register JSPs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The registration of a JSP is as simple as all the previous recipes. You just
    need to register `DefaultJspMapping` with the corresponding URL patterns. After
    this is done, you are set to serve JSPs right away. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are set to serve the JSP, the following screen will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Register JSPs](img/5081OS_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The now available Whiteboard extender starts a ServiceListener that registers
    any incoming new service such as a servlet, filter, and JSP and hands them over
    to either the standard Http Service or the extended Http Service (the WebContainer
    interface).
  prefs: []
  type: TYPE_NORMAL
- en: Using the direct service approach has only one downside—all of the registered
    servlet services use the same `ServletContextPath`. This is due to the fact that
    the Http Service registered servlets neglect a way to register the servlet with
    a specialized ServletContextPath, and therefore are bound to`/`with an extra URL
    path for the servlet. For example, the first two servlets of this recipe register
    with `/whiteboard` and `/whiteboard/logo`, where the ServletContextPath is `/`.
    To distinguish between different ServletContextPaths, a WAB is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the previous samples have one thing in common: all of them are registered
    within the same bundle. To separate servlets from filters, you need to make sure
    that you have the same HttpContext in use; this is handled in a later recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Building an application with custom HttpContext with Apache Karaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All previous recipes have covered how to register servlets and filters, and
    all from within the same bundle bound to a default HttpContext. If no other HttpContext
    is defined, DefaultHttpContext is created while registering a servlet or resource.
    With this recipe, we will work with a custom HttpContext.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As this recipe is a specialization of the previous recipes, you'll find the
    source code for it in the *Building a Http Service with the Whiteboard pattern
    in Apache Karaf* recipe. As usual, the recipe demands the successful installation
    of the `http-whiteboard` feature; how this can be achieved is explained in the
    *Installing extended Http Service in Apache Karaf* recipe. The source code in
    this recipe is reduced to the important sections. The full sources can be found
    at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe4](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe4).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is defining properties. As with servlets, registering an HttpContext
    requires configuring a name for the HttpContext, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is registering, HttpContext. This will register the custom WhiteboardContext
    as HttpContext with a specialized ID `forbidden`. This way, other services are
    able to select this HttpContext. This is shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is registering the servlet. The servlet using this HttpContext
    is referencing the HttpContext by just being registered using the same HttpContext
    ID. Consider the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The custom HttpContext returns `false` for the `handleSecurity` method. Therefore,
    the request will return a 401 error as HTTP return code. Consider the following
    code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows the HTTP error window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/5081OS_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Till now, the registration of servlets, filters, and other resources always
    took place from the same bundle. How does this fit into the OSGi world? Doesn''t
    it make sense to split this apart? It actually does, but it isn''t easy and the
    OSGi spec doesn''t require it to be possible. With Pax Web 3, it is possible to
    have this working but requires some specialties. First of all, it needs a shared
    HttpContext (its description and how to work with it you will find in the next
    set of steps). The following is a component diagram to give you an idea of the
    setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/5081OS_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is registering the SharedWebContainerContext. For the shared
    HttpContext, it is essential to have the SharedWebContainerContext, which is a
    specialized HttpContext. At this point, the WebContainer interface is our friend
    and helps us by providing a method for the creation of the SharedWebContainerContext,
    which is the `getDefaultSharedHttpContext` method. This is described in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This freshly created SharedWebContainerContext needs to be registered as a
    service, as the filter from the other bundle needs to refer to it. Consider the
    following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is registering the servlet with the shared context. As we want
    to add a filter from a different bundle, we need to add a servlet first. We will
    do this using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, the first bundle is set in our recipe, and we need to take care
    of the second bundle that only contains the filter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next step is referencing the shared HttpContext. We need to get the *shared*
    HttpContext first, though this time we don't create a new one; we just need to
    reference the one that the first bundle registered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the service reference for the HttpContext service that matches the given
    LDAP filter `(httpContext.id=shared)`. Also, see step 1, where we registered the
    service with this property. Consider the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From this service reference, we acquire the HttpContext instance, which in our
    case is the SharedWebContainerContext at this point.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next step is registering the filter for the shared context. From here on,
    it's quite simple. The registration of the servlet filter is done in the usual
    way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the properties needed for registration and register the filter with the
    WebContainer service. It is important that the properties contain the reference
    to the right HttpContext, `shared` at this point. The most important part is that
    it needs to actually register the filter with the preregistered HttpContext.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Can''t this be done easier?**'
  prefs: []
  type: TYPE_NORMAL
- en: The not-yet-released version of Pax Web 4 helps with the sharing of contexts.
    It will especially help in working with the Whiteboard pattern. Since the release
    of Karaf 3 (which uses Pax Web 3), the `features.xml` file of Pax Web is maintained
    and released in the Pax Web release cycle. This will help to upgrade just this
    feature while Karaf itself might stay on another version.
  prefs: []
  type: TYPE_NORMAL
- en: Building a standard web project to host in Apache Karaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As building a standard web application and WAR isn't really in the scope of
    this book, the focus of this recipe lies on the *transformation* of a standard
    WAR into a WAB.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sample code for this recipe is available at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe6](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe6).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Transforming a standard WAR project into a WAB is simple. So, let's take a look
    at the specialties around WAR and WAB files. For simplicity, let's call this project
    web project from here on.
  prefs: []
  type: TYPE_NORMAL
- en: Contrasting with a standard bundle project, where the classes reside directly
    in the JAR file, the classes of a web project should be contained in the `classes`
    folder under the `WEB-INF` folder. The same is true for embedded libraries; in
    a web project, these libraries are required to be placed in the `lib` folder under
    the `WEB-INF` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Beware—embedding other JAR files should be done only if the JAR file is needed
    internally. Referencing other bundles should be your first choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that `maven-bundle-plugin` is capable of taking care of this
    special placement of classes and libraries. The `<_wab>` section takes care of
    this. Here, you define the base path of your web application folder. As this is
    a Maven project, the web application path resides in the `webapp` folder in the
    `src/main` folder. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As it is required for a web application bundle to have a `Web-ContextPath` manifest
    entry, this is set to `packt-sample` in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The WAR feature installs the Pax Web War extender. The WAR extender waits for
    bundles containing the `Web-ContextPath` header and will scan this bundle for
    the `web.xml` and `jetty-web.xml` configuration files. It also takes care of the
    annotated servlet's classes. For each WAR file, there will be a unique servlet
    context with the path defined in the `Web-ContextPath` manifest header. This is
    different from registering servlets via the Http Service (with or without the
    Whiteboard extender), where it is all about the alias.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The only downside of the previously created WAB file is that it is not a WAR
    file anymore. As the POM file declares the resulting package to be of type bundle,
    the artifact is packaged as a JAR file. This surely will cause issues in the case
    of a WAR file that is supposed to be run on Apache Karaf or a non-OSGi container.
  prefs: []
  type: TYPE_NORMAL
- en: To make this work, the Maven POM file of the project needs to be adapted. First,
    set the packaging to WAR. This will use `maven-war-plugin` to package this bundle,
    and in turn, the WAR file is not a WAB file anymore, as it lacks a valid OSGi
    manifest.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s necessary to combine the two plugins to create a valid OSGi WAB file.
    For this, we need to configure `maven-bundle-plugin` in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The plugin is configured just to produce a manifest file, and as the packaging
    is of the type WAR, `maven-bundle-plugin` needs to be configured to support the
    WAR format as valid packaging.
  prefs: []
  type: TYPE_NORMAL
- en: 'The manifest file generated from the preceding code will be merged into the
    WAR bundle explicitly using the `manifestFile` attribute, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: With these configurations, you'll generate a web application that can run in
    Apache Karaf and outside of OSGi.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete sample, take a look at the source code at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe6](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe6).
    Here, you will find a special POM file, `pom.war_xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring security for a web application in Apache Karaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will handle how to build a web application with authentication enabled.
    As we are running within Apache Karaf and Karaf supports **Java Authentication
    and Authorization Service** (**JAAS**) out of the box, we will show you everything
    that is needed to run a basic authentication with JAAS on Karaf.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The prerequisite is to install the WAR feature. The source code for this recipe
    is available at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe7](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe7).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is configuring the user/password combination in Karaf. Let''s
    start with the user configuration. Let''s make sure that the `users.properties`
    file in the `/etc` folder contains the following setup (it''s the default configuration):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `users.properties` file follows the following syntax:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It can also have the following syntax:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is configuring JAAS in Jetty. The `jetty.xml` file used by Pax
    Web needs to contain a valid authentication realm. This realm needs to be configured
    for the usage of JAAS. Configuration of the `JAASLoginService` class will look
    like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The key to accessing the realm of Karaf is to define the `loginModuleName` value
    to `karaf` and define the right principal. As we are running within Karaf, we
    need as configure the `roleClassNames` value to be `org.apache.karaf.jaas.boot.principal.RolePrincipal`.
    With this, the security handshake configuration between Jetty and Karaf is complete.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last step is configuring the web application to use JAAS. To use it from
    within the web application, the `web.xml` file needs to have security enabled
    and configured, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The security for this application is set to secure the secured URL for both
    the `GET` and `POST` methods. The required role has to be of the name `admin`,
    as was configured in step 1\. Consider the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The login configuration is set to be of the type `BASIC`, so the container takes
    care of the authentication and it's configured to use the default realm. This
    configuration points to the defined `JAASLoginService` class with the name `default`
    (configured in step 2).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key for authentication in a web application is the JAAS security mechanism
    provided by Karaf. It's just a matter of configuration to make sure all parts
    are connected appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: When working with Karaf and JAAS security realms, it might be of interest to
    know which realms are currently available. There is a shell command available
    to list all realms—the `jaas:realm-list` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will show us the available realms, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/5081OS_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have configured security in the web application, the only thing
    missing is a way of addressing the application in a secure way. To enable SSL,
    we need to take parts of the configuration from the *Configuring Pax Web modules
    deployed in Apache Karaf* recipe and enable certain values that are off by default.
    All this is done to the `org.ops4j.pax.web.cfg` configuration file, as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: With this configuration, we enable listening on the secure port, which is `8443`
    in our case. The `keystore` value is stored at a location relative to the Karaf
    base directory.
  prefs: []
  type: TYPE_NORMAL
- en: The `clientauthwanted` and `clientauthneeded` properties are set to `true` if
    the client should send a certificate for authentication instead of login credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Once the configurations have been saved, they will be picked up by the FileInstaller
    bundle and applied to running Jetty server through Pax Web.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a fully working SSL, you''ll need a certificate, and so we need to create
    one. The following steps will work on the Linux and Mac environments and most
    likely on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is the `keystore` setup. First of all, create the directory to
    contain the keystore that will be used with Karaf. It has to match the `org.ops4j.pax.web.ssl.keystore`
    property configured in the `org.ops4j.pax.web.cfg` file. This is shown in the
    following screenshot:![There's more…](img/5081OS_04_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the system shell, not the Karaf shell, you will need to use a tool to create
    SSH keys. We will be using the Java tool named **keytool** to create keys and
    certificates. First, create the key to sign the certificate. Make sure that you''re
    doing this in the `keystore` directory (`etc/keystore`). This can be done as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use a simple password as the password, as this is an example, but you shouldn''t
    actually do this in production. As password, we use server. Have a look at the
    following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![There''s more…](img/5081OS_04_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Once you see the previous screenshot, you are already set to use SSL in your
    application. You will need to navigate your browser to the application with the
    SSL port configured previously; in our example, it is `8443`. Your browser will
    complain about an unsigned certificate of an unknown source. After accepting it,
    you'll have the login prompt from your authentication WAR file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is importing the client certificate. It is also possible to connect
    to the server with a signed client certificate. The client needs to do the same
    as has been done for the server—create a self-signed certificate. This certificate
    needs to be imported to the keystore of the server so that the server knows which
    certificate to accept. This can be done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This client certificate needs to be transmitted by the HTTP client software,
    which may be a browser or some other means of communicating software.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Binding a web project to a specific host in Apache Karaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Karaf 3 and Pax Web 3, it is possible to bind a web application to a specific
    HTTP connector. This is a feasible solution to separate internal and external
    applications on the same server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sample code for this recipe is available at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe8](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe8).
    Here, you will find a `jetty.xml` file at the `src/main/etc` location. It can
    be used to add an extra connector. Two extra recipes are available to show how
    to use this with a standard WAB file or the Whiteboard extender.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, the server needs to be configured to support different HTTP connectors.
    Therefore, it is necessary to configure the Jetty server by editing the `jetty.xml`
    file found in the `etc` folder, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Changes to the `jetty.xml` file will take effect only on the restart of the
    server and will not be picked up by FileInstaller and applied at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The second connector is bound to port `8282` and named `alternateConnector`.
    This will be referenced by the application to be bound to this connector.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, the WAB file needs two additional manifest entries, which are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The extra connector configured in the `jetty.xml` file is interpreted by Pax
    Web and is added to Jetty. With the special manifest entries, the web application
    bundle is bound to the configured HTTP connector. The number of connectors and
    applications bound to them are not limited.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Pax Web 3, and therefore with Apache Karaf 3, it is not only possible to
    bind the WAB file to the web connector, but also to a normal bundle. This needs
    some special handling, as there is no `Web-ContextPath` manifest header to define
    the context path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to achieve this is to use the Whiteboard extender. For this, we
    need to register a specialized HttpContext, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The registered servlet just needs to use the following HttpContext:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: That's it. Now you need to call the servlet with the `http://localhost:8282/whiteboard/connector`
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: The servlet is registered with the alias/connector, but the HttpContext takes
    care of the Whiteboard context path.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Servlet 3.0 annotated web application with Apache Karaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the Servlet 3.0 API, it's possible to have web archives only with annotated
    servlets and omit a `web.xml` file, or at least omit the configuration of the
    application within a `web.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, you will find the code for this recipe at the GitHub location at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe9](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe9).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with the *Building a standard web project to host in Apache Karaf* recipe,
    we just build another WAB bundle. Only this time, we have a `web.xml` file containing
    only the definition for the `welcome-file-list` method and annotated servlets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is defining the `web.xml` file. This can be done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is annotating the servlet. The servlet is simple and consists
    only of the usual servlet code and annotation. Consider the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is annotating the filter. The filter also consists of the annotation
    to declare it to be a filter together with the `init` parameters, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this assembly, you are all set to run Servlet 3.0 API applications in Apache
    Karaf.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pax Web does go a step further. As long as the bundle contains a `Web-ContextPath`
    in its `MANIFEST.MF` file, it's considered as a WAB file, and therefore, the Pax
    Web WAR extender handles it as such.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that you have a `Web-ContextPath` in your manifest, as shown in the
    following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, make sure that you have an annotated servlet contained in your bundle,
    as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Pointing the browser to `http://localhost:8181/packt-sample/test` will return
    the desired web content.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Pax Web WAR extender usually looks for bundles containing a `Web-ContextPath`
    in the manifest and for a `web.xml` file to publish the web archive. From Pax
    Web 3.0 on, the WAR extender also accepts bundles containing a `Web-ContextPath`
    in their manifest only.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CDI web application with Apache Karaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, modern web applications use **Contexts and Dependency Injection**
    (**CDI**) to wire the application. In the context of OSGi, it would be nice to
    have this working together with OSGi services. Pax Web, together with Pax CDI,
    takes care of this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides the installation of the WAR feature, it is required to install Pax
    CDI. Use the following commands to install them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the `weld` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The source code for this recipe can be found at [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe10](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter4/chapter4-recipe10).
  prefs: []
  type: TYPE_NORMAL
- en: This recipe needs the bundle and web submodules. The bundle submodule contains
    the OSGi service, and the web submodule contains the CDI web application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with the web application. The `web.xml` file can either be empty
    or can contain the entry for a `welcome-file-list` method, as the application
    is a Servlet 3.0 application. For a CDI application, it is required to have a
    `beans.xml` definition in the class path. As this is a web application, the `beans.xml`
    file is expected to be in the `WEB-INF` folder. For our use, it is sufficient
    to keep an empty `beans.xml` file in this directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The servlet needs to be annotated with the `@WebServlet` annotation to be picked
    up by Pax Web. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The servlet uses an OSGi service to retrieve simple quotes. This service is
    referenced via an injection, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The specialty of Pax CDI is the `@OsgiService` annotation. This annotation will
    wire the corresponding OSGi service to this servlet. The `dynamic = true` property
    makes sure that the dynamism of OSGi services is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a smooth interaction between Pax Web and Pax CDI, a few more configurations
    are required. These are handled in the POM file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Other than the already-known instructions such as `<_wab>` and `<Web-ContextPath>`,
    a CDI bundle requires the `<Require-Capability>` instruction. With this instruction,
    the resolver is informed of the fact that the web bundle requires the capability
    of the CDI bundle.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pax Web registers all of the servlets of a CDI web application. These servlets
    wait for the initialization of the context through Pax CDI. The service is provided
    by another bundle. As long as this service isn't available, the servlet will not
    start. The other important part is the `<Require-Capability>` manifest entry.
    It helps the resolver to wire the WAR bundle to the Pax CDI extension bundle.
    This way, the Pax CDI extender is capable of taking care of the injections.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `<Require-Capability>` header can also be bound to a specific version.
    To do so, the following needs to be configured instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although this recipe gave you a brief overview of how to use CDI to wire services
    in OSGi, a lot more is possible. You can use CDI not only to wire an application
    within the same bundle but also to provide services through CDI and use it in
    another bundle. For more details about Pax CDI and the possibilities, refer to
    the Pax CDI project page at [https://ops4j1.jira.com/wiki/display/PAXCDI/Documentation](https://ops4j1.jira.com/wiki/display/PAXCDI/Documentation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some more samples can be found at [https://github.com/ops4j/org.ops4j.pax.cdi/tree/master/pax-cdi-samples](https://github.com/ops4j/org.ops4j.pax.cdi/tree/master/pax-cdi-samples).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
