- en: Chapter 6. Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming has changed, in the past we could just rely on computers getting
    faster year after year. This is proving to be more and more difficult; so, hardware
    manufacturers are taking a different approach. Now, they are embedding more processors
    into computers. Nowadays, it's not uncommon to see phones with just or four cores.
  prefs: []
  type: TYPE_NORMAL
- en: This calls for a different way of writing software, one in which we are able
    to execute some tasks in other processes, explicitly. The modern languages are
    trying to make this task feasible and easier for modern developers, and Clojure
    is no exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will see how Clojure enables you to write simple concurrent
    programs by reviewing Clojure''s core concepts and primitives; in particular,
    we need to understand the concept of identity and value that Clojure has embedded
    into the language. In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using your Java knowledge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Clojure model of state and identity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Futures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software transactional memory and refs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atoms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watchers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using your Java knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing Java and your way around Java's threading APIs gives you a great advantage,
    since Clojure relies on the tools that you already know.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you'll see how to use threads and you can extend everything you see here
    to execute other services.
  prefs: []
  type: TYPE_NORMAL
- en: Before going any further, let's create a new project that we'll use as a sandbox
    for all of our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create it, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using your Java knowledge](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Modify the `clojure-concurrency.core` namespace, so that it looks similar to
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s easy to understand what''s happening here. We are creating a thread with
    our function and then starting it; so that we can use it in the REPL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using your Java knowledge](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`java.lang.Thread` has a constructor, which receives an object implementing
    the runnable interface. You can just pass a Clojure function because every function
    in Clojure implements runnable and callable interfaces. This means that you can
    also use the executors transparently in Clojure!'
  prefs: []
  type: TYPE_NORMAL
- en: We'll see a `nil` and `Hello threaded world` values in any random order. The
    `nil` value is what the start thread returns.
  prefs: []
  type: TYPE_NORMAL
- en: The `Hello threaded world` is a message from another thread. With this, we now
    have the basic tools to get to know and understand how threads work in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: The Clojure model of state and identity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clojure has very strong opinions about concurrency, in order to take it in a
    simpler way it redefines what state and identity mean. Let's explore the meaning
    of this concepts in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: When talking about state in Java, you probably think about the values of the
    attributes of your Java classes. The state in Clojure is similar to Java, it refers
    to the values of objects but there are very important differences that allow simpler
    concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Clojure, identity is an entity that might have different values over time.
    Consider the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: I have an identity; I will be and continue being this particular individual,
    my opinions, ideas, and appearance might change over time but I am the same individual
    with the same identity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have a bank account; it has a particular number and is run by a particular
    bank. The amount of money you have in it changes over time, but it is the same
    bank account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider a ticker symbol (such as GOOG), it identifies a stock in the stock
    market; the value associated with it changes over time, but not its identity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State** is a value that an identity took at some point in time. One of its
    important features is that it is immutable. State is a snapshot of an identity''s
    value at some given time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Who you are right now, how you feel, how you look, and what you think is your
    current state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The money you currently have in your bank account is its current state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of the GOOG stock is its current state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these states are immutable; it doesn't matter who you are tomorrow or
    how much you win or spend. It is true and it will always be true that in this
    particular moment in time you have a certain state.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rich Hickey, Clojure's author, is a great talker and has several talks in which
    he explains the ideas and philosophy behind Clojure. In one of them, (Are We There
    Yet?) he explains this idea of state, identity, and time very extensively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now explain the two key concepts in Clojure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identity**: Throughout your whole life, you have a single identity; you never
    stop being you, even if you keep changing throughout your whole life.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State**: At any given moment in your life, you are a certain person with
    likes, dislikes, and some beliefs. We call this way of being at a moment of your
    life, the state. If you look at a particular moment in your life, you will see
    a fixed value. Nothing will change the fact that you were the way you were in
    that moment in time. That particular state is immutable; over time, you have different
    states or values, but each of those states is immutable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use this fact to write simpler concurrent programs. Whenever you want to
    interact with an identity, you look at it and you get its current value (a snapshot
    at the time), and then you operate with what you have.
  prefs: []
  type: TYPE_NORMAL
- en: In imperative programming, you normally have a guarantee that you have the latest
    value but it is very difficult to keep it in a consistent state. The reason for
    this is that you are relying on a shared mutable state.
  prefs: []
  type: TYPE_NORMAL
- en: A shared mutable state is the reason why you need to use a synchronized code,
    locks, and mutexes. It is also the reason for very complex programs, with difficult
    bugs to track.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, Java is learning the lessons from other programming languages and
    now it has primitives that allow simpler concurrent programming. These ideas are
    taken from other languages and newer ideas, so there is a good chance that someday
    you'll see similar concepts to what you'll study here in other mainstream programming
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: There is no guarantee that you'll always have the latest value, but don't worry,
    you just have to think about things differently and use the concurrency primitives
    that Clojure gives you.
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to how you work in real life, you don't know exactly what's
    happening with all of your friends or co-workers when you do something for them;
    you talk to them, get the current facts, and then go and get working. While you
    are at it, something needs to change; in this case we need a coordination mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure has various such coordination mechanisms, let's have a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are a full stack Java developer, there is a good chance that you have
    met promises in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Promises are simple abstractions that don't impose strict requirements on you;
    you can use them to calculate the result on some other thread, light process,
    or anything you like.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, there are a couple of ways to achieve this; one of them is with futures
    (`java.util.concurrentFuture`) and if you want something more similar to JavaScript's
    promise there is a nice implementation called **jdeferred** ([https://github.com/jdeferred/jdeferred](https://github.com/jdeferred/jdeferred)),
    which you might have used before.
  prefs: []
  type: TYPE_NORMAL
- en: 'In essence a promise is just a promise that you can give to your caller, the
    caller can use it at any given time. There are two possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: If the promise has already been fulfilled, the call returns immediately
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If not, the caller will block until the promise is fulfilled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example; remember to use the start-thread function
    in the `clojure-concurrency.core` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Promises](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Promises are only calculated once and then cached. So don't worry about using
    them as many times as you like once it has been calculated, there is no runtime
    cost associated!
  prefs: []
  type: TYPE_NORMAL
- en: Let's stop here and analyze the code, we are creating a promise called `p` and
    then we start a thread that does two things.
  prefs: []
  type: TYPE_NORMAL
- en: It tries to get a value from `p` (the `deref` function tries to read the value
    from a promise) and then prints `Hello world`.
  prefs: []
  type: TYPE_NORMAL
- en: We won't see the `Hello world` message just yet; we will instead see a `nil`
    value. Why is that?
  prefs: []
  type: TYPE_NORMAL
- en: The start thread returns the `nil` value and what happens now is what we described
    in the first place; `p` is the promise and our new thread will block it until
    it gets a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to see the `Hello world` message, we need to deliver the promise.
    Let''s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Promises](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we now get the `Hello world` message!
  prefs: []
  type: TYPE_NORMAL
- en: 'As I said, there is no need to use another thread. Let''s now see another example
    in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Promises](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use `@p` instead of (`deref p`), it works for every identity in this
    chapter too.
  prefs: []
  type: TYPE_NORMAL
- en: In this example we don't create separate threads; we create the promise, deliver
    it, and then use it in the same thread.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, promises are an extremely simple type of synchronization mechanism,
    you can decide whether to use threads, executor services (which are just thread
    pools), or some other mechanism, such as lightweight threads.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at Pulsar library for creating lightweight threads.
  prefs: []
  type: TYPE_NORMAL
- en: Pulsar and lightweight threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a thread is an expensive operation and it consumes RAM memory. To
    know how much memory creating a thread consumes in Mac OS X or Linux, run the
    next command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'What you see here will depend on the OS and JVM version that you are using,
    with Java 1.8u45 on Mac OS X, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pulsar and lightweight threads](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I am getting a stack size of 1024 kilobytes per thread. What can we do to improve
    the numbers? Other languages, such as Erlang and Go create a few threads from
    the beginning and then execute their tasks using those threads. It becomes important
    to be able to suspend a particular task and run another in the same thread.
  prefs: []
  type: TYPE_NORMAL
- en: In Clojure there is a library called **Pulsar** ([https://github.com/puniverse/pulsar](https://github.com/puniverse/pulsar)),
    which is an interface for a Java API called **Quasar** ([https://github.com/puniverse/quasar](https://github.com/puniverse/quasar)).
  prefs: []
  type: TYPE_NORMAL
- en: In order to support Pulsar, as of version 0.6.2, you need to do two things.
  prefs: []
  type: TYPE_NORMAL
- en: Add the `[co.paralleluniverse/pulsar "0.6.2"]` dependency to your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an instrumentation agent to your JVM (`adding :java-agents [[co.paralleluniverse/quasar-core
    "0.6.2"]]` to your `project.clj`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The instrumentation agent should be able to suspend functions in a thread and
    then change them for other functions. In the end, your `project.clj` file should
    look similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's write our last example with promises using Pulsar's lightweight threads
    called fibers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pulsar comes with its own promises in the `co.paralleluniverse.pulsar.core`
    package and they can be used as a drop-in replacement for promises in `clojure.core`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is a bit more interesting, we use two of Pulsar''s functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spawn-fiber`: This function creates a light thread, you can create thousands
    of fibers if you want in a single program. They are cheap to create and as long
    as you program them carefully, there shouldn''t be many problems coming from this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`span-thread`: This is Pulsar''s version of start-thread, it creates a real
    thread and runs it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this particular example, we calculate `p2` and `p3` in two fibers and then
    `p3` in a thread. At this point, everything is waiting for us to deliver the value
    of `p1`; we do it with the `deliver` function.
  prefs: []
  type: TYPE_NORMAL
- en: Pulsar has other very interesting features that allow for simpler parallel programming,
    have a look at the documentation if you are interested. In the last part of this
    chapter, we will have a look at `core.async`. Pulsar has an interface modelled
    after `core.async`, which you can use if you like.
  prefs: []
  type: TYPE_NORMAL
- en: Futures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have been using Java for a while, you might know the `java.util.concurrent.Future`
    class, this is Clojure's implementation of futures and it is extremely similar
    to Java, only a bit simpler. Its interface and usage are almost identical to promises
    with a very important difference, when using futures everything will run in a
    different thread automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a simple example using futures, in any REPL do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Your REPL should freeze for 20 seconds and then print `Hello world`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Futures are also cached, so you only need to pay once for the cost of calculation
    and then you can use them any number of times you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, futures look much easier than promises. You don''t need to
    worry about creating threads or fibers, but there are downsides to this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: You have less flexibility; you can only run futures in a predefined thread pool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should be careful if your futures take too much time, they could end up
    NOT running because the implicit thread pool has a number of threads available.
    If they are all busy some of your tasks will end up queued and waiting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Futures` have their use cases, if you have very few processor intensive tasks,
    if you have IO bound tasks, maybe using promises with fibers is a good idea, since
    they allow you to keep your processor free to run more tasks concurrently.'
  prefs: []
  type: TYPE_NORMAL
- en: Software transactional memory and refs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of Clojure's most interesting features is **software transactional memory**
    (**STM**). It uses **multiversion concurrency control** (**MVCC**), in a very
    similar fashion to how databases work, implementing a form of optimistic concurrency
    control.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MVCC is what databases use for transactions; what this means is that every operation
    within a transaction has its own copy of variables. After executing its operations,
    it checks if any of the used variables changed during the transaction and if they
    did the transaction fails. This is called optimistic concurrency control because
    we are optimistic and we don't lock any variable; we let every thread do its work
    thinking that it's going to work correctly and then check if it was correct. In
    practice, this allows for greater concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the most obvious example, a bank account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write some code now, enter into the REPL and write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Try to write the future and the `dosync` functions at the same time so you have
    the same results.
  prefs: []
  type: TYPE_NORMAL
- en: We have just three lines of code here but there are quite a few things happening.
  prefs: []
  type: TYPE_NORMAL
- en: First of all we define a `ref (account)`; refs are the managed variables in
    transactions. They are also the first implementation we see of Clojure's identity
    idea. Note that the account is an identity now and it might take multiple values
    throughout its life.
  prefs: []
  type: TYPE_NORMAL
- en: We now modify its value, we do this within a transaction since refs cannot be
    modified outside of transactions; thus, the `dosync` block.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we print the account and we can use (`deref` account) or `@account`,
    as we did for promises and futures.
  prefs: []
  type: TYPE_NORMAL
- en: Refs can be read from anywhere, there is no need for it to be within a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at something a little bit more interesting now, write or copy the
    next code into the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything goes well, you should have an output similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Software transactional memory and refs](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This might seem a little strange, what is happening?
  prefs: []
  type: TYPE_NORMAL
- en: The first transaction starts its process using the current value for account,
    the other transaction then modifies the value of account before the first transaction
    is finished; Clojure realizes this and it restarts the first transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You shouldn't execute functions with side effects within transactions, as there
    is no guarantee that they will be executed only once. If you need to do something
    like that you should use an agent.
  prefs: []
  type: TYPE_NORMAL
- en: This is the first example of how a transaction works, but using `ref-set` is
    not a good idea in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at another example, the classic example of moving money
    from an account *A* to an account *B*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a better example of how transactions work; you will probably see something
    similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Software transactional memory and refs](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'First of all, you need to understand how the `alter` function works; it''s
    simple and it receives:'
  prefs: []
  type: TYPE_NORMAL
- en: The ref that it has to modify
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function that it has to apply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The extra arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Is translated to something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is the preferred way to modify the current value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a step by step description of what''s going on here:'
  prefs: []
  type: TYPE_NORMAL
- en: We define two accounts with a balance of 10000 and 2000.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We try to move 500 units from the first account to the second but first we sleep
    for 5 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We announce (using the promise) that we have started the transaction. The current
    thread moves on, since it was waiting for the started value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the balance of account-a to 20.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first transaction realizes that something has changed and restarts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The transaction goes on and is finished this time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Nothing happens, since the new balance is not enough to move 50 units.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the end, if you check the balance, like `[@account-a @account-b]`, you will
    see that the first account has 20 and the second account has 2000.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another use case that you should take into account; let''s check the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The idea is that if `secured` is set to true, you shouldn't be able to withdraw
    any money.
  prefs: []
  type: TYPE_NORMAL
- en: If you run it and then check for the value of `@account`, you'll see that even
    after changing the value of `secured` to true a withdrawal occurs. Why is that?
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason is that transactions only check for values that you modify within
    a transaction or values that you read; here we are reading the secured value before
    the modification, so the transaction doesn''t fail. We can tell the transaction
    to be a little bit more careful by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here almost the same thing happened. What is the difference?
  prefs: []
  type: TYPE_NORMAL
- en: There is one subtle difference, the second transaction can't finish until the
    first transaction is done. If you look at it in detail, you will notice that you
    can't modify the secured value until after the other transaction runs.
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to a lock; not the best idea but useful in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: Atoms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now seen how promises, futures, and transactions work in Clojure. We'll
    now see atoms.
  prefs: []
  type: TYPE_NORMAL
- en: Even though STM is very useful and powerful you'll see that in practice it is
    not very commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: Atoms are one of Clojure's workhorses, when it comes to concurrent programming.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of atoms as transactions that modify one single value. You might
    be thinking, what good is that? Imagine you had lots of events that you want to
    store in a single vector. If you are used to Java, you probably know that using
    a `java.util.ArrayList` package is bound to have problems; since, you are almost
    surely going to lose data.
  prefs: []
  type: TYPE_NORMAL
- en: In that case, you probably want to use a class from the `java.util.concurrent`
    package, how can you guarantee that you'll have no data loss in Clojure?
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easy, atoms come to the rescue! Let''s try this piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We are again using Pulsar and its lightweight threads. Here, we define an events
    atom and a `log-events` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `log-events` execute a `swap!` a given number of times.
  prefs: []
  type: TYPE_NORMAL
- en: '`Swap!` is similar to the `alter` function it receives:'
  prefs: []
  type: TYPE_NORMAL
- en: The atom that it should modify
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function that it applies to the atom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The extra arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, it gives the atom the new value that comes from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We then spawn five fibers, each fiber adds 500 events to the events atom.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running this, we can check for the number of events from each fiber like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have 500 elements from each fiber with no data loss and using
    Clojure's default data structures. There is no need to use special data structures
    for each use case, locks, or mutexes. This allows for greater concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: When you modify an atom, you need to wait for the operation to be complete meaning
    it is synchronous.
  prefs: []
  type: TYPE_NORMAL
- en: Agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if you don't care about the result of some operation? You just need to
    fire something and then forget it. In that case agents are what you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Agents also run in separate thread pools, there are two functions that you
    can use to fire an agent:'
  prefs: []
  type: TYPE_NORMAL
- en: '`send`: This executes your function in an implicit thread pool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`send-off`: This tries to execute your function in a new thread but there''s
    a change, it will reuse another thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agents are the way to go if you want to cause side effects in a transaction;
    since, they will only be executed after the transaction has completed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'They work in a very simple manner, here is an example usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you copy and paste the exact previous code you will see a `0` and then a
    `:done` message, if you check for the value of `@agt`, then you will see the value
    `10`.
  prefs: []
  type: TYPE_NORMAL
- en: Agents are a good way to execute a given task and modify some value in a different
    thread with simpler semantics than those of futures or manually modifying values
    in another thread.
  prefs: []
  type: TYPE_NORMAL
- en: Validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen the primary concurrency primitives now, let's see some utilities
    that apply to all of them at once.
  prefs: []
  type: TYPE_NORMAL
- en: We can define a validator that checks if the new value of some function is desirable
    or not; you can use them for refs, atoms, agents, and even vars.
  prefs: []
  type: TYPE_NORMAL
- en: The `validator` function must receive a single value and return true if the
    new value is valid or false otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple `validator` that checks if the new value is lower than
    `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We get an exception. The reason is that the new value (`10`) is not valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add `4` without a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Be careful with the validator and agents, since you will probably not know
    when an exception occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Watchers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to validators, there are also watchers. Watchers are functions that
    are executed whenever Clojure''s identities get a new value. An important question
    is the thread in which watchers run. Watchers run in the same thread as the watched
    entity (if you add a watcher to an agent it will be run in the agent''s thread),
    it will be run before the agent code executes, so you should be careful and use
    the old-value new-value instead of reading the value with `deref`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `add-watch` function receives:'
  prefs: []
  type: TYPE_NORMAL
- en: The ref, atom, agent, or var that should be watched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A key that will be passed to the watcher function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A function with four parameters: the key, the reference itself, the old value,
    and the new value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After executing the previous code we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: core.async
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `core.async` is yet another way of programming concurrently; it uses the
    idea of lightweight threads and channels to communicate between them.
  prefs: []
  type: TYPE_NORMAL
- en: Why lightweight threads?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The lightweight threads are used in languages, such as go and Erlang. They excel
    in being able to run thousands of threads in a single process.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between the lightweight threads and traditional threads?
  prefs: []
  type: TYPE_NORMAL
- en: The traditional threads need to reserve memory. This also takes some time. If
    you want to create a couple of thousand threads, you will be using a noticeable
    amount of memory for each thread; asking the kernel to do that also takes time.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference with lightweight threads? To have a couple of hundred
    lightweight threads, you only need to create a couple of threads. There is no
    need to reserve memory and lightweight threads are a mere software idea.
  prefs: []
  type: TYPE_NORMAL
- en: This can be achieved with most languages and Clojure is adding first class support
    (without changing the language this is part of the Lisp power) with using `core.async`!
    Let's have a look at how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two concepts that you need to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Goblocks**: They are the lightweight threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Channels**: Channels are a way to communicate between goblocks, you can think
    of them as queues. Goblocks can publish a message to the channel and other goblocks
    can take a message from them. Just as there are integration patterns for queues,
    there are integration patterns for channels and you will find concepts similar
    to broadcasting, filtering, and mapping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's play a little with each of them so you can understand better how
    to use them for our program.
  prefs: []
  type: TYPE_NORMAL
- en: Goblocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will find goblocks in the `clojure.core.async` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Goblocks are extremely easy to use, you need the go macro and you will do something
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: They are similar to threads; you just need to remember that you can create goblocks
    freely. There can be thousands of running goblocks in a single JVM.
  prefs: []
  type: TYPE_NORMAL
- en: Channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can actually use anything you like to communicate between goblocks, but
    it is recommended that you use channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Channels have two main operations: putting and getting. Let''s check how to
    do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it!! It looks pretty simple, as you can see there are three main functions
    that we are using with channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '`chan`: This function creates a channel and the channels can store some messages
    in a buffer. If you want this functionality, you should just pass the size of
    the buffer to the `chan` function. If no size is specified, the channel can store
    only one message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>!`: The put function must be used within a goblock; it receives a channel
    and the value you want to publish to it. This function blocks, if a channel''s
    buffer is already full. It will block until something is consumed from the channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<!`: This takes function; this function must be used within a goblock. It
    receives the channel you are taking from. It is blocking and if you haven''t published
    something in the channel it will park until there''s data available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are lots of other functions that you can use with channels, for now let''s
    add two related functions that you will probably use soon:'
  prefs: []
  type: TYPE_NORMAL
- en: '`>!!`: The blocking put, works exactly the same as the `put` function; except
    it can be used from anywhere. Note that if a channel cannot take more data, this
    function will block the entire thread from where it runs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<!!`: The blocking works exactly the same as the `take` function, except you
    can use this from anywhere and not just from inside goblocks. Just keep in mind
    that this blocks the thread where it runs until there''s data available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you look into the `core.async` API docs ([http://clojure.github.io/core.async/](http://clojure.github.io/core.async/))
    you will find a fair amount of functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of them look similar to the functions that give you functionalities similar
    to queues, let''s take a look at the `broadcast` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With this you can publish it to several channels at the same time, this is helpful
    if you want to subscribe multiple processes to a single source of events with
    a great amount of separation of concern.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take a good look, you will also find familiar functions over there:
    `map`, `filter`, and `reduce`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on the version of `core.async`, some of these functions might not
    be there anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Why are these functions there? Those functions are meant to modify collections
    of data, right?
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that there has been a good amount of effort towards using channels
    as higher-level abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to see channels as collections of events, if you think of them that
    way it's easy to see that you can create a new channel by mapping every element
    of an old channel or you can create a new channel by filtering away some elements.
  prefs: []
  type: TYPE_NORMAL
- en: In recent versions of Clojure, the abstraction has become even more noticeable
    with transducers.
  prefs: []
  type: TYPE_NORMAL
- en: Transducers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Transducers are a way to separate the computations from the input source. Simply,
    they are a way to apply a sequence of steps to a sequence or a channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of a sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `comp` feels similar to the threading macros, it composes functions and
    stores the steps of the computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting part is that we can use the same odd-counts transformation
    with a channel, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have checked the core Clojure mechanisms for concurrent programming, as
    you can see, they feel natural and they build on already existing paradigms, such
    as immutability. The most important idea is what an identity and value is; we
    now know that we can have the following values as identifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: Refs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atoms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also get the snapshot of their value with the defer function or the `@`
    shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to use something a little more primitive, we can use promises or
    futures.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen how to use threads, or Pulsar's fibers. Most of Clojure's
    primitives aren't specific to some concurrency mechanism, so we can use any parallel
    programming mechanism with any type of Clojure primitive.
  prefs: []
  type: TYPE_NORMAL
