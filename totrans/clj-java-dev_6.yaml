- en: Chapter 6. Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。并发
- en: Programming has changed, in the past we could just rely on computers getting
    faster year after year. This is proving to be more and more difficult; so, hardware
    manufacturers are taking a different approach. Now, they are embedding more processors
    into computers. Nowadays, it's not uncommon to see phones with just or four cores.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编程已经改变了，在过去，我们只需依赖计算机每年变得更强大。这变得越来越困难；因此，硬件制造商正在采取不同的方法。现在，他们正在将更多的处理器嵌入到计算机中。如今，看到只有或四个核心的手机并不罕见。
- en: This calls for a different way of writing software, one in which we are able
    to execute some tasks in other processes, explicitly. The modern languages are
    trying to make this task feasible and easier for modern developers, and Clojure
    is no exception.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一种不同的软件编写方式，其中我们能够显式地执行其他进程中的某些任务。现代语言正在尝试使这项任务对现代开发者来说可行且更容易，Clojure 也不例外。
- en: 'In this chapter, we will see how Clojure enables you to write simple concurrent
    programs by reviewing Clojure''s core concepts and primitives; in particular,
    we need to understand the concept of identity and value that Clojure has embedded
    into the language. In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过回顾 Clojure 的核心概念和原语来了解 Clojure 如何使你能够通过编写简单的并发程序；特别是，我们需要理解 Clojure
    嵌入到语言中的身份和值的概念。在本章中，我们将涵盖以下主题：
- en: Using your Java knowledge
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运用你的 Java 知识
- en: The Clojure model of state and identity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure 的状态和身份模型
- en: Promises
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺
- en: Futures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来
- en: Software transactional memory and refs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件事务内存和引用
- en: Atoms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子
- en: Agents
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Validators
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证器
- en: Watchers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视器
- en: Using your Java knowledge
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运用你的 Java 知识
- en: Knowing Java and your way around Java's threading APIs gives you a great advantage,
    since Clojure relies on the tools that you already know.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 知道 Java 以及熟悉 Java 的线程 API 给你带来了巨大的优势，因为 Clojure 依赖于你已经知道的工具。
- en: Here, you'll see how to use threads and you can extend everything you see here
    to execute other services.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将看到如何使用线程，你可以扩展这里看到的一切来执行其他服务。
- en: Before going any further, let's create a new project that we'll use as a sandbox
    for all of our tests.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们创建一个新的项目，我们将将其用作所有测试的沙盒。
- en: 'Create it, as shown in the following screenshot:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示创建它：
- en: '![Using your Java knowledge](img/00017.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![运用你的 Java 知识](img/00017.jpeg)'
- en: 'Modify the `clojure-concurrency.core` namespace, so that it looks similar to
    the following code snippet:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `clojure-concurrency.core` 命名空间，使其看起来类似于以下代码片段：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It''s easy to understand what''s happening here. We are creating a thread with
    our function and then starting it; so that we can use it in the REPL, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情很容易理解。我们使用我们的函数创建了一个线程，然后启动它；这样我们就可以在 REPL 中使用它，如下所示：
- en: '![Using your Java knowledge](img/00018.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![运用你的 Java 知识](img/00018.jpeg)'
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`java.lang.Thread` has a constructor, which receives an object implementing
    the runnable interface. You can just pass a Clojure function because every function
    in Clojure implements runnable and callable interfaces. This means that you can
    also use the executors transparently in Clojure!'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Thread` 有一个构造函数，它接收一个实现可运行接口的对象。你只需传递一个 Clojure 函数，因为 Clojure 中的每个函数都实现了可运行和可调用接口。这意味着你还可以在
    Clojure 中透明地使用执行器！'
- en: We'll see a `nil` and `Hello threaded world` values in any random order. The
    `nil` value is what the start thread returns.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在任意顺序中看到 `nil` 和 `Hello threaded world` 的值。`nil` 值是启动线程返回的值。
- en: The `Hello threaded world` is a message from another thread. With this, we now
    have the basic tools to get to know and understand how threads work in Clojure.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hello threaded world` 是来自另一个线程的消息。有了这个，我们现在有了基本的工具来了解和理解 Clojure 中线程的工作方式。'
- en: The Clojure model of state and identity
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure 的状态和身份模型
- en: Clojure has very strong opinions about concurrency, in order to take it in a
    simpler way it redefines what state and identity mean. Let's explore the meaning
    of this concepts in Clojure.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 对并发有非常强烈的看法，为了以更简单的方式处理它，它重新定义了状态和身份的含义。让我们探索 Clojure 中这些概念的含义。
- en: When talking about state in Java, you probably think about the values of the
    attributes of your Java classes. The state in Clojure is similar to Java, it refers
    to the values of objects but there are very important differences that allow simpler
    concurrency.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论 Java 中的状态时，你可能首先会想到你的 Java 类属性的值。Clojure 中的状态与 Java 类似，它指的是对象的值，但有一些非常重要的差异，这些差异允许更简单的并发。
- en: 'In Clojure, identity is an entity that might have different values over time.
    Consider the following examples:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，身份是一个可能在时间上具有不同值的实体。考虑以下例子：
- en: I have an identity; I will be and continue being this particular individual,
    my opinions, ideas, and appearance might change over time but I am the same individual
    with the same identity.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我有一个身份；我将继续是这一特定个体，我的观点、想法和外表可能会随时间而改变，但我始终是同一个具有相同身份的个体。
- en: You have a bank account; it has a particular number and is run by a particular
    bank. The amount of money you have in it changes over time, but it is the same
    bank account.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个银行账户；它有一个特定的号码，由特定的银行运营。你账户中的金额会随时间变化，但它始终是同一个银行账户。
- en: Consider a ticker symbol (such as GOOG), it identifies a stock in the stock
    market; the value associated with it changes over time, but not its identity.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑一个股票代码（例如GOOG），它标识了股市中的一支股票；与其相关的价值会随时间变化，但它的身份不会变。
- en: '**State** is a value that an identity took at some point in time. One of its
    important features is that it is immutable. State is a snapshot of an identity''s
    value at some given time.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态**是身份在某个时间点所采取的值。它的一个重要特征是不可变性。状态是身份在某个给定时间点的快照。'
- en: 'So, in the previous examples:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在之前的例子中：
- en: Who you are right now, how you feel, how you look, and what you think is your
    current state
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你现在是谁，你的感受，你的外表，以及你的想法，都是你的当前状态
- en: The money you currently have in your bank account is its current state
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你目前在银行账户中的钱是其当前状态
- en: The value of the GOOG stock is its current state
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GOOG股票的价值是其当前状态
- en: All of these states are immutable; it doesn't matter who you are tomorrow or
    how much you win or spend. It is true and it will always be true that in this
    particular moment in time you have a certain state.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些状态都是不可变的；无论你明天是谁，或者你赢了多少或花了多少，这都是真的，并且永远是真的，在这个特定的时间点上，你处于某种状态。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Rich Hickey, Clojure's author, is a great talker and has several talks in which
    he explains the ideas and philosophy behind Clojure. In one of them, (Are We There
    Yet?) he explains this idea of state, identity, and time very extensively.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure的作者Rich Hickey是一位伟大的演讲者，他有几场演讲解释了Clojure背后的思想和哲学。在其中一场（Are We There Yet?）中，他非常详细地解释了这个关于状态、身份和时间的观点。
- en: 'Let''s now explain the two key concepts in Clojure:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来解释Clojure中的两个关键概念：
- en: '**Identity**: Throughout your whole life, you have a single identity; you never
    stop being you, even if you keep changing throughout your whole life.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份**：在你的一生中，你有一个单一的身份；你永远不会停止成为你自己，即使你在整个一生中都在不断变化。'
- en: '**State**: At any given moment in your life, you are a certain person with
    likes, dislikes, and some beliefs. We call this way of being at a moment of your
    life, the state. If you look at a particular moment in your life, you will see
    a fixed value. Nothing will change the fact that you were the way you were in
    that moment in time. That particular state is immutable; over time, you have different
    states or values, but each of those states is immutable.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：在任何给定的生活时刻，你都是一个特定的人，有喜好、厌恶和一些信念。我们称这种生活时刻的存在方式为状态。如果你看一个特定的生活时刻，你会看到一个固定的值。没有任何东西会改变你在那个时间点的样子。那个特定的状态是不可变的；随着时间的推移，你会有不同的状态或值，但每个状态都是不可变的。'
- en: We use this fact to write simpler concurrent programs. Whenever you want to
    interact with an identity, you look at it and you get its current value (a snapshot
    at the time), and then you operate with what you have.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用这个事实来编写更简单的并发程序。每次你想与一个身份交互时，你查看它，并获取它的当前值（一个时间点的快照），然后你用你所拥有的东西进行操作。
- en: In imperative programming, you normally have a guarantee that you have the latest
    value but it is very difficult to keep it in a consistent state. The reason for
    this is that you are relying on a shared mutable state.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，你通常有一个保证你拥有最新值的保证，但很难保持它的一致性状态。原因在于你依赖于共享的可变状态。
- en: A shared mutable state is the reason why you need to use a synchronized code,
    locks, and mutexes. It is also the reason for very complex programs, with difficult
    bugs to track.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 共享的可变状态是为什么你需要使用同步代码、锁和互斥锁的原因。它也是复杂程序和难以追踪的错误的原因。
- en: Nowadays, Java is learning the lessons from other programming languages and
    now it has primitives that allow simpler concurrent programming. These ideas are
    taken from other languages and newer ideas, so there is a good chance that someday
    you'll see similar concepts to what you'll study here in other mainstream programming
    languages.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Java正在从其他编程语言中吸取教训，现在它有了允许更简单并发编程的原语。这些想法来自其他语言和新的想法，所以有很大可能性有一天你会在其他主流编程语言中看到与你在学习这里相似的概念。
- en: There is no guarantee that you'll always have the latest value, but don't worry,
    you just have to think about things differently and use the concurrency primitives
    that Clojure gives you.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 没有保证你总能得到最新的值，但不用担心，你只需要换一种思维方式，并使用Clojure提供的并发原语。
- en: This is similar to how you work in real life, you don't know exactly what's
    happening with all of your friends or co-workers when you do something for them;
    you talk to them, get the current facts, and then go and get working. While you
    are at it, something needs to change; in this case we need a coordination mechanism.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这与你在现实生活中工作的方式类似，当你为朋友或同事做某事时，你并不知道他们具体发生了什么；你与他们交谈，获取当前的事实，然后去工作。在你做这些的同时，可能需要改变一些东西；在这种情况下，我们需要一个协调机制。
- en: Clojure has various such coordination mechanisms, let's have a look at them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure有各种这样的协调机制，让我们来看看它们。
- en: Promises
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺
- en: If you are a full stack Java developer, there is a good chance that you have
    met promises in JavaScript.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个全栈Java开发者，你很可能在JavaScript中遇到过承诺。
- en: Promises are simple abstractions that don't impose strict requirements on you;
    you can use them to calculate the result on some other thread, light process,
    or anything you like.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺是简单的抽象，不会对你提出严格的要求；你可以使用它们在另一个线程、轻量级进程或任何你喜欢的地方计算结果。
- en: In Java, there are a couple of ways to achieve this; one of them is with futures
    (`java.util.concurrentFuture`) and if you want something more similar to JavaScript's
    promise there is a nice implementation called **jdeferred** ([https://github.com/jdeferred/jdeferred](https://github.com/jdeferred/jdeferred)),
    which you might have used before.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，有几种实现这种方式的方法；其中之一是使用未来（futures，`java.util.concurrentFuture`），如果你想得到一个更类似于JavaScript的承诺的实现，有一个叫做**jdeferred**（[https://github.com/jdeferred/jdeferred](https://github.com/jdeferred/jdeferred)）的很好的实现，你可能之前已经使用过了。
- en: 'In essence a promise is just a promise that you can give to your caller, the
    caller can use it at any given time. There are two possibilities:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，承诺只是你可以提供给调用者的一个承诺，调用者可以在任何给定时间使用它。有两种可能性：
- en: If the promise has already been fulfilled, the call returns immediately
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果承诺已经被履行，调用将立即返回
- en: If not, the caller will block until the promise is fulfilled
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不是，调用者将阻塞直到承诺得到履行
- en: 'Let''s take a look at an example; remember to use the start-thread function
    in the `clojure-concurrency.core` package:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子；请记住在`clojure-concurrency.core`包中使用`start-thread`函数：
- en: '![Promises](img/00019.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![Promises](img/00019.jpeg)'
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Promises are only calculated once and then cached. So don't worry about using
    them as many times as you like once it has been calculated, there is no runtime
    cost associated!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺（Promises）只计算一次，然后被缓存。所以一旦计算完成，你就可以放心地多次使用它们，不会产生任何运行时成本！
- en: Let's stop here and analyze the code, we are creating a promise called `p` and
    then we start a thread that does two things.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里停下来分析代码，我们创建了一个名为`p`的承诺，然后启动一个线程执行两件事。
- en: It tries to get a value from `p` (the `deref` function tries to read the value
    from a promise) and then prints `Hello world`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它试图从`p`（`deref`函数试图从承诺中读取值）获取一个值，然后打印“Hello world”。
- en: We won't see the `Hello world` message just yet; we will instead see a `nil`
    value. Why is that?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在还看不到“Hello world”消息；相反，我们会看到一个`nil`值。这是为什么？
- en: The start thread returns the `nil` value and what happens now is what we described
    in the first place; `p` is the promise and our new thread will block it until
    it gets a value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 启动线程返回`nil`值，现在发生的事情正是我们最初描述的；`p`是承诺，我们的新线程将阻塞它直到它得到一个值。
- en: 'In order to see the `Hello world` message, we need to deliver the promise.
    Let''s do that now:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到“Hello world”消息，我们需要履行承诺。现在让我们来做这件事：
- en: '![Promises](img/00020.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Promises](img/00020.jpeg)'
- en: As you can see, we now get the `Hello world` message!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们现在得到了“Hello world”消息！
- en: 'As I said, there is no need to use another thread. Let''s now see another example
    in the REPL:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如我所说，没有必要使用另一个线程。现在让我们在REPL中看看另一个例子：
- en: '![Promises](img/00021.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![Promises](img/00021.jpeg)'
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can use `@p` instead of (`deref p`), it works for every identity in this
    chapter too.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `@p` 而不是 (`deref p`)，这对本章中的每个身份也适用。
- en: In this example we don't create separate threads; we create the promise, deliver
    it, and then use it in the same thread.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不创建单独的线程；我们创建承诺，交付它，然后在同一线程中使用它。
- en: As you can see, promises are an extremely simple type of synchronization mechanism,
    you can decide whether to use threads, executor services (which are just thread
    pools), or some other mechanism, such as lightweight threads.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，承诺是一种极其简单的同步机制，您可以选择是否使用线程、执行器服务（这只是线程池）或某种其他机制，例如轻量级线程。
- en: Let's have a look at Pulsar library for creating lightweight threads.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看用于创建轻量级线程的 Pulsar 库。
- en: Pulsar and lightweight threads
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pulsar 和轻量级线程
- en: 'Creating a thread is an expensive operation and it consumes RAM memory. To
    know how much memory creating a thread consumes in Mac OS X or Linux, run the
    next command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 创建线程是一个昂贵的操作，并且它会消耗 RAM 内存。为了知道在 Mac OS X 或 Linux 中创建线程消耗了多少内存，请运行以下命令：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What you see here will depend on the OS and JVM version that you are using,
    with Java 1.8u45 on Mac OS X, we get the following output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这里看到的内容将取决于您使用的操作系统和 JVM 版本，在 Mac OS X 上使用 Java 1.8u45，我们得到以下输出：
- en: '![Pulsar and lightweight threads](img/00022.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Pulsar 和轻量级线程](img/00022.jpeg)'
- en: I am getting a stack size of 1024 kilobytes per thread. What can we do to improve
    the numbers? Other languages, such as Erlang and Go create a few threads from
    the beginning and then execute their tasks using those threads. It becomes important
    to be able to suspend a particular task and run another in the same thread.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我为每个线程获取 1024 千字节的堆栈大小。我们能做些什么来提高这些数字？其他语言，如 Erlang 和 Go，一开始就创建几个线程，然后使用这些线程执行任务。能够挂起特定任务并在同一线程中运行另一个任务变得很重要。
- en: In Clojure there is a library called **Pulsar** ([https://github.com/puniverse/pulsar](https://github.com/puniverse/pulsar)),
    which is an interface for a Java API called **Quasar** ([https://github.com/puniverse/quasar](https://github.com/puniverse/quasar)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 中有一个名为 **Pulsar** 的库（[https://github.com/puniverse/pulsar](https://github.com/puniverse/pulsar)），它是一个名为
    **Quasar** 的 Java API 的接口（[https://github.com/puniverse/quasar](https://github.com/puniverse/quasar)）。
- en: In order to support Pulsar, as of version 0.6.2, you need to do two things.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持 Pulsar，从版本 0.6.2 开始，您需要做两件事。
- en: Add the `[co.paralleluniverse/pulsar "0.6.2"]` dependency to your project
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `[co.paralleluniverse/pulsar "0.6.2"]` 依赖项添加到您的项目中
- en: Add an instrumentation agent to your JVM (`adding :java-agents [[co.paralleluniverse/quasar-core
    "0.6.2"]]` to your `project.clj`)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个仪器代理添加到您的 JVM 中（将 `adding :java-agents [[co.paralleluniverse/quasar-core
    "0.6.2"]]` 添加到您的 `project.clj` 文件中）
- en: 'The instrumentation agent should be able to suspend functions in a thread and
    then change them for other functions. In the end, your `project.clj` file should
    look similar to:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 仪器代理应该能够挂起线程中的函数，然后将其更改为其他函数。最后，您的 `project.clj` 文件应该看起来类似于：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's write our last example with promises using Pulsar's lightweight threads
    called fibers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 Pulsar 的轻量级线程（称为纤维）来编写我们的最后一个使用承诺的例子。
- en: 'Pulsar comes with its own promises in the `co.paralleluniverse.pulsar.core`
    package and they can be used as a drop-in replacement for promises in `clojure.core`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Pulsar 在 `co.paralleluniverse.pulsar.core` 包中提供了自己的承诺，并且可以用作 `clojure.core`
    中承诺的替代品：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This example is a bit more interesting, we use two of Pulsar''s functions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子更有趣一些，我们使用了 Pulsar 的两个函数：
- en: '`spawn-fiber`: This function creates a light thread, you can create thousands
    of fibers if you want in a single program. They are cheap to create and as long
    as you program them carefully, there shouldn''t be many problems coming from this.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spawn-fiber`：这个函数创建一个轻量级线程，如果您想在一个程序中创建数千个纤维，也是可以的。它们创建成本低，只要您仔细编程，就不应该有很多问题。'
- en: '`span-thread`: This is Pulsar''s version of start-thread, it creates a real
    thread and runs it.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`span-thread`：这是 Pulsar 的 start-thread 版本，它创建一个真实线程并运行它。'
- en: In this particular example, we calculate `p2` and `p3` in two fibers and then
    `p3` in a thread. At this point, everything is waiting for us to deliver the value
    of `p1`; we do it with the `deliver` function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，我们在两个纤维中计算 `p2` 和 `p3`，然后在线程中计算 `p3`。在这个时候，一切都在等待我们提供 `p1` 的值；我们使用
    `deliver` 函数来完成它。
- en: Pulsar has other very interesting features that allow for simpler parallel programming,
    have a look at the documentation if you are interested. In the last part of this
    chapter, we will have a look at `core.async`. Pulsar has an interface modelled
    after `core.async`, which you can use if you like.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Pulsar还有其他非常有趣的功能，允许更简单的并行编程，如果你感兴趣，可以查看文档。在本章的最后部分，我们将探讨`core.async`。Pulsar有一个基于`core.async`的接口模型，如果你喜欢，可以使用它。
- en: Futures
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来（Futures）
- en: If you have been using Java for a while, you might know the `java.util.concurrent.Future`
    class, this is Clojure's implementation of futures and it is extremely similar
    to Java, only a bit simpler. Its interface and usage are almost identical to promises
    with a very important difference, when using futures everything will run in a
    different thread automatically.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用Java一段时间了，你可能知道`java.util.concurrent.Future`类，这是Clojure对未来的实现，它与Java非常相似，只是稍微简单一些。它的接口和用法几乎与承诺相同，但有一个非常重要的区别，当使用未来时，所有操作都会自动在不同的线程中运行。
- en: 'Let''s see a simple example using futures, in any REPL do the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用未来的简单示例，在任何REPL中执行以下操作：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Your REPL should freeze for 20 seconds and then print `Hello world`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你的REPL应该冻结20秒，然后打印`Hello world`。
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Futures are also cached, so you only need to pay once for the cost of calculation
    and then you can use them any number of times you want.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 未来（futures）也被缓存，所以你只需要为计算成本付费一次，然后你可以根据需要多次使用它们。
- en: 'At first glance, futures look much easier than promises. You don''t need to
    worry about creating threads or fibers, but there are downsides to this approach:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，未来（futures）似乎比承诺（promises）简单得多。你不需要担心创建线程或纤程，但这种方法也有其缺点：
- en: You have less flexibility; you can only run futures in a predefined thread pool.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的灵活性较少；你只能在预定义的线程池中运行未来（futures）。
- en: You should be careful if your futures take too much time, they could end up
    NOT running because the implicit thread pool has a number of threads available.
    If they are all busy some of your tasks will end up queued and waiting.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的未来（futures）占用太多时间，它们可能最终不会运行，因为隐含的线程池有可用的线程数量。如果它们都忙碌，一些任务将最终排队等待。
- en: '`Futures` have their use cases, if you have very few processor intensive tasks,
    if you have IO bound tasks, maybe using promises with fibers is a good idea, since
    they allow you to keep your processor free to run more tasks concurrently.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Futures`有其用例，如果你有很少的处理器密集型任务，如果你有I/O密集型任务，也许使用带有纤程的承诺是个好主意，因为它们允许你保持处理器空闲以并行运行更多任务。'
- en: Software transactional memory and refs
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件事务内存和refs
- en: One of Clojure's most interesting features is **software transactional memory**
    (**STM**). It uses **multiversion concurrency control** (**MVCC**), in a very
    similar fashion to how databases work, implementing a form of optimistic concurrency
    control.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure最有趣的功能之一是**软件事务内存**（**STM**）。它使用**多版本并发控制**（**MVCC**），其工作方式与数据库非常相似，实现了乐观并发控制的一种形式。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: MVCC is what databases use for transactions; what this means is that every operation
    within a transaction has its own copy of variables. After executing its operations,
    it checks if any of the used variables changed during the transaction and if they
    did the transaction fails. This is called optimistic concurrency control because
    we are optimistic and we don't lock any variable; we let every thread do its work
    thinking that it's going to work correctly and then check if it was correct. In
    practice, this allows for greater concurrency.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: MVCC是数据库用于事务的；这意味着事务内的每个操作都有自己的变量副本。在执行其操作后，它会检查在事务过程中是否有任何使用的变量发生变化，如果发生了变化，则事务失败。这被称为乐观并发控制，因为我们持乐观态度，我们不锁定任何变量；我们让每个线程做自己的工作，认为它会正确工作，然后检查它是否正确。在实践中，这允许更高的并发性。
- en: Let's start with the most obvious example, a bank account.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最明显的例子开始，一个银行账户。
- en: 'Let''s write some code now, enter into the REPL and write:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们写一些代码，进入REPL并编写：
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Try to write the future and the `dosync` functions at the same time so you have
    the same results.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试同时编写未来（future）和`dosync`函数，以便得到相同的结果。
- en: We have just three lines of code here but there are quite a few things happening.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里只有三行代码，但发生的事情却相当多。
- en: First of all we define a `ref (account)`; refs are the managed variables in
    transactions. They are also the first implementation we see of Clojure's identity
    idea. Note that the account is an identity now and it might take multiple values
    throughout its life.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个`ref (account)`；引用是事务中的管理变量。它们也是我们看到的Clojure身份概念的第一个实现。请注意，账户现在是一个身份，它在其生命周期中可能具有多个值。
- en: We now modify its value, we do this within a transaction since refs cannot be
    modified outside of transactions; thus, the `dosync` block.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在修改其值，我们在事务中进行此操作，因为引用不能在事务之外修改；因此，`dosync`块。
- en: In the end, we print the account and we can use (`deref` account) or `@account`,
    as we did for promises and futures.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们打印账户，我们可以使用（`deref`账户）或`@account`，就像我们对承诺和未来所做的那样。
- en: Refs can be read from anywhere, there is no need for it to be within a transaction.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 引用可以从任何地方读取，不需要它在事务内。
- en: 'Let''s look at something a little bit more interesting now, write or copy the
    next code into the REPL:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一些更有趣的东西，将下面的代码写入或复制到REPL中：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If everything goes well, you should have an output similar to the following
    screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该得到以下截图类似的输出：
- en: '![Software transactional memory and refs](img/00023.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![软件事务内存和引用](img/00023.jpeg)'
- en: This might seem a little strange, what is happening?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点奇怪，发生了什么？
- en: The first transaction starts its process using the current value for account,
    the other transaction then modifies the value of account before the first transaction
    is finished; Clojure realizes this and it restarts the first transaction.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个事务使用账户的当前值开始其过程，另一个事务在第一个事务完成之前修改了账户的值；Clojure意识到这一点，并重新启动了第一个事务。
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You shouldn't execute functions with side effects within transactions, as there
    is no guarantee that they will be executed only once. If you need to do something
    like that you should use an agent.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该在事务中执行有副作用的函数，因为没有保证它们只会执行一次。如果你需要做类似的事情，你应该使用代理。
- en: This is the first example of how a transaction works, but using `ref-set` is
    not a good idea in general.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是事务工作方式的第一个示例，但使用`ref-set`通常不是一个好主意。
- en: 'Let''s take a look at another example, the classic example of moving money
    from an account *A* to an account *B*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子，将资金从账户*A*转移到账户*B*的经典例子：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is a better example of how transactions work; you will probably see something
    similar to the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更好的示例，说明了事务是如何工作的；你可能会看到以下截图中的类似内容：
- en: '![Software transactional memory and refs](img/00024.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![软件事务内存和引用](img/00024.jpeg)'
- en: 'First of all, you need to understand how the `alter` function works; it''s
    simple and it receives:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要了解`alter`函数是如何工作的；它很简单，它接收：
- en: The ref that it has to modify
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要修改的引用
- en: The function that it has to apply
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须应用的功能
- en: The extra arguments
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的参数
- en: 'So this function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个函数：
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Is translated to something like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译成类似以下内容：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is the preferred way to modify the current value.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是修改当前值的首选方式。
- en: 'Let''s see a step by step description of what''s going on here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地描述这里发生的事情：
- en: We define two accounts with a balance of 10000 and 2000.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了两个账户，余额分别为10000和2000。
- en: We try to move 500 units from the first account to the second but first we sleep
    for 5 seconds.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们尝试将500个单位从第一个账户移动到第二个账户，但首先我们休眠5秒钟。
- en: We announce (using the promise) that we have started the transaction. The current
    thread moves on, since it was waiting for the started value.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过承诺宣布我们已经开始事务。当前线程继续运行，因为它正在等待已启动的值。
- en: We set the balance of account-a to 20.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将账户-a的余额设置为20。
- en: The first transaction realizes that something has changed and restarts.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个事务意识到发生了变化并重新启动。
- en: The transaction goes on and is finished this time.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事务继续进行并最终完成。
- en: Nothing happens, since the new balance is not enough to move 50 units.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有发生任何变化，因为新的余额不足以移动50个单位。
- en: In the end, if you check the balance, like `[@account-a @account-b]`, you will
    see that the first account has 20 and the second account has 2000.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你检查余额，如`[@account-a @account-b]`，你会看到第一个账户有20，第二个账户有2000。
- en: 'There is another use case that you should take into account; let''s check the
    following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有另一个用例你应该考虑；让我们检查以下代码：
- en: '[PRE10]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The idea is that if `secured` is set to true, you shouldn't be able to withdraw
    any money.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是，如果`secured`设置为true，你不应该能够提取任何资金。
- en: If you run it and then check for the value of `@account`, you'll see that even
    after changing the value of `secured` to true a withdrawal occurs. Why is that?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行它，然后检查 `@account` 的值，你会发现即使将 `secured` 的值更改为 true 后仍然发生提款。为什么是这样？
- en: 'The reason is that transactions only check for values that you modify within
    a transaction or values that you read; here we are reading the secured value before
    the modification, so the transaction doesn''t fail. We can tell the transaction
    to be a little bit more careful by using the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是事务只检查你在事务中修改的值或你读取的值；这里我们在修改之前读取了受保护的价值，所以事务没有失败。我们可以通过以下代码告诉事务要更加小心一些：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here almost the same thing happened. What is the difference?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎发生了同样的事情。有什么区别？
- en: There is one subtle difference, the second transaction can't finish until the
    first transaction is done. If you look at it in detail, you will notice that you
    can't modify the secured value until after the other transaction runs.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个细微的区别，第二个事务不能完成，直到第一个事务完成。如果你仔细观察，你会注意到你只能在其他事务运行之后修改受保护的价值。
- en: This is similar to a lock; not the best idea but useful in some cases.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于一个锁；不是最好的主意，但在某些情况下很有用。
- en: Atoms
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子
- en: We have now seen how promises, futures, and transactions work in Clojure. We'll
    now see atoms.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了在 Clojure 中承诺、未来和事务是如何工作的。现在我们将看到原子。
- en: Even though STM is very useful and powerful you'll see that in practice it is
    not very commonly used.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管STM非常有用且强大，但在实践中它并不常用。
- en: Atoms are one of Clojure's workhorses, when it comes to concurrent programming.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 原子是 Clojure 在并发编程中的工作马，当涉及到修改单个值的事务时。
- en: You can think of atoms as transactions that modify one single value. You might
    be thinking, what good is that? Imagine you had lots of events that you want to
    store in a single vector. If you are used to Java, you probably know that using
    a `java.util.ArrayList` package is bound to have problems; since, you are almost
    surely going to lose data.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把原子想象成修改单个值的事务。你可能想知道，那有什么好处？想象一下，你有很多事件想要存储在一个单一的向量中。如果你习惯于 Java，你可能会知道使用
    `java.util.ArrayList` 包肯定会出问题；因为你几乎肯定会丢失数据。
- en: In that case, you probably want to use a class from the `java.util.concurrent`
    package, how can you guarantee that you'll have no data loss in Clojure?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，你可能想使用 `java.util.concurrent` 包中的一个类，你如何在 Clojure 中保证没有数据丢失？
- en: 'It''s easy, atoms come to the rescue! Let''s try this piece of code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，原子来救命！让我们尝试这段代码：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We are again using Pulsar and its lightweight threads. Here, we define an events
    atom and a `log-events` function.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用 Pulsar 和其轻量级线程。在这里，我们定义了一个事件原子和一个 `log-events` 函数。
- en: The `log-events` execute a `swap!` a given number of times.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`log-events` 执行给定次数的 `swap!`。'
- en: '`Swap!` is similar to the `alter` function it receives:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`Swap!` 与它接收到的 `alter` 函数类似：'
- en: The atom that it should modify
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该修改的原子
- en: The function that it applies to the atom
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用到原子的函数
- en: The extra arguments
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的参数
- en: 'In this case, it gives the atom the new value that comes from:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它给原子赋予来自新的值：
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We then spawn five fibers, each fiber adds 500 events to the events atom.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了五个纤维，每个纤维向事件原子添加 500 个事件。
- en: 'After running this, we can check for the number of events from each fiber like
    this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码后，我们可以这样检查每个纤维的事件数量：
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we have 500 elements from each fiber with no data loss and using
    Clojure's default data structures. There is no need to use special data structures
    for each use case, locks, or mutexes. This allows for greater concurrency.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们每个纤维有 500 个元素，没有数据丢失，并使用 Clojure 的默认数据结构。不需要为每个用例使用特殊的数据结构，锁或互斥锁。这允许有更高的并发性。
- en: When you modify an atom, you need to wait for the operation to be complete meaning
    it is synchronous.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当你修改一个原子时，你需要等待操作完成，这意味着它是同步的。
- en: Agents
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: What if you don't care about the result of some operation? You just need to
    fire something and then forget it. In that case agents are what you need.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在乎某些操作的结果呢？你只需要触发某件事，然后忘记它。在这种情况下，代理就是你所需要的。
- en: 'Agents also run in separate thread pools, there are two functions that you
    can use to fire an agent:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 代理也在单独的线程池中运行，有两个函数可以用来触发一个代理：
- en: '`send`: This executes your function in an implicit thread pool'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send`: 这将在隐式线程池中执行你的函数'
- en: '`send-off`: This tries to execute your function in a new thread but there''s
    a change, it will reuse another thread'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send-off`: 这尝试在一个新线程中执行你的函数，但有一个变化，它将重用另一个线程'
- en: Agents are the way to go if you want to cause side effects in a transaction;
    since, they will only be executed after the transaction has completed successfully.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在事务中引起副作用，那么agent是最佳选择；因为它们只有在事务成功完成后才会执行。
- en: 'They work in a very simple manner, here is an example usage:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 它们以非常简单的方式工作，以下是一个示例用法：
- en: '[PRE15]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you copy and paste the exact previous code you will see a `0` and then a
    `:done` message, if you check for the value of `@agt`, then you will see the value
    `10`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你复制粘贴确切的上一段代码，你会看到一个`0`然后是一个`:done`消息，如果你检查`@agt`的值，那么你会看到值`10`。
- en: Agents are a good way to execute a given task and modify some value in a different
    thread with simpler semantics than those of futures or manually modifying values
    in another thread.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Agent是执行给定任务并在不同线程中修改一些值的简单语义方式，比futures或手动在另一个线程中修改值更简单。
- en: Validators
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证器
- en: We have seen the primary concurrency primitives now, let's see some utilities
    that apply to all of them at once.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了主要的并发原语，现在让我们看看一些适用于所有这些的实用工具。
- en: We can define a validator that checks if the new value of some function is desirable
    or not; you can use them for refs, atoms, agents, and even vars.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个验证器来检查某个函数的新值是否可取；你可以为refs、atoms、agents甚至vars使用它们。
- en: The `validator` function must receive a single value and return true if the
    new value is valid or false otherwise.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`validator`函数必须接收一个值，如果新值有效则返回`true`，否则返回`false`。'
- en: 'Let''s create a simple `validator` that checks if the new value is lower than
    `5`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的`validator`来检查新值是否小于`5`：
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We get an exception. The reason is that the new value (`10`) is not valid.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到了异常。原因是新值（`10`）无效。
- en: 'You can add `4` without a problem:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以无问题地添加`4`：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Be careful with the validator and agents, since you will probably not know
    when an exception occurred:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证器和agent上要小心，因为你可能不知道何时发生异常：
- en: '[PRE18]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Watchers
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监视器
- en: 'Similar to validators, there are also watchers. Watchers are functions that
    are executed whenever Clojure''s identities get a new value. An important question
    is the thread in which watchers run. Watchers run in the same thread as the watched
    entity (if you add a watcher to an agent it will be run in the agent''s thread),
    it will be run before the agent code executes, so you should be careful and use
    the old-value new-value instead of reading the value with `deref`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与验证器类似，也存在监视器。监视器是当Clojure的身份获得新值时执行的函数。一个重要的问题是监视器运行的线程。监视器在与被监视实体相同的线程中运行（如果你向一个agent添加监视器，它将在agent的线程中运行），它将在agent代码执行之前运行，所以你应该小心，并使用旧值和新值而不是使用`deref`读取值：
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `add-watch` function receives:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`add-watch`函数接收：'
- en: The ref, atom, agent, or var that should be watched
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该被监视的ref、atom、agent或var
- en: A key that will be passed to the watcher function
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将被传递给监视器函数的键
- en: 'A function with four parameters: the key, the reference itself, the old value,
    and the new value'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有四个参数的函数：键、引用本身、旧值和新值
- en: 'After executing the previous code we get:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码后，我们得到：
- en: '[PRE20]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: core.async
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: core.async
- en: The `core.async` is yet another way of programming concurrently; it uses the
    idea of lightweight threads and channels to communicate between them.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`core.async`是另一种并发编程的方式；它使用轻量级线程和通道来在它们之间进行通信。'
- en: Why lightweight threads?
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么是轻量级线程？
- en: The lightweight threads are used in languages, such as go and Erlang. They excel
    in being able to run thousands of threads in a single process.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级线程用于像go和Erlang这样的语言中。它们擅长在单个进程中运行成千上万的线程。
- en: What is the difference between the lightweight threads and traditional threads?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级线程和传统线程之间有什么区别？
- en: The traditional threads need to reserve memory. This also takes some time. If
    you want to create a couple of thousand threads, you will be using a noticeable
    amount of memory for each thread; asking the kernel to do that also takes time.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的线程需要预留内存。这也需要一些时间。如果你想要创建几千个线程，你将为每个线程使用可观的内存；请求内核这样做也需要时间。
- en: What is the difference with lightweight threads? To have a couple of hundred
    lightweight threads, you only need to create a couple of threads. There is no
    need to reserve memory and lightweight threads are a mere software idea.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级线程与传统的线程有什么区别？要拥有几百个轻量级线程，你只需要创建几个线程。不需要预留内存，轻量级线程只是一个软件概念。
- en: This can be achieved with most languages and Clojure is adding first class support
    (without changing the language this is part of the Lisp power) with using `core.async`!
    Let's have a look at how it works.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过大多数语言实现，Clojure 通过使用 `core.async` 添加了一级支持（不改变语言本身，这是 Lisp 力量的部分），让我们看看它是如何工作的。
- en: 'There are two concepts that you need to keep in mind:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个概念你需要记住：
- en: '**Goblocks**: They are the lightweight threads.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Goblocks**：它们是轻量级的线程。'
- en: '**Channels**: Channels are a way to communicate between goblocks, you can think
    of them as queues. Goblocks can publish a message to the channel and other goblocks
    can take a message from them. Just as there are integration patterns for queues,
    there are integration patterns for channels and you will find concepts similar
    to broadcasting, filtering, and mapping.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通道**：通道是 goblocks 之间通信的一种方式，你可以把它们看作是队列。Goblocks 可以向通道发布消息，其他 goblocks 可以从它们那里获取消息。正如存在针对队列的集成模式一样，也存在针对通道的集成模式，你将发现类似广播、过滤和映射的概念。'
- en: Now, let's play a little with each of them so you can understand better how
    to use them for our program.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐一尝试它们，以便你能更好地理解如何在我们的程序中使用它们。
- en: Goblocks
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Goblocks
- en: You will find goblocks in the `clojure.core.async` namespace.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `clojure.core.async` 命名空间中找到 goblocks。
- en: 'Goblocks are extremely easy to use, you need the go macro and you will do something
    similar to this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Goblocks 非常容易使用，你需要 go 宏，你将做类似这样的事情：
- en: '[PRE21]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: They are similar to threads; you just need to remember that you can create goblocks
    freely. There can be thousands of running goblocks in a single JVM.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 它们类似于线程；你只需要记住你可以自由创建 goblocks。在单个 JVM 中可以有成千上万的运行 goblocks。
- en: Channels
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道
- en: You can actually use anything you like to communicate between goblocks, but
    it is recommended that you use channels.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上可以使用任何你喜欢的东西在 goblocks 之间进行通信，但建议你使用通道。
- en: 'Channels have two main operations: putting and getting. Let''s check how to
    do it:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通道有两个主要操作：放入和获取。让我们看看如何做：
- en: '[PRE22]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'That''s it!! It looks pretty simple, as you can see there are three main functions
    that we are using with channels:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！！看起来很简单，正如你所见，我们使用通道的主要有三个函数：
- en: '`chan`: This function creates a channel and the channels can store some messages
    in a buffer. If you want this functionality, you should just pass the size of
    the buffer to the `chan` function. If no size is specified, the channel can store
    only one message.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chan`：这个函数创建一个通道，通道可以在缓冲区中存储一些消息。如果你想使用这个功能，你应该只将缓冲区的大小传递给 `chan` 函数。如果没有指定大小，通道只能存储一条消息。'
- en: '`>!`: The put function must be used within a goblock; it receives a channel
    and the value you want to publish to it. This function blocks, if a channel''s
    buffer is already full. It will block until something is consumed from the channel.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>!`: put 函数必须在 goblock 内部使用；它接收一个通道以及你想要向其发布的值。如果通道的缓冲区已满，此函数将阻塞。它将阻塞，直到从通道中消耗掉一些内容。'
- en: '`<!`: This takes function; this function must be used within a goblock. It
    receives the channel you are taking from. It is blocking and if you haven''t published
    something in the channel it will park until there''s data available.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<!`: 这个取函数；这个函数必须在 goblock 内部使用。它接收你正在从中获取的通道。它是阻塞的，如果你没有在通道中发布任何内容，它将等待直到有数据可用。'
- en: 'There are lots of other functions that you can use with channels, for now let''s
    add two related functions that you will probably use soon:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用许多其他与通道一起使用的函数，现在让我们添加两个相关的函数，你可能会很快使用到：
- en: '`>!!`: The blocking put, works exactly the same as the `put` function; except
    it can be used from anywhere. Note that if a channel cannot take more data, this
    function will block the entire thread from where it runs.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>!!`: 阻塞 put 操作，与 `put` 函数的工作方式完全相同；只不过它可以从任何地方使用。注意，如果通道无法接收更多数据，此函数将阻塞从其运行的整个线程。'
- en: '`<!!`: The blocking works exactly the same as the `take` function, except you
    can use this from anywhere and not just from inside goblocks. Just keep in mind
    that this blocks the thread where it runs until there''s data available.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<!!`: 阻塞操作与 `take` 函数的工作方式完全相同，只不过你可以从任何地方使用，而不仅仅是 goblock 内部。只需记住，这将在有数据可用之前阻塞运行它的线程。'
- en: If you look into the `core.async` API docs ([http://clojure.github.io/core.async/](http://clojure.github.io/core.async/))
    you will find a fair amount of functions.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `core.async` API 文档([http://clojure.github.io/core.async/](http://clojure.github.io/core.async/))，你会找到相当多的函数。
- en: 'Some of them look similar to the functions that give you functionalities similar
    to queues, let''s take a look at the `broadcast` function:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些看起来类似于提供类似队列功能的函数，让我们看看`broadcast`函数：
- en: '[PRE23]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With this you can publish it to several channels at the same time, this is helpful
    if you want to subscribe multiple processes to a single source of events with
    a great amount of separation of concern.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，你可以同时发布到多个通道，如果你想要将多个进程订阅到单个事件源，并且有很大的关注点分离，这很有帮助。
- en: 'If you take a good look, you will also find familiar functions over there:
    `map`, `filter`, and `reduce`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细看，你也会在那里找到熟悉的函数：`map`、`filter`和`reduce`。
- en: Note
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Depending on the version of `core.async`, some of these functions might not
    be there anymore.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`core.async`的版本，其中一些函数可能已经不再存在。
- en: Why are these functions there? Those functions are meant to modify collections
    of data, right?
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这里有这些函数？这些函数是用来修改数据集合的，对吧？
- en: The reason is that there has been a good amount of effort towards using channels
    as higher-level abstractions.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于，已经投入了大量努力来使用通道作为高级抽象。
- en: The idea is to see channels as collections of events, if you think of them that
    way it's easy to see that you can create a new channel by mapping every element
    of an old channel or you can create a new channel by filtering away some elements.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是将通道视为事件集合，如果你这样想，就很容易看出你可以通过映射旧通道的每个元素来创建一个新的通道，或者你可以通过过滤掉一些元素来创建一个新的通道。
- en: In recent versions of Clojure, the abstraction has become even more noticeable
    with transducers.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure的最近版本中，抽象通过转换器变得更加明显。
- en: Transducers
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换器
- en: Transducers are a way to separate the computations from the input source. Simply,
    they are a way to apply a sequence of steps to a sequence or a channel.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器是一种将计算与输入源分离的方法。简单来说，它们是将一系列步骤应用于序列或通道的方法。
- en: 'Let''s look at an example of a sequence:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个序列的例子：
- en: '[PRE24]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `comp` feels similar to the threading macros, it composes functions and
    stores the steps of the computation.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`comp`感觉类似于线程宏，它组合函数并存储计算的步骤。'
- en: 'The interesting part is that we can use the same odd-counts transformation
    with a channel, such as:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分在于我们可以使用相同的奇数计数转换与通道，例如：
- en: '[PRE25]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We have checked the core Clojure mechanisms for concurrent programming, as
    you can see, they feel natural and they build on already existing paradigms, such
    as immutability. The most important idea is what an identity and value is; we
    now know that we can have the following values as identifiers:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经检查了核心Clojure并发编程机制，如您所见，它们感觉自然，并且建立在已经存在的范式之上，例如不可变性。最重要的想法是身份和价值是什么；我们现在知道我们可以有以下值作为标识符：
- en: Refs
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用
- en: Atoms
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子
- en: Agents
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: We can also get the snapshot of their value with the defer function or the `@`
    shortcut.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`defer`函数或`@`快捷键获取它们的值快照。
- en: If we want to use something a little more primitive, we can use promises or
    futures.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用更原始的东西，我们可以使用承诺或未来。
- en: We have also seen how to use threads, or Pulsar's fibers. Most of Clojure's
    primitives aren't specific to some concurrency mechanism, so we can use any parallel
    programming mechanism with any type of Clojure primitive.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何使用线程或Pulsar的纤维。Clojure的大多数原语并不特定于某种并发机制，因此我们可以使用任何并行编程机制与任何类型的Clojure原语一起使用。
