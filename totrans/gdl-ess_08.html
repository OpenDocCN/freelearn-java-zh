<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;8.&#xA0;Organizing Build Logic and Plugins"><div class="book" id="1FLS42-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. Organizing Build Logic and Plugins</h1></div></div></div><p class="calibre8">Plugins are one of the major building blocks of Gradle, which we have not discussed much until now. You have seen different standard plugins such as Java, Eclipse, Scala, and so on, which comes with a set of defined tasks. Developers just include the plugin, configure the required tasks, and leverage the functionalities. In this chapter, we will get an overview of what a plugin is, how you can group tasks to a plugin, how you can extract the plugin logic from a build file to <code class="literal">buildSrc</code>, and also how to create a standalone plugin.</p></div>

<div class="book" title="Chapter&#xA0;8.&#xA0;Organizing Build Logic and Plugins">
<div class="book" title="Extracting build logic to buildSrc"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec43" class="calibre1"/>Extracting build logic to buildSrc</h1></div></div></div><p class="calibre8">Plugins <a id="id252" class="calibre1"/>are nothing but the group of tasks with specific orders and default configurations, which are created to provide a certain functionality. For example, <code class="literal">java</code> plugin contains tasks that provide the functionality to build a Java project, <code class="literal">scala</code> plugin contains tasks to build Scala projects, and so on. Although Gradle provides many standard plugins, you can also find different third-party plugins to fulfil the project's need. There might always be a case when you are not able to find the desired functionality with the existing plugins and would like to create a new one for your custom requirement. We will see the different ways in which a developer can create a plugin and use it.</p><p class="calibre8">The very first plugin that a user can create is in the build file itself. The following is the sample code of a plugin, which a developer can write in <code class="literal">build.gradle</code> and use it:</p><div class="informalexample"><pre class="programlisting">apply plugin: CustomPlugin

class CustomPlugin implements Plugin&lt;Project&gt; {
  void apply(Project project) {
    project.task('task1') &lt;&lt; {
      println "Sample task1 in custom plugin"
      
    }
    project.task('task2') &lt;&lt; {
      println "Sample task2 in custom plugin"
      
    }    
  }
}
task2.dependsOn task1</pre></div><p class="calibre8">Here, we have<a id="id253" class="calibre1"/> created a plugin in the build file itself. This is the beauty of Gradle script. You can also write a class in the Gradle file. To create a custom plugin, you need to create a Groovy class that implements the <code class="literal">Plugin</code> interface. You can write a plugin even in Java or any other JVN language. Since Gradle build scripts are written in Groovy, we have used Groovy to write the plugin implementation. All the tasks that you want to implement, you need to define inside the <code class="literal">apply</code> method. We have defined two tasks, <code class="literal">task1</code> and <code class="literal">task2</code>. Also, we have defined the life cycle as a relationship between the two tasks. If a developer calls <code class="literal">task1</code>, only <code class="literal">task1</code> will be executed. If you execute <code class="literal">task2</code>, both <code class="literal">task1</code> and <code class="literal">task2</code> will get executed. Try to execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">&gt; gradle task2</strong></span>
<span class="strong"><strong class="calibre9">:task1</strong></span>
<span class="strong"><strong class="calibre9">Sample task1 in customer plugin</strong></span>
<span class="strong"><strong class="calibre9">:task2</strong></span>
<span class="strong"><strong class="calibre9">Sample task2 in custom plugin</strong></span>

<span class="strong"><strong class="calibre9">BUILD SUCCESSFUL</strong></span>
<span class="strong"><strong class="calibre9">Total time: 2.206 secs</strong></span>
</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip22" class="calibre1"/>Tip</h3><p class="calibre8">To use a plugin in the build file, you always need to use <code class="literal">apply plugin:&lt;plugin name/plugin</code> class (if a plugin is implemented in the same script or in the <code class="literal">buildSrc</code> directory).</p></div><p class="calibre8">This is one of the simple ways in which a developer can define a custom plugin. However, if we follow the design principles, it is not a good practice to mix the build logic and custom logic into the same file. It would be difficult to maintain the code and it might also increase the maintenance efforts. We will always recommend you to write plugin code separate from the build logic. To achieve this, Gradle provides two different ways as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Extract plugin code to <code class="literal">buildSrc</code></li><li class="listitem">Independent plugin</li></ul></div><p class="calibre8">To extract plugin code to <code class="literal">buildSrc</code>, Gradle recommends you to create a <code class="literal">buildSrc</code> directory inside the project directory and keep the plugin code there. The following is the folder hierarchy for the same:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">C:./Gradle/Chapter8/CustomPlugin1</strong></span>
<span class="strong"><strong class="calibre9">│   build.gradle</strong></span>
<span class="strong"><strong class="calibre9">│</strong></span>
<span class="strong"><strong class="calibre9">└───buildSrc</strong></span>
<span class="strong"><strong class="calibre9">    └───src</strong></span>
<span class="strong"><strong class="calibre9">        └───main</strong></span>
<span class="strong"><strong class="calibre9">            └───groovy</strong></span>
<span class="strong"><strong class="calibre9">                └───ch8</strong></span>
<span class="strong"><strong class="calibre9">                        CustomPlugin.groovy</strong></span>
</pre></div><p class="calibre8">Here, we have <a id="id254" class="calibre1"/>created a separate <code class="literal">buildSrc</code> directory; inside that, we kept the plugin code in the <code class="literal">CustomPlugin.groovy</code> file. Move the preceding Groovy class from the <code class="literal">build.gradle</code> file into this file. Include the package statement at the top. You also need to import the <code class="literal">org.gradle.api.*</code>. Your <code class="literal">CustomPlugin.groovy</code> file will look as follows:</p><div class="informalexample"><pre class="programlisting">package ch8
import org.gradle.api.*
class CustomPlugin implements Plugin&lt;Project&gt; {
// Plugin functionality here
}</pre></div><p class="calibre8">The <code class="literal">build.gradle</code> file contents will be as follows:</p><div class="informalexample"><pre class="programlisting">import ch8.CustomPlugin
apply plugin: CustomPlugin</pre></div><p class="calibre8">You just need to import the package and add the apply <code class="literal">plugin</code> statement. All the background work of compiling the class and including the class into classpath at the runtime, will be performed by Gradle. Now, try to execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">&gt; gradle task1</strong></span>
<span class="strong"><strong class="calibre9">:buildSrc:compileJava UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:buildSrc:compileGroovy UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:buildSrc:processResources UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:buildSrc:classes UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:buildSrc:jar UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:buildSrc:assemble UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:buildSrc:compileTestJava UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:buildSrc:compileTestGroovy UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:buildSrc:processTestResources UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:buildSrc:testClasses UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:buildSrc:test UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:buildSrc:check UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:buildSrc:build UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:task1</strong></span>
<span class="strong"><strong class="calibre9">Sample task1 in custom plugin</strong></span>

<span class="strong"><strong class="calibre9">BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong class="calibre9">Total time: 3.374 secs</strong></span>
</pre></div><p class="calibre8">Here, you<a id="id255" class="calibre1"/> can see that Gradle performed the compile and build task for your custom plugin code, and now you just need to execute the tasks that are part of your custom plugin. Gradle also allows you to configure your custom plugin in a build file. You can set a dependency between the tasks or add more functionality to the tasks in the build file itself, rather than updating your plugin code again and again. If you want to add some more features for <code class="literal">task1</code>, you can do it as follows:</p><div class="informalexample"><pre class="programlisting">task1.doLast {
println "Added more functionality to task1"
}
task2.dependsOn task1</pre></div><p class="calibre8">Now, if you try to execute <code class="literal">task1</code>, it will append the preceding statement.</p><p class="calibre8">In this way, you can separate the build logic from the <code class="literal">build.gradle</code> file to a separate class file under <code class="literal">buildSrc directory</code>. If you have a multi-project build, the plugin defined in the root project <code class="literal">buildSrc</code> can be reused by all the subprojects' build files. You do not need to define a separate plugin for each sub-projects. This process has still one limitation. It does not allow you to use this plugin for other projects. Since it is tightly coupled with the current project, you can use this plugin only with the same project or the sub-projects defined in the root project. To overcome this, you can plug out the plugin code into a standalone plugin and package it into a JAR file, which you can publish to a repository so that it can be reused by any projects. In the next section, we will discuss the standalone plugin.</p></div></div>
<div class="book" title="The first plugin" id="1GKCM1-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec44" class="calibre1"/>The first plugin</h1></div></div></div><p class="calibre8">To make<a id="id256" class="calibre1"/> the plugin reusable for all the other projects, Gradle allows you to separate the plugin code and package it in a JAR file. You can include this JAR file in any projects in which you want to reuse this functionality. You can create the standalone project in Java or Groovy. We will proceed with Groovy. You can use any editor (Eclipse, NetBeans, or Idea) to create a plugin. Since our main purpose is to show you how to create a standalone plugin, we will not go into the details of the editor. We will use a simple text editor. To proceed with the standalone plugin, separate the above <code class="literal">buildSrc</code> code into an independent directory. You can name it <code class="literal">CustomPlugin</code>. So, the directory structure will be as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">C:/Gradle/Chapter8/CustomPlugin.</strong></span>
<span class="strong"><strong class="calibre9">│   build.gradle</strong></span>
<span class="strong"><strong class="calibre9">│</strong></span>
<span class="strong"><strong class="calibre9">└───src</strong></span>
<span class="strong"><strong class="calibre9">    └───main</strong></span>
<span class="strong"><strong class="calibre9">        └───groovy</strong></span>
<span class="strong"><strong class="calibre9">            └───ch8</strong></span>
<span class="strong"><strong class="calibre9">                    CustomPlugin.groovy</strong></span>
</pre></div><p class="calibre8">You might be<a id="id257" class="calibre1"/> surprised to know why we are creating a <code class="literal">build.gradle</code> file here. With this <code class="literal">build.gradle</code>, we will package the plugin code into a jar file. Now, the question arises as to how you will include this plugin into other build files. You need a <span class="strong"><strong class="calibre9">plugin ID</strong></span>
<a id="id258" class="calibre1"/> for this plugin. To add a plugin ID to your plugin, you need to create a property file inside the <code class="literal">src/main/resources/META-INF/gradle-plugins</code> directory. The name of the properties file will be your plugin ID. Here, we will add the <code class="literal">customplugin.properties</code> file in the above directory. The content of this file will be as follows:</p><div class="informalexample"><pre class="programlisting">implementation-class=ch8.CustomPlugin

Your build file content would be.

apply plugin: 'groovy'
version = '1.0'
dependencies {
  compile gradleApi()
  compile localGroovy()
}</pre></div><p class="calibre8">To compile Groovy code, you need to include the preceding two statements in compile configurations. Since we are using a plain vanilla Groovy class here, we have not added any other dependency JARs. If your plugin code has a dependency on any other third-party JARs, you can include them in the dependency and configure the respective repositories.</p><p class="calibre8">Now, we will build the plugin as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">&gt; gradle clean build</strong></span>
<span class="strong"><strong class="calibre9">:clean</strong></span>
<span class="strong"><strong class="calibre9">:compileJava UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:compileGroovy</strong></span>
<span class="strong"><strong class="calibre9">:processResources</strong></span>
<span class="strong"><strong class="calibre9">:classes</strong></span>
<span class="strong"><strong class="calibre9">:jar</strong></span>
<span class="strong"><strong class="calibre9">:assemble</strong></span>
<span class="strong"><strong class="calibre9">:compileTestJava UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:compileTestGroovy UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:processTestResources UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:testClasses UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:test UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:check UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:build</strong></span>

<span class="strong"><strong class="calibre9">BUILD SUCCESSFUL</strong></span>
<span class="strong"><strong class="calibre9">Total time: 4.671 secs</strong></span>
</pre></div><p class="calibre8">You can find the JAR file inside <code class="literal">&lt;project&gt;/build/libs/CustomPlugin-1.0.jar</code>.</p><p class="calibre8">You can <a id="id259" class="calibre1"/>publish this plugin JAR to your organization's internal repositories so that any other projects can directly download it from there and use it. Now, we will create another project and will refer to this plugin JAR into that project.</p><p class="calibre8">Create a new directory, <code class="literal">SampleProject</code>, and add <code class="literal">build.gradle</code> to the project. Now, a question arises as to how will your <code class="literal">build.gradle</code> refer to <code class="literal">SamplePlugin</code>. For this, you need to mention the location of the <code class="literal">SamplePlugin</code> JAR in <code class="literal">buildscript closure</code> and add dependency to this JAR in the <code class="literal">dependencies</code> closure.</p><p class="calibre8">The content of your <code class="literal">build.gradle</code> will be as follows:</p><div class="informalexample"><pre class="programlisting">buildscript {
repositories {
  flatDir {dirs "../CustomPlugin/build/libs/"}
}
dependencies {
classpath group: 'ch8', name: 'CustomPlugin',version: '1.0'
}
}
apply plugin: 'customplugin'</pre></div><p class="calibre8">Here, we are using a <code class="literal">flat file repository</code>, thus, referring to the custom plugin JAR using the <code class="literal">flatDir</code> configuration. We recommend you to use the organization's local repository; thus, it can be centrally accessed by any of the organization's projects. In the dependencies closure, we are referring to the <code class="literal">CustomPlugin</code> JAR file. This is the prerequisite to use any plugin. Finally, we are adding the <code class="literal">apply plugin</code> statement and mentioning the plugin name in single quotes.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip23" class="calibre1"/>Tip</h3><p class="calibre8">The plugin name is the name of the property file you create in the <code class="literal">src/main/resources/META-INF/gradle-plugins</code> directory.</p></div><p class="calibre8">Now, you can execute the build file using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">&gt; gradle task1</strong></span>

<span class="strong"><strong class="calibre9">:task1</strong></span>
<span class="strong"><strong class="calibre9">Sample task1 in custom plugin</strong></span>

<span class="strong"><strong class="calibre9">BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong class="calibre9">Total time: 2.497 secs</strong></span>
</pre></div></div>
<div class="book" title="Configuring plugins" id="1HIT81-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec45" class="calibre1"/>Configuring plugins</h1></div></div></div><p class="calibre8">So far, we <a id="id260" class="calibre1"/>have seen how to create a standalone custom plugin and include it in another project build file. Gradle also allows you to configure plugin properties and customize them as per your project's need. You have already learned how you can customize the source code location and test code location in a <code class="literal">java</code> plugin. We will see an example of how you can replicate the same behavior in your custom plugin. To define plugin properties, you need to create one additional <code class="literal">extension</code> class and register the class into your <code class="literal">plugin</code> class. Let's say we want to add the <code class="literal">location</code> property to the plugin. Create the <code class="literal">CustomPluginExtension.groovy</code> class as follows:</p><div class="informalexample"><pre class="programlisting">package ch8
class CustomPluginExtension {
def location = "/plugin/defaultlocation"
}</pre></div><p class="calibre8">Now, register this class to your <code class="literal">plugin</code> class:</p><div class="informalexample"><pre class="programlisting">class CustomPlugin implements Plugin&lt;Project&gt; {
  void apply(Project project) {
    def extension = project.extensions.create("customExt",CustomPluginExtension)

project.task('task1') &lt;&lt; {
      println "Sample task1 in custom plugin"
      println "location is "+project.customExt.location
  }
}
}</pre></div><p class="calibre8">Now, build the plugin again so that your changes are part of the latest plugin JAR file and then try to execute <code class="literal">build.gradle</code> of <code class="literal">SampleProject</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">&gt; gradle task1</strong></span>
<span class="strong"><strong class="calibre9">:task1</strong></span>
<span class="strong"><strong class="calibre9">Sample task1 in custom plugin</strong></span>
<span class="strong"><strong class="calibre9">location is /plugin/defaultlocation</strong></span>

<span class="strong"><strong class="calibre9">BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong class="calibre9">Total time: 2.79 secs</strong></span>
</pre></div><p class="calibre8">Here, you can <a id="id261" class="calibre1"/>see the default value on the command line output. If you want to change this field to some other value, add <code class="literal">customExt closure</code> to your <code class="literal">SampleProject</code> <code class="literal">build.gradle</code> file with a different value configured for the location:</p><div class="informalexample"><pre class="programlisting">buildscript {
repositories {
  flatDir {dirs "../CustomPlugin/build/libs/"}
}
dependencies {
  classpath group: 'ch8', name: 'CustomPlugin',version: '1.0'
}
}
apply plugin: 'customplugin'

<span class="strong"><strong class="calibre9">customExt {</strong></span>
<span class="strong"><strong class="calibre9">  location="/plugin/newlocation"</strong></span>
<span class="strong"><strong class="calibre9">}</strong></span>
</pre></div><p class="calibre8">Now try to execute <code class="literal">task1</code> again:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">&gt; gradle task1</strong></span>
<span class="strong"><strong class="calibre9">:task1</strong></span>
<span class="strong"><strong class="calibre9">Sample task1 in custom plugin</strong></span>
<span class="strong"><strong class="calibre9">location is /plugin/newlocation</strong></span>

<span class="strong"><strong class="calibre9">BUILD SUCCESSFUL</strong></span>
<span class="strong"><strong class="calibre9">Total time: 5.794 secs</strong></span>
</pre></div><p class="calibre8">Here, you can observe the update value for the location attribute.</p></div>
<div class="book" title="Summary" id="1IHDQ1-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec46" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we discussed one of Gradle's main building blocks, plugins. A plugin helps to organize and modularize the functionality and also helps to package a set of related tasks and configurations. We also discussed the different ways of creating custom plugins, from writing the plugin code in the build file itself to creating a standalone plugin JAR file and reusing it in different projects. In the last section, we also covered how you can configure the plugin's existing properties and customize them as per your project's requirement.</p><p class="calibre8">Before concluding this book in the next chapter, we will be discussing how you can build Groovy and Scala projects with the help of Gradle. Also, as this is a mobile age, where all the traditional software or web applications are now moving to apps, we will also be discussing building Android projects.</p></div></body></html>