<html><head></head><body>
<div class="book" title="Chapter&#xA0;11.&#xA0;Reactive Programming" id="20R681-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11" class="calibre1"/>Chapter 11. Reactive Programming</h1></div></div></div><p class="calibre8">This chapter is a little detour to reactive programming. It lets us handle the concurrency requirements of an application in some cases. It provides an abstraction to handle concurrency. Even though the concepts are old, it has gained interest in recent years due to the beginning of large inflow of data. In modern times, billions of devices generate data every day. Tapping into this data is essential for the growth of business; in some cases, processing the data to statistically analyze it or feeding it to some machine learning algorithm may be the entire business in itself. This makes it essential to support the processing of this large in-flow of data, provide a quick response, and be resilient to failures. Of course, one can do these things even using a traditional or imperative programming paradigm, just as one can, in theory, build any application using an assembly language. However, this makes the application extremely complex to maintain and impossible to modify according to business needs. In this chapter, we will discuss the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Basic idea of reactive programming</li><li class="listitem">Building an example reactive framework</li><li class="listitem">Building example programs using our framework</li></ul></div></div>

<div class="book" title="Chapter&#xA0;11.&#xA0;Reactive Programming" id="20R681-eeeded97b5e248ac807bb1bec4d7c800">
<div class="book" title="What is reactive programming?"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch11lvl1sec61" class="calibre1"/>What is reactive programming?</h1></div></div></div><p class="calibre8">Suppose we <a id="id568" class="calibre1"/>have a web server that lets us query some data or save it. This web server serves multiple requests at the same time, and each request is a short task that involves some computation. What is the usual way of achieving this? Well, the naive way would be to spawn a new thread for each request. But one can easily realize that this leads to an explosion in the number of threads in the application. Plus, the creation and deletion of threads are heavyweight activities; they slow down the entire application.</p><p class="calibre8">Next, you can use a thread pool so the same threads can be used over and over to avoid the overhead of creation and deletion of threads. However, if you want to serve thousands of requests at the same time, this will require a thread pool with thousands of threads. Thread scheduling in an operating system is complex and involves a lot of logic, including priority and so on. Operating systems do not expect threads to just run short bursts of computation; they are not optimized that way. Therefore, the solution is to use the same thread for multiple simultaneous requests. This can, in general, be done if we stop blocking for IO and use the same thread for another task when one task is waiting for I/O. Managing these things, however, is extremely complicated. Hence, we would need a framework to carry out <a id="id569" class="calibre1"/>these activities for us. Such a framework can be called a reactive framework.</p><p class="calibre8">Reactive programming takes care of the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Scalability</strong></span>: This property is <a id="id570" class="calibre1"/>the capability of the application to cater to proportional number of requests as the number of available resources increases. If one processor serves 500 requests per second, two processors should do 1,000.</li><li class="listitem"><span class="strong"><strong class="calibre2">Responsiveness</strong></span>: We want the application to be responsive; for example, it should show a status when it is computing some result or fetching it from some other place.</li><li class="listitem"><span class="strong"><strong class="calibre2">Resilience</strong></span>: Since we use the same thread for multiple tasks, handling errors is more complicated than usual. How do we let the user know of an error? So instead of propagating the exceptions back down the call stack, we move forward and explicitly tackle the error situations.</li></ul></div><p class="calibre8">There are different techniques for using reactive programming; it depends on the actual problem we are trying to solve. We will not discuss all of them but will focus on the commonly used ones.</p></div></div>

<div class="book" title="Producer-consumer model"><div class="book" id="21PMQ2-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec62" class="calibre1"/>Producer-consumer model</h1></div></div></div><p class="calibre8">A producer-consumer <a id="id571" class="calibre1"/>model is a design that divides processing into small components that send messages to other components. One produces a message and the other consumes and acts on it. It provides an abstraction to easily implement an application optimized to utilize all the resources. A producer-consumer model starts with a queue of messages. Producers publish messages in this queue and consumers receive them. This queue is different from the queues we have studied so far in a few ways. We want this queue to be thread-safe, which is required for the queue to work correctly in a multithreaded environment. We do not need to worry about the exact order of the messages being dequeued. After all, the order of messages does not matter when they are being received by different threads. In these conditions, we optimize the delivery of the messages. Before implementing this queue, let's discuss a few thread synchronization techniques beyond what we have learned so far using the synchronized keyword. These techniques are required for more optimal usage of resources while <a id="id572" class="calibre1"/>maintaining the correctness of the program.</p></div>

<div class="book" title="Producer-consumer model">
<div class="book" title="Semaphore"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec89" class="calibre1"/>Semaphore</h2></div></div></div><p class="calibre8">A semaphore is a special <a id="id573" class="calibre1"/>variable that lets us limit the number of <a id="id574" class="calibre1"/>threads that can use a particular resource. The following code shows an example of a semaphore that gives us a thread-safe counter:</p><div class="informalexample"><pre class="programlisting">public class SemaphoreExample {
    volatile int threadSafeInt = 0;
    Semaphore semaphore = new Semaphore(1);
    public int incremementAndGet() throws InterruptedException{
        semaphore.acquire();
        int previousValue = threadSafeInt++;
        semaphore.release();
        return previousValue;
    }
}</pre></div><p class="calibre8">Here, the semaphore has been initialized to <code class="email">1</code>, which means it will allow only one thread to acquire it. No other thread can acquire it until it is released. Unlike synchronization, there is no requirement here that the same thread has to call the release method that had acquired it, which makes it particularly flexible.</p><p class="calibre8">A call to the <code class="email">acquire</code> method of a semaphore will be blocked until it successfully acquires it. This means that the calling thread will be taken off the thread scheduler and put aside in such a way that the operating system's thread scheduler will not be able to see it. Once the semaphore is ready to be acquired, this thread will be put back in place for the thread scheduler to see it.</p></div></div>

<div class="book" title="Producer-consumer model">
<div class="book" title="Compare and set"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec90" class="calibre1"/>Compare and set</h2></div></div></div><p class="calibre8">Compare and set <a id="id575" class="calibre1"/>is an atomic operation that lets you update the value of a variable if and only if the existing value matches a specific value. This enables us to update a variable based on its previous value. The CAS operation returns a <a id="id576" class="calibre1"/>Boolean. If the comparison is a match, which means the set operation is successful, it returns <code class="email">true</code>; otherwise, it returns <code class="email">false</code>. The idea is to keep trying until this set operation is successful. The following diagram shows the basic strategy:</p><div class="mediaobject"><img src="../images/00077.jpeg" alt="Compare and set" class="calibre9"/><div class="caption"><p class="calibre15">Figure 1: Atomic update using the compare and set operation</p></div></div><p class="calibre10"> </p><p class="calibre8">In <span class="strong"><em class="calibre12">Figure 1</em></span>, we are trying to increment the value of the shared variable <span class="strong"><strong class="calibre2">var</strong></span>. The operation requires us to <a id="id577" class="calibre1"/>read the value in a thread-specific <a id="id578" class="calibre1"/>temporary location, then increment the temporary value and reassign it to the shared variable. However, this operation can cause problems if there are multiple threads trying to perform the update simultaneously. It can happen that both the threads read the value simultaneously in order to get the same temp value. Both these threads can update the shared variable with the incremented value. This will increment the value only once, but it should have actually caused two increments. To avoid this, we check whether the value of <span class="strong"><strong class="calibre2">var</strong></span> is still the same and update only when it is so; otherwise, we read the value of <span class="strong"><strong class="calibre2">var</strong></span> <a id="id579" class="calibre1"/>again and repeat the process. Since this compare and set operation is atomic, it guarantees that no increments <a id="id580" class="calibre1"/>will be lost. The following is the Java code that does the exact same thing:</p><div class="informalexample"><pre class="programlisting">public class ThreadSafeCounter {
    AtomicInteger counter;
    public int incrementAndGet(){
        while (true){
            int value = counter.get();
            if(counter.compareAndSet(value, value+1)){
                return value;
            }
        }
    }
}</pre></div><p class="calibre8">To use any atomic operation, we need to use classes from the <code class="email">java.util.concurrent.atomic</code> package. <code class="email">AtomicInteger</code> is a class that encapsulates an integer and enables the <code class="email">compareAndSet</code> operation on it. There are other utility methods as well. In particular, it has methods to perform atomic increments and decrements, just like the one we <a id="id581" class="calibre1"/>have implemented here.</p></div></div>

<div class="book" title="Producer-consumer model">
<div class="book" title="Volatile field"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec91" class="calibre1"/>Volatile field</h2></div></div></div><p class="calibre8">Suppose we have a field <a id="id582" class="calibre1"/>that is being written to and read from multiple threads. If all the threads run on the same single CPU, the writes can simply happen on the CPU cache; they need not be synced to the main memory often. This would not be a problem as the value could also be read from the same cache. However, multiple CPUs can have their own caches, and in such a case, a write to a cache from one CPU will not be visible from another thread running on a different CPU. Most programs accept this and work accordingly. Java, for example, maintains a separate copy of a shared variable for each thread, which is occasionally synced. If we, however, want to mandate that the writes from one thread should be visible from another thread, we need to declare the field volatile. All fields involved in atomic operations are declared volatile.</p></div></div>

<div class="book" title="Producer-consumer model">
<div class="book" title="Thread-safe blocking queue"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch11lvl2sec92" class="calibre1"/>Thread-safe blocking queue</h2></div></div></div><p class="calibre8">Now we are <a id="id583" class="calibre1"/>ready to implement our thread-safe blocking queue. Thread-safe means that multiple threads can share the same queue; blocking means that if a thread tries to dequeue an element and the queue is <a id="id584" class="calibre1"/>currently empty, the call to dequeue will be blocked until some other thread enqueues an element. Similarly, if a thread tries to enqueue a new element and the queue is full, the call to the queue will be blocked until another thread dequeues an element and frees some space.</p><p class="calibre8">Our queue will store elements in a fixed length array and maintain two counters that would store the next index for queuing and dequeuing. Two semaphores block threads when the queue is either empty or full. Along with this, each array position is provided with two semaphores that ensure that enqueuing and dequeuing operations do not overwrite or repeat any elements. It does this by ensuring that once a new element is enqueued in a particular position, it is not overwriten before it is dequeued. Similarly, once a particular array index is dequeued, it is never dequeued again before another enqueue stores another element in it:</p><div class="informalexample"><pre class="programlisting">public class ThreadSafeFixedLengthBlockingQueue&lt;E&gt; {</pre></div><p class="calibre8">The <code class="email">underflowSemaphore</code> ensures that dequeues are blocked when the queue is empty, and <code class="email">overflowSemaphore</code> ensures that enqueues are blocked when the queue is full:</p><div class="informalexample"><pre class="programlisting">    Semaphore underflowSemaphore;
    Semaphore overflowSemaphore;

    AtomicInteger nextEnqueueIndex;
    AtomicInteger nextDequeueIndex;</pre></div><p class="calibre8">The array store is the space that holds the elements:</p><div class="informalexample"><pre class="programlisting">    E[] store;</pre></div><p class="calibre8">Both <code class="email">enqueueLocks</code> and <code class="email">dequeueLocks</code> are individual position-based locks that allow only a dequeue after an enqueue and vice versa:</p><div class="informalexample"><pre class="programlisting">    Semaphore [] enqueueLocks;
    Semaphore [] dequeueLocks;

    int length;</pre></div><p class="calibre8">The <code class="email">alive</code> flag can be used by the dequeuing threads to know when they can stop running, and no more elements would be expected. This flag needs to be set by the enqueuing threads:</p><div class="informalexample"><pre class="programlisting">    boolean alive = true;</pre></div><p class="calibre8">All initializations are pretty much self-evident:</p><div class="informalexample"><pre class="programlisting">    public ThreadSafeFixedLengthBlockingQueue(int length){
        this.length = length;
        store = (E[]) new Object[length];
        nextEnqueueIndex = new AtomicInteger();
        nextDequeueIndex = new AtomicInteger();
        underflowSemaphore = new Semaphore(length);
        overflowSemaphore = new Semaphore(length);
        underflowSemaphore.acquireUninterruptibly(length);
        enqueueLocks = new Semaphore[length];
        dequeueLocks = new Semaphore[length];
        for(int i=0;i&lt;length;i++){
            enqueueLocks[i] = new Semaphore(1);
            dequeueLocks[i] = new Semaphore(1);
            dequeueLocks[i].acquireUninterruptibly();
        }
    }</pre></div><p class="calibre8">The enqueue <a id="id585" class="calibre1"/>operation first makes <a id="id586" class="calibre1"/>sure that the queue is not full by acquiring <code class="email">overflowSemaphore</code>:</p><div class="informalexample"><pre class="programlisting">    public void enqueue(E value) throws InterruptedException {
        overflowSemaphore.acquire();</pre></div><p class="calibre8">The <code class="email">nextEnqueueIndex</code> is then incremented and the previous value is returned, which is then used to compute the index in the array where the element would be stored. The seemingly complicated expression ensures that the index rolls over properly even after the <code class="email">nextEnqueueIndex</code> integer rolls over, provided the length of the queue is an integer power of 2:</p><div class="informalexample"><pre class="programlisting">        int index = (length + nextEnqueueIndex.getAndIncrement() % length) 
          % length;</pre></div><p class="calibre8">Once the index is selected, we must acquire an enqueue lock on the position, store the value, and then release the dequeue lock to mark this position as ready for dequeuing. At the end, we release one count on <code class="email">underflowSemaphore</code> to mark the fact that there is one more element in the queue to be dequeued:</p><div class="informalexample"><pre class="programlisting">        enqueueLocks[index].acquire();
        store[index] = value;
        dequeueLocks[index].release();
        underflowSemaphore.release();
    }</pre></div><p class="calibre8">The dequeue operation is very similar to the enqueue operation, just the role of the semaphores are reversed. There is slightly more complicated code before the actual operation starts. This is to enable the dequeuing threads to quit when no more elements are available:</p><div class="informalexample"><pre class="programlisting">    public E dequeue() throws InterruptedException {</pre></div><p class="calibre8">Instead of <a id="id587" class="calibre1"/>directly acquiring <code class="email">underflowSemaphore</code>, we use <code class="email">tryAcquire</code>, which will wake up the thread after 1 second if there are no elements are available to be dequeued. This gives us a chance to check the value of the <code class="email">alive</code> Boolean flag and quit the dequeue operation in case it is no longer alive. If the queue is no longer alive, we interrupt the current thread and exit. Otherwise, we <a id="id588" class="calibre1"/>compute the index and dequeue the element to the enqueue operation in a similar manner:</p><div class="informalexample"><pre class="programlisting">        while (alive &amp;&amp; !underflowSemaphore.tryAcquire(1, TimeUnit.SECONDS));
        if(!alive){
            Thread.currentThread().interrupt();
        }
        int index = (length + nextDequeueIndex.getAndIncrement() % length) 
                 % length;
        dequeueLocks[index].acquire();
        E value = store[index];
        enqueueLocks[index].release();
        overflowSemaphore.release();
        return value;
    }</pre></div><p class="calibre8">This is a utility method to return the current number of elements in the queue. This is useful for knowing when to kill the queue (set the <code class="email">alive</code> flag to <code class="email">false</code>) in a producer-consumer setup:</p><div class="informalexample"><pre class="programlisting">    public int currentElementCount(){
        return underflowSemaphore.availablePermits();
    }

    public void killDequeuers(){
        alive = false;
    }

}</pre></div></div></div>

<div class="book" title="Producer-consumer model">
<div class="book" title="Producer-consumer implementation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch11lvl2sec93" class="calibre1"/>Producer-consumer implementation</h2></div></div></div><p class="calibre8">We can now <a id="id589" class="calibre1"/>implement a producer-consumer setup using the queue we have created. In simple words, the producer-consumer queue is a queue of events that the producers produce and the consumers consume. There are three kinds of events. The <code class="email">INVOCATION</code> type refers to the regular events that propagate processing. The <code class="email">ERROR</code> type event is raised when an exception needs to be propagated. The <code class="email">COMPLETION</code> event is produced when it is required that the dequeue threads need to be terminated and the queue needs to be closed. The <code class="email">ProcerConsumer</code> queue takes <code class="email">Consumer</code> as input:</p><div class="informalexample"><pre class="programlisting">public interface Consumer&lt;E&gt; {
    void onMessage(E message);
    default void onError(Exception error){
        error.printStackTrace();
    }
    default void onComplete(){

    }
}

public class ProducerConsumerQueue&lt;E&gt; {
    enum EventType{
        INVOCATION, ERROR, COMPLETION
    }</pre></div><p class="calibre8">The <code class="email">Event</code> class represents single events. Depending on the type, it can have a value or exception:</p><div class="informalexample"><pre class="programlisting">    class Event{
        E value;
        Exception error;
        EventType eventType;
    }
    ThreadSafeFixedLengthBlockingQueue&lt;Event&gt; queue;
    boolean alive = true;
    Thread [] threads;</pre></div><p class="calibre8">The constructor of <code class="email">ProducerConsuerQueue</code> creates consumer threads. It also takes consumer code as input. The consumer must implement the <code class="email">Consumer</code> interface:</p><div class="informalexample"><pre class="programlisting">    public ProducerConsumerQueue(int bufferSize, int threadCount, 
                 Consumer&lt;E&gt; consumer){
        queue = new ThreadSafeFixedLengthBlockingQueue&lt;&gt;(bufferSize);
        threads = new Thread[threadCount];</pre></div><p class="calibre8">The consumer thread runs code that dequeues events and calls the methods on <code class="email">consumerCode</code> as per the event type in the loop. The loop ends when the termination event is received and no more events are there in the queue to be processed:</p><div class="informalexample"><pre class="programlisting">        Runnable consumerCode = ()-&gt;{
            try{
                while(alive || queue.currentElementCount()&gt;0){
                    Event e = queue.dequeue();
                    switch (e.eventType) {
                        case INVOCATION:
                            consumer.onMessage(e.value);
                            break;
                        case ERROR:
                            consumer.onError(e.error);
                            break;
                        case COMPLETION:
                            alive = false;
                            consumer.onComplete();
                    }
                }

            } catch (InterruptedException e) {

            } finally{

            }
        };</pre></div><p class="calibre8">Consumer <a id="id590" class="calibre1"/>threads are spawned:</p><div class="informalexample"><pre class="programlisting">        for(int i=0;i&lt;threadCount;i++) {
            threads[i] = new Thread(consumerCode);
            threads[i].start();
        }
    }</pre></div><p class="calibre8">The <code class="email">produce</code> method is invoked from a producer thread. Notice that the queue does not manage producer threads; they need to be managed separately:</p><div class="informalexample"><pre class="programlisting">    public void produce(E value) throws InterruptedException {
        Event event = new Event();
        event.value = value;
        event.eventType = EventType.INVOCATION;
        queue.enqueue(event);
    }</pre></div><p class="calibre8">Once a producer thread marks the stream of events to be completed, no more new events could be generated and the dequeuing threads will be terminated after they process all the events:</p><div class="informalexample"><pre class="programlisting">    public void markCompleted() throws InterruptedException {
        Event event = new Event();
        event.eventType = EventType.COMPLETION;
        queue.enqueue(event);
    }</pre></div><p class="calibre8">This is to propagate <a id="id591" class="calibre1"/>an exception:</p><div class="informalexample"><pre class="programlisting">    public void sendError(Exception ex) throws InterruptedException {
        Event event = new Event();
        event.error = ex;
        event.eventType = EventType.ERROR;
        queue.enqueue(event);
    }</pre></div><p class="calibre8">If we need to wait for all the dequeuing threads to terminate, we use this:</p><div class="informalexample"><pre class="programlisting">    public void joinThreads() throws InterruptedException {
        for(Thread t: threads){
            t.join();
        }
    }
}</pre></div><p class="calibre8">To see how to use this producer-consumer queue to actually solve a problem, we will consider a dummy problem. We will work on a file—<code class="email">com-orkut.ungraph.txt</code>—that is open to public and contains all the friendships between users in <span class="strong"><strong class="calibre2">Orkut</strong></span>, which was a social networking site in the past. The file can be downloaded from <a class="calibre1" href="https://snap.stanford.edu/data/bigdata/communities/com-orkut.ungraph.txt.gz">https://snap.stanford.edu/data/bigdata/communities/com-orkut.ungraph.txt.gz</a>. To protect privacy, all the users are simply referenced by some arbitrary ID and the mapping with the actual users is not shared. We will also use another file called <code class="email">ulist</code> that would contain the list of user IDs we are interested in. Our task is to find the number of friends that each user in the second file has. The following commands show how the two files look:</p><div class="informalexample"><pre class="programlisting">$ head com-orkut.ungraph.txt 
1	2 
1	3 
1	4 
1	5 
1	6 
1	7 
1	8 
1	9 
1	10 
1	11 
$ head ulist 
2508972 
1081826 
2022585 
141678 
709419 
877187 
1592426 
1013109 
1490560 
623595 </pre></div><p class="calibre8">Each line in <code class="email">com-orkut.ungraph.txt</code> has two IDs that are separated by a whitespace. The meaning is that there is <a id="id592" class="calibre1"/>friendship between these two users. It is given that each friendship is mentioned only once in the file and is undirected. Note that this means each line should increase the friend count for both the IDs. Each line in <code class="email">ulist</code> has a single ID. All IDs are unique, and we must find the friend count of each of these IDs. Note that some of these have no friends and thus are not mentioned in <code class="email">com-orkut.ungraph.txt</code>.</p><p class="calibre8">We will first create a utility class that will let us read integer IDs from the files. The purpose of this class is to read integer values from any text file so that not too many objects are created in the process. This is just to reduce garbage collection to some extent. In this case, we used file-channel-based logic that uses <code class="email">ByteBuffer</code> as a buffer: </p><div class="informalexample"><pre class="programlisting">public class FileReader {
    ByteBuffer buf= ByteBuffer.allocate(65536);
    FileChannel channel;</pre></div><p class="calibre8">The <code class="email">readCount</code> variable keeps track of how many characters are left in the buffer:</p><div class="informalexample"><pre class="programlisting">    int readCount = 0;

    public FileReader(String filename) throws FileNotFoundException {
        channel = new FileInputStream(filename).getChannel();
        buf.clear();
    }</pre></div><p class="calibre8">To read an <code class="email">int</code>, keep reading the bytes in a loop until you hit a byte that is not a digit. In the meantime, keep computing the integer that the string of characters represents:</p><div class="informalexample"><pre class="programlisting">    public int readIntFromText() throws IOException {
        int value = 0;
        while(true){</pre></div><p class="calibre8">First check whether the buffer is empty; if yes, refill it by reading from the file:</p><div class="informalexample"><pre class="programlisting">            if(readCount&lt;=0){
                buf.clear();
                readCount = channel.read(buf);</pre></div><p class="calibre8">If no more bytes are available in the file, don't care to flip the buffer:</p><div class="informalexample"><pre class="programlisting">                if(readCount&lt;0){
                    break;
                }
                buf.flip();
            }</pre></div><p class="calibre8">We read a byte and <a id="id593" class="calibre1"/>decrement <code class="email">readCount</code> because now the buffer has one less byte:</p><div class="informalexample"><pre class="programlisting">            byte nextChar = buf.get();
            readCount--;</pre></div><p class="calibre8">If the character is a digit, keep computing the integer; otherwise, break the loop and return the calculated integer value:</p><div class="informalexample"><pre class="programlisting">            if(nextChar&gt;='0' &amp;&amp; nextChar&lt;='9') {
                value = value * 10 + (nextChar - '0');
            }else{
                break;
            }

        }
        return value;
    }
}</pre></div><p class="calibre8">With the help of this, we will create a program to create a file output, which will contain the user IDs provided in <code class="email">ulist</code> along with the corresponding friend count. The idea is that reading the file is made asynchronous by computing the friend count. Since the counting involves a binary search, we want two threads doing it instead of one:</p><div class="informalexample"><pre class="programlisting">public class FriendCountProblem {
    private static final String USER_LIST_FILE = "ulist";
    private static final String EDGES_PATH = "com-orkut.ungraph.txt";
    private static final String OUTPUT_FILE_PATH = "output";

    public static void main(String [] args)
      throws Exception {
        FileReader userListReader = new FileReader(USER_LIST_FILE);</pre></div><p class="calibre8">First, we simply count the number of lines present in <code class="email">ulist</code>. This will let us create the correct size array:</p><div class="informalexample"><pre class="programlisting">        int count = 0;

        while(true){

            int lineValue = userListReader.readIntFromText();
            if(lineValue==0){
                break;
            }
            count++;
        }</pre></div><p class="calibre8">We create two arrays: one <a id="id594" class="calibre1"/>containing the keys and the other containing the friend count of each of the keys. The counts are stored in <code class="email">AtomicInteger</code> objects so that they can be incremented from multiple threads:</p><div class="informalexample"><pre class="programlisting">        Integer [] keys = new Integer[count];
        AtomicInteger [] values = new AtomicInteger[count];</pre></div><p class="calibre8">We read <code class="email">userIDs</code> from <code class="email">ulist</code> in an array:</p><div class="informalexample"><pre class="programlisting">        userListReader = new FileReader(USER_LIST_FILE);


        int index = 0;

        while(true){

            int uid = userListReader.readIntFromText();
            if(uid==0){
                break;
            }
            keys[index] = uid;
            values[index] =  new AtomicInteger(0);
            index++;

        }</pre></div><p class="calibre8">Now we sort the array of <code class="email">userID</code> so that we can perform binary search on it:</p><div class="informalexample"><pre class="programlisting">        ArraySorter.quicksort(keys,(a,b)-&gt;a-b);</pre></div><p class="calibre8">The job of our consumers is to search for each user encountered in <code class="email">com-orkut.ungraph.txt</code> and increment the corresponding count in the array values. Note that creating <code class="email">ProducerConsumerQueue</code> does not start any processing; only consumer threads are created <a id="id595" class="calibre1"/>through this. Processing will start only when we produce events, which we will do after reading from <code class="email">com-orkut.ungraph.txt</code>:</p><div class="informalexample"><pre class="programlisting">        ProducerConsumerQueue&lt;Integer&gt; queue 
                = new ProducerConsumerQueue&lt;&gt;(4092, 2, (v)-&gt;{
            int pos  = ArraySearcher.binarySearch(keys,v);
            if(pos&lt;0){
                return;
            }
            values[pos].incrementAndGet();
        });</pre></div><p class="calibre8">We use the main thread for producing the events. We use the same <code class="email">FileReader</code> class for reading each user ID separately. This is because both the users in a line in <code class="email">com-orkut.ungraph.txt</code> have a friend (which is the other one in the same line) for each line in the file. So we simply read the users and post them as events so that the consumers can process them:</p><div class="informalexample"><pre class="programlisting">        FileReader edgeListFileReader = new FileReader(EDGES_PATH);
        while(true){
            int val = edgeListFileReader.readIntFromText();
            if(val == 0){
                break;
            }
            queue.produce(val);
        }</pre></div><p class="calibre8">Once we are done processing the entire <code class="email">com-orkut.ungraph.txt</code> file, we simply mark the queue as completed and wait for the consumer threads to be terminated:</p><div class="informalexample"><pre class="programlisting">        queue.markCompleted();
        queue.joinThreads();</pre></div><p class="calibre8">Now all the counts must be updated in the values array. So we simply read them one by one and output them in the file output:</p><div class="informalexample"><pre class="programlisting">        PrintStream out = new PrintStream(OUTPUT_FILE_PATH);
        for(int i=0;i&lt;count;i++){
            out.println(keys[i] +" : "+values[i].get());
        }
        out.flush();
    }
}</pre></div><p class="calibre8">The preceding example demonstrates how an actual problem can be solved using the reactive technique of <span class="strong"><strong class="calibre2">producer-consumer</strong></span>. Now we will discuss another way of implementing our <a id="id596" class="calibre1"/>event queue; it does not involve blocking on semaphores.</p></div></div>

<div class="book" title="Producer-consumer model">
<div class="book" title="Spinlock and busy wait"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch11lvl2sec94" class="calibre1"/>Spinlock and busy wait</h2></div></div></div><p class="calibre8">A semaphore <a id="id597" class="calibre1"/>normally blocks a thread before the thread acquires it. This blocking is achieved by the operating system by removing the thread from the list of threads that are ready to be scheduled for processing time on the CPU. The list of threads ready to be scheduled are called running threads. Every semaphore has a list of threads waiting on it, and these threads are removed from the list of running threads. Once the semaphore is released, threads from the list attached to the semaphore are removed and put back on the list of the running threads. This operation is somewhat heavyweight and requires processing time. Another way to stop a thread from accessing a shared resource is to use a spinlock. A spinlock is generally implemented using an atomic variable and compare and set operation. A thread in a spinlock simply tries to perform compare and set on a variable in a loop; it does so until it succeeds. To the operating system, this thread is as good as a running thread and is scheduled just like any other thread. The thread itself, however, keeps trying a compare and set operation and consumes processor time. This is why it is called a busy wait. The thread can proceed to do something meaningful once the compare and set operation is successful. Spinlocks are useful when the resource would not be available only for a short period of time. It simply does not make sense to do all the heavy lifting of removing the thread from the list of running thread and blocking on a semaphore if the resource is unavailable for a brief period of time.</p><p class="calibre8">We can implement our thread-safe queue with spinlocks instead of semaphores as shown in the following code. Each array location for storing the queue elements is protected by two <code class="email">AtomicBoolean</code> variables, stored in the <code class="email">enqueueLocks</code> and <code class="email">dequeueLocks</code> arrays. The only thing we want to make sure is that after each dequeue, there should only be a single enqueue, and after each enqueue, there should only be a single dequeue for a particular array location. Different array locations should be independent of one another:</p><div class="informalexample"><pre class="programlisting">public class ThreadSafeFixedLengthSpinlockQueue&lt;E&gt; {
    int nextEnqueueIndex;
    int nextDequeueIndex;
    E[] store;
    AtomicBoolean[] enqueueLocks;
    AtomicBoolean[] dequeueLocks;
    AtomicInteger currentElementCount = new AtomicInteger(0);
    int length;
    volatile boolean alive = true;
    public ThreadSafeFixedLengthSpinlockQueue(int length){
        this.length = length;
        store = (E[]) new Object[length];
        enqueueLocks = new AtomicBoolean[length];
        dequeueLocks = new AtomicBoolean[length];</pre></div><p class="calibre8">When <code class="email">enqueueLocks[i]</code> is <code class="email">false</code>, it means there is no element being stored at the position <code class="email">i</code>. When <code class="email">dequeueLock[i]</code> is <code class="email">true</code>, it means the same thing. The reason we need both is for <a id="id598" class="calibre1"/>protection when an element is in the process of being enqueued or dequeued:</p><div class="informalexample"><pre class="programlisting">        for(int i=0;i&lt;length;i++){
            enqueueLocks[i] = new AtomicBoolean(false);
            dequeueLocks[i] = new AtomicBoolean(true);
        }
    }</pre></div><p class="calibre8">Here is the core of the lock. We simply take the next index to enqueue and try to get <code class="email">enqueueLock</code>. If it is <code class="email">false</code>, which means nothing is already enqueued, it is atomically set to <code class="email">true</code> and it starts the enqueue process; otherwise, we keep doing the same thing in a busy loop until the compare and set operation is successful. Once the process is complete, we release <code class="email">dequeueLock</code> by simply setting it to <code class="email">false</code>. A compare and set operation is not necessary here because it is guaranteed to be <code class="email">true</code>. The number of elements are maintained using another atomic variable:</p><div class="informalexample"><pre class="programlisting">    public void enqueue(E value) throws InterruptedException {

        while (true) {
            int index = nextEnqueueIndex;
            nextEnqueueIndex = (nextEnqueueIndex+1) % length;
            if(enqueueLocks[index].compareAndSet(false,true)){
                currentElementCount.incrementAndGet();
                store[index] = value;
                dequeueLocks[index].set(false);
                return;
            }
        }
    }</pre></div><p class="calibre8">The dequeue operation is very similar, just that the enqueue and dequeue locks have switched places:</p><div class="informalexample"><pre class="programlisting">    public E dequeue() throws InterruptedException {
        while(alive) {
            int index = nextDequeueIndex;
            nextDequeueIndex = (nextDequeueIndex+1) % length;
            if(dequeueLocks[index].compareAndSet(false,true)){
                currentElementCount.decrementAndGet();
                E value = store[index];
                enqueueLocks[index].set(false);
                return value;
            }
        }
        throw new InterruptedException("");
    }</pre></div><p class="calibre8">The rest of the code is self-evident:</p><div class="informalexample"><pre class="programlisting">    public int currentElementCount(){
        return currentElementCount.get();
    }

    public void killDequeuers(){
        alive = false;
    }
  
}</pre></div><p class="calibre8">We can simply replace the queue in the <code class="email">ProducerConsumerQueue</code> class to use this spinlock-based <a id="id599" class="calibre1"/>queue. In the case of our example problem, the spinlock version of the queue performs better.</p><p class="calibre8">Let's solve another problem using <code class="email">ProducerConsumerQueue</code>. Our problem is to find all the perfect numbers between 2 and 500,000. What is a perfect number? A perfect number is a number that is the sum of all its divisors, excluding itself. The first perfect number is 6. 6 has three divisors excluding itself, namely 1, 2, and 3 and 6=1+2+3. This is what makes 6 a perfect number. To find all the perfect numbers between 2 and 500,000, we will check whether each number in the range is a perfect number. We can write the following code to figure out whether a given number is a perfect number. For every number <span class="strong"><em class="calibre12">div</em></span>, we check whether the number <span class="strong"><em class="calibre12">x</em></span> is divisible by <span class="strong"><em class="calibre12">div</em></span>; if so, we add it to the sum. In such a case, if we divide<span class="strong"><em class="calibre12"> x</em></span> by <span class="strong"><em class="calibre12">div</em></span>, we will of course get another divisor of <span class="strong"><em class="calibre12">x</em></span> as a result stored in the variable quotient. This must also be added to the sum, unless it is equal to <span class="strong"><em class="calibre12">div</em></span>. We stop this process when we pass through the square root of <span class="strong"><em class="calibre12">x</em></span>, that is, when <span class="strong"><em class="calibre12">div</em></span> is bigger than the quotient we get when <span class="strong"><em class="calibre12">x</em></span> is divided by <span class="strong"><em class="calibre12">div</em></span>. Since we, originally, exclude <span class="strong"><em class="calibre12">1</em></span> as a divisor to avoid adding the number itself, we add <span class="strong"><em class="calibre12">1</em></span> to the sum at the end and check whether it is equal to <span class="strong"><em class="calibre12">x</em></span>; if so, <span class="strong"><em class="calibre12">x</em></span> is a perfect number:</p><div class="informalexample"><pre class="programlisting">public static boolean isPerfect(long x){
        long div = 2;
        long sum=0;
        while(true){
            long quotient = x/div;
            if(quotient&lt;div){
                break;
            }
            if(x%div==0){
                sum+=div;
                if(quotient!=div){
                    sum+=quotient;
                }
            }
            div++;
        }
        return 1+sum==x;
    }</pre></div><p class="calibre8">As you can see, checking whether a given number is a perfect number is a computationally expensive operation, which makes it desirable to use all the CPUs to compute it. We will use <a id="id600" class="calibre1"/>our producer-consumer framework to do this. The code is self-explanatory. Our consumer code simply checks whether a given number is a perfect number and then prints the number if it is so. The producer simply generates and queues all the numbers. Since the consumer is run in multiple threads and it is the part that is computationally intensive, it should work faster than the single-threaded version:</p><div class="informalexample"><pre class="programlisting">public static void findPerfectNumberWithProducerConsumer() throws InterruptedException{
        long start = System.currentTimeMillis();
        ProducerConsumerQueue&lt;Long&gt; queue 
                 = new ProducerConsumerQueue&lt;&gt;(4096, 4, (x)-&gt;{
            if(isPerfect(x)){
                System.out.println(x);
            }
        });

        for(long i=2;i&lt;5_00_000;i++){
            queue.produce(i);
        }
        queue.markCompleted();
        queue.joinThreads();
        System.out.println("Time in ms: "+(System.currentTimeMillis()-start));
    }</pre></div><p class="calibre8">Since my computer has four CPU cores, I used four threads to do the heavy lifting. On my computer, this program takes 1,596 milliseconds as compared to 4,002 milliseconds for the single-threaded program, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">public static void findPerfectNumberWithSingleThread(){
        long start = System.currentTimeMillis();
        for(long i=2;i&lt;5_00_000;i++){
            if(isPerfect(i)){
                System.out.println(i);
            }
        }
        System.out.println("Time in ms: "+(System.currentTimeMillis()-start));
    }</pre></div></div></div>
<div class="book" title="Functional way of reactive programming"><div class="book" id="22O7C2-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec63" class="calibre1"/>Functional way of reactive programming</h1></div></div></div><p class="calibre8">Most reactive <a id="id601" class="calibre1"/>programming frameworks provide functional APIs for reactive programming, which makes it even easier to work with. In this section, we will build a functional reactive API and solve a problem with it. The idea is to use the concept of a stream. A stream is a data generator or source that can provide input when requested. Functional APIs provide map, filter, and consume operations on the stream. The map and the filter operations create a new stream, and the consume operation gives a <code class="email">EventConsumer</code> instance. The idea is that when <code class="email">EventConsumer</code> is asked to start processing, it would spawn its own producer threads and consumer threads and treat each map, filter, or consume operations as a separately scheduled operation in a producer-consumer queue. This is just to highlight what we are really trying to achieve.</p><p class="calibre8">For example, I will put the code to use the functional API to solve the same perfect number problem. We will replace the pseudo-method <code class="email">someWayCreateAStream</code> with the actual code to create a stream later. The point is to show how an event stream can be manipulated using the map, filter, and consume method. The processing really starts when the process method is called, and in each step of map, filter, and consume are decoupled processing steps and are potentially run in different threads:</p><div class="informalexample"><pre class="programlisting">  public static void findPerfectNumbersWithFunctionalAPI(){
        EventStream&lt;Long&gt; stream = someWayCreateAStream();
        stream.filter((x)-&gt;x&gt;1)
                .filter(EventStream::isPerfect)
                .consume((x)-&gt;{System.out.println(x);})
                .onError((x)-&gt;System.out.println(x))
                .process(4096,1,4);

    }</pre></div><p class="calibre8">When we create an instance of <code class="email">EventStream</code> or <code class="email">EventConsumer</code>, no processing happens; only metadata is created. It is when the method process is invoked that the processing starts. This is done by the process method spawning the producer and consumer threads. The producer threads create and enqueue events that contain the initial value and the processing <a id="id602" class="calibre1"/>code (like map, filter, or consume operations). A dequeuer runs the first piece of processing and enqueues another event for the next level of processing; it does this for map and filter operations. A consume operation is the end of the processing chain, and it does not return any value. This is when no more events are scheduled.</p><p class="calibre8">This requires that a dequeuer thread must also do some enqueue operations. What can be a problem with this? There are two kinds of threads that enqueue. One of these threads is responsible for dequeueing too. These threads may get blocked while trying to perform enqueue operations when the queue is full. But this would mean that they would not be able to do any dequeue operation either; this is because if they do this, the queue would never have more space again. This situation is a deadlock; all the threads are blocked and are expecting other threads to do something to unblock them.</p><p class="calibre8">To see why this deadlock happens, let's imagine a queue with length 4. Suppose there are two dequeuing threads that also perform an enqueue operation once in some cases. Let's have another enqueuer thread too. Since the threads can run in any order, it is possible that the enqueuer runs first and enqueues four new elements to make the queue full. Now say two dequeuers run, each dequeuing one element. Before these threads get a chance to enqueue once more, the enqueuer thread is run again, and this time it enqueues two new elements to fill the queue. Now the dequeuer threads are run, but they are blocked because the queue is full. They cannot even dequeue any element because they are themselves blocked from enqueuing more elements. This is a deadlock situation. <span class="strong"><em class="calibre12">Figure 2</em></span> shows this situation:</p><div class="mediaobject"><img src="../images/00078.jpeg" alt="Functional way of reactive programming" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">What we really want is threads that will not only perform the enqueue operation, but also block the queue before it is completely full. This is so that the dequeueing threads can use some space to keep dequeuing and enqueuing until they reach a point where they will not have to enqueue <a id="id603" class="calibre1"/>anymore (because they have reached the last step of the processing chain). Eventually, the queue gets empty and the enqueuer threads can be unblocked again. To do this, we need to have two different kinds of enqueue operations. One that does not block until the queue is full, and another that blocks once the queue is half or more full. We can implement the second type using the following code in the <code class="email">ThreadSafeFixedLengthSpinlockQueue </code>class. The <code class="email">enqueueProducerOnly</code> method is just like the <code class="email">enqueue</code> method, except it performs an atomic check of the <code class="email">currentElementCount</code> variable instead of just incrementing it. If, while enqueueing, it is seen that the queue is already full, we release the enqueue lock and restart. The thread that does only enqueue operations and no dequeue operation must use this method instead of the regular <code class="email">enqueue</code> method:</p><div class="informalexample"><pre class="programlisting">public void enqueueProducerOnly(E value ) throws InterruptedException{
        int halfLength = length/2;
        while (true) {

            int index = nextEnqueueIndex;
            nextEnqueueIndex = (nextEnqueueIndex+1) % length;
            if(enqueueLocks[index].compareAndSet(false,true)){
                int numberOfElements = currentElementCount.get();
                if(numberOfElements&gt;=halfLength
                   || (!currentElementCount.compareAndSet(numberOfElements, numberOfElements+1))){
                    enqueueLocks[index].set(false);
                    continue;
                }
                store[index] = value;
                dequeueLocks[index].set(false);
                return;
            }
        }
    }</pre></div><p class="calibre8">We can now use this method to implement a corresponding method in the <code class="email">ProducerConsumerQueue</code> class. This method is exactly the same as the produce method, except that here, the call to enqueue has been replaced by a call to the <code class="email">enqueueProducerOnly</code> method:</p><div class="informalexample"><pre class="programlisting">public void produceExternal(E value) throws InterruptedException {
        Event event = new Event();
        event.value = value;
        event.eventType = EventType.INVOCATION;
        queue.enqueueProducerOnly(event);
 }</pre></div><p class="calibre8">Now let's see the <code class="email">EventStream</code> class. The whole point of the <code class="email">EventStream</code> class is to create metadata in a functional way. It is an abstract class with only one abstract method called <code class="email">read()</code>. A call to the <code class="email">read</code> method should return the next object that needs to be processed. The class maintains a pointer to the previous <code class="email">EventStream</code> on which this <code class="email">EventStream</code> will work. This means that the operation represented by <code class="email">EventStream</code> will work on the data obtained after all the previous <code class="email">EventStream</code> have been processed. It is really a linked list of <code class="email">EventStream</code>. Depending on the kind of operation the current <code class="email">EventStream</code> represents, it either has a mapper, a filter, or nothing. The <code class="email">read</code> method is applicable only to the <a id="id604" class="calibre1"/>first <code class="email">EventStream</code> that generates the data. Both the map filter methods return another <code class="email">EventStream</code> that represents the corresponding processing. After all the map and filter calls, the list linked by <code class="email">EventStream</code> will store all the operations from the last to the first:</p><div class="informalexample"><pre class="programlisting">public abstract class EventStream&lt;E&gt; {
    EventStream previous;
    OneArgumentExpressionWithException mapper;
    OneArgumentExpressionWithException filter;
    public &lt;R&gt; EventStream&lt;R&gt; map(OneArgumentExpressionWithException&lt;E,R&gt; mapper){
        EventStream&lt;R&gt; mapped = new EventStream&lt;R&gt;() {

            @Override
            public R read() {
                return null;
            }
        };
        mapped.mapper = mapper;
        mapped.previous = this;
        return mapped;
    }
    public EventStream&lt;E&gt; filter(OneArgumentExpressionWithException&lt;E, Boolean&gt; filter){
        EventStream&lt;E&gt; mapped = new EventStream&lt;E&gt;() {

            @Override
            public E read() {
                return null;
            }
        };
        mapped.filter = filter;
        mapped.previous = this;
        return mapped;
    }</pre></div><p class="calibre8">The consume method, however, returns an instance of <code class="email">EventConsumer</code>. This is the terminal processing in any chain that does not compute a new value. The <code class="email">EventConsumer</code> <a id="id605" class="calibre1"/>class, as would be shown a little later, contains all of the logic to actually start the processing:</p><div class="informalexample"><pre class="programlisting">    public EventConsumer&lt;E&gt; consume(
      OneArgumentStatementWithException&lt;E&gt; consumer){
            EventConsumer eventConsumer = new EventConsumer(consumer, this) {
        };
        return eventConsumer;
    }
    public abstract E read();
}</pre></div><p class="calibre8">Since we need to store the details of the processing inside an <code class="email">EventConsumer</code> instance, we will first make a few classes to store this information. The first one is a <code class="email">Task</code> interface that represents any of the map, filter, or consume operation:</p><div class="informalexample"><pre class="programlisting">public interface Task {
}</pre></div><p class="calibre8">This interface is implemented by three classes that represent each kind of operation. To store the code, we need two additional functional interfaces that represent an expression and a statement that would allow you to throw exceptions:</p><div class="informalexample"><pre class="programlisting">@FunctionalInterface
public interface OneArgumentExpressionWithException&lt;A,R&gt; {
    R compute(A a) throws Exception;
}
@FunctionalInterface
public interface OneArgumentStatementWithException&lt;E&gt; {
    void doSomething(E input) throws Exception;
}</pre></div><p class="calibre8">The following classes implement the <code class="email">Task</code> interface:</p><div class="informalexample"><pre class="programlisting">public class MapperTask implements Task {
    OneArgumentExpressionWithException mapper;
    Task nextTask;

    public MapperTask(
            OneArgumentExpressionWithException mapper,
            Task nextTask) {
        this.mapper = mapper;
        this.nextTask = nextTask;
    }

}

public class FilterTask implements Task{
    OneArgumentExpressionWithException filter;
    Task nextTask;

    public FilterTask(
            OneArgumentExpressionWithException filter,
            Task nextTask) {
        this.filter = filter;
        this.nextTask = nextTask;
    }
}</pre></div><p class="calibre8">Both <code class="email">MapperTask</code> and <code class="email">FilterTask</code> have a pointer to the next task because they are intermediate operations. They also store the piece of code associated with the processing. The <code class="email">ProcessorTask</code> <a id="id606" class="calibre1"/>represents the terminal operation, so it does not have a pointer to the next task:</p><div class="informalexample"><pre class="programlisting">public class ProcessorTask&lt;E&gt; implements Task{
    OneArgumentStatementWithException&lt;E&gt; processor;

    public ProcessorTask(
            OneArgumentStatementWithException&lt;E&gt; processor) {
        this.processor = processor;
    }
}</pre></div><p class="calibre8">We will now create the <code class="email">EventConsumer</code> class that will create a task chain and run it:</p><div class="informalexample"><pre class="programlisting">public abstract class EventConsumer&lt;E&gt; {
    OneArgumentStatementWithException consumptionCode;
    EventStream&lt;E&gt; eventStream;
    Task taskList = null;
    private ProducerConsumerQueue&lt;StreamEvent&gt; queue;
    private OneArgumentStatement&lt;Exception&gt; errorHandler = (ex)-&gt;ex.printStackTrace();</pre></div><p class="calibre8">A <code class="email">StreamEvent</code> is a processing request that is an element of the producer-consumer queue. It stores <code class="email">value</code> as <a id="id607" class="calibre1"/>
<code class="email">Object</code> and <code class="email">task</code>. The <code class="email">task</code> can have more tasks pointed to by its next reference:</p><div class="informalexample"><pre class="programlisting">    class StreamEvent{
        Object value;
        Task task;
    }</pre></div><p class="calibre8">An <code class="email">EventStream</code> stores its previous operation—that is to say that if we read the head of the list, which would be the last operation. Of course, we need to arrange the operations in the order of execution and not in reverse order. This is what the <code class="email">eventStreamToTask</code> method does. A <code class="email">MapperTask</code> or <code class="email">FilterTask</code> stores the next operation, so the head of the list is the first operation to be carried out:</p><div class="informalexample"><pre class="programlisting">        private Task eventStreamToTask(EventStream stream){
        Task t = new ProcessorTask(consumptionCode);
        EventStream s = stream;
        while(s.previous !=null){
            if(s.mapper!=null)
                t = new MapperTask(s.mapper, t);
            else if(s.filter!=null){
                t = new FilterTask(s.filter, t);
            }
            s = s.previous;
        }
        return t;
    }</pre></div><p class="calibre8">The constructor is package-accessible; it is intended to be initialized only from inside the <code class="email">consume</code> method of an <code class="email">EventStream</code>:</p><div class="informalexample"><pre class="programlisting">    EventConsumer(
            OneArgumentStatementWithException consumptionCode,
            EventStream&lt;E&gt; eventStream) {
        this.consumptionCode = consumptionCode;
        this.eventStream = eventStream;
        taskList = eventStreamToTask(eventStream);
    }</pre></div><p class="calibre8">The following is the piece of code responsible for actually carrying out the operations. The <code class="email">ConsumerCodeContainer</code> class implements <code class="email">Consumer</code> and acts as the consumer of the producer-consumer queue for processing events:</p><div class="informalexample"><pre class="programlisting">    class ConsumerCodeContainer implements Consumer&lt;StreamEvent&gt;{
        @Override
        public void onError(Exception error) {
            errorHandler.doSomething(error);
        }</pre></div><p class="calibre8">The <code class="email">onMessage</code> method is invoked for every event in the producer-consumer queue. Based on the actual task, it takes the corresponding action. Notice that for <code class="email">MapperTask</code> and <code class="email">FilterTask</code>, a new event is enqueued with the next operation:</p><div class="informalexample"><pre class="programlisting">        @Override
        public void onMessage(StreamEvent evt) {</pre></div><p class="calibre8">The <code class="email">ProcessorTask</code> is <a id="id608" class="calibre1"/>always the end of a processing chain. The operation is simply invoked on the value and no new event is queued:</p><div class="informalexample"><pre class="programlisting">            if(evt.task instanceof ProcessorTask){
                try {
                    ((ProcessorTask) evt.task).processor
                            .doSomething(evt.value);
                } catch (Exception e) {
                    queue.sendError(e);
                }
            }</pre></div><p class="calibre8">For a <code class="email">FilterTask</code>, the event with the next task is enqueued only if the condition is satisfied:</p><div class="informalexample"><pre class="programlisting">            else if(evt.task instanceof FilterTask){
                StreamEvent nextEvent = new StreamEvent();
                try {
                    if((Boolean)((FilterTask) evt.task).filter.compute(evt.value)) {
                        nextEvent.task =
                                ((FilterTask) evt.task).nextTask;
                        nextEvent.value = evt.value;
                        queue.produce(nextEvent);
                    }
                } catch (Exception e) {
                    queue.sendError(e);
                }
            }</pre></div><p class="calibre8">For a <code class="email">MapperTask</code>, the next task is enqueued with the value computed by the current map operation:</p><div class="informalexample"><pre class="programlisting">             else if(evt.task instanceof MapperTask){
                StreamEvent nextEvent = new StreamEvent();
                try {
                    nextEvent.value = ((MapperTask) evt.task).mapper.compute(evt.value);
                    nextEvent.task = ((MapperTask) evt.task).nextTask;
                    queue.produce(nextEvent);
                } catch (Exception e) {
                    queue.sendError(e);
                }
            }
        }
    }</pre></div><p class="calibre8">The process method <a id="id609" class="calibre1"/>is responsible for kicking the actual processing of the tasks. It uses a <code class="email">ProducerConsumerQueue</code> to schedule events that are processed by the consumer previously discussed:</p><div class="informalexample"><pre class="programlisting">    public void process(int bufferSize, int numberOfProducerThreads, int numberOfConsumerThreads) {
      queue = new ProducerConsumerQueue&lt;&gt;(bufferSize,
      numberOfConsumerThreads, new ConsumerCodeContainer());</pre></div><p class="calibre8">Only the original <code class="email">EventStream</code> on which map and filter were called has the <code class="email">read</code> method implemented. So we simply get a reference to the original <code class="email">EventStream</code>:</p><div class="informalexample"><pre class="programlisting">        EventStream s = eventStream;
        while(s.previous !=null){
            s = s.previous;
        }</pre></div><p class="calibre8">The <code class="email">startingStream</code> variable points to the original <code class="email">EventStream</code>:</p><div class="informalexample"><pre class="programlisting">        EventStream startingStream = s;</pre></div><p class="calibre8">The producer code also runs in separate threads. The <code class="email">Runnable producerRunnable</code> contains the producer code. It simply keeps calling the <code class="email">read</code> method of the <code class="email">EventStream</code> until <code class="email">null</code> is returned (which marks the end of the stream) and enqueues a <code class="email">StreamEvent</code> with the value and the task chain we have created with the help of the <code class="email">eventStreamToTask</code> method:</p><div class="informalexample"><pre class="programlisting">        Runnable producerRunnable = ()-&gt;{
            while(true){
                Object value = startingStream.read();
                if(value==null){
                    break;
                }
                StreamEvent nextEvent = new StreamEvent();
                try {
                    nextEvent.value = value;
                    nextEvent.task = taskList;
                    queue.produceExternal(nextEvent);
                } catch (Exception e) {
                    queue.sendError(e);
                }
            }
            try {
                queue.markCompleted();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        };</pre></div><p class="calibre8">Now we <a id="id610" class="calibre1"/>spawn the <code class="email">producer</code> threads and wait for them to finish with the <code class="email">join</code> calls:</p><div class="informalexample"><pre class="programlisting">        Thread [] producerThreads = new Thread[numberOfProducerThreads];
        for(int i=0;i&lt;numberOfProducerThreads;i++){
            producerThreads[i] = new Thread(producerRunnable);
            producerThreads[i].start();
        }
        for(int i=0;i&lt;numberOfProducerThreads;i++){
            try {
                producerThreads[i].join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }</pre></div><p class="calibre8">This is a method to register a custom error handler and return a new <code class="email">EventConsumer</code>:</p><div class="informalexample"><pre class="programlisting">    public EventConsumer&lt;E&gt; onError(
               OneArgumentStatement&lt;Exception&gt; errorHandler){
        EventConsumer&lt;E&gt; consumer 
         = new EventConsumer&lt;E&gt;(consumptionCode, eventStream) {};
        consumer.taskList = taskList;
        consumer.errorHandler = errorHandler;
        return consumer;
    }
}</pre></div><p class="calibre8">Going back to our original problem of perfect numbers, all we have to do now is to define an <code class="email">EventStream</code> with a read method that generates all the numbers and then does maps and filters on them as follows. Notice that the <code class="email">EventStream.read()</code> method may be invoked by multiple threads simultaneously if we use more than one producer thread, so it is better for it to be thread-safe.</p><p class="calibre8">The <code class="email">read</code> <a id="id611" class="calibre1"/>method simply increments an <code class="email">AtomicLong</code> and returns the previous value, unless the previous value is greater than <code class="email">5_00_000L</code>; in this case, it returns <code class="email">null</code>, marking the end of the stream. We have already seen the rest of the code:</p><div class="informalexample"><pre class="programlisting">  public static void findPerfectNumbersWithFunctionalAPI(){
        long start = System.currentTimeMillis();
        EventStream&lt;Long&gt; stream = new EventStream&lt;Long&gt;() {
            AtomicLong next = new AtomicLong(0L);
            @Override
            public Long read() {
                Long ret = next.incrementAndGet();
                if(ret&lt;=5_00_000L){
                    return ret;
                }
                return null;
            }
        };
        stream.filter((x)-&gt;x&gt;1)
                .filter(EventStream::isPerfect)
                .consume((x)-&gt;{System.out.println(x);})
                .onError((x)-&gt;System.out.println(x))
                .process(4096,1,4);

        System.out.println("Time in ms: "+(System.currentTimeMillis()-start));
    }</pre></div><p class="calibre8">This code runs for almost the same time as the previous reactive version without a functional API. I will leave it up to you to use the functional API to implement the friend count solution, as it is fairly simple as one gets the hang of it. All you need to think about is how to implement the <code class="email">read</code> method to return the integers from the file.</p></div>
<div class="book" title="Summary" id="23MNU1-eeeded97b5e248ac807bb1bec4d7c800"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec64" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we learned how to do advanced thread synchronization using volatile fields, atomic operations, and semaphores. We used these to create our own reactive programming framework and also created a functional API for reactive programming. We used our frameworks to solve sample problems and saw how multithreaded scalable apps can be written easily with a reactive framework.</p><p class="calibre8">There are many reactive programming frameworks available, such as RxJava, Akka, and many more. They are slightly different in their implementation and features. They all provide a lot more features than the one we used. This chapter is just an introduction to the topic; interested readers can learn more about reactive programming from the books dedicated to this subject.</p><p class="calibre8">In this book, I tried to give you a head start in the world of algorithms, with implementations in Java. Algorithms are a vast field of study. Every computation problem needs to be solved by an algorithm. A further study would include complexity classes of algorithms, equivalence of algorithms, and approximate algorithms for highly complex problems. A complex problem is a problem that guarantees that any algorithm that solves it must have a certain amount of complexity. This gives rise to the concept of the complexity classes of problems. There are also formal/mathematical ways of proving the correctness of algorithms. All these areas can be pursued by you.</p><p class="calibre8">The book also covers functional and reactive programming a little bit. This should work as a head start in those areas; you can learn more about them in the books dedicated to these topics.</p></div></body></html>