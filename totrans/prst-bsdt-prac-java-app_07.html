<html><head></head><body>
		<div id="_idContainer050">
			<h1 class="chapter-number" id="_idParaDest-84"><a id="_idTextAnchor138"/>7</h1>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor139"/>The Missing Guide for jOOQ Adoption</h1>
			<p><strong class="bold">Object-oriented programming</strong> (<strong class="bold">OOP</strong>) is the most popular approach when discussing enterprise <a id="_idIndexMarker276"/>architecture; however, there are more, such as data-driven. In today’s data-driven world, jOOQ has emerged as a powerful tool for developers to use to interact with databases, offering a seamless and efficient approach to working <span class="No-Break">with SQL.</span></p>
			<p>Firstly, let’s address <a id="_idIndexMarker277"/>the fundamental question: what is jOOQ? <strong class="bold">jOOQ</strong>, which stands for <strong class="bold">Java Object Oriented Querying</strong>, is a lightweight yet robust Java library that empowers developers to write type-safe SQL queries fluently and intuitively. It provides a <strong class="bold">domain-specific language</strong> (<strong class="bold">DSL</strong>) that encapsulates the <a id="_idIndexMarker278"/>complexities of SQL, allowing developers to focus on writing concise and <span class="No-Break">readable code.</span></p>
			<p>Now, you might wonder why jOOQ has gained significant traction among developers. The answer lies in its ability to bridge the gap between the relational world of databases and the object-oriented paradigm of modern application development. jOOQ enables developers to leverage the full power of SQL within their Java code, providing flexibility, performance, and <a id="_idIndexMarker279"/>maintainability that is often difficult to achieve with traditional <strong class="bold">object-relational mapping</strong> (<span class="No-Break"><strong class="bold">ORM</strong></span><span class="No-Break">) frameworks.</span></p>
			<p>As we dive deeper into the world of jOOQ, we will explore the concept of data-driven design and its implications. Unlike traditional OOP, which primarily revolves around manipulating objects and their behaviors, data-driven design emphasizes the underlying data structures and their relationships. We will examine how jOOQ embraces this approach, empowering developers to efficiently handle complex database interactions while maintaining the benefits of strong typing and <span class="No-Break">compile-time safety.</span></p>
			<p>In this chapter, we will explore the jOOQ framework and how to use it in an enterprise architecture with both Jakarta EE <span class="No-Break">and MicroProfile:</span></p>
			<ul>
				<li>Data-driven and object-oriented programming <span class="No-Break">in Java</span></li>
				<li>What <span class="No-Break">is jOOQ?</span></li>
				<li>Using jOOQ <span class="No-Break">with Jakarta/MicroProfile</span></li>
			</ul>
			<p>So, let’s embark on this journey to discover the power of jOOQ and understand how it revolutionizes how we interact with databases, bridging the gap between the world of SQL <span class="No-Break">and O<a id="_idTextAnchor140"/>OP.</span></p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor141"/>Technical requirements</h1>
			<p>The following are required for <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><span class="No-Break">Java 17</span></li>
				<li><span class="No-Break">Git</span></li>
				<li><span class="No-Break">Maven</span></li>
				<li>Any <span class="No-Break">preferred IDE</span></li>
				<li>The code for this chapter can be found <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-07"><span class="No-Break">https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter<span id="_idTextAnchor142"/>-07</span></a></li>
			</ul>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor143"/>Data-driven and object-oriented programming in Java</h2>
			<p>In Java, <strong class="bold">data-driven</strong> programming refers to an approach where the underlying data and its structure <a id="_idIndexMarker280"/>primarily drive the design and functionality of a program. It focuses on manipulating and processing data in a way that allows for flexibility, extensibility, and easy modification without heavily relying on the behavior <span class="No-Break">of objects.</span></p>
			<p>In contrast, OOP is a programming paradigm that revolves around objects, which are instances of <a id="_idIndexMarker281"/>classes. OOP emphasizes encapsulating data and related behavior within objects, promoting concepts such as inheritance, polymorphism, and abstraction. It focuses on modeling real-world entities as objects and defining their behaviors through methods <span class="No-Break">and relationships.</span></p>
			<p>The critical <a id="_idIndexMarker282"/>difference between <a id="_idIndexMarker283"/>data-driven programming and OOP lies in their approach to program design. In OOP, the emphasis is on modeling entities and their behavior, organizing code around objects and their interactions. This approach works well when the behavior of objects is complex or when there is a need to represent the real-world entities in <span class="No-Break">the system.</span></p>
			<p>On the other hand, data-driven programming prioritizes manipulating and processing data structures. It is <a id="_idIndexMarker284"/>beneficial when dealing with large amounts of data, such <a id="_idIndexMarker285"/>as databases or data-centric applications. Data-driven programming allows for efficient querying, filtering, and transformation of data, often leveraging declarative approaches such as SQL or other <span class="No-Break">query languages.</span></p>
			<p>In some situations, a data-driven approach may be more suitable than an object-oriented one. Here are a <span class="No-Break">few examples:</span></p>
			<ul>
				<li><strong class="bold">Data processing and analysis</strong>: A data-driven approach with specialized libraries or <a id="_idIndexMarker286"/>frameworks can offer better performance and flexibility when dealing with extensive datasets or performing complex <span class="No-Break">analytical tasks</span></li>
				<li><strong class="bold">Database-driven applications</strong>: When developing applications that interact heavily with databases or rely on data from external sources, a data-driven approach such as jOOQ can simplify database interactions and optimize <span class="No-Break">query execution</span></li>
				<li><strong class="bold">Configuration-driven systems</strong>: In systems where the behavior is primarily determined by configuration files or external data, a data-driven approach allows easy modifications and customization without requiring <span class="No-Break">code changes</span></li>
				<li><strong class="bold">Rule-based systems</strong>: In applications that involve complex rule evaluation or decision-making based on data, a data-driven approach can provide a transparent and manageable way to express and <span class="No-Break">process rules</span></li>
			</ul>
			<p>It’s important to note that OOP and data-driven programming are not mutually exclusive, and they can often be combined to achieve the desired functionality and maintainability in a Java application. The choice between the two approaches depends on the specific requirements of the system and the nature of the problem <span class="No-Break">being solved.</span></p>
			<p>While data-driven programming offers several advantages, it also comes with inevitable trade-offs. Here are some of the trade-offs associated with <span class="No-Break">data-driven programming:</span></p>
			<ul>
				<li><strong class="bold">Increased complexity</strong>: Data-driven programming can introduce additional complexity, especially when dealing with large and complex data structures. Managing and <a id="_idIndexMarker287"/>manipulating data at a granular level may require intricate code and logic, making the system harder to understand <span class="No-Break">and maintain.</span></li>
				<li><strong class="bold">Reduced encapsulation</strong>: In data-driven programming, the focus is primarily on the data and its manipulation rather than encapsulating behavior within objects. This can lead to reduced encapsulation and increased data exposure, potentially compromising the security and integrity of <span class="No-Break">the system.</span></li>
				<li><strong class="bold">Limited expressiveness</strong>: While data-driven programming provides powerful data manipulation and querying mechanisms, it may have limitations when expressing complex business logic or relationships between data. OOP, emphasizing behavior and encapsulation, can often provide more expressive and intuitive solutions for <span class="No-Break">such scenarios.</span></li>
			</ul>
			<p>Despite these trade-offs, data-driven programming can be highly beneficial when efficient data <a id="_idIndexMarker288"/>manipulation, querying, and flexibility are crucial. By understanding these trade-offs, developers can make informed decisions when choosing between object-oriented and data-driven approaches, considering their applications’ specific requirements <span class="No-Break">and constraints.</span></p>
			<p>Object-oriented is the <a id="_idIndexMarker289"/>most popular paradigm when discussing enterprise applications; however, we can explore more paradigms, such as a <span class="No-Break">data-driven design.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">This chapter gives a brief overview of this topic, but if you want to go deep, there are two <span class="No-Break">recommended materials.</span></p>
			<p class="callout">The first one is the book <em class="italic">Data-Oriented Programming</em> by Yehonathan Sharvit, which talks about this pattern, for which we can summarize <span class="No-Break">three principles:</span></p>
			<ul>
				<li class="callout">The code <span class="No-Break">is data-separated</span></li>
				<li class="callout">Data <span class="No-Break">is immutable</span></li>
				<li class="callout">Data has <span class="No-Break">flexible access</span></li>
			</ul>
			<p class="callout">The second one is an article called <em class="italic">Data-Oriented Programming</em> by Brian Goetz, where Brian explains more about new features of Java, mainly records, and how to take advantage <span class="No-Break">of Java.</span></p>
			<p class="callout">Given this overview of data-oriented programming, let’s go deep with one of the most popular frameworks that can help you to design and create data-oriented <span class="No-Break">applic<a id="_idTextAnchor144"/>ations: jOOQ.</span></p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor145"/>What is jOOQ?</h2>
			<p>jOOQ is a powerful Java library that bridges the gap between OOP and data-oriented programming in the <a id="_idIndexMarker290"/>context of enterprise applications. While OOP has long been the dominant paradigm in developing enterprise applications, there are cases where a data-oriented approach can offer unique advantages. jOOQ provides an elegant solution for developers to use to harness the power of SQL and leverage data-driven design principles within their <span class="No-Break">Java code.</span></p>
			<p>OOP has been widely adopted for its ability to model complex systems by encapsulating data and behavior <a id="_idIndexMarker291"/>within objects. It emphasizes code organization, reusability, and modularity. However, as enterprise applications deal with vast amounts of data and complex database interactions, a purely object-oriented approach can sometimes <span class="No-Break">be limiting.</span></p>
			<p>This is where jOOQ comes into play. jOOQ enables developers to seamlessly integrate SQL and relational database operations into their Java code. It provides a fluent, type-safe, and intuitive DSL for constructing SQL queries and interacting with databases. By embracing a data-oriented approach, jOOQ empowers developers to work directly with data structures and leverage the full power of SQL for querying, aggregating, and <span class="No-Break">transforming data.</span></p>
			<p>With jOOQ, developers can break free from the constraints of traditional ORM frameworks and gain fine-grained control over their database interactions. By embracing a data-oriented mindset, they can optimize performance, handle complex data manipulations, and take advantage of the features and optimizations offered by the underlying <span class="No-Break">database system.</span></p>
			<p>By using jOOQ, developers can tap into the benefits of OOP and data-oriented programming paradigms. They can continue to utilize the proven principles of object-oriented design for encapsulating behavior within objects while also benefiting from the efficiency and flexibility of data-oriented programming for handling large datasets and complex <span class="No-Break">database operations.</span></p>
			<p>In the following <a id="_idIndexMarker292"/>sections, we will explore the features and capabilities of jOOQ in greater detail. We will delve into the DSL provided by jOOQ for constructing SQL queries, discuss its integration with Java code, and showcase its benefits for data-driven design. Together, we will discover how jOOQ can revolutionize how we interact with databases and enable a seamless fusion of OOP and data-oriented programming in <span class="No-Break">enterprise applications.</span></p>
			<p>While jOOQ offers many benefits and advantages, it also has inevitable trade-offs. Here are some of the trade-offs associated with <span class="No-Break">using jOOQ:</span></p>
			<ul>
				<li><strong class="bold">Learning curve</strong>: jOOQ introduces a new DSL for constructing SQL queries, which requires <a id="_idIndexMarker293"/>developers to familiarize themselves with its syntax and concepts. There is a learning curve involved in understanding the intricacies of jOOQ and utilizing <span class="No-Break">it effectively.</span></li>
				<li><strong class="bold">Increased code complexity</strong>: Using jOOQ can introduce additional code complexity compared to traditional ORM frameworks or direct SQL queries. The DSL syntax and the need to map between Java objects and database records may result in more code and potential complexity, especially for complex <span class="No-Break">database interactions.</span></li>
				<li><strong class="bold">Limited database portability</strong>: jOOQ generates SQL queries based on the underlying database dialect and its specific features. While jOOQ aims to provide a unified API across different databases, some differences in supported features and behavior may still exist. It can limit the portability of code between other <span class="No-Break">database systems.</span></li>
				<li><strong class="bold">Performance considerations</strong>: While jOOQ offers efficient query construction and execution, the performance may still be influenced by factors such as database schema design, indexing, and query optimization. It is crucial to consider the performance implications of jOOQ-generated queries and optimize the database <span class="No-Break">schema accordingly.</span></li>
				<li><strong class="bold">Maintenance and upgrades</strong>: As with any third-party library, using jOOQ introduces a dependency that needs to be managed and maintained. Keeping up with new releases, compatibility with different Java versions, and resolving potential issues or bugs may require additional effort during maintenance <span class="No-Break">and upgrades.</span></li>
				<li><strong class="bold">Limited abstraction of an underlying database</strong>: Unlike ORM frameworks that provide a higher level of abstraction, jOOQ requires developers to understand SQL and <a id="_idIndexMarker294"/>the underlying database schema well. It may be a disadvantage if you prefer a more abstract approach with hidden <span class="No-Break">database-specific details.</span></li>
				<li><strong class="bold">Potential impedance mismatch</strong>: There may be cases where the object-oriented nature of the application clashes with the data-oriented approach of jOOQ. Balancing the two paradigms and maintaining consistency between the object model and the database schema can be challenging and may require careful <span class="No-Break">design considerations.</span></li>
			</ul>
			<p>While jOOQ provides powerful capabilities for data-driven programming in Java, there may be better <a id="_idIndexMarker295"/>choices in some situations. It’s essential to weigh these trade-offs against your project’s specific requirements and constraints. Consider project complexity, team experience, performance needs, and database requirements when deciding whether jOOQ is the right tool for <span class="No-Break">your application.</span></p>
			<p>When we talk about a new tool, we compare it with the one we know; thus, let’s discuss more the difference <a id="_idIndexMarker296"/>between jOOQ and the <strong class="bold">Java Persistence API</strong> (<strong class="bold">JPA</strong>) and when we should choose<a id="_idTextAnchor146"/> one over <span class="No-Break">the other.</span></p>
			<h3>JPA versus jOOQ</h3>
			<p>Both jOOQ and JPA are <a id="_idIndexMarker297"/>popular choices for database access in Java applications, but they have different approaches and use cases. Here is a comparison <a id="_idIndexMarker298"/>between the two and when you might choose one over <span class="No-Break">the other:</span></p>
			<p><span class="No-Break">jOOQ</span></p>
			<ul>
				<li><strong class="bold">SQL-centric approach</strong>: jOOQ provides a fluent DSL that allows developers to construct SQL queries in a type-safe and intuitive manner. It gives fine-grained control over <a id="_idIndexMarker299"/>the SQL statements and allows leveraging the full power of SQL. jOOQ is well suited to scenarios where complex querying, database-specific features, and performance optimizations <span class="No-Break">are essential.</span></li>
				<li><strong class="bold">Data-driven design</strong>: jOOQ embraces a data-oriented programming paradigm, making it <a id="_idIndexMarker300"/>suitable for working with large datasets and intricate database operations. It provides efficient data manipulation capabilities and allows developers to work closely with the underlying data structures. jOOQ is a good fit for applications with central data processing <span class="No-Break">and analysis.</span></li>
				<li><strong class="bold">Database-specific features</strong>: jOOQ supports various database-specific features and <a id="_idIndexMarker301"/>functions, allowing developers to take advantage of the specific capabilities offered by different database systems. It makes it a suitable choice when working closely with a particular database and using its <span class="No-Break">unique features.</span></li>
			</ul>
			<p><span class="No-Break">JPA</span></p>
			<ul>
				<li><strong class="bold">ORM</strong>: JPA focuses on mapping Java objects to relational database tables, providing a higher <a id="_idIndexMarker302"/>level of abstraction. It allows developers to work with persistent entities and automatically maps objects to database records. JPA is a good fit for applications that heavily rely on object-oriented design and require a seamless integration between objects and <span class="No-Break">the database.</span></li>
				<li><strong class="bold">Cross-database portability</strong>: JPA aims to provide a portable API that can work with <a id="_idIndexMarker303"/>different databases. It abstracts away database-specific details, allowing applications to switch between database systems with minimal code changes. JPA is a suitable choice when you need flexibility regarding the database backend and want to avoid <span class="No-Break">vendor lock-in.</span></li>
				<li><strong class="bold">Rapid application development</strong>: JPA offers features such as automatic CRUD operations, caching, and transaction management, simplifying and accelerating <a id="_idIndexMarker304"/>application development. It provides a higher level of abstraction, reducing the need for writing low-level SQL queries. JPA is beneficial when you prioritize rapid prototyping, productivity, and a focus on business logic over <span class="No-Break">database-specific optimizations.</span></li>
			</ul>
			<p>Choosing between jOOQ and JPA depends on your specific project requirements. If your application is data-intensive, requires complex querying, and needs fine-grained control over SQL, jOOQ might <a id="_idIndexMarker305"/>be a better choice. On the other hand, JPA may be the more suitable option if you prioritize object-oriented design, portability across different databases, and rapid application development. It’s also worth considering hybrid approaches where you can use both jOOQ and JPA together in different parts of your application, leveraging the strengths of each library <span class="No-Break">as needed.</span></p>
			<p>Given an introduction about jOOQ, let’s put this into practice, this time combined with Jakarta EE. This book shows Jakarta EE in several persistence frameworks; in this chapter, we’ll s<a id="_idTextAnchor147"/>how you Jakarta EE <span class="No-Break">with jOOQ.</span></p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor148"/>Using jOOQ with Jakarta/MicroProfile</h2>
			<p>In this section, we will explore the integration of jOOQ with Jakarta EE and MicroProfile, two powerful <a id="_idIndexMarker306"/>frameworks in the Java ecosystem. jOOQ, with its data-driven approach <a id="_idIndexMarker307"/>and SQL-centric capabilities, can seamlessly complement the enterprise-grade features provided by Jakarta EE and the microservices-oriented practice of MicroProfile. By combining these technologies, developers can unlock a powerful toolkit for building robust, scalable, and data-driven <span class="No-Break">Java applications.</span></p>
			<p>Jakarta EE, formerly Java EE, is a set of specifications and APIs that provides a standardized <a id="_idIndexMarker308"/>platform for building enterprise applications in Java. It offers a wide range <a id="_idIndexMarker309"/>of features, including servlets, <strong class="bold">JavaServer Faces</strong> (<strong class="bold">JSF</strong>), <strong class="bold">Enterprise JavaBeans</strong> (<strong class="bold">EJB</strong>), and JPA. Developers can leverage a mature <a id="_idIndexMarker310"/>ecosystem and industry standards with Jakarta EE to create scalable and <span class="No-Break">maintainable applications.</span></p>
			<p>On the other hand, MicroProfile is a community-driven initiative that focuses on building <a id="_idIndexMarker311"/>microservices-based <a id="_idIndexMarker312"/>applications in Java. It provides <a id="_idIndexMarker313"/>a lightweight and modular set of specifications and APIs tailored for microservice architectures. MicroProfile enables developers to leverage technologies such as JAX-RS, JSON-P, and CDI in microservices, allowing for greater flexibility <span class="No-Break">and agility.</span></p>
			<p>Combining jOOQ with Jakarta EE and MicroProfile can bring the best of both worlds to your Java applications. Here are some benefits and use cases of <span class="No-Break">this combination:</span></p>
			<ul>
				<li><strong class="bold">Enhanced database interactions</strong>: jOOQ’s SQL-centric approach allows you to write complex <a id="_idIndexMarker314"/>and optimized SQL queries <a id="_idIndexMarker315"/>directly in your Java code. It enables efficient and fine-grained control over database interactions, allowing for optimized data retrieval, updates, and analysis. Integrating jOOQ with Jakarta EE and MicroProfile will enable you to seamlessly leverage jOOQ’s powerful query-building capabilities within your enterprise or <span class="No-Break">microservices applications.</span></li>
				<li><strong class="bold">Data-driven microservices</strong>: Architectures often require efficient data access and manipulation across multiple services. Combining jOOQ with MicroProfile allows you to design microservices that leverage jOOQ’s data-driven approach for seamless database integration. It enables each microservice to independently handle its data operations, benefiting from the performance and flexibility offered by <span class="No-Break">jOOQ’s DSL.</span></li>
				<li><strong class="bold">Integration with JPA and ORM</strong>: Jakarta EE applications often utilize JPA and ORM frameworks for database interactions. By integrating jOOQ with Jakarta EE and its persistence capabilities, you can leverage the benefits of both jOOQ’s SQL-centric approach and JPA’s object-oriented design. It allows you to efficiently handle complex queries and leverage JPA’s entity management, transactions, and caching features, resulting in a powerful and flexible data <span class="No-Break">access layer.</span></li>
				<li><strong class="bold">Cross-cutting concerns and scalability</strong>: Jakarta EE and MicroProfile provide a <a id="_idIndexMarker316"/>wealth of features for cross-cutting <a id="_idIndexMarker317"/>concerns such as security, logging, and monitoring. By integrating jOOQ with these frameworks, you can leverage their capabilities to ensure consistent security policies, efficient logging, and monitoring of database interactions across your application or <span class="No-Break">microservices architecture.</span></li>
			</ul>
			<p>Throughout this section, we will explore practical examples and demonstrate how to combine jOOQ with Jakarta EE and MicroProfile effectively. We will showcase the integration of jOOQ with Jakarta EE’s Persistence API, illustrate the use of jOOQ in microservices architectures with MicroProfile, and discuss best practices for leveraging the combined power of <span class="No-Break">these technologies.</span></p>
			<p>By the end of this section, you will have a solid understanding of how to work with jOOQ, Jakarta EE, and MicroProfile together, enabling you to build robust and data-driven Java applications in enterprise and microservices contexts. Let’s dive in and explore the possibilities of this <span class="No-Break">powerful combination.</span></p>
			<p>To demonstrate the combination potential, we’ll create a simple project using Java SE with Maven, but <a id="_idIndexMarker318"/>as a highlight, we can convert this code smoothly into microservices. This <a id="_idIndexMarker319"/>project is a CRUD with a single table, <strong class="source-inline">Book</strong>, where we’ll execute operations within, as in an <span class="No-Break">executable class.</span></p>
			<p>We’ll still use a simple database project, the H2, to reduce our project’s requirements. But you can replace it on production with PostgreSQL, MariaDB, and so on. Indeed, that is the beauty of relational databases; we can change easier between databases without much impact if we compare them with <span class="No-Break">NoSQL databases:</span></p>
			<ol>
				<li>Let’s start <a id="_idIndexMarker320"/>with the configurations on the Maven project, where we’ll <a id="_idIndexMarker321"/>include <span class="No-Break">the dependencies:</span><pre class="source-code">
&lt;dependency&gt;    &lt;groupId&gt;org.jboss.weld.se&lt;/groupId&gt;    &lt;artifactId&gt;weld-se-shaded&lt;/artifactId&gt;    &lt;version&gt;${weld.se.core.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.smallrye.config&lt;/groupId&gt;    &lt;artifactId&gt;smallrye-config-core&lt;/artifactId&gt;    &lt;version&gt;2.13.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.jooq&lt;/groupId&gt;    &lt;artifactId&gt;jooq&lt;/artifactId&gt;    &lt;version&gt;3.18.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.h2database&lt;/groupId&gt;    &lt;artifactId&gt;h2&lt;/artifactId&gt;    &lt;version&gt;2.1.214&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;    &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt;    &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;</pre></li>				<li>After the Maven dependencies, the next step is to include the plugins to generate the database structure and then create the jOOQ based on this table. We’ll start the <a id="_idIndexMarker322"/>data structure and, using the plugin, we’ll execute the following query; as <a id="_idIndexMarker323"/>you’ll see, we’ll make the schema and include some books in it. We’ll not show the plugin source code; see the repository source for <span class="No-Break">more details:</span><pre class="source-code">
DROP TABLE IF EXISTS book;CREATE TABLE book (                      id INT NOT NULL,                      title VARCHAR(400) NOT NULL,                      author VARCHAR(400) NOT NULL,                      release INT,                      CONSTRAINT pk_t_book PRIMARY KEY (id));INSERT INTO book VALUES (1, 'Fundamentals of Software  Architecture', 'Neal Ford' , 2020);INSERT INTO book VALUES (2, 'Staff Engineer:  Leadership beyond the management track', 'Will    Larson' , 2021);INSERT INTO book VALUES (3, 'Building Evolutionary  Architectures', 'Neal Ford' , 2017);INSERT INTO book VALUES (4, 'Clean Code', 'Robert  Cecil Martin' , 2008);INSERT INTO book VALUES (5, 'Patterns of Enterprise  Application Architecture', 'Martin Fowler' , 2002);</pre></li>				<li>The Maven infrastructure is ready, and the next step is to define the configuration to get the connection to the database and make it available to the CDI context. We’ll combine Jakarta CDI with Eclipse MicroProfile Config and extract the properties such as the JDBC URL <span class="No-Break">and credentials.</span></li>
				<li>We’ll put this credentials information, such as the username and password, in <strong class="source-inline">microprofile-config.properties</strong>; however, remember that you should not do so with production credentials. One thing I do is overwrite those configurations <a id="_idIndexMarker324"/>by the environment. Thus, the developer will understand this at production <a id="_idIndexMarker325"/>without knowing about it; a developer knows about those properties without comprehending the production properties. This is one of the advantages of taking the <a id="_idIndexMarker326"/>implementation <a id="_idIndexMarker327"/>to the edge of the Twelve-Factor <span class="No-Break">App (</span><a href="https://12factor.net"><span class="No-Break">https://12factor.net</span></a><span class="No-Break">):</span><pre class="source-code">
@ApplicationScopedclass ConnectionSupplier {    private static final Logger LOGGER = Logger      .getLogger(ConnectionSupplier.class.getName());    private static final String URL= "db.url";    private static final String USER = "db.username";    private static final String PASSWORD =      "db.password";    private static final Config CONFIG =      ConfigProvider.getConfig();    @ApplicationScoped    @Produces    public Connection get() throws SQLException {        LOGGER.fine("Starting the database          connection");        var url = CONFIG.getValue(URL, String.class);        var password =          CONFIG.getOptionalValue(PASSWORD,            String.class).orElse("");        var user = CONFIG.getValue(USER,          String.class);        return DriverManager.getConnection(          url, user, password);    }    public void close(@Disposes Connection connection)      throws SQLException {        connection.close();        LOGGER.fine("closing the database          connection");    }}</pre></li>				<li>CDI can create and destroy bean instances in your container context. We’ll use this to develop <a id="_idIndexMarker328"/>and close connections, avoiding any connection leaks in our <a id="_idIndexMarker329"/>application. Once we have the connection, let’s create the <strong class="source-inline">DSLContext</strong> instance – this is the bridge between our data and Java, providing an easy and safe way <span class="No-Break">through </span><span class="No-Break"><strong class="source-inline">fluent-API</strong></span><span class="No-Break">:</span><pre class="source-code">
@ApplicationScopedclass ContextSupplier implements Supplier&lt;DSLContext&gt; {    private final Connection connection;    @Inject    ContextSupplier(Connection connection) {        this.connection = connection;    }    @Override    @Produces    public DSLContext get() {        return using(connection, SQLDialect.H2);    }}</pre></li>				<li>We could make both <strong class="source-inline">Connection</strong> and <strong class="source-inline">DSLContext</strong> available and handled by CDI; the <a id="_idIndexMarker330"/>next step is using both to work with the relational database. You <a id="_idIndexMarker331"/>could inject <strong class="source-inline">DSLContext</strong> as a field, but since we have created it using Java SE, we’ll create a <strong class="source-inline">SeContainer</strong> and select it, as in the <span class="No-Break">following code:</span><pre class="source-code">
try (SeContainer container =  SeContainerInitializer.newInstance().initialize()) {    DSLContext context =      container.select(DSLContext.class).get();//...}</pre></li>				<li>Are you ready for action? Let’s do a CRUD operation without creating an entity thanks to jOOQ, which, based on the database schema, will generate the data structure we can work with. The first step in the operation is the insertion. The code shows the record creation where we can set attributes and store them based on the <span class="No-Break">setter methods:</span><pre class="source-code">
BookRecord record = context.newRecord(BOOK);record.setId(random.nextInt(0, 100));record.setRelease(2022);record.setAuthor("Otavio Santana");record.setTitle("Apache Cassandra Horizontal  scalability for Java applications");record.store();</pre></li>				<li>With the data, we can read that information from the database; using fluent-API and the <strong class="source-inline">select</strong> method with the <strong class="source-inline">DSLContext</strong> class, we can do several select query operations. The query will select the books ordered by title. The <a id="_idIndexMarker332"/>advantage of this approach is that we’ll see whether the query is <a id="_idIndexMarker333"/>compatible at the application level most of the time because it won’t compile if you do any <span class="No-Break">irregular operation:</span><pre class="source-code">
Result&lt;Record&gt; books = context.select()        .from(BOOK)        .orderBy(BOOK.TITLE)        .fetch();books.forEach(book -&gt; {    var id = book.getValue(BOOK.ID);    var author = book.getValue(BOOK.AUTHOR);    var title = book.getValue(BOOK.TITLE);    var release = book.getValue(BOOK.RELEASE);    System.out.printf("Book %s by %s has id: %d and      release: %d%n",            title, author, id, release);});</pre></li>				<li>The last two steps are <strong class="source-inline">update</strong> and <strong class="source-inline">delete</strong>; you can execute the other operations, exploring the fluent-API capability. We can define as many parameters and conditions as we wish. The sample we’re using will set the <strong class="source-inline">where</strong> condition at the <span class="No-Break"><strong class="source-inline">ID</strong></span><span class="No-Break"> value:</span><pre class="source-code">
context.update(BOOK)        .set(BOOK.TITLE, "Cassandra Horizontal          scalability for Java applications")        .where(BOOK.ID.eq(randomId))        .execute();context.delete(BOOK)        .where(BOOK.ID.eq(randomId))        .execute();</pre></li>			</ol>
			<p>We could explore the <a id="_idIndexMarker334"/>whole CRUD operation based on the data without creating entities thanks to <a id="_idIndexMarker335"/>the jOOQ API. The data approach allows for generating the structure from the schema. We can guarantee that my application will work with the last entity with<a id="_idTextAnchor149"/>out needing any work. That ends our jOOQ journey <span class="No-Break">for today.</span></p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor150"/>Summary</h1>
			<p>This chapter delved into data-driven programming and its trade-offs compared to the object-oriented approach. We explored the benefits and challenges of embracing a data-driven mindset, understanding that there are scenarios where a data-oriented approach can provide unique advantages over the traditional object-oriented paradigm. We then witnessed how jOOQ, a powerful Java library, bridges the gap between OOP and data-driven programming, allowing developers to leverage the full power of SQL and data manipulation within their <span class="No-Break">Java code.</span></p>
			<p>We also examined the integration of jOOQ with Jakarta EE and MicroProfile, two frameworks widely used in developing enterprise and microservices applications. By combining these technologies, developers can take advantage of both the data-driven capabilities of jOOQ and the enterprise-grade features provided by Jakarta EE and the microservices-oriented approach of MicroProfile. This integration enables efficient database interactions, fine-grained control over SQL queries, and the ability to leverage object-oriented and data-oriented design principles in a <span class="No-Break">unified architecture.</span></p>
			<p>By combining the data-driven approach enabled by jOOQ with the enterprise-grade features of Jakarta EE and MicroProfile, and exploring the groundbreaking capabilities of MicroStream, we can take our applications to new heights of performance, scalability, and efficiency. We are on the brink of a new era in database-driven application development, where the power of data meets the speed <span class="No-Break">of execution.</span></p>
			<p>So, let’s embark on the next chapter of our journey, where we dive into the world of MicroStream and unleash the true potential of our persistence layer, Jakarta EE, and MicroProfile-powered applications. Exciting times lie ahead as we embrace this cutting-edge technology and witness the transformation it brings to our development process and the performance of <span class="No-Break">our applications.</span></p>
		</div>
	</body></html>