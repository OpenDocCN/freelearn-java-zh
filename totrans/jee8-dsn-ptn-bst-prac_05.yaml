- en: Aspect-Oriented Programming and Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向方面编程与设计模式
- en: 'In this chapter, we will look at the concept of **aspect-oriented programming**
    (**AOP**), focusing on which situations AOP should be used in, as well as how
    to achieve AOP with the use of CDI interceptors and decorators. Finally, we will
    also look at some examples of its implementation. By the end of this chapter,
    you will be able to identify a situation that requires AOP with the use of interceptors
    and decorators. Furthermore, you will also be able to identify the best approach
    to implementing these concepts. The topics covered in this chapter are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨**面向方面编程**（**AOP**）的概念，重点关注哪些情况下应该使用AOP，以及如何通过使用CDI拦截器和装饰器来实现AOP。最后，我们还将探讨其实现的一些示例。到本章结束时，你将能够使用拦截器和装饰器识别需要AOP的情况。此外，你还将能够识别实现这些概念的最佳方法。本章涵盖的主题如下：
- en: Aspect-oriented programming
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向方面编程
- en: AOP in a JEE scenario – the interceptor
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JEE场景中的AOP – 拦截器
- en: EJB interceptor implementation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EJB拦截器实现
- en: CDI interceptor implementation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDI拦截器实现
- en: The decorator pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: The decorator pattern in a JEE scenario
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JEE场景中的装饰器模式
- en: Decorator implementation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器实现
- en: Aspect-oriented programming
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向方面编程
- en: AOP is a programming paradigm that allows us to separate business logic from
    some technical code that crosscuts all applications. In other words, AOP allows
    the separation of crosscutting concerns. We will encounter crosscutting code when
    we input the logging code in certain methods to show technical support information.
    We also encounter it when we input statistic code to see how many times a method
    calls or who the user using the application is, or even for exception and error
    handling. We see this kind of code in almost all parts of an application—it is
    code that is repeated along the whole application. This kind of code has its own
    objectives and concerns, and it is a very good idea to separate it from the business
    code, which is related to the application use cases.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: AOP是一种编程范式，它允许我们将业务逻辑与跨越所有应用程序的一些技术代码分离。换句话说，AOP允许分离横切关注点。当我们向某些方法中输入日志代码以显示技术支持信息时，我们会遇到横切代码。我们也会在输入统计代码以查看方法被调用多少次或使用应用程序的用户是谁，或者甚至用于异常和错误处理时遇到它。我们在应用程序的几乎所有部分都能看到这种代码——这是在整个应用程序中重复的代码。这种代码有其自己的目标和关注点，将其从与应用程序用例相关的业务代码中分离出来是一个非常好的主意。
- en: These aspects of the system (such as logging or exception handling) are very
    difficult to implement in a modular way. What we are saying here is that we don't
    want to mix these aspects with business code. By mixing these two types of code,
    we are left with a final code that is more difficult to maintain.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统方面（如日志或异常处理）在模块化实现中非常困难。我们在这里说的是，我们不希望将这些方面与业务代码混合。通过混合这两种类型的代码，我们得到的是一个更难维护的最终代码。
- en: With AOP, we can join or add an executable code to our source code without changing
    it, meaning that the source code remains intact. As we said, if we want to log
    a method, for instance, then we can do that without disrupting our business code
    with a service code, such as the logging service.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AOP，我们可以在不改变源代码的情况下添加或连接可执行代码，这意味着源代码保持完整。正如我们所说，如果我们想记录一个方法，例如，我们可以那样做而不破坏我们的业务代码，比如使用日志服务这样的服务代码。
- en: Compile-time versus run-time AOP
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译时与运行时AOP
- en: AOP is achieved through code injection during compile-time or runtime.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: AOP是通过编译时或运行时代码注入来实现的。
- en: Frameworks that implement AOP at compile-time change the binary code (the `.class` file),
    so when the interceptor code is injected, we are left with a `.class` file that
    is different from the `.class` that would be generated without the injection code.
    The resulting `.class` file then becomes incompatible with the source code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时实现AOP的框架会改变二进制代码（即`.class`文件），因此当拦截器代码被注入时，我们得到的是一个与未注入代码生成的`.class`文件不同的`.class`文件。结果`.class`文件与源代码不兼容。
- en: On the other hand, the run-time injection does not modify either the source
    code or the `.class` file. In this case, the interception method is done in a
    separate code from the class or place that contains the method. As a consequence,
    the interception codes that are executed before and after the method's original
    call are found in another class.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，运行时注入不会修改源代码或`.class`文件。在这种情况下，拦截方法是在包含方法的类或位置之外的单独代码中完成的。因此，在方法原始调用之前和之后执行的拦截代码位于另一个类中。
- en: Java does not offer a built-in solution for AOP, but some third-party frameworks,
    such as Eclipse AspectJ and Spring, are widely used in Java applications. We could
    use Eclipse AspectJ, for instance, to implement AOP. Eclipse AspectJ is a seamless
    aspect-oriented extension to the Java programming language. It is a Java platform
    that is compatible and easy to use. However, JEE implements AOP using a new idea
    concept known as an **interceptor**, and we will see how this functions in the
    following section. All JEE programmers can have AOP using interceptors, without
    it being necessary to get the JAR's dependency related to the AspectJ solution
    and putting this into our application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Java没有提供AOP的内置解决方案，但一些第三方框架，如Eclipse AspectJ和Spring，在Java应用程序中得到了广泛使用。例如，我们可以使用Eclipse
    AspectJ来实现AOP。Eclipse AspectJ是Java编程语言的无缝面向方面扩展。它是一个兼容且易于使用的Java平台。然而，JEE使用一种称为**拦截器**的新概念来实现AOP，我们将在下一节中看到它是如何工作的。所有JEE程序员都可以使用拦截器来实现AOP，而不需要获取与AspectJ解决方案相关的JAR依赖项并将其放入我们的应用程序中。
- en: AOP in JEE scenario – the interceptor
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JEE场景中的AOP – 拦截器
- en: Aspect-oriented software development enables the clean modularization of crosscutting
    concerns. For the benefit of all JEE programmers, we can also separate business
    code from crosscutting concerns, which is a solution that the interceptor technologies
    offer by implementing JEE.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 面向方面的软件开发使得对横切关注点的清晰模块化成为可能。为了所有JEE程序员的利益，我们还可以将业务代码与横切关注点分离，这是拦截器技术通过实现JEE提供的解决方案。
- en: When an EJB method or a managed bean is called and there is an interceptor associated
    with this call (we will see how this is implemented soon), we can write a code
    to be executed immediately before the method calls and also just after the method
    calls (that is, after the return of the method).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用EJB方法或托管Bean时，如果与此调用关联有拦截器（我们很快将看到它是如何实现的），我们可以在方法调用之前和之后（即方法返回之后）编写要立即执行的代码。
- en: 'Intercepting filter patterns is another pattern that is used for intercepting
    a request. In JEE, we can implement the filter pattern using web filters and servlets.
    By using a web filter, a Java web application implements the interception of web
    requests and responses. The web application can intercept the request, fulfill
    an action, and also intercept the response. The following list contains several
    examples of filters that have many actions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截过滤器模式是另一种用于拦截请求的模式。在JEE中，我们可以使用Web过滤器和Servlet实现过滤器模式。通过使用Web过滤器，Java Web应用程序实现了对Web请求和响应的拦截。Web应用程序可以拦截请求，执行操作，也可以拦截响应。以下列表包含了一些具有许多操作的过滤器示例：
- en: Authentication/authorization filters
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证/授权过滤器
- en: Logging and auditing filters
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志和审计过滤器
- en: Image conversion filters
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像转换过滤器
- en: Data compression filters
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据压缩过滤器
- en: Encryption filters
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密过滤器
- en: Tokenizing filters
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分词过滤器
- en: The interceptor acts as a filter, and therefore we can consider a web filter
    as an interceptor. However, this mechanism is related to web requests and responses. We
    will not talk about this type of interception in this chapter. Instead, we will
    cover the interceptor patterns that are used in managed beans—that is, the EJB
    interceptor, the CDI beans interceptor, and a kind of business logic interceptor
    referred to as *the decorator*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器充当过滤器的作用，因此我们可以将Web过滤器视为拦截器。然而，这种机制与Web请求和响应相关。在本章中，我们不会讨论这种类型的拦截。相反，我们将介绍在托管Bean中使用的拦截器模式，即EJB拦截器、CDI
    Bean拦截器以及一种称为*装饰器*的业务逻辑拦截器。
- en: A brief word about CDI and beans
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简要介绍CDI和Bean
- en: We are presuming that the reader knows the basic characteristics that surround
    the CDI, as well as its main objectives and uses. However, it is very important
    to emphasize some definitions and aspects of the CDI.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设读者已经了解围绕CDI的基本特征，以及其主要目标和用途。然而，强调CDI的一些定义和方面非常重要。
- en: The CDI technology is one of the pillars of the JEE platform, and it is present
    in most of its services. This means that these services depend in some way on
    the CDI mechanism—CDI is closely related to the bean concept within the EE specification,
    so let's take a look at what a bean actually is.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: CDI技术是JEE平台的一个支柱，它存在于其大多数服务中。这意味着这些服务以某种方式依赖于CDI机制——CDI与EE规范中的bean概念密切相关，因此让我们看看bean实际上是什么。
- en: The bean
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 豆类
- en: The idea of a bean is quite generic. Here, we are not talking about the concept
    of JavaBeans, with the getters and setters access method. Instead, we are talking
    about the concept of the bean as a web component or business component. In this
    scenario, we encounter several types of beans, such as Java classes in web and
    JEE-related beans, such as EJB beans and JSF-managed beans. There are even some third-party
    frameworks outside of the JEE specification (such as Spring) that have a different
    concept of the bean. The concept of a JEE bean is known as a **managed bean**,
    which is managed by a container that requires little intervention by the programmer
    and has a well-defined life cycle. As well as this, a managed bean can provide
    mechanisms for intercepting its execution and life cycle callback methods, and
    can be injected into other beans or JEE objects.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: bean的概念相当通用。在这里，我们不是在谈论JavaBeans的概念，即带有getters和setters访问方法的概念。相反，我们是在谈论bean作为Web组件或业务组件的概念。在这种情况下，我们会遇到几种类型的bean，例如Web和JEE相关的Java类，如EJB
    bean和JSF托管bean。甚至还有一些JEE规范之外的第三方框架（如Spring）对bean有不同的概念。JEE bean的概念被称为**托管bean**，它由容器管理，需要程序员很少的干预，并且具有明确的生命周期。此外，托管bean可以提供拦截其执行和生命周期回调方法的机制，并且可以被注入到其他bean或JEE对象中。
- en: 'Consequently, an object that has a well-defined life cycle context can be considered
    a bean or a managed bean. In other words, a managed bean is a component that the
    container constructs and destroys (as part of managing its life cycle). CDI includes
    built-in support for several different kinds of bean. The following Java EE components
    can be injected:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，具有良好定义的生命周期上下文的对象可以被视为一个bean或一个托管bean。换句话说，托管bean是容器构建和销毁（作为管理其生命周期的一部分）的组件。CDI为几种不同类型的bean提供了内置支持。以下Java
    EE组件可以注入：
- en: '**Managed beans**: EJB session beans, classes annotated with `@ManagedBean`,
    decorators, and classes that conform to the CDI rules for becoming a managed bean'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**托管bean**：EJB会话bean、使用`@ManagedBean`注解的类、装饰器以及符合CDI规则成为托管bean的类'
- en: '**Java EE resources**: Resources that can be referenced from the component
    environment naming space'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java EE资源**：可以从组件环境命名空间引用的资源'
- en: '**Arbitrary objects**:Objects that are returned by producer methods and fields'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任意对象**：由生产者方法和字段返回的对象'
- en: Managed beans may also inject other beans.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 托管bean也可以注入其他bean。
- en: '**Obs:** The JSF specification also describes a technology known as managed
    beans. These managed beans are different from the ones we describe here. The Java
    EE foundational managed beans are a generalization of the JSF ones, and are not
    limited to web modules.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：JSF规范还描述了一种称为托管bean的技术。这些托管bean与我们这里描述的不同。Java EE基础托管bean是JSF的一个泛化，并不限于Web模块。'
- en: 'There are other objects from the JEE platform (such as the servlet and interceptor
    objects) that are not classified as JEE beans, and which may have injected beans
    via the CDI mechanism. The JEE platform components that may have beans injected
    are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: JEE平台还有其他对象（如servlet和拦截器对象）不被归类为JEE bean，并且可能通过CDI机制注入bean。可能注入bean的JEE平台组件如下：
- en: Servlets (including servlet filters and servlet event listeners)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Servlets（包括Servlet过滤器和服务监听器）
- en: JSP tag handlers and tag library event listeners
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSP标签处理器和标签库事件监听器
- en: JSF scope-managed beans
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSF作用域托管bean
- en: JAX–RS components
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAX-RS 组件
- en: JAX–WS service endpoints and handlers
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAX-WSS服务端点和处理器
- en: WebSocket endpoints
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket端点
- en: Managed beans in CDI
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CDI中的托管bean
- en: 'There are several ways to declare a Java class as a managed bean. For example,
    if we annotate a class with `@ManageBean`, it is defined as a managed bean. However,
    the CDI specification insists that a class has to be considered as a managed bean
    according to certain criteria. These criteria are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以将Java类声明为托管bean。例如，如果我们使用`@ManageBean`注解一个类，它就被定义为托管bean。然而，CDI规范坚持认为，一个类必须根据某些标准被视为托管bean。这些标准如下：
- en: It is not a nonstatic inner class
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不是一个非静态内部类
- en: It is a concrete class or it is annotated with `@Decorator`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个具体类，或者它被`@Decorator`注解
- en: It is not an EJB component
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不是一个EJB组件
- en: It does not implement `javax.enterprise.inject.spi.Extension`
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不实现`javax.enterprise.inject.spi.Extension`
- en: It either has a `no-argument` constructor, or declares a constructor annotated
    with `@Inject`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它要么有一个无参构造函数，要么声明了一个带有`@Inject`注解的构造函数
- en: Loose coupling
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松散耦合
- en: Some of the objectives of using patterns in the JEE context are to reduce the
    coupling between classes on different layers—or even on the same layer—as well
    as the code reuse (that is, the use of some existing code that provides a certain
    functionality). With these two objectives, we are able to improve software maintenance
    and quality. But how?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在JEE上下文中使用模式的一些目标是为了减少不同层之间——甚至同一层——的类之间的耦合，以及代码重用（即使用提供一定功能的现有代码）。有了这两个目标，我们能够提高软件维护和质量。但如何做到呢？
- en: Loose coupling allows programmers to fix bugs or to develop new functionalities
    in a layer with minimum impact on the other layers. In addition, with every tested
    code, methods of special beans or objects may be called from different parts of
    an application, thereby improving software organization and clarity. As a result
    of this, software quality is improved and development time decreased.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 松散耦合允许程序员在最小影响其他层的情况下，在一个层中修复错误或开发新的功能。此外，随着每一段测试过的代码，可以从应用程序的不同部分调用特殊豆或对象的方法，从而提高软件组织和清晰度。因此，软件质量得到提升，开发时间减少。
- en: As we know, loose coupling makes the code easier to maintain.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，松散耦合使代码更容易维护。
- en: In fact, the CDI provides loose coupling. In addition, the CDI works in a strong,
    safe way using qualifier annotations instead of string identification.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，CDI提供了松散耦合。此外，CDI使用资格注解而不是字符串标识符，以强大、安全的方式工作。
- en: 'In JEE, the use of events, interceptors, and decorators provides loose coupling,
    as described in the following list:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在JEE中，使用事件、拦截器和装饰器提供松散耦合，如下列所示：
- en: '**Event notifications**: Establish a decoupling between event-generating clients
    and event listeners (observers)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件通知**：在事件生成客户端和事件监听器（观察者）之间建立解耦'
- en: '**Interceptors**: Separate technical concerns from business logic'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拦截器**：将技术关注点与业务逻辑分离'
- en: '**Decorators**: Allow business concerns to be extended (adding business functionality
    to existing ones)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰器**：允许扩展业务关注点（向现有业务功能添加业务功能）'
- en: In this chapter, we will see how the interceptors and decorators achieve this
    goal.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到拦截器和装饰器如何实现这一目标。
- en: Interceptors in the JEE platform
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JEE平台中的拦截器
- en: 'An Oracle tutorial defines an interceptor as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Oracle教程将拦截器定义为如下：
- en: '"*An interceptor is a class used to interpose in invocation **methods **or
    life cycle events that occur in an associated target class."*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '"*拦截器是一个用于在关联的目标类中插入调用**方法**或生命周期事件的类。"*'
- en: As previously mentioned, interceptors are generally used for technical tasks,
    referred to as cross-cutting tasks. This includes auditing, logging, controlling statistics,
    and so on. These tasks are separate from the business logic, and may be repeated
    over the entire application. Consequently, we can put the interceptor code into
    a separate class that is different from the target class that we want to intercept
    in order to improve code maintenance.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，拦截器通常用于技术任务，称为横切任务。这包括审计、记录、控制统计等。这些任务与业务逻辑分开，并且可能在整个应用程序中重复。因此，我们可以将拦截器代码放入一个与我们要拦截的目标类不同的单独类中，以提高代码维护性。
- en: The concept of the interceptor was first introduced in JEE5, and it was only
    used for EJBs (session beans and message-driven beans). With the introduction
    of **context and dependency injection** (**CDI**) in JEE6, the interceptors were
    extended to all managed beans—that is, to beans that meet the CDI-managed bean.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器的概念首次在JEE5中引入，并且最初仅用于EJB（会话Bean和消息驱动Bean）。随着JEE6中**上下文和依赖注入**（**CDI**）的引入，拦截器被扩展到所有托管Bean——即满足CDI托管Bean的Bean。
- en: Interceptor methods are invoked on an associated target class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器方法在关联的目标类上被调用。
- en: We can define an interceptor within the target class as an interceptor method,
    or we can define an interceptor in a separate class (called an **interceptor class**)
    that contains the interceptor method. Interceptor methods are always invoked when
    a target class method is annotated to be intercepted and is then invoked, or when
    a life cycle callback method is intercepted (such as before the construction or
    after the destruction of a bean). It is important to note that for simple applications,
    we can put interceptors in the target class. However, for a more complex application,
    or for when the application grows in complexity, we should put the interceptor
    in a separate class.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在目标类内部定义一个拦截器作为拦截器方法，或者我们可以在一个单独的类（称为**拦截器类**）中定义拦截器，该类包含拦截器方法。拦截器方法总是在目标类方法被注解为需要拦截并被调用时，或者当生命周期回调方法被拦截（例如在bean构造或销毁之前）时被调用。需要注意的是，对于简单的应用，我们可以在目标类中放置拦截器。然而，对于更复杂的应用，或者当应用变得复杂时，我们应该将拦截器放在一个单独的类中。
- en: Each element that you want to intercept is called an **advice**. We say that
    an interceptor decorates the advice, and each time an advice is called, an interceptor
    code is executed (if it exists). The location of the point where this code is
    executed is called the **pointcut**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个你想拦截的元素被称为**建议**。我们说拦截器装饰了建议，每次建议被调用时，都会执行拦截器代码（如果存在）。此代码执行点的位置被称为**切入点**。
- en: Interceptor methods on an associated target class are invoked when advice target
    class methods are invoked, or when there is a life cycle event and the life cycle
    callback method related to the event is called.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当建议目标类的方法被调用，或者当有生命周期事件并且与事件相关的生命周期回调方法被调用时，将调用关联的目标类上的拦截器方法。
- en: 'The following figure shows an interceptor sequence diagram:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了拦截器序列图：
- en: '![](img/615b4cb0-2b60-4df4-9678-d88895353e5d.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/615b4cb0-2b60-4df4-9678-d88895353e5d.png)'
- en: This sequence diagram shows a chain of interceptors. When a client calls a business
    method and there is a chain of interceptors associated with it, the first interceptor
    is called and does something (that is, this first interceptor method's code is
    executed), then calls the second interceptor explicitly, and so on. This continues
    until the last interceptor in the chain calls the bean's business method. We will
    see how this call is made later. For now, we can say that an element of the chain
    of interceptors calls the next element in the same way until the last element—which
    is the business method of the managed bean itself—is invoked.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此序列图显示了拦截器链。当客户端调用业务方法并且与之关联有一个拦截器链时，首先调用第一个拦截器并执行某些操作（即，执行此第一个拦截器方法的代码），然后显式调用第二个拦截器，依此类推。这个过程一直持续到链中的最后一个拦截器调用托管bean的业务方法。我们将在稍后看到这个调用是如何进行的。现在，我们可以这样说，拦截器链中的每个元素以相同的方式调用下一个元素，直到最后一个元素——即托管bean本身的业务方法被调用。
- en: 'We can define interceptor classes and interceptor methods using annotations,
    or, alternatively, we can define the deployment descriptor of the application.
    However, in this section, we will only cover the use of annotations. The following
    table shows the annotations used in interceptor methods that define the condition
    or when the interception occurs:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用注解来定义拦截器类和拦截器方法，或者，作为替代，我们可以定义应用的部署描述符。然而，在本节中，我们只将涵盖注解的使用。以下表格显示了在拦截器方法中使用的注解，这些注解定义了拦截的条件或拦截发生的时间：
- en: '| **Interceptor annotation** | **Description** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **拦截器注解** | **描述** |'
- en: '| `javax.interceptor.AroundConstruct` | This defines an intercept method that
    receives a callback when the constructor of the target class is invoked |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `javax.interceptor.AroundConstruct` | 这定义了一个在目标类构造函数被调用时接收回调的拦截方法 |'
- en: '| `javax.interceptor.AroundInvoke` | This defines an intercept method that
    is executed when a method of the target class that is marked to be intercepted with
    an annotation is invoked |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `javax.interceptor.AroundInvoke` | 这定义了一个拦截方法，当目标类中被标记为需要通过注解进行拦截的方法被调用时执行
    |'
- en: '| `javax.interceptor.AroundTimeout` | This defines an interceptor method that
    interposes on timeout methods |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `javax.interceptor.AroundTimeout` | 这定义了一个拦截超时方法的拦截器方法 |'
- en: '| `javax.annotation.PostConstruct` | This defines an interceptor method for
    post-construct life cycle events |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `javax.annotation.PostConstruct` | 这定义了一个用于后构造生命周期事件的拦截器方法 |'
- en: '| `javax.annotation.PreDestroy` | This defines an interceptor method for predestroy
    life cycle events |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `javax.annotation.PreDestroy` | 这定义了一个用于预销毁生命周期事件的拦截器方法 |'
- en: EJB interceptor implementation
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EJB拦截器实现
- en: In this section, we will look at an example of the original EJB interceptor
    implementation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看一个原始EJB拦截器实现的示例。
- en: Suppose that there is a stateless session EJB, such as `AcademicFacadeImpl`,
    as well as a business method called `testReview`. This method is responsible for
    scheduling a student test review. Let's say that we want to know, statistically,
    which students have made the most test review requests. We could do this within
    the business code, but that is not what we want. Instead, we want to separate
    statistic logic from business logic statistics—we want a statistic interceptor.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设存在一个无状态会话EJB，例如`AcademicFacadeImpl`，以及一个名为`testReview`的业务方法。这个方法负责安排学生测试复习。假设我们想从统计学的角度知道哪些学生提出了最多的测试复习请求。我们可以在业务代码中这样做，但这不是我们想要的。相反，我们希望将统计逻辑与业务逻辑分开——我们希望有一个统计拦截器。
- en: 'First of all, we will create an EJB target class named `AcademicFacadeImpl` (this
    class was already created in the last chapter). In the beginning, there is no
    interceptor reference, as shown in the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个名为`AcademicFacadeImpl`的EJB目标类（这个类已经在上一章中创建过）。一开始，没有拦截器引用，如下代码所示：
- en: '[PRE0]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So, we define an interceptor using one of the interceptor annotations listed
    in the previous table. This can be found within the target class or in a separate
    interceptor class. The following code shows an `@AroundInvoke` interceptor method
    declared in the target class:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用前表中列出的拦截器注解之一来定义一个拦截器。这个拦截器可以在目标类内部或单独的拦截器类中找到。以下代码展示了在目标类中声明的`@AroundInvoke`拦截器方法：
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, we can use a separate interceptor class. We may apply the `@Interceptor` annotation,
    but interceptor classes do not have to be annotated. An interceptor class must
    have a `public` and `no-argument` constructor. The following code shows an interceptor
    class with an `@Interceptor` and `@AroundInvoke` interceptor method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用一个单独的拦截器类。我们可以应用`@Interceptor`注解，但拦截器类不必注解。拦截器类必须有一个`public`和`无参数`的构造函数。以下代码展示了带有`@Interceptor`和`@AroundInvoke`拦截器方法的拦截器类：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we use the CDI event API. This API is used to implement an
    event-firing mechanism. Basically, this uses a bean to fire an event, and one
    or more beans observe this firing. This mechanism is implemented from an `Event`
    class object, as shown in the code. We use a `String` type to qualify the event,
    but we could use any other type, or use qualifiers to qualify our event.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用CDI事件API。这个API用于实现事件触发机制。基本上，它使用一个bean来触发事件，一个或多个bean观察这个触发。这个机制是从一个`Event`类对象实现的，如下代码所示。我们使用`String`类型来限定事件，但我们可以使用任何其他类型，或者使用限定符来限定我们的事件。
- en: We can also see the `InvocationContext` object that is a parameter of the `statisticMethod`
    method. This object provides information about the context of the intercepted
    invocation. In addition, this object has methods for controlling the chain interceptor.
    For example, the `proceed` method calls the next interceptor in the interceptor
    chain, or the intercepted method of the business object. We will learn more about `InvocationContext`
    later.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到`statisticMethod`方法的参数`InvocationContext`对象。这个对象提供了关于拦截调用上下文的信息。此外，这个对象有控制链式拦截器的方法。例如，`proceed`方法调用拦截器链中的下一个拦截器，或者业务对象的拦截方法。我们将在后面了解更多关于`InvocationContext`的信息。
- en: 'Next, we must use the `@Interceptors` annotation to define at least one interceptor.
    We can define interceptors at the class or method level of the target class by
    indicating whether we want to intercept all the business methods or just some
    specific business methods. The following code shows only one interceptor declared
    at the class level:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须使用`@Interceptors`注解定义至少一个拦截器。我们可以在目标类的类或方法级别定义拦截器，通过指定我们是否想拦截所有业务方法或只是某些特定的业务方法。以下代码仅展示了在类级别声明的一个拦截器：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following code declares the same interceptor, but at the method level:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码声明了相同的拦截器，但位于方法级别：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will put `@Interceptors` at the method level. This is because we don't want
    to intercept all other EJB methods.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在方法级别放置`@Interceptors`。这是因为我们不想拦截所有其他EJB方法。
- en: 'Finally, we must create a class that will observe the statistical event. This
    class will handle statistical issues. This is shown in the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须创建一个将观察统计事件的类。这个类将处理统计问题。如下代码所示：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When the `requestTestReview` method of the `AcademicFacadeImpl` class is called,
    it is intercepted (this method is marked with an interceptor), so the `statisticMethod`
    method of the `StatisticInterceptor` class is called. During the execution of
    this method, a statistical event is triggered. The purpose here is to perform
    statistical control asynchronously for execution of the business method.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`AcademicFacadeImpl`类的`requestTestReview`方法时，它会被拦截（此方法带有拦截器标记），因此会调用`StatisticInterceptor`类的`statisticMethod`方法。在执行此方法期间，会触发一个统计事件。这里的目的是对业务方法的执行进行异步的统计控制。
- en: 'As an alternative, we could convert the `StatisticalFacadeImpl` into an EJB
    and annotate the `control` method with `@Asynchronous`. As a result, we would
    not have to fire a statistical event, and instead, we could call the following
    asynchronous method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种替代方案，我们可以将`StatisticalFacadeImpl`转换为EJB，并使用`@Asynchronous`注解`control`方法。结果，我们就不必触发统计事件，而是可以调用以下异步方法：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Intercepting method invocation
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拦截方法调用
- en: If we want a specific method to be a pointcut, we have to annotate it with the `@AroundInvoke` annotation.
    The `@AroundInvoke` method (or the pointcut method) must* return an object*, and
    must have a parameter of the `InvocationContext` type. As well as this, the pointcut
    method should *throw an exception*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让一个特定方法成为切入点，我们必须使用`@AroundInvoke`注解它。`@AroundInvoke`方法（或切入点方法）必须*返回一个对象*，并且必须有一个`InvocationContext`类型的参数。此外，切入点方法应该*抛出异常*。
- en: The `InvocationContext` methods can be called in order to access information about
    the current context, such as the name of the pointcut, the method annotations,
    the method parameters, and so on. However, it is important to note that in an
    interception situation, the target class method is invoked only when the `@AroundInvoke`
    method calls the `proceed` method. As a result, the `@AroundInvoke` method must
    call the `proceed` method in order to invoke the target class method. In the case
    of the chain of interceptors, every time an EJB business method is called, each
    `@AroundInvoke` method of each chain interceptor is called in the order that is
    configured for them (via `@Interceptors`) until the target class method is invoked.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 可以调用`InvocationContext`方法来访问有关当前上下文的信息，例如切入点的名称、方法注解、方法参数等。然而，重要的是要注意，在拦截情况下，只有当`@AroundInvoke`方法调用`proceed`方法时，目标类方法才会被调用。因此，`@AroundInvoke`方法必须调用`proceed`方法来调用目标类方法。在拦截器链的情况下，每次调用EJB业务方法时，每个链拦截器的每个`@AroundInvoke`方法都会按照它们配置的顺序（通过`@Interceptors`）被调用，直到调用目标类方法。
- en: These `@AroundInvoke` interceptor methods can have any of the access-level modifiers—public,
    protected, private, or package. However, the methods must not be static or final. Keep
    in mind that only one `@AroundInvoke` interceptor method per class is permitted.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`@AroundInvoke`拦截器方法可以具有任何访问级别修饰符——公共的、受保护的、私有的或包级别的。然而，方法不能是静态的或最终的。请记住，每个类只允许有一个`@AroundInvoke`拦截器方法。
- en: '`AroundInvoke` interceptor methods have the following form:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`AroundInvoke`拦截器方法具有以下形式：'
- en: '`@AroundInvoke`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`@AroundInvoke`'
- en: '`[public, protected, private or package-level ] Object method-name (InvocationContext)
    throws Exception { ...}`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`[public, protected, private or package-level ] Object method-name (InvocationContext)
    throws Exception { ...}`'
- en: Only one `AroundInvoke` interceptor method per class is allowed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类只允许有一个`AroundInvoke`拦截器方法。
- en: Another important thing to keep in mind is that an `AroundInvoke` interceptor can
    have the same transaction context as the target method.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要记住的重要事情是，`AroundInvoke`拦截器可以与目标方法具有相同的事务上下文。
- en: Interceptor class and multiple method interceptors
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拦截器类和多个方法拦截器
- en: Having an interceptor in a separate class improves code maintenance by providing
    a clear division of responsibilities between classes, meaning that the classes
    become more cohesive. In addition, interceptor classes may have resources and
    managed beans injected into them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在单独的类中拥有拦截器可以通过在类之间提供清晰的职责划分来提高代码维护性，这意味着类变得更加紧密。此外，拦截器类可能被注入资源和托管Bean。
- en: Another important factor worth mentioning is that the interceptor method belongs
    to the same EJB transaction context. So, whenever we want to intercept a business
    logic to do a technical task, such as logging or statistic persistence, we must
    take care. For instance, we don't want any errors to be thrown during statistic
    control, thereby generating a business transaction rollback.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的重要因素是，拦截器方法属于同一个 EJB 事务上下文。因此，每次我们想要拦截业务逻辑以执行技术任务，例如日志记录或统计持久化时，我们必须小心。例如，我们不希望在统计控制期间抛出任何错误，从而生成业务事务回滚。
- en: In this case, we should perform asynchronous statistic controlling. This would
    guarantee that any eventual error would occur in a new transaction, separate from
    the current transaction. So, it is essential that good software design and strong
    business knowledge are achieved before coding.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们应该执行异步统计控制。这将保证任何最终错误都会在一个新的事务中发生，与当前事务分离。因此，在编码之前实现良好的软件设计和强大的业务知识是至关重要的。
- en: Interceptor classes may have resources and managed beans injected into them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器类可以注入资源和托管 Bean。
- en: 'The `@Interceptors` annotation is used to inject one or more interceptors into
    the EJB target class or into the EJB target method. See the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Interceptors` 注解用于将一个或多个拦截器注入到 EJB 目标类或 EJB 目标方法中。请参见以下代码：'
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The interceptors are invoked in the order in which they were defined within
    the `@Interceptors` annotation. However, if the interceptors are also defined
    in the deployment descriptor, this order can be overridden. Consequently, if there
    is an interceptor chain, an interceptor calls the next one by invoking the `InvocationContext.proceed`
    method within the order specified in `@Interceptors`. This continues until the
    business method is invoked.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器按照在 `@Interceptors` 注解中定义的顺序被调用。然而，如果拦截器也在部署描述符中定义，则可以覆盖此顺序。因此，如果存在拦截器链，拦截器将按照
    `@Interceptors` 中指定的顺序通过调用 `InvocationContext.proceed` 方法来调用下一个拦截器。这将继续，直到调用业务方法。
- en: The interceptor class is referenced in the EJB target class, which causes the
    target class to discover the interceptor class. This situation establishes a coupling
    between both classes. We will cover how the CDI interceptor mechanism corrects
    this situation later.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器类在 EJB 目标类中被引用，这导致目标类发现拦截器类。这种情况在两个类之间建立了耦合。我们将在稍后介绍 CDI 拦截器机制如何纠正这种情况。
- en: Intercepting life cycle callback events
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拦截生命周期回调事件
- en: The interceptor methods that are used for the life cycle callback events (`AroundConstruct`,
    `PostConstruct`, and `PreDestroy`) follow the same model for implementing the
    interceptors as previously described in regards to location. This may be defined
    in the target class, in interceptor classes, or in both classes. In this chapter,
    we will only see examples of `PostConstruct` and `PreDestroy` callback events.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 用于生命周期回调事件（`AroundConstruct`、`PostConstruct` 和 `PreDestroy`）的拦截器方法遵循与之前描述的拦截器实现模型相同的模式，关于位置方面。这可以在目标类、拦截器类或两个类中定义。在本章中，我们将仅看到
    `PostConstruct` 和 `PreDestroy` 回调事件的示例。
- en: As described in the previous table containing the interceptor annotations, a
    method with the `@PostConstruct` annotation is used to intercept the `PostConstruct`
    life cycle event, and a method with a `@PreDestroy` annotation is used to intercept
    the `PreDestroy` life cycle event. Intercepting classes have the same life cycle
    as the target classes. This means that when an instance of the target class is
    created, an interceptor object is also created for each declaration of the interceptor
    class in the target class.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如前表中的拦截器注解所述，带有 `@PostConstruct` 注解的方法用于拦截 `PostConstruct` 生命周期事件，而带有 `@PreDestroy`
    注解的方法用于拦截 `PreDestroy` 生命周期事件。拦截器类具有与目标类相同的生命周期。这意味着当目标类的一个实例被创建时，目标类中每个拦截器类的声明都会创建一个拦截器对象。
- en: 'However, there is another way to approach this. We can define callback methods
    for life cycle events and define interceptor methods for these callback methods.
    So what we really want is to intercept a callback method. The callback method for
    a life cycle event within the target class (or a life cycle event interceptor
    on the target class side) has the following syntax:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有另一种方法可以解决这个问题。我们可以为生命周期事件定义回调方法，并为这些回调方法定义拦截器方法。因此，我们真正想要拦截的是回调方法。目标类内部的生命周期事件回调方法（或目标类侧的生命周期事件拦截器）具有以下语法：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'An example of this could be the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这的例子可能是以下内容：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The interceptor method for this callback  method defined in an interceptor
    class (or a life cycle event interceptor on the interceptor class side) has the
    following syntax:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在拦截器类中定义的此回调方法（或在拦截器类侧的生命周期事件拦截器）的拦截器方法具有以下语法：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'An example could be the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可能是以下内容：
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can define callback methods for life cycle events (`AroundConstruct`, `PostConstruct`,
    and `PreDestroy`) and we can also define interceptor methods for these callback
    methods.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义生命周期事件（`AroundConstruct`、`PostConstruct`和`PreDestroy`）的回调方法，我们也可以为这些回调方法定义拦截器方法。
- en: When testing various situations, we noticed some interesting things.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试各种情况时，我们注意到一些有趣的事情。
- en: For the `@Interceptors` at class level, if both methods for the same life cycle
    event are defined in both the target class and interceptor class, then only the
    callback interceptor is called. However, if there is an explicit invocation of
    `InvocationContext.proceed` inside the callback interceptor, then the callback
    method in the target class is also called. Let's see what happens when we annotate
    both the EJB class and the `Interceptor` class with the `@PostConstruct` annotation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类级别的`@Interceptors`，如果目标类和拦截器类中定义了同一生命周期事件的两个方法，那么只调用回调拦截器。然而，如果在回调拦截器内部显式调用了`InvocationContext.proceed`，则目标类中的回调方法也会被调用。让我们看看当我们用`@PostConstruct`注解同时注解EJB类和`Interceptor`类时会发生什么。
- en: 'The following code shows the `initialize` method (which has a `@PostConstruct`)
    of the EJB `AcademicFacadelImpl` class:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码显示了EJB `AcademicFacadelImpl`类的`initialize`方法（它有一个`@PostConstruct`注解）：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following code shows the `initialize` method (which has a `@PostConstruct`) of
    the `Interceptor` class:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码显示了`Interceptor`类的`initialize`方法（它有一个`@PostConstruct`注解）：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will then receive the following response:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到以下响应：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, we may do this in the `Interceptor` class, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可以在`Interceptor`类中这样做，如下所示：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'By doing this, we will receive the following response:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们将收到以下响应：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For the `@Interceptors` at the method level, only the callback method is called,
    regardless of whether the `InvocationContext.proceed` is called at the interceptor
    class.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于方法级别的`@Interceptors`，只有回调方法会被调用，无论在拦截器类中是否调用了`InvocationContext.proceed`。
- en: CDI interceptor implementation
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CDI拦截器实现
- en: Along with the introduction to the CDI mechanism, a new approach to interceptors
    was built based on the functionality of the Java EE interceptors that were previously
    seen. With the CDI engine, you can intercept business methods for the CDI-managed
    beans, not just for the EJB beans. A key difference for the interceptor under
    the CDI context is the way in which the interceptor is injected into the managed
    bean. We now have the concept of the interceptor binding type. This is an annotation
    that qualifies the desired type of interceptor for the bean.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍CDI机制的同时，基于之前看到的Java EE拦截器的功能，建立了一种新的拦截器方法。使用CDI引擎，您可以拦截CDI管理的业务方法，而不仅仅是EJB方法。在CDI上下文中，拦截器的一个关键区别是拦截器注入到管理
    bean 的方式。我们现在有了拦截器绑定类型的概念。这是一个注解，用于限定 bean 所需的拦截器类型。
- en: 'Suppose we want to create an interceptor for logging. In this case, we would
    initially create an interceptor binding type named `@Loggable`, which is described
    as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个用于日志记录的拦截器。在这种情况下，我们最初会创建一个名为`@Loggable`的拦截器绑定类型，其描述如下：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will then create an interceptor class. The interceptor class is annotated
    with both the interceptor binding type and the `@Interceptor` annotation. For
    this example, we create the `LoggedInterceptor` class, as shown in the following
    code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个拦截器类。拦截器类同时注解了拦截器绑定类型和`@Interceptor`注解。在这个例子中，我们创建了`LoggedInterceptor`类，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `@AroundInvoke` method works in the same way as previously described in
    the EJB interceptor.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`@AroundInvoke`方法与之前在EJB拦截器中描述的方式相同。'
- en: Furthermore, `@Loggable` works as a qualifier for the class interceptor. Since
    it is a kind of qualifier, it is always interesting to declare the interceptor
    binding type as an adjective. Consequently, we use the word *loggable**, *which means
    that it is suitable for logging.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`@Loggable`作为类拦截器的限定符。由于它是一种限定符，因此总是很有趣地将拦截器绑定类型声明为形容词。因此，我们使用单词*可记录的*，这意味着它适合于日志记录。
- en: 'Once we have created the interceptor binding type and the interceptor class,
    we can annotate the entire bean or some individual bean methods with the binding
    type to intercept either all bean methods or specific methods. Look at the following
    examples:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了拦截器绑定类型和拦截器类，我们就可以用绑定类型注解整个bean或某些单个bean方法，以拦截所有bean方法或特定方法。看看以下示例：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For specific methods, we would use the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定方法，我们将使用以下方法：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For an interceptor CDI to be invoked, it must be specified in the `beans.xml`,
    as shown in the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用拦截器CDI，必须在`beans.xml`中指定，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: An application may use multiple interceptors. If an application uses more than
    one interceptor, then the interceptors are invoked in the order specified in the
    `beans.xml` file.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序可以使用多个拦截器。如果一个应用程序使用了多个拦截器，那么拦截器的调用顺序将按照`beans.xml`文件中指定的顺序进行。
- en: There is a fundamental difference between the CDI interceptor and past EJB interceptors.
    The CDI bean knows nothing about the interceptor implementation class; it only
    knows about the interceptor binding type. This approach results in loose coupling.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: CDI拦截器和过去的EJB拦截器之间存在根本性的区别。CDI bean对拦截器实现类一无所知；它只知道拦截器绑定类型。这种方法导致了松耦合。
- en: Let's use the same example as the EJB interceptor. However, this time we are
    going to use the CDI interceptor mechanism. We will use the same EJB of `AcademicFacadeImpl`,
    but instead of `@Interceptors`, we will use an interceptor binding type called
    `Statistic` and will annotate the `Statisticlnterceptor` class with this binding
    type.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用与EJB拦截器相同的示例。然而，这次我们将使用CDI拦截器机制。我们将使用相同的`AcademicFacadeImpl` EJB，但我们将使用一个名为`Statistic`的拦截器绑定类型，并用此绑定类型注解`StatisticInterceptor`类。
- en: 'Let''s look at the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will use the same EJB of `StatisticalFacadeImpl` to handle the statistical
    elements, as shown in the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与`StatisticalFacadeImpl`相同的EJB来处理统计元素，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we will annotate our business method (or class) with `@Statistic`.
    In this case, we will annotate a business method:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用`@Statistic`注解我们的业务方法（或类）。在这种情况下，我们将注解一个业务方法：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Every time a client calls the EJB method (or any intercepted method of any CDI-managed
    bean) that is annotated with `@Statistic`, the `@AroundInvoke` method of the `StatisticInterceptor`
    class is invoked first. In our example, the `@AroundInvoke` method fires an asynchronous
    event. It was deliberately set up in this way so that statistical control does
    not participate in the business process.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每当客户端调用带有`@Statistic`注解的EJB方法（或任何CDI管理的bean的任何被拦截的方法）时，首先调用`StatisticInterceptor`类的`@AroundInvoke`方法。在我们的示例中，`@AroundInvoke`方法触发一个异步事件。这种方式是故意设置的，以便统计控制不参与业务流程。
- en: Decorator
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: A decorator is a pattern that makes it possible to extend the business logic
    of a specific functionality at run-time dynamically. The decorator pattern works
    as a business component wrapper, intercepting the `call` method that is responsible
    for executing the function. In other words, this pattern decorates the original
    business object by packaging the same object and providing additional functionality
    while also keeping the existing functionality intact. The decorator pattern is
    a structural design pattern.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是一种模式，它使得在运行时动态地扩展特定功能性的业务逻辑成为可能。装饰器模式作为一个业务组件包装器，拦截负责执行功能的`call`方法。换句话说，这个模式通过包装相同的对象来装饰原始业务对象，同时提供额外的功能，同时保持现有功能完整。装饰器模式是一种结构型设计模式。
- en: This pattern dynamically changes the way in which an object functions at run-time
    without impacting the existing functionality of the objects. In short, this pattern
    adds additional behavior to the object by wrapping it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在运行时动态地改变对象的功能方式，而不影响现有对象的功能。简而言之，这个模式通过包装对象来向对象添加额外的行为。
- en: The decorator pattern
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: 'The decorator pattern is one of the most frequently used GoF structural patterns.
    Its class diagram is shown in the following figure:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式是GoF结构模式中最常用的模式之一。其类图如下所示：
- en: '![](img/be43dd1a-1c56-4700-980b-945bf23a5002.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/be43dd1a-1c56-4700-980b-945bf23a5002.png)'
- en: 'The constituent elements of this pattern are described in *Design Patterns*:
    *Elements Of Reusable Object-Oriented Software* (the GoF book), and are shown
    in the following table:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式的构成元素在《设计模式》：*可复用面向对象软件元素*（GoF书籍）中进行了描述，并在下表中展示：
- en: '| `Component` | This defines the interface for objects that can have responsibilities
    added to them dynamically |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `Component` | 这定义了可以动态添加职责的对象的接口 |'
- en: '| `ConcreteComponent` | This defines an object to which additional responsibilities
    can be attached |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `ConcreteComponent` | 这定义了一个对象，可以附加额外的职责 |'
- en: '| `Decorator` | This maintains a reference to a component object, and defines
    an interface that conforms to a component''s interface |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `Decorator` | 这维护了对组件对象的引用，并定义了一个符合组件接口的接口 |'
- en: '| `ConcreteDecorator` | This adds responsibilities to the component |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `ConcreteDecorator` | 这向组件添加职责 |'
- en: We can always use inheritance or composition to extend the basic behavior of
    a business class or domain in compile-time. However, we cannot do this at run-time.
    The decorator pattern is used to accomplish the task of extending functionality
    at run-time.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在编译时使用继承或组合来扩展业务类或域的基本行为。然而，我们无法在运行时这样做。装饰器模式用于在运行时扩展功能。
- en: In order to explain the decorator pattern better, let's take an example from
    the academic world. Imagine that we have a domain class called `BasicEngineering`,
    and this class has a method that performs the task of listing the disciplines
    used for basic engineering. Let's say that we also have two other engineering
    models—mechanical engineering and electrical engineering. Each of these models
    has their own disciplines. Consequently, each of the engineering models has a
    list of the basic disciplines plus its own list of specific disciplines.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地解释装饰器模式，让我们从一个学术领域的例子开始。想象一下，我们有一个名为 `BasicEngineering` 的域类，并且这个类有一个执行列出基本工程所使用的学科的任务的方法。让我们假设我们还有两个其他工程模型——机械工程和电气工程。每个模型都有自己的学科。因此，每个工程模型都有一个基本学科的列表加上其自己的特定学科的列表。
- en: 'The following class diagram shows this arrangement:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类图显示了这种安排：
- en: '![](img/c683c250-cfac-4c50-bdca-fb7c251c80f8.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c683c250-cfac-4c50-bdca-fb7c251c80f8.png)'
- en: We could implement this pattern in a classic decorator pattern, but this is
    not our goal. In fact, we do not need to implement it in a trivial way because
    JEE technology already provides us with a mechanism for implementing the decorator
    pattern with the use of CDI technology. We will use the `@Decorator` annotation
    to implement this pattern.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在经典的装饰器模式中实现这个模式，但这不是我们的目标。实际上，我们不需要以简单的方式实现它，因为 JEE 技术已经为我们提供了一个使用 CDI
    技术实现装饰器模式的机制。我们将使用 `@Decorator` 注解来实现这个模式。
- en: The decorator in a JEE scenario
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JEE场景中的装饰器
- en: First of all, we create an `Engineering` interface that has the business method
    we want to decorate. We then create an abstract class named `BasicEngineering`
    that extends `Engineering`. As the following code shows, we can make an abstract
    `EngineeringDecorator` using two concrete decorators, or we can make two abstract
    decorator classes that implement `Engineering` directly. There is no obligation
    to keep the decorator classes concrete.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个 `Engineering` 接口，该接口具有我们想要装饰的业务方法。然后，我们创建一个名为 `BasicEngineering` 的抽象类，它扩展了
    `Engineering`。如下代码所示，我们可以使用两个具体装饰器来创建一个抽象的 `EngineeringDecorator`，或者我们可以创建两个直接实现
    `Engineering` 的抽象装饰器类。没有义务保持装饰器类是具体的。
- en: For the sake of simplicity, let's create the two decorator classes as abstract,
    without having to extend them from a basic decorator class. So, both the `ElectronicDecorator`
    and `MechanicalDecorator` classes will decorate the `Engineering` objects (`ElectronicEngineering`
    and `MechanicalEngineering`).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，让我们创建两个装饰器类为抽象的，而不需要从基本装饰器类扩展它们。因此，`ElectronicDecorator` 和 `MechanicalDecorator`
    类都将装饰 `Engineering` 对象（`ElectronicEngineering` 和 `MechanicalEngineering`）。
- en: 'The following code shows the model classes that are used in this example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了在此示例中使用的模型类：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can see that the `ElectronicEngineering` and `MechanicalEngineering` classes
    are qualified with the `@Electronic` and `@Mechanical` decorators respectively.
    We can see that with the qualifiers, we can identify which type of object we are
    going to decorate. Thus, the `MechanicalDecorator` decorates any `Engineering`
    that has the `@Mechanical` qualifier, and the `ElectronicDecorator` decorates
    any `Engineering` that has the `@Electronic` qualifier.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`ElectronicEngineering` 和 `MechanicalEngineering` 类分别被 `@Electronic`
    和 `@Mechanical` 装饰器修饰。我们可以看到，通过限定符，我们可以识别出将要装饰的对象类型。因此，`MechanicalDecorator` 装饰任何具有
    `@Mechanical` 限定符的 `Engineering` 对象，而 `ElectronicDecorator` 装饰任何具有 `@Electronic`
    限定符的 `Engineering` 对象。
- en: Decorator implementation
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器实现
- en: 'The following code shows the `MechanicalDecorator` and the `ElectronicDecorator` decorator
    classes:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`MechanicalDecorator`和`ElectronicDecorator`装饰器类：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can see that the `Engineering` object is annotated with `@Delegate`. This
    is the business object that will be decorated. When invoked, the `getDisciplines`
    business method will pass the call to the `getDisciplines` method of the decorator.
    At this point, the decorator takes care of the situation. The decorator's `getDisciplines`
    method calls the delegate object's `getDisciplines` method and adds decorated
    disciplines. This means that it extends the functionality by adding the specific
    disciplines to the basic ones.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`Engineering`对象被注解为`@Delegate`。这是将被装饰的业务对象。当被调用时，`getDisciplines`业务方法会将调用传递给装饰器的`getDisciplines`方法。在这个时候，装饰器负责处理这种情况。装饰器的`getDisciplines`方法调用代理对象的`getDisciplines`方法并添加装饰学科。这意味着它通过添加特定的学科来扩展基本功能。
- en: It is also important to bear in mind that the `@Electronic` qualifier identifies
    the decorated object. So, `ElectronicDecorator` decorates the `@Electronic` object
    while `MechanicalDecorator` decorates the `@Mechanical` object.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是要记住，`@Electronic`限定符标识了被装饰的对象。因此，`ElectronicDecorator`装饰了`@Electronic`对象，而`MechanicalDecorator`装饰了`@Mechanical`对象。
- en: It is logical to wonder why the `getDisciplines` method cannot be put into each
    of the model classes. Depending on the type of business, this approach would be
    better. However, let's say that the disciplines can vary widely, and that we have
    a large number of engineering models. In this case, things can get more complicated,
    and the use of a decorator adds functionality to something already established.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有理由怀疑为什么`getDisciplines`方法不能放入每个模型类中。根据业务类型的不同，这种方法可能更好。然而，假设学科可能有很大的差异，并且我们有大量的工程模型。在这种情况下，事情可能会变得更加复杂，使用装饰器可以为已经建立的东西添加功能。
- en: A decorator can be declared as an abstract class so that it does not have to
    implement all the business methods of the interface.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器可以声明为抽象类，这样它就不必实现接口的所有业务方法。
- en: 'Furthermore, for a decorator to be invoked in a CDI context, it must be specified—like
    an interceptor—in the `beans.xml` file. So, the decorators of our example are
    specified as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了在CDI上下文中调用装饰器，它必须在`beans.xml`文件中指定，就像拦截器一样。因此，我们的示例装饰器指定如下：
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If an application uses more than one decorator, then the decorators are invoked
    in the order in which they are specified in the `beans.xml` file.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序使用多个装饰器，则装饰器按在`beans.xml`文件中指定的顺序调用。
- en: If an application has both interceptors and decorators, then the interceptors
    are invoked first.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序既有拦截器又有装饰器，则首先调用拦截器。
- en: A decorator must be specified like an interceptor in the `beans.xml` file. The
    decorators are invoked in the order in which they are specified in the `beans.xml`
    file.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器必须在`beans.xml`文件中像拦截器一样指定。装饰器按在`beans.xml`文件中指定的顺序调用。
- en: 'In fact, we could create another decorator, known as `BasicEngineeringDecorator`,
    which would be responsible for decorating any `Engineering`. We then simply input
    the `@any` qualifier to qualify the `Engineering` object. Of course, we should
    also worry about the order. This should be the first factor to be called. Consequently,
    the decorators are listed in the `beans.xml` file, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以创建另一个名为`BasicEngineeringDecorator`的装饰器，它将负责装饰任何`Engineering`对象。然后我们只需简单地输入`@any`限定符来限定`Engineering`对象。当然，我们也应该担心顺序。这应该是首先调用的因素。因此，装饰器在`beans.xml`文件中按如下顺序列出：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen that interceptors and decorators are the platforms
    through which the JEE platform provides aspect-oriented programming. Interceptors
    are used to interpose the invocation of some method or life cycle events that
    occur in an associated target class. The interceptor takes care of technical tasks,
    called **crosscutting tasks**, that are repeated throughout an application, such
    as logging, auditing, and exception handling. These tasks are separate from business
    logic, and it's a good idea to put the interceptor in a separate class for easy
    maintenance.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到拦截器和装饰器是JEE平台提供面向方面编程的平台。拦截器用于在关联的目标类中插入某些方法调用或生命周期事件的调用。拦截器负责处理在整个应用程序中重复出现的技术任务，称为**横切任务**，例如日志记录、审计和异常处理。这些任务与业务逻辑分开，将拦截器放在单独的类中以便于维护是一个好主意。
- en: We learned how the classic interceptor mechanism works for EJB, as well as the
    CDI inspector mechanism, which can intercept any managed bean and not just EJB-managed
    beans.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了经典拦截器机制在EJB中的应用，以及CDI检查器机制，它可以拦截任何托管Bean，而不仅仅是EJB管理的Bean。
- en: While the interceptor takes care of the technical tasks, we can add functionality
    to the existing business logic with the decorators. We learned that the decorator
    pattern is a well-known structural design pattern. A decorator is a type of interceptor
    for business classes, and is used when we want to add functionality to a business
    class while also keeping it intact.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当拦截器负责技术任务时，我们可以通过装饰器向现有的业务逻辑中添加功能。我们了解到装饰器模式是一种众所周知的结构型设计模式。装饰器是业务类的一种拦截器，当我们想要在不破坏业务类的前提下为其添加功能时，就会使用它。
- en: The use of interceptor and decorators promotes low coupling and easy maintenance.
    However, we must use them carefully. For example, with regards to decorators,
    we should avoid excessively spreading them through the application. Excessive
    decentralization can cause an inverse effect and worsen code maintenance.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用拦截器和装饰器促进了低耦合和易于维护。然而，我们必须谨慎使用它们。例如，关于装饰器，我们应该避免过度地在应用程序中扩散它们。过度的分散化可能会产生相反的效果，并恶化代码维护。
- en: An interceptor belongs to the same transactional context of the business class
    that it interposes. As an interceptor only deals with technical issues, tasks
    related to it cannot influence the execution of business logic. Consequently,
    errors generated in technical tasks cannot be thrown to the business logic. In
    a similar way, the execution time of these tasks cannot compose the execution
    time of business logic.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器属于它所拦截的业务类的相同事务上下文。由于拦截器只处理技术问题，与之相关的任务不能影响业务逻辑的执行。因此，在技术任务中产生的错误不能抛给业务逻辑。同样地，这些任务的执行时间不能组成业务逻辑的执行时间。
