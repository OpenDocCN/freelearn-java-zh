- en: Aspect-Oriented Programming and Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the concept of **aspect-oriented programming**
    (**AOP**), focusing on which situations AOP should be used in, as well as how
    to achieve AOP with the use of CDI interceptors and decorators. Finally, we will
    also look at some examples of its implementation. By the end of this chapter,
    you will be able to identify a situation that requires AOP with the use of interceptors
    and decorators. Furthermore, you will also be able to identify the best approach
    to implementing these concepts. The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Aspect-oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AOP in a JEE scenario – the interceptor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EJB interceptor implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CDI interceptor implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decorator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decorator pattern in a JEE scenario
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorator implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aspect-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AOP is a programming paradigm that allows us to separate business logic from
    some technical code that crosscuts all applications. In other words, AOP allows
    the separation of crosscutting concerns. We will encounter crosscutting code when
    we input the logging code in certain methods to show technical support information.
    We also encounter it when we input statistic code to see how many times a method
    calls or who the user using the application is, or even for exception and error
    handling. We see this kind of code in almost all parts of an application—it is
    code that is repeated along the whole application. This kind of code has its own
    objectives and concerns, and it is a very good idea to separate it from the business
    code, which is related to the application use cases.
  prefs: []
  type: TYPE_NORMAL
- en: These aspects of the system (such as logging or exception handling) are very
    difficult to implement in a modular way. What we are saying here is that we don't
    want to mix these aspects with business code. By mixing these two types of code,
    we are left with a final code that is more difficult to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: With AOP, we can join or add an executable code to our source code without changing
    it, meaning that the source code remains intact. As we said, if we want to log
    a method, for instance, then we can do that without disrupting our business code
    with a service code, such as the logging service.
  prefs: []
  type: TYPE_NORMAL
- en: Compile-time versus run-time AOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AOP is achieved through code injection during compile-time or runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks that implement AOP at compile-time change the binary code (the `.class` file),
    so when the interceptor code is injected, we are left with a `.class` file that
    is different from the `.class` that would be generated without the injection code.
    The resulting `.class` file then becomes incompatible with the source code.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the run-time injection does not modify either the source
    code or the `.class` file. In this case, the interception method is done in a
    separate code from the class or place that contains the method. As a consequence,
    the interception codes that are executed before and after the method's original
    call are found in another class.
  prefs: []
  type: TYPE_NORMAL
- en: Java does not offer a built-in solution for AOP, but some third-party frameworks,
    such as Eclipse AspectJ and Spring, are widely used in Java applications. We could
    use Eclipse AspectJ, for instance, to implement AOP. Eclipse AspectJ is a seamless
    aspect-oriented extension to the Java programming language. It is a Java platform
    that is compatible and easy to use. However, JEE implements AOP using a new idea
    concept known as an **interceptor**, and we will see how this functions in the
    following section. All JEE programmers can have AOP using interceptors, without
    it being necessary to get the JAR's dependency related to the AspectJ solution
    and putting this into our application.
  prefs: []
  type: TYPE_NORMAL
- en: AOP in JEE scenario – the interceptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aspect-oriented software development enables the clean modularization of crosscutting
    concerns. For the benefit of all JEE programmers, we can also separate business
    code from crosscutting concerns, which is a solution that the interceptor technologies
    offer by implementing JEE.
  prefs: []
  type: TYPE_NORMAL
- en: When an EJB method or a managed bean is called and there is an interceptor associated
    with this call (we will see how this is implemented soon), we can write a code
    to be executed immediately before the method calls and also just after the method
    calls (that is, after the return of the method).
  prefs: []
  type: TYPE_NORMAL
- en: 'Intercepting filter patterns is another pattern that is used for intercepting
    a request. In JEE, we can implement the filter pattern using web filters and servlets.
    By using a web filter, a Java web application implements the interception of web
    requests and responses. The web application can intercept the request, fulfill
    an action, and also intercept the response. The following list contains several
    examples of filters that have many actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication/authorization filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging and auditing filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image conversion filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data compression filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tokenizing filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interceptor acts as a filter, and therefore we can consider a web filter
    as an interceptor. However, this mechanism is related to web requests and responses. We
    will not talk about this type of interception in this chapter. Instead, we will
    cover the interceptor patterns that are used in managed beans—that is, the EJB
    interceptor, the CDI beans interceptor, and a kind of business logic interceptor
    referred to as *the decorator*.
  prefs: []
  type: TYPE_NORMAL
- en: A brief word about CDI and beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are presuming that the reader knows the basic characteristics that surround
    the CDI, as well as its main objectives and uses. However, it is very important
    to emphasize some definitions and aspects of the CDI.
  prefs: []
  type: TYPE_NORMAL
- en: The CDI technology is one of the pillars of the JEE platform, and it is present
    in most of its services. This means that these services depend in some way on
    the CDI mechanism—CDI is closely related to the bean concept within the EE specification,
    so let's take a look at what a bean actually is.
  prefs: []
  type: TYPE_NORMAL
- en: The bean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of a bean is quite generic. Here, we are not talking about the concept
    of JavaBeans, with the getters and setters access method. Instead, we are talking
    about the concept of the bean as a web component or business component. In this
    scenario, we encounter several types of beans, such as Java classes in web and
    JEE-related beans, such as EJB beans and JSF-managed beans. There are even some third-party
    frameworks outside of the JEE specification (such as Spring) that have a different
    concept of the bean. The concept of a JEE bean is known as a **managed bean**,
    which is managed by a container that requires little intervention by the programmer
    and has a well-defined life cycle. As well as this, a managed bean can provide
    mechanisms for intercepting its execution and life cycle callback methods, and
    can be injected into other beans or JEE objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, an object that has a well-defined life cycle context can be considered
    a bean or a managed bean. In other words, a managed bean is a component that the
    container constructs and destroys (as part of managing its life cycle). CDI includes
    built-in support for several different kinds of bean. The following Java EE components
    can be injected:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Managed beans**: EJB session beans, classes annotated with `@ManagedBean`,
    decorators, and classes that conform to the CDI rules for becoming a managed bean'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java EE resources**: Resources that can be referenced from the component
    environment naming space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arbitrary objects**:Objects that are returned by producer methods and fields'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managed beans may also inject other beans.
  prefs: []
  type: TYPE_NORMAL
- en: '**Obs:** The JSF specification also describes a technology known as managed
    beans. These managed beans are different from the ones we describe here. The Java
    EE foundational managed beans are a generalization of the JSF ones, and are not
    limited to web modules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other objects from the JEE platform (such as the servlet and interceptor
    objects) that are not classified as JEE beans, and which may have injected beans
    via the CDI mechanism. The JEE platform components that may have beans injected
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Servlets (including servlet filters and servlet event listeners)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSP tag handlers and tag library event listeners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSF scope-managed beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JAX–RS components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JAX–WS service endpoints and handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebSocket endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managed beans in CDI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several ways to declare a Java class as a managed bean. For example,
    if we annotate a class with `@ManageBean`, it is defined as a managed bean. However,
    the CDI specification insists that a class has to be considered as a managed bean
    according to certain criteria. These criteria are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is not a nonstatic inner class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a concrete class or it is annotated with `@Decorator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not an EJB component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not implement `javax.enterprise.inject.spi.Extension`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It either has a `no-argument` constructor, or declares a constructor annotated
    with `@Inject`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loose coupling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the objectives of using patterns in the JEE context are to reduce the
    coupling between classes on different layers—or even on the same layer—as well
    as the code reuse (that is, the use of some existing code that provides a certain
    functionality). With these two objectives, we are able to improve software maintenance
    and quality. But how?
  prefs: []
  type: TYPE_NORMAL
- en: Loose coupling allows programmers to fix bugs or to develop new functionalities
    in a layer with minimum impact on the other layers. In addition, with every tested
    code, methods of special beans or objects may be called from different parts of
    an application, thereby improving software organization and clarity. As a result
    of this, software quality is improved and development time decreased.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, loose coupling makes the code easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the CDI provides loose coupling. In addition, the CDI works in a strong,
    safe way using qualifier annotations instead of string identification.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JEE, the use of events, interceptors, and decorators provides loose coupling,
    as described in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event notifications**: Establish a decoupling between event-generating clients
    and event listeners (observers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interceptors**: Separate technical concerns from business logic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decorators**: Allow business concerns to be extended (adding business functionality
    to existing ones)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will see how the interceptors and decorators achieve this
    goal.
  prefs: []
  type: TYPE_NORMAL
- en: Interceptors in the JEE platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An Oracle tutorial defines an interceptor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"*An interceptor is a class used to interpose in invocation **methods **or
    life cycle events that occur in an associated target class."*'
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, interceptors are generally used for technical tasks,
    referred to as cross-cutting tasks. This includes auditing, logging, controlling statistics,
    and so on. These tasks are separate from the business logic, and may be repeated
    over the entire application. Consequently, we can put the interceptor code into
    a separate class that is different from the target class that we want to intercept
    in order to improve code maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of the interceptor was first introduced in JEE5, and it was only
    used for EJBs (session beans and message-driven beans). With the introduction
    of **context and dependency injection** (**CDI**) in JEE6, the interceptors were
    extended to all managed beans—that is, to beans that meet the CDI-managed bean.
  prefs: []
  type: TYPE_NORMAL
- en: Interceptor methods are invoked on an associated target class.
  prefs: []
  type: TYPE_NORMAL
- en: We can define an interceptor within the target class as an interceptor method,
    or we can define an interceptor in a separate class (called an **interceptor class**)
    that contains the interceptor method. Interceptor methods are always invoked when
    a target class method is annotated to be intercepted and is then invoked, or when
    a life cycle callback method is intercepted (such as before the construction or
    after the destruction of a bean). It is important to note that for simple applications,
    we can put interceptors in the target class. However, for a more complex application,
    or for when the application grows in complexity, we should put the interceptor
    in a separate class.
  prefs: []
  type: TYPE_NORMAL
- en: Each element that you want to intercept is called an **advice**. We say that
    an interceptor decorates the advice, and each time an advice is called, an interceptor
    code is executed (if it exists). The location of the point where this code is
    executed is called the **pointcut**.
  prefs: []
  type: TYPE_NORMAL
- en: Interceptor methods on an associated target class are invoked when advice target
    class methods are invoked, or when there is a life cycle event and the life cycle
    callback method related to the event is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows an interceptor sequence diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/615b4cb0-2b60-4df4-9678-d88895353e5d.png)'
  prefs: []
  type: TYPE_IMG
- en: This sequence diagram shows a chain of interceptors. When a client calls a business
    method and there is a chain of interceptors associated with it, the first interceptor
    is called and does something (that is, this first interceptor method's code is
    executed), then calls the second interceptor explicitly, and so on. This continues
    until the last interceptor in the chain calls the bean's business method. We will
    see how this call is made later. For now, we can say that an element of the chain
    of interceptors calls the next element in the same way until the last element—which
    is the business method of the managed bean itself—is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define interceptor classes and interceptor methods using annotations,
    or, alternatively, we can define the deployment descriptor of the application.
    However, in this section, we will only cover the use of annotations. The following
    table shows the annotations used in interceptor methods that define the condition
    or when the interception occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interceptor annotation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.interceptor.AroundConstruct` | This defines an intercept method that
    receives a callback when the constructor of the target class is invoked |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.interceptor.AroundInvoke` | This defines an intercept method that
    is executed when a method of the target class that is marked to be intercepted with
    an annotation is invoked |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.interceptor.AroundTimeout` | This defines an interceptor method that
    interposes on timeout methods |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.annotation.PostConstruct` | This defines an interceptor method for
    post-construct life cycle events |'
  prefs: []
  type: TYPE_TB
- en: '| `javax.annotation.PreDestroy` | This defines an interceptor method for predestroy
    life cycle events |'
  prefs: []
  type: TYPE_TB
- en: EJB interceptor implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at an example of the original EJB interceptor
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that there is a stateless session EJB, such as `AcademicFacadeImpl`,
    as well as a business method called `testReview`. This method is responsible for
    scheduling a student test review. Let's say that we want to know, statistically,
    which students have made the most test review requests. We could do this within
    the business code, but that is not what we want. Instead, we want to separate
    statistic logic from business logic statistics—we want a statistic interceptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we will create an EJB target class named `AcademicFacadeImpl` (this
    class was already created in the last chapter). In the beginning, there is no
    interceptor reference, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we define an interceptor using one of the interceptor annotations listed
    in the previous table. This can be found within the target class or in a separate
    interceptor class. The following code shows an `@AroundInvoke` interceptor method
    declared in the target class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use a separate interceptor class. We may apply the `@Interceptor` annotation,
    but interceptor classes do not have to be annotated. An interceptor class must
    have a `public` and `no-argument` constructor. The following code shows an interceptor
    class with an `@Interceptor` and `@AroundInvoke` interceptor method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use the CDI event API. This API is used to implement an
    event-firing mechanism. Basically, this uses a bean to fire an event, and one
    or more beans observe this firing. This mechanism is implemented from an `Event`
    class object, as shown in the code. We use a `String` type to qualify the event,
    but we could use any other type, or use qualifiers to qualify our event.
  prefs: []
  type: TYPE_NORMAL
- en: We can also see the `InvocationContext` object that is a parameter of the `statisticMethod`
    method. This object provides information about the context of the intercepted
    invocation. In addition, this object has methods for controlling the chain interceptor.
    For example, the `proceed` method calls the next interceptor in the interceptor
    chain, or the intercepted method of the business object. We will learn more about `InvocationContext`
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must use the `@Interceptors` annotation to define at least one interceptor.
    We can define interceptors at the class or method level of the target class by
    indicating whether we want to intercept all the business methods or just some
    specific business methods. The following code shows only one interceptor declared
    at the class level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code declares the same interceptor, but at the method level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We will put `@Interceptors` at the method level. This is because we don't want
    to intercept all other EJB methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we must create a class that will observe the statistical event. This
    class will handle statistical issues. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When the `requestTestReview` method of the `AcademicFacadeImpl` class is called,
    it is intercepted (this method is marked with an interceptor), so the `statisticMethod`
    method of the `StatisticInterceptor` class is called. During the execution of
    this method, a statistical event is triggered. The purpose here is to perform
    statistical control asynchronously for execution of the business method.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative, we could convert the `StatisticalFacadeImpl` into an EJB
    and annotate the `control` method with `@Asynchronous`. As a result, we would
    not have to fire a statistical event, and instead, we could call the following
    asynchronous method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Intercepting method invocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want a specific method to be a pointcut, we have to annotate it with the `@AroundInvoke` annotation.
    The `@AroundInvoke` method (or the pointcut method) must* return an object*, and
    must have a parameter of the `InvocationContext` type. As well as this, the pointcut
    method should *throw an exception*.
  prefs: []
  type: TYPE_NORMAL
- en: The `InvocationContext` methods can be called in order to access information about
    the current context, such as the name of the pointcut, the method annotations,
    the method parameters, and so on. However, it is important to note that in an
    interception situation, the target class method is invoked only when the `@AroundInvoke`
    method calls the `proceed` method. As a result, the `@AroundInvoke` method must
    call the `proceed` method in order to invoke the target class method. In the case
    of the chain of interceptors, every time an EJB business method is called, each
    `@AroundInvoke` method of each chain interceptor is called in the order that is
    configured for them (via `@Interceptors`) until the target class method is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: These `@AroundInvoke` interceptor methods can have any of the access-level modifiers—public,
    protected, private, or package. However, the methods must not be static or final. Keep
    in mind that only one `@AroundInvoke` interceptor method per class is permitted.
  prefs: []
  type: TYPE_NORMAL
- en: '`AroundInvoke` interceptor methods have the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@AroundInvoke`'
  prefs: []
  type: TYPE_NORMAL
- en: '`[public, protected, private or package-level ] Object method-name (InvocationContext)
    throws Exception { ...}`'
  prefs: []
  type: TYPE_NORMAL
- en: Only one `AroundInvoke` interceptor method per class is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to keep in mind is that an `AroundInvoke` interceptor can
    have the same transaction context as the target method.
  prefs: []
  type: TYPE_NORMAL
- en: Interceptor class and multiple method interceptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having an interceptor in a separate class improves code maintenance by providing
    a clear division of responsibilities between classes, meaning that the classes
    become more cohesive. In addition, interceptor classes may have resources and
    managed beans injected into them.
  prefs: []
  type: TYPE_NORMAL
- en: Another important factor worth mentioning is that the interceptor method belongs
    to the same EJB transaction context. So, whenever we want to intercept a business
    logic to do a technical task, such as logging or statistic persistence, we must
    take care. For instance, we don't want any errors to be thrown during statistic
    control, thereby generating a business transaction rollback.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we should perform asynchronous statistic controlling. This would
    guarantee that any eventual error would occur in a new transaction, separate from
    the current transaction. So, it is essential that good software design and strong
    business knowledge are achieved before coding.
  prefs: []
  type: TYPE_NORMAL
- en: Interceptor classes may have resources and managed beans injected into them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Interceptors` annotation is used to inject one or more interceptors into
    the EJB target class or into the EJB target method. See the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The interceptors are invoked in the order in which they were defined within
    the `@Interceptors` annotation. However, if the interceptors are also defined
    in the deployment descriptor, this order can be overridden. Consequently, if there
    is an interceptor chain, an interceptor calls the next one by invoking the `InvocationContext.proceed`
    method within the order specified in `@Interceptors`. This continues until the
    business method is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: The interceptor class is referenced in the EJB target class, which causes the
    target class to discover the interceptor class. This situation establishes a coupling
    between both classes. We will cover how the CDI interceptor mechanism corrects
    this situation later.
  prefs: []
  type: TYPE_NORMAL
- en: Intercepting life cycle callback events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The interceptor methods that are used for the life cycle callback events (`AroundConstruct`,
    `PostConstruct`, and `PreDestroy`) follow the same model for implementing the
    interceptors as previously described in regards to location. This may be defined
    in the target class, in interceptor classes, or in both classes. In this chapter,
    we will only see examples of `PostConstruct` and `PreDestroy` callback events.
  prefs: []
  type: TYPE_NORMAL
- en: As described in the previous table containing the interceptor annotations, a
    method with the `@PostConstruct` annotation is used to intercept the `PostConstruct`
    life cycle event, and a method with a `@PreDestroy` annotation is used to intercept
    the `PreDestroy` life cycle event. Intercepting classes have the same life cycle
    as the target classes. This means that when an instance of the target class is
    created, an interceptor object is also created for each declaration of the interceptor
    class in the target class.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is another way to approach this. We can define callback methods
    for life cycle events and define interceptor methods for these callback methods.
    So what we really want is to intercept a callback method. The callback method for
    a life cycle event within the target class (or a life cycle event interceptor
    on the target class side) has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of this could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The interceptor method for this callback  method defined in an interceptor
    class (or a life cycle event interceptor on the interceptor class side) has the
    following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'An example could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can define callback methods for life cycle events (`AroundConstruct`, `PostConstruct`,
    and `PreDestroy`) and we can also define interceptor methods for these callback
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: When testing various situations, we noticed some interesting things.
  prefs: []
  type: TYPE_NORMAL
- en: For the `@Interceptors` at class level, if both methods for the same life cycle
    event are defined in both the target class and interceptor class, then only the
    callback interceptor is called. However, if there is an explicit invocation of
    `InvocationContext.proceed` inside the callback interceptor, then the callback
    method in the target class is also called. Let's see what happens when we annotate
    both the EJB class and the `Interceptor` class with the `@PostConstruct` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the `initialize` method (which has a `@PostConstruct`)
    of the EJB `AcademicFacadelImpl` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows the `initialize` method (which has a `@PostConstruct`) of
    the `Interceptor` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then receive the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we may do this in the `Interceptor` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, we will receive the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For the `@Interceptors` at the method level, only the callback method is called,
    regardless of whether the `InvocationContext.proceed` is called at the interceptor
    class.
  prefs: []
  type: TYPE_NORMAL
- en: CDI interceptor implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with the introduction to the CDI mechanism, a new approach to interceptors
    was built based on the functionality of the Java EE interceptors that were previously
    seen. With the CDI engine, you can intercept business methods for the CDI-managed
    beans, not just for the EJB beans. A key difference for the interceptor under
    the CDI context is the way in which the interceptor is injected into the managed
    bean. We now have the concept of the interceptor binding type. This is an annotation
    that qualifies the desired type of interceptor for the bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to create an interceptor for logging. In this case, we would
    initially create an interceptor binding type named `@Loggable`, which is described
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then create an interceptor class. The interceptor class is annotated
    with both the interceptor binding type and the `@Interceptor` annotation. For
    this example, we create the `LoggedInterceptor` class, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `@AroundInvoke` method works in the same way as previously described in
    the EJB interceptor.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, `@Loggable` works as a qualifier for the class interceptor. Since
    it is a kind of qualifier, it is always interesting to declare the interceptor
    binding type as an adjective. Consequently, we use the word *loggable**, *which means
    that it is suitable for logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have created the interceptor binding type and the interceptor class,
    we can annotate the entire bean or some individual bean methods with the binding
    type to intercept either all bean methods or specific methods. Look at the following
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For specific methods, we would use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For an interceptor CDI to be invoked, it must be specified in the `beans.xml`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: An application may use multiple interceptors. If an application uses more than
    one interceptor, then the interceptors are invoked in the order specified in the
    `beans.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: There is a fundamental difference between the CDI interceptor and past EJB interceptors.
    The CDI bean knows nothing about the interceptor implementation class; it only
    knows about the interceptor binding type. This approach results in loose coupling.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the same example as the EJB interceptor. However, this time we are
    going to use the CDI interceptor mechanism. We will use the same EJB of `AcademicFacadeImpl`,
    but instead of `@Interceptors`, we will use an interceptor binding type called
    `Statistic` and will annotate the `Statisticlnterceptor` class with this binding
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the same EJB of `StatisticalFacadeImpl` to handle the statistical
    elements, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will annotate our business method (or class) with `@Statistic`.
    In this case, we will annotate a business method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Every time a client calls the EJB method (or any intercepted method of any CDI-managed
    bean) that is annotated with `@Statistic`, the `@AroundInvoke` method of the `StatisticInterceptor`
    class is invoked first. In our example, the `@AroundInvoke` method fires an asynchronous
    event. It was deliberately set up in this way so that statistical control does
    not participate in the business process.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A decorator is a pattern that makes it possible to extend the business logic
    of a specific functionality at run-time dynamically. The decorator pattern works
    as a business component wrapper, intercepting the `call` method that is responsible
    for executing the function. In other words, this pattern decorates the original
    business object by packaging the same object and providing additional functionality
    while also keeping the existing functionality intact. The decorator pattern is
    a structural design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern dynamically changes the way in which an object functions at run-time
    without impacting the existing functionality of the objects. In short, this pattern
    adds additional behavior to the object by wrapping it.
  prefs: []
  type: TYPE_NORMAL
- en: The decorator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The decorator pattern is one of the most frequently used GoF structural patterns.
    Its class diagram is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be43dd1a-1c56-4700-980b-945bf23a5002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The constituent elements of this pattern are described in *Design Patterns*:
    *Elements Of Reusable Object-Oriented Software* (the GoF book), and are shown
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Component` | This defines the interface for objects that can have responsibilities
    added to them dynamically |'
  prefs: []
  type: TYPE_TB
- en: '| `ConcreteComponent` | This defines an object to which additional responsibilities
    can be attached |'
  prefs: []
  type: TYPE_TB
- en: '| `Decorator` | This maintains a reference to a component object, and defines
    an interface that conforms to a component''s interface |'
  prefs: []
  type: TYPE_TB
- en: '| `ConcreteDecorator` | This adds responsibilities to the component |'
  prefs: []
  type: TYPE_TB
- en: We can always use inheritance or composition to extend the basic behavior of
    a business class or domain in compile-time. However, we cannot do this at run-time.
    The decorator pattern is used to accomplish the task of extending functionality
    at run-time.
  prefs: []
  type: TYPE_NORMAL
- en: In order to explain the decorator pattern better, let's take an example from
    the academic world. Imagine that we have a domain class called `BasicEngineering`,
    and this class has a method that performs the task of listing the disciplines
    used for basic engineering. Let's say that we also have two other engineering
    models—mechanical engineering and electrical engineering. Each of these models
    has their own disciplines. Consequently, each of the engineering models has a
    list of the basic disciplines plus its own list of specific disciplines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class diagram shows this arrangement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c683c250-cfac-4c50-bdca-fb7c251c80f8.png)'
  prefs: []
  type: TYPE_IMG
- en: We could implement this pattern in a classic decorator pattern, but this is
    not our goal. In fact, we do not need to implement it in a trivial way because
    JEE technology already provides us with a mechanism for implementing the decorator
    pattern with the use of CDI technology. We will use the `@Decorator` annotation
    to implement this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The decorator in a JEE scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, we create an `Engineering` interface that has the business method
    we want to decorate. We then create an abstract class named `BasicEngineering`
    that extends `Engineering`. As the following code shows, we can make an abstract
    `EngineeringDecorator` using two concrete decorators, or we can make two abstract
    decorator classes that implement `Engineering` directly. There is no obligation
    to keep the decorator classes concrete.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, let's create the two decorator classes as abstract,
    without having to extend them from a basic decorator class. So, both the `ElectronicDecorator`
    and `MechanicalDecorator` classes will decorate the `Engineering` objects (`ElectronicEngineering`
    and `MechanicalEngineering`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the model classes that are used in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `ElectronicEngineering` and `MechanicalEngineering` classes
    are qualified with the `@Electronic` and `@Mechanical` decorators respectively.
    We can see that with the qualifiers, we can identify which type of object we are
    going to decorate. Thus, the `MechanicalDecorator` decorates any `Engineering`
    that has the `@Mechanical` qualifier, and the `ElectronicDecorator` decorates
    any `Engineering` that has the `@Electronic` qualifier.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code shows the `MechanicalDecorator` and the `ElectronicDecorator` decorator
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `Engineering` object is annotated with `@Delegate`. This
    is the business object that will be decorated. When invoked, the `getDisciplines`
    business method will pass the call to the `getDisciplines` method of the decorator.
    At this point, the decorator takes care of the situation. The decorator's `getDisciplines`
    method calls the delegate object's `getDisciplines` method and adds decorated
    disciplines. This means that it extends the functionality by adding the specific
    disciplines to the basic ones.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to bear in mind that the `@Electronic` qualifier identifies
    the decorated object. So, `ElectronicDecorator` decorates the `@Electronic` object
    while `MechanicalDecorator` decorates the `@Mechanical` object.
  prefs: []
  type: TYPE_NORMAL
- en: It is logical to wonder why the `getDisciplines` method cannot be put into each
    of the model classes. Depending on the type of business, this approach would be
    better. However, let's say that the disciplines can vary widely, and that we have
    a large number of engineering models. In this case, things can get more complicated,
    and the use of a decorator adds functionality to something already established.
  prefs: []
  type: TYPE_NORMAL
- en: A decorator can be declared as an abstract class so that it does not have to
    implement all the business methods of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, for a decorator to be invoked in a CDI context, it must be specified—like
    an interceptor—in the `beans.xml` file. So, the decorators of our example are
    specified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If an application uses more than one decorator, then the decorators are invoked
    in the order in which they are specified in the `beans.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: If an application has both interceptors and decorators, then the interceptors
    are invoked first.
  prefs: []
  type: TYPE_NORMAL
- en: A decorator must be specified like an interceptor in the `beans.xml` file. The
    decorators are invoked in the order in which they are specified in the `beans.xml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, we could create another decorator, known as `BasicEngineeringDecorator`,
    which would be responsible for decorating any `Engineering`. We then simply input
    the `@any` qualifier to qualify the `Engineering` object. Of course, we should
    also worry about the order. This should be the first factor to be called. Consequently,
    the decorators are listed in the `beans.xml` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen that interceptors and decorators are the platforms
    through which the JEE platform provides aspect-oriented programming. Interceptors
    are used to interpose the invocation of some method or life cycle events that
    occur in an associated target class. The interceptor takes care of technical tasks,
    called **crosscutting tasks**, that are repeated throughout an application, such
    as logging, auditing, and exception handling. These tasks are separate from business
    logic, and it's a good idea to put the interceptor in a separate class for easy
    maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how the classic interceptor mechanism works for EJB, as well as the
    CDI inspector mechanism, which can intercept any managed bean and not just EJB-managed
    beans.
  prefs: []
  type: TYPE_NORMAL
- en: While the interceptor takes care of the technical tasks, we can add functionality
    to the existing business logic with the decorators. We learned that the decorator
    pattern is a well-known structural design pattern. A decorator is a type of interceptor
    for business classes, and is used when we want to add functionality to a business
    class while also keeping it intact.
  prefs: []
  type: TYPE_NORMAL
- en: The use of interceptor and decorators promotes low coupling and easy maintenance.
    However, we must use them carefully. For example, with regards to decorators,
    we should avoid excessively spreading them through the application. Excessive
    decentralization can cause an inverse effect and worsen code maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: An interceptor belongs to the same transactional context of the business class
    that it interposes. As an interceptor only deals with technical issues, tasks
    related to it cannot influence the execution of business logic. Consequently,
    errors generated in technical tasks cannot be thrown to the business logic. In
    a similar way, the execution time of these tasks cannot compose the execution
    time of business logic.
  prefs: []
  type: TYPE_NORMAL
