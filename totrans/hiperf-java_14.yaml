- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Profiling Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the complexity of our Java applications increases, the need to gain insights
    into how they use system resources such as CPU and memory becomes increasingly
    important and a critical aspect of ensuring our applications perform efficiently.
    This is where profiling tools come in; they can help us identify issues such as
    bottlenecks and memory leaks so that we can enhance our applications to improve
    the user experience and overall performance.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter takes a deep dive into profiling and profiling tools. We will start
    with an introduction to profiling and its importance to our ability to fine-tune
    our applications for optimal performance. Categories of profiling tools and their
    uses are also covered to help give you a basic understanding, leading to a review
    of specific profiling tools.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover Java profiling tools bundled with the **Java Development Kit**
    (**JDK**) and ones embedded in **Integrated Development Environments** (**IDEs**),
    such as IntelliJ IDEA, Eclipse, and NetBeans. Additionally, third-party profiling
    tools will be reviewed, including YourKit Java Profiler, JProfiler, and VisualVM.
    The intention is to provide you with a firm understanding of the various profiling
    tools available, their strengths and weaknesses, and practical use cases so that
    you can determine which tool is best suited for your needs and use them effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Our coverage of profiling tools includes a comparative analysis to help you
    evaluate performance overhead, tool accuracy, ease of use, integration issues,
    and costs. We will end the chapter with a look at future Java profiling trends,
    including profiling tool advancements, emerging standards, and the integration
    of **Artificial Intelligence** (**AI**) and **Machine Learning** (**ML**) for
    further performance tuning.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have a foundational understanding of
    profiling tools and be able to leverage the knowledge you gained from hands-on
    exercises to improve the performance of your Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to profiling tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profilers bundled in the JDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IDE-embedded profilers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional profilers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comparative analysis of profiling tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical profiling strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case studies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Future trends in Java profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to profiling tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Profiling tools play a critical role in performance tuning and proactive application
    enhancements to support high-performance Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling
  prefs: []
  type: TYPE_NORMAL
- en: Profiling is the process of analyzing software at runtime with the goal of identifying
    performance issues, including bottlenecks, resource use, and optimization opportunities.
  prefs: []
  type: TYPE_NORMAL
- en: Once we build and test our software, it moves into production. This is where
    profiling occurs, during runtime. Using profiling tools, we can gain detailed
    insights into the runtime behavior of our applications. The goal is to have efficient
    code and our systems to perform optimally, including low latency, high reliability,
    and high availability. It is not enough for our applications to perform accurately;
    they also need to perform efficiently. The use of profiling tools allows us to
    pinpoint performance issues so we can further optimize our code.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of profiling in performance tuning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at five specific reasons that illustrate the importance of profiling
    to support performance tuning:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application responsiveness**: At the heart of performance tuning is ensuring
    that our applications are responsive. Users should not be subjected to high latency.
    Profiling tools help us analyze how our resources are used, shedding light on
    opportunities for improvement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bottlenecks**: The use of profiling tools can help us identify performance
    bottlenecks and even potential bottlenecks. This allows us to take a proactive
    approach to performance tuning and helps us avoid catastrophic bottlenecks in
    the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous improvement**: Software systems are not developed, deployed, and
    forgotten. We maintain our systems and strive to continually improve them. Systems
    that perform at desired levels today might underperform when a new operating system
    is released, or other environmental factors change. This requires a continuous
    improvement mindset. Continually profiling our applications and addressing optimization
    opportunities can help ensure our systems remain responsive and efficient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource utilization**: The use of hardware resources such as CPU and memory
    should be closely monitored, as inefficient use of these resources can result
    in system lag and suboptimal input/output operations. Profiling tools can help
    us identify areas that can be optimized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: The larger our applications are, the more significant even
    a minor performance issue can be to overall system performance. The use of profiling
    tools helps us identify opportunities to enhance performance and address any related
    issues that could become more pronounced as our application scales, due to increased
    demand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of profiling tools and their uses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are seven broad categories of profiling tools, each with its own focus
    area or purpose. Let’s review those now:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CPU profilers**: This category of profiles analyzes an application’s CPU
    usage. They can identify specific methods in our applications that are the most
    CPU-intensive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IDE embedded profilers**: Most major IDEs (e.g., NetBeans, Eclipse, and IntelliJ
    IDEA) have built-in profiling tools. Because they are part of the IDE, they seamlessly
    integrate with the development environment. This makes them especially easy to
    use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input/output profilers**: These profilers specifically focus on our application’s
    input/output operations. If our input/output processes are slow or inefficient,
    these profilers can bring them to light so that we can refine operations such
    as file handling, database interactions, and network communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory profilers**: Memory profilers give us a window into memory allocation
    and memory use. This can help us identify actual or potential memory leaks and
    identify memory consumption optimization opportunities. We can use this category
    of profiler to provide insights into garbage collection, memory retention, and
    even object life cycles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network profilers**: As the name suggests, this category of profilers specializes
    in analyzing an application’s network communications. These profilers can help
    us identify latency issues and to understand how bandwidth is being used. Network
    profilers also help us identify suboptimal or inefficient network protocols.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Specialized profilers**: This is a category of profilers that provide tailored
    features for specific performance situations. They can also be used for specific
    environments (e.g., distributed systems or real-time systems) or specific scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thread profilers**: Thread profilers monitor thread activity and are especially
    useful in multithreaded environments. This category of profiler helps us detect
    thread contention issues and potential deadlocks and identifies opportunities
    to optimize thread management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to understand what profiling tools are and their categories
    and uses. This knowledge can help you select the most appropriate tool for your
    performance-related goals and system requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Profilers bundled in the JDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JDK includes profiling tools that can provide us with valuable insights
    into our Java application’s performance. The use of these tools is highly recommended
    to identify performance issues and opportunities for performance fine-tuning.
    This section explores the primary profilers that are built-in to the JDK – JVisualVM
    and **Java Mission** **Control** (**JMC**).
  prefs: []
  type: TYPE_NORMAL
- en: JVisualVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **JVisualVM**, short for **Java Visual Virtual Machine**, is a robust profiling
    tool built into the JDK. It offers an impressive set of features that include
    monitoring, profiling, and troubleshooting Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: An overview and features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JVisualVM provides a graphical user interface that combines several JDK tools,
    including JConsole. The interface is displayed in the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1: The JVisualVM graphical user interface](img/B21942_14_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: The JVisualVM graphical user interface'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key features of JVisualVM are summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Heap dump analysis**: JVisualVM is able to capture heap dumps and analyze
    them for us. This can help us gain insight into memory use and identify real or
    potential memory leaks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plugin integration**: This tool’s functionality can be extended by a multitude
    of available plugins. The plugin repository is available via the Tools menu, open
    and displayed in the following figure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 14.2: The JVisualVM plugin repository](img/B21942_14_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: The JVisualVM plugin repository'
  prefs: []
  type: TYPE_NORMAL
- en: '**Monitoring**: JVisualVM can monitor, in real time, our application’s memory
    consumption, garbage collection, thread activity, and CPU usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Profiling**: This tool offers the ability to conduct detailed profiling of
    CPU and memory use. This can help identify memory leaks and bottlenecks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thread analysis**: JVisualVM can be used to monitor and analyze our application’s
    thread states and thread activities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases and examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use JVisualVM for multiple use cases, and it is especially useful in
    the development, testing, and production phases. This tool provides us with detailed
    CPU and memory usage insights. We can use this tool to see which of our methods
    consumes the most CPU time. We can also look at memory consumption, object allocations,
    and garbage collection to help us optimize our application’s memory use.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider a situation where we have a web application whose users
    report occasional lag. We can use JVisualVM to monitor our application’s CPU and
    memory use. This can help us identify spikes. From there, we can analyze thread
    dumps to determine the source of the problem. In this scenario, it could be as
    simple as a single Java method or thread that causes the occasional lag. Using
    the profiling tool can help us quickly get to the core of the issue so that we
    can refine our code accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: JMC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JMC is another powerful JDK tool that we can use to profile and monitor our
    Java applications, most specifically in production environments. As you can see
    from the screenshot below, JMC includes the **JMX Console** and **Flight Recorder**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3: The JMC welcome screen](img/B21942_14_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: The JMC welcome screen'
  prefs: []
  type: TYPE_NORMAL
- en: An overview and features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Java Management Extensions** (**JMX**) console is used to monitor and
    manage our Java applications. The **Flight Recorder** is for continuous monitoring
    and profiling. It collects detailed performance data, with limited impact on application
    performance. The events recorded include method invocations, memory allocation,
    thread activity, and input/output operations. The **Java Flight Recorder** (**JFR**)
    is the core component of JMC and can be used to record our running applications
    and then analyze the results, giving us insights into CPU usage, method-specific
    execution times, data on memory allocations, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the capabilities of JMC and JVisualVM can result in deep insights
    into our application’s performance, empowering us to optimize our resource use
    and improve the responsiveness of our applications. In the next section, we will
    review profiling tools embedded in IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: IDE-embedded profilers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java developers use built-in profiling tools with their favorite IDEs. Using
    these profilers offers a convenient method of analyzing our software directly
    within our development environment of choice. This section explores the built-in
    capabilities of the IntelliJ IDEA, Eclipse, and NetBeans IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: The IntelliJ IDEA profiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **IntelliJ IDEA profiler** allows us to profile our Java applications from
    within the IDE. This powerful feature is only available in the commercial edition
    of the IDE (**IntelliJ IDEA Ultimate**), so if you are using the **Community Edition**
    (**CE**), you will not be able to use the IntelliJ IDEA profiler. Integration
    and setup are simple; here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open IntelliJ IDEA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write or load your Java project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the **Run** | **Profile** menu option to start profiling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the type of profiling you want (CPU or memory).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With CPU profiling, the tool can identify methods in your code that consume
    the most CPU time. Call trees are also provided that show code paths and overall
    resource use (CPU and memory). The memory profiling capabilities of the IntelliJ
    IDEA Profiler include the ability to trace object allocations, analyze garbage
    collection efficacy, and detect memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse’s Test and Performance Tools Platform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Eclipse IDE is popular for Java developers, and it previously had an embedded
    profiling tool called the **Test and Performance Tools Platform** (**TPTP**).
    It was provided as a plugin, available from the Eclipse Marketplace. The key features
    included are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: CPU profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input/output profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TPTP is mentioned here so that developers with Eclipse are not left wondering
    what embedded profiling tools Eclipse has. TPTP was archived, likely due to the
    increasing power of the JDK built-in profiling tools.
  prefs: []
  type: TYPE_NORMAL
- en: NetBeans Profiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The NetBeans Profiler is integrated into the NetBeans IDE and has a top-level
    **Profile** menu item for easy configuration and access. The tool can conduct
    performance analysis in the categories of telemetry, methods, objects, threads,
    locks, and SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows the four main components of the tool’s dashboard
    when **Telemetry profiling** is selected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4: The NetBeans telemetry profiler window](img/B21942_14_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: The NetBeans telemetry profiler window'
  prefs: []
  type: TYPE_NORMAL
- en: The object profiler, shown in the following figure, provides real-time analysis
    so that you can review your application’s performance at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5: The NetBeans object profiler window](img/B21942_14_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: The NetBeans object profiler window'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the profiling tools that are integrated with your IDE can help
    you become more efficient with your time, as these integrated tools are the easiest
    to configure and use when compared to third-party tools, and in some cases, they
    are easier than using the profiling tools bundled with the JDK.
  prefs: []
  type: TYPE_NORMAL
- en: Additional profilers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have looked at profiling tools that are built-in to the JDK and ones
    embedded in an IDE. There is a third category of profilers, ones that are external
    to the JDK and IDEs. This section reviews three of the most prevalent profilers
    in this category. These are specialized tools that can give us deeper insights,
    based on sophisticated analysis of our runtime applications.
  prefs: []
  type: TYPE_NORMAL
- en: YourKit Java Profiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'YourKit Javak Profiler is a robust profiling tool that is available with an
    open source license. Advanced features and support require purchasing a license.
    The key features and capabilities of this tool are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous Integration**/**Continuous Delivery** (**CI**/**CD**) integration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input/output profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote server profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JProfiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JProfiler profiling tool is a commercial application that is said to be
    an intuitive, all-in-one profiler for Java applications. It has a friendly, easy-to-use
    interface and powerful capabilities that include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: CPU profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap and object graph analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IDE integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove server profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VisualVM plugins and extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We previously covered VisualVM as a JDK-bundled profiling tool. It is featured
    in this section because there are a host of third-party plugins and extensions
    that can be used to enhance VisualVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list shows some of the plugins available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Buffer Monitor**: Can be used to monitor direct buffer use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Heap Walker**: This plugin provides finite memory and heap analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kill Application**: This plugin facilitates terminating non-responsive monitoring
    processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sampler plugin**: Provides detailed CPU and memory sampling options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Startup Profiler**: This plugin facilitates the use of instrumented profiling
    from startups. This is useful for applications with a short runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thread Inspector**: Provides advanced thread analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tracer**: This is a framework for detailed monitoring, using probes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VisualGC**: Provides deep analysis and visualization for the garbage collector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are additional plugins and extensions for the VisualVM Profiler. In addition,
    developers can create their own custom plugins if needed.
  prefs: []
  type: TYPE_NORMAL
- en: A comparative analysis of profiling tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the great things about using profiling tools is that we have several
    options available to us. This section reviews the top six profiling tools featured
    in this chapter, using the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accuracy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ease of use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By following each category analysis, we will score each of these profiling tools
    to see how they stack up against each other.
  prefs: []
  type: TYPE_NORMAL
- en: Performance overhead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When comparing profiling tools, it is important to consider their performance
    overhead. This factor can help you select the right tool for your use case. Here
    is a review of the performance overhead for our six selected profiling tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IntelliJ IDEA Profiler**: This tool has moderate overhead and is suitable
    for development and testing; however, it is not ideal for production environments,
    especially with high-load applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JMC**: Minimal overhead is one of JMC’s strongest features. This is especially
    evident when using JFR. JMC is designed for production use and typically has negligible
    impact on performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JProfiler**: This tool has moderate overhead but a high level of detailed
    profiling analysis, giving developers a tough decision regarding the balance between
    detailed insights and increased overhead. Profiling with this tool is appropriate
    for development and testing environments and controlled production instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JVisualVM**: This profiling tool’s performance overhead varies between low
    and moderate, based on the depth of profiling desired. It is suitable for development
    and production environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NetBeans Profiler**: This tool has moderate overhead and is only suitable
    for non-production environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**YourKit Java Profiler**: This tool has a high level of configurability to
    help manage overhead. It is appropriate for both production and non-production
    environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accuracy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Not all profiling tools are 100% accurate, and it is important to have a firm
    understanding of your tool’s accuracy level. Here is a review of the accuracy
    of your featured profiling tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IntelliJ IDEA Profiler**: This tool’s greatest accuracy is with CPU and memory
    profiling. Accuracy takes a dip when profiling threads, and it can increase performance
    overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JMC**: This is a high-accuracy profiling tool that delivers precise results
    with minimal performance impact, even in production environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JProfiler**: This profiling tool provides highly accurate results along with
    detailed visualizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JVisualVM**: While this profiling tool provides accurate sampling and data,
    the need for high precision increases performance overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NetBeans Profiler**: This tool provides accurate CPU and memory profiling
    and real-time thread analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**YourKit Java Profiler**: This profiling tool renders highly accurate results
    in CPU, memory, and thread analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ease of use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ease of use is another important factor that we need to consider when selecting
    a profiling tool. If a tool is difficult to use and takes considerable time, it
    might not be the right tool for you. Here is a review of the ease of use for our
    featured tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IntelliJ IDEA Profiler**: This tool is seamlessly integrated into the IntelliJ
    IDEA IDE, making it intuitive and easy to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JMC**: This is an advanced tool that can require a concerted effort to learn.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JProfiler**: This tool is renowned for its ease of use. It is also thoroughly
    documented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JVisualVM**: This profiling tool is beginner-friendly and has a simplistic
    user interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NetBeans Profiler**: This tool is integrated into the NetBeans IDE, making
    it easy to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**YourKit Java Profiler**: This profiling tool has an intuitive user interface
    and is user-friendly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Developers tend to favor profiling tools that have deep integrations. Here
    is a review of that characteristic for each of our six selected profiling tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IntelliJ IDEA Profiler**: This tool is deeply integrated into the IntelliJ
    IDEA IDE and supports custom workflows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JMC**: JMC is bundled with the JDK, making integration with JVM-based applications
    seamless.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JProfiler**: This tool easily integrates with the most popular build tools
    and IDEs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JVisualVM**: This tool is integrated with the IDE and is easy to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NetBeans Profiler**: This tool is fully integrated into the NetBeans IDE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**YourKit Java Profiler**: This profiling tool supports integration with the
    major IDEs and CI/CD.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cost and licensing considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The cost of profiling tools can be a significant factor. Independent developers
    tend to favor free tools, while large teams might opt to pay for more robust tools.
    Here is the cost factor for our six tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IntelliJ IDEA Profiler**: This profiler is included with the IntelliJ IDEA
    Ultimate edition, which requires a paid subscription.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JMC**: This tool is free for development and testing but might require payment
    for use in production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JProfiler**: This is a commercial tool that requires payment for use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JVisualVM**: This tool is free and bundled with the JDK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NetBeans Profiler**: This is a free tool that is integrated into the NetBeans
    IDE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**YourKit Java Profiler**: This is a commercial tool that requires payment
    for use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best use cases for each tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is likely that no single profiling tool will fit your needs every time.
    Each of our tools has a specific use case they are most suited for:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IntelliJ IDEA Profiler**: This tool is best suited for IntelliJ IDEA users
    who want to use an integrated profiling tool during development'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JMC**: This tool is ideal for production environments because of its low
    overhead and its ability to provide detailed analysis, especially when using JFR'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JProfiler**: This profiling tool is ideal for developers who want an easy-to-use,
    powerful tool that has advanced analysis capabilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JVisualVM**: This tool is best suited for developers who want a free profiling
    option for CPU and memory analysis during the software development and testing
    phases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NetBeans Profiler**: This tool is ideal for NetBeans IDE users who want a
    reliable integrated profiling tool for CPU, memory, and thread analysis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**YourKit Java Profiler**: This profiling tool is best suited for users who
    want in-depth profiling during all phases of the software development life cycle,
    including production'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scoring our profiling tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following table rates the six featured profiling tools based on performance
    overhead, analysis accuracy, ease of use, integration, and cost. The scores range
    from 1 to 5, with 1 being the lowest and 5 being the highest possible score.
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 14.1: The profiling tool scoring matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B21942_14_6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14.1: The profiling tool scoring matrix'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, no single tool received a top score in every category. Based
    on this scoring, JMC received the highest score of 22, followed by JProfiler and
    YourKit Java Profiler at 21 points each. JVisualVM and NetBeans Profiler scored
    20, and the IntelliJ IDEA Profiler scored the lowest, with 19 points.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding the strengths, limitations, and trade-offs of each profiling
    tool, you should be able to choose the most appropriate tool for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Practical profiling strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The benefits of profiling our Java applications to help identify and resolve
    performance issues have been established. We will next explore effective profiling
    strategies so that you can optimize your Java applications efficiently. This section
    covers strategies to identify performance bottlenecks and differentiate profiling
    approaches between development and production environments. We will also look
    at how to implement continuous profiling for long-term performance management.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying performance bottlenecks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The primary goal of profiling is to identify performance bottlenecks. We can
    adopt several strategies to achieve this goal, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Begin by monitoring CPU usage, memory consumption, and response times. These
    high-level metrics can help you identify areas that require deeper analysis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider using sampling profilers that can quickly identify methods that consume
    the most CPU time. Tools such as JVisualVM and IntelliJ IDEA Profiler provide
    this type of functionality. The goal is to use sampling to pinpoint issues without
    a significant impact on performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have identified an area for deeper analysis, use instrumentation profiling,
    such as what is provided by JProfiler and YourKit Java Profiler. These tools can
    help you examine specific code paths and methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be sure to analyze your application’s thread activity. This is critical for
    applications that employ concurrent processing. Tools such as JMC and NetBeans
    Profiler have extensive thread analysis functionality. They can be used to detect
    thread contention, deadlocks, and even inefficient synchronization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use memory profilers to analyze object allocations, identify objects that are
    not collected by Java’s garbage collector, and capture heap dumps. Tools such
    as JProfiler and YourKit Java Profiler have this capability and help identify
    potential memory leaks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if your application makes extensive use of database interactions or
    input/output operations, use profilers that can provide insight into JDBC calls
    and input/output. The aim is to identify inefficient queries and input/output
    bottlenecks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling in development versus production
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How and what we profile should be informed by our current environment. Profiling
    in a development environment should be approached differently than profiling a
    running application in production.
  prefs: []
  type: TYPE_NORMAL
- en: The following table provides a comparative analysis of profiling in development
    and production environments, using 10 key aspects of profiling.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Aspect** | **Development profiling** | **Production profiling** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Primary focus | Identify and resolve performance issues | Monitor and resolve
    runtime performance issues |'
  prefs: []
  type: TYPE_TB
- en: '| Access requirements | Direct access | Remote access |'
  prefs: []
  type: TYPE_TB
- en: '| Frequency | Frequent profiling | Selective profiling based on observations
    |'
  prefs: []
  type: TYPE_TB
- en: '| Performance impact | High overhead tolerated | Minimal overhead required
    |'
  prefs: []
  type: TYPE_TB
- en: '| Profiling type | Detailed instrumentation | Sampling |'
  prefs: []
  type: TYPE_TB
- en: '| Tools | IntelliJ IDEA Profiler, JProfiler, and YourKit Java Profiler | JMC
    and JVisualVM |'
  prefs: []
  type: TYPE_TB
- en: '| Data granularity | High | Low |'
  prefs: []
  type: TYPE_TB
- en: '| Load simulation | Simulate realistic loads | Real-time user load |'
  prefs: []
  type: TYPE_TB
- en: '| Automation | Integrated with CI/CD | Continuous monitoring |'
  prefs: []
  type: TYPE_TB
- en: 'Table 14.2: Profiling comparative analysis'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the differences in profiling based on your application’s environment
    can help you conduct efficient profiling, subsequently allowing you to enhance
    your Java application’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous profiling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should profile throughout the development process and then continuously
    once our application is in production. Implementing continuous profiling includes
    the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Establishing performance baselines so that you can compare future profiling
    results to them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating profiling with your CI/CD pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring you are monitoring key performance metrics including CPU use, memory
    use, and response times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing your polling data so that you can conduct historical analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to routine monitoring, conducting full profiling audits at regular
    intervals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring to communicate profiling results with the development team so that
    they are informed and can enhance the performance of your current system, helping
    to make future applications more performant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These practical profiling strategies can help identify and resolve performance
    bottlenecks. It is important to establish a formal profiling approach that can
    be meticulously followed.
  prefs: []
  type: TYPE_NORMAL
- en: Case studies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section details three case studies to illustrate the practical implementation
    of profiling tools in real-world scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Case study 1 – profiling a large enterprise application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Scenario**: A large global financial services company developed, tested,
    and deployed an enterprise application to handle their transactions and reporting.
    Recently, the application started experiencing performance degradation. This was
    especially evident during peak user transaction times.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Profiling tools**: The development team selected JProfiler for its capability
    to provide detailed profiling and because it integrated with their development
    environment.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process implemented**: The company took a three-step approach to profiling:'
  prefs: []
  type: TYPE_NORMAL
- en: They first conducted an initial analysis, looking at CPU use, memory use, and
    thread analysis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, they used the profiler data from *step 1* to identify bottlenecks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third step was to optimize their enterprise application. This optimization
    included rewriting inefficient algorithms, implementing more efficient data structures,
    optimizing object creation and disposal, and reducing thread contention by implementing
    a refined locking mechanism.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Outcome**: Transaction times significantly improved, and memory consumption
    was now stable. Moreover, the improved application was now able to handle peak
    load times without network latency issues or impact on the user experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Case study 2 – performance tuning in a microservices architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Scenario**: A technology company developed a large-scale e-commerce application
    using a microservices architecture. There are a lot of microservices with the
    primary ones handling user authentication, product inventories, product catalogs,
    payment transactions, and order processing. Staff and users have reported intermittent
    latency issues and occasional timeouts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Profiling tools**: The tech company selected JMC for profiling, based on
    its low overhead and ability to monitor applications in production using JFR.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process implemented**: The company decided to enable JFR recordings on all
    microservices. Their plan was to collect detailed performance data without a significant
    impact on performance. Next, they used JMC to analyze the JFR data to identify
    resource usage patterns and potential hotspots.'
  prefs: []
  type: TYPE_NORMAL
- en: Analysis revealed their product catalog service had sporadic CPU usage spikes
    that impacted overall response times. Their thread profiling analysis shows that
    the order processing service caused timeouts, based on thread contention. They
    also reviewed network profiling data, which showed the payment transaction service’s
    database interactions had high latency.
  prefs: []
  type: TYPE_NORMAL
- en: With profiling and analysis complete, the development team optimized their e-commerce
    application. Specifically, they optimized the product catalog service by implementing
    a caching mechanism. The order processing service was rewritten with an optimized
    thread management schema, using thread pools. Lastly, the payment transaction
    service’s database queries were optimized, and connection pooling was implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '**Outcome**: The technology company’s e-commerce system showed improved performance
    following the optimizations. Latency was reduced and it was significantly more
    stable, with few timeouts. The staff reported improved satisfaction and user complaints
    waned.'
  prefs: []
  type: TYPE_NORMAL
- en: Case study 3 – profiling and optimizing a high-throughput system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Scenario**: A communications company uses a system for high throughput and
    real-time data processing and analytics. Their system has significant performance
    degradation during high load times. This leads to delays in data processing and
    analysis operations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Profiling tools**: The company selected the YourKit Java Profiler tool because
    it has comprehensive features, and it is ideal for high-throughput systems.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process implemented**: The communication company’s development team adopted
    a three-step approach – conduct initial profiling, identify bottlenecks, and optimize.'
  prefs: []
  type: TYPE_NORMAL
- en: The initial profiling included a look at CPU and memory use. They focused on
    data processing and analytic components of their system. They also conducted a
    detailed thread analysis to help identify bottlenecks evident in thread processing.
  prefs: []
  type: TYPE_NORMAL
- en: Their second step was to identify bottlenecks. Their CPU profiling reviewed
    that some of their data processing modules contained complex computations, which
    have a significant draw on CPU use. Their memory profiling results indicated that
    their analytics module had high memory usage. That same module showed frequent
    garbage collection events that negatively impacted the system’s overall performance.
    They also looked at thread analysis results, which showed thread contention during
    peak data loads, further reducing performance.
  prefs: []
  type: TYPE_NORMAL
- en: The company’s last step was to optimize its system. They optimized their data
    processing algorithms to improve the efficiency of their computations and enhanced
    parallel processing to take advantage of multi-core processors. Developers also
    optimized their analytics module by reducing object creation, improving data structures,
    and minimizing garbage collection. The team also optimized how their application
    managed threads. They introduced thread pools to reduce thread contention.
  prefs: []
  type: TYPE_NORMAL
- en: '**Outcome**: The communication company’s high-throughput system realized significant
    performance improvements following the system optimizations. Their data processing
    times were reduced by 55% and latency during analytics processing was minimized.
    Their system can now handle high data loads efficiently and meet real-time data
    processing requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: The three case studies demonstrate a practical application of profiling strategies
    and tools in various contexts. They all used a similar three-step approach (profile,
    identify, optimize) and had successful outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Future trends in Java profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The software development landscape is ever-shifting, and profiling tools and
    techniques are equally dynamic. As technological innovations emerge, so do tools
    to help developers address and manage them. This final section explores future
    trends in Java profiling, with a focus on profiling tools and integration with
    AI and ML. The section ends with a list of emerging standards and best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Advances in profiling tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Current profiling tools continue to be improved, with new versions frequently
    being released. It is also common for new profiling tools to be introduced periodically.
    The key advancements with profiling tools are in the following five areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Improved user interfaces**: We should see more intuitive interfaces and better
    visualizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud-native profiling**: Cloud computing and distributed computing are the
    norm, and profiling tools are apt to cater to these environments to a greater
    extent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced real-time profiling**: Profiling tools will enhance their real-time
    processing capabilities and continually decrease their impact on performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low-overhead instrumentation**: Profiling high-throughput systems can result
    in system latency. Future advances will decrease the impact these systems have
    on performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unified monitoring and profiling**: The convergence of monitoring and profiling
    tools can be advantageous for development teams that want diagnostics that combine
    real-time monitoring and deep profiling data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with AI and machine learning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'AI and ML technologies can be leveraged by profiling tools. These technologies
    can help performance-tuning efforts. Here are key aspects of the use of AI and
    ML in performance tuning:'
  prefs: []
  type: TYPE_NORMAL
- en: Adaptive profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated anomaly detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intelligent optimization recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Predictive performance modeling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Root cause analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emerging standards and best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following recommendations are intended to help guide your effective use
    of profiling tools and techniques as they exist today and as they evolve:'
  prefs: []
  type: TYPE_NORMAL
- en: Adopt a continuous profiling strategy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be mindful of security and privacy considerations when profiling tools collect
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicate and collaborate with your team. This includes their involvement
    in your profiling strategy, a review of the results, and optimization planning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include your profiling efforts in a holistic performance management plan.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standardize your profiling APIs so that you can introduce interoperability and
    integration simplification. These standards can help ensure that your profiling
    data is consistent and that you can effectively compare the standards across different
    tools and environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to stay abreast of changes to the profiling tools you use and
    to be cognizant of new tools and techniques as they are introduced. This awareness,
    coupled with adherence to best practices, can help ensure that you fully leverage
    profiling tools and techniques, resulting in high-performing Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter took a thorough look at profiling tools and their role in Java
    application performance. We explored various profilers, including those bundled
    in the JDK and embedded in IDEs, and third-party tools such as JProfiler and YourKit
    Java Profiler. Coverage included practical profiling strategies to help identify
    performance bottlenecks, distinct profiling approaches required for development
    and performance environments, and the importance of continuous profiling to support
    long-term performance management. We introduced three real-world case studies
    to illustrate profiling tool applications. Finally, we examined future trends
    and best practices regarding Java profiling tools.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will examine how to optimize our databases and queries
    to enhance the performance of our Java applications. We will review database design
    considerations, purposeful SQL query generation, and several strategies, including
    normalization, indexing, connection pooling, caching, JDBC and ORM optimizations,
    transaction management, and testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 5: Advanced Topics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final part of the book addresses advanced topics that push the boundaries
    of Java performance optimization. It begins with strategies to optimize databases
    and SQL queries, followed by techniques for effective code monitoring and maintenance.
    You will learn about unit and performance testing to ensure that your applications
    meet performance standards. This part concludes with an exploration of leveraging
    **artificial intelligence** (**AI**) to enhance the performance of Java applications,
    providing a forward-looking perspective on future trends and technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B21942_15.xhtml#_idTextAnchor288), *Optimizing Your Databases
    and SQL Queries*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B21942_16.xhtml#_idTextAnchor307), *Code Monitoring and Maintenance*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 17*](B21942_17.xhtml#_idTextAnchor331), *Unit and Performance Testing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 18*](B21942_18.xhtml#_idTextAnchor345), *Leveraging Artificial Intelligence
    (AI) for High Performance Java Applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
