<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;5.&#xA0;Multimethods and Protocols" id="164MG1-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Multimethods and Protocols</h1></div></div></div><p class="calibre7">We now have a better understanding of how Clojure works; we understand how to perform simple operations with immutable data structures but we are missing some features that could make our lives much easier.</p><p class="calibre7">If you have been a Java programmer for a while, you are probably thinking about polymorphism and its particular flavor in Java.</p><p class="calibre7">Polymorphism is one of the concepts that enable us to reuse a code. It gives us the ability to interact with different objects with the same API.</p><p class="calibre7">Clojure has a powerful polymorphism paradigm that allows us to write simple code, create code that interacts with types that don't exist yet, and extend code in ways it wasn't devised for when a programmer wrote it.</p><p class="calibre7">To help us with polymorphism in Clojure, we have two important concepts that we will cover in this chapter:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Multimethods</li><li class="listitem">Protocols</li></ul></div><p class="calibre7">Each of them has its own use cases and things it is best at; we will look into them in the next section.</p><p class="calibre7">We will learn each of these different concepts by reviewing what we already know from Java and then we will learn similar concepts from Clojure that give us much more power.</p></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Multimethods and Protocols" id="164MG1-f3eee9b8c89a4c399520b72f8d890ddc">
<div class="book" title="Polymorphism in Java"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec34" class="calibre1"/>Polymorphism in Java</h1></div></div></div><p class="calibre7">Java uses <a id="id175" class="calibre1"/>polymorphism heavily, its collection API is based on it. Probably the best examples of polymorphism in Java are the following classes:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">java.util.List</code></li><li class="listitem"><code class="email">java.util.Map</code></li><li class="listitem"><code class="email">java.util.Set</code></li></ul></div><p class="calibre7">We know that depending on our use case we should use a particular implementation of these data structures.</p><p class="calibre7">If we prefer to use an ordered Set, we might use a TreeSet.</p><p class="calibre7">If we need a Map in a concurrent environment, we will use a <code class="email">java.util.concurrent.ConcurrentHashMap</code>.</p><p class="calibre7">The <a id="id176" class="calibre1"/>beautiful thing is that you can write your code using the <code class="email">java.util.Map</code> and <code class="email">java.util.Set</code> interfaces and if you need to change to another type of Set or Map, because the conditions have changed or someone has created a better version of the collection for you, you don't need to change any code!</p><p class="calibre7">Lets look at a very simple example of polymorphism in Java.</p><p class="calibre7">Imagine that you have a Shapes hierarchy; it might look similar to the following code:</p><div class="informalexample"><pre class="programlisting">package shapes;

public interface Shape {
  public double getArea();
}

public class Square implements Shape {
  private double side;
  public Square(double side) {
this.side = side;
  }

  public double getArea() {
    return side * side;
  }

}

public class Circle implements Shape {
  private double radius;
  public Circle(double radius) {
this.radius = radius;
  }

  public double getArea() {
    return Math.PI * radius * radius;
  }

}</pre></div><p class="calibre7">You surely are aware of the power of this concept, you can now calculate the summation of all the areas of a collection of figures, such as this:</p><div class="mediaobject"><img src="../images/00014.jpeg" alt="Polymorphism in Java" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The <code class="email">totalArea</code> method <a id="id177" class="calibre1"/>doesn't care about the specific types of shapes that you pass to it and you can add new types of shapes, such as rectangles or trapezoids. Your same code will now work with new data types.</p><p class="calibre7">Now, with the same Java code base, imagine that you wanted to add a new function to your shape interface, something simple, such as a <code class="email">getPerimeter</code> method.</p><p class="calibre7">This seems quite simple; you will have to modify each class that implements the Shape interface. I'm sure you've faced this problem a lot of times when you don't have access to the base source. The solution is to write a wrapper around your Shape objects but this introduces more classes and incidental complexity.</p><p class="calibre7">Clojure has its own idea of polymorphism, it is much simpler but also very powerful; you can in fact solve the perimeter problem with it in a very simple way.</p><p class="calibre7">One way to solve this is with multimethods; lets have a look at how they work.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Multimethods in Clojure"><div class="book" id="173722-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec35" class="calibre1"/>Multimethods in Clojure</h1></div></div></div><p class="calibre7">Multimethods <a id="id178" class="calibre1"/>are similar to interfaces, they allow you to write a common contract and then a family of functions can fulfill that interface with a specific implementation.</p><p class="calibre7">They are extremely flexible, as you will see they grant you a very fine control over what function is going to get invoked for a specific data object.</p><p class="calibre7">Multimethods consist of three parts:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A function (or method) declaration</li><li class="listitem">A dispatch function</li><li class="listitem">Each possible implementation of the function</li></ul></div><p class="calibre7">One of the most interesting features of multimethods is that you can implement new functions for already existing types without having to write wrappers around your currently existing object.</p><p class="calibre7">The multimethod declaration works the same way as the interface; you define a common contract for the polymorphic function, as shown:</p><div class="informalexample"><pre class="programlisting">(defmulti name docstring? attr-map? dispatch-fn&amp; options)</pre></div><p class="calibre7">The <code class="email">defmulti</code> macro defines the contract for your multimethod, it consists of:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The multimethod's name</li><li class="listitem">An optional <code class="email">doctstring</code> (this is the documentation string)</li><li class="listitem">The attribute map</li><li class="listitem">The <code class="email">dispatch-fn</code> function</li></ul></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note18" class="calibre1"/>Note</h3><p class="calibre7">The <code class="email">dispatch</code> function gets called for every piece of content; it generates a dispatch key that is later checked against its function implementation. When the dispatch key and the key in the function implementation match, the function is called.</p></div><p class="calibre7">The <code class="email">dispatch</code> function receives the same parameters that the function you are calling receives and returns a dispatch key that is used to determine the function that should dispatch the request.</p><p class="calibre7">Each implementation function must define a dispatch key, if it matches with the <code class="email">dispatch</code> function's result, then this function is executed.</p><p class="calibre7">An example should clarify:</p><div class="informalexample"><pre class="programlisting">(defmultiarea :shape)

(defmethodarea :square [{:keys [side]}] (* side side))

(area {:shape :square :side 5})
;;=&gt; 25</pre></div><p class="calibre7">Here, we are defining a multimethod called <code class="email">area</code>; the <code class="email">defmulti</code> statement has the following structure:</p><div class="informalexample"><pre class="programlisting">(defmultifunction-name dispatch-function)</pre></div><p class="calibre7">In this case, the<a id="id179" class="calibre1"/> multimethod is called <code class="email">area</code> and the <code class="email">dispatch</code> function is the <code class="email">:shape</code> keyword.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note19" class="calibre1"/>Note</h3><p class="calibre7">Remember, keywords can be used as functions that look up themselves in maps. So, for example, the result of (<code class="email">:shape {:shape :square}</code>) is <code class="email">:square</code>.</p></div><p class="calibre7">Afterwards, we define a method, as shown:</p><div class="informalexample"><pre class="programlisting">(defmethodfunction-name dispatch-key [params] function-body)</pre></div><p class="calibre7">Note that the <code class="email">dispatch-key</code> is always the result of invoking the <code class="email">dispatch-function</code> with <code class="email">params</code> as parameters.</p><p class="calibre7">Finally, let's look at the invocation, <code class="email">(area {:shape :square :side 5})</code> which is calling a multimethod. The first thing that happens is that we call the dispatch function <code class="email">:shape</code>, as shown:</p><div class="informalexample"><pre class="programlisting">(:shape {:shape :square :side 5})
;; :square</pre></div><p class="calibre7">The <code class="email">:square</code> function is now the dispatch key, we need to look for the method that has that dispatch key; in this case, the only method that we defined works. So, the function is executed and we get the result of <code class="email">25</code>.</p><p class="calibre7">It is pretty simple to add the area and perimeter for both square and circle, lets check the implementation:</p><div class="informalexample"><pre class="programlisting">(defmethodarea :circle [{:keys [radius]}]
(* Math/PI radius radius))

(defmultiperimeter :shape)

(defmethodperimeter :square [{:keys [side]}] (* side 4))

(defmethodperimeter :circle [{:keys [radius]}] (* 2 Math/PI radius))</pre></div><p class="calibre7">Now, we have defined how to calculate the perimeter and area of circles and squares with very little effort and without having to define a very strict object hierarchy. However, we are just starting to uncover the power of multimethods.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note20" class="calibre1"/>Note</h3><p class="calibre7">Keywords can be namespaced, it allows you to keep your code better organized. There are two ways to define a namespaced keyword, such as <code class="email">:namespace/keyword</code> and <code class="email">::keyword</code>. When using the <code class="email">::</code> notation, the used namespace is the current namespace. So if you write <code class="email">::test</code> in the REPL, you will be defining <code class="email">:user/test</code>.</p></div><p class="calibre7">Let's try another<a id="id180" class="calibre1"/> example, copy the following code into your REPL:</p><div class="mediaobject"><img src="../images/00015.jpeg" alt="Multimethods in Clojure" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">As you can see, it just works as you might expect it to. However, let's see how you can create a keyword hierarchy to be a little bit more flexible than this.</p></div>

<div class="book" title="Multimethods in Clojure">
<div class="book" title="Keyword hierarchies"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec36" class="calibre1"/>Keyword hierarchies</h2></div></div></div><p class="calibre7">You can <a id="id181" class="calibre1"/>declare that a keyword derives from another keyword and then respond to other dispatch keys, for that you can use the <code class="email">derive</code> function:</p><div class="informalexample"><pre class="programlisting">(derive ::hominid ::primate)</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip17" class="calibre1"/>Tip</h3><p class="calibre7">When defining a keyword hierarchy, you have to use namespaced keywords.</p></div><p class="calibre7">Here, you are declaring that the <code class="email">::hominid</code> key is derived from the <code class="email">::animal</code> key and you can now use <code class="email">::hominid</code> as <code class="email">::animal</code>; let's see that now:</p><div class="informalexample"><pre class="programlisting">(walk {:type ::hominid})
;; Primate Walk</pre></div><p class="calibre7">We do have some problems when defining hierarchies, for instance what will happen if the same keyword were to be derived from two conflicting keywords? Let's give it a try:</p><div class="informalexample"><pre class="programlisting">(derive ::hominid ::animal)

(walk {:type ::hominid})
;;java.lang.IllegalArgumentException: Multiple methods in multimethod 'walk' match dispatch value: :boot.user/hominid -&gt; :boot.user/animal and :boot.user/primate, and neither is preferred</pre></div><p class="calibre7">We get <a id="id182" class="calibre1"/>an error that says, there are two methods that match the dispatch value. Since our hominid derives both from animal and primate, it doesn't know which to resolve.</p><p class="calibre7">We can work this out explicitly with:</p><div class="informalexample"><pre class="programlisting">(prefer-method walk ::hominid ::primate)
(walk {:type ::hominid})
; Primate walk</pre></div><p class="calibre7">Now, everything works correctly. We know that we prefer to resolve to a primate when calling the walk multimethod with the hominid key.</p><p class="calibre7">You can also define a more specific method, just for the <code class="email">hominid</code> key:</p><div class="informalexample"><pre class="programlisting">(defmethodwalk ::hominid [_] "Walk in two legs")

(walk {:type ::hominid})
;; Walk in two legs</pre></div><p class="calibre7">The derivation hierarchy can get a little complex and we might need some functions to introspect relationships. Clojure has the following functions to work with type hierarchies.</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">isa?</code></li><li class="listitem"><code class="email">parents</code></li><li class="listitem"><code class="email">descendants</code></li><li class="listitem"><code class="email">underive</code></li></ul></div><div class="book" title="isa?"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch05lvl3sec11" class="calibre1"/>isa?</h3></div></div></div><p class="calibre7">The <code class="email">isa</code> function <a id="id183" class="calibre1"/>checks if a type derives from some other type, it works with Java classes as well as Clojure keywords.</p><p class="calibre7">It is simple to explain with examples:</p><div class="informalexample"><pre class="programlisting">(isa? java.util.ArrayListjava.util.List)
;;=&gt; true

(isa? ::hominid ::animal)
;;=&gt; true

(isa? ::animal ::primate)
;;=&gt; false</pre></div></div><div class="book" title="parents"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch05lvl3sec12" class="calibre1"/>parents</h3></div></div></div><p class="calibre7">The <code class="email">parent</code> function<a id="id184" class="calibre1"/> returns a set of a type's parents, they might be Java or Clojure keywords:</p><div class="informalexample"><pre class="programlisting">(parents java.util.ArrayList)
;;=&gt; #{java.io.Serializablejava.util.Listjava.lang.Cloneablejava.util.RandomAccessjava.util.AbstractList}

(parents ::hominid)
#{:user/primate :user/animal}</pre></div></div><div class="book" title="descendants"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch05lvl3sec13" class="calibre1"/>descendants</h3></div></div></div><p class="calibre7">The <a id="id185" class="calibre1"/>
<code class="email">descendants</code> function, as you can imagine, returns a set of descendants of the <code class="email">passd</code> keyword; it is important to keep in mind that in this case only Clojure keywords are allowed:</p><div class="informalexample"><pre class="programlisting">(descendants ::animal)
;;=&gt; #{:boot.user/hominid}</pre></div></div><div class="book" title="underive"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch05lvl3sec14" class="calibre1"/>underive</h3></div></div></div><p class="calibre7">The <a id="id186" class="calibre1"/>
<code class="email">underive</code> function breaks the relation between two types, as you can imagine it only works with the Clojure keywords:</p><div class="informalexample"><pre class="programlisting">(underive ::hominid ::animal)
;;=&gt; (isa? ::hominid ::animal)</pre></div><p class="calibre7">This function will normally be used at development time and they allow you to play around with your type hierarchy in a very simple and dynamic way.</p></div></div></div>

<div class="book" title="Multimethods in Clojure">
<div class="book" title="A la carte dispatch functions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec37" class="calibre1"/>A la carte dispatch functions</h2></div></div></div><p class="calibre7">Until now, we<a id="id187" class="calibre1"/> have used a keyword as a dispatch function but you can use any function you like with as many arguments as you want. Let's take <a id="id188" class="calibre1"/>a look at some examples:</p><div class="informalexample"><pre class="programlisting">(defn dispatch-func [arg1 arg2]
  [arg2 arg1])</pre></div><p class="calibre7">This is a simple function, but it shows two important facts:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="email">dispatch</code> function can receive more than one argument</li><li class="listitem">The <code class="email">dispatch</code> key can be anything, not just a keyword</li></ul></div><p class="calibre7">Lets have a look at how we can use this <code class="email">dispatch</code> function:</p><div class="informalexample"><pre class="programlisting">(defmulti sample-multimethod dispatch-func)
;; Here we are saying that we want to use dispatch-func to calculate the dispatch-key

(defmethod sample-multimethod [:second :first] [first second] [:normal-params first second])
(defmethod sample-multimethod [:first :second] [first second] [:switch-params second first])

(sample-multimethod :first :second)
;;=&gt; [:normal-params :first: second]

(sample-multimethod :second :first)
;; =&gt;[:switch-params :first: second]</pre></div><p class="calibre7">We are getting to know the <code class="email">dispatch</code> function a little bit better; now that you know that you can implement any <code class="email">dispatch</code> function, you have a very fine grained control over what function gets called and when.</p><p class="calibre7">Lets look at one more example, so we can finally grasp the complete idea:</p><div class="mediaobject"><img src="../images/00016.jpeg" alt="A la carte dispatch functions" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Now the<a id="id189" class="calibre1"/> true power of multimethods becomes apparent. You <a id="id190" class="calibre1"/>now have an adhoc way of defining polymorphic functions which has the possibility to define type hierarchies and even execute your own logic to determine the function that is going to be called finally.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Protocols in Clojure" id="181NK1-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec36" class="calibre1"/>Protocols in Clojure</h1></div></div></div><p class="calibre7">Multimethods are <a id="id191" class="calibre1"/>just one of the options for polymorphism you have in Clojure, there are other ways to implement polymorphic functions.</p><p class="calibre7">Protocols are a little easier to understand and they might feel more similar to Java interfaces.</p><p class="calibre7">Lets try to define our shape program using protocols:</p><div class="informalexample"><pre class="programlisting">(defprotocol Shape
  "This is a protocol for shapes"
  (perimeter [this] "Calculates the perimeter of this shape")
  (area [this] "Calculates the area of this shape"))</pre></div><p class="calibre7">Here, we have defined a protocol and it is called shaped and everything that implements this protocol must implement the following two functions: <code class="email">perimeter</code> and <code class="email">area</code>.</p><p class="calibre7">There are <a id="id192" class="calibre1"/>a number of ways to implement a protocol; one interesting feature is that you can even extend Java classes to implement a protocol without an access to the Java source and without having to recompile anything.</p><p class="calibre7">Let's start by creating a record that implements the type.</p></div>

<div class="book" title="Protocols in Clojure" id="181NK1-f3eee9b8c89a4c399520b72f8d890ddc">
<div class="book" title="Records in Clojure"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec38" class="calibre1"/>Records in Clojure</h2></div></div></div><p class="calibre7">Records work<a id="id193" class="calibre1"/> exactly like maps, but they are much faster if you stick to the predefined keys. Defining a record is similar to defining a class, Clojure knows beforehand about the fields that the record will have, so it can generate byte code on the fly and the code that uses the records is much faster.</p><p class="calibre7">Lets define a <code class="email">Square</code> record, as shown:</p><div class="informalexample"><pre class="programlisting">(defrecord Square [side]
  Shape
  (perimeter [{:keys [side]}] (* 4 side))
  (area [{:keys [side]}] (* side side)))</pre></div><p class="calibre7">Here, we are defining the <code class="email">Square</code> record and it has the following properties:</p><div class="book"><ul class="itemizedlist"><li class="listitem">It has only one field, <code class="email">size</code>; this is going to work as a map with only the side key</li><li class="listitem">It implements the <code class="email">Shape</code> protocol</li></ul></div><p class="calibre7">Lets have a look at how a record is instantiated and how we can use it:</p><div class="informalexample"><pre class="programlisting">(Square. 5)
;;=&gt; #user/Square{:size 5}

(def square (Square. 5))

(let [{side :side} square] side)
;;=&gt; 5

(let [{:keys [side]} square] side)
;;=&gt; 5

(doseq [[k v] (Square. 5)] (println k v))
;; :side 5</pre></div><p class="calibre7">As you can see it works exactly like a map, you can even associate things to it:</p><div class="informalexample"><pre class="programlisting">(assoc (Square. 5) :hello :world)</pre></div><p class="calibre7">The downside of doing this is that we no longer have the performance guarantees that we had when defining just the record fields; nonetheless, it is a great way of giving some structure to our code.</p><p class="calibre7">We still have<a id="id194" class="calibre1"/> to check how we can use our perimeter and area functions, it is pretty simple. Let's have a look:</p><div class="informalexample"><pre class="programlisting">(perimeter square)
;;=&gt; 20

(area square)
;;=&gt; 25</pre></div><p class="calibre7">Just to continue with the example, let's define the <code class="email">Circle</code> record:</p><div class="informalexample"><pre class="programlisting">(defrecord Circle [radius]
  Shape
  (perimeter [{:keys [radius]}] (* Math/PI 2 radius))
  (area [{:keys [radius]}] (* Math/PI radius radius)))

(def circle (Circle. 5))

(perimeter circle)
;;=&gt; 31.41592653589793

(area circle)
;;=&gt; 78.53981633974483</pre></div><p class="calibre7">One of the promises was that we will be able to extend our existing records and types without having to touch the current code. Well, lets keep to that promise and check how to extend our records without having to touch existing code.</p><p class="calibre7">Imagine, we need to add a predicate telling us whether a shape has an area or not; we might then define the next protocol, as shown:</p><div class="informalexample"><pre class="programlisting">(defprotocolShapeProperties
  (num-sides [this] "How many sides a shape has"))</pre></div><p class="calibre7">Let's get directly to the extend type, which is going to help us define this <code class="email">num-sides</code> function for our old protocols. Note that with <code class="email">extend-type</code> we can even define functions for existing Java types:</p><div class="informalexample"><pre class="programlisting">(extend-type Square
ShapeProperties
  (num-sides [this] 4))

(extend-type Circle
ShapeProperties
  (num-sides [this] Double/POSITIVE_INFINITY))

(num-sides square)
;;=&gt; 4

(num-sides circle)
;;=&gt; Infinity</pre></div><p class="calibre7">Protocols <a id="id195" class="calibre1"/>become much more interesting when you extend them for Java types. Lets create a protocol that includes some functions for list like structures:</p><div class="informalexample"><pre class="programlisting">(defprotocolListOps
  (positive-values [list])
  (negative-values [list])
  (non-zero-values [list]))

(extend-type java.util.List
ListOps
  (positive-values [list]
    (filter #(&gt; % 0) list))
  (negative-values [list]
    (filter #(&lt; % 0) list))
  (non-zero-values [list]
    (filter #(not= % 0) list)))</pre></div><p class="calibre7">And now you can use the positive values, negative values and <code class="email">non-zero-values</code> with anything that extends from <code class="email">java.util.List</code>, including Clojure's vectors:</p><div class="informalexample"><pre class="programlisting">(positive-values [-1 0 1])
;;=&gt; (1)

(negative-values [-1 0 1])
;;=&gt; (-1)

(no-zero-values [-1 0 1])
;;=&gt; (-1 1)</pre></div><p class="calibre7">It might not be very exciting to extend <code class="email">java.util.List</code>, since you can define these three as functions and it works the same way but you can extend any custom Java type with this mechanism.</p></div></div>
<div class="book" title="Summary" id="190861-f3eee9b8c89a4c399520b72f8d890ddc"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec37" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">Now we understand Clojure's way a little bit better and we have a better grasp of what to look for when we need polymorphism. We understand that when needing a polymorphic function we have several options:</p><div class="book"><ul class="itemizedlist"><li class="listitem">We can implement multimethods if we need a highly customized dispatching mechanism</li><li class="listitem">We can implement multimethods if we need to define a complex inheritance structure</li><li class="listitem">We can implement a protocol and define a custom type that implements that protocol</li><li class="listitem">We can define a protocol and extend existing Java or Clojure types with our custom functions for each type</li></ul></div><p class="calibre7">Polymorphism in Clojure is very powerful. It allows you to extend the functionality of Clojure or Java types that already exist; it feels like adding methods to an interface. The best thing about it is that you don't need to redefine or recompile anything.</p><p class="calibre7">In the next chapter, we will talk about concurrency—one of the key features of Clojure. We will learn about the idea of what the identity and values are and how those key concepts make writing concurrent programs much easier.</p></div></body></html>