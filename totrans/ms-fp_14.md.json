["```java\n:help \n```", "```java\nscala> var foo = 3\nfoo: Int = 3\n```", "```java\nscala> var foo = 3\nfoo: Int = 3\n\nscala> foo = 20\nfoo: Int = 20\n```", "```java\nscala> val bar = 3\nbar: Int = 3\n```", "```java\nscala> val bar = 3\nbar: Int = 3\n\n```", "```java\nscala> bar = 20\n<console>:12: error: reassignment to val\n       bar = 20\n```", "```java\nscala> def square(x: Int) = x * x\nsquare: (x: Int)Int\n\nscala> square(10)\nres0: Int = 100\n\nscala> square(2)\nres1: Int = 4\n```", "```java\nscala> val x = { println(\"x value is evaluated now\"); 10 }\nx value is evaluated now\nx: Int = 10\n\nscala> lazy val x = { println(\"x value is evaluated now\"); 10 }\nx: Int = <lazy>\n\nscala> x\nx value is evaluated now\nres2: Int = 10\n```", "```java\nscala> var x: Int = 5\nx: Int = 5\n\nscala> var x: String = 4\n<console>:11: error: type mismatch;\n found : Int(4)\n required: String\n       var x: String = 4\n                       ^\n\nscala> val x: Int = 5\nx: Int = 5\n\nscala> def square(x: Int): Int = x * x\nsquare: (x: Int)Int\n```", "```java\nscala> val flag = true\nflag: Boolean = true\n\nscala> if (flag) {\n     | println(\"Flag is true\")\n     | }\nFlag is true\n\nscala> if (!flag) {\n     | println(\"Flag is false\")\n     | } else {\n     | println(\"Flag is true\")\n     | }\nFlag is true\n\nscala> var x: Int = 0\nx: Int = 0\n\nscala> while (x < 5) {\n     | x += 1\n     | println(s\"x = $x\")\n     | }\nx = 1\nx = 2\nx = 3\nx = 4\nx = 5\n```", "```java\nscala> if (flag) println(\"Flag is true\")\nFlag is true\n```", "```java\nscala> val list = 0 to 3\nlist: scala.collection.immutable.Range.Inclusive = Range 0 to 3\n\nscala> val result =\n     | for {\n     |   e <- list\n     |   list2 = 0 to e\n     |   e2 <- list2\n     | } yield (e, e2)\nresult: scala.collection.immutable.IndexedSeq[(Int, Int)] = Vector((0,0), (1,0), (1,1), (2,0), (2,1), (2,2), (3,0), (3,1), (3,2), (3,3))\n\nscala> println(result.mkString(\"\\n\"))\n(0,0)\n(1,0)\n(1,1)\n(2,0)\n(2,1)\n(2,2)\n(3,0)\n```", "```java\n(3,1)\n(3,2)\n(3,3)\n```", "```java\nscala> val result = list.flatMap { e =>\n     | val list2 = 0 to e\n     | list2.map { e2 => (e, e2) }\n     | }\nresult: scala.collection.immutable.IndexedSeq[(Int, Int)] = Vector((0,0), (1,0), (1,1), (2,0), (2,1), (2,2), (3,0), (3,1), (3,2), (3,3))\n```", "```java\nscala> val opt1 = Some(3)\nopt1: Some[Int] = Some(3)\n\nscala> val opt2 = Some(2)\nopt2: Some[Int] = Some(2)\n\nscala> val opt3: Option[Int] = None\nopt3: Option[Int] = None\n\nscala> val res1 =\n     | for {\n     |   e1 <- opt1\n     |   e2 <- opt2\n     | } yield e1 * e2\nres1: Option[Int] = Some(6)\n\nscala> val res2 =\n     | for {\n     |   e1 <- opt1\n     |   e3 <- opt3\n     | } yield e1 * e3\nres2: Option[Int] = None\n```", "```java\nscala> val str = \"Foo\"\nstr: String = Foo\n\nscala> str match {\n     | case \"Bar\" => println(\"It is a bar\")\n     | case \"Foo\" => println(\"It is a foo\")\n     | }\nIt is a foo\n```", "```java\nscala> val list = List(1, 2, 3, 4, 5)\nlist: List[Int] = List(1, 2, 3, 4, 5)\n\nscala> list match {\n     | case e1 :: e2 :: rest => e1 + e2\n     | }\n<console>:13: warning: match may not be exhaustive.\nIt would fail on the following inputs: List(_), Nil\n       list match {\n       ^\nres10: Int = 3\n```", "```java\nscala> class Dummy(x: Int) { val xSquared = x * x }\ndefined class Dummy\n\nscala> object square {\n     | def unapply(d: Dummy): Option[Int] = Some(d.xSquared)\n     | }\ndefined object square\n\nscala> new Dummy(3) match {\n     | case square(s) => println(s\"Square is $s\")\n     | }\nSquare is 9\n```", "```java\nscala> val findSquare: PartialFunction[Any, Int] = {\n     | case x: Int => x * x\n     | case square(s) => s\n     | }\nfindSquare: PartialFunction[Any,Int] = <function1>\n\nscala> findSquare(2)\nres12: Int = 4\n\nscala> findSquare(new Dummy(3))\nres13: Int = 9\n\nscala> findSquare(\"Stuff\")\nscala.MatchError: Stuff (of class java.lang.String)\n  at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:255)\n  at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:253)\n  at $anonfun$1.applyOrElse(<console>:13)\n  at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:34)\n  ... 28 elided\n```", "```java\nscala> :paste\n// Entering paste mode (ctrl-D to finish)\n\nclass Dummy(constructorArgument: String) {\n  var variable: Int = 0\n  val value: String = constructorArgument * 2\n  def method(x: Int): String = s\"You gave me $x\"\n}\n\n// Exiting paste mode, now interpreting.\n\ndefined class Dummy\n\nscala> new Dummy(\"Foo\")\nres15: Dummy = Dummy@1a2f7e20\n\nscala> res15.variable\nres16: Int = 0\n\nscala> res15.value\nres17: String = FooFoo\n\nscala> res15.method(2)\nres18: String = You gave me 2\n```", "```java\nscala> case class User(id: Int, name: String, passwordHash: String)\ndefined class User\n```", "```java\nscala> val user = User(1, \"dummyuser123\", \"d8578edf8458ce06fbc5bb76a58c5ca4\")\nuser: User = User(1,dummyuser123,d8578edf8458ce06fbc5bb76a58c5ca4)\n\nscala> user match {\n     | case User(id, name, hash) => println(s\"The user $name has id $id and password hash $hash\")\n     | }\nThe user dummyuser123 has id 1 and password hash d8578edf8458ce06fbc5bb76a58c5ca4\n```", "```java\nscala> user.toString\nres20: String = User(1,dummyuser123,d8578edf8458ce06fbc5bb76a58c5ca4)\n\nscala> val user2 = User(user.id, user.name, user.passwordHash)\nuser2: User = User(1,dummyuser123,d8578edf8458ce06fbc5bb76a58c5ca4)\n\nscala> user.equals(user2)\nres21: Boolean = true\n\nscala> user.hashCode\nres22: Int = -363163489\n\nscala> user2.hashCode\nres23: Int = -363163489\n```", "```java\nscala> :paste\n// Entering paste mode (ctrl-D to finish)\n\ntrait Foo {\n  def saySomething = println(\"I am inherited from Foo\")\n}\n\n// Exiting paste mode, now interpreting.\n\ndefined trait Foo\n```", "```java\nscala> :paste\n// Entering paste mode (ctrl-D to finish)\n\ntrait Foo {\n  def saySomething = println(\"I am inherited from Foo\")\n}\n\ntrait Bar {\n  def saySomething = println(\"I am inherited from Bar\")\n}\n\nclass Dummy extends Foo with Bar {\n  override def saySomething = super.saySomething\n}\n\n// Exiting paste mode, now interpreting.\n\ndefined trait Foo\ndefined trait Bar\ndefined class Dummy\n\nscala> new Dummy().saySomething\nI am inherited from Bar\n```", "```java\nscala> :paste\n// Entering paste mode (ctrl-D to finish)\n\nobject Foo {\n  def say = println(\"I am Foo\")\n}\n\n// Exiting paste mode, now interpreting.\n\ndefined object Foo\n\nscala> Foo.say\nI am Foo\n```"]