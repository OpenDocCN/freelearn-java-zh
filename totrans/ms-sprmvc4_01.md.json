["```java\n$ curl http://start.Spring.io/starter.tgz \\\n-d name=masterSpringMvc  \\\n-d dependencies=web \\\n-d language=java \\\n-d JavaVersion=1.8 \\\n-d type=gradle-project \\\n-d packageName=masterSpringMvc \\\n-d packaging=jar \\\n-d baseDir=app | tar -xzvf -\n% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\nDload  Upload   Total   Spent    Left  Speed\n100  1255  100  1119  100   136   1014    123  0:00:01  0:00:01 --:--:--  1015\nx app/\nx app/src/\nx app/src/main/\nx app/src/main/Java/\nx app/src/main/Java/com/\nx app/src/main/Java/com/geowarin/\nx app/src/main/resources/\nx app/src/main/resources/static/\nx app/src/main/resources/templates/\nx app/src/test/\nx app/src/test/Java/\nx app/src/test/Java/com/\nx app/src/test/Java/com/geowarin/\nx app/build.Gradle\nx app/src/main/Java/com/geowarin/AppApplication.Java\nx app/src/main/resources/application.properties\nx app/src/test/Java/com/geowarin/AppApplicationTests.Java\n\n```", "```java\n$ cd app\n$ git init\n\n```", "```java\n# IntelliJ project files\n.idea\n*.iml\n\n# gradle\n.gradle\nbuild\n```", "```java\n$ git add .\n$ git commit -m \"Generated with curl start.Spring.io\"\n[master (root-commit) eded363] Generated with curl start.Spring.io\n4 files changed, 75 insertions(+)\ncreate mode 100644 build.Gradle\ncreate mode 100644 src/main/Java/com/geowarin/AppApplication.Java\ncreate mode 100644 src/main/resources/application.properties\ncreate mode 100644 src/test/Java/com/geowarin/AppApplicationTests.Java\n\n```", "```java\n$ gradle wrapper\n:wrapper\n\nBUILD SUCCESSFUL\n\nTotal time: 6.699 secs\n\n```", "```java\n$ git status -s\n?? .gradle/\n?? gradle/\n?? gradlew\n?? gradlew.bat\n\n```", "```java\n$ git add .\n$ git commit -m \"Added Gradle wrapper\"\n\n```", "```java\n$ ./gradlew bootrun\n\n```", "```java\nbuildscript {\n    ext {\n        springBootVersion = '1.2.5.RELEASE'\n    }\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath(\"org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}\") \n        classpath(\"io.spring.gradle:dependency-management-plugin:0.5.1.RELEASE\")\n    }\n}\n\napply plugin: 'java'\napply plugin: 'eclipse'\napply plugin: 'idea'\napply plugin: 'spring-boot' \napply plugin: 'io.spring.dependency-management' \n\njar {\n    baseName = 'masterSpringMvc'\n    version = '0.0.1-SNAPSHOT'\n}\nsourceCompatibility = 1.8\ntargetCompatibility = 1.8\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    compile(\"org.springframework.boot:spring-boot-starter-web\")\n    testCompile(\"org.springframework.boot:spring-boot-starter-test\") \n}\n\neclipse {\n    classpath {\n         containers.remove('org.eclipse.jdt.launching.JRE_CONTAINER')\n         containers 'org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8'\n    }\n}\n\ntask wrapper(type: Wrapper) {\n    gradleVersion = '2.3'\n}\n```", "```java\n./gradlew build\n\n```", "```java\npackage masterSpringMvc;\n\nimport org.Springframework.boot.SpringApplication;\nimport org.Springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class AppApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AppApplication.class, args);\n    }\n}\n```", "```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@Configuration\n@EnableAutoConfiguration\n@ComponentScan\npublic @interface SpringBootApplication {\n\n  /**\n  * Exclude specific auto-configuration classes such that they will never be applied.\n  */\n  Class<?>[] exclude() default {};\n}\n```", "```java\npackage masterSpringMvc.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@Controller\npublic class HelloController {\n\n    @RequestMapping(\"/\")\n    @ResponseBody\n    public String hello() {\n        return \"Hello, world!\";\n    }\n}\n```", "```java\ndebug=true\n```", "```java\n=========================\nAUTO-CONFIGURATION REPORT\n=========================\n\nPositive matches:\n-----------------\n\n DispatcherServletAutoConfiguration\n - @ConditionalOnClass classes found: org.Springframework.web.servlet.DispatcherServlet (OnClassCondition)\n - found web application StandardServletEnvironment (OnWebApplicationCondition)\n\n EmbeddedServletContainerAutoConfiguration\n - found web application StandardServletEnvironment (OnWebApplicationCondition)\n\n ErrorMvcAutoConfiguration\n - @ConditionalOnClass classes found: javax.servlet.Servlet,org.springframework.web.servlet.DispatcherServlet (OnClassCondition)\n - found web application StandardServletEnvironment (OnWebApplicationCondition)\n\n HttpEncodingAutoConfiguration\n - @ConditionalOnClass classes found: org.springframework.web.filter.CharacterEncodingFilter (OnClassCondition)\n - matched (OnPropertyCondition)\n\n<Input trimmed>\n\n```", "```java\n/**\n* {@link EnableAutoConfiguration Auto-configuration} for the Spring\n* {@link DispatcherServlet}. Should work for a standalone application where an embedded\n* servlet container is already present and also for a deployable application using\n* {@link SpringBootServletInitializer}.\n*\n* @author Phillip Webb\n* @author Dave Syer\n*/\n@Order(Ordered.HIGHEST_PRECEDENCE)\n@Configuration\n@ConditionalOnWebApplication\n@ConditionalOnClass(DispatcherServlet.class)\n@AutoConfigureAfter(EmbeddedServletContainerAutoConfiguration.class)\npublic class DispatcherServletAutoConfiguration {\n\n    /*\n    * The bean name for a DispatcherServlet that will be mapped to the root URL \"/\"\n    */\n    public static final String DEFAULT_DISPATCHER_SERVLET_BEAN_NAME = \"dispatcherServlet\";\n\n    /*\n    * The bean name for a ServletRegistrationBean for the DispatcherServlet \"/\"\n    */\n    public static final String DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME = \"dispatcherServletRegistration\";\n\n    @Configuration\n    @Conditional(DefaultDispatcherServletCondition.class)\n    @ConditionalOnClass(ServletRegistration.class)\n    protected static class DispatcherServletConfiguration {\n\n        @Autowired\n        private ServerProperties server;\n\n        @Autowired(required = false)\n        private MultipartConfigElement multipartConfig;\n\n        @Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)\n        public DispatcherServlet dispatcherServlet() {\n            return new DispatcherServlet();\n        }\n\n        @Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)\n        public ServletRegistrationBean dispatcherServletRegistration() {\n            ServletRegistrationBean registration = new ServletRegistrationBean(\n                    dispatcherServlet(), this.server.getServletMapping());\n            registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);\n            if (this.multipartConfig != null) {\n                registration.setMultipartConfig(this.multipartConfig);\n            }\n            return registration;\n        }\n\n        @Bean\n        @ConditionalOnBean(MultipartResolver.class)\n        @ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)\n        public MultipartResolver multipartResolver(MultipartResolver resolver) {\n            // Detect if the user has created a MultipartResolver but named it incorrectly\n            return resolver;\n        }\n\n    }\n\n    @Order(Ordered.LOWEST_PRECEDENCE - 10)\n    private static class DefaultDispatcherServletCondition extends SpringBootCondition {\n\n        @Override\n        public ConditionOutcome getMatchOutcome(ConditionContext context,\n                AnnotatedTypeMetadata metadata) {\n            ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n            ConditionOutcome outcome = checkServlets(beanFactory);\n            if (!outcome.isMatch()) {\n                return outcome;\n            }\n            return checkServletRegistrations(beanFactory);\n        }\n\n    }\n}\n```", "```java\n@Configuration\n@Import(EnableWebMvcConfiguration.class)\n@EnableConfigurationProperties({ WebMvcProperties.class, ResourceProperties.class })\npublic static class WebMvcAutoConfigurationAdapter extends WebMvcConfigurerAdapter {\n\n  @Value(\"${spring.view.prefix:}\")\n  private String prefix = \"\";\n\n  @Value(\"${spring.view.suffix:}\")\n  private String suffix = \"\";\n\n  @Bean\n  @ConditionalOnMissingBean(InternalResourceViewResolver.class)\n  public InternalResourceViewResolver defaultViewResolver() {\n    InternalResourceViewResolver resolver = new InternalResourceViewResolver();\n    resolver.setPrefix(this.prefix);\n    resolver.setSuffix(this.suffix);\n    return resolver;\n  }\n}\n```", "```java\nprivate static final String[] CLASSPATH_RESOURCE_LOCATIONS = {\n    \"classpath:/META-INF/resources/\", \"classpath:/resources/\",\n    \"classpath:/static/\", \"classpath:/public/\" };\n\nprivate static final String[] RESOURCE_LOCATIONS;\nstatic {\n  RESOURCE_LOCATIONS = new String[CLASSPATH_RESOURCE_LOCATIONS.length\n      + SERVLET_RESOURCE_LOCATIONS.length];\n  System.arraycopy(SERVLET_RESOURCE_LOCATIONS, 0, RESOURCE_LOCATIONS, 0,\n      SERVLET_RESOURCE_LOCATIONS.length);\n  System.arraycopy(CLASSPATH_RESOURCE_LOCATIONS, 0, RESOURCE_LOCATIONS,\n      SERVLET_RESOURCE_LOCATIONS.length, CLASSPATH_RESOURCE_LOCATIONS.length);\n}\n\n@Override\npublic void addResourceHandlers(ResourceHandlerRegistry registry) {\n  if (!this.resourceProperties.isAddMappings()) {\n    logger.debug(\"Default resource handling disabled\");\n    return;\n  }\n\n  Integer cachePeriod = this.resourceProperties.getCachePeriod();\n  if (!registry.hasMappingForPattern(\"/webjars/**\")) {\n    registry.addResourceHandler(\"/webjars/**\")\n        .addResourceLocations(\"classpath:/META-INF/resources/webjars/\")\n        .setCachePeriod(cachePeriod);\n  }\n  if (!registry.hasMappingForPattern(\"/**\")) {\n    registry.addResourceHandler(\"/**\")\n        .addResourceLocations(RESOURCE_LOCATIONS)\n        .setCachePeriod(cachePeriod);\n  }\n}\n```", "```java\n@Bean\n@ConditionalOnMissingBean(LocaleResolver.class)\n@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"locale\")\npublic LocaleResolver localeResolver() {\n  return new FixedLocaleResolver(\n      StringUtils.parseLocaleString(this.mvcProperties.getLocale()));\n}\n```", "```java\nConditionalOnClass({ Servlet.class, DispatcherServlet.class })\n@ConditionalOnWebApplication\n// Ensure this loads before the main WebMvcAutoConfiguration so that the error View is\n// available\n@AutoConfigureBefore(WebMvcAutoConfiguration.class)\n@Configuration\npublic class ErrorMvcAutoConfiguration implements EmbeddedServletContainerCustomizer,\n        Ordered {\n\n    @Value(\"${error.path:/error}\")\n    private String errorPath = \"/error\";\n\n    @Autowired\n    private ServerProperties properties;\n\n    @Override\n    public int getOrder() {\n        return 0;\n    }\n\n    @Bean\n    @ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)\n    public DefaultErrorAttributes errorAttributes() {\n        return new DefaultErrorAttributes();\n    }\n\n    @Bean\n    @ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT)\n    public BasicErrorController basicErrorController(ErrorAttributes errorAttributes) {\n        return new BasicErrorController(errorAttributes);\n    }\n\n    @Override\n    public void customize(ConfigurableEmbeddedServletContainer container) {\n        container.addErrorPages(new ErrorPage(this.properties.getServletPrefix()\n                + this.errorPath));\n    }\n\n    @Configuration\n    @ConditionalOnProperty(prefix = \"error.whitelabel\", name = \"enabled\", matchIfMissing = true)\n    @Conditional(ErrorTemplateMissingCondition.class)\n    protected static class WhitelabelErrorViewConfiguration {\n\n        private final SpelView defaultErrorView = new SpelView(\n                \"<html><body><h1>Whitelabel Error Page</h1>\"\n                        + \"<p>This application has no explicit mapping for /error, so you are seeing this as a fallback.</p>\"\n                        + \"<div id='created'>${timestamp}</div>\"\n                        + \"<div>There was an unexpected error (type=${error}, status=${status}).</div>\"\n                        + \"<div>${message}</div></body></html>\");\n\n        @Bean(name = \"error\")\n        @ConditionalOnMissingBean(name = \"error\")\n        public View defaultErrorView() {\n            return this.defaultErrorView;\n        }\n\n        // If the user adds @EnableWebMvc then the bean name view resolver from\n        // WebMvcAutoConfiguration disappears, so add it back in to avoid disappointment.\n        @Bean\n        @ConditionalOnMissingBean(BeanNameViewResolver.class)\n        public BeanNameViewResolver beanNameViewResolver() {\n            BeanNameViewResolver resolver = new BeanNameViewResolver();\n            resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10);\n            return resolver;\n        }\n\n    }\n}\n```", "```java\n@Order(Ordered.HIGHEST_PRECEDENCE)\n@Configuration\n@ConditionalOnWebApplication\n@Import(EmbeddedServletContainerCustomizerBeanPostProcessorRegistrar.class)\npublic class EmbeddedServletContainerAutoConfiguration {\n\n  /**\n  * Nested configuration for if Tomcat is being used.\n  */\n  @Configuration\n  @ConditionalOnClass({ Servlet.class, Tomcat.class })\n  @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)\n  public static class EmbeddedTomcat {\n\n    @Bean\n    public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() {\n      return new TomcatEmbeddedServletContainerFactory();\n    }\n\n  }\n\n  /**\n  * Nested configuration if Jetty is being used.\n  */\n  @Configuration\n  @ConditionalOnClass({ Servlet.class, Server.class, Loader.class })\n  @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)\n  public static class EmbeddedJetty {\n\n    @Bean\n    public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() {\n      return new JettyEmbeddedServletContainerFactory();\n    }\n\n  }\n\n  /**\n  * Nested configuration if Undertow is being used.\n  */\n  @Configuration\n  @ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class })\n  @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)\n  public static class EmbeddedUndertow {\n\n    @Bean\n    public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() {\n      return new UndertowEmbeddedServletContainerFactory();\n    }\n\n  }\n}\n```", "```java\nserver.port = 8443\nserver.ssl.key-store = classpath:keystore.jks\nserver.ssl.key-store-password = secret\nserver.ssl.key-password = another-secret\n\n```"]