- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code Monitoring and Maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing efficient code is not enough to ensure that our Java applications perform
    at a high level after the initial launch of our systems. We must adopt a robust
    strategy of coding monitoring and maintenance to ensure that our systems continue
    to perform at desired levels even as data and use volumes increase and environments
    change. This chapter focuses on the critical practices, and associated tools,
    of code monitoring and maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Our chapter starts with an exploration of **Application Performance Management**
    (**APM**) tools that we can use to conduct real-time monitoring and obtain diagnostic
    data to help us keep our applications running efficiently. Our APM tool exploration
    will include use cases and implementation strategies.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of **code reviews** is also covered with the goal of instilling
    a dedication to continual process improvement, specifically to continually maintain
    code quality. Insights into best practices and automation tools will provide you
    with knowledge on how you use selected tools and practices to identify potential
    issues in your code before they cause undesired system behavior and negatively
    impact the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter also introduces the concept of logging and shares how effective
    it can be for monitoring applications. We will explore best practices, logging
    frameworks, and how to analyze log data. Our goal is to log the correct data and
    learn to use the logged data to identify optimization opportunities without introducing
    excessive system overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: APM tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code reviews
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring and alerting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintenance strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APM tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java developers spend more time maintaining their systems than they do developing
    them. This is because our systems are in production longer than it takes to write
    and test our code. It stands to reason that we should approach **Application Performance
    Management** (**APM**) seriously and appreciate the crucial role it has in our
    ability to ensure our systems continue to perform optimally and maximize the user
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: APM tool overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: APM tools are designed to help us monitor our systems to manage their performance.
    These tools provide real-time insights into how our applications are performing.
    They can help us identify potential bottlenecks and possible optimization opportunities
    such as with resource use. The metrics generated by APM tools can be measured
    against baselines and give us a true picture of our system’s overall health.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary objectives of APM tools include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring application reliability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring application scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying performance issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing actionable insights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time application monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User interaction tracking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s next look at the key features of APM tools.
  prefs: []
  type: TYPE_NORMAL
- en: APM tool key features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'AMP tools range from basic to robust and can have a varied array of features.
    The top 10 key features of AMP tools are as follows, in no specific order:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide configurable alerts based on performance thresholds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor system resource usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuously monitor application performance such as response times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify performance bottlenecks by tracing individual transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify and log exceptions and errors with sufficient detail to support troubleshooting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Track and measure user interactions such as transaction durations and load times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conduct in-depth analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide numeric and visual reporting of analytic data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate with other tools such as CI/CD pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automate performance management processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have an appreciation for the importance of APM tools, their objectives,
    and their key features, let’s review five common APM tools used for Java application
    monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Popular APM tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a plethora of AMP tools available to Java application developers. The
    table that follows lists five common tools and provides a brief description and
    URL for each.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tool** | **Description** | **URL** |'
  prefs: []
  type: TYPE_TB
- en: '| **AppDynamics** | Strong performance monitor with great visibility into Java
    applications | [https://www.appdynamics.com/product/application-performance-monitoring](https://www.appdynamics.com/product/application-performance-monitoring)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Datadog** | Cloud-based monitoring and analytics tool | [https://www.dynatrace.com/monitoring/solutions/cloud-monitoring-cio-report/](https://www.dynatrace.com/monitoring/solutions/cloud-monitoring-cio-report/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Dynatrace** | Advanced tool that leverages AI for performance monitoring
    | [https://www.dynatrace.com/monitoring/platform/application-observability/](https://www.dynatrace.com/monitoring/platform/application-observability/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Elastic APM** | Open source performance monitoring tool | [https://www.elastic.co/observability/application-performance-monitoring](https://www.elastic.co/observability/application-performance-monitoring)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **New Relic** | Perhaps the most commonly used tool, with extensive monitoring
    and analytics capabilities | [https://www.newrelic.com](https://www.newrelic.com)
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 16.1: Popular APM tools for Java applications'
  prefs: []
  type: TYPE_NORMAL
- en: Note on URLs
  prefs: []
  type: TYPE_NORMAL
- en: The URLs listed in the preceding table were valid at the time of this book’s
    initial publication date. If you find a link that is no longer valid, you can
    search for the tool name along with *APM tool for Java applications* (for example,
    *Dynatrace APM tool for Java applications*) to find the new link.
  prefs: []
  type: TYPE_NORMAL
- en: You should take the time to experiment with each APM tool to determine which
    one or ones you’d like to work with. Once you have an idea of which one(s) you
    will use, you can review the best practices presented in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: APM tool best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Regardless of which APM tool you adopt, there are several best practices that
    can help you leverage your selected tool to support your monitoring efforts. Here
    are several best practices for you to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Regularly analyze your performance data. This can help you identify trends and
    anomalies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedule and conduct periodic reviews of your APM configurations and performance
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establish clear performance monitoring goals, aligning them with your organization’s
    objectives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create your **Key Performance Indicators** (**KPIs**) and periodically review
    them for relevancy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establish a culture of performance awareness among your teams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a comprehensive approach to instrumentation to ensure that everything
    that can be monitored is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate APM tools with your DevOps processes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prioritize monitoring your most critical metrics such as error rates, response
    times, resource use, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure your APM tool to provide you with alerts and notifications for greater
    efficiency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the best practices presented here can help you maximize the benefits
    of using APM tools.
  prefs: []
  type: TYPE_NORMAL
- en: Code reviews
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code reviews are a fundamental component of software development. As we previously
    suggested, code quality does not remain constant after it goes live. Environments
    change, new data is introduced, scaling can occur, and user behavior can change.
    This underscores the importance of conducting code reviews.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purposes of code reviews are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring consistency in adherence to standards and guidelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encouraging collaboration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facilitating knowledge transfer among teams and increasing individual buy-in
    to code quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying defects and security vulnerabilities with quality assurance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s review some best practices when conducting code reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some self-descriptive best practices to consider when conducting code
    reviews:'
  prefs: []
  type: TYPE_NORMAL
- en: Automate where possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encourage constructive feedback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establish coding standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limit the size of code changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prioritize critical code sections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set code review time limits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use checklists for reviewer consistency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first best practice suggests that you automate where possible. There are
    automated code review tools worth your independent research and analysis. Here
    is a list of these to review:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Checkstyle**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code Climate**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FindBugs** and its successor, **SpotBugs**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PMD**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SonarQube**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take your time reviewing the automation tools. Once you have selected the one
    you like best, experiment with it before officially adopting it for live projects.
    Next, let’s look at peer review processes.
  prefs: []
  type: TYPE_NORMAL
- en: Peer review processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Code review is often done by peers and it can be awkward if not approached
    properly. Here are some tips for conducting proper and efficient peer reviews:'
  prefs: []
  type: TYPE_NORMAL
- en: Assign reviewers who have the appropriate expertise and experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotate reviewers to mitigate complacency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prepare for reviews by mandating in-code commenting standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use code review tools (such as GitHub pull requests) to streamline the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encourage an atmosphere of mutual respect and open communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow up on all feedback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following these tips can ease the awkwardness and improve the efficiency of
    peer reviews. Next, let’s look at some common pitfalls regarding code reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Common pitfalls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several pitfalls when conducting code reviews, although they are overshadowed
    by the benefits we get from the process. This section examines the top five pitfalls
    experienced when conducting code reviews and suggests solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pitfall** | **Solution** |'
  prefs: []
  type: TYPE_TB
- en: '| Delayed reviews | Set clear timelines and integrate them into your development
    workflow. |'
  prefs: []
  type: TYPE_TB
- en: '| Inconsistent standards | Establish clear guidelines and use checklists. |'
  prefs: []
  type: TYPE_TB
- en: '| Lack of constructive feedback | Focus on providing constructive feedback.
    Be specific and ensure that feedback is actionable. |'
  prefs: []
  type: TYPE_TB
- en: '| Neglecting automation tools | Use automation tools to your advantage. They
    can catch routine issues while your developers review more complex issues. |'
  prefs: []
  type: TYPE_TB
- en: '| Overly long reviews | Keep reviews short and frequent. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 16.2: Common code review pitfalls with solutions'
  prefs: []
  type: TYPE_NORMAL
- en: An understanding of these pitfalls can help ensure that your code reviews are
    seamlessly integrated into your workflows.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will review logging.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging data is a fundamental component of code monitoring and maintenance.
    This data can reveal information about how our code performs, where it is failing,
    what security concerns there might be, and more. It involves recording information
    about how our program runs. We can use this information for audits, debugging,
    and monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key aspects of logging include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DEBUG`, `ERROR`, and `INFO`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log messages**: These are the narrative descriptions of application events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log rotation**: We rotate logs by archiving old logs and starting new ones.
    This prevents singular, large logs that can be difficult to manage and result
    in storage issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log targets**: Targets are the storage destinations for the logs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a fundamental understanding of logging, let’s review some best
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our logging implementations should be focused on the relevancy of what is captured
    and on the efficiency of the system. With those goals in mind, here are some best
    practices regarding logging:'
  prefs: []
  type: TYPE_NORMAL
- en: Adopt a concise but descriptive mentality for logs. You will want them to be
    clear and not overly verbose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Centralize your logs to facilitate aggregated and comprehensive processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider using a structured logging format such as JSON so they are easier to
    parse and analyze.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focus on log levels that are aligned with your systems’ most critical processes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formalize your logging practices to include formats and naming conventions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protect individually identifiable or other sensitive data from being included
    in logs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review your logs regularly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will review useful logging frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Logging frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several logging frameworks that we can use for our Java applications.
    Developers typically select one after reviewing their options. Here is a list
    of some of the more popular frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.util.logging`). While it only provides basic logging capabilities, we
    can use it without the need for additional libraries. It is a good framework to
    use if you are just getting started with logging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log4j2**: This is an advanced framework that supports various configurations,
    log levels, types, and destinations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logback**: This framework provides a high-performance option compatible with
    **Simple Logging Facade for** **Java** (**SLF4J**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SLF4J**: This framework provides an abstraction to support multiple logging
    frameworks such as Logback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tinylog**: As the name suggests, this is a lightweight framework with low
    overhead. It is ideal for small applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These frameworks can help simplify our implementation and management of logging.
    Next, let’s look at key strategies for analyzing our logged data.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing log data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the primary reasons for logging systems data is to provide us with the
    ability to analyze it for the betterment of our system’s overall performance.
    Here are some strategies you can use for analyzing and managing your log data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Aggregate**: Feed your logs into a central repository for more efficient
    analysis. There are several tools (such as **Logstash** and **Elasticsearch**)
    that can be used to help with this strategy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analyze**: Use tools (such as **Datadog** and **Graylog**) to help analyze
    and visualize logged data. Use statistical analysis to gain deep insights.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automate**: Use automated alerts to inform you of activity based on thresholds
    you set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Archive**: Archive logs to avoid log bloat.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the best practices and leveraging selected frameworks and tools can
    help ensure your logging efforts are purposeful and efficient. Next, let’s look
    at how to set up monitoring and alerts.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and alerting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our log data is always available when we want to review it, but more importantly,
    it can be used to provide us with automated alerts based on how we set things
    up. Effective monitoring and alerting are key operations for maintaining our Java
    applications and ensuring their high performance and security.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and alerting can provide us with real-time insights into how our
    application is performing and promptly alert us to anything that requires immediate
    action.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring system setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The steps involved in setting up your monitoring system will depend on the
    frameworks and tools you select. Here is a six-step process that can be used irrespective
    of the frameworks and tools you select:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identify key metrics**: You need to know what you want to collect so that
    what is collected is useful. Your critical metrics might include CPU usage, memory
    use, error rates, response times, and so on. Once you have identified your key
    metrics, you can establish performance goals.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Select monitoring tools**: Select the monitoring tools (such as **Grafana**,
    **New Relic**, or **Prometheus**) that are the most appropriate for your application’s
    architecture and requirements.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Integrate monitoring agents**: Integrate monitoring agents into your Java
    application to collect performance data. Depending on your solution, you might
    add specific monitoring code, leverage built-in capabilities of existing frameworks,
    or use APIs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Set up data collection**: Configure your monitoring system to collect and
    store performance data. Be mindful and ensure that the data collection operation
    is efficient and does not result in significant application overhead.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Visualize**: Create or use dashboards provided by your monitoring tools to
    visually represent the collected data. You can use tools such as Grafana to build
    interactive dashboards that can help you quickly understand your application’s
    performance status.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Review and adjust**: Periodically review the effectiveness of your monitoring
    setup and make necessary adjustments. Reassess this each time you introduce a
    new component or service.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once your monitoring system has been set up, you will be ready to configure
    it to provide informative alerts.
  prefs: []
  type: TYPE_NORMAL
- en: Alert configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Configuring alerts involves setting thresholds and rules that trigger notifications
    when certain performance conditions are met. Follow these steps to set up an effective
    alert schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Define criteria**: Identify the conditions that you want alerts for and be
    specific. For example, you might choose 92% CPU usage, increased response times,
    spikes in errors, and so on. You can base your thresholds on historical application
    data and performance benchmarks.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Set levels**: Categorize your alerts by severity (that is, **information**,
    **warning**, **critical**) so your team can prioritize their response efforts.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Configure channels**: Set up channels for alert notifications so your team
    is informed. You might simply use **SMS**, email, **Slack**, or **Discord**, or
    implement an incident management platform such as **PagerDuty**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Fine-tune thresholds**: When setting up alerts, you want to avoid alert fatigue.
    This will require you to fine-tune your alert thresholds. Overwhelming your team
    with unnecessary alerts will negate the efficacy of your alert system.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test**: Regularly test your alert setup to ensure it works. You can even
    conduct drills to simulate performance situations to verify your system’s efficacy.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once your alert system has been set up, you need to determine your response
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Alert and incident response
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is important to establish a formal approach to incident response. When establishing
    your alert response schema, consider the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Which alerts warrant a response?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Who responds to which alerts?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What internal communication is necessary?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What external communication is required?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What follow-up actions are necessary?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A structured approach to responding to alerts and incidents can help ensure
    that critical issues are appropriately addressed. This can lead to rapid resolution
    and minimum downtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key components of an effective alert and incident response approach include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Alert acknowledgment**: When an alert is received, acknowledge it promptly.
    You may establish maximum response times for your team to follow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assessment**: Investigate each alert to understand the root causes. The goal
    is not only to fix a current issue but also to prevent the issue from repeating
    in the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Execution of plans**: Ensure that your team follows predefined incident response
    plans through issue resolution. These plans should consist of documented step-by-step
    procedures for common issues and complex problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communication**: Keep internal and external stakeholders informed about the
    incident status and resolution progress using predefined communication channels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**: After resolving the incident, the root cause(s), resolution
    steps, and lessons learned should be documented. When appropriate, conduct a post-incident
    review with your team to identify improvement opportunities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we set up a robust and purposeful monitoring and alerting system, we significantly
    increase our ability to effectively maintain and improve the performance of our
    Java applications, even as they scale.
  prefs: []
  type: TYPE_NORMAL
- en: Maintenance strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need a strategy to maintain our application’s code that goes beyond simply
    responding to system alerts. When we take a purposeful approach to code maintenance,
    we can ensure the sustained reliability, availability, and performance of our
    Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: The main concept is to maintain a balance between scheduled maintenance and
    reactive maintenance. The table that follows provides insights into each approach
    and includes their advantages and best practices.
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Scheduled maintenance** | **Reactive maintenance** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Approach details** | A planned approach to update code on scheduled intervals
    | Addressing issues as they arise |'
  prefs: []
  type: TYPE_TB
- en: '| **Advantages** |'
  prefs: []
  type: TYPE_TB
- en: Predictable downtimes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduced risks of failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continual optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Immediate issue resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires fewer resources compared to the scheduled maintenance approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Best practices** |'
  prefs: []
  type: TYPE_TB
- en: Establish and follow the maintenance schedule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test changes during maintenance windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicate the plan to internal and external stakeholders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Implement robust monitoring and alerting systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create incident response plans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create documentation to support troubleshooting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 16.3: Comparison of scheduled maintenance and reactive maintenance approaches'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have established your maintenance approach, you should consider documentation
    and knowledge management. Let’s look at that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation and knowledge management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Effective documentation and knowledge management is undeniably vital for maintaining
    a healthy code base. It can also help ensure smooth transitions during maintenance
    activities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Documentation should be comprehensive, especially for large systems. Comprehensive
    documentation should consist of the following main components:'
  prefs: []
  type: TYPE_NORMAL
- en: API documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also important to have a knowledge-sharing component, which can include
    internal wikis and training for new team members. As systems are updated, the
    knowledge-sharing artifacts should be updated to ensure that they remain relevant.
    How knowledge is shared is almost as important as what is shared. Collaboration
    tools such as **Teams**, **SharePoint**, **Confluence**, and **GitHub wikis**
    can be used to facilitate collaborative document and knowledge sharing.
  prefs: []
  type: TYPE_NORMAL
- en: Maintenance strategies often include **refactoring**, which we will review in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refactoring is the process of repurposing existing code without changing its
    external behavior. The purpose of refactoring is to improve the code’s readability,
    maintainability, and performance.
  prefs: []
  type: TYPE_NORMAL
- en: We can identify the need for refactoring through **code smells**, which are
    signs of poorly designed code, duplicate code, and large or long classes and methods.
    Performance bottlenecks and complex logic are additional indicators that code
    should be refactored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following techniques can be used for refactoring your code:'
  prefs: []
  type: TYPE_NORMAL
- en: Break down large classes and methods into smaller, more manageable components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rename classes, methods, and variables so they are meaningful and self-describing.
    This added code clarity improves overall readability and maintainability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove unused code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplify complex conditional logic into clearer, more readable constructs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When refactoring our code, we should strive to refactor in small, incremental
    steps. This will minimize the risks of introducing new bugs. We should always
    write **unit tests** (see [*Chapter 17*](B21942_17.xhtml#_idTextAnchor331), *Unit
    and Performance Testing*) before and after refactoring. This helps us ensure that
    the functionality remains unchanged. Lastly, we should use a version control system
    to track our changes and support code **rollback** if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we inherit systems and must maintain legacy code. That is covered
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Legacy code refers to older code bases. They are typically difficult to maintain
    due to outdated practices, lack of documentation, or deprecated technologies (that
    is, systems coded with the **Common Business Oriented** **Language** (**COBOL**)).
  prefs: []
  type: TYPE_NORMAL
- en: When inheriting a legacy code base, we should first conduct a thorough code
    review to identify problematic areas, outdated dependencies, and security vulnerabilities.
    Armed with knowledge from the code review, we can prioritize critical sections
    of the code that require immediate attention or pose significant risks or security
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'When feasible, we should adopt a modernization strategy for the legacy code.
    This could include the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing incremental updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using code wrappers for new features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating testing for changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting legacy code and changes to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a backup schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a version control system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolating legacy components from the rest of the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Training your developers on the legacy code and your maintenance plan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing these maintenance strategies can help you ensure the ongoing stability
    and performance of your Java applications. The strategies are aimed at making
    the code easier to update, maintain, and scale over time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored the essential practices and tools for effective code monitoring
    and maintenance, focusing on ensuring long-term performance, reliability, security,
    and scalability. We began with an overview of APM tools, detailing their key features
    such as real-time monitoring, transaction tracing, error tracking, and user experience
    monitoring. Popular APM tools for Java were reviewed, along with best practices
    for their implementation and use.
  prefs: []
  type: TYPE_NORMAL
- en: We emphasized the importance of code reviews for the goal of maintaining high-quality
    code. We covered best practices, detailed the peer review process, and shared
    common pitfalls, offering avoidance solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of logging was examined, starting with the fundamentals, including
    log levels, messages, and targets. We outlined best practices for effective logging,
    such as using appropriate levels, avoiding sensitive information, and centralizing
    logs. We also introduced popular logging frameworks for Java and discussed techniques
    for analyzing and managing log data.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and alerting were highlighted. We covered how to set up a comprehensive
    monitoring system, as well as alert configuration and incident response strategies.
    We concluded the chapter by covering maintenance strategies. We compared scheduled
    and reactive maintenance approaches, stressing the importance of proactive planning.
    We emphasized the role of documentation and knowledge management in maintaining
    healthy code bases. Finally, we explored effective refactoring strategies and
    provided guidance on how to deal with legacy code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce strategies for creating and using unit
    and performance tests to help create and maintain high-performance Java applications.
    Specifically, we will look at unit testing, performance testing, and overarching
    strategies.
  prefs: []
  type: TYPE_NORMAL
