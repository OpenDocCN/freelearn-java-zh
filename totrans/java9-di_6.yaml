- en: Aspect-Oriented Programming and Interceptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have learned about the concept of dependency injection and its implementation
    in popular frameworks, such as Spring and Google Guice. We also learned how to
    control the object creation process by scoping beans based on business requirements. In
    this chapter, we will learn another way of implementing separation of concerns:
    **aspect-oriented programming** (**AOP**).'
  prefs: []
  type: TYPE_NORMAL
- en: AOP solves a different portion of the design problem by isolating repeated code
    from the application and plugging it in dynamically. AOP, along with **Inversion
    of Control** (**IoC**), brings modularity to the application. AOP helps in organizing
    your application in layer fashion, which would be impossible in the traditional
    object-oriented approach.
  prefs: []
  type: TYPE_NORMAL
- en: AOP permits you to intercept the flow of business code and straightforwardly
    inject a set of functionalities, without touching or altering the original code.
    This makes your application loosely coupled from those common functionalities.
    Before we dive into this concept, let's first understand the scenario, what the
    problem is, and how we can use AOP as an effective solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discover and discuss the following interesting topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What AOP is, and what problems you can solve with AOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to achieve AOP in Spring Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing AOP frameworks and a style of configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AOP introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While writing any software application, the best practice is to divide your
    code into multiple independent modules based on business use cases. For example,
    you write an **Employee Service** class for all employee-related functions, an
    **HRService** class for all HR-related functions, and so on and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the whole application consists of a set of independent classes that
    span multiple verticals and doesn’t share the same class hierarchy. This diagram
    depicts this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Irrespective of the independent nature of each vertical, there are a few common
    items you need to implement across all of them, such as **transaction management**,
    **session management**, **audit logging**, **security**, **caching**, or any such
    custom processing mechanism based on rules.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to implement these common services across verticals with a traditional
    approach, you need to put them into each of the methods in these classes manually.
    Taking an example of a logging mechanism, for this, you would need to write a
    little bit of code at the beginning and end of every method.
  prefs: []
  type: TYPE_NORMAL
- en: This leads to code duplication, as the same logic needs to be placed several
    times. This leads to a maintenance nightmare in the later part of the application
    development process when any changes are introduced. Let's understand how.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose, as per your business requirements, you add audit logs after each update
    and delete method. You put the method name and its time in the log. Now, let's
    say your business needs to place the name of currently logged-in users in the
    log. In this case, you need to update the logging details manually in several
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: This is just one example. You will end up changing the code for each of the
    common services, spread across multiple verticals. The effective solution is to
    keep them isolated from verticals. Implement them in one place and plug them into
    other core business classes as and when required based on certain rules or criteria.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, the core part of the business logic does not have to know that something
    that is common across multiple classes has been included, removed, or changed,
    and can keep working as before. Separating common functionalities (cross-cutting
    concerns in the AOP paradigm) and turning them on and off without touching or
    modifying the core business logic, will eventually increase modularity and bring
    great flexibility in terms of maintenance in any application. AOP aims to provide
    a way to achieve this solution. AOP is mainly used to provide declarative services.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand AOP concepts, it''s crucial to understand the terminology used
    in the AOP paradigm:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Concern:** This is a behavior or functionality we want to achieve in our
    application. For example, HR management and employee management are two functionalities,
    and are thus considered as concerns in AOP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aspect:** In very simple terms, this is a common behavior that spans multiple
    classes in the same or different hierarchy. In other words, the common concept
    that cuts across multiple concerns is called the aspect. In our example, the logging
    mechanism is called the aspect in AOP terminology.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Join-point:** This is a point during the execution flow of the application
    where you need to apply **Advice**. For example, a method invocation or a place
    where you need to handle an exception could be join-point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advice:** This is an action performed on a specific join-point by the AOP
    framework. Conceptually, it''s a common functionality implementation at that join-point.
    The process of applying **Advice** can be controlled by specifying various types,
    such as `around`, `before`, `after`, `throws`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Point-cut:** This is an expression that describes a pattern of applicable
    join-points. In other words, the AOP framework will apply the **Advice** (common
    functionality) on join-points (methods) that are described by a point-cut (for
    example, `set*` means all methods start with the word *set*). We can say a point-cut
    is a filter criterion to choose join-points in the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most cases, developers get confused between join-point and point-cut. Let's
    take a real-life example to understand the difference. Suppose you want to buy
    cooking oil and you go to the department store. You reach the grocery section
    and find various edible oils made from difference sources, such as sunflower,
    groundnut, cotton seed, rice brand, corn, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Your requirement is to choose light oil (in terms of low cholesterol) for your
    daily needs, and hence you choose either sunflower oil or rice brand oil. In this
    case, all the available edible oils are the join-points, and your choice of sunflower/rice
    brand oil, based on your needs, is considered a point-cut. In short, all available
    options are considered as join-points, while the one you choose, based on your
    needs, is called a point-cut.
  prefs: []
  type: TYPE_NORMAL
- en: '**Target object:** That is the object in which the common functionalities are
    being implemented. In other words, this is the object on which the **Advice**
    is applied by a set of aspects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AOP-Proxy:** Proxy is a design pattern used to encapsulate the object and
    control access to it. The AOP framework creates a proxy/dynamic object to implement
    various aspects (in the form of **Advice**). In short, AOP creates a proxy object
    that looks like the object on which the proxy was created, but with a few additional
    features. In **Spring Framework**, AOP-proxy is supplied through the JDK or the
    CGLIB library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Weaving: **As we have seen, the main idea behind AOP is to plug common behaviors
    (or aspects) into business classes without modifying them. The process of linking
    such aspects with other classes to apply **Advice** is called weaving.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weaving can be done at compile or run time. **Spring AOP** supports load-time
    weaving, while the **AspectJ** framework supports both compile-time and load-time
    weaving.
  prefs: []
  type: TYPE_NORMAL
- en: '**Compile-time weaving**:In this type of weaving, the process of linking aspects
    is performed at compile time. The AOP framework will apply the aspects to your
    Java source file and create a binary class file, which is woven with those aspects.
    AspectJ uses a special compiler to achieve compile-time weaving.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post-compile-time (or binary) weaving**:This is similar to compile-time weaving.
    The process of linking aspects is performed on precompiled classes, or JAR files.
    The aspects that are woven may be in either source or binary form. This, again,
    can be done through a special compiler. Both compile-time and post-compile-time
    weaving can be achieved through AspectJ.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime weaving**:Compile-time and post-compile-time weaving happens before
    the actual class file is loaded into memory, whereas runtime (or load-time) weaving
    happens once the target class is loaded into JVM by the class loader. Runtime
    weavers are supported by both the Spring AOP and AspectJ frameworks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The process of weaving can be expressed through the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00044.gif)'
  prefs: []
  type: TYPE_IMG
- en: Spring AOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Spring AOP** is purely developed in Java. It doesn''t require us to alter
    or control the class loader hierarchy. Because of this adaptability, you can utilize
    Spring AOP for a servlet container or application server. At present, Spring AOP
    only supports applying Advice at method level. In other words, method-level join-points
    are supported in Spring AOP'
  prefs: []
  type: TYPE_NORMAL
- en: Spring supports AOP in conjunction with its IoC capabilities. You can define
    aspects with normal bean definition, while weaving them with AOP specific configuration.
    In other words, IoC is used to define aspects, and AOP is used to weave them to
    other objects. Spring uses both of them to solve common problems. This is how
    Spring AOP differs from other AOP frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Spring AOP is a proxy-based framework, and supports runtime weaving of objects.
    It can be used through either XML-based or AspectJ annotation-based configuration.
  prefs: []
  type: TYPE_NORMAL
- en: XML(schema)-based Spring AOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like a class is the unit of the object-oriented programming paradigm,
    aspect is the unit of AOP. Modularity is achieved through aspect in an aspect-oriented
    programming model. If you wish to choose XML-based configuration for AOP, Spring
    supports defining aspects using `aop` namespace tags. You need to define `aop`
    namespace tags as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To differentiate AOP-specific configuration, you need to specify all AOP-related
    artifacts such as aspects, point-cut, Advice, and so on, within an `<aop:config>`
    element inside your Spring context (XML) file. Multiple `<aop:config>` elements
    are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring aspect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing in Spring AOP is to decide on and define the aspects. In XML-based
    configuration, an aspect is conceptualized as a simple Java class that you need
    to declare as a bean definition in a Spring application context (XML) file. The `<aop:aspect>`
    element is used to define an aspect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since an aspect is a form of Java class, it can be defined as a normal Spring
    bean, and then can be configured with the `ref` attribute of the `<aop:aspect>`
    element. The state and behavior is associated with fields and methods of the aspect
    class, while the point-cut and advice information is configured in the XML. In
    the previous example, we define logging as an aspect.
  prefs: []
  type: TYPE_NORMAL
- en: After defining an aspect, the next step is to define the join-point through
    the point-cut. Spring AOP supports method-level join-points only.
  prefs: []
  type: TYPE_NORMAL
- en: In XML schema based-AOP, Spring enables an auto-proxy mechanism with the `<aop:config>`
    declaration. You do not need to define anything for auto-proxy explicitly; however,
    if you are enabling auto-proxy with some other mechanism (such as AutoProxyCreator),
    you should choose either of these options to avoid any runtime issues.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a point-cut
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just to recall, a join-point is a place where we want to apply **Advice**, and
    a point-cut represents a pattern of matching join-points. A point-cut must be
    defined within the `<aop:config>` element. A point-cut can be declared within
    the `<aop:aspect>` element or outside of it. If it's defined outside of `<aop:aspect>`,
    it can be shared between multiple aspects and advisors.
  prefs: []
  type: TYPE_NORMAL
- en: 'A point-cut allows Advice to be applied to the target object independently
    of the object-oriented hierarchy. Transaction management through AOP Advice in
    Spring is a real example of where transaction Advice is applied to specific methods
    (`add`/`update`/`delete` methods) that span multiple object hierarchies. This
    snippet is one of the possible ways of writing a point-cut:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A point-cut is uniquely identified by its `id` attribute. The `expression`
    attribute represents the pattern (or filter) of matching join-points. The value
    of the `expression` attribute consists of two components:'
  prefs: []
  type: TYPE_NORMAL
- en: Point-cut designator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Point-cut designator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **point-cut designator** (**PCD**) is a keyword (initial word) that tells
    Spring AOP how to match the point-cut. Spring AOP supports various point-cut designators:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`execution`:** This is used to match method execution (join-points). This
    is a primary designator, and is used most of the time while working with Spring
    AOP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`within`:** This designator has the limitation of matching of join-points
    within certain types only. It''s not as flexible as execution. For example, it''s
    not allowed to specify return types or method parameter mapping. If the patterns
    with `within` are up to the Java package, it matches all methods of all classes
    within that package. If the pattern is pointing to a specific class, then this
    designator will cover all the methods within that class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`this`: **This restricts the matching of join-points to the beans that are
    references of a given type in an expression. In other words, the `this` designator
    is one step narrower than the `within` designator, and expects you to specify
    a specific class type as a pattern. It will not be allowed to define any wildcard
    patterns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`target`:** This limits the matching of join-points, where the target object
    is an instance of the given type in an expression. The target designator seems
    similar to the `this` designator, but there is a difference in their use. Let''s
    understand this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we have seen, Spring AOP creates proxy objects through either the **JDK**
    or the **CGLIB** library. Spring AOP uses a JDK-based proxy if the target object
    implements an interface; otherwise, it selects CGLIB. You should use the `this`
    designator when CGLIB provides the proxy (that is, your target object doesn't
    implement an interface), and the target designator when the JDK provides the proxy
    (the `target` object implements an interface).
  prefs: []
  type: TYPE_NORMAL
- en: '**`args`:** This designator is generally used for matching method arguments.
    It allows us to pass wildcards for matching packages, Java classes, return types,
    or method names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`@target`:** This PCD filters the join-points where the class of the object
    has an annotation of a given type. Although the names are equal, the `@target` designator
    is not similar to the `target` designator. They are different in terms of matching
    the join-points as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `target` designator: Matches the target object if it is an instance of
    the given type in an expression'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `@target` designator: Matches the target object, if the class of target
    object has an annotation of given type'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`@within`:** This designator restricts matching join-points to within the
    type that has a given annotation. It allows us to use wildcards to match point-cuts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`@annotation`:** This PCD is used to match a point-cut of a type that has
    a given annotation. It''s useful to construct point-cuts on classes that have
    custom annotation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`@args`:** This designator restricts matching a join-point to where actual
    runtime objects passed as method arguments have an annotation of a given type.
    This is useful to narrow down the join-point selection to specific methods from
    the available overloaded methods in the target class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pattern is a filter criteria to match possible join-points. It tells Spring
    AOP what to match. **Patterns** are generally written within brackets, just after
    the PCD. It's a kind of regular expression in AOP to select the desired join-point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring AOP supports only method-level join-points, and patterns are used to
    choose specific methods of the target object. A pattern consists of the following
    expressions in the same order:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access modifier**: For Spring AOP, the only possible value is `public`. This
    expression is optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Return type**: This is the fully qualified name of the return type. Putting
    `*` for this expression means it allows any return type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java package**: Java package name can be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java class name**: Java class name can be used. Putting `*` for this expression
    means it applies to all Java classes under a given package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method name**: Method name can be given. Putting `*` in this expression will
    include all methods of a given class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method parameters**: Type of parameter can be given. Putting `..` (two dots)
    means any number of parameters for a given method will be considered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exception details**: Throws a declaration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The format of a pattern is exactly similar to method signature. Let's understand
    the meaning of the previous expressions by seeing a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 1** :The following expression will match all public methods of the `EmployeeService`
    class with the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Method with any return value, including void
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method with any parameters, including empty parameter method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Example 2**:The following expression will match all public methods with the
    following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Method with any return value, including void
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method with any parameters, including empty parameter method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method of all classes that fall directly under the `com.packet.spring.aop.service` Java
    package:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Example 3**: The following expression will match all public methods with
    the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Method with any return value, including void
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method with any parameters, including empty parameter method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method of all classes fall under the `com.packet.spring.aop.service` Java package and
    its subpackage:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Example 4**:The following expression will match all public methods of the `EmployeeService`
    class with the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Method with a return type of String only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method with any parameters, including an empty parameter method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Example 5**:The following expression will match all public methods of the `EmployeeService` class
    with the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Method with any return value, including void
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method with two parameters, first a `String` and second a `Long`, in the same
    order of method parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Example 6**:The following expression will match all public methods of the `EmployeeService` class
    with the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Method with any return value, including void
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method with one or more parameters, where the first parameter is `String` only:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Example 7**:The following expression will match specific public methods with
    the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Method name starts with the `find` word
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method with any return value, including void
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method with just one parameter of type `String`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods of all classes fall under the `com.packet.spring.aop.service` Java
    package:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Declaring Advice (interceptor)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to define **Advice**. This is an action performed on a join-point.
    Advice is also referred as an *interceptor*. Spring AOP supports various types
    of Advice, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Before Advice:** This type of Advice is executed just before the execution
    starts at the join-point. In the case of an exception, Spring will stop further
    execution of this Advice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**After Advice: **As its name suggests, this type of Advice is executed after
    completion of join-point execution (either a normal exit, or in the case of an
    exception, from the join-point).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Around Advice: **This type of Advice is executed around the join-point (before
    and/or after the advised method). Because of this, you have the control to execute
    the join-point and return the original method value, or bypass the flow and return
    a custom value. In general, around Advice is used to execute some logic before
    and/or after a method''s main logic. Due to this, it''s the most powerful type
    of Advice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**After returning Advice: **This is similar to after Advice. The difference
    is that it''s being executed on a normal exit from a join-point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**After throwing Advice: **This is also similar to after Advice, but is executed
    when an exception occurred during execution of the Advice''s method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In XML-based Spring AOP, you need to be careful of the order of AOP elements
    while defining them within `<aop:config>`. For example, `<aop:pointcut>` must
    be defined before or within the `<aop:aspect>` element or else Spring will show
    an error. Similarly, AOP Advice must be defined within the `<aop:aspect>` element.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing before advice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far we have seen how to declare aspects, point-cuts, and Advice. Let''s
    put them together and understand how they work together. Suppose we want to put
    a logger at the beginning of all methods of classes that fall under the `com.packet.spring.aop.service`
    package. The configuration would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have defined a point-cut that matches all public methods of all classes under
    the `com.packet.spring.aop.service` package, with any parameter and any return
    value. Next, we have defined the logging aspect bean, and given its reference
    to `<aop:aspect>` with the `ref` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the aspect, we have defined before advice (`<aop:before>`) and gave
    point-cut reference there. The  `printStartLog` method is defined in the aspect
    bean as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It's not required to pass the `JoinPoint` parameter in the `printStartLog` method.
    It will work even if you don't pass the `JoinPoint` parameter. But, it gives you
    metadata about the target object. In this sense, it's useful. For example, in
    the previous case, we display the woven method's name and its class name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The target class `EmployeeService` is defined in the `com.packet.spring.aop.service`
    package as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we get the `EmployeeService` object from Spring''s application context
    file and call these methods, AOP will intercept all these methods and insert the
    log (which we kept in the `printStartLog` of `LoggingAspect`), before execution
    of each of the methods (because we have used before advice):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And you will get output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can observe how Spring AOP traps each method of the `EmployeeService` class
    and adds the log at the beginning of each method. It prints the `method` name
    and `class` name dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing after advice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like before advice, we can also implement other advice types. Let''s take
    an example of after advice and around advice. For after advice, just add one method
    in the `LoggingAspect` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In after advice, we are just printing the `method` name. We also need to update
    the aspect configuration in the application context file. Just add an after advice
    entry for our logging aspect, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This time, you can observe how AOP intercepts each method and implements after
    advice along with before advice.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing around advice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring AOP also provides around advice, which is a combination of before and
    after in one go. If you need to process something before and after, you can simply
    implement around advice instead of before and after advice separately. To implement
    around advice, just add one more method in our `LoggingAspect` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For *around* advice, Spring AOP supplies the `ProceedingJoinPoint` object instead
    of `JoinPoint` object.  `proceedingJoinPoint.proceed()` will simply call the method
    on the `target` object, and you can put the before logic just above the `proceedingJoinPoint.proceed()`
    call and after the logic just next to it.
  prefs: []
  type: TYPE_NORMAL
- en: '`ProceedingJoinPoint` can be used for around advice only. If you try to use
    it for before or after advice, you will get an error. For them, you should use
    join-point only.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to update the configuration to plug around advice for the
    aspect as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is how around advice is implemented and does the work of *before* and *after* advice
    altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Don't use *before*, *after*, and *around* advice all together. If you need to
    put some additional code at the beginning of the method, use *before* advice only,
    instead of *around*. Although using *around* advice can achieve what you implemented
    with *before* advice alone, it's not a good idea. Use *around* advice only when
    you want to add something before and after methods.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing after returning advice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **after returning** advice works just like after advice. The only difference
    is that this advice will be executed on matching methods only on normal exit.
    If an exception occurs, this advice will not be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at a scenario to understand the need for this advice. Suppose
    you want to send a message (email) to a concerned person when a particular method
    is executed successfully on the `target` class. Since this is a new concern (sending
    a message on successful execution of the `target` method), we have created a new aspect
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SendMessage` aspect has one method called `sendMessageOnSuccessExit`.
    We want this method to be called on a normal method exit (without an exception)
    from the `target` class. You can write the logic to send the message (email) in
    this method. The new aspect will be configured in the application context (XML)
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created a new point-cut that will match all the methods of the `HRService`
    class. This class will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When you get an object of `HRService` from Spring and call the `showHolidayList` method,
    you will get output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `target` method returns a value and you want to modify it with AOP,
    you can do this  with after returning advice. For this, you need to specify the
    parameter name in the `<aop:aspect>` element as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the value of the `returning` attribute says that the `sendMessageOnSuccessExit`
    method must declare a parameter called `retVal`.  Spring AOP will pass the return
    value from the method of the `target` object to this parameter (`retVal`) while
    applying this advice. Therefore, the type of the return value from the method
    of the `target` object must be compatible with the type of the parameter (`retVal`,
    in our case) in the advice method. Let''s update the `showHoliday` method of the
    `SendMessage` advice as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The return value type of this method is `String`. To update the return value,
    you need to change the advice method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When you get the `HRService` object from Spring and call its `showHolidayList()`
    method, you will get the following updated return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Implementing AfterThrowing advice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The AfterThrowing advice* will be executed when the matched methods of the
    target object exit with an exception. This is also useful when you want to take
    an action on an exception that occurred during execution of the method. Let''s
    create AfterThrowing advice as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sendMessageOnErrorExit` advice method will be defined in the `sendMessage`
    aspect as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure this advice is applied, the method in the `target` class must
    exist with an exception. So, let''s add one method that throws an exception in
    the `target` class (HRService) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When you take the `HRService` object from Spring and call the `showMyLeave`
    method, you will get output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '@AspectJ annotation-based Spring AOP'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring allows another way to support AOP through the @AspectJ annotation. It's
    an alternative to XML-based configuration to define the aspect using regular Java
    classes with AOP-specific annotation. Spring introduced the @AspectJ style as
    a part of the AspectJ 5 release. Though with @AspectJ, Spring facilitates same
    annotation like AspectJ 5, the underlying framework is pure Spring AOP. Due to
    this arrangement, there is no dependency on AspectJ compiler or weaver.
  prefs: []
  type: TYPE_NORMAL
- en: To use @AspectJ annotation for Spring AOP, you need to enable its support in
    Spring through configuration and turn auto-proxy on. **Autoproxying** is a mechanism
    to create a proxy on the object of a Spring bean on which one or more aspects
    are woven. This allows Spring AOP to intercept the methods and apply advice on
    the matching point-cut.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen in [Chapter 3](part0066.html#1UU540-255b24dd0eb24162a557b7d0d84b0b16),
    *Dependency Injection with Spring*, Spring supports configuration of annotation
    either in the application context (XML) file, or in the Java configuration. Similarly,
    @AspectJ configuration can be done with either of these options. With Java-based
    configuration, you can enable Spring AOP annotation with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can choose the application context (XML) file to enable `@Aspect`
    annotation. This can be achieved with the `<aop:aspectj-autoproxy/>` element.
  prefs: []
  type: TYPE_NORMAL
- en: Spring AOP creates a proxy object to embed customer code; however, when you
    define any class as an aspect with the @Aspect annotation (or XML configuration),
    Spring will not create the proxy of that class. In short, the aspect class can't
    be the target of advice from another aspect. Spring will omit all such aspect
    classes from auto-proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring aspect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of declaring Aspect with the @AspectJ annotation style is somewhat
    similar to XML schema-based AOP declaration. Just to recall, a Java class can
    be an Aspect in the Spring AOP framework. In annotation-based Spring AOP, you
    can declare any bean as an Aspect with the `@Aspect` annotation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SessionCheck` class is defined as a regular Spring bean in the application
    context (XML) file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Aspect classes may have methods and fields like any other Java class. Spring
    doesn't impose any limits on defining aspects only with the bean defined in the
    application context (XML) file. If you have used bean autodetection through Java
    package scanning (with the `<context:component-scan>` element), Spring intelligently
    detects the `Aspect` class with the `@Aspect` annotation. Aspect classes may contain
    point-cuts and advice declaration.
  prefs: []
  type: TYPE_NORMAL
- en: The @Aspect annotation itself is not sufficient for Spring to autodetect the
    class. You still need to use @Component, or any other stereotype annotation. @Aspect
    will consider the class (which is autodetected by @Component or an equivalent
    annotation) as an aspect for Spring AOP.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring point-cut
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Point-cuts are regular expressions or patterns to filter join-points where
    we want to apply advice. Since Spring AOP only supports method-level join-points,
    you can consider a point-cut as a matching of method execution on Spring beans.
    In the `@AspectJ` annotation style, a point-cut is declared by a method of an
    Aspect class (declared with the `@Aspect` annotation). Such methods are called
    **point-cut signatures**. The `@Pointcut` annotation is used to define such a
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the `validateSession` method represents a point-cut signature,
    while the `@Pointcut` annotation is used to describe a point-cut expression. The
    preceding point-cut is applied to all public methods of all classes under the
    `com.packt.spring.aop.service` package that have any parameters and return values.
    A method that represents a point-cut signature must have `void` as a return type. The
    preceding annotation-based AOP is equivalent to XML-based AOP configuration, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like XML-based AOP, you can use various point-cut types (point-cut designators)
    such as `within`, `this`, `target`, `args`, `@annotation`, `@target`, `@within`, and `@args` with
    annotation-style AOP. On top of these, Spring supports an additional point-cut
    type (PCD) called **bean**, which matches the method execution on a particular
    bean or set of beans. It can be declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This point-cut is applied to the bean with an ID or name of `batchOperation` defined
    in the application context (XML) file. If a wildcard (only `*` is allowed) is
    used, this point-cut can be applied on multiple beans.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like XML-based configuration, annotation-based AOP also supports combining
    point-cut with `and`, `or`, and `negated` operations. In `@AspectJ`-style AOP,
    you can refer point-cut with its name (signature) while combining with other point-cut,
    or referring them in Aspect declaration in XML schema. Multiple point-cuts can
    be combined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first point-cut, `checkSession`, will be applied on all public methods of
    any class under the` com.packt.spring.aop.report` package. The second point-cut, `printUserName`,
    will be applied on any public method with a single argument of type `String`,
    while the third point-cut, `userSession`, is applicable on all public methods
    that have a single argument of type `String` of any classes under the `com.packt.spring.aop.report` package.
    We have used the name (point-cut signature) of the first and second point-cuts
    to combine them in the third point-cut definition.
  prefs: []
  type: TYPE_NORMAL
- en: It's common practice to create smaller point-cuts with simple expressions, and
    build complex point-cuts by combining them with `and` , `or`, and `negated` operations. By
    referring to its name, point-cuts are so simple to define, and yet powerful when
    combining with other point-cuts.
  prefs: []
  type: TYPE_NORMAL
- en: Since point-cuts are referred by `method` name, the visibility of the Java method
    is applied to point-cuts. For example, **private** point-cuts are used in the
    same type, **protected** point-cuts in the same package, and **public** point-cuts
    can be applied anywhere (that is, can be referred to in other aspect classes in
    different hierarchies). This brings great flexibility when building an enterprise
    application with multiple modules, and when you want to share a set of operations
    between various aspects. You can make public point-cuts in common aspects that
    can be shared with other aspects in different modules.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Advice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declaring Advice with `@AspectJ`-style annotation is similar to XML-based AOP
    configuration. The XML configuration will be replaced by an annotation declaration
    in the aspect class. Just to recall, Advice is an action to be performed on a
    point-cut configured with it. Advice can be declared in the Aspect class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@Before` annotation is used to declare before advice with the `displayUserName`
    method. The point-cut expression defined within the `@Before` annotation is called
    *in-lined*, because it''s declared in the same place. You can also put a reference
    of the point-cut (declared separately with the `@Pointcut` annotation) within
    the `@Before` annotation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how a point-cut with the `method` signature `checkSession()` is being
    referred to in the `@Before` advice. The previous configuration is equivalent
    to the following XML-based configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have seen, the access modifier of the point-cut signature will decide
    its visibility. You can refer any public point-cut to the advice on a different
    `Aspect` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is how you can refer to a public point-cut defined in some other aspect
    class. You need to use a fully-qualified class and put the `method` name with
    a dot in between. We have seen an example of before and after advice types. You
    can define other advice types, such as around advice, after returning advice and
    after throwing advice, similar to the schema-based AOP we have seen in previous
    topics.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring an advisor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring provides another mechanism to define advice and aspect as a single unit.
    It''s called an **advisor**. It''s only available in Spring AOP and not in native
    AspectJ. In this model, you need to define advice as a class that implements one
    of the advice interfaces. An advisor can be defined with the `<aop:advisor>` element
    in the application context (XML) file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to define an advisor with the `<aop:advisor>` element within `<aop:config>`.
    You can define a point-cut advisor with the `point-cut-ref` attribute. In the
    previous example, we have defined an in-lined point-cut. If you are following
    annotation-based AOP, you can refer to any public point-cut defined in the aspect
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are referring to the point-cut with its signature (`checkReportPermission()`)
    defined in the `PermissionCheck` aspect class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also defined a bean with the  `LoggingAdvisor` class, which is an `advisor`
    class, and referred in the `<aop:advisor>` element with the `advice-ref` attribute.
    The `LogginAdvisor` class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This `advisor` class is implementing the `before` method of the `MethodBeforeAdvise`
    interface. It's equivalent to implementing before advice. Spring AOP provides
    other sets of advice interfaces, such as `MethodInterceptor`, `ThrowsAdvice`,
    and `AfterReturningAdvice`, which are equivalent to implementing around advice,
    after throwing advice, and after returning advice respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing AOP frameworks and style of configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you conclude that you will go ahead with the Aspect programming model
    to achieve or implement your requirements, this question comes into the picture:
    should you choose Spring AOP or the full-fledged AspectJ framework ?'
  prefs: []
  type: TYPE_NORMAL
- en: After choosing the framework, the question of selecting the style of configuration
    would come up next. For example, in the case of the AspectJ framework, will you
    choose AspectJ code style or `@AspectJ` annotation style? Similarly, in the case
    of Spring AOP, will you select a Spring XML file or an `@AspectJ`-based annotation
    style to define various artifacts such as aspects, point-cuts, advice, and advisors?
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right framework with the specific style for defining the configuration
    depends on many factors, such as project requirements, availability of development
    tools, team expertise, compatibility of your existing system code with the AOP
    framework, how quickly you want to implement AOP, and performance overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Spring AOP versus AspectJ language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we mainly looked at Spring AOP. AspectJ is another solution
    to implement AOP; however, Spring AOP is simpler than AspectJ because it doesn't
    require you to introduce an AspectJ compiler or weaver into your development and
    build process.
  prefs: []
  type: TYPE_NORMAL
- en: Spring AOP has been introduced to provide a simple AOP implementation throughout the
    IoC container to solve generic problems, while AspectJ is a full featured AOP
    framework. AspectJ is powerful in nature, but more complex than Spring AOP. AspectJ
    supports compile-time, post-compile-time, and runtime weaving, while Spring AOP
    only supports runtime weaving through a proxy.
  prefs: []
  type: TYPE_NORMAL
- en: If your business needs advice on the set of operations of the Spring bean project,
    Spring AOP is the right choice for you. If you come across a requirement where
    you need to intercept and implement advice on objects not managed by the Spring
    container, you should go with the AspectJ programming framework.
  prefs: []
  type: TYPE_NORMAL
- en: Spring AOP supports method-level join-points only. If you need any advice on
    join-points other than methods (such as field, setter, or getter methods), you
    should consider AspectJ. Another point you should consider while choosing from
    these frameworks is performance. Spring AOP uses a proxy, so there should be little
    runtime overhead. Compared to Spring AOP, there is less overhead while working
    with AspectJ.
  prefs: []
  type: TYPE_NORMAL
- en: XML versus @AspectJ-style annotation for Spring AOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When there is more than one option to choose from, it''s always a dilemma,
    and that is the case here. Which option should you choose while using Spring AOP:
    XML-based or annotation-based? Each of these styles has benefits and limitations.
    You should consider them both before choosing the right one for your needs.'
  prefs: []
  type: TYPE_NORMAL
- en: The XML style is very well-known and has been widely used since the evolution
    of the Spring Framework. Almost all Spring developers are handy with it. Choosing
    the XML style means all your configurations are in one central place. This will
    help to identify how many artifacts (aspects, point-cuts, and sets of advice)
    are defined in the system in a cleaner way. This will be a benefit in the alteration
    of the configuration (for example, changing the expression of a point-cut) independently.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, with the XML style, a piece of information is split across
    different places. The configuration is done in XML, while the actual implementation
    is defined in the respective bean classes. While using @AspectJ-style annotation,
    there will be just a single module, Aspect, which declares that all the artifacts,
    such as point-cuts, advice, and so on, are well encapsulated.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other limitations to XML-based AOP, for example, a bean declared
    as an Aspect would be a singleton only. Also, you can''t refer to the point-cut
    by its signature (name) while combining with other point-cuts. To take an example,
    a point-cut declaration with an annotation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The point-cut signatures (names) of `checkSession` and `printUserName` are used
    to combine them and form a new expression, `userSession`. The downside of XML-based
    configuration is that you can't combine point-cut expressions like this.
  prefs: []
  type: TYPE_NORMAL
- en: On top of these facts, Spring AOP allows you to mix XML schema-based configuration
    with @AspectJ-style annotation declaration. For example, you can define a point-cut
    and an aspect with annotation, and declare the set of advice (interceptors) in
    XML-based configuration. They all can coexist without any issues.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned one of the important ways to achieve separation
    of concerns called AOP. Conceptually, we are removing the dependency of cross-cutting
    concerns from business code and applying them with plug-and -play fashion and
    in a more controlled way with AOP. It solves the design problem that we never
    could resolve with the traditional AOP model.
  prefs: []
  type: TYPE_NORMAL
- en: We understood the need of AOP by taking an example where we need to keep changing
    business code when common functionality is changed. We have also seen various
    terminologies used in AOP, which is very crucial to understanding underlying concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Soon after learning the theory of AOP, we started our journey with Spring AOP
    to understand the practical concepts. First, we learned to define AOP configuration
    in an XML file, followed by declaring various artifacts such as aspect, point-cut,
    and advice. Details about point-cut expressions and advice types were shown with
    various examples and code samples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we learned how to define Spring AOP configuration with the `@AspectJ`
    annotation style, followed by declaring aspects, advice, and point-cuts with annotation.
    We also learned how to define an advisor by implementing various interfaces. Lastly,
    we saw the benefits and limitations of Spring AOP and the AspectJ framework, followed
    by how to choose the configuration style for Spring AOP: XML or annotation.'
  prefs: []
  type: TYPE_NORMAL
- en: We will move on to learn various design patterns that you can use to achieve
    IoC, and what the best practices, patterns, and anti-patterns are while working
    with dependency injection in the next chapter.
  prefs: []
  type: TYPE_NORMAL
