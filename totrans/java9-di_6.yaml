- en: Aspect-Oriented Programming and Interceptors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向切面编程和拦截器
- en: 'So far, we have learned about the concept of dependency injection and its implementation
    in popular frameworks, such as Spring and Google Guice. We also learned how to
    control the object creation process by scoping beans based on business requirements. In
    this chapter, we will learn another way of implementing separation of concerns:
    **aspect-oriented programming** (**AOP**).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了依赖注入的概念及其在Spring和Google Guice等流行框架中的实现。我们还学习了如何根据业务需求对bean进行范围划分，以控制对象创建过程。在本章中，我们将学习实现关注点分离的另一种方法：**面向切面编程**（**AOP**）。
- en: AOP solves a different portion of the design problem by isolating repeated code
    from the application and plugging it in dynamically. AOP, along with **Inversion
    of Control** (**IoC**), brings modularity to the application. AOP helps in organizing
    your application in layer fashion, which would be impossible in the traditional
    object-oriented approach.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: AOP通过将重复代码从应用程序中隔离出来并动态插入，解决了设计问题的一部分。AOP与**控制反转**（**IoC**）一起，为应用程序带来了模块化。AOP有助于以分层方式组织您的应用程序，这在传统的面向对象方法中是不可能的。
- en: AOP permits you to intercept the flow of business code and straightforwardly
    inject a set of functionalities, without touching or altering the original code.
    This makes your application loosely coupled from those common functionalities.
    Before we dive into this concept, let's first understand the scenario, what the
    problem is, and how we can use AOP as an effective solution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: AOP允许您拦截业务代码的流程，并直接注入一系列功能，而无需触及或更改原始代码。这使得您的应用程序与这些常见功能松散耦合。在我们深入探讨这个概念之前，让我们首先了解场景、问题以及如何使用AOP作为有效的解决方案。
- en: 'In this chapter, we will discover and discuss the following interesting topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将发现和讨论以下有趣的主题：
- en: What AOP is, and what problems you can solve with AOP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AOP是什么，以及您可以使用AOP解决哪些问题
- en: How to achieve AOP in Spring Framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Spring框架中实现AOP
- en: Choosing AOP frameworks and a style of configuration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择AOP框架和配置风格
- en: AOP introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AOP简介
- en: While writing any software application, the best practice is to divide your
    code into multiple independent modules based on business use cases. For example,
    you write an **Employee Service** class for all employee-related functions, an
    **HRService** class for all HR-related functions, and so on and so forth.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何软件应用程序时，最佳实践是根据业务用例将代码划分为多个独立的模块。例如，您为所有与员工相关的功能编写一个**Employee Service**类，为所有与人力资源相关的功能编写一个**HRService**类，等等。
- en: 'In general, the whole application consists of a set of independent classes that
    span multiple verticals and doesn’t share the same class hierarchy. This diagram
    depicts this scenario:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，整个应用程序由一组独立的类组成，这些类跨越多个垂直领域，并且不共享相同的类层次结构。此图展示了这一场景：
- en: '![](img/00043.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00043.jpeg)'
- en: Irrespective of the independent nature of each vertical, there are a few common
    items you need to implement across all of them, such as **transaction management**,
    **session management**, **audit logging**, **security**, **caching**, or any such
    custom processing mechanism based on rules.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每个垂直领域都是独立的，但您需要在所有这些领域实现一些共同的项目，例如**事务管理**、**会话管理**、**审计日志**、**安全**、**缓存**或任何基于规则的定制处理机制。
- en: If you wish to implement these common services across verticals with a traditional
    approach, you need to put them into each of the methods in these classes manually.
    Taking an example of a logging mechanism, for this, you would need to write a
    little bit of code at the beginning and end of every method.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望使用传统方法在垂直领域实现这些常见服务，您需要手动将这些服务放入这些类的每个方法中。以日志机制为例，为此，您需要在每个方法的开始和结束时编写一些代码。
- en: This leads to code duplication, as the same logic needs to be placed several
    times. This leads to a maintenance nightmare in the later part of the application
    development process when any changes are introduced. Let's understand how.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了代码重复，因为相同的逻辑需要被放置多次。这导致在应用程序开发过程的后期引入任何更改时，维护变得噩梦般。让我们了解如何。
- en: Suppose, as per your business requirements, you add audit logs after each update
    and delete method. You put the method name and its time in the log. Now, let's
    say your business needs to place the name of currently logged-in users in the
    log. In this case, you need to update the logging details manually in several
    methods.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，根据你的业务需求，你在每个更新和删除方法之后添加审计日志。你将方法名称及其时间放入日志中。现在，假设你的业务需要在日志中放置当前登录用户的名称。在这种情况下，你需要手动在几个方法中更新日志细节。
- en: This is just one example. You will end up changing the code for each of the
    common services, spread across multiple verticals. The effective solution is to
    keep them isolated from verticals. Implement them in one place and plug them into
    other core business classes as and when required based on certain rules or criteria.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个例子。你最终需要对分布在多个垂直领域的每个通用服务进行代码更改。有效的解决方案是将它们与垂直领域隔离开来。在一个地方实现它们，并根据某些规则或标准，在需要时将它们插入到其他核心业务类中。
- en: In essence, the core part of the business logic does not have to know that something
    that is common across multiple classes has been included, removed, or changed,
    and can keep working as before. Separating common functionalities (cross-cutting
    concerns in the AOP paradigm) and turning them on and off without touching or
    modifying the core business logic, will eventually increase modularity and bring
    great flexibility in terms of maintenance in any application. AOP aims to provide
    a way to achieve this solution. AOP is mainly used to provide declarative services.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，业务逻辑的核心部分不需要知道跨越多个类的通用内容已被包含、删除或更改，并且可以像以前一样继续工作。将通用功能（AOP范式中的横切关注点）分离出来，在不接触或修改核心业务逻辑的情况下打开和关闭它们，最终会增加模块化，并在任何应用程序的维护方面带来极大的灵活性。AOP旨在提供实现这一解决方案的方法。AOP主要用于提供声明性服务。
- en: 'To understand AOP concepts, it''s crucial to understand the terminology used
    in the AOP paradigm:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解面向切面编程（AOP）的概念，关键是要了解AOP范式中所使用的术语：
- en: '**Concern:** This is a behavior or functionality we want to achieve in our
    application. For example, HR management and employee management are two functionalities,
    and are thus considered as concerns in AOP.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点（Concern）**：这是我们希望在应用程序中实现的行为或功能。例如，人力资源管理员工管理是两个功能，因此被视为AOP中的关注点。'
- en: '**Aspect:** In very simple terms, this is a common behavior that spans multiple
    classes in the same or different hierarchy. In other words, the common concept
    that cuts across multiple concerns is called the aspect. In our example, the logging
    mechanism is called the aspect in AOP terminology.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切面（Aspect）**：用非常简单的话来说，这是跨越同一或不同层次结构中多个类的通用行为。换句话说，跨越多个关注点的通用概念称为切面。在我们的例子中，日志机制在AOP术语中被称为切面。'
- en: '**Join-point:** This is a point during the execution flow of the application
    where you need to apply **Advice**. For example, a method invocation or a place
    where you need to handle an exception could be join-point.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接点（Join-point）**：这是在应用程序执行流程中需要应用**通知（Advice）**的点。例如，方法调用或需要处理异常的地方可以是连接点。'
- en: '**Advice:** This is an action performed on a specific join-point by the AOP
    framework. Conceptually, it''s a common functionality implementation at that join-point.
    The process of applying **Advice** can be controlled by specifying various types,
    such as `around`, `before`, `after`, `throws`, and so on.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知（Advice）**：这是AOP框架在特定连接点上执行的操作。从概念上讲，它是在该连接点上实现的通用功能。应用**通知**的过程可以通过指定各种类型来控制，例如`around`、`before`、`after`、`throws`等。'
- en: '**Point-cut:** This is an expression that describes a pattern of applicable
    join-points. In other words, the AOP framework will apply the **Advice** (common
    functionality) on join-points (methods) that are described by a point-cut (for
    example, `set*` means all methods start with the word *set*). We can say a point-cut
    is a filter criterion to choose join-points in the system.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切入点（Point-cut）**：这是一个描述适用连接点模式的表达式。换句话说，AOP框架将在由切入点（例如，`set*`表示所有以单词*set*开头的方法）描述的连接点（方法）上应用**通知（Advice）**（通用功能）。我们可以说切入点是选择系统中连接点的筛选标准。'
- en: In most cases, developers get confused between join-point and point-cut. Let's
    take a real-life example to understand the difference. Suppose you want to buy
    cooking oil and you go to the department store. You reach the grocery section
    and find various edible oils made from difference sources, such as sunflower,
    groundnut, cotton seed, rice brand, corn, and so on.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，开发人员会在连接点和切入点之间感到困惑。让我们通过一个现实生活中的例子来理解这种区别。假设你想买食用油，你去了百货商店。你到达了杂货区，发现各种来自不同来源的可食用油，如葵花籽油、花生油、棉籽油、大米品牌、玉米等等。
- en: Your requirement is to choose light oil (in terms of low cholesterol) for your
    daily needs, and hence you choose either sunflower oil or rice brand oil. In this
    case, all the available edible oils are the join-points, and your choice of sunflower/rice
    brand oil, based on your needs, is considered a point-cut. In short, all available
    options are considered as join-points, while the one you choose, based on your
    needs, is called a point-cut.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您的要求是选择轻油（就低胆固醇而言）来满足您的日常需求，因此您选择葵花籽油或大米品牌油。在这种情况下，所有可用的食用油都是连接点，而您根据需求选择的葵花籽油/大米品牌油被认为是切入点。简而言之，所有可用的选项都被认为是连接点，而您根据需求选择的那个被称为切入点。
- en: '**Target object:** That is the object in which the common functionalities are
    being implemented. In other words, this is the object on which the **Advice**
    is applied by a set of aspects.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标对象**：这是实现公共功能的对象。换句话说，这是由一系列方面应用**通知**的对象。'
- en: '**AOP-Proxy:** Proxy is a design pattern used to encapsulate the object and
    control access to it. The AOP framework creates a proxy/dynamic object to implement
    various aspects (in the form of **Advice**). In short, AOP creates a proxy object
    that looks like the object on which the proxy was created, but with a few additional
    features. In **Spring Framework**, AOP-proxy is supplied through the JDK or the
    CGLIB library.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AOP-代理**：代理是一种设计模式，用于封装对象并控制对其的访问。AOP框架创建一个代理/动态对象以实现各种方面（以**通知**的形式）。简而言之，AOP创建了一个代理对象，它看起来像创建代理的对象，但具有一些额外的功能。在**Spring框架**中，AOP代理通过JDK或CGLIB库提供。'
- en: '**Weaving: **As we have seen, the main idea behind AOP is to plug common behaviors
    (or aspects) into business classes without modifying them. The process of linking
    such aspects with other classes to apply **Advice** is called weaving.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**织入**：正如我们所见，AOP背后的主要思想是将公共行为（或方面）插入业务类中，而不修改它们。将此类方面与其他类链接以应用**通知**的过程称为织入。'
- en: Weaving can be done at compile or run time. **Spring AOP** supports load-time
    weaving, while the **AspectJ** framework supports both compile-time and load-time
    weaving.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 织入可以在编译或运行时进行。**Spring AOP**支持加载时织入，而**AspectJ**框架支持编译时和加载时织入。
- en: '**Compile-time weaving**:In this type of weaving, the process of linking aspects
    is performed at compile time. The AOP framework will apply the aspects to your
    Java source file and create a binary class file, which is woven with those aspects.
    AspectJ uses a special compiler to achieve compile-time weaving.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译时织入**：在这种类型的织入中，链接方面的过程是在编译时执行的。AOP框架将方面应用到您的Java源文件上，并创建一个二进制类文件，该文件与这些方面交织在一起。AspectJ使用一个特殊的编译器来实现编译时织入。'
- en: '**Post-compile-time (or binary) weaving**:This is similar to compile-time weaving.
    The process of linking aspects is performed on precompiled classes, or JAR files.
    The aspects that are woven may be in either source or binary form. This, again,
    can be done through a special compiler. Both compile-time and post-compile-time
    weaving can be achieved through AspectJ.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译后（或二进制）织入**：这与编译时织入类似。链接方面的过程是在预编译的类或JAR文件上执行的。织入的方面可以是源形式或二进制形式。这同样可以通过一个特殊的编译器来完成。编译时和编译后织入都可以通过AspectJ实现。'
- en: '**Runtime weaving**:Compile-time and post-compile-time weaving happens before
    the actual class file is loaded into memory, whereas runtime (or load-time) weaving
    happens once the target class is loaded into JVM by the class loader. Runtime
    weavers are supported by both the Spring AOP and AspectJ frameworks.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时织入**：编译时和编译后织入发生在实际类文件被加载到内存之前，而运行时（或加载时）织入发生在目标类被类加载器加载到JVM之后。运行时织入器由Spring
    AOP和AspectJ框架都支持。'
- en: 'The process of weaving can be expressed through the following diagram:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 织入过程可以通过以下图表表示：
- en: '![](img/00044.gif)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00044.gif)'
- en: Spring AOP
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring AOP
- en: '**Spring AOP** is purely developed in Java. It doesn''t require us to alter
    or control the class loader hierarchy. Because of this adaptability, you can utilize
    Spring AOP for a servlet container or application server. At present, Spring AOP
    only supports applying Advice at method level. In other words, method-level join-points
    are supported in Spring AOP'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring AOP**完全是用Java开发的。它不需要我们修改或控制类加载器层次结构。正因为这种适应性，您可以使用Spring AOP于servlet容器或应用服务器。目前，Spring
    AOP仅支持在方法级别应用通知。换句话说，Spring AOP支持方法级别的连接点。'
- en: Spring supports AOP in conjunction with its IoC capabilities. You can define
    aspects with normal bean definition, while weaving them with AOP specific configuration.
    In other words, IoC is used to define aspects, and AOP is used to weave them to
    other objects. Spring uses both of them to solve common problems. This is how
    Spring AOP differs from other AOP frameworks.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Spring支持AOP与它的IoC能力相结合。您可以使用常规的Bean定义来定义方面，并通过AOP特定的配置来织入它们。换句话说，IoC用于定义方面，而AOP用于将它们织入其他对象。Spring使用这两者来解决常见问题。这就是Spring
    AOP与其他AOP框架不同的地方。
- en: Spring AOP is a proxy-based framework, and supports runtime weaving of objects.
    It can be used through either XML-based or AspectJ annotation-based configuration.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP是一个基于代理的框架，并支持对象的运行时织入。它可以通过基于XML或AspectJ注解的配置来使用。
- en: XML(schema)-based Spring AOP
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于XML模式的Spring AOP
- en: 'Just like a class is the unit of the object-oriented programming paradigm,
    aspect is the unit of AOP. Modularity is achieved through aspect in an aspect-oriented
    programming model. If you wish to choose XML-based configuration for AOP, Spring
    supports defining aspects using `aop` namespace tags. You need to define `aop`
    namespace tags as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 就像类是面向对象编程范式的单元一样，方面是AOP的单元。在面向方面的编程模型中，通过方面实现模块化。如果您希望选择基于XML的AOP配置，Spring支持使用`aop`命名空间标签来定义方面。您需要按照以下方式定义`aop`命名空间标签：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To differentiate AOP-specific configuration, you need to specify all AOP-related
    artifacts such as aspects, point-cut, Advice, and so on, within an `<aop:config>`
    element inside your Spring context (XML) file. Multiple `<aop:config>` elements
    are allowed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分AOP特定的配置，您需要在Spring上下文（XML）文件内的`<aop:config>`元素中指定所有AOP相关的工件，如方面、切点、通知等。允许存在多个`<aop:config>`元素。
- en: Declaring aspect
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明方面
- en: 'The first thing in Spring AOP is to decide on and define the aspects. In XML-based
    configuration, an aspect is conceptualized as a simple Java class that you need
    to declare as a bean definition in a Spring application context (XML) file. The `<aop:aspect>`
    element is used to define an aspect:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP的第一步是决定并定义方面。在基于XML的配置中，方面被构想为一个简单的Java类，您需要将其声明为Spring应用程序上下文（XML）文件中的Bean定义。《aop:aspect》元素用于定义方面：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since an aspect is a form of Java class, it can be defined as a normal Spring
    bean, and then can be configured with the `ref` attribute of the `<aop:aspect>`
    element. The state and behavior is associated with fields and methods of the aspect
    class, while the point-cut and advice information is configured in the XML. In
    the previous example, we define logging as an aspect.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于方面是一种Java类的形式，它可以被定义为普通的Spring Bean，然后可以通过`<aop:aspect>`元素的`ref`属性进行配置。状态和行为与方面的类的字段和方法相关联，而切点和通知信息则在XML中进行配置。在先前的例子中，我们将日志定义为方面。
- en: After defining an aspect, the next step is to define the join-point through
    the point-cut. Spring AOP supports method-level join-points only.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 定义方面之后，下一步是通过切点定义连接点。Spring AOP仅支持方法级别的连接点。
- en: In XML schema based-AOP, Spring enables an auto-proxy mechanism with the `<aop:config>`
    declaration. You do not need to define anything for auto-proxy explicitly; however,
    if you are enabling auto-proxy with some other mechanism (such as AutoProxyCreator),
    you should choose either of these options to avoid any runtime issues.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于XML模式的AOP中，Spring通过`<aop:config>`声明启用自动代理机制。您不需要显式定义任何自动代理的内容；然而，如果您通过其他机制（如AutoProxyCreator）启用自动代理，您应该选择这些选项之一以避免任何运行时问题。
- en: Declaring a point-cut
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明切点
- en: Just to recall, a join-point is a place where we want to apply **Advice**, and
    a point-cut represents a pattern of matching join-points. A point-cut must be
    defined within the `<aop:config>` element. A point-cut can be declared within
    the `<aop:aspect>` element or outside of it. If it's defined outside of `<aop:aspect>`,
    it can be shared between multiple aspects and advisors.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 就回忆一下，连接点是我们想要应用**通知**的地方，而点设计符代表匹配连接点的模式。点设计符必须在`<aop:config>`元素内定义。点设计符可以在`<aop:aspect>`元素内或外部声明。如果它在`<aop:aspect>`外部定义，它可以在多个方面和通知之间共享。
- en: 'A point-cut allows Advice to be applied to the target object independently
    of the object-oriented hierarchy. Transaction management through AOP Advice in
    Spring is a real example of where transaction Advice is applied to specific methods
    (`add`/`update`/`delete` methods) that span multiple object hierarchies. This
    snippet is one of the possible ways of writing a point-cut:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 点设计符允许通知独立于面向对象层次结构应用于目标对象。通过Spring AOP通知进行事务管理是一个真正的例子，其中事务通知应用于跨越多个对象层次结构的方法（`add`/`update`/`delete`方法）。这个片段是编写点设计符的可能方法之一：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A point-cut is uniquely identified by its `id` attribute. The `expression`
    attribute represents the pattern (or filter) of matching join-points. The value
    of the `expression` attribute consists of two components:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 点设计符通过其`id`属性唯一标识。`expression`属性表示匹配连接点的模式（或过滤器）。`expression`属性的值由两个组件组成：
- en: Point-cut designator
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点设计符
- en: Pattern
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式
- en: Point-cut designator
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点设计符
- en: 'A **point-cut designator** (**PCD**) is a keyword (initial word) that tells
    Spring AOP how to match the point-cut. Spring AOP supports various point-cut designators:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**点设计符**（**PCD**）是一个关键字（初始单词），告诉Spring AOP如何匹配点设计符。Spring AOP支持各种点设计符：'
- en: '**`execution`:** This is used to match method execution (join-points). This
    is a primary designator, and is used most of the time while working with Spring
    AOP.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`execution`:** 这用于匹配方法执行（连接点）。这是一个主要设计符，在处理Spring AOP时通常使用。'
- en: '**`within`:** This designator has the limitation of matching of join-points
    within certain types only. It''s not as flexible as execution. For example, it''s
    not allowed to specify return types or method parameter mapping. If the patterns
    with `within` are up to the Java package, it matches all methods of all classes
    within that package. If the pattern is pointing to a specific class, then this
    designator will cover all the methods within that class.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`within`:** 这个设计符限制了仅匹配特定类型的连接点。它不如执行灵活。例如，不允许指定返回类型或方法参数映射。如果`within`的模式达到Java包级别，它将匹配该包中所有类的所有方法。如果模式指向一个特定的类，那么这个设计符将覆盖该类中的所有方法。'
- en: '**`this`: **This restricts the matching of join-points to the beans that are
    references of a given type in an expression. In other words, the `this` designator
    is one step narrower than the `within` designator, and expects you to specify
    a specific class type as a pattern. It will not be allowed to define any wildcard
    patterns.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`this`:** 这限制了连接点的匹配，仅限于表达式中的给定类型的bean。换句话说，`this`设计符比`within`设计符更窄一步，并期望你指定一个特定的类类型作为模式。不允许定义任何通配符模式。'
- en: '**`target`:** This limits the matching of join-points, where the target object
    is an instance of the given type in an expression. The target designator seems
    similar to the `this` designator, but there is a difference in their use. Let''s
    understand this.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`target`:** 这限制了匹配连接点，其中目标对象是表达式中的给定类型的实例。目标设计符似乎与`this`设计符相似，但它们的使用有所不同。让我们来理解这一点。'
- en: As we have seen, Spring AOP creates proxy objects through either the **JDK**
    or the **CGLIB** library. Spring AOP uses a JDK-based proxy if the target object
    implements an interface; otherwise, it selects CGLIB. You should use the `this`
    designator when CGLIB provides the proxy (that is, your target object doesn't
    implement an interface), and the target designator when the JDK provides the proxy
    (the `target` object implements an interface).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Spring AOP通过JDK或CGLIB库创建代理对象。如果目标对象实现了接口，Spring AOP使用基于JDK的代理；否则，它选择CGLIB。当CGLIB提供代理时（即，你的目标对象没有实现接口），你应该使用`this`设计符；当JDK提供代理时（`target`对象实现了接口），你应该使用目标设计符。
- en: '**`args`:** This designator is generally used for matching method arguments.
    It allows us to pass wildcards for matching packages, Java classes, return types,
    or method names.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`args`**：这个指示符通常用于匹配方法参数。它允许我们传递通配符来匹配包、Java类、返回类型或方法名称。'
- en: '**`@target`:** This PCD filters the join-points where the class of the object
    has an annotation of a given type. Although the names are equal, the `@target` designator
    is not similar to the `target` designator. They are different in terms of matching
    the join-points as follows:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`@target`**：这个PCD（点切割定义）过滤了具有给定类型注解的对象类的连接点。尽管名称相同，但`@target`指示符与`target`指示符不同。它们在匹配连接点方面有所不同，如下所示：'
- en: 'The `target` designator: Matches the target object if it is an instance of
    the given type in an expression'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`指示符：如果表达式中的目标对象是给定类型的实例，则匹配目标对象。'
- en: 'The `@target` designator: Matches the target object, if the class of target
    object has an annotation of given type'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@target`指示符：如果目标对象的类具有给定类型的注解，则匹配目标对象。'
- en: '**`@within`:** This designator restricts matching join-points to within the
    type that has a given annotation. It allows us to use wildcards to match point-cuts.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`@within`**：这个指示符限制了匹配的连接点在具有给定注解的类型内部。它允许我们使用通配符来匹配点切割。'
- en: '**`@annotation`:** This PCD is used to match a point-cut of a type that has
    a given annotation. It''s useful to construct point-cuts on classes that have
    custom annotation.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`@annotation`**：这个PCD用于匹配具有给定注解类型的点切割。这对于在具有自定义注解的类上构建点切割非常有用。'
- en: '**`@args`:** This designator restricts matching a join-point to where actual
    runtime objects passed as method arguments have an annotation of a given type.
    This is useful to narrow down the join-point selection to specific methods from
    the available overloaded methods in the target class.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`@args`**：这个指示符限制了匹配连接点，只有当实际运行时作为方法参数传递的对象具有给定类型的注解时。这有助于将连接点选择缩小到目标类中可用的重载方法中的特定方法。'
- en: Patterns
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式
- en: A pattern is a filter criteria to match possible join-points. It tells Spring
    AOP what to match. **Patterns** are generally written within brackets, just after
    the PCD. It's a kind of regular expression in AOP to select the desired join-point.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 模式是匹配可能连接点的过滤条件。它告诉Spring AOP要匹配什么。**模式**通常在PCD之后、括号内书写，它是一种AOP中的正则表达式，用于选择所需的连接点。
- en: 'Spring AOP supports only method-level join-points, and patterns are used to
    choose specific methods of the target object. A pattern consists of the following
    expressions in the same order:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP只支持方法级别的连接点，并且使用模式来选择目标对象的具体方法。一个模式由以下表达式按相同顺序组成：
- en: '**Access modifier**: For Spring AOP, the only possible value is `public`. This
    expression is optional.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问修饰符**：对于Spring AOP，唯一可能的值是`public`。这个表达式是可选的。'
- en: '**Return type**: This is the fully qualified name of the return type. Putting
    `*` for this expression means it allows any return type.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回类型**：这是返回类型的完全限定名称。使用`*`（星号）表示允许任何返回类型。'
- en: '**Java package**: Java package name can be used.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java包**：可以使用Java包名称。'
- en: '**Java class name**: Java class name can be used. Putting `*` for this expression
    means it applies to all Java classes under a given package.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java类名称**：可以使用Java类名称。在这个表达式中使用`*`表示它适用于给定包下的所有Java类。'
- en: '**Method name**: Method name can be given. Putting `*` in this expression will
    include all methods of a given class.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法名称**：可以指定方法名称。在这个表达式中使用`*`将包括给定类中的所有方法。'
- en: '**Method parameters**: Type of parameter can be given. Putting `..` (two dots)
    means any number of parameters for a given method will be considered.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法参数**：可以指定参数类型。使用`..`（两个点）表示给定方法可以接受任意数量的参数。'
- en: '**Exception details**: Throws a declaration.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常详情**：抛出声明。'
- en: The format of a pattern is exactly similar to method signature. Let's understand
    the meaning of the previous expressions by seeing a few examples.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 模式的格式与方法签名完全相同。让我们通过查看一些示例来理解前面表达式的含义。
- en: '**Example 1** :The following expression will match all public methods of the `EmployeeService`
    class with the following conditions:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例 1**：以下表达式将匹配满足以下条件的`EmployeeService`类中的所有公共方法：'
- en: Method with any return value, including void
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含任何返回值的方法，包括void
- en: 'Method with any parameters, including empty parameter method:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含空参数方法在内的任何参数的方法：
- en: '![](img/00045.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00045.jpeg)'
- en: '**Example 2**:The following expression will match all public methods with the
    following conditions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例 2**：以下表达式将匹配满足以下条件的所有公共方法：'
- en: Method with any return value, including void
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何返回值的方法，包括无返回值的方法
- en: Method with any parameters, including empty parameter method
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何参数的方法，包括空参数方法
- en: 'Method of all classes that fall directly under the `com.packet.spring.aop.service` Java
    package:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接位于`com.packet.spring.aop.service` Java包下的所有类的成员方法：
- en: '![](img/00046.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00046.jpeg)'
- en: '**Example 3**: The following expression will match all public methods with
    the following conditions:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例 3**：以下表达式将匹配所有满足以下条件的公共方法：'
- en: Method with any return value, including void
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何返回值的方法，包括无返回值的方法
- en: Method with any parameters, including empty parameter method
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何参数的方法，包括空参数方法
- en: 'Method of all classes fall under the `com.packet.spring.aop.service` Java package and
    its subpackage:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位于`com.packet.spring.aop.service` Java包及其子包下的所有类的成员方法：
- en: '![](img/00047.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00047.jpeg)'
- en: '**Example 4**:The following expression will match all public methods of the `EmployeeService`
    class with the following conditions:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例 4**：以下表达式将匹配`EmployeeService`类的所有公共方法，满足以下条件：'
- en: Method with a return type of String only
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只返回`String`类型的方法
- en: 'Method with any parameters, including an empty parameter method:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何参数的方法，包括空参数方法：
- en: '![](img/00048.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00048.jpeg)'
- en: '**Example 5**:The following expression will match all public methods of the `EmployeeService` class
    with the following conditions:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例 5**：以下表达式将匹配`EmployeeService`类的所有公共方法，满足以下条件：'
- en: Method with any return value, including void
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何返回值的方法，包括无返回值的方法
- en: 'Method with two parameters, first a `String` and second a `Long`, in the same
    order of method parameter:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有两个参数的方法，第一个参数是`String`类型，第二个参数是`Long`类型，且顺序与方法参数相同：
- en: '![](img/00049.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00049.jpeg)'
- en: '**Example 6**:The following expression will match all public methods of the `EmployeeService` class
    with the following conditions:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例 6**：以下表达式将匹配`EmployeeService`类的所有公共方法，满足以下条件：'
- en: Method with any return value, including void
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何返回值的方法，包括无返回值的方法
- en: 'Method with one or more parameters, where the first parameter is `String` only:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个或多个参数的方法，其中第一个参数只能是`String`类型：
- en: '![](img/00050.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00050.jpeg)'
- en: '**Example 7**:The following expression will match specific public methods with
    the following conditions:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例 7**：以下表达式将匹配满足以下条件的特定公共方法：'
- en: Method name starts with the `find` word
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名称以`find`单词开头
- en: Method with any return value, including void
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何返回值的方法，包括无返回值的方法
- en: Method with just one parameter of type `String`
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一个参数类型为`String`的方法
- en: 'Methods of all classes fall under the `com.packet.spring.aop.service` Java
    package:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位于`com.packet.spring.aop.service` Java包下的所有类的成员方法：
- en: '![](img/00051.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00051.jpeg)'
- en: Declaring Advice (interceptor)
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明通知（拦截器）
- en: 'The next step is to define **Advice**. This is an action performed on a join-point.
    Advice is also referred as an *interceptor*. Spring AOP supports various types
    of Advice, as shown here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义**通知**。这是在连接点上执行的操作。通知也被称为*拦截器*。Spring AOP支持各种类型的通知，如此处所示：
- en: '**Before Advice:** This type of Advice is executed just before the execution
    starts at the join-point. In the case of an exception, Spring will stop further
    execution of this Advice.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前置通知**：这种类型的通知是在连接点执行开始之前执行的。在发生异常的情况下，Spring将停止进一步执行此通知。'
- en: '**After Advice: **As its name suggests, this type of Advice is executed after
    completion of join-point execution (either a normal exit, or in the case of an
    exception, from the join-point).'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回后通知**：正如其名所示，这种类型的通知是在连接点执行完成后执行的（无论是正常退出，还是在异常情况下从连接点退出）。'
- en: '**Around Advice: **This type of Advice is executed around the join-point (before
    and/or after the advised method). Because of this, you have the control to execute
    the join-point and return the original method value, or bypass the flow and return
    a custom value. In general, around Advice is used to execute some logic before
    and/or after a method''s main logic. Due to this, it''s the most powerful type
    of Advice.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环绕通知**：这种类型的通知是在连接点周围执行的（在通知方法之前和/或之后）。因此，您有控制权来执行连接点并返回原始方法值，或者绕过流程并返回自定义值。通常，环绕通知用于在方法的主要逻辑之前和/或之后执行某些逻辑。因此，它是通知中最强大的一种类型。'
- en: '**After returning Advice: **This is similar to after Advice. The difference
    is that it''s being executed on a normal exit from a join-point.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回后通知**：这与返回后通知类似。区别在于它是在连接点的正常退出时执行的。'
- en: '**After throwing Advice: **This is also similar to after Advice, but is executed
    when an exception occurred during execution of the Advice''s method.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抛出通知之后：**这和后置通知类似，但它在执行通知方法的执行过程中发生异常时执行。'
- en: In XML-based Spring AOP, you need to be careful of the order of AOP elements
    while defining them within `<aop:config>`. For example, `<aop:pointcut>` must
    be defined before or within the `<aop:aspect>` element or else Spring will show
    an error. Similarly, AOP Advice must be defined within the `<aop:aspect>` element.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于XML的Spring AOP中，当你定义`<aop:config>`内的AOP元素时，需要小心AOP元素的顺序。例如，`<aop:pointcut>`必须在`<aop:aspect>`元素之前或其中定义，否则Spring将显示错误。同样，AOP通知必须在`<aop:aspect>`元素内定义。
- en: Implementing before advice
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现前置通知
- en: 'So far we have seen how to declare aspects, point-cuts, and Advice. Let''s
    put them together and understand how they work together. Suppose we want to put
    a logger at the beginning of all methods of classes that fall under the `com.packet.spring.aop.service`
    package. The configuration would be as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何声明方面、切入点和建议。让我们将它们放在一起，了解它们是如何协同工作的。假设我们想在属于`com.packet.spring.aop.service`包的所有类的所有方法的开头放置一个记录器。配置如下：
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have defined a point-cut that matches all public methods of all classes under
    the `com.packet.spring.aop.service` package, with any parameter and any return
    value. Next, we have defined the logging aspect bean, and given its reference
    to `<aop:aspect>` with the `ref` attribute.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个切入点，它匹配`com.packet.spring.aop.service`包下所有类的所有公共方法，无论参数和返回值如何。接下来，我们定义了日志方面bean，并将其引用通过`ref`属性传递给`<aop:aspect>`。
- en: 'Inside the aspect, we have defined before advice (`<aop:before>`) and gave
    point-cut reference there. The  `printStartLog` method is defined in the aspect
    bean as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在方面中，我们之前已经定义了通知（`<aop:before>`）并在那里提供了切入点引用。`printStartLog`方法在方面bean中定义如下：
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It's not required to pass the `JoinPoint` parameter in the `printStartLog` method.
    It will work even if you don't pass the `JoinPoint` parameter. But, it gives you
    metadata about the target object. In this sense, it's useful. For example, in
    the previous case, we display the woven method's name and its class name.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`printStartLog`方法中不需要传递`JoinPoint`参数。即使你不传递`JoinPoint`参数，它也能正常工作。但是，它提供了关于目标对象的元数据。从这个意义上说，它是有用的。例如，在前面的案例中，我们显示了织入方法的名称和其类名。
- en: 'The target class `EmployeeService` is defined in the `com.packet.spring.aop.service`
    package as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 目标类`EmployeeService`在`com.packet.spring.aop.service`包中定义如下：
- en: '[PRE5]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we get the `EmployeeService` object from Spring''s application context
    file and call these methods, AOP will intercept all these methods and insert the
    log (which we kept in the `printStartLog` of `LoggingAspect`), before execution
    of each of the methods (because we have used before advice):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从Spring的应用程序上下文文件中获取`EmployeeService`对象并调用这些方法时，AOP将拦截所有这些方法，并在每个方法的执行之前插入日志（我们保存在`LoggingAspect`的`printStartLog`中）：
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And you will get output as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can observe how Spring AOP traps each method of the `EmployeeService` class
    and adds the log at the beginning of each method. It prints the `method` name
    and `class` name dynamically.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以观察到Spring AOP如何捕获`EmployeeService`类的每个方法，并在每个方法的开头添加日志。它动态地打印`method`名称和`class`名称。
- en: Implementing after advice
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现后置通知
- en: 'Just like before advice, we can also implement other advice types. Let''s take
    an example of after advice and around advice. For after advice, just add one method
    in the `LoggingAspect` class as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 就像前置通知一样，我们也可以实现其他通知类型。让我们以后置通知和环绕通知为例。对于后置通知，只需在`LoggingAspect`类中添加一个方法，如下所示：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In after advice, we are just printing the `method` name. We also need to update
    the aspect configuration in the application context file. Just add an after advice
    entry for our logging aspect, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在后置通知中，我们只是打印`method`名称。我们还需要更新应用程序上下文文件中的方面配置。只需为我们的日志方面添加一个后置通知条目，如下所示：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You will get the following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This time, you can observe how AOP intercepts each method and implements after
    advice along with before advice.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你可以观察到AOP如何拦截每个方法，并实现后置通知和前置通知。
- en: Implementing around advice
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现环绕通知
- en: 'Spring AOP also provides around advice, which is a combination of before and
    after in one go. If you need to process something before and after, you can simply
    implement around advice instead of before and after advice separately. To implement
    around advice, just add one more method in our `LoggingAspect` as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP还提供了环绕建议，它是一次性结合了前置和后置。如果你需要在前后处理某些事情，你可以简单地实现环绕建议，而不是分别实现前置和后置建议。要实现环绕建议，只需在`LoggingAspect`中添加一个额外的方法，如下所示：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For *around* advice, Spring AOP supplies the `ProceedingJoinPoint` object instead
    of `JoinPoint` object.  `proceedingJoinPoint.proceed()` will simply call the method
    on the `target` object, and you can put the before logic just above the `proceedingJoinPoint.proceed()`
    call and after the logic just next to it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*附近*的建议，Spring AOP提供`ProceedingJoinPoint`对象而不是`JoinPoint`对象。`proceedingJoinPoint.proceed()`将简单地调用`target`对象上的方法，你可以在`proceedingJoinPoint.proceed()`调用上方放置前置逻辑，并在其旁边放置后置逻辑。
- en: '`ProceedingJoinPoint` can be used for around advice only. If you try to use
    it for before or after advice, you will get an error. For them, you should use
    join-point only.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProceedingJoinPoint`只能用于环绕建议。如果你尝试将其用于前置或后置建议，你会得到一个错误。对于它们，你应该只使用连接点。'
- en: 'The last step is to update the configuration to plug around advice for the
    aspect as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是更新配置，为方面插入环绕建议，如下所示：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You will get output as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is how around advice is implemented and does the work of *before* and *after* advice
    altogether.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是环绕建议的实现方式，以及它如何一起完成前置和后置建议的工作。
- en: Don't use *before*, *after*, and *around* advice all together. If you need to
    put some additional code at the beginning of the method, use *before* advice only,
    instead of *around*. Although using *around* advice can achieve what you implemented
    with *before* advice alone, it's not a good idea. Use *around* advice only when
    you want to add something before and after methods.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 不要同时使用*前置*、*后置*和*环绕*建议。如果你需要在方法开始处放置一些额外的代码，请仅使用*前置*建议，而不是*环绕*。虽然使用*环绕*建议可以单独使用*前置*建议实现的功能，但这不是一个好主意。只有当你想在方法前后添加内容时才使用*环绕*建议。
- en: Implementing after returning advice
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现返回后建议
- en: The **after returning** advice works just like after advice. The only difference
    is that this advice will be executed on matching methods only on normal exit.
    If an exception occurs, this advice will not be applied.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回后**建议的工作方式与返回建议相同。唯一的区别是，此建议仅在正常退出时在匹配的方法上执行。如果发生异常，则此建议不会应用。'
- en: 'We will look at a scenario to understand the need for this advice. Suppose
    you want to send a message (email) to a concerned person when a particular method
    is executed successfully on the `target` class. Since this is a new concern (sending
    a message on successful execution of the `target` method), we have created a new aspect
    class as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一个场景来理解这个建议的需求。假设你希望在`target`类上执行特定方法成功时向相关人员发送消息（电子邮件）。由于这是一个新的关注点（在`target`方法成功执行时发送消息），我们已创建了一个新的方面类，如下所示：
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `SendMessage` aspect has one method called `sendMessageOnSuccessExit`.
    We want this method to be called on a normal method exit (without an exception)
    from the `target` class. You can write the logic to send the message (email) in
    this method. The new aspect will be configured in the application context (XML)
    file as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`SendMessage`方面有一个名为`sendMessageOnSuccessExit`的方法。我们希望这个方法在`target`类的正常方法退出（没有异常）时被调用。你可以在该方法中编写发送消息（电子邮件）的逻辑。新的方面将在应用程序上下文（XML）文件中按如下方式配置：'
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We have created a new point-cut that will match all the methods of the `HRService`
    class. This class will be as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的切入点，它将匹配`HRService`类的所有方法。这个类将如下所示：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When you get an object of `HRService` from Spring and call the `showHolidayList` method,
    you will get output as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从Spring获取`HRService`对象并调用`showHolidayList`方法时，你将得到以下输出：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If the `target` method returns a value and you want to modify it with AOP,
    you can do this  with after returning advice. For this, you need to specify the
    parameter name in the `<aop:aspect>` element as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`target`方法返回一个值，并且你想使用AOP修改它，你可以通过返回后建议来完成。为此，你需要在`<aop:aspect>`元素中指定参数名，如下所示：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this code, the value of the `returning` attribute says that the `sendMessageOnSuccessExit`
    method must declare a parameter called `retVal`.  Spring AOP will pass the return
    value from the method of the `target` object to this parameter (`retVal`) while
    applying this advice. Therefore, the type of the return value from the method
    of the `target` object must be compatible with the type of the parameter (`retVal`,
    in our case) in the advice method. Let''s update the `showHoliday` method of the
    `SendMessage` advice as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`returning` 属性的值表示 `sendMessageOnSuccessExit` 方法必须声明一个名为 `retVal` 的参数。Spring
    AOP在应用此建议时，将`target`对象的方法的返回值传递给此参数（`retVal`）。因此，`target`对象的方法的返回值类型必须与建议方法中参数的类型（在我们的例子中是`retVal`）兼容。让我们按照以下方式更新
    `SendMessage` 建议的 `showHoliday` 方法：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The return value type of this method is `String`. To update the return value,
    you need to change the advice method as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的返回值类型为 `String`。要更新返回值，您需要按照以下方式更改建议方法：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you get the `HRService` object from Spring and call its `showHolidayList()`
    method, you will get the following updated return value:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从Spring获取`HRService`对象并调用其`showHolidayList()`方法时，您将得到以下更新的返回值：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Implementing AfterThrowing advice
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现AfterThrowing建议
- en: '*The AfterThrowing advice* will be executed when the matched methods of the
    target object exit with an exception. This is also useful when you want to take
    an action on an exception that occurred during execution of the method. Let''s
    create AfterThrowing advice as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*AfterThrowing建议* 会在目标对象的匹配方法抛出异常时执行。当您想在方法执行过程中发生的异常上采取行动时，这也很有用。让我们按照以下方式创建AfterThrowing建议：'
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `sendMessageOnErrorExit` advice method will be defined in the `sendMessage`
    aspect as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendMessageOnErrorExit` 建议方法将在 `sendMessage` 切面中定义如下：'
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To make sure this advice is applied, the method in the `target` class must
    exist with an exception. So, let''s add one method that throws an exception in
    the `target` class (HRService) as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保应用此建议，`target`类中的方法必须存在异常。因此，让我们在`target`类（HRService）中添加一个抛出异常的方法，如下所示：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you take the `HRService` object from Spring and call the `showMyLeave`
    method, you will get output as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从Spring获取`HRService`对象并调用`showMyLeave`方法时，您将得到以下输出：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '@AspectJ annotation-based Spring AOP'
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于@AspectJ注解的Spring AOP
- en: Spring allows another way to support AOP through the @AspectJ annotation. It's
    an alternative to XML-based configuration to define the aspect using regular Java
    classes with AOP-specific annotation. Spring introduced the @AspectJ style as
    a part of the AspectJ 5 release. Though with @AspectJ, Spring facilitates same
    annotation like AspectJ 5, the underlying framework is pure Spring AOP. Due to
    this arrangement, there is no dependency on AspectJ compiler or weaver.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 允许通过 @AspectJ 注解支持另一种支持AOP的方式。这是使用带有AOP特定注解的常规Java类定义切面的XML配置的替代方案。Spring在AspectJ
    5版本中引入了@AspectJ风格。尽管使用@AspectJ，Spring简化了与AspectJ 5相同的注解，但其底层框架是纯Spring AOP。由于这种安排，不需要依赖AspectJ编译器或编织器。
- en: To use @AspectJ annotation for Spring AOP, you need to enable its support in
    Spring through configuration and turn auto-proxy on. **Autoproxying** is a mechanism
    to create a proxy on the object of a Spring bean on which one or more aspects
    are woven. This allows Spring AOP to intercept the methods and apply advice on
    the matching point-cut.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用@AspectJ注解进行Spring AOP，您需要通过配置在Spring中启用其支持，并开启自动代理。**自动代理**是一种在Spring bean对象上创建代理的机制，该对象上织入了至少一个切面。这允许Spring
    AOP拦截方法并在匹配的切入点应用建议。
- en: 'As we have seen in [Chapter 3](part0066.html#1UU540-255b24dd0eb24162a557b7d0d84b0b16),
    *Dependency Injection with Spring*, Spring supports configuration of annotation
    either in the application context (XML) file, or in the Java configuration. Similarly,
    @AspectJ configuration can be done with either of these options. With Java-based
    configuration, you can enable Spring AOP annotation with the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [第3章](part0066.html#1UU540-255b24dd0eb24162a557b7d0d84b0b16) “使用Spring的依赖注入”
    中所看到的，Spring 支持在应用程序上下文（XML）文件或Java配置中配置注解。同样，@AspectJ配置可以使用这两种选项中的任何一种。使用基于Java的配置，您可以使用以下代码启用Spring
    AOP注解：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Alternatively, you can choose the application context (XML) file to enable `@Aspect`
    annotation. This can be achieved with the `<aop:aspectj-autoproxy/>` element.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以选择应用程序上下文（XML）文件来启用`@Aspect`注解。这可以通过`<aop:aspectj-autoproxy/>`元素实现。
- en: Spring AOP creates a proxy object to embed customer code; however, when you
    define any class as an aspect with the @Aspect annotation (or XML configuration),
    Spring will not create the proxy of that class. In short, the aspect class can't
    be the target of advice from another aspect. Spring will omit all such aspect
    classes from auto-proxy.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP 创建一个代理对象以嵌入客户代码；然而，当你将任何类定义为带有 `@Aspect` 注解（或 XML 配置）的 aspect 时，Spring
    不会创建该类的代理。简而言之，aspect 类不能成为另一个 aspect 通知的目标。Spring 将省略所有此类 aspect 类的自动代理。
- en: Declaring aspect
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明 aspect
- en: 'The concept of declaring Aspect with the @AspectJ annotation style is somewhat
    similar to XML schema-based AOP declaration. Just to recall, a Java class can
    be an Aspect in the Spring AOP framework. In annotation-based Spring AOP, you
    can declare any bean as an Aspect with the `@Aspect` annotation as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 @AspectJ 注解风格声明 Aspect 的概念与基于 XML 架构的 AOP 声明有些类似。只是为了回顾一下，Java 类可以在 Spring
    AOP 框架中作为 Aspect。在基于注解的 Spring AOP 中，你可以使用 `@Aspect` 注解将任何 bean 声明为 Aspect，如下所示：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `SessionCheck` class is defined as a regular Spring bean in the application
    context (XML) file as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`SessionCheck` 类在应用程序上下文（XML）文件中定义为常规 Spring bean，如下所示：'
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Aspect classes may have methods and fields like any other Java class. Spring
    doesn't impose any limits on defining aspects only with the bean defined in the
    application context (XML) file. If you have used bean autodetection through Java
    package scanning (with the `<context:component-scan>` element), Spring intelligently
    detects the `Aspect` class with the `@Aspect` annotation. Aspect classes may contain
    point-cuts and advice declaration.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Aspect 类可以像任何其他 Java 类一样拥有方法和字段。Spring 并不对仅通过在应用程序上下文（XML）文件中定义的 bean 来定义 aspect
    有限制。如果你已经通过 Java 包扫描（使用 `<context:component-scan>` 元素）使用了 bean 自动检测，Spring 会智能地检测带有
    `@Aspect` 注解的 `Aspect` 类。Aspect 类可以包含切点和通知声明。
- en: The @Aspect annotation itself is not sufficient for Spring to autodetect the
    class. You still need to use @Component, or any other stereotype annotation. @Aspect
    will consider the class (which is autodetected by @Component or an equivalent
    annotation) as an aspect for Spring AOP.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Aspect` 注解本身不足以让 Spring 自动检测类。你仍然需要使用 `@Component` 或任何其他 stereotypes 注解。`@Aspect`
    将类（由 `@Component` 或等效注解自动检测）视为 Spring AOP 的 aspect。'
- en: Declaring point-cut
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明切点
- en: 'Point-cuts are regular expressions or patterns to filter join-points where
    we want to apply advice. Since Spring AOP only supports method-level join-points,
    you can consider a point-cut as a matching of method execution on Spring beans.
    In the `@AspectJ` annotation style, a point-cut is declared by a method of an
    Aspect class (declared with the `@Aspect` annotation). Such methods are called
    **point-cut signatures**. The `@Pointcut` annotation is used to define such a
    method as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 切点是正则表达式或模式，用于过滤我们想要应用通知的连接点。由于 Spring AOP 只支持方法级别的连接点，你可以将切点视为在 Spring beans
    上匹配方法执行。在 `@AspectJ` 注解风格中，切点是通过 Aspect 类（使用 `@Aspect` 注解声明）的方法声明的。这些方法被称为 **切点签名**。`@Pointcut`
    注解用于定义此类方法，如下所示：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this code, the `validateSession` method represents a point-cut signature,
    while the `@Pointcut` annotation is used to describe a point-cut expression. The
    preceding point-cut is applied to all public methods of all classes under the
    `com.packt.spring.aop.service` package that have any parameters and return values.
    A method that represents a point-cut signature must have `void` as a return type. The
    preceding annotation-based AOP is equivalent to XML-based AOP configuration, as
    follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`validateSession` 方法代表一个切点签名，而 `@Pointcut` 注解用于描述一个切点表达式。前面的切点应用于 `com.packt.spring.aop.service`
    包下所有具有参数和返回值的公共方法。代表切点签名的必须具有 `void` 作为返回类型。前面的基于注解的 AOP 与基于 XML 的 AOP 配置等效，如下所示：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Just like XML-based AOP, you can use various point-cut types (point-cut designators)
    such as `within`, `this`, `target`, `args`, `@annotation`, `@target`, `@within`, and `@args` with
    annotation-style AOP. On top of these, Spring supports an additional point-cut
    type (PCD) called **bean**, which matches the method execution on a particular
    bean or set of beans. It can be declared as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 就像基于 XML 的 AOP 一样，你可以使用各种切点类型（切点设计符），如 `within`、`this`、`target`、`args`、`@annotation`、`@target`、`@within`
    和 `@args`，在注解风格的 AOP 中使用。除此之外，Spring 还支持一个额外的切点类型（PCD）称为 **bean**，它匹配特定 bean 或一组
    bean 上的方法执行。它可以声明如下：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This point-cut is applied to the bean with an ID or name of `batchOperation` defined
    in the application context (XML) file. If a wildcard (only `*` is allowed) is
    used, this point-cut can be applied on multiple beans.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此切点应用于在应用程序上下文（XML）文件中定义的ID或名称为`batchOperation`的bean。如果使用通配符（只允许`*`），则此切点可以应用于多个bean。
- en: 'Just like XML-based configuration, annotation-based AOP also supports combining
    point-cut with `and`, `or`, and `negated` operations. In `@AspectJ`-style AOP,
    you can refer point-cut with its name (signature) while combining with other point-cut,
    or referring them in Aspect declaration in XML schema. Multiple point-cuts can
    be combined as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 就像基于XML的配置一样，基于注解的AOP也支持将切点与`and`、`or`和`negated`操作相结合。在`@AspectJ`风格的AOP中，你可以通过其名称（签名）来引用切点，在与其他切点结合时，或者通过XML模式中的Aspect声明来引用它们。多个切点可以按如下方式组合：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first point-cut, `checkSession`, will be applied on all public methods of
    any class under the` com.packt.spring.aop.report` package. The second point-cut, `printUserName`,
    will be applied on any public method with a single argument of type `String`,
    while the third point-cut, `userSession`, is applicable on all public methods
    that have a single argument of type `String` of any classes under the `com.packt.spring.aop.report` package.
    We have used the name (point-cut signature) of the first and second point-cuts
    to combine them in the third point-cut definition.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个切点`checkSession`将应用于`com.packt.spring.aop.report`包下任何类的所有公共方法。第二个切点`printUserName`将应用于具有单个`String`类型参数的任何公共方法，而第三个切点`userSession`适用于`com.packt.spring.aop.report`包下任何类的所有具有单个`String`类型参数的公共方法。我们在第三个切点定义中使用了第一个和第二个切点的名称（切点签名）来组合它们。
- en: It's common practice to create smaller point-cuts with simple expressions, and
    build complex point-cuts by combining them with `and` , `or`, and `negated` operations. By
    referring to its name, point-cuts are so simple to define, and yet powerful when
    combining with other point-cuts.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 创建具有简单表达式的较小切点是一种常见的做法，并通过将它们与`and`、`or`和`negated`操作相结合来构建复杂切点。通过引用其名称，切点的定义非常简单，但在与其他切点结合时却非常强大。
- en: Since point-cuts are referred by `method` name, the visibility of the Java method
    is applied to point-cuts. For example, **private** point-cuts are used in the
    same type, **protected** point-cuts in the same package, and **public** point-cuts
    can be applied anywhere (that is, can be referred to in other aspect classes in
    different hierarchies). This brings great flexibility when building an enterprise
    application with multiple modules, and when you want to share a set of operations
    between various aspects. You can make public point-cuts in common aspects that
    can be shared with other aspects in different modules.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于切点是按`method`名称引用的，Java方法的可见性应用于切点。例如，**private**切点用于同一类型，**protected**切点用于同一包，而**public**切点可以在任何地方应用（即可以在不同层次结构中的其他Aspect类中引用）。这在构建具有多个模块的企业应用程序时提供了极大的灵活性，当你想在各种Aspect之间共享一组操作时。你可以在公共Aspect中创建公共切点，这些切点可以与其他模块中的Aspect共享。
- en: Declaring Advice
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明通知
- en: 'Declaring Advice with `@AspectJ`-style annotation is similar to XML-based AOP
    configuration. The XML configuration will be replaced by an annotation declaration
    in the aspect class. Just to recall, Advice is an action to be performed on a
    point-cut configured with it. Advice can be declared in the Aspect class as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@AspectJ`风格注解声明通知与基于XML的AOP配置类似。XML配置将被Aspect类中的注解声明所取代。只是为了回顾一下，通知是在配置了它的切点上执行的操作。通知可以在Aspect类中如下声明：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `@Before` annotation is used to declare before advice with the `displayUserName`
    method. The point-cut expression defined within the `@Before` annotation is called
    *in-lined*, because it''s declared in the same place. You can also put a reference
    of the point-cut (declared separately with the `@Pointcut` annotation) within
    the `@Before` annotation as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Before`注解通过`displayUserName`方法声明前置通知。在`@Before`注解内定义的点切点表达式称为*内联的*，因为它是在同一位置声明的。你还可以在`@Before`注解中放置切点的引用（使用`@Pointcut`注解单独声明）如下所示：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is how a point-cut with the `method` signature `checkSession()` is being
    referred to in the `@Before` advice. The previous configuration is equivalent
    to the following XML-based configuration:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在`@Before`通知中引用具有`method`签名`checkSession()`的切点。前面的配置等同于以下基于XML的配置：
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As we have seen, the access modifier of the point-cut signature will decide
    its visibility. You can refer any public point-cut to the advice on a different
    `Aspect` class as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，点切签名（point-cut signature）的访问修饰符将决定其可见性。你可以将任何公共点切（public point-cut）引用到不同`Aspect`类的建议（advice）中，如下所示：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is how you can refer to a public point-cut defined in some other aspect
    class. You need to use a fully-qualified class and put the `method` name with
    a dot in between. We have seen an example of before and after advice types. You
    can define other advice types, such as around advice, after returning advice and
    after throwing advice, similar to the schema-based AOP we have seen in previous
    topics.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何引用在某个其他方面类中定义的公共点切的方法。你需要使用完全限定的类名，并在`method`名之间加上点号。我们已经看到了前置和后置建议类型（before
    and after advice types）的例子。你可以定义其他建议类型，例如环绕建议（around advice）、返回后建议（after returning
    advice）和抛出后建议（after throwing advice），这些与我们在先前主题中看到的基于模式的AOP类似。
- en: Declaring an advisor
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明一个顾问
- en: 'Spring provides another mechanism to define advice and aspect as a single unit.
    It''s called an **advisor**. It''s only available in Spring AOP and not in native
    AspectJ. In this model, you need to define advice as a class that implements one
    of the advice interfaces. An advisor can be defined with the `<aop:advisor>` element
    in the application context (XML) file as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了一种机制来定义建议和方面作为一个单一单元。它被称为**顾问**。它仅在Spring AOP中可用，而不在原生AspectJ中。在这个模型中，你需要定义一个实现建议接口之一的类作为建议。顾问可以使用以下方式在应用程序上下文（XML）文件中的`<aop:advisor>`元素中定义：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You need to define an advisor with the `<aop:advisor>` element within `<aop:config>`.
    You can define a point-cut advisor with the `point-cut-ref` attribute. In the
    previous example, we have defined an in-lined point-cut. If you are following
    annotation-based AOP, you can refer to any public point-cut defined in the aspect
    class as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在`<aop:config>`元素内定义一个顾问（advisor），使用`<aop:advisor>`元素。你可以使用`point-cut-ref`属性定义一个点切顾问。在先前的例子中，我们定义了一个内联点切。如果你遵循基于注解的AOP，你可以按照以下方式引用在方面类（aspect
    class）中定义的任何公共点切：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this example, we are referring to the point-cut with its signature (`checkReportPermission()`)
    defined in the `PermissionCheck` aspect class.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们引用的是在`PermissionCheck`方面类中定义的具有其签名（`checkReportPermission()`）的点切。
- en: 'We also defined a bean with the  `LoggingAdvisor` class, which is an `advisor`
    class, and referred in the `<aop:advisor>` element with the `advice-ref` attribute.
    The `LogginAdvisor` class is defined as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个具有`LoggingAdvisor`类的bean，这是一个顾问类，并在`<aop:advisor>`元素中使用`advice-ref`属性进行引用。`LogginAdvisor`类的定义如下：
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This `advisor` class is implementing the `before` method of the `MethodBeforeAdvise`
    interface. It's equivalent to implementing before advice. Spring AOP provides
    other sets of advice interfaces, such as `MethodInterceptor`, `ThrowsAdvice`,
    and `AfterReturningAdvice`, which are equivalent to implementing around advice,
    after throwing advice, and after returning advice respectively.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个顾问类实现了`MethodBeforeAdvise`接口的`before`方法。它等同于实现前置建议。Spring AOP提供了其他一系列的建议接口，如`MethodInterceptor`、`ThrowsAdvice`和`AfterReturningAdvice`，分别对应实现环绕建议、抛出后建议和返回后建议。
- en: Choosing AOP frameworks and style of configuration
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择AOP框架和配置风格
- en: 'Once you conclude that you will go ahead with the Aspect programming model
    to achieve or implement your requirements, this question comes into the picture:
    should you choose Spring AOP or the full-fledged AspectJ framework ?'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定将使用方面编程模型来实现或实现你的需求，这个问题就会出现：你应该选择Spring AOP还是完整的AspectJ框架？
- en: After choosing the framework, the question of selecting the style of configuration
    would come up next. For example, in the case of the AspectJ framework, will you
    choose AspectJ code style or `@AspectJ` annotation style? Similarly, in the case
    of Spring AOP, will you select a Spring XML file or an `@AspectJ`-based annotation
    style to define various artifacts such as aspects, point-cuts, advice, and advisors?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择框架之后，接下来会面临选择配置风格的问题。例如，在AspectJ框架的情况下，你会选择AspectJ代码风格还是`@AspectJ`注解风格？同样，在Spring
    AOP的情况下，你会选择Spring XML文件还是基于`@AspectJ`的注解风格来定义各种工件，如方面（aspects）、点切（point-cuts）、建议（advice）和顾问（advisors）？
- en: Choosing the right framework with the specific style for defining the configuration
    depends on many factors, such as project requirements, availability of development
    tools, team expertise, compatibility of your existing system code with the AOP
    framework, how quickly you want to implement AOP, and performance overhead.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 根据特定的风格选择合适的框架来定义配置取决于许多因素，例如项目需求、开发工具的可用性、团队的专业知识、现有系统代码与 AOP 框架的兼容性、你希望多快实现
    AOP，以及性能开销。
- en: Spring AOP versus AspectJ language
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring AOP 与 AspectJ 语言
- en: In this chapter, we mainly looked at Spring AOP. AspectJ is another solution
    to implement AOP; however, Spring AOP is simpler than AspectJ because it doesn't
    require you to introduce an AspectJ compiler or weaver into your development and
    build process.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们主要探讨了 Spring AOP。AspectJ 是实现 AOP 的另一种解决方案；然而，Spring AOP 比 AspectJ 更简单，因为它不需要你在开发和构建过程中引入
    AspectJ 编译器或编织器。
- en: Spring AOP has been introduced to provide a simple AOP implementation throughout the
    IoC container to solve generic problems, while AspectJ is a full featured AOP
    framework. AspectJ is powerful in nature, but more complex than Spring AOP. AspectJ
    supports compile-time, post-compile-time, and runtime weaving, while Spring AOP
    only supports runtime weaving through a proxy.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP 的引入是为了在整个 IoC 容器中提供一个简单的 AOP 实现，以解决通用问题，而 AspectJ 是一个功能齐全的 AOP 框架。AspectJ
    本质上很强大，但比 Spring AOP 更复杂。AspectJ 支持编译时、编译后和运行时编织，而 Spring AOP 只通过代理支持运行时编织。
- en: If your business needs advice on the set of operations of the Spring bean project,
    Spring AOP is the right choice for you. If you come across a requirement where
    you need to intercept and implement advice on objects not managed by the Spring
    container, you should go with the AspectJ programming framework.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的业务需要在 Spring bean 项目的操作集上提供建议，Spring AOP 是你的正确选择。如果你遇到需要拦截并实现非由 Spring 容器管理的对象上的建议的需求，你应该选择
    AspectJ 编程框架。
- en: Spring AOP supports method-level join-points only. If you need any advice on
    join-points other than methods (such as field, setter, or getter methods), you
    should consider AspectJ. Another point you should consider while choosing from
    these frameworks is performance. Spring AOP uses a proxy, so there should be little
    runtime overhead. Compared to Spring AOP, there is less overhead while working
    with AspectJ.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP 只支持方法级别的连接点。如果你需要在除了方法之外的其他连接点（如字段、setter 或 getter 方法）上提供任何建议，你应该考虑
    AspectJ。在选择这些框架时，你应该考虑的另一个点是性能。Spring AOP 使用代理，因此应该几乎没有运行时开销。与 Spring AOP 相比，使用
    AspectJ 时开销更小。
- en: XML versus @AspectJ-style annotation for Spring AOP
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring AOP 的 XML 与 @AspectJ-style 注解
- en: 'When there is more than one option to choose from, it''s always a dilemma,
    and that is the case here. Which option should you choose while using Spring AOP:
    XML-based or annotation-based? Each of these styles has benefits and limitations.
    You should consider them both before choosing the right one for your needs.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当有多个选项可供选择时，总是一个困境，这里也是如此。在使用 Spring AOP 时，你应该选择哪种选项：基于 XML 还是基于注解？每种风格都有其优点和局限性。在选择适合你需求的正确选项之前，你应该考虑它们两个。
- en: The XML style is very well-known and has been widely used since the evolution
    of the Spring Framework. Almost all Spring developers are handy with it. Choosing
    the XML style means all your configurations are in one central place. This will
    help to identify how many artifacts (aspects, point-cuts, and sets of advice)
    are defined in the system in a cleaner way. This will be a benefit in the alteration
    of the configuration (for example, changing the expression of a point-cut) independently.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: XML 风格非常知名，自从 Spring 框架的演变以来就被广泛使用。几乎所有的 Spring 开发者都熟悉它。选择 XML 风格意味着所有的配置都在一个中心位置。这将有助于以更清晰的方式识别系统中定义了多少工件（方面、切入点、和一系列建议）。这将有助于独立地更改配置（例如，更改切入点的表达式）。
- en: On the other hand, with the XML style, a piece of information is split across
    different places. The configuration is done in XML, while the actual implementation
    is defined in the respective bean classes. While using @AspectJ-style annotation,
    there will be just a single module, Aspect, which declares that all the artifacts,
    such as point-cuts, advice, and so on, are well encapsulated.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用 XML 风格时，信息会被分散在不同的地方。配置是在 XML 中完成的，而实际的实现是在相应的 bean 类中定义的。当使用 @AspectJ-style
    注解时，将只有一个模块，即 Aspect，它声明所有工件，如切入点、建议等，都被很好地封装。
- en: 'There are other limitations to XML-based AOP, for example, a bean declared
    as an Aspect would be a singleton only. Also, you can''t refer to the point-cut
    by its signature (name) while combining with other point-cuts. To take an example,
    a point-cut declaration with an annotation is as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 基于XML的AOP还有其他限制，例如，声明为方面的Bean将仅是单例。此外，在与其他切入点结合时，您不能通过其签名（名称）引用切入点。例如，以下是一个使用注解的切入点声明：
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The point-cut signatures (names) of `checkSession` and `printUserName` are used
    to combine them and form a new expression, `userSession`. The downside of XML-based
    configuration is that you can't combine point-cut expressions like this.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkSession`和`printUserName`的切入点签名（名称）被用来将它们组合并形成一个新的表达式，即`userSession`。基于XML的配置的缺点是您不能像这样组合切入点表达式。'
- en: On top of these facts, Spring AOP allows you to mix XML schema-based configuration
    with @AspectJ-style annotation declaration. For example, you can define a point-cut
    and an aspect with annotation, and declare the set of advice (interceptors) in
    XML-based configuration. They all can coexist without any issues.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些事实的基础上，Spring AOP允许您将基于XML的配置与@AspectJ风格的注解声明混合使用。例如，您可以使用注解定义切入点和一个方面，并在基于XML的配置中声明建议（拦截器）集合。它们都可以共存而不会出现任何问题。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned one of the important ways to achieve separation
    of concerns called AOP. Conceptually, we are removing the dependency of cross-cutting
    concerns from business code and applying them with plug-and -play fashion and
    in a more controlled way with AOP. It solves the design problem that we never
    could resolve with the traditional AOP model.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了实现关注点分离的重要方法之一，即AOP。从概念上讲，我们正在消除业务代码中横切关注点的依赖，并以即插即用的方式以及更受控的方式通过AOP应用它们。它解决了我们从未能够用传统AOP模型解决的问题。
- en: We understood the need of AOP by taking an example where we need to keep changing
    business code when common functionality is changed. We have also seen various
    terminologies used in AOP, which is very crucial to understanding underlying concepts.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个示例，我们理解了AOP的需求，即当通用功能发生变化时，我们需要不断更改业务代码。我们还看到了在AOP中使用的各种术语，这对于理解底层概念至关重要。
- en: Soon after learning the theory of AOP, we started our journey with Spring AOP
    to understand the practical concepts. First, we learned to define AOP configuration
    in an XML file, followed by declaring various artifacts such as aspect, point-cut,
    and advice. Details about point-cut expressions and advice types were shown with
    various examples and code samples.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习AOP理论不久后，我们开始了Spring AOP的旅程，以理解其实际概念。首先，我们学习了如何在XML文件中定义AOP配置，随后声明了各种工件，如方面、切入点和建议。通过各种示例和代码示例展示了切入点表达式和建议类型。
- en: 'Next, we learned how to define Spring AOP configuration with the `@AspectJ`
    annotation style, followed by declaring aspects, advice, and point-cuts with annotation.
    We also learned how to define an advisor by implementing various interfaces. Lastly,
    we saw the benefits and limitations of Spring AOP and the AspectJ framework, followed
    by how to choose the configuration style for Spring AOP: XML or annotation.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们学习了如何使用`@AspectJ`注解风格定义Spring AOP配置，随后通过注解声明方面、建议和切入点。我们还学习了如何通过实现各种接口来定义顾问。最后，我们看到了Spring
    AOP和AspectJ框架的优缺点，以及如何选择Spring AOP的配置风格：XML或注解。
- en: We will move on to learn various design patterns that you can use to achieve
    IoC, and what the best practices, patterns, and anti-patterns are while working
    with dependency injection in the next chapter.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续学习各种设计模式，这些模式可以帮助您实现IoC，以及在使用依赖注入时最佳实践、模式和反模式。
