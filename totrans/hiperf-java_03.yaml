- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimizing Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loops are fundamental programming constructs that are not terribly difficult
    to understand or write. We use them to iterate through our application’s data
    structures and perform repetitive tasks. We often take loops for granted based
    on their simple syntax and readability. When performance is a concern, loops have
    a duality. On one side, loops serve as a fundamental construct for efficient data
    processing. On the other side, poorly optimized loops can introduce significant
    bottlenecks and degrade the overall performance of our Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Concepts covered in this chapter include loop overhead, loop unrolling, benchmarks,
    loop fusion, loop parallelization, and loop vectorization. We will use code examples
    to provide insights and demonstrate best practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Types of loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing loops for performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter explores techniques, strategies, and best practices to help you
    get the best performance out of your loops and to prevent the unintentional introduction
    of substantial bottlenecks that undermine runtime performance.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples and instructions in this chapter, you will need the ability
    to load, edit, and run Java code. If you have not set up your development environment,
    please refer back to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014).
  prefs: []
  type: TYPE_NORMAL
- en: 'The finished code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter03](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter03)'
  prefs: []
  type: TYPE_NORMAL
- en: Types of loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loops are indispensable constructs for iterating through data structures, controlling
    the flow of code, and performing repetitive tasks. They are central to many algorithms
    and applications. While loops can be used to efficiently process data and perform
    repetitive tasks, they can be equally problematic when we are concerned with performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to understand different types of loops, their characteristics,
    and their performance implications. This section explores different loop types
    in Java, which include `for`, `while`, `do`-`while`, and `for`-`each`. Our goal
    is to understand each loop type’s purpose and impact on code readability and efficiency.
    Specifically, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A loop’s impact on performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loop optimization basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loop unrolling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being armed with a deeper understanding of loop types can equip you to make
    the right loop selection for a given requirement.
  prefs: []
  type: TYPE_NORMAL
- en: A loop’s impact on performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to understand a loop’s impact on performance, we must have a firm understanding
    of the different types of loops. This section provides information on each loop
    type to include use cases and advantages. Examples are used to provide implementation
    details.
  prefs: []
  type: TYPE_NORMAL
- en: for loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`for` loops are the most basic loop type. They have a concise syntax with well-defined
    loop control. They are the unofficial default for iterating through a set of items.
    Let’s look at the following components of these loops: initialization, condition,
    iteration, and efficiency.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for a `for` loop is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Dissecting the preceding syntax, we can identify `int i =0;` as the `i` and
    it is set to `0`. The `i < 5;` `i` is less than `5`. If the evaluation returns
    `true`, then the loop continues; otherwise, it ends. The final component is the
    `i++` to increase the **control variable** by 1 at the end of each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: There are some performance-related issues with a `for` loop. When we initialize
    our loop, we should avoid initializing variables outside of the loop as it can
    sometimes degrade performance with redundant initializations within the loop.
    The **condition expression** directly impacts the number of iterations the loop
    will perform. Making this expression overly complex can slow down the loop. Lastly,
    the **iteration expression** should be properly designed to help prevent an infinite
    loop and inefficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an inefficient example and then a second example with performance
    improvements. The following example counts how many corgis have names with the
    letter “`e`”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code has two inefficiencies:'
  prefs: []
  type: TYPE_NORMAL
- en: The loop condition is checked using the `length()` method in each iteration.
    This means that, for each corgi in the array, the length of the array is accessed,
    which can lead to unnecessary performance overhead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our code snippet uses `corgis[i].getName().contains("e")` to check if the corgi’s
    name contains the letter “`e`.” So, for each corgi name, we are creating a new
    string and performing a string search. This will most assuredly be computationally
    expensive, especially with long names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these inefficiencies in mind, let’s look at a revised section of that
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet is an improved version that has the following performance
    enhancements:'
  prefs: []
  type: TYPE_NORMAL
- en: We cached the array’s length by storing it in the `corgislength` variable. Since
    we populate that variable outside of the loop, we avoid repeated access to the
    array’s length during each iteration. This can save tremendously on computational
    effort.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of using the `contains()` method to check the names, we use the `indexof()`
    method. There is a significant difference here. When we use the `contains()` method,
    a new substring is created and a full search is conducted. Using the `indexof()`
    method returns the index position of the first occurrence of “`e`” or -1 if it
    is not found. This is a much more efficient way to check for a character’s existence
    in a string without creating unnecessary substrings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With our exploration of `for` loops completed, let us look at how to use `while`
    loops in an efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: while loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`while` loops are perhaps the second most common loop used in Java. They are
    fundamental flow control constructs that we can use to repeatedly execute a block
    of code, as long as a specified condition remains `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for a `while` loop is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These loops do not require initialization, but when initialization is employed,
    care should be taken to ensure they are correct so as to prevent unintended application
    behavior such as an infinite loop. When the `true`, the body of the loop is executed.
    The loop terminates when the `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Condition expressions
  prefs: []
  type: TYPE_NORMAL
- en: We should strive to create straightforward condition expressions for loop efficiency.
    Overly complex condition expressions can increase processing overhead, resulting
    in poor performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an inefficient example and then a second example with performance
    improvements. The following example is of an online ordering system. We want to
    check each order ID to determine if it starts with the “`OL`” prefix. If it does
    not, it should be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are two inefficiencies in the preceding code snippet. First, the list
    size is repeatedly accessed; it is checked during each iteration. This can lead
    to unnecessary performance overhead. Secondly, the string concatenation, using
    the `+` operator, creates a new string, which can be inefficient when repeatedly
    performed within a loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is a modified version of the online ordering system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding updated code snippet stands to improve system performance due
    to two factors. First, the list size is now cached, and second, we are using a
    more efficient string modification approach. Here, we are modifying the strings
    without creating new string objects.
  prefs: []
  type: TYPE_NORMAL
- en: With our exploration of `while` loops completed, let us look at how to use `do`-`while`
    loops in an efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: do-while loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`do`-`while` loops, as with the ones previously covered, are flow control structures
    that allow for the repeated execution of a code block while a specified condition
    remains `true`. The unique nature of this type of loop is that the condition is
    checked after the loop’s code block is executed. This ensures that the loop’s
    block of code is executed at least once.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a simple `do`-`while` loop for a guessing game
    where the user continues to guess a number until they guess correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code snippet, we use a Boolean flag to control
    our loop. The flag is checked during each iteration. This approach is inefficient
    in that it adds unnecessary complexity and an extra variable. Let’s modify the
    code so that it is more efficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With our updated example, we use `userGuess != secretNumber` as the loop condition,
    negating the need for a Boolean flag. This both simplifies our code and can make
    our code more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: for-each loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We introduced the `for`-`each` loop in [*Chapter 2*](B21942_02.xhtml#_idTextAnchor028)
    and noted that this type of loop is also referred to as an enhanced `for` loop.
    We choose to implement this type of loop when we want to iterate over all elements
    in a dataset, without having to manage an iterator or index. Let’s look at an
    initial example and then refine it for better performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is an automotive parts processing application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The inefficiency in the preceding code stems from the sequential processing
    of each automotive part within the loop. This can be a time-consuming operation
    and lead to poor performance. Let’s look at an improved version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this improved version, we implement a `processAutoParts()` method that takes
    the entire parts list as a parameter. This permits batch processing of parts,
    which can significantly improve overall performance.
  prefs: []
  type: TYPE_NORMAL
- en: With our exploration of loop types completed, let us now review loop optimization
    basics.
  prefs: []
  type: TYPE_NORMAL
- en: Loop optimization basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we strive to ensure our Java applications are high-performing, we rightly
    focus on loop optimizations. Loops are equally ubiquitous in Java programming,
    making their inefficiencies especially problematic. Loop efficiency can vary significantly
    based on implementation and use. This section examines fundamental aspects of
    loop optimization, with the aim of equipping you with the knowledge and tools
    to boost the performance of your Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Loop overhead
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Loop overhead refers to the additional computational costs associated with the
    initialization, implementation, and termination of a loop. While loops are essential
    for achieving various programming tasks, they are not free from computational
    overhead. Understanding loop overhead is crucial because excessive overhead can
    degrade the overall performance of your Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: The three main components of loop overhead are loop initialization, condition
    evaluation, and iteration. As previously illustrated, each type of loop can result
    in inefficiencies with one or more of these components. Fortunately, there are
    strategies we can adopt to help minimize loop overhead. First, we can optimize
    loop initialization. This can be done by initializing our control variables outside
    of the loop. The performance gained is due to avoiding redundant assignments within
    the loop. We can also minimize the number of variables declared within the loop.
  prefs: []
  type: TYPE_NORMAL
- en: A second strategy is to use simple and efficient condition expressions. We want
    to avoid complex conditions within loops. If our loop’s condition is dependent
    on a dataset’s length, that length should be cached outside of the loop to prevent
    repeated access.
  prefs: []
  type: TYPE_NORMAL
- en: Thirdly, we can streamline our iteration. To adopt this strategy, we should
    ensure the iteration is designed to update loop control variables correctly and
    efficiently. We also should use the appropriate expression increments/decrements
    in an efficient and correct manner. Lastly, we should consider alternative loop
    types for each set of requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Bottlenecks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unoptimized loops can result in bottlenecks in the performance of our Java
    applications. Understanding the cause of these bottlenecks is a necessary first
    step to avoiding them. As previously covered in this chapter, the following are
    common performance bottlenecks associated with loops in Java programming:'
  prefs: []
  type: TYPE_NORMAL
- en: Inefficient condition expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inefficient iteration steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unnecessary computations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suboptimal data access patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Excessive memory allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We should strive to implement optimization strategies specific to each loop
    type, as detailed in the preceding sections. General loop optimization strategies
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Profile our loops to identify performance bottlenecks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid premature optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose appropriate data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose appropriate algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, as you will learn later in this chapter, profiling tools and methodologies
    can be used to help us determine where bottlenecks are within our loops.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Optimizing loops beyond the basic strategies covered in this chapter requires
    a firm understanding of how they perform, their characteristics, and the ability
    to measure optimizations for performance. We accomplish this measurement through
    benchmarking. Our goal is to assess the effectiveness of our loop optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: We should establish a benchmarking environment so that we can evaluate loop
    performance. This requires us to set up a consistent environment that facilitates
    accurate measurements and comparative analysis. Each optimization can be tested
    against the benchmark to determine if it increased or degraded application performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To establish a benchmarking environment, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose a benchmarking framework or library that provides tools for measuring
    the performance of our Java code. We will take a specific look at the **Java Microbenchmarking
    Harness** (**JMH**) tool in [*Chapter 13*](B21942_13.xhtml#_idTextAnchor227).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure your development environment is properly configured and up to date.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write benchmarking classes that include the loops we want to benchmark.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify settings and parameters for our benchmarks. This can include measurement
    time, number of iterations, and warm-up iterations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the variables involved are consistent across all tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conduct warm-up runs to account for any JVM-specific warm-up effects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measure execution times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Analyze results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat and validate multiple times to ensure the validity of your findings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interpret your results and optimize.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Document your results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By following these steps for establishing a benchmarking environment, you can
    make informed decisions about your loop optimizations, identify performance bottlenecks,
    and fine-tune your Java applications to achieve higher performance.
  prefs: []
  type: TYPE_NORMAL
- en: Loop unrolling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Loop unrolling is an advanced optimization strategy. It is an optimization technique
    we can employ in Java to improve our loops. The approach involves replicating,
    or unrolling, the loop’s code block multiple times, to reduce the number of required
    iterations. More specifically, instead of executing our loop’s code block once
    per iteration, we expand the loop to execute the code block multiple times within
    a single iteration. While this may seem complex, it can reduce the loop overhead
    caused by condition checks and updating variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of loop unrolling include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reduced loop overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved CPU instruction cache usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhanced compiler optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opportunities for parallelism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two types of loop unrolling: manual and automatic. Let’s look at
    an example of each. This first example is of manual loop unrolling. Here, we must
    explicitly rewrite our loop code to unroll it. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The manual loop unrolling provides us with finite control over the unrolling
    process, but, because it is done manually, it is exceedingly difficult to maintain
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'With automatic loop unrolling, we can leverage compiler optimization tools
    to automatically unroll our loop code. The compiler will reference compiler flags
    that we specify. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Compiler flags
  prefs: []
  type: TYPE_NORMAL
- en: In Java, compiler flags are used to specify non-default settings or options
    at compile time. We pass flags (for example, `-O`, to enable optimization during
    compilation) to the `javac` compiler command.
  prefs: []
  type: TYPE_NORMAL
- en: Using automatic unrolling can simplify the optimization process and save us
    time. The disadvantage to this approach is that the unrolling results might not
    be the most efficient. As the complexity of our loops increases, the efficiency
    of the automatic unrolling results decreases.
  prefs: []
  type: TYPE_NORMAL
- en: It is considered a best practice to use loop unrolling when we have a known
    and fixed number of iterations. Also, if loop overhead is not a significant concern,
    then loop unrolling may not be necessary. A side effect of manual unrolling may
    be increased memory usage. Whenever unrolling loops, we should profile and measure
    optimizations on performance.
  prefs: []
  type: TYPE_NORMAL
- en: There are limitations of loop unrolling. First, not every loop is ideal for
    unrolling, such as when the dataset size is variable or dynamic. Another limitation
    or disadvantage of unrolling is that it can result in bloated code, increasing
    the binary size, which, in turn, can result in instruction cache mistakes. Lastly,
    automatically unrolling may not always produce the desired loop optimization.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a comprehensive understanding of loop types in Java, including
    their strengths and weaknesses and their ideal use cases. Your loop selection
    decisions can now be more informed and help ensure you are creating code that
    is performant and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Testing loops for performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a firm grasp of the different types of loops and their advantages
    and disadvantages, we should feel empowered to make the best loop selections.
    Furthermore, we should be able to implement optimization strategies. But how do
    we know if our loop optimization strategies result in better or worse performance?
    That is where testing comes into play and is the focus of this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will cover the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Profiling tools and methodology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarking and testing strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case studies and examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our goal is to obtain the knowledge and practical skills needed to evaluate,
    optimize, and harness the full potential of loops within our Java applications.
    Moreover, we want to have a testing strategy that will inform us of the efficacy
    of our optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling tools and methodology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is not enough to write optimized loops in our Java applications. We should
    have a clear understanding of profiling tools and methodologies. In our context,
    profiling is the practice of analyzing the execution of our loops to gain insights
    into their performance characteristics. We can glean crucial information on how
    much CPU time our loops demand.
  prefs: []
  type: TYPE_NORMAL
- en: Why profiling is important
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Profiling is considered a diagnostic tool used by developers who are concerned
    with the performance of their Java applications. Profiling is applicable to all
    sections of our code, and, in this section, our focus is on loops. We use profiling
    tools to get deep insights into the behavior of our code at runtime. Here are
    some insights we can gain from profiling:'
  prefs: []
  type: TYPE_NORMAL
- en: How much CPU time do our loops consume?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are memory leaks present?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does our code result in excessive memory allocation?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do our loops interact with the CPU cache?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do our loops interact with memory?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can write our loops in different ways and use profiling to help inform us
    of which method is the best from an overall runtime performance perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three basic profiling types: CPU, memory, and thread. In **CPU profiling**,
    the focus is on how our code uses the CPU. This profiling type is especially useful
    for identifying CPU bottlenecks created by our loops.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory profiling** gives us insights into memory-related issues. These can
    include excessive memory consumption, memory leaks, and excessive or inefficient
    object creation. This is one of the most useful profiling types when our focus
    is on loop optimization.'
  prefs: []
  type: TYPE_NORMAL
- en: The **thread profiling** type is useful in identifying synchronization issues
    that can affect the performance of our loops.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Profiling tools are software applications that help automate profiling options
    for us. There are a plethora of tools available to Java developers, many of which
    are open source and free to use. These tools can be organized into three categories:
    those that come bundled with the JDK, those that come bundled with an **integrated
    development environment** (**IDE**), and commercial or third-party tools.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at two examples of profiling tools that come bundled with the JDK.
    First, **Java Flight Recorder** (**JFR**) is a built-in tool that can record and
    analyze application behavior. This tool is lauded for its low processing overhead.
    **VisualVM** is another profiling tool that comes bundled with the JDK. It provides
    great insights into CPU usage and memory usage, as well as thread activity.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling methodologies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A profiling methodology is essentially your approach to profiling. This is more
    than simply selecting a profiler to use. In fact, you often will want to use more
    than one tool as part of your methodology. When asked what your profiling methodology
    is, consider what your overall approach is.
  prefs: []
  type: TYPE_NORMAL
- en: You might employ a **sampling profiling** methodology where you periodically
    pull data on your application’s execution. This sampling approach provides a quick
    view of code execution behavior and can provide insights into what might need
    deeper profiling.
  prefs: []
  type: TYPE_NORMAL
- en: Another common profiling methodology is **instrumentation profiling**. This
    approach requires us to add profiling code to our application. While this approach
    can provide the greatest level of fidelity regarding code execution behavior,
    it also commands the most CPU overhead.
  prefs: []
  type: TYPE_NORMAL
- en: A third popular profiling methodology is **continuous profiling**. This approach
    collects a lot of data over long periods of an application running. Developers
    who employ this methodology can gain insights into long-term trends and more easily
    detect performance anomalies.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying hotspots in our loops
  prefs: []
  type: TYPE_NORMAL
- en: In the context of Java loops, a hotspot is a loop that consumes excessive CPU
    time or memory at runtime. It is imperative that we pinpoint these hotspots in
    our loops so that we can optimize them.
  prefs: []
  type: TYPE_NORMAL
- en: As a final note on profiling, we should realize that identifying a **hotspot**
    is just one step, and using a profiling tool is another. We need to address the
    issues we uncover and then reapply profiling tools to ensure our changes have
    the desired impact. Developers should have a continuous improvement mindset over
    their loops and other code. This requires the continual monitoring and profiling
    of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking and testing strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have accepted that optimizing loops is a critical part of ensuring our Java
    applications perform at a high level. This high performance requires benchmarking
    and testing strategies. This section looks at both types of strategies and shares
    best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking strategies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JMH is the most common toolkit used for conducting performance testing of Java
    code. It does a wonderful job of handling finite components of Java performance
    testing. As the name suggests, it is designed specifically to test Java code and
    is widely used in micro-level performance testing. Some features of JMH are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: It measures the performance characteristics of microbenchmarks (code segments).
    It is especially handy for loop performance testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JMH supports measurements of average time, sample time, single-shot time, and
    throughput. This gives developers great flexibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With JMH, developers have finite control of the testing environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be integrated with build tools (for example, Maven).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides detailed microbenchmarking results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regardless of which benchmarking tool we use, it is important to first establish
    a baseline. We can accomplish this by running our tools on unoptimized code. Once
    we have the results of that test, we have our baseline. Testing optimized code
    can be evaluated against the baseline.
  prefs: []
  type: TYPE_NORMAL
- en: Testing strategies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are three primary testing strategies. The first is unit testing. This
    strategy can help us ensure that any changes we make to our loops do not impact
    the expected code behavior. Unit testing can also help us test our loops with
    edge cases such as with extreme values.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling and hotspot analysis is another testing strategy that has already
    been covered in this chapter. As a reminder, we use profiler tools such as JFR
    or VisualVM to help us analyze CPU and memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we can use regression testing to test our loops after we make changes
    to the application. This can help ensure that our changes do not negatively impact
    any other functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of our testing strategy, we should approach loop optimization testing
    in an iterative manner. This means we should make small, incremental changes to
    our loops, testing after each change.
  prefs: []
  type: TYPE_NORMAL
- en: Case studies and examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section covers practical case studies and examples of optimizing loops
    in Java. It can be powerful to review real-world scenarios as we stand to gain
    great insights into common challenges and best practices for solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Case studies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider a case study in which we need to process a large dataset and aggregate
    data based on a business requirement. Our challenge, in this scenario, is that
    our aggregation loop is very slow. Since we have a large dataset, we want to solve
    for the slow loop. What can we do? We can ensure we are using an `ArrayList` instead
    of a `LinkedList`. We can also use Java’s **Stream API** to implement parallel
    processing. This should make better use of multi-core CPUs. We can also minimize
    object creation within the loop. Given this scenario and the suggested solutions,
    we are likely to significantly reduce the aggregation loop operation time as well
    as the complexity of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at another case study. This one features a banking application that
    calculates investment risk metrics over large datasets. The challenge, in this
    scenario, is that our main calculation loop is inefficient. We might take a three-pronged
    optimization strategy. First, we will examine our algorithm and see if it can
    be improved. Next, we will write our code so that it supports **Just-In-Time**
    (**JIT**) compilation. Lastly, we will look at our data structures and make any
    necessary changes to minimize memory access issues. This three-pronged approach
    can result in a significantly more performant application.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s look at two real-world applications of loop testing and optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Our first example is data processing for healthcare analytics. The challenge
    is that processing large groups of patient data for analytical reports is slow.
    The solution is to implement multithreading and batch processing within our loops
    so that we can process data in parallel chunks. The result of this approach should
    be a significant reduction in data processing time.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is inventory management as part of an e-commerce Java application.
    The challenge is to optimize the loop in our code that processes inventory updates.
    For this scenario, we will assume that the loop is slower than it has been in
    the past, most likely due to an ever-increasing inventory dataset. The solution
    would likely be to use efficient data structures and change our loop structure
    as appropriate. The result of this approach should be faster inventory processing
    and greater response times.
  prefs: []
  type: TYPE_NORMAL
- en: This section covered profiling tools, profiling methodologies, benchmarking,
    testing strategies, case studies, and examples. We can now confidently evaluate,
    optimize, and harness the full potential of loops within our Java applications,
    leading to high runtime performance.
  prefs: []
  type: TYPE_NORMAL
- en: Nested loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we’ll cover the fundamental concepts, practical optimization strategies,
    and technical intricacies involved in effectively optimizing nested loops in Java
    applications. We will tackle the concept of nested loops, as they relate to high-performance
    Java applications, in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to nested loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loop fusion in nested loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallelizing nested loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested loop vectorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to understand when to use nested loops and, when we do, how
    to implement them in the most optimal method.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to nested loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A nested loop is when one loop is located inside another. This creates a complex
    iteration scenario. Here is the syntax for a simple nested loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding syntax, the outer loop runs 10 times, and for
    each iteration, the inner loop also runs three times. This results in a total
    of 10 x 10 = 100 iterations.
  prefs: []
  type: TYPE_NORMAL
- en: We can implement a finite number of levels in our nested loops. With each inner
    loop, our code becomes more complex, more difficult to read, and more frustrating
    to maintain. So, when would we use nested loops? One common implementation is
    when processing multi-dimensional arrays such as matrices. They are also used
    when performing operations on tables.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when implementing nested loops. They can very quickly become inefficient
    and make your application sluggish and non-responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Loop fusion in nested loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we must implement nested loops in our Java applications, we should consider
    applying loop fusion to them for efficiency. Loop fusion is essentially an algorithmic
    approach where we combine adjacent loops, ones that perform operations on the
    same dataset, into a single loop.
  prefs: []
  type: TYPE_NORMAL
- en: We can also attempt to reduce redundant calculations and improve cache utilization.
    This is possible when we merge loops because it stands to minimize redundancy,
    thereby improving the use of cache. The technique involves reusing data that is
    loaded into the cache during the same iteration. The outcome is generally fewer
    cache misses.
  prefs: []
  type: TYPE_NORMAL
- en: Loop fusion can also prove beneficial when using complex algorithms such as
    matrix multiplication. There is a potential side effect, namely increased loop
    complexity. This greater complexity results in decreased code readability and
    makes the code more difficult to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Parallelizing nested loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To parallelize nested loops in Java, we need to restructure our loops so they
    can execute concurrently across multiple CPU cores instead of on a single core.
    As you would expect, this is a component of parallel computing, which can result
    in significantly increased runtime performance. Strategies for parallelizing nested
    loops include chunking our dataset and processing each chunk in a separate thread.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of multithreading is often discussed along with parallel streams
    in the context of nested loops. Comparing the two, we can learn that multithreading
    offers additional control but requires us to explicitly manage threads and tasks.
    Parallel streams, which are part of Java’s **Stream API**, provide us with an
    easier method to parallelize operations, but with less control over the threading
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, when parallelizing, we must handle synchronization and thread safety.
    Synchronization becomes key as does ensuring thread safety. This is especially
    true when we deal with shared data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Nested loop vectorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may recall from [*Chapter 2*](B21942_02.xhtml#_idTextAnchor028) of this
    book that vectorization refers to the process of executing a single instruction
    simultaneously on multiple data points. We can leverage vectorization for nested
    loops to significantly increase computational speed, especially when dealing with
    complex data manipulations such as a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Instruction, Multiple Data** (**SIMD**) can be an important concept
    in nested loop optimization. SIMD is a key concept in vectorization where, as
    the name suggests, a single operation is performed on multiple data elements.
    This is an especially effective technique with repetitive nested loops. The efficacy
    of vectorization depends on compiler optimizations and hardware support. Not all
    CPUs have SIMD capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: This section provided a structured overview of nested loop optimization with
    the goal of increasing Java application performance. Fundamental concepts were
    covered, as were practical optimization strategies, and some technical intricacies
    involved in effectively optimizing nested loops in Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on loops, fundamental programming constructs, and how to
    get the most out of them from a runtime performance perspective. Concepts covered
    included loop overhead, loop unrolling, benchmarks, loop fusion, loop parallelization,
    and loop vectorization. We used code examples to provide insights and demonstrate
    best practices.
  prefs: []
  type: TYPE_NORMAL
- en: We explored techniques, strategies, and best practices to help you get the best
    performance out of your loops and to prevent the unintentional introduction of
    substantial bottlenecks that undermine runtime performance.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter takes a specific look at Java object pooling, which is a design
    pattern used to manage reusable objects to conserve resources and improve application
    performance.
  prefs: []
  type: TYPE_NORMAL
