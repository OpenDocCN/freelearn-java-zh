- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Optimizing Loops
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化循环
- en: Loops are fundamental programming constructs that are not terribly difficult
    to understand or write. We use them to iterate through our application’s data
    structures and perform repetitive tasks. We often take loops for granted based
    on their simple syntax and readability. When performance is a concern, loops have
    a duality. On one side, loops serve as a fundamental construct for efficient data
    processing. On the other side, poorly optimized loops can introduce significant
    bottlenecks and degrade the overall performance of our Java applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 循环是基本编程结构，理解或编写它们并不特别困难。我们使用它们来遍历应用程序的数据结构并执行重复性任务。由于它们的简单语法和可读性，我们经常将循环视为理所当然。当性能成为关注点时，循环具有双重性。一方面，循环作为高效数据处理的基本结构。另一方面，未优化的循环可能会引入显著的瓶颈，并降低我们的Java应用程序的整体性能。
- en: Concepts covered in this chapter include loop overhead, loop unrolling, benchmarks,
    loop fusion, loop parallelization, and loop vectorization. We will use code examples
    to provide insights and demonstrate best practices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及的概念包括循环开销、循环展开、基准测试、循环融合、循环并行化和循环向量化。我们将使用代码示例来提供见解并展示最佳实践。
- en: 'This chapter covers the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Types of loops
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环类型
- en: Testing loops for performance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试循环的性能
- en: Nested loops
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套循环
- en: This chapter explores techniques, strategies, and best practices to help you
    get the best performance out of your loops and to prevent the unintentional introduction
    of substantial bottlenecks that undermine runtime performance.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了技术、策略和最佳实践，以帮助您从循环中获得最佳性能，并防止无意中引入会削弱运行时性能的严重瓶颈。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the examples and instructions in this chapter, you will need the ability
    to load, edit, and run Java code. If you have not set up your development environment,
    please refer back to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的示例和说明，您需要能够加载、编辑和运行Java代码。如果您尚未设置开发环境，请参阅[*第1章*](B21942_01.xhtml#_idTextAnchor014)。
- en: 'The finished code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter03](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter03)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可以在以下位置找到：[https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter03](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter03)
- en: Types of loops
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环类型
- en: Loops are indispensable constructs for iterating through data structures, controlling
    the flow of code, and performing repetitive tasks. They are central to many algorithms
    and applications. While loops can be used to efficiently process data and perform
    repetitive tasks, they can be equally problematic when we are concerned with performance.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 循环是遍历数据结构、控制代码流程和执行重复性任务不可或缺的结构。它们是许多算法和应用的核心。虽然循环可以用来高效地处理数据和执行重复性任务，但当我们关注性能时，它们也可能同样有问题。
- en: 'It is important to understand different types of loops, their characteristics,
    and their performance implications. This section explores different loop types
    in Java, which include `for`, `while`, `do`-`while`, and `for`-`each`. Our goal
    is to understand each loop type’s purpose and impact on code readability and efficiency.
    Specifically, we will cover the following topics:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 理解不同类型的循环、它们的特性和性能影响是很重要的。本节探讨了Java中的不同循环类型，包括`for`、`while`、`do`-`while`和`for`-`each`。我们的目标是理解每种循环类型的目的及其对代码可读性和效率的影响。具体来说，我们将涵盖以下主题：
- en: A loop’s impact on performance
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环对性能的影响
- en: Loop optimization basics
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环优化基础
- en: Loop unrolling
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环展开
- en: Being armed with a deeper understanding of loop types can equip you to make
    the right loop selection for a given requirement.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有对循环类型的深入理解可以使您能够为特定需求选择正确的循环。
- en: A loop’s impact on performance
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环对性能的影响
- en: In order to understand a loop’s impact on performance, we must have a firm understanding
    of the different types of loops. This section provides information on each loop
    type to include use cases and advantages. Examples are used to provide implementation
    details.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解循环对性能的影响，我们必须对不同的循环类型有一个牢固的理解。本节提供了关于每种循环类型的信息，包括用例和优势。使用示例来提供实现细节。
- en: for loops
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for循环
- en: '`for` loops are the most basic loop type. They have a concise syntax with well-defined
    loop control. They are the unofficial default for iterating through a set of items.
    Let’s look at the following components of these loops: initialization, condition,
    iteration, and efficiency.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环是最基本的循环类型。它们具有简洁的语法和定义良好的循环控制。它们是非官方的默认循环，用于遍历一系列项目。让我们看看这些循环的以下组成部分：初始化、条件、迭代和效率。'
- en: 'The syntax for a `for` loop is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的语法如下：'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Dissecting the preceding syntax, we can identify `int i =0;` as the `i` and
    it is set to `0`. The `i < 5;` `i` is less than `5`. If the evaluation returns
    `true`, then the loop continues; otherwise, it ends. The final component is the
    `i++` to increase the **control variable** by 1 at the end of each iteration.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 分析之前的语法，我们可以将`int i =0;`识别为`i`，并将其设置为`0`。`i < 5;`表示`i`小于`5`。如果评估结果返回`true`，则循环继续；否则，循环结束。最后一部分是`i++`，在每次迭代的末尾将**控制变量**增加1。
- en: There are some performance-related issues with a `for` loop. When we initialize
    our loop, we should avoid initializing variables outside of the loop as it can
    sometimes degrade performance with redundant initializations within the loop.
    The **condition expression** directly impacts the number of iterations the loop
    will perform. Making this expression overly complex can slow down the loop. Lastly,
    the **iteration expression** should be properly designed to help prevent an infinite
    loop and inefficiency.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环存在一些与性能相关的问题。当我们初始化循环时，应避免在循环外部初始化变量，因为这有时会因循环内的冗余初始化而降低性能。**条件表达式**直接影响循环将执行的迭代次数。使这个表达式过于复杂可能会减慢循环的速度。最后，**迭代表达式**应设计得当，以帮助防止无限循环和不效率。'
- en: 'Let’s look at an inefficient example and then a second example with performance
    improvements. The following example counts how many corgis have names with the
    letter “`e`”:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个低效的例子，然后是一个具有性能改进的第二例子。以下示例计算有多少corgi的名字包含字母“`e`”：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code has two inefficiencies:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码有两个低效之处：
- en: The loop condition is checked using the `length()` method in each iteration.
    This means that, for each corgi in the array, the length of the array is accessed,
    which can lead to unnecessary performance overhead.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环条件在每次迭代中使用`length()`方法进行检查。这意味着，对于数组中的每个corgi，都会访问数组长度，这可能导致不必要的性能开销。
- en: Our code snippet uses `corgis[i].getName().contains("e")` to check if the corgi’s
    name contains the letter “`e`.” So, for each corgi name, we are creating a new
    string and performing a string search. This will most assuredly be computationally
    expensive, especially with long names.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码片段使用`corgis[i].getName().contains("e")`来检查corgi的名字是否包含字母“`e`”。因此，对于每个corgi名字，我们都在创建一个新的字符串并执行字符串搜索。这肯定会增加计算成本，尤其是在名字很长的情况下。
- en: 'With these inefficiencies in mind, let’s look at a revised section of that
    code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些低效之处，让我们看看代码的一个修订版块：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code snippet is an improved version that has the following performance
    enhancements:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段是一个改进版本，具有以下性能提升：
- en: We cached the array’s length by storing it in the `corgislength` variable. Since
    we populate that variable outside of the loop, we avoid repeated access to the
    array’s length during each iteration. This can save tremendously on computational
    effort.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过将数组长度存储在`corgislength`变量中来缓存数组长度。由于我们在循环外部填充该变量，我们避免了在每次迭代中对数组长度的重复访问。这可以大大节省计算工作量。
- en: Instead of using the `contains()` method to check the names, we use the `indexof()`
    method. There is a significant difference here. When we use the `contains()` method,
    a new substring is created and a full search is conducted. Using the `indexof()`
    method returns the index position of the first occurrence of “`e`” or -1 if it
    is not found. This is a much more efficient way to check for a character’s existence
    in a string without creating unnecessary substrings.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不是使用`contains()`方法来检查名字，而是使用`indexof()`方法。这里有一个显著的区别。当我们使用`contains()`方法时，会创建一个新的子字符串并执行完整搜索。使用`indexof()`方法返回“`e`”首次出现的位置索引，如果没有找到，则返回-1。这是一个更有效的方法来检查字符串中字符的存在，而不创建不必要的子字符串。
- en: With our exploration of `for` loops completed, let us look at how to use `while`
    loops in an efficient manner.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了对`for`循环的探索后，让我们看看如何高效地使用`while`循环。
- en: while loops
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`while`循环'
- en: '`while` loops are perhaps the second most common loop used in Java. They are
    fundamental flow control constructs that we can use to repeatedly execute a block
    of code, as long as a specified condition remains `true`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环可能是Java中第二常用的循环。它们是基本的流程控制结构，我们可以使用它们来重复执行代码块，只要指定的条件保持`true`。'
- en: 'The syntax for a `while` loop is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环的语法如下：'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These loops do not require initialization, but when initialization is employed,
    care should be taken to ensure they are correct so as to prevent unintended application
    behavior such as an infinite loop. When the `true`, the body of the loop is executed.
    The loop terminates when the `false`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些循环不需要初始化，但一旦使用了初始化，应确保其正确性，以防止出现无限循环等意外的应用行为。当条件为`true`时，循环体将被执行。循环在条件为`false`时终止。
- en: Condition expressions
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 条件表达式
- en: We should strive to create straightforward condition expressions for loop efficiency.
    Overly complex condition expressions can increase processing overhead, resulting
    in poor performance.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该努力创建简单的条件表达式以提高循环效率。过于复杂的条件表达式会增加处理开销，导致性能下降。
- en: 'Let’s look at an inefficient example and then a second example with performance
    improvements. The following example is of an online ordering system. We want to
    check each order ID to determine if it starts with the “`OL`” prefix. If it does
    not, it should be added:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个低效的例子，然后是第二个具有性能改进的例子。以下是一个在线订购系统的例子。我们想要检查每个订单ID是否以“`OL`”前缀开头。如果不是，则应该添加：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are two inefficiencies in the preceding code snippet. First, the list
    size is repeatedly accessed; it is checked during each iteration. This can lead
    to unnecessary performance overhead. Secondly, the string concatenation, using
    the `+` operator, creates a new string, which can be inefficient when repeatedly
    performed within a loop.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中存在两个低效之处。首先，列表的大小被反复访问；它在每次迭代时都会进行检查。这可能导致不必要的性能开销。其次，使用`+`运算符进行字符串连接会创建一个新的字符串，当在循环中重复执行时可能会效率低下。
- en: 'The following code snippet is a modified version of the online ordering system:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是修改后的在线订购系统版本：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding updated code snippet stands to improve system performance due
    to two factors. First, the list size is now cached, and second, we are using a
    more efficient string modification approach. Here, we are modifying the strings
    without creating new string objects.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的更新代码片段由于两个因素而有望提高系统性能。首先，列表大小现在被缓存，其次，我们使用了一种更有效的字符串修改方法。在这里，我们修改字符串而不创建新的字符串对象。
- en: With our exploration of `while` loops completed, let us look at how to use `do`-`while`
    loops in an efficient manner.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成对`while`循环的探索后，让我们看看如何高效地使用`do`-`while`循环。
- en: do-while loops
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: do-while循环
- en: '`do`-`while` loops, as with the ones previously covered, are flow control structures
    that allow for the repeated execution of a code block while a specified condition
    remains `true`. The unique nature of this type of loop is that the condition is
    checked after the loop’s code block is executed. This ensures that the loop’s
    block of code is executed at least once.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前讨论的`do-while`循环一样，`do`-`while`循环是允许在指定条件保持`true`时重复执行代码块的流程控制结构。这种类型循环的独特之处在于，条件是在循环代码块执行之后进行检查的。这确保了循环代码块至少执行一次。
- en: 'The following example shows a simple `do`-`while` loop for a guessing game
    where the user continues to guess a number until they guess correctly:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了用于猜数字游戏的简单`do`-`while`循环，用户会继续猜测数字，直到猜对为止：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see in the preceding code snippet, we use a Boolean flag to control
    our loop. The flag is checked during each iteration. This approach is inefficient
    in that it adds unnecessary complexity and an extra variable. Let’s modify the
    code so that it is more efficient:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的代码片段中所见，我们使用布尔标志来控制我们的循环。该标志在每次迭代时都会被检查。这种方法效率低下，因为它增加了不必要的复杂性和额外的变量。让我们修改代码，使其更加高效：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With our updated example, we use `userGuess != secretNumber` as the loop condition,
    negating the need for a Boolean flag. This both simplifies our code and can make
    our code more efficient.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的更新示例中，我们使用`userGuess != secretNumber`作为循环条件，从而消除了对布尔标志的需要。这既简化了我们的代码，也可以使我们的代码更加高效。
- en: for-each loops
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for-each循环
- en: We introduced the `for`-`each` loop in [*Chapter 2*](B21942_02.xhtml#_idTextAnchor028)
    and noted that this type of loop is also referred to as an enhanced `for` loop.
    We choose to implement this type of loop when we want to iterate over all elements
    in a dataset, without having to manage an iterator or index. Let’s look at an
    initial example and then refine it for better performance.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第二章*](B21942_02.xhtml#_idTextAnchor028)中介绍了`for`-`each`循环，并指出这种类型的循环也被称为增强型`for`循环。当我们想要遍历数据集中的所有元素，而不需要管理迭代器或索引时，我们选择实现这种类型的循环。让我们先看一个初始示例，然后为了更好的性能对其进行优化。
- en: 'The following code snippet is an automotive parts processing application:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是一个汽车零部件处理应用：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The inefficiency in the preceding code stems from the sequential processing
    of each automotive part within the loop. This can be a time-consuming operation
    and lead to poor performance. Let’s look at an improved version:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的低效源于在循环中对每个汽车零部件进行顺序处理。这可能是一个耗时的操作，并可能导致性能不佳。让我们看看一个改进版本：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this improved version, we implement a `processAutoParts()` method that takes
    the entire parts list as a parameter. This permits batch processing of parts,
    which can significantly improve overall performance.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个改进版本中，我们实现了一个`processAutoParts()`方法，它接受整个零部件列表作为参数。这允许批量处理零部件，这可以显著提高整体性能。
- en: With our exploration of loop types completed, let us now review loop optimization
    basics.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成了对循环类型的探索之后，现在让我们回顾一下循环优化的基础。
- en: Loop optimization basics
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环优化基础
- en: As we strive to ensure our Java applications are high-performing, we rightly
    focus on loop optimizations. Loops are equally ubiquitous in Java programming,
    making their inefficiencies especially problematic. Loop efficiency can vary significantly
    based on implementation and use. This section examines fundamental aspects of
    loop optimization, with the aim of equipping you with the knowledge and tools
    to boost the performance of your Java applications.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们努力确保我们的Java应用程序具有高性能时，我们当然会关注循环优化。循环在Java编程中同样无处不在，这使得它们的低效特别成问题。循环效率可能因实现和使用方式而显著不同。本节将探讨循环优化的基本方面，目的是为您提供知识和工具，以提升您的Java应用程序的性能。
- en: Loop overhead
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环开销
- en: Loop overhead refers to the additional computational costs associated with the
    initialization, implementation, and termination of a loop. While loops are essential
    for achieving various programming tasks, they are not free from computational
    overhead. Understanding loop overhead is crucial because excessive overhead can
    degrade the overall performance of your Java applications.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 循环开销指的是与循环的初始化、实现和终止相关的额外计算成本。虽然循环对于实现各种编程任务至关重要，但它们并非没有计算开销。理解循环开销至关重要，因为过度的开销可能会降低您Java应用程序的整体性能。
- en: The three main components of loop overhead are loop initialization, condition
    evaluation, and iteration. As previously illustrated, each type of loop can result
    in inefficiencies with one or more of these components. Fortunately, there are
    strategies we can adopt to help minimize loop overhead. First, we can optimize
    loop initialization. This can be done by initializing our control variables outside
    of the loop. The performance gained is due to avoiding redundant assignments within
    the loop. We can also minimize the number of variables declared within the loop.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 循环开销的三个主要组成部分是循环初始化、条件评估和迭代。正如之前所展示的，每种类型的循环都可能导致一个或多个这些组件的低效。幸运的是，我们可以采用一些策略来帮助最小化循环开销。首先，我们可以优化循环初始化。这可以通过在循环外部初始化我们的控制变量来实现。所获得的性能提升是由于避免了在循环中的冗余赋值。我们还可以最小化在循环中声明的变量数量。
- en: A second strategy is to use simple and efficient condition expressions. We want
    to avoid complex conditions within loops. If our loop’s condition is dependent
    on a dataset’s length, that length should be cached outside of the loop to prevent
    repeated access.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种策略是使用简单高效的条件表达式。我们希望避免在循环中包含复杂的条件。如果我们的循环条件依赖于数据集的长度，那么这个长度应该在循环外部缓存，以防止重复访问。
- en: Thirdly, we can streamline our iteration. To adopt this strategy, we should
    ensure the iteration is designed to update loop control variables correctly and
    efficiently. We also should use the appropriate expression increments/decrements
    in an efficient and correct manner. Lastly, we should consider alternative loop
    types for each set of requirements.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们可以简化迭代。为了采用这种策略，我们应该确保迭代被设计为正确且高效地更新循环控制变量。我们还应该以高效和正确的方式使用适当的表达式递增/递减。最后，我们应该考虑针对每套要求选择不同的循环类型。
- en: Bottlenecks
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 瓶颈
- en: 'Unoptimized loops can result in bottlenecks in the performance of our Java
    applications. Understanding the cause of these bottlenecks is a necessary first
    step to avoiding them. As previously covered in this chapter, the following are
    common performance bottlenecks associated with loops in Java programming:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 未优化的循环可能导致我们的Java应用程序性能出现瓶颈。了解这些瓶颈的原因是避免它们的第一步。正如本章前面所提到的，以下是与Java编程中的循环相关的常见性能瓶颈：
- en: Inefficient condition expressions
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低效的条件表达式
- en: Inefficient iteration steps
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低效的迭代步骤
- en: Unnecessary computations
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不必要的计算
- en: Suboptimal data access patterns
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不理想的数据访问模式
- en: Excessive memory allocation
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过多的内存分配
- en: 'We should strive to implement optimization strategies specific to each loop
    type, as detailed in the preceding sections. General loop optimization strategies
    are the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该努力实现针对每种循环类型的特定优化策略，如前几节所述。一般的循环优化策略如下：
- en: Profile our loops to identify performance bottlenecks
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析我们的循环以识别性能瓶颈
- en: Avoid premature optimization
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免过早优化
- en: Choose appropriate data structures
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的数据结构
- en: Choose appropriate algorithms
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的算法
- en: Additionally, as you will learn later in this chapter, profiling tools and methodologies
    can be used to help us determine where bottlenecks are within our loops.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如你将在本章后面学到的那样，分析工具和方法可以帮助我们确定我们的循环中存在哪些瓶颈。
- en: Benchmarking
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基准测试
- en: Optimizing loops beyond the basic strategies covered in this chapter requires
    a firm understanding of how they perform, their characteristics, and the ability
    to measure optimizations for performance. We accomplish this measurement through
    benchmarking. Our goal is to assess the effectiveness of our loop optimizations.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 优化循环超出了本章涵盖的基本策略，需要深入了解它们的性能、特性和测量优化以提升性能的能力。我们通过基准测试来完成这一测量。我们的目标是评估我们的循环优化的有效性。
- en: We should establish a benchmarking environment so that we can evaluate loop
    performance. This requires us to set up a consistent environment that facilitates
    accurate measurements and comparative analysis. Each optimization can be tested
    against the benchmark to determine if it increased or degraded application performance.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该建立一个基准测试环境，以便我们可以评估循环性能。这需要我们设置一个一致的环境，便于准确测量和比较分析。每个优化都可以通过基准测试来测试，以确定它是否提高了或降低了应用程序的性能。
- en: 'To establish a benchmarking environment, follow these steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要建立基准测试环境，请遵循以下步骤：
- en: Choose a benchmarking framework or library that provides tools for measuring
    the performance of our Java code. We will take a specific look at the **Java Microbenchmarking
    Harness** (**JMH**) tool in [*Chapter 13*](B21942_13.xhtml#_idTextAnchor227).
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个提供测量我们Java代码性能工具的基准测试框架或库。我们将在[*第13章*](B21942_13.xhtml#_idTextAnchor227)中具体探讨**Java微基准测试工具**（**JMH**）。
- en: Ensure your development environment is properly configured and up to date.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的开发环境配置正确且最新。
- en: Write benchmarking classes that include the loops we want to benchmark.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写包含我们想要基准测试的循环的基准测试类。
- en: Specify settings and parameters for our benchmarks. This can include measurement
    time, number of iterations, and warm-up iterations.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的基准测试指定设置和参数。这可以包括测量时间、迭代次数和预热迭代次数。
- en: Ensure that the variables involved are consistent across all tests.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保涉及的变量在所有测试中都是一致的。
- en: Conduct warm-up runs to account for any JVM-specific warm-up effects.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行预热运行以考虑任何JVM特定的预热效果。
- en: Measure execution times.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量执行时间。
- en: Analyze results.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析结果。
- en: Repeat and validate multiple times to ensure the validity of your findings.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复并多次验证以确保你发现的有效性。
- en: Interpret your results and optimize.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释你的结果并进行优化。
- en: Document your results.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录你的结果。
- en: By following these steps for establishing a benchmarking environment, you can
    make informed decisions about your loop optimizations, identify performance bottlenecks,
    and fine-tune your Java applications to achieve higher performance.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些步骤建立基准测试环境，你可以就循环优化做出明智的决定，识别性能瓶颈，并微调你的Java应用程序以实现更高的性能。
- en: Loop unrolling
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环展开
- en: Loop unrolling is an advanced optimization strategy. It is an optimization technique
    we can employ in Java to improve our loops. The approach involves replicating,
    or unrolling, the loop’s code block multiple times, to reduce the number of required
    iterations. More specifically, instead of executing our loop’s code block once
    per iteration, we expand the loop to execute the code block multiple times within
    a single iteration. While this may seem complex, it can reduce the loop overhead
    caused by condition checks and updating variables.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 循环展开是一种高级优化策略。它是一种我们可以在Java中采用的优化技术，以改进我们的循环。这种方法涉及复制或展开循环的代码块多次，以减少所需的迭代次数。更具体地说，我们不是每次迭代执行一次循环的代码块，而是扩展循环，在单个迭代中多次执行代码块。虽然这听起来可能很复杂，但它可以减少由条件检查和更新变量引起的循环开销。
- en: 'The benefits of loop unrolling include the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 循环展开的好处包括以下内容：
- en: Reduced loop overhead
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少循环开销
- en: Improved CPU instruction cache usage
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改善CPU指令缓存使用
- en: Enhanced compiler optimization
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强编译器优化
- en: Opportunities for parallelism
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行机会
- en: 'There are two types of loop unrolling: manual and automatic. Let’s look at
    an example of each. This first example is of manual loop unrolling. Here, we must
    explicitly rewrite our loop code to unroll it. Here is an example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 循环展开有两种类型：手动和自动。让我们看看每种类型的示例。第一个示例是手动循环展开。在这里，我们必须明确重写我们的循环代码以展开它。以下是一个示例：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The manual loop unrolling provides us with finite control over the unrolling
    process, but, because it is done manually, it is exceedingly difficult to maintain
    the code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 手动循环展开为我们提供了对展开过程的有限控制，但由于它是手动完成的，因此难以维护代码。
- en: 'With automatic loop unrolling, we can leverage compiler optimization tools
    to automatically unroll our loop code. The compiler will reference compiler flags
    that we specify. Here is an example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过自动循环展开，我们可以利用编译器优化工具自动展开我们的循环代码。编译器将引用我们指定的编译器标志。以下是一个示例：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Compiler flags
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器标志
- en: In Java, compiler flags are used to specify non-default settings or options
    at compile time. We pass flags (for example, `-O`, to enable optimization during
    compilation) to the `javac` compiler command.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，编译器标志用于在编译时指定非默认设置或选项。我们将标志（例如，`-O`，以在编译时启用优化）传递给`javac`编译器命令。
- en: Using automatic unrolling can simplify the optimization process and save us
    time. The disadvantage to this approach is that the unrolling results might not
    be the most efficient. As the complexity of our loops increases, the efficiency
    of the automatic unrolling results decreases.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自动展开可以简化优化过程并节省我们的时间。这种方法的缺点是展开的结果可能不是最有效的。随着我们循环的复杂性增加，自动展开的结果效率会降低。
- en: It is considered a best practice to use loop unrolling when we have a known
    and fixed number of iterations. Also, if loop overhead is not a significant concern,
    then loop unrolling may not be necessary. A side effect of manual unrolling may
    be increased memory usage. Whenever unrolling loops, we should profile and measure
    optimizations on performance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个已知且固定的迭代次数时，使用循环展开被认为是一种最佳实践。此外，如果循环开销不是一个重要的问题，那么循环展开可能不是必要的。手动展开的副作用可能是增加内存使用。每次展开循环时，我们都应该对性能优化进行性能分析。
- en: There are limitations of loop unrolling. First, not every loop is ideal for
    unrolling, such as when the dataset size is variable or dynamic. Another limitation
    or disadvantage of unrolling is that it can result in bloated code, increasing
    the binary size, which, in turn, can result in instruction cache mistakes. Lastly,
    automatically unrolling may not always produce the desired loop optimization.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 循环展开有一些局限性。首先，并非每个循环都适合展开，例如当数据集大小是可变或动态时。展开的另一个局限性或缺点是它可能导致代码膨胀，增加二进制文件大小，这反过来又可能导致指令缓存错误。最后，自动展开不一定总是产生期望的循环优化。
- en: You should now have a comprehensive understanding of loop types in Java, including
    their strengths and weaknesses and their ideal use cases. Your loop selection
    decisions can now be more informed and help ensure you are creating code that
    is performant and maintainable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该对Java中的循环类型有一个全面的理解，包括它们的优缺点和它们理想的使用场景。你现在可以做出更明智的循环选择决策，这有助于确保你创建的代码既高效又易于维护。
- en: Testing loops for performance
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试循环的性能
- en: Now that we have a firm grasp of the different types of loops and their advantages
    and disadvantages, we should feel empowered to make the best loop selections.
    Furthermore, we should be able to implement optimization strategies. But how do
    we know if our loop optimization strategies result in better or worse performance?
    That is where testing comes into play and is the focus of this section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对不同类型的循环及其优缺点有了牢固的掌握，我们应该有信心做出最佳的循环选择。此外，我们还应该能够实施优化策略。但如何知道我们的循环优化策略是否提高了性能或降低了性能？这就是测试发挥作用的地方，也是本节的重点。
- en: 'In this section, we will cover the following concepts:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖以下概念：
- en: Profiling tools and methodology
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析工具和方法
- en: Benchmarking and testing strategies
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试和测试策略
- en: Case studies and examples
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究和示例
- en: Our goal is to obtain the knowledge and practical skills needed to evaluate,
    optimize, and harness the full potential of loops within our Java applications.
    Moreover, we want to have a testing strategy that will inform us of the efficacy
    of our optimizations.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是获取评估、优化和充分利用Java应用程序中循环的全部潜力的所需知识和实践技能。此外，我们希望有一个测试策略，能够告诉我们优化的有效性。
- en: Profiling tools and methodology
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析工具和方法
- en: It is not enough to write optimized loops in our Java applications. We should
    have a clear understanding of profiling tools and methodologies. In our context,
    profiling is the practice of analyzing the execution of our loops to gain insights
    into their performance characteristics. We can glean crucial information on how
    much CPU time our loops demand.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Java应用程序中编写优化的循环是不够的。我们应该对分析工具和方法有一个清晰的理解。在我们的环境中，分析是分析我们循环执行以深入了解其性能特性的实践。我们可以从分析中获得关于我们的循环需要多少CPU时间的关键信息。
- en: Why profiling is important
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么分析很重要
- en: 'Profiling is considered a diagnostic tool used by developers who are concerned
    with the performance of their Java applications. Profiling is applicable to all
    sections of our code, and, in this section, our focus is on loops. We use profiling
    tools to get deep insights into the behavior of our code at runtime. Here are
    some insights we can gain from profiling:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 分析被认为是关注Java应用程序性能的开发者使用的诊断工具。分析适用于我们代码的各个部分，在本节中，我们的重点是循环。我们使用分析工具来深入了解代码在运行时的行为。以下是我们可以从分析中获得的一些见解：
- en: How much CPU time do our loops consume?
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的循环消耗了多少CPU时间？
- en: Are memory leaks present?
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否存在内存泄漏？
- en: Does our code result in excessive memory allocation?
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码是否导致了过度的内存分配？
- en: How do our loops interact with the CPU cache?
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的循环如何与CPU缓存交互？
- en: How do our loops interact with memory?
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的循环如何与内存交互？
- en: We can write our loops in different ways and use profiling to help inform us
    of which method is the best from an overall runtime performance perspective.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用不同的方式编写循环，并使用分析来帮助我们了解哪种方法在整体运行时性能方面最好。
- en: Profiling types
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析类型
- en: 'There are three basic profiling types: CPU, memory, and thread. In **CPU profiling**,
    the focus is on how our code uses the CPU. This profiling type is especially useful
    for identifying CPU bottlenecks created by our loops.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，有三种基本的分析类型：CPU、内存和线程。在**CPU分析**中，重点是我们的代码如何使用CPU。这种分析类型对于识别由我们的循环创建的CPU瓶颈特别有用。
- en: '**Memory profiling** gives us insights into memory-related issues. These can
    include excessive memory consumption, memory leaks, and excessive or inefficient
    object creation. This is one of the most useful profiling types when our focus
    is on loop optimization.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存分析**让我们深入了解与内存相关的问题。这些问题可能包括过度的内存消耗、内存泄漏以及过度的或低效的对象创建。这是我们关注循环优化时最有用的分析类型之一。'
- en: The **thread profiling** type is useful in identifying synchronization issues
    that can affect the performance of our loops.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程分析**类型有助于识别可能影响我们循环性能的同步问题。'
- en: Profiling tools
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析工具
- en: 'Profiling tools are software applications that help automate profiling options
    for us. There are a plethora of tools available to Java developers, many of which
    are open source and free to use. These tools can be organized into three categories:
    those that come bundled with the JDK, those that come bundled with an **integrated
    development environment** (**IDE**), and commercial or third-party tools.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析工具是帮助我们自动选择性能分析选项的软件应用程序。Java开发者有许多可用的工具，其中许多是开源的，并且免费使用。这些工具可以分为三类：与JDK捆绑的工具、与**集成开发环境**（**IDE**）捆绑的工具，以及商业或第三方工具。
- en: Let’s look at two examples of profiling tools that come bundled with the JDK.
    First, **Java Flight Recorder** (**JFR**) is a built-in tool that can record and
    analyze application behavior. This tool is lauded for its low processing overhead.
    **VisualVM** is another profiling tool that comes bundled with the JDK. It provides
    great insights into CPU usage and memory usage, as well as thread activity.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个与JDK捆绑提供的性能分析工具的例子。首先，**Java飞行记录器**（**JFR**）是一个内置工具，可以记录和分析应用程序行为。这个工具因其低处理开销而受到赞誉。**VisualVM**是另一个与JDK捆绑提供的性能分析工具。它提供了关于CPU使用、内存使用以及线程活动的深刻见解。
- en: Profiling methodologies
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能分析方法
- en: A profiling methodology is essentially your approach to profiling. This is more
    than simply selecting a profiler to use. In fact, you often will want to use more
    than one tool as part of your methodology. When asked what your profiling methodology
    is, consider what your overall approach is.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析方法本质上是你进行性能分析的方法。这不仅仅是简单地选择一个性能分析器来使用。实际上，你通常会希望在你的方法中使用多个工具。当被问及你的性能分析方法时，考虑一下你的整体方法是什么。
- en: You might employ a **sampling profiling** methodology where you periodically
    pull data on your application’s execution. This sampling approach provides a quick
    view of code execution behavior and can provide insights into what might need
    deeper profiling.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会采用**采样性能分析**方法，定期获取应用程序执行的数据。这种采样方法可以快速查看代码执行行为，并可以提供深入了解哪些可能需要更深入的性能分析。
- en: Another common profiling methodology is **instrumentation profiling**. This
    approach requires us to add profiling code to our application. While this approach
    can provide the greatest level of fidelity regarding code execution behavior,
    it also commands the most CPU overhead.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的性能分析方法是**仪器性能分析**。这种方法要求我们在应用程序中添加性能分析代码。虽然这种方法可以提供关于代码执行行为的最高保真度，但它也要求最高的CPU开销。
- en: A third popular profiling methodology is **continuous profiling**. This approach
    collects a lot of data over long periods of an application running. Developers
    who employ this methodology can gain insights into long-term trends and more easily
    detect performance anomalies.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种流行的性能分析方法是**持续性能分析**。这种方法在应用程序长时间运行期间收集大量数据。采用这种方法的开发者可以深入了解长期趋势，并更容易地检测性能异常。
- en: Identifying hotspots in our loops
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 识别循环中的热点
- en: In the context of Java loops, a hotspot is a loop that consumes excessive CPU
    time or memory at runtime. It is imperative that we pinpoint these hotspots in
    our loops so that we can optimize them.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java循环的上下文中，热点是在运行时消耗过多CPU时间或内存的循环。我们迫切需要在我们的循环中确定这些热点，以便我们可以优化它们。
- en: As a final note on profiling, we should realize that identifying a **hotspot**
    is just one step, and using a profiling tool is another. We need to address the
    issues we uncover and then reapply profiling tools to ensure our changes have
    the desired impact. Developers should have a continuous improvement mindset over
    their loops and other code. This requires the continual monitoring and profiling
    of our code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在对性能分析的最后一点说明中，我们应该意识到，识别**热点**只是第一步，使用性能分析工具则是另一步。我们需要解决我们发现的这些问题，然后重新应用性能分析工具以确保我们的更改产生预期的效果。开发者应该对他们的循环和其他代码保持持续改进的心态。这需要持续监控和性能分析我们的代码。
- en: Benchmarking and testing strategies
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试和测试策略
- en: We have accepted that optimizing loops is a critical part of ensuring our Java
    applications perform at a high level. This high performance requires benchmarking
    and testing strategies. This section looks at both types of strategies and shares
    best practices.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经接受，优化循环是确保我们的Java应用程序在高水平运行的关键部分。这种高性能需要基准测试和测试策略。本节将探讨这两种策略，并分享最佳实践。
- en: Benchmarking strategies
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基准测试策略
- en: 'JMH is the most common toolkit used for conducting performance testing of Java
    code. It does a wonderful job of handling finite components of Java performance
    testing. As the name suggests, it is designed specifically to test Java code and
    is widely used in micro-level performance testing. Some features of JMH are the
    following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: JMH是用于进行Java代码性能测试最常用的工具包。它在处理Java性能测试的有限组件方面做得非常出色。正如其名称所暗示的，它是专门为测试Java代码而设计的，并且在微级性能测试中得到广泛应用。JMH的一些特性如下：
- en: It measures the performance characteristics of microbenchmarks (code segments).
    It is especially handy for loop performance testing.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它测量微基准测试（代码段）的性能特征。对于循环性能测试来说，它特别方便。
- en: JMH supports measurements of average time, sample time, single-shot time, and
    throughput. This gives developers great flexibility.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JMH支持测量平均时间、样本时间、单次时间和吞吐量。这为开发者提供了极大的灵活性。
- en: With JMH, developers have finite control of the testing environment.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JMH，开发者可以对测试环境有有限的控制。
- en: Can be integrated with build tools (for example, Maven).
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以与构建工具（例如，Maven）集成。
- en: Provides detailed microbenchmarking results.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供详细的微基准测试结果。
- en: Regardless of which benchmarking tool we use, it is important to first establish
    a baseline. We can accomplish this by running our tools on unoptimized code. Once
    we have the results of that test, we have our baseline. Testing optimized code
    can be evaluated against the baseline.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们使用哪种基准测试工具，首先建立基准线都很重要。我们可以通过在未优化的代码上运行我们的工具来完成这项工作。一旦我们有了那个测试的结果，我们就有了基准线。测试优化后的代码可以与基准线进行比较。
- en: Testing strategies
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试策略
- en: There are three primary testing strategies. The first is unit testing. This
    strategy can help us ensure that any changes we make to our loops do not impact
    the expected code behavior. Unit testing can also help us test our loops with
    edge cases such as with extreme values.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种主要的测试策略。第一种是单元测试。这种策略可以帮助我们确保我们对循环所做的任何更改都不会影响预期的代码行为。单元测试还可以帮助我们测试循环的边缘情况，例如使用极端值。
- en: Profiling and hotspot analysis is another testing strategy that has already
    been covered in this chapter. As a reminder, we use profiler tools such as JFR
    or VisualVM to help us analyze CPU and memory usage.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件和热点分析是本章已经介绍过的另一种测试策略。提醒一下，我们使用配置文件工具，如JFR或VisualVM，来帮助我们分析CPU和内存使用情况。
- en: Lastly, we can use regression testing to test our loops after we make changes
    to the application. This can help ensure that our changes do not negatively impact
    any other functionality.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在对应用程序进行更改后使用回归测试来测试我们的循环。这可以帮助确保我们的更改不会对其他任何功能产生负面影响。
- en: Regardless of our testing strategy, we should approach loop optimization testing
    in an iterative manner. This means we should make small, incremental changes to
    our loops, testing after each change.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们的测试策略如何，我们都应该以迭代的方式处理循环优化测试。这意味着我们应该对我们的循环进行小的、逐步的更改，并在每次更改后进行测试。
- en: Case studies and examples
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究和示例
- en: This section covers practical case studies and examples of optimizing loops
    in Java. It can be powerful to review real-world scenarios as we stand to gain
    great insights into common challenges and best practices for solutions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了优化Java中循环的实际案例研究和示例。回顾现实场景可以非常强大，因为我们有机会深入了解常见的挑战和解决方案的最佳实践。
- en: Case studies
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例研究
- en: Consider a case study in which we need to process a large dataset and aggregate
    data based on a business requirement. Our challenge, in this scenario, is that
    our aggregation loop is very slow. Since we have a large dataset, we want to solve
    for the slow loop. What can we do? We can ensure we are using an `ArrayList` instead
    of a `LinkedList`. We can also use Java’s **Stream API** to implement parallel
    processing. This should make better use of multi-core CPUs. We can also minimize
    object creation within the loop. Given this scenario and the suggested solutions,
    we are likely to significantly reduce the aggregation loop operation time as well
    as the complexity of the loop.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个案例研究，其中我们需要处理大量数据集并根据业务需求聚合数据。在这个场景中，我们的挑战是聚合循环非常慢。由于我们有大量数据集，我们希望解决慢循环的问题。我们能做什么？我们可以确保使用`ArrayList`而不是`LinkedList`。我们还可以使用Java的**Stream
    API**来实现并行处理。这应该能更好地利用多核CPU。我们还可以在循环中尽量减少对象创建。考虑到这个场景和提出的解决方案，我们很可能会显著减少聚合循环的操作时间以及循环的复杂性。
- en: Let’s look at another case study. This one features a banking application that
    calculates investment risk metrics over large datasets. The challenge, in this
    scenario, is that our main calculation loop is inefficient. We might take a three-pronged
    optimization strategy. First, we will examine our algorithm and see if it can
    be improved. Next, we will write our code so that it supports **Just-In-Time**
    (**JIT**) compilation. Lastly, we will look at our data structures and make any
    necessary changes to minimize memory access issues. This three-pronged approach
    can result in a significantly more performant application.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个案例研究。这个案例研究是一个银行应用程序，它在大数据集上计算投资风险指标。在这种情况下，挑战在于我们的主要计算循环效率低下。我们可能采取三管齐下的优化策略。首先，我们将检查我们的算法，看看是否可以改进。接下来，我们将编写我们的代码，使其支持**即时编译**（**JIT**）。最后，我们将查看我们的数据结构，并做出任何必要的更改以最小化内存访问问题。这种三管齐下的方法可以导致应用程序性能显著提高。
- en: Examples
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: Let’s look at two real-world applications of loop testing and optimization.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个现实世界的循环测试和优化应用。
- en: Our first example is data processing for healthcare analytics. The challenge
    is that processing large groups of patient data for analytical reports is slow.
    The solution is to implement multithreading and batch processing within our loops
    so that we can process data in parallel chunks. The result of this approach should
    be a significant reduction in data processing time.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个例子是医疗保健分析的数据处理。挑战在于处理大量患者数据以生成分析报告很慢。解决方案是在我们的循环中实现多线程和批量处理，以便我们可以并行处理数据块。这种方法的成果应该是数据处理时间的显著减少。
- en: Another example is inventory management as part of an e-commerce Java application.
    The challenge is to optimize the loop in our code that processes inventory updates.
    For this scenario, we will assume that the loop is slower than it has been in
    the past, most likely due to an ever-increasing inventory dataset. The solution
    would likely be to use efficient data structures and change our loop structure
    as appropriate. The result of this approach should be faster inventory processing
    and greater response times.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是作为电子商务Java应用程序一部分的库存管理。挑战在于优化我们代码中处理库存更新的循环。对于这种情况，我们将假设循环比过去慢，这很可能是由于库存数据集不断增长。解决方案可能是使用高效的数据结构并相应地更改我们的循环结构。这种方法的成果应该是更快的库存处理和更长的响应时间。
- en: This section covered profiling tools, profiling methodologies, benchmarking,
    testing strategies, case studies, and examples. We can now confidently evaluate,
    optimize, and harness the full potential of loops within our Java applications,
    leading to high runtime performance.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了分析工具、分析方法、基准测试、测试策略、案例研究和示例。我们现在可以自信地评估、优化并充分利用Java应用程序中的循环，从而实现高运行时性能。
- en: Nested loops
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套循环
- en: 'Now, we’ll cover the fundamental concepts, practical optimization strategies,
    and technical intricacies involved in effectively optimizing nested loops in Java
    applications. We will tackle the concept of nested loops, as they relate to high-performance
    Java applications, in the following sections:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将介绍在Java应用程序中有效优化嵌套循环所涉及的基本概念、实用优化策略和技术复杂性。在接下来的章节中，我们将探讨嵌套循环的概念，以及它们与高性能Java应用程序的关系：
- en: Introduction to nested loops
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套循环简介
- en: Loop fusion in nested loops
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套循环中的循环融合
- en: Parallelizing nested loops
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套循环并行化
- en: Nested loop vectorization
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套循环向量化
- en: It is important to understand when to use nested loops and, when we do, how
    to implement them in the most optimal method.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 理解何时使用嵌套循环以及如何以最优化方式实现它们是很重要的。
- en: Introduction to nested loops
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套循环简介
- en: 'A nested loop is when one loop is located inside another. This creates a complex
    iteration scenario. Here is the syntax for a simple nested loop:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套循环是指一个循环位于另一个循环内部。这创建了一个复杂的迭代场景。以下是一个简单嵌套循环的语法：
- en: '[PRE12]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see in the preceding syntax, the outer loop runs 10 times, and for
    each iteration, the inner loop also runs three times. This results in a total
    of 10 x 10 = 100 iterations.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在先前的语法中看到的那样，外循环运行10次，对于每次迭代，内循环也运行三次。这导致总共10 x 10 = 100次迭代。
- en: We can implement a finite number of levels in our nested loops. With each inner
    loop, our code becomes more complex, more difficult to read, and more frustrating
    to maintain. So, when would we use nested loops? One common implementation is
    when processing multi-dimensional arrays such as matrices. They are also used
    when performing operations on tables.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在嵌套循环中实现有限级别的嵌套。随着每个内部循环的出现，我们的代码变得更加复杂，更难以阅读，也更难以维护。那么，我们何时会使用嵌套循环呢？一个常见的实现是当处理多维数组，如矩阵时。它们也用于在表格上执行操作。
- en: Warning
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Be careful when implementing nested loops. They can very quickly become inefficient
    and make your application sluggish and non-responsive.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现嵌套循环时要小心。它们可能会非常快地变得低效，并使你的应用程序变得缓慢且无响应。
- en: Loop fusion in nested loops
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套循环中的循环融合
- en: If we must implement nested loops in our Java applications, we should consider
    applying loop fusion to them for efficiency. Loop fusion is essentially an algorithmic
    approach where we combine adjacent loops, ones that perform operations on the
    same dataset, into a single loop.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须在 Java 应用程序中实现嵌套循环，为了提高效率，我们应该考虑对它们应用循环融合。循环融合本质上是一种算法方法，其中我们将相邻的循环，即对同一数据集执行操作的循环，合并成一个循环。
- en: We can also attempt to reduce redundant calculations and improve cache utilization.
    This is possible when we merge loops because it stands to minimize redundancy,
    thereby improving the use of cache. The technique involves reusing data that is
    loaded into the cache during the same iteration. The outcome is generally fewer
    cache misses.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以尝试减少冗余计算并提高缓存利用率。当我们合并循环时这是可能的，因为它可以最小化冗余，从而提高缓存的使用。这种技术涉及在相同迭代期间重新使用加载到缓存中的数据。结果通常是更少的缓存未命中。
- en: Loop fusion can also prove beneficial when using complex algorithms such as
    matrix multiplication. There is a potential side effect, namely increased loop
    complexity. This greater complexity results in decreased code readability and
    makes the code more difficult to maintain.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用复杂算法，如矩阵乘法时，循环融合也可能证明是有益的。可能存在一个副作用，即增加了循环的复杂性。这种更大的复杂性导致代码可读性降低，使得代码更难以维护。
- en: Parallelizing nested loops
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行化嵌套循环
- en: To parallelize nested loops in Java, we need to restructure our loops so they
    can execute concurrently across multiple CPU cores instead of on a single core.
    As you would expect, this is a component of parallel computing, which can result
    in significantly increased runtime performance. Strategies for parallelizing nested
    loops include chunking our dataset and processing each chunk in a separate thread.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Java 中并行化嵌套循环，我们需要重新构建我们的循环，以便它们可以在多个 CPU 核心上并发执行，而不是在单个核心上。正如你所期望的，这是并行计算的一个组成部分，可以显著提高运行时性能。并行化嵌套循环的策略包括将数据集分块，并在单独的线程中处理每个块。
- en: The concept of multithreading is often discussed along with parallel streams
    in the context of nested loops. Comparing the two, we can learn that multithreading
    offers additional control but requires us to explicitly manage threads and tasks.
    Parallel streams, which are part of Java’s **Stream API**, provide us with an
    easier method to parallelize operations, but with less control over the threading
    model.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程的概念通常与嵌套循环中的并行流一起讨论。比较两者，我们可以了解到多线程提供了额外的控制，但需要我们显式地管理线程和任务。Java 的 **Stream
    API** 中的并行流提供了一种更简单的方法来并行化操作，但我们对线程模型的控制较少。
- en: Lastly, when parallelizing, we must handle synchronization and thread safety.
    Synchronization becomes key as does ensuring thread safety. This is especially
    true when we deal with shared data structures.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在并行化时，我们必须处理同步和线程安全。同步变得至关重要，确保线程安全也同样重要。这在我们处理共享数据结构时尤其如此。
- en: Nested loop vectorization
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套循环向量化
- en: You may recall from [*Chapter 2*](B21942_02.xhtml#_idTextAnchor028) of this
    book that vectorization refers to the process of executing a single instruction
    simultaneously on multiple data points. We can leverage vectorization for nested
    loops to significantly increase computational speed, especially when dealing with
    complex data manipulations such as a matrix.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，从本书的[*第二章*](B21942_02.xhtml#_idTextAnchor028)中，向量化指的是在多个数据点上同时执行单个指令的过程。我们可以利用向量化来提高嵌套循环的计算速度，尤其是在处理复杂的数据操作，如矩阵时。
- en: '**Single Instruction, Multiple Data** (**SIMD**) can be an important concept
    in nested loop optimization. SIMD is a key concept in vectorization where, as
    the name suggests, a single operation is performed on multiple data elements.
    This is an especially effective technique with repetitive nested loops. The efficacy
    of vectorization depends on compiler optimizations and hardware support. Not all
    CPUs have SIMD capabilities.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**单指令多数据**（**SIMD**）在嵌套循环优化中可能是一个重要的概念。SIMD 是向量化中的一个关键概念，正如其名称所暗示的，它对多个数据元素执行单个操作。这对于重复的嵌套循环来说是一种特别有效的技术。向量化的有效性取决于编译器优化和硬件支持。并非所有
    CPU 都具有 SIMD 功能。'
- en: This section provided a structured overview of nested loop optimization with
    the goal of increasing Java application performance. Fundamental concepts were
    covered, as were practical optimization strategies, and some technical intricacies
    involved in effectively optimizing nested loops in Java applications.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了一个结构化的嵌套循环优化概述，旨在提高 Java 应用程序的性能。涵盖了基本概念，以及实用的优化策略，还涉及在 Java 应用程序中有效优化嵌套循环的一些技术复杂性。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter focused on loops, fundamental programming constructs, and how to
    get the most out of them from a runtime performance perspective. Concepts covered
    included loop overhead, loop unrolling, benchmarks, loop fusion, loop parallelization,
    and loop vectorization. We used code examples to provide insights and demonstrate
    best practices.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了循环，这是编程的基本结构，以及如何从运行时性能的角度最大限度地利用它们。涵盖的概念包括循环开销、循环展开、基准测试、循环融合、循环并行化和循环向量化。我们通过代码示例提供见解并展示最佳实践。
- en: We explored techniques, strategies, and best practices to help you get the best
    performance out of your loops and to prevent the unintentional introduction of
    substantial bottlenecks that undermine runtime performance.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了技术、策略和最佳实践，以帮助您从循环中获得最佳性能，并防止无意中引入重大的瓶颈，从而损害运行时性能。
- en: The next chapter takes a specific look at Java object pooling, which is a design
    pattern used to manage reusable objects to conserve resources and improve application
    performance.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将专门探讨 Java 对象池，这是一种设计模式，用于管理可重用对象以节省资源并提高应用程序性能。
