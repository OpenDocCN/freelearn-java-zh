["```java\ncase class ListOrderBook( \n  bids: TreeMap[Price, List[BuyLimitOrder]], \n  offers: TreeMap[Price, List[SellLimitOrder]]) { \n  def bestBid: Option[BuyLimitOrder] =  \n    ??? // hidden for brevity \n  def bestOffer: Option[SellLimitOrder] =  \n    ??? // hidden for brevity \n} \n\n```", "```java\nsealed trait LimitOrder { \n  def id: OrderId \n  def price: Price \n} \ncase class BuyLimitOrder(id: OrderId, price: Price) extends LimitOrder \ncase class SellLimitOrder(id: OrderId, price: Price) extends LimitOrder \ncase class Price(value: BigDecimal) \n\n```", "```java\ncase class Price(value: BigDecimal) extends AnyVal \n\n```", "```java\nsealed trait List[+A] \ncase object Nil extends List[Nothing] \ncase class ::[A](head: A, tail: List[A]) extends List[A] \n\n```", "```java\nval list = ::(1, ::(2, ::(3, Nil)))\n\n```", "```java\nList(1,2,3,4) match { \n  case 1 :: x :: rest => println(s\"second element: $x, rest: $rest\") \n} \n\n```", "```java\nval list = ::(1, ::(2, ::(3, Nil))) \nval listWithZero = ::(0, list) \n\n```", "```java\nclass TreeMap[A, +B] private (tree: RB.Tree[A, B])(implicit val ordering: Ordering[A]) \n\n```", "```java\nobject Price { \n  implicit val ordering: Ordering[Price] = new Ordering[Price] { \n    def compare(x: Price, y: Price): Int = \n      Ordering.BigDecimal.compare(x.value, y.value) \n  } \n} \n\n```", "```java\n  def handle( \n    currentTime: () => EventInstant, \n    ob: ListOrderBook, \n    c: Command): (ListOrderBook, Event) = c match { \n    case AddLimitOrder(_, o) => ??? // hidden for brevity \n    case CancelOrder(_, id) => ??? // hidden for brevity \n  } \n\n```", "```java\n  sealed trait Command \n  case class AddLimitOrder(i: CommandInstant, o: LimitOrder) extends Command \n  case class CancelOrder(i: CommandInstant, id: OrderId) extends Command \n\n```", "```java\n  sealed trait Event \n  case class OrderExecuted(i: EventInstant, buy: Execution,  \n    sell: Execution) extends Event \n  case class LimitOrderAdded(i: EventInstant) extends Event \n  case class OrderCancelRejected(i: EventInstant,  \n    id: OrderId) extends Event \n  case class OrderCanceled(i: EventInstant,  \n    id: OrderId) extends Event \n\n```", "```java\ncase class ListOrderBook( \n  bids: TreeMap[Price, List[BuyLimitOrder]], \n  offers: TreeMap[Price, List[SellLimitOrder]]) { \n  def bestBid: Option[BuyLimitOrder] = \n    bids.lastOption.flatMap(_._2.headOption) \n\n  def bestOffer: Option[SellLimitOrder] = \n    offers.headOption.flatMap(_._2.headOption) \n} \n\n```", "```java\norderBook.bestOffer.exists(buyOrder.price.value >= _.price.value)  \n  match { \n          case true => ??? // cross the book \n          case false => ??? // rest on the book \n  } \n\n```", "```java\nval orders = orderBook.bids.getOrElse(buyOrder.price, Nil) \n          orderBook.copy(bids = orderBook.bids + (buyOrder.price -> orders.:+(buyOrder))) -> \n            LimitOrderAdded(currentTime()) \n\n```", "```java\n      case (priceLevel, (sell :: Nil)) => (orderBook.copy(offers = orderBook.offers - sell.price), \n        OrderExecuted(currentTime(), Execution(buy.id, sell.price), \n          Execution(sell.id, sell.price))) \n      case (_, (sell :: remainingSells)) => (orderBook.copy(offers = orderBook.offers + (sell.price -> remainingSells)), \n        OrderExecuted(currentTime(), \n          Execution(buy.id, sell.price), Execution(sell.id, sell.price))) \n\n```", "```java\norderBook.offers.find { case (price, priceLevel) => priceLevel.exists(_.id == idToCancel) } \n        .fold[(ListOrderBook, Event)](orderBook -> \n        OrderCancelRejected(currentTime(), idToCancel)) { \n        case (price, priceLevel) => \n          val updatedPriceLevel = priceLevel.filter(_.id != idToCancel) \n          orderBook.copy(offers = updatedPriceLevel.nonEmpty match { \n            case true => orderBook.offers + (price -> updatedPriceLevel) \n            case false => orderBook.offers - price \n          }) -> OrderCanceled(currentTime(), idToCancel) \n\n```", "```java\ncase class QueueOrderBook( \n  bids: TreeMap[Price, Queue[BuyLimitOrder]], \n  offers: TreeMap[Price, Queue[SellLimitOrder]]) \n\n```", "```java\nclass Queue[+A] protected(protected val in: List[A], protected val out: List[A]) \n\n```", "```java\ndef enqueue[B >: A](elem: B) = new Queue(elem :: in, out) \n\n```", "```java\ndef dequeue: (A, Queue[A]) = out match { \n    case Nil if !in.isEmpty => val rev = in.reverse ; (rev.head, new Queue(Nil, rev.tail)) \n    case x :: xs            => (x, new Queue(in, xs)) \n    case _                  => throw new NoSuchElementException(\"dequeue on empty queue\") \n  } \n\n```", "```java\ncase class LazyCancelOrderBook( \n  pendingCancelIds: Set[OrderId], \n  bids: TreeMap[Price, Queue[BuyLimitOrder]], \n  offers: TreeMap[Price, Queue[SellLimitOrder]]) \n\n```", "```java\ntrait Set[A] \n\n```", "```java\nclass Set3[A] private[collection] (elem1: A, elem2: A, elem3: A) \n\n```", "```java\n    def + (elem: A): Set[A] = \n      if (contains(elem)) this \n      else new Set4(elem1, elem2, elem3, elem) \n\n    def - (elem: A): Set[A] = \n      if (elem == elem1) new Set2(elem2, elem3) \n      else if (elem == elem2) new Set2(elem1, elem3) \n      else if (elem == elem3) new Set2(elem1, elem2) \n      else this \n\n```", "```java\n def + (elem: A): Set[A] = \n      if (contains(elem)) this \n      else new HashSet[A] + (elem1, elem2, elem3, elem4, elem) \n\n```", "```java\ndef handleCancelOrder( \n    currentTime: () => EventInstant, \n    ob: LazyCancelOrderBook, \n    id: OrderId): (LazyCancelOrderBook, Event) = \n    ob.copy(pendingCancelIds = ob.pendingCancelIds + id) -> \n      OrderCanceled(currentTime(), id) \n\n```", "```java\ncase class LazyCancelOrderBook( \n  activeIds: Set[OrderId], \n  pendingCancelIds: Set[OrderId], \n  bids: TreeMap[Price, Queue[BuyLimitOrder]], \n  offers: TreeMap[Price, Queue[SellLimitOrder]]) \n\n```", "```java\ndef handleCancelOrder( \n    currentTime: () => EventInstant, \n    ob: LazyCancelOrderBook, \n    id: OrderId): (LazyCancelOrderBook, Event) = \n    ob.activeIds.contains(id) match { \n      case true => ob.copy(activeIds = ob.activeIds - id, \n        pendingCancelIds = ob.pendingCancelIds + id) -> \n        OrderCanceled(currentTime(), id) \n      case false => ob -> OrderCancelRejected(currentTime(), id) \n    } \n\n```", "```java\norderBook.bestOffer.exists(_.price.value <= buy.price.value) match { \n        case true => ??? // crossing order \n        case false => ???  // resting order \n\n```", "```java\n      def restLimitOrder: (LazyCancelOrderBook, Event) = { \n        val orders = orderBook.bids.getOrElse(buy.price, Queue.empty) \n        orderBook.copy(bids = orderBook.bids + (buy.price -> orders.enqueue(buy)), \n          activeIds = orderBook.activeIds + buy.id) -> LimitOrderAdded(currentTime()) \n      } \n\norderBook.bestOffer.exists(_.price.value <= buy.price.value) match { \n        case true => ??? // crossing order \n        case false => restLimitOrder \n\n```", "```java\n      @tailrec \n      def findActiveOrder( \n        q: Queue[SellLimitOrder], \n        idsToRemove: Set[OrderId]): (Option[SellLimitOrder], Option[Queue[SellLimitOrder]], Set[OrderId]) = \n        q.dequeueOption match { \n          case Some((o, qq)) => orderBook.pendingCancelIds.contains(o.id) match { \n            case true => \n              findActiveOrder(qq, idsToRemove + o.id) \n            case false => \n              (Some(o), if (qq.nonEmpty) Some(qq) else None, idsToRemove + o.id) \n          } \n          case None => (None, None, idsToRemove) \n        } \n\n```", "```java\norderBook.offers.headOption.fold(restLimitOrder) { \n        case (price, offers) => findActiveOrder(offers, Set.empty) match { \n          case (Some(o), Some(qq), rms) => (orderBook.copy( \n            offers = orderBook.offers + (o.price -> qq), activeIds = orderBook.activeIds -- rms), \n            OrderExecuted(currentTime(), \n              Execution(buy.id, o.price), Execution(o.id, o.price))) \n          case (Some(o), None, rms) => (orderBook.copy( \n            offers = orderBook.offers - o.price, activeIds = orderBook.activeIds -- rms), \n            OrderExecuted(currentTime(), \n              Execution(buy.id, o.price), Execution(o.id, o.price))) \n          case (None, _, rms) => \n            val bs = orderBook.bids.getOrElse(buy.price, Queue.empty).enqueue(buy) \n            (orderBook.copy(bids = orderBook.bids + (buy.price -> bs), \n              offers = orderBook.offers - price, \n              activeIds = orderBook.activeIds -- rms + buy.id), \n              LimitOrderAdded(currentTime())) \n        } \n      } \n\n```", "```java\nsbt 'project chapter4' 'jmh:run CancelBenchmarks -foe true'\n\n```", "```java\n@State(Scope.Benchmark) \n  class InterleavedOrderState { \n    var lazyBook: LazyCancelOrderBook = LazyCancelOrderBook.empty \n    var eagerBook: QueueOrderBook = QueueOrderBook.empty \n\n    @Setup \n    def setup(): Unit = { \n      lazyBook = (1 to maxOrderCount).foldLeft(LazyCancelOrderBook.empty) { \n        case (b, i) => LazyCancelOrderBook.handle( \n          () => EventInstant.now(), b, AddLimitOrder( \n            CommandInstant.now(), BuyLimitOrder(OrderId(i), bidPrice)))._1 \n      } \n      eagerBook = (1 to maxOrderCount).foldLeft(QueueOrderBook.empty) { \n        case (b, i) => QueueOrderBook.handle( \n          () => EventInstant.now(), b, AddLimitOrder( \n            CommandInstant.now(), BuyLimitOrder(OrderId(i), bidPrice)))._1 \n      } \n    } \n  } \n\n```", "```java\n@Benchmark \n  def lazyOneToOneCT(state: InterleavedOrderState): LazyCancelOrderBook = { \n    val b1 = LazyCancelOrderBook.handle(() => EventInstant.now(), \n      state.lazyBook, firstCancel)._1 \n    LazyCancelOrderBook.handle(() => EventInstant.now(), \n      b1, firstCrossSell)._1 \n  } \n\n@Benchmark \n  def lazyTwoToOneCT(state: InterleavedOrderState): LazyCancelOrderBook = { \n    val b1 = LazyCancelOrderBook.handle(() => EventInstant.now(), \n      state.lazyBook, firstCancel)._1 \n    val b2 = LazyCancelOrderBook.handle(() => EventInstant.now(), \n      b1, secondCancel)._1 \n    LazyCancelOrderBook.handle(() => EventInstant.now(), \n      b2, firstCrossSell)._1 \n  } \n\n@Benchmark \n  def lazyOneToTwoCT(state: InterleavedOrderState): LazyCancelOrderBook = { \n    val b1 = LazyCancelOrderBook.handle(() => EventInstant.now(), \n      state.lazyBook, firstCancel)._1 \n    val b2 = LazyCancelOrderBook.handle(() => EventInstant.now(), \n      b1, firstCrossSell)._1 \n    LazyCancelOrderBook.handle(() => EventInstant.now(), \n      b2, secondCrossSell)._1 \n  } \n\n```", "```java\nsbt 'project chapter4' 'jmh:run InterleavedOrderBenchmarks -foe true'\n\n```", "```java\ncase class TimestampMinutes(value: Int) extends AnyVal { \n  def next: TimestampMinutes = TimestampMinutes(value + 1) \n} \n\ncase class AskPrice(value: Int) extends AnyVal \ncase class BidPrice(value: Int) extends AnyVal \ncase class Execution(time: TimestampMinutes, ask: AskPrice, bid: BidPrice) \n\ncase class Midpoint(time: TimestampMinutes, value: Double) \nobject Midpoint { \n  def fromAskAndBid(time: TimestampMinutes,askPrice: AskPrice, \n   bidPrice: BidPrice): Midpoint = \n   Midpoint(time, (bidPrice.value + askPrice.value) / 2D) \n} \n\ncase class MinuteRollUp(value: Int) extends AnyVal \ncase class Return(value: Double) extends AnyVal \n\nobject Return { \n  def fromMidpoint(start: Midpoint, end: Midpoint): Return = \n    Return((end.value - start.value) / start.value * 100) \n} \n\n```", "```java\ndef computeReturnsWithList( \n  rollUp: MinuteRollUp, \n  data: List[Midpoint]): List[Return] = { \n  for { i <- (rollUp.value until data.size).toList} yield       Return.fromMidpoint(data(i - rollUp.value), data(i)) \n} \n\n```", "```java\ndef computeReturnsWithVector( \n  rollUp: MinuteRollUp, \n  data: Vector[Midpoint]): Vector[Return] = { \n  for { \n    i <- (rollUp.value until data.size).toVector \n  } yield Return.fromMidpoint(data(i - rollUp.value), data(i)) \n} \n\n```", "```java\ndef returnThirdElement[A](v: Vector[A]): Option[A] = v match { \n case _ +: _ +: x +: _ => Some(x) \n  case _ => None \n} \n\n```", "```java\n scala> returnThirdElement(Vector(1,2,3,4,5))\n    res1: Option[Int] = Some(3) \n```", "```java\nclass MidpointSeries private(val points: Vector[Midpoint]) extends AnyVal \nobject MidpointSeries { \n\n private def removeDuplicates(v: Vector[Midpoint]): Vector[Midpoint] = { \n   @tailrec \n   def loop( \n     current: Midpoint, \n     rest: Vector[Midpoint], \n     result: Vector[Midpoint]): Vector[Midpoint] = { \n     val sameTime = current +: rest.takeWhile(_.time == current.time) \n     val average = sameTime.map(_.value).sum / sameTime.size \n\n     val newResult = result :+ Midpoint(current.time, average) \n     rest.drop(sameTime.size - 1) match { \n       case h +: r => loop(h, r, newResult) \n       case _ => newResult \n     } \n   } \n\n   v match { \n     case h +: rest => loop(h, rest, Vector.empty) \n     case _ => Vector.empty \n   } \n } \n\n def fromExecution(executions: Vector[Execution]): MidpointSeries = { \n   new MidpointSeries(removeDuplicates( \n     executions.map(Midpoint.fromExecution))) \n } \n\n```", "```java\nclass MidpointSeries private(val points: Vector[Midpoint]) extends AnyVal { \n\n def returns(rollUp: MinuteRollUp): Vector[Return] = { \n   for { \n     i <- (rollUp.value until points.size).toVector \n   } yield Return.fromMidpoint(points(i - rollUp.value), points(i)) \n } \n} \n\n```", "```java\nprivate def extrapolate(a: Midpoint,b: Midpoint, time: TimestampMinutes): Midpoint = { \n val price = a.value + \n   ((time.value - a.time.value) / (b.time.value - a.time.value)) * \n     (b.value - a.value) \n Midpoint(time, price) \n} \n\n```", "```java\nprivate def addMissingDataPoints( \n  v: Vector[Midpoint]): Vector[Midpoint] = { \n @tailrec \n def loop( \n   previous: Midpoint, \n   rest: Vector[Midpoint], \n   result: Vector[Midpoint]): Vector[Midpoint] = rest match { \n   case current +: mPoints if previous.time.value == current.time.value - 1 => \n     // Nothing to extrapolate, the data points are consecutive \n     loop(current, mPoints, result :+ previous) \n\n   case current +: mPoints if previous.time.value < current.time.value - 1 => \n     //Need to generate a data point \n     val newPoint = extrapolate(previous, current, previous.time.next) \n     loop(newPoint, rest, result :+ previous) \n\n   case _ => result :+ previous \n } \n\n v match { \n   case h +: rest => loop(h, rest, Vector.empty) \n   case _ => Vector.empty \n } \n} \n\n```", "```java\ndef fromExecution(executions: Vector[Execution]): MidpointSeries = { \n new MidpointSeries( \n   addMissingDataPoints( \n     removeDuplicates( \n       executions.map(Midpoint.fromExecution)))) \n} \n\n```", "```java\nval arr = Array(1, 2, 3) \nval arrReversed = arr.reverse   // arrReversed is an Array[Int] \nval seqReversed: Seq[Int] = arr.reverse   \n// seqReversed is a WrappedArray \n\n```", "```java\nclass ReturnSeriesFrame(val series: Array[Array[Return]]) { \n  val scalingVector: Array[Double] = { \n    val v = new Array[Double](series.length) \n    for (i <- series.indices) { \n      v(i) = series(i).max.value \n    } \n      v \n  } \n} \n\n```", "```java\nobject ReturnSeriesFrame { \ndef scaleWithMap(frame: ReturnSeriesFrame): ReturnSeriesFrame = { \n new ReturnSeriesFrame( \n   frame.series.zip(frame.scalingVector).map {  \ncase (series, scaling) => series.map(point => Return(point.value / scaling)) \n   }) \n} \n} \n\n```", "```java\ndef scaleWithSpire(frame: ReturnSeriesFrame): ReturnSeriesFrame = { \n import spire.syntax.cfor._ \n\n val result = new Array[Array[Return]](frame.series.length) \n\n cfor(0)(_ < frame.series.length, _ + 1) { i => \n   val s = frame.series(i) \n   val scaled = new Array[Return](s.length) \n   cfor(0)(_ < s.length, _ + 1) { j => \n     val point = s(j) \n     scaled(j) = Return(point.value / frame.scalingVector(i)) \n   } \n   result(i) = scaled \n } \n\n new ReturnSeriesFrame(result) \n} \n\n```", "```java\npublic highperfscala.dataanalysis.ArrayBasedReturnSeriesFrame scaleWithSpire(highperfscala.dataanalysis.ArrayBasedReturnSeriesFrame); \n    Code: \n       0: aload_1 \n       1: invokevirtual #121                // Method highperfscala/dataanalysis/ArrayBasedReturnSeriesFrame.series:()[[Lhighperfscala/dataanalysis/Return; \n       4: arraylength \n       5: anewarray     #170                // class \"[Lhighperfscala/dataanalysis/Return;\" \n       8: astore_2 \n       9: iconst_0 \n      10: istore_3 \n      11: iload_3 \n     [... omitted for brevity] \n      39: iload         6 \n      [... omitted for brevity] \n      82: istore        6 \n      84: goto          39 \n      [... omitted for brevity] \n      95: istore_3 \n      96: goto          11 \n      99: new           #16                 // class highperfscala/dataanalysis/ArrayBasedReturnSeriesFrame \n     102: dup \n     103: aload_2 \n     104: invokespecial #19                 // Method highperfscala/dataanalysis/ArrayBasedReturnSeriesFrame.\"<init>\":([[Lhighperfscala/dataanalysis/Return;)V \n     107: areturn \n\n```"]