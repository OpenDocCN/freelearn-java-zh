<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Right-Sizing Your Services</h1>
                </header>
            
            <article>
                
<p>In this chapter, you will learn what Swarm does to create your services with only those dependencies that are necessary for them. You will learn in greater detail what a fraction <span>is</span>, how Swarm detects what fractions should be used, and how you can modify the fraction discovery behavior. Finally, you will learn how to further modify the service creation size and behavior using hollow JARs and thin JARs.</p>
<p><span>Before we explain all of that, we will introduce the service on which we are going to work.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Catalog service</h1>
                </header>
            
            <article>
                
<p>In the first chapter, you learned the basic architecture of the pet store sample application and the services that constitute it. In this and the next chapter, we will be working with the catalog service. To recall, this is the service responsible for providing the information about pets available in the store. We are going to introduce that simple functionality now. In the next three chapters, we will modify that code in order to show you different features and configuration options of WildFly Swarm. Let's look at the initial version.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Draft version</h1>
                </header>
            
            <article>
                
<p><span>We will start by introducing the first, draft version of the service, which we will examine and extend later.</span></p>
<div class="packt_tip">Examples reference: <kbd>chapter3/catalog-service-jaxrs</kbd>.</div>
<p>As in the preceding chapter, we have to start with the <kbd>pom.xml</kbd>:</p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"UTF-8"</span><span>?&gt;<br/></span><span>&lt;project </span><span>xmlns=</span><span>"http://maven.apache.org/POM/4.0.0"<br/></span><span>         </span><span>xmlns:</span><span>xsi</span><span>=</span><span>"http://www.w3.org/2001/XMLSchema-instance"<br/></span><span>         </span><span>xsi</span><span>:schemaLocation=</span><span>"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span><span>&gt;<br/></span><span>    &lt;modelVersion&gt;</span>4.0.0<span>&lt;/modelVersion&gt;<br/></span><span><br/></span><span>    &lt;groupId&gt;</span>org.packt.swarm.petstore<span>&lt;/groupId&gt;<br/></span><span>    &lt;artifactId&gt;</span>catalog-service-jaxrs<span>&lt;/artifactId&gt;<br/></span><span>    &lt;version&gt;</span>1.0<span>&lt;/version&gt;<br/></span><span>    &lt;packaging&gt;</span>war<span>&lt;/packaging&gt;<br/></span><span><br/></span><span>    (...)</span><span><br/></span><span>    <br/></span><span>    &lt;dependencies&gt;<br/><strong>        &lt;!-- 1 --&gt;</strong><br/></span><strong>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.wildfly.swarm&lt;/groupId&gt;<br/>            &lt;artifactId&gt;jaxrs&lt;/artifactId&gt;<br/>            &lt;version&gt;${version.wildfly.swarm}&lt;/version&gt;<br/>        &lt;/dependency&gt;</strong><span><br/></span><span>    &lt;/dependencies&gt;<br/></span><span><br/></span><span>    &lt;build&gt;<br/></span><span>        &lt;plugins&gt;<br/></span><span>            &lt;plugin&gt;<br/></span><span>                &lt;artifactId&gt;</span>maven-war-plugin<span>&lt;/artifactId&gt;<br/></span><span>                &lt;version&gt;</span>${version.war.plugin}<span>&lt;/version&gt;<br/></span><span>                &lt;configuration&gt;<br/></span><span>                    &lt;failOnMissingWebXml&gt;</span>false<span>&lt;/failOnMissingWebXml&gt;<br/></span><span>                &lt;/configuration&gt;<br/></span><span>            &lt;/plugin&gt;<br/><strong>            &lt;!-- 2 --&gt;</strong><br/></span><strong>            &lt;plugin&gt;<br/>                &lt;groupId&gt;org.wildfly.swarm&lt;/groupId&gt;<br/>                &lt;artifactId&gt;wildfly-swarm-plugin&lt;/artifactId&gt;<br/>                &lt;version&gt;${version.wildfly.swarm}&lt;/version&gt;<br/>                &lt;executions&gt;<br/>                    &lt;execution&gt;<br/>                        &lt;goals&gt;<br/>                            &lt;goal&gt;package&lt;/goal&gt;<br/>                        &lt;/goals&gt;<br/>                    &lt;/execution&gt;<br/>                &lt;/executions&gt;<br/></strong><span><strong>            &lt;/plugin&gt;</strong><br/></span><span>        &lt;/plugins&gt;<br/></span><span>    &lt;/build&gt;<br/></span><span><br/></span><span>&lt;/project&gt;</span></pre>
<p>We have to add the dependency to <span>JAX-RS</span> fraction (1) and configure the WildFly Swarm plugin (2). Let's move to the code now.</p>
<p>We will start with a simple domain class, <kbd>Item</kbd>, <span>which</span> contains information about the pets available in the store:</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog.model<span>;<br/></span><span><br/></span><span>public class </span>Item {<br/><br/><br/>    <span>private </span>String <span>itemId</span><span>;<br/></span><span>    private </span>String <span>name</span><span>;<br/></span><span>    private int </span><span>quantity</span><span>;<br/></span><span><br/></span><span>    private </span>String <span>description</span><span>;<br/></span><span><br/></span><span>    public </span>String <span>getItemId</span>() {<br/>        <span>return </span><span>itemId</span><span>;<br/></span><span>    </span>}<br/><br/>    <span>public void </span><span>setItemId</span>(String itemId) {<br/>        <span>this</span>.<span>itemId </span>= itemId<span>;<br/></span><span>    </span>}<br/><br/>    <span>public </span>String <span>getName</span>() {<br/>        <span>return </span><span>name</span><span>;<br/></span><span>    </span>}<br/><br/>    <span>public void </span><span>setName</span>(String name) {<br/>        <span>this</span>.<span>name </span>= name<span>;<br/></span><span>    </span>}<br/><br/>    <span>public int </span><span>getQuantity</span>() {<br/>        <span>return </span><span>quantity</span><span>;<br/></span><span>    </span>}<br/><br/>    <span>public void </span><span>setQuantity</span>(<span>int </span>quantity) {<br/>        <span>this</span>.<span>quantity </span>= quantity<span>;<br/></span><span>    </span>}<br/><br/>    <span>public </span>String <span>getDescription</span>() {<br/>        <span>return </span><span>description</span><span>;<br/></span><span>    </span>}<br/><br/>    <span>public void </span><span>setDescription</span>(String description) {<br/>        <span>this</span>.<span>description </span>= description<span>;<br/></span><span>    </span>}<br/>}</pre>
<p>As you can see in the preceding code, this is a simple class containing <kbd>itemId</kbd>, <kbd>name</kbd>, description of the pet, and the quantity available in the store. As in the <kbd>Hello World</kbd> example, we have to initialize our JAX-RS application:</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span>javax.ws.rs.<span>ApplicationPath</span><span>;<br/></span><span>import </span>javax.ws.rs.core.Application<span>;<br/></span><span><br/></span><span>@ApplicationPath</span>(<span>"/"</span>)<br/><span>public class </span>CatalogApplication <span>extends </span>Application {<br/>}</pre>
<p><span>Finally, we are ready to write a simple JAX-RS</span> <span>resource that will serve up information about available pets from the in-memory <kbd>HashMap</kbd>:</span></p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span>org.packt.swarm.petstore.catalog.model.Item<span>;<br/></span><span><br/></span><span>import </span>javax.ws.rs.<span>GET</span><span>;<br/></span><span>import </span>javax.ws.rs.<span>Path</span><span>;<br/></span><span>import </span>javax.ws.rs.<span>PathParam</span><span>;<br/></span><span>import </span>javax.ws.rs.<span>Produces</span><span>;<br/></span><span>import </span>javax.ws.rs.core.MediaType<span>;<br/></span><span>import </span>javax.ws.rs.core.Response<span>;<br/></span><span>import </span>java.util.HashMap<span>;<br/></span><span>import </span>java.util.Map<span>;<br/></span><span><br/><strong>//1</strong><br/></span><strong>@Path("/")</strong><br/><span>public class </span>CatalogResource {<br/><br/><strong>    //2</strong><br/><strong>    private Map&lt;String, Item&gt; catalog = new HashMap&lt;&gt;()</strong><span><strong>;</strong><br/></span><span><br/></span><strong>    public CatalogResource(){</strong><br/><strong>        Item turtle = new Item();<br/>        turtle.setItemId("turtle");<br/>        turtle.setName("turtle");<br/>        turtle.setQuantity(5);<br/>        turtle.setDescription("Slow, friendly reptile. Let your busy self see how it spends 100 years of his life laying on sand and swimming.");<br/>        catalog.put("turtle", turtle);<br/>    }</strong><br/><br/><strong>    //3</strong><br/><strong>    @GET<br/>    @Path("item/{itemId}")</strong><br/><strong>    @Produces(MediaType.APPLICATION_JSON)</strong><br/><strong>    public Response searchById(@PathParam("itemId") String itemId) {</strong><br/><strong>        try {</strong><br/><strong>            Item item = catalog.get(itemId);<br/>            return Response.ok(item).build();<br/>        } catch (Exception e) {</strong><br/><strong>            return Response.status(Response.Status.BAD_REQUEST).entity(e.getMessage()).build();<br/>        }</strong><br/><strong>    }</strong><br/><br/>}</pre>
<p>Our resource is located at the root path of an application (1). In the first version, we have implemented the catalog as a <kbd>HashMap</kbd> and populated it with the first pet—<kbd>turtle</kbd> (2). The <kbd>searchById</kbd> method will be invoked when the <kbd>GET</kbd> method is invoked with the <kbd>"item"</kbd> address and the <kbd>itemId</kbd> parameter (3).</p>
<p>We can build and deploy the application as in the first chapter:</p>
<pre>mvn wildfly-swarm:run</pre>
<p>If we enter the address of the <span class="packt_screen">catalog-service</span> in the web browser, we will be able to find our first pet in the catalog:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cf2ea670-396d-4fcb-aa12-6caea794a24f.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fractions</h1>
                </header>
            
            <article>
                
<p>In the preceding example, we did the following: we annotated our classes with <span>JAX-RS</span> annotations, built the code using Swarm Maven plugin, and obtained a runnable Swarm-based JAR. The resulting JAR is much smaller than a full application server. The reason for that is that Swarm has wrapped our code in only those parts of WildFly that it needs to work. Now, we will look in greater detail at this statement.</p>
<p>Let's run the application created in the preceding chapter again:</p>
<pre>mvn wildfly-swarm:run</pre>
<p>Let's look at the beginning of the console output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ed519f6d-79e1-481f-bc43-4b522c3d629b.png"/></div>
<p>Take a look at the lines of the log in the red rectangle. Swarm is informing us that it has installed four fractions: <span>JAX-RS</span>, Undertow, Elytron, and Logging. However, what does it mean by that and what actually is a fraction?</p>
<p>The fraction is a part of the functionality needed by an application. To be more precise, fraction gathers the code and the configuration necessary for some part of the enterprise functionality to work.</p>
<p>As we have used <span>JAX-RS</span> in our service, we have added the <span>JAX-RS</span> fraction as a Maven dependency. To recall, this was the following dependency in the <kbd>pom.xml</kbd>:</p>
<pre>(...)<strong><br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.wildfly.swarm&lt;/groupId&gt;<br/>            &lt;artifactId&gt;jaxrs&lt;/artifactId&gt;<br/>            &lt;version&gt;${version.wildfly.swarm}&lt;/version&gt;<br/>        &lt;/dependency&gt;<br/><br/></strong>(...)</pre>
<p>As a result, Swarm has built a service that contains this fraction. However, by looking again at the preceding screenshot, we can see that <span>JAX-RS</span> is not the only fraction installed as there are also Undertow, Elytron, and Logging fractions present.</p>
<p>The reason for the Logging fraction presence is that there are some fractions that are necessary for all configurations—logging is one among them. What about Undertow fraction? Fractions can depend on other fractions. As you probably know, <span>JAX-RS</span> needs to use a web server to serve web pages that it generates, and as a result, the <span>JAX-RS</span> fraction requires the dependency on the Undertow plugin. Swarm has discovered that we are using <span>JAX-RS</span>, so it included it in the generated application, but it also had to analyze dependencies of that fraction. The result of this analysis showed that another fraction, namely Undertow, has to be included. Similarly, both <span>JAX-RS</span> and Undertow depend on the Elytron fraction, which is responsible for implementing the security. As a result, it too was added to the created service.</p>
<p>Now, let's take a look at what happens if we decide to refactor our catalog service and use CDI.</p>
<div class="packt_tip">Examples reference: <kbd>chapter3/catalog-service-jaxrs-cdi/</kbd>.</div>
<p>Let's move the search functionality from the <span>JAX-RS</span> resource to the CDI service:</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span>org.packt.swarm.petstore.catalog.model.Item<span>;<br/></span><span><br/></span><span>import </span>javax.enterprise.context.<span>ApplicationScoped</span><span>;<br/></span><span>import </span>java.util.HashMap<span>;<br/></span><span>import </span>java.util.Map<span>;<br/></span><span><br/><strong>//1</strong><br/></span><span><strong>@ApplicationScoped</strong><br/></span><span>public class </span>CatalogService {<br/><br/>    <span>private </span>Map&lt;String<span>, </span>Item&gt; <span>catalog </span>= <span>new </span>HashMap&lt;&gt;()<span>;<br/></span><span><br/></span><span>    public </span><span>CatalogService</span>(){<br/>        Item turtle = <span>new </span>Item()<span>;<br/></span><span>        </span>turtle.setItemId(<span>"turtle"</span>)<span>;<br/></span><span>        </span>turtle.setName(<span>"turtle"</span>)<span>;<br/></span><span>        </span>turtle.setQuantity(<span>5</span>)<span>;<br/></span><span>        </span>turtle.setDescription(<span>"Slow, friendly reptile. Let your busy self see how it spends 100 years of his life laying on sand and swimming."</span>)<span>;<br/></span><span>        </span><span>catalog</span>.put(<span>"turtle"</span><span>, </span>turtle)<span>;<br/></span><span>    </span>}<br/><br/><strong>    //2</strong><br/><strong>    public Item searchById(String itemId){</strong><br/><strong>        return catalog.get(itemId);<br/>    }</strong><br/><br/>}</pre>
<p>We created an application-scoped bean (1) and provided the <kbd>Search</kbd> method as the part of its API (2). Also, we have to modify the <kbd>CatalogResource</kbd>:</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span>org.packt.swarm.petstore.catalog.model.Item<span>;<br/></span><span><br/></span><span>import </span>javax.inject.<span>Inject</span><span>;<br/></span><span>import </span>javax.<span>ws</span>.rs.<span>GET</span><span>;<br/></span><span>import </span>javax.<span>ws</span>.rs.<span>Path</span><span>;<br/></span><span>import </span>javax.<span>ws</span>.rs.<span>PathParam</span><span>;<br/></span><span>import </span>javax.<span>ws</span>.rs.<span>Produces</span><span>;<br/></span><span>import </span>javax.<span>ws</span>.rs.core.MediaType<span>;<br/></span><span>import </span>javax.<span>ws</span>.rs.core.Response<span>;<br/></span><span><br/></span><span>@Path</span>(<span>"/"</span>)<br/><span>public class </span>CatalogResource {<br/><br/><strong>    //1</strong><br/><strong>    @Inject<br/>    private CatalogService catalogService</strong><span><strong>;</strong><br/></span><span><br/></span><span>    </span><span>@GET<br/></span><span>    @Path</span>(<span>"item/{itemId}"</span>)<br/>    <span>@Produces</span>(MediaType.<span>APPLICATION_JSON</span>)<br/>    <span>public </span>Response <span>searchByName</span>(<span>@PathParam</span>(<span>"itemId"</span>) String itemId) {<br/>        <span>try </span>{<br/><strong>            //2</strong><br/><strong>            Item item = catalogService.searchById(itemId)</strong><span><strong>;</strong><br/></span><span>            return </span>Response.<span>ok</span>(item).build()<span>;<br/></span><span>        </span>} <span>catch </span>(Exception e) {<br/>            <span>return</span></pre>
<pre>Response.<span>status</span>(Response.Status.<span>BAD_REQUEST</span>).entity(e.getMessage()).build()<span>;<br/></span><span>        </span>}<br/>    }<br/><br/>}</pre>
<p><span>We injected</span> the <kbd>CatalogService</kbd> that we have just created to it (1) and used it to look for the pet (2). Finally, we have to modify the <kbd>pom.xml</kbd>:</p>
<pre><span>(...)<br/><br/>    &lt;dependencies&gt;</span><span><br/></span><span>        &lt;dependency&gt;<br/></span><span>            &lt;groupId&gt;</span>org.wildfly.swarm<span>&lt;/groupId&gt;<br/></span><span>            &lt;artifactId&gt;</span>jaxrs<span>&lt;/artifactId&gt;<br/></span><span>            &lt;version&gt;</span>${version.wildfly.swarm}<span>&lt;/version&gt;<br/></span><span>        &lt;/dependency&gt;<br/><strong>        &lt;!-- 1 --&gt;</strong><br/></span><strong>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.wildfly.swarm&lt;/groupId&gt;<br/>            &lt;artifactId&gt;cdi&lt;/artifactId&gt;<br/>            &lt;version&gt;${version.wildfly.swarm}&lt;/version&gt;<br/></strong><span><strong>        &lt;/dependency&gt;</strong><br/></span><span><br/></span><span>    &lt;/dependencies&gt;<br/></span><br/>(...)</pre>
<p>We have to add Swarm's CDI fraction (2).</p>
<p>After doing all of the things mentioned previously in this chapter, we can build our application and see a result that is similar to the one in the preceding example.</p>
<p>Let's look at the WildFly-Swarm plugin's log again:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/aa9cea36-709b-44c0-b99e-3e160ec0af83.png" style=""/></div>
<p>We now have eight fractions present. Apart from the ones that were introduced in the preceding application, CDI, CDI-config, <kbd>Bean Validation</kbd>, and <kbd>Transactions</kbd> have been added. Again, Swarm has scanned the application and found out that it relies on <span>JAX-RS</span> and CDI; it has added those fractions and all their dependencies.</p>
<p>As you probably noted, the fractions that we see now are tightly related to Java EE specification. Can we then think of them as particular Java EE specification implementations added to the server core on demand? No. As we already know, Swarm is based on the Java EE server and part of its use case is to enable the transition from the monolith applications to microservices, there is a large group of fractions that map to the implementation of some Java EE functionalities. They are not limited to that, though. There is another group of fractions that provide functionality outside the Java EE. What is more, you are also able to implement your own fraction if you need it in your use case.</p>
<p>Look under WildFly's hood to understand how WildFly plugin works internally to create your lean Swarm application. Let's start by explaining how fraction detection works and how you can change its behavior by modifying Swarm's configuration parameters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fraction detection</h1>
                </header>
            
            <article>
                
<p>Let's return to our <span>latest</span> <kbd>CatalogService</kbd>. As you recall, it uses <span>JAX-RS</span> and CDI. We have provided the dependencies manually by editing the <kbd>pom.xml</kbd> file:</p>
<pre><span>(...)<br/></span><span><br/></span><span>    &lt;dependencies&gt;</span><span><br/></span><strong>        &lt;!-- 1 --&gt;<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.wildfly.swarm&lt;/groupId&gt;<br/>            &lt;artifactId&gt;jaxrs&lt;/artifactId&gt;<br/>            &lt;version&gt;${version.wildfly.swarm}&lt;/version&gt;<br/>        &lt;/dependency&gt;<br/><br/>        &lt;!-- 2 --&gt;<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.wildfly.swarm&lt;/groupId&gt;<br/>            &lt;artifactId&gt;cdi&lt;/artifactId&gt;<br/>            &lt;version&gt;${version.wildfly.swarm}&lt;/version&gt;<br/></strong><span><strong>        &lt;/dependency&gt;</strong><br/></span><span>    &lt;/dependencies&gt;<br/><br/></span><span>(...)</span></pre>
<p>We have provided dependencies for two fractions: <span>JAX-RS</span> (1) and CDI (2). We can run the application and note that it is indeed working.</p>
<p>Let's continue our experiment now. What happens if we configure only one fraction?</p>
<pre><span>(...)<br/></span><span>&lt;dependencyManagement&gt;<br/></span><span>    &lt;dependencies&gt;<br/><strong>        &lt;!-- 2 --&gt;</strong><br/></span><strong>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.jboss.spec&lt;/groupId&gt;<br/>            &lt;artifactId&gt;jboss-javaee-7.0&lt;/artifactId&gt;<br/>            &lt;version&gt;${version.jboss.spec.javaee.7.0}&lt;/version&gt;<br/>            &lt;type&gt;pom&lt;/type&gt;<br/>            &lt;scope&gt;import&lt;/scope&gt;<br/>        &lt;/dependency</strong><span><strong>&gt;</strong><br/></span><span>    &lt;/dependencies&gt;<br/></span><span>&lt;/dependencyManagement&gt;</span><span> <br/><br/>&lt;dependencies&gt;</span><span><br/></span><strong>   &lt;!-- 1 --&gt;<br/>   &lt;dependency&gt;<br/>       &lt;groupId&gt;org.wildfly.swarm&lt;/groupId&gt;<br/>       &lt;artifactId&gt;jaxrs&lt;/artifactId&gt;<br/>       &lt;version&gt;${version.wildfly.swarm}&lt;/version&gt;<br/>   &lt;/dependency&gt;<br/><br/>   &lt;!-- 2 --&gt;<br/>   &lt;dependency&gt;<br/>       &lt;groupId&gt;javax.enterprise&lt;/groupId&gt;<br/>       &lt;artifactId&gt;cdi-api&lt;/artifactId&gt;<br/>       &lt;scope&gt;provided&lt;/scope&gt;<br/></strong><span><strong>   &lt;/dependency&gt;</strong><br/></span><span>&lt;/dependencies&gt;<br/></span><span><br/>(...)</span></pre>
<p>In the preceding code, only the <span>JAX-RS</span> dependency is configured (1). Note that in such a case we have to explicitly define a dependency on CDI-API (2). When we run the application, we see the following log:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b10c842f-7c56-4539-b56d-9476eb90df73.png"/></div>
<p>You will see no errors yet, but the first few lines of your log already foretell that problems will occur. Although CDI is used, its fractions (and its dependents) have not been added. If we get into a browser and enter the address of our service, we will see a bad request error. Add a temporary log to service class:</p>
<pre><span>package </span><span>org</span>.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span><span>org</span>.jboss.logging.Logger<span>;<br/></span><span>import </span><span>org</span>.packt.swarm.petstore.catalog.model.Item<span>;<br/></span><span><br/></span><span>import </span>javax.inject.<span>Inject</span><span>;<br/></span><span>import </span>javax.ws.rs.<span>GET</span><span>;<br/></span><span>import </span>javax.ws.rs.<span>Path</span><span>;<br/></span><span>import </span>javax.ws.rs.<span>PathParam</span><span>;<br/></span><span>import </span>javax.ws.rs.<span>Produces</span><span>;<br/></span><span>import </span>javax.ws.rs.core.MediaType<span>;<br/></span><span>import </span>javax.ws.rs.core.Response<span>;<br/></span><span><br/></span><span>@Path</span>(<span>"/"</span>)<br/><span>public class </span>CatalogResource {<br/><br/>    <strong>private final Logger log = Logger.getLogger(getClass())</strong><span><strong>;</strong><br/></span><span><br/></span><span>    </span><span>@Inject<br/></span><span>    </span><span>private </span>CatalogService <span>catalogService</span><span>;<br/></span><span><br/></span><span>    </span><span>@GET<br/></span><span>    @Path</span>(<span>"item/{itemId}"</span>)<br/>    <span>@Produces</span>(MediaType.<span>APPLICATION_JSON</span>)<br/>    <span>public </span>Response <span>searchByName</span>(<span>@PathParam</span>(<span>"itemId"</span>) String itemId) {<br/>        <span>try </span>{<br/>            Item item = <span>catalogService</span>.searchById(itemId)<span>;<br/></span><span>            return </span>Response.<span>ok</span>(item).build()<span>;<br/></span><span>        </span>} <span>catch </span>(Exception e) {<br/>            <strong>log.error("BAD REQUEST", e)</strong><span><strong>;</strong><br/></span><span>            return </span>Response.<span>status</span>(Response.Status.<span>BAD_REQUEST</span>).entity(e.getMessage()).build()<span>;<br/></span><span>        </span>}<br/>    }<br/><br/>}</pre>
<p class="mce-root">We will be able to note the cause of our problem:</p>
<pre><span>ERROR [org.packt.swarm.petstore.catalog.CatalogResource] (default task-1) Bad request: java.lang.NullPointerException<br/>        at org.packt.swarm.petstore.catalog.CatalogResource.searchByName(CatalogResource.java:27)<br/>        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br/>        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br/>        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br/>        at java.lang.reflect.Method.invoke(Method.java:498)<br/>        at org.jboss.resteasy.core.MethodInjectorImpl.invoke(MethodInjectorImpl.java:140)<br/>        at org.jboss.resteasy.core.ResourceMethodInvoker.invokeOnTarget(ResourceMethodInvoker.java:295)<br/>        at org.jboss.resteasy.core.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:249)<br/>        at org.jboss.resteasy.core.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:236)<br/>        at org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:406)<br/>        at org.jboss.resteasy.core.SynchronousDispatcher.invoke(SynchronousDispatcher.java:213)<br/>        at org.jboss.resteasy.plugins.server.servlet.ServletContainerDispatcher.service(ServletContainerDispatcher.java:228)<br/>        at org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(HttpServletDispatcher.java:56)<br/>        at org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(HttpServletDispatcher.java:51)<br/>        at javax.servlet.http.HttpServlet.service(HttpServlet.java:790)</span></pre>
<p>Owing to missing CDI fraction, bean resolution and injection were not performed. As a result, the service object was not injected into the <kbd>CatalogResource</kbd> resource, resulting in <kbd>NullPointerException</kbd>.</p>
<p>Let's get one step further and remove all the fractions:</p>
<pre><span><br/></span><span>&lt;dependencies&gt;<br/><strong>    &lt;!-- 2 --&gt;</strong><br/></span><strong>    &lt;dependency&gt;</strong><br/><strong>        &lt;groupId&gt;org.jboss.spec.javax.ws.rs&lt;/groupId&gt;</strong><br/><strong>        &lt;artifactId&gt;jboss-jaxrs-api_2.0_spec&lt;/artifactId&gt;</strong><br/><strong>        &lt;scope&gt;provided&lt;/scope&gt;</strong><br/><strong>    &lt;/dependency&gt;</strong><strong><br/></strong>    &lt;dependency&gt;<br/>        &lt;groupId&gt;javax.enterprise&lt;/groupId&gt;<br/>        &lt;artifactId&gt;cdi-api&lt;/artifactId&gt;<br/>        &lt;scope&gt;provided&lt;/scope&gt;<br/>    &lt;/dependency&gt;<span><br/><strong>        &lt;!-- 1 --&gt;</strong><br/><strong>        &lt;!-- no fractions here ... --&gt;</strong></span><span><br/></span><span>    &lt;/dependencies&gt;<br/></span><span><br/>(...)<br/></span></pre>
<p>We have removed all the fractions (1). Please note that in such a case we have to provide all of the Java EE APIs manually (2).</p>
<div class="packt_tip packt_infobox">Example reference: <kbd>chapter3/catalog-service-auto-detect/</kbd>.</div>
<p>When we build the project configured this way, we will see something interesting in the log:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9374c6d1-9525-46f9-94d7-88c8dba1d692.png" style=""/></div>
<p>In the preceding example, Swarm has performed automatic fraction detection. How does it work?</p>
<p>Swarm found out that <kbd>org.packt.swarm.petstore.catalog.CatalogResource</kbd> is using the classes from the <kbd>javax.ws.rs</kbd> package, which resulted in the inclusion of <span>JAX-RS</span>. Similarly, usage of the <kbd>javax.inject</kbd> package led to the inclusion of the CDI fraction. Later, as in manual examples, Swarm has a build service that contains the detected fractions, their dependencies, and fractions that are always needed. If you run the service now, you will note that it is indeed working correctly.</p>
<p>In order to understand why Swarm behaved in the described way in the recent examples, we must learn about fraction detection mode. Let's do it now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fraction detection mode</h1>
                </header>
            
            <article>
                
<p>Swarm Maven plugin can work in different fraction detection modes. If you do not provide fraction dependencies manually, it runs in the when-missing mode. We have already seen the behavior of this mode in our previous examples: when no direct fraction dependency is provided, the plugin performs auto-detection. On the other hand, if we provide at least one fraction dependency manually, the auto-detection mode is turned off. This is the reason why our last example wasn't built with the CDI fraction included: adding the <span>JAX-RS</span> fraction manually turned auto-detection off.</p>
<p>Is there something we can do about it? Yup, we can use a different detection mode: <kbd>force</kbd>. This mode makes auto-detection work every time. After detecting the fractions that are used, it merges the detection result with fractions configured by the user.</p>
<div class="packt_infobox">Example reference: <kbd>chapter3/catalog-service-force-detect</kbd>.</div>
<p>Let's reconfigure our example to make it work:</p>
<pre><span>(...)<br/></span><span><br/></span><span>    &lt;dependencies&gt;</span><span><br/></span><span>        &lt;dependency&gt;<br/></span><span>            &lt;groupId&gt;</span>javax.enterprise<span>&lt;/groupId&gt;<br/></span><span>            &lt;artifactId&gt;</span>cdi-api<span>&lt;/artifactId&gt;<br/></span><span>            &lt;scope&gt;</span>provided<span>&lt;/scope&gt;<br/></span><span>        &lt;/dependency&gt;<br/></span><strong>        &lt;!-- 1 --&gt;<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.wildfly.swarm&lt;/groupId&gt;<br/>            &lt;artifactId&gt;jaxrs&lt;/artifactId&gt;<br/>            &lt;version&gt;${version.wildfly.swarm}&lt;/version&gt;<br/></strong><span><strong>        &lt;/dependency&gt;</strong><br/></span><span>    &lt;/dependencies&gt;<br/></span><span><br/></span><span>    &lt;build&gt;<br/></span><span>        &lt;plugins&gt;<br/></span><span>            &lt;plugin&gt;<br/></span><span>                &lt;artifactId&gt;</span>maven-war-plugin<span>&lt;/artifactId&gt;<br/></span><span>                &lt;version&gt;</span>${version.war.plugin}<span>&lt;/version&gt;<br/></span><span>                &lt;configuration&gt;<br/></span><span>                    &lt;failOnMissingWebXml&gt;</span>false<span>&lt;/failOnMissingWebXml&gt;<br/></span><span>                &lt;/configuration&gt;<br/></span><span>            &lt;/plugin&gt;<br/></span><span>            &lt;plugin&gt;<br/></span><span>                &lt;groupId&gt;</span>org.wildfly.swarm<span>&lt;/groupId&gt;<br/></span><span>                &lt;artifactId&gt;</span>wildfly-swarm-plugin<span>&lt;/artifactId&gt;<br/></span><span>                &lt;version&gt;</span>${version.wildfly.swarm}<span>&lt;/version&gt;<br/><strong>                &lt;!-- 2 --&gt;</strong><br/></span><strong>                &lt;configuration&gt;<br/>                    &lt;fractionDetectMode&gt;force&lt;/fractionDetectMode&gt;<br/></strong><span><strong>                &lt;/configuration&gt;</strong><br/></span><span>                &lt;executions&gt;<br/></span><span>                    &lt;execution&gt;<br/></span><span>                        &lt;goals&gt;<br/></span><span>                            &lt;goal&gt;</span>package<span>&lt;/goal&gt;<br/></span><span>                        &lt;/goals&gt;<br/></span><span>                    &lt;/execution&gt;<br/></span><span>                &lt;/executions&gt;<br/></span><span>            &lt;/plugin&gt;<br/></span><span>        &lt;/plugins&gt;<br/></span><span>    &lt;/build&gt;<br/></span><span><br/></span><span>&lt;/project&gt;</span></pre>
<p>Again, only the <span>JAX-RS</span> fraction is configured (1); however, because we have configured the Maven plugin with the <kbd>force</kbd> detection mode (2), Swarm will <span>also</span> detect the previously missing CDI fraction. If we run our application again, we will see that all necessary fractions were detected and the application works correctly.</p>
<p>We have seen two fraction detection modes: when-missing and <kbd>force</kbd>. Is there another? Yes, there is one more: <em>never</em>. In this mode, as its name implies, the fractions are never detected, and you always have to provide all of them manually.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Thin and hollow JARs</h1>
                </header>
            
            <article>
                
<p>As we said before, during the standard Maven plugin operation, the resulting application contains both the Swarm server and the application that is deployed on it. We can change that behavior. Let's suppose that we deploy our application in the cloud and later push new changes to its code. Since it is the application code that changes in most cases, we would like to create the container with the server in the cloud and later push <span>only</span> code to it. How are we able to do it? By using hollow JARs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using hollow JARs</h1>
                </header>
            
            <article>
                
<p>You are able to configure the Maven plugin to build hollow JARs, which contain the swarm server without the actual application deployed on it. Let's return to the <span>JAX-RS</span> + CDI example again to show how it works.</p>
<div class="packt_infobox">Example reference: <kbd>chapter3/catalog-service-hollow-jar</kbd>.</div>
<p>The first thing that we will need to do is configure the Maven plugin:</p>
<pre><span>(...)<br/><br/></span><span>    &lt;build&gt;<br/></span><span>        &lt;plugins&gt;<br/></span><span>            &lt;plugin&gt;<br/></span><span>                &lt;artifactId&gt;</span>maven-war-plugin<span>&lt;/artifactId&gt;<br/></span><span>                &lt;version&gt;</span>${version.war.plugin}<span>&lt;/version&gt;<br/></span><span>                &lt;configuration&gt;<br/></span><span>                    &lt;failOnMissingWebXml&gt;</span>false<span>&lt;/failOnMissingWebXml&gt;<br/></span><span>                &lt;/configuration&gt;<br/></span><span>            &lt;/plugin&gt;<br/></span><span>            &lt;plugin&gt;<br/></span><span>                &lt;groupId&gt;</span>org.wildfly.swarm<span>&lt;/groupId&gt;<br/></span><span>                &lt;artifactId&gt;</span>wildfly-swarm-plugin<span>&lt;/artifactId&gt;<br/></span><span>                &lt;version&gt;</span>${version.wildfly.swarm}<span>&lt;/version&gt;<br/></span><strong>                &lt;!-- 1 --&gt;<br/>                &lt;configuration&gt;<br/>                    &lt;hollow&gt;true&lt;/hollow&gt;<br/></strong><span><strong>                &lt;/configuration&gt;</strong><br/></span><span>                &lt;executions&gt;<br/></span><span>                    &lt;execution&gt;<br/></span><span>                        &lt;goals&gt;<br/></span><span>                            &lt;goal&gt;</span>package<span>&lt;/goal&gt;<br/></span><span>                        &lt;/goals&gt;<br/></span><span>                    &lt;/execution&gt;<br/></span><span>                &lt;/executions&gt;<br/></span><span>            &lt;/plugin&gt;<br/></span><span>        &lt;/plugins&gt;<br/></span><span>    &lt;/build&gt;<br/></span><span>(...)</span></pre>
<p>The only thing that we have to do is to enable the hollow configuration parameter (1). When we build the application and navigate to our target directory, we will see the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3f141a9c-0e43-4481-9f56-334cdca95fd9.png" style=""/></div>
<p>As you can see in the preceding screenshot, one directory ends with the <kbd>-hollow-swarm</kbd> suffix. This is our hollow jar without the deployed application. When running it, we must provide the name of the application that we will deploy on the created server. We will be able to do it in the following way:</p>
<pre><span>java jar catalog-1.0-hollow-swarm.jar catalog-1.0.war<br/></span></pre>
<p>This will start the container and run our application. As a result, it will behave in the same way as the original example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using thin JARs</h1>
                </header>
            
            <article>
                
<p>You will be able to create a thin JAR. A thin JAR does not contain its Maven dependencies and loads them during application startup from a local or remote Maven repository.</p>
<div class="packt_infobox">Example reference: <kbd>chapter3/catalog-service-thin-jar</kbd>.</div>
<p>Let's take a look at an example:</p>
<pre><span>(...)<br/></span><span><br/></span><span>    &lt;build&gt;<br/></span><span>        &lt;plugins&gt;<br/></span><span>            &lt;plugin&gt;<br/></span><span>                &lt;artifactId&gt;</span>maven-war-plugin<span>&lt;/artifactId&gt;<br/></span><span>                &lt;version&gt;</span>${version.war.plugin}<span>&lt;/version&gt;<br/></span><span>                &lt;configuration&gt;<br/></span><span>                    &lt;failOnMissingWebXml&gt;</span>false<span>&lt;/failOnMissingWebXml&gt;<br/></span><span>                &lt;/configuration&gt;<br/></span><span>            &lt;/plugin&gt;<br/></span><span>            &lt;plugin&gt;<br/></span><span>                &lt;groupId&gt;</span>org.wildfly.swarm<span>&lt;/groupId&gt;<br/></span><span>                &lt;artifactId&gt;</span>wildfly-swarm-plugin<span>&lt;/artifactId&gt;<br/></span><span>                &lt;version&gt;</span>${version.wildfly.swarm}<span>&lt;/version&gt;<br/></span><strong>                &lt;!-- 1 --&gt;<br/>                &lt;configuration&gt;<br/>                    &lt;bundleDependencies&gt;false&lt;/bundleDependencies&gt;<br/></strong><span><strong>                &lt;/configuration&gt;</strong><br/></span><span>                &lt;executions&gt;<br/></span><span>                    &lt;execution&gt;<br/></span><span>                        &lt;goals&gt;<br/></span><span>                            &lt;goal&gt;</span>package<span>&lt;/goal&gt;<br/></span><span>                        &lt;/goals&gt;<br/></span><span>                    &lt;/execution&gt;<br/></span><span>                &lt;/executions&gt;<br/></span><span>            &lt;/plugin&gt;<br/></span><span>        &lt;/plugins&gt;<br/></span><span>    &lt;/build&gt;<br/></span><span><br/></span>(...)</pre>
<p>When we build the application and look at the target directory, we get the following result:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/793ebc5f-22ea-4c9b-8931-51db0c9871c8.png" style=""/></div>
<p>Note that in the preceding scenario, all the JARs are very small with the runnable JAR of <kbd>744</kbd> KB.</p>
<p>You also have the possibility to mix thin JARs with hollow JARs. The runnable JAR does not contain the application that has to be deployed on it, so it has to be run in the same way as in the preceding example:</p>
<pre><span>java jar catalog-1.0-hollow-swarm.jar catalog-1.0.war</span></pre>
<p>Both the server and the deployment do not contain bundled dependencies, so they have to be loaded from the Maven repository using the application deployment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned how Swarm creates runnable, right-sized services. You learned what a fraction <span>is</span>, how the fraction detection process looks, and how you can modify it. Finally, you learned how to create hollow and thin JARs.</p>
<p>In the next chapter, we will show you how to configure your microservices.</p>
<p> </p>
<p> </p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>