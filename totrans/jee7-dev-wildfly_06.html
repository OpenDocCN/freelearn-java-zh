<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;6.&#xA0;Developing Applications with JBoss JMS Provider"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06" class="calibre1"/>Chapter 6. Developing Applications with JBoss JMS Provider</h1></div></div></div><p class="calibre8">Messaging is a method of communication between software components and applications. <span class="strong"><strong class="calibre9">Java Message Service</strong></span> (<span class="strong"><strong class="calibre9">JMS</strong></span>) is a Java API—designed originally by Sun—that allows applications to create, send, receive, and read messages. The new 2.0 version of the API has been introduced with JSR 343 (<a class="calibre1" href="https://jcp.org/en/jsr/detail?id=343">https://jcp.org/en/jsr/detail?id=343</a>).</p><p class="calibre8">Messaging <a id="id623" class="calibre1"/>differs from other standard protocols, such as <span class="strong"><strong class="calibre9">Remote Method Invocation</strong></span> (<span class="strong"><strong class="calibre9">RMI</strong></span>) or <span class="strong"><strong class="calibre9">Hypertext Transfer Protocol</strong></span> (<span class="strong"><strong class="calibre9">HTTP</strong></span>), in<a id="id624" class="calibre1"/> two ways. First, the conversation is mediated by a messaging server so it's not a two-way conversation between peers. Second, the sender and the receiver need to know what message format and what destination to use. This is in contrast to tightly coupled technologies, such as Remote Method Invocation (RMI), that require an application to know about a remote application's methods.</p><p class="calibre8">In this chapter, we will cover the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A brief introduction to message-oriented systems</li><li class="listitem">The building blocks of the JBoss messaging subsystem</li><li class="listitem">Setting up proof of concept programming examples</li><li class="listitem">How to use JMS and resource adapters to integrate with external systems</li></ul></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Developing Applications with JBoss JMS Provider">
<div class="book" title="A short introduction to JMS"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch06lvl1sec30" class="calibre1"/>A short introduction to JMS</h1></div></div></div><p class="calibre8">JMS defines <a id="id625" class="calibre1"/>a vendor-neutral (but Java-specific) set of programming interfaces to interact with asynchronous messaging systems. Messaging enables distributed communication that is loosely coupled. The whole messaging interchange is a two-step process where a component sends a message to a destination that is in turn retrieved by the recipient with the mediation of the JMS server. In JMS, there are two types of destinations: topics and queues. These have different semantics, which are explained next.</p><p class="calibre8">In a point-to-point model, messages are <a id="id626" class="calibre1"/>sent from producers to consumers via queues. A given queue might have multiple receivers, but only one receiver would be able to consume each of the messages. Only the first receiver who requests the message will get it, while the others will not, as shown in the following image:</p><div class="mediaobject"><img src="../images/00051.jpeg" alt="A short introduction to JMS" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">A message sent to a <span class="strong"><strong class="calibre9">topic</strong></span>, on the other hand, might be received by multiple parties. Messages published on a specific topic are sent to all the message consumers who have registered (subscribed) themselves <a id="id627" class="calibre1"/>to receive messages on that topic. A<a id="id628" class="calibre1"/> subscription can be <span class="strong"><strong class="calibre9">durable</strong></span> or <span class="strong"><strong class="calibre9">nondurable</strong></span>. A <a id="id629" class="calibre1"/>nondurable subscriber can only receive messages<a id="id630" class="calibre1"/> that are published while it is <span class="strong"><strong class="calibre9">active</strong></span>. A nondurable subscription does not guarantee the delivery of a message; it might deliver the same message more than once. A durable subscription, on the other hand, guarantees that the consumer receives the message exactly once, as depicted in the following image:</p><div class="mediaobject"><img src="../images/00052.jpeg" alt="A short introduction to JMS" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">As far as <a id="id631" class="calibre1"/>message consumption is concerned, even though JMS is inherently asynchronous, the JMS specification allows messages to be consumed in either of the following two ways:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Synchronously</strong></span>: A subscriber or a <a id="id632" class="calibre1"/>receiver explicitly fetches the message from the destination<a id="id633" class="calibre1"/> by calling the <code class="email">receive()</code> method of any <code class="email">MessageConsumer</code> instance. The <code class="email">receive()</code> method can block until a message <a id="id634" class="calibre1"/>arrives or can take a time out if a message does not arrive within a specified time limit.</li><li class="listitem"><span class="strong"><strong class="calibre9">Asynchronously</strong></span>: With the asynchronous <a id="id635" class="calibre1"/>mode, the client must implement the <code class="email">javax.jms.MessageListener</code> interface and overwrite the <code class="email">onMessage()</code> method. Whenever <a id="id636" class="calibre1"/>a message arrives at the destination, the JMS provider delivers the message by calling the listener's <code class="email">onMessage</code> method, which acts on the contents of the message.</li></ul></div><p class="calibre8">A JMS message consists of a header, properties, and a body. The message headers provide a fixed set of metadata fields that describe the message with information such as where the message is going and when it is received. The properties are a set of key-value pairs used for application-specific purposes, usually to help filter messages quickly when they are received. Finally, the body contains whatever data is being sent to the message.</p><p class="calibre8">The JMS<a id="id637" class="calibre1"/> API supports two delivery modes for messages to specify whether or not the messages are lost if the JMS provider fails, indicated by the following constants:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The<a id="id638" class="calibre1"/> <span class="strong"><strong class="calibre9">persistent</strong></span> delivery mode, which is <a id="id639" class="calibre1"/>the default, instructs the JMS provider to take extra care to ensure that a message is not lost in transit in the case of a JMS provider failure. A message sent with this delivery mode is logged to stable storage when it is sent.</li><li class="listitem">The<a id="id640" class="calibre1"/> <span class="strong"><strong class="calibre9">nonpersistent</strong></span> delivery mode does<a id="id641" class="calibre1"/> not require the JMS provider to store the message<a id="id642" class="calibre1"/> or otherwise guarantee that it is not lost if the provider fails.</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="The building blocks of JMS"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec31" class="calibre1"/>The building blocks of JMS</h1></div></div></div><p class="calibre8">The basic <a id="id643" class="calibre1"/>building blocks of any JMS application consist of the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Administered objects—connection factories and destinations</li><li class="listitem">Connections</li><li class="listitem">Sessions</li><li class="listitem">Message producers</li><li class="listitem">Message consumers</li><li class="listitem">Messages</li></ul></div><p class="calibre8">Let's take a closer look at them:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Connection factory</strong></span>: This object encapsulates a set of connection configuration parameters that have been defined by an administrator. A client uses it to <a id="id644" class="calibre1"/>create a connection<a id="id645" class="calibre1"/> with a JMS provider. A connection factory hides provider-specific details from JMS clients and abstracts administrative information into objects in the Java programming language.</li><li class="listitem"><span class="strong"><strong class="calibre9">Destination</strong></span>: This is the component a client uses to specify the target of messages it produces and the source of messages it consumes. In the <span class="strong"><strong class="calibre9">point-to-point</strong></span> (<span class="strong"><strong class="calibre9">PTP</strong></span>) messaging <a id="id646" class="calibre1"/>domain, destinations are called <a id="id647" class="calibre1"/>queues; in the <span class="strong"><strong class="calibre9">publish/subscribe (pub/sub)</strong></span> messaging <a id="id648" class="calibre1"/>domain, destinations are called topics.</li><li class="listitem"><span class="strong"><strong class="calibre9">Connection</strong></span>: This <a id="id649" class="calibre1"/>encapsulates a virtual<a id="id650" class="calibre1"/> connection with a JMS provider. A connection could represent an open TCP/IP socket between a client and a provider service. You use a connection to create one or more sessions.</li><li class="listitem"><span class="strong"><strong class="calibre9">Session</strong></span>: This is <a id="id651" class="calibre1"/>a single-threaded context for <a id="id652" class="calibre1"/>producing and consuming messages. You use sessions to create message producers, message consumers, and messages. Sessions serialize the execution of message listeners and provide a transactional context with which to group a set of sends and receives into an atomic unit of work.</li><li class="listitem"><span class="strong"><strong class="calibre9">Message producer</strong></span>: This is an object created by a session and is used to send messages<a id="id653" class="calibre1"/> to a destination. The PTP <a id="id654" class="calibre1"/>form of a message producer implements the <code class="email">QueueSender</code> interface. The pub/sub form implements the <code class="email">TopicPublisher</code> interface. From JMS 2.0, it is possible to rely only on the <code class="email">JMSProducer</code> interface.</li><li class="listitem"><span class="strong"><strong class="calibre9">Message consumer</strong></span>: This is an object created by a session and is used to receive<a id="id655" class="calibre1"/> messages sent to a destination. A <a id="id656" class="calibre1"/>message consumer allows a JMS client to register interest in a destination with a JMS provider. The JMS provider<a id="id657" class="calibre1"/> manages the delivery of messages from a destination to the registered consumers of the destination. The PTP form of message consumer implements the <code class="email">QueueReceiver</code> interface. The pub/sub form implements the <code class="email">TopicSubscriber</code> interface. The latest JMS version supports a new <code class="email">JMSConsumer</code> API.</li></ul></div></div>

<div class="book" title="The building blocks of JMS">
<div class="book" title="The JBoss messaging subsystem"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec48" class="calibre1"/>The JBoss messaging subsystem</h2></div></div></div><p class="calibre8">JBoss<a id="id658" class="calibre1"/> AS has used different JMS implementations <a id="id659" class="calibre1"/>across its releases, such as JBoss MQ and JBoss<a id="id660" class="calibre1"/> Messaging. Since JBoss AS 6.0, the default JMS provider is <span class="strong"><strong class="calibre9">HornetQ</strong></span> (<a class="calibre1" href="http://www.jboss.org/hornetq">http://www.jboss.org/hornetq</a>), which provides a multiprotocol, embeddable, high-performant, and clusterable messaging system.</p><p class="calibre8">At its core, HornetQ is designed simply as a set of <span class="strong"><strong class="calibre9">Plain Old Java Objects</strong></span> (<span class="strong"><strong class="calibre9">POJOs</strong></span>) with few<a id="id661" class="calibre1"/> dependencies on external JAR files. In fact, the only<a id="id662" class="calibre1"/> one JAR dependency is the Netty library, which leverages the Java<span class="strong"><strong class="calibre9"> New Input-Output</strong></span> (<span class="strong"><strong class="calibre9">NIO</strong></span>) API to build high-performance network applications.</p><p class="calibre8">Because of its easily adaptable architecture, HornetQ can be embedded in your own project or instantiated in any dependency injection framework such as JBossMicrocontainer, Spring, or Google Guice.</p><p class="calibre8">In this book, we will cover a scenario where HornetQ is integrated into the WildFly subsystem as a module, as shown in the following diagram. This diagram depicts how the JCA Adapter and the HornetQ server fit in the overall picture:</p><div class="mediaobject"><img src="../images/00053.jpeg" alt="The JBoss messaging subsystem" class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div class="book" title="The building blocks of JMS">
<div class="book" title="Creating and using connection factories"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec49" class="calibre1"/>Creating and using connection factories</h2></div></div></div><p class="calibre8">It is<a id="id663" class="calibre1"/> the job of the connection factory that encapsulates<a id="id664" class="calibre1"/> the connection's parameters to create new <a id="id665" class="calibre1"/>JMS connections. A connection factory is <a id="id666" class="calibre1"/>bound to the <span class="strong"><strong class="calibre9">Java Naming Directory Index</strong></span> (<span class="strong"><strong class="calibre9">JNDI</strong></span>) and can <a id="id667" class="calibre1"/>be looked up by both local and remote clients, provided they supply the correct environment parameters. Since a connection factory can be reused multiple times in your code, it's the kind of object that can be conveniently cached by a remote client or a message-driven bean.</p><p class="calibre8">The definition of connection-factory instances is included in the <code class="email">full</code> and <code class="email">full-ha</code> server configurations. You can choose either of the server configurations using the <code class="email">–c</code> command argument, for instance, <code class="email">standalone.bat –c standalone-full.xml</code>. We will cover the configuration profiles in depth in <a class="calibre1" title="Chapter 9. Managing the Application Server" href="part0048_split_000.html#page">Chapter 9</a>, <span class="strong"><em class="calibre10">Managing the Application Server</em></span>. For now, just remember to start your server with the full configuration profile whenever you need JMS.</p><p class="calibre8">You can inspect the connection factories in the overall JMS configuration, which is available by surfing the admin console and navigating to <span class="strong"><strong class="calibre9">Configuration</strong></span> | <span class="strong"><strong class="calibre9">Messaging Destinations</strong></span> | <span class="strong"><strong class="calibre9">Connection Factories</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00054.jpeg" alt="Creating and using connection factories" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">As you can see in the previous screenshot, there are the following two out-of-the-box connection-factory definitions:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">InVmConnectionFactory</strong></span>: This connection factory is bound under the <code class="email">java:/ConnectionFactory</code> entry and is used when the server and client are part <a id="id668" class="calibre1"/>of the same process (that is, they are running on the same JVM).</li><li class="listitem"><span class="strong"><strong class="calibre9">RemoteConnectionFactory</strong></span>: This connection factory is bounded under the <code class="email">java:jboss/exported/jms/RemoteConnectionFactory</code> entry, and as the name<a id="id669" class="calibre1"/> implies, it can be used using Netty as the connector when JMS connections are provided by a remote server.</li></ul></div><p class="calibre8">If you<a id="id670" class="calibre1"/> want to change the connection factory's <a id="id671" class="calibre1"/>JNDI binding, the simplest choice is to go <a id="id672" class="calibre1"/>through<a id="id673" class="calibre1"/> the server configuration file (for example, <code class="email">standalone-full.xml</code>, for a standalone mode):</p><div class="informalexample"><pre class="programlisting">&lt;connection-factory name="InVmConnectionFactory"&gt;
      &lt;connectors&gt;
        &lt;connector-ref connector-name="in-vm"/&gt;
   &lt;/connectors&gt;
   &lt;entries&gt;
<span class="strong"><strong class="calibre9">     &lt;entry name="java:/ConnectionFactory"/&gt;</strong></span>
   &lt;/entries&gt;
&lt;/connection-factory&gt;
&lt;connection-factory name="RemoteConnectionFactory"&gt;
   &lt;connectors&gt;
     &lt;connector-ref connector-name="http-connector"/&gt;
   &lt;/connectors&gt;
   &lt;entries&gt;
<span class="strong"><strong class="calibre9">     &lt;entry name="java:jboss/exported/jms/RemoteConnectionFactory"/&gt;</strong></span>
   &lt;/entries&gt;
&lt;/connection-factory&gt;
&lt;pooled-connection-factory name="hornetq-ra"&gt;
&lt;transaction mode="xa"/&gt;
   &lt;connectors&gt;
      &lt;connector-ref connector-name="in-vm"/&gt;
   &lt;/connectors&gt;
   &lt;entries&gt;
<span class="strong"><strong class="calibre9">        &lt;entry name="java:/JmsXA"/&gt;</strong></span>
<span class="strong"><strong class="calibre9">      &lt;entry name="java:jboss/DefaultJMSConnectionFactory"/&gt;</strong></span>
    &lt;/entries&gt;
&lt;/pooled-connection-factory&gt;</pre></div><p class="calibre8">The connection factory can be injected just like any other Java EE resource; the following code fragment shows how a stateless EJB gets the default connection factory injected:</p><div class="informalexample"><pre class="programlisting">@Stateless
public class SampleEJB {

<span class="strong"><strong class="calibre9">    @Resource(mappedName = "java:/ConnectionFactory")</strong></span>
<span class="strong"><strong class="calibre9">    private ConnectionFactory cf; </strong></span>
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note29" class="calibre1"/>Note</h3><p class="calibre8">In <a id="id674" class="calibre1"/>order <a id="id675" class="calibre1"/>to use<a id="id676" class="calibre1"/> the messaging subsystem, you <a id="id677" class="calibre1"/>have to start WildFly using a Java EE full profile, which includes the messaging subsystem. So, for example, if you want to start a standalone server instance that is JMS-aware, you can simply use the following code:</p><div class="informalexample"><pre class="programlisting">standalone.sh –c standalone-full.xml</pre></div></div></div></div>

<div class="book" title="The building blocks of JMS">
<div class="book" title="Using JMS destinations"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec50" class="calibre1"/>Using JMS destinations</h2></div></div></div><p class="calibre8">Along <a id="id678" class="calibre1"/>with the definition of connection factories, you will need <a id="id679" class="calibre1"/>to learn how to configure JMS destinations (queues and topics).</p><p class="calibre8">This can be achieved with a variety of instruments. Since we have started dealing with the web console, just navigate to the <span class="strong"><strong class="calibre9">Configuration</strong></span> tab and pick the <span class="strong"><strong class="calibre9">Messaging</strong></span> subsystem from the left panel. Select <span class="strong"><strong class="calibre9">Destinations</strong></span> and click on the <span class="strong"><strong class="calibre9">View</strong></span> central link.</p><p class="calibre8">From there, you<a id="id680" class="calibre1"/> can use the upper menu tab that contains a set of options, the first one of which—named <span class="strong"><strong class="calibre9">Queues/Topics</strong></span>—can be used to configure your JMS destinations, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00055.jpeg" alt="Using JMS destinations" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Now click <a id="id681" class="calibre1"/>on the <span class="strong"><strong class="calibre9">Add</strong></span> button. You should see the following dialog:</p><div class="mediaobject"><img src="../images/00056.jpeg" alt="Using JMS destinations" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Enter the <a id="id682" class="calibre1"/>mandatory name for your destination and its JNDI. You<a id="id683" class="calibre1"/> can optionally choose to define your JMS destination as either of the following options:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Durable</strong></span>: This <a id="id684" class="calibre1"/>option allows the JMS server to hold on to a message in case the subscriber is temporarily unavailable.</li><li class="listitem"><span class="strong"><strong class="calibre9">Selector</strong></span>: This<a id="id685" class="calibre1"/> option allows a filter to the JMS destination (we will cover this in greater detail later in this chapter).</li></ul></div><p class="calibre8">Click on the <span class="strong"><strong class="calibre9">Save</strong></span> button and verify that the queue has been enlisted among the JMS destinations.</p><p class="calibre8">The preceding change will reflect in the server configuration file as follows:</p><div class="informalexample"><pre class="programlisting">&lt;jms-destinations&gt;
   &lt;jms-queue name="TicketQueue"&gt;
      &lt;entry name="java:jboss/jms/queue/ticketQueue"/&gt;
         &lt;durable&gt;false&lt;/durable&gt;
   &lt;/jms-queue&gt;
&lt;/jms-destinations&gt;</pre></div><p class="calibre8">It's worth <a id="id686" class="calibre1"/>noting that the JMS configuration usually differs <a id="id687" class="calibre1"/>on every application server. In this chapter, we will cover only the approach used in WildFly, but the key concepts between different providers stay the same.</p></div></div>

<div class="book" title="The building blocks of JMS">
<div class="book" title="Adding message-driven beans to your application"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch06lvl2sec51" class="calibre1"/>Adding message-driven beans to your application</h2></div></div></div><p class="calibre8">Once <a id="id688" class="calibre1"/>we do the configuration, we <a id="id689" class="calibre1"/>can start coding a JMS message consumer, such <a id="id690" class="calibre1"/>as a message-driven bean.</p><p class="calibre8"><span class="strong"><strong class="calibre9">Message-driven beans</strong></span> (<span class="strong"><strong class="calibre9">MDBs</strong></span>) are stateless, server-side, and transaction-aware components <a id="id691" class="calibre1"/>that process asynchronous JMS messages.</p><p class="calibre8">One of the<a id="id692" class="calibre1"/> most important aspects of message-driven beans is that they can consume and process messages concurrently. This capability provides a significant advantage over traditional JMS clients, which must be custom built to manage resources, transactions, and security in a multithreaded environment. MDB containers manage concurrency automatically so the bean developer can focus on the business logic of processing the messages. An MDB can receive hundreds of JMS messages from various applications and process them all at the same time because numerous instances of it can be executed concurrently in the container.</p><p class="calibre8">From the semantic point of view, an MDB is classified as an enterprise bean, just like a session or entity bean, but there are some important differences. At first, the message-driven bean does not have component interfaces. These are absent because the message-driven bean is not accessible via the Java RMI API; it responds only to asynchronous messages.</p><p class="calibre8">Just as the entity and session beans have well-defined life cycles, so does the MDB bean. The MDB instance's life cycle has two states, <span class="strong"><strong class="calibre9">Does not Exist</strong></span> and <span class="strong"><strong class="calibre9">Method ready Pool</strong></span>, as shown<a id="id693" class="calibre1"/> in<a id="id694" class="calibre1"/> the following image:</p><div class="mediaobject"><img src="../images/00057.jpeg" alt="Adding message-driven beans to your application" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">When<a id="id695" class="calibre1"/> a message is received, the EJB <a id="id696" class="calibre1"/>container checks to see whether<a id="id697" class="calibre1"/> any MDB instance is available in the pool. If a bean is available in the free pool, JBoss uses that instance. Once an MDB instance's <code class="email">onMessage()</code> method is returned, the request is complete and the instance is placed back in the free pool. This results in the best response time, as the request is served without waiting for a new instance to be created.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note30" class="calibre1"/>Note</h3><p class="calibre8">On the other hand, if all the instances in the pool are busy, the new request will be serialized since it's guaranteed that the same instance will not be allowed to serve multiple clients at the same time. Also, if a client sends out multiple messages to the server containing an MDB, there is no guarantee that the same MDB instance will be used for each message or that the messages will be processed in the order in which the client sent them. This means that the application should be designed to handle messages that arrive out of order.</p></div><p class="calibre8">The number of MDBs in the pool is configured in the EJB pool, which can be reached from the console by navigating to <span class="strong"><strong class="calibre9">Configuration</strong></span> | <span class="strong"><strong class="calibre9">Container</strong></span> | <span class="strong"><strong class="calibre9">EJB 3</strong></span> | <span class="strong"><strong class="calibre9">Bean Pools</strong></span> as depicted in the following screenshot:</p><div class="mediaobject"><img src="../images/00058.jpeg" alt="Adding message-driven beans to your application" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The <a id="id698" class="calibre1"/>bean pool's configuration is<a id="id699" class="calibre1"/> contained in the bean pool central tab, which<a id="id700" class="calibre1"/> holds both the stateless and MDB pool configurations. The default value for the MDB's max pool size is 20 units.</p><p class="calibre8">It is also possible to override pools for specific beans. You can use either the JBoss-specific <code class="email">org.jboss.ejb3.annotation.Pool</code> annotation or the <code class="email">jboss-ejb3.xml</code> deployment<a id="id701" class="calibre1"/> descriptor. For more information on overriding pools for the chosen beans, visit <a class="calibre1" href="https://docs.jboss.org/author/display/WFLY8/EJB3+subsystem+configuration+guide">https://docs.jboss.org/author/display/WFLY8/EJB3+subsystem+configuration+guide</a>.</p><p class="calibre8">If no bean instances are available, the request will be blocked until an active MDB completes a method call or the transaction times out.</p><div class="book" title="Cooking message-driven beans"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec36" class="calibre1"/>Cooking message-driven beans</h3></div></div></div><p class="calibre8">We will <a id="id702" class="calibre1"/>now add a message-driven bean to our application from the previous chapter, which will be used to intercept messages when a new ticket is booked. For the purpose of our example, we will just trace whether the JMS message has been received; however, you can also use it for more complex purposes such as notifying external systems.</p><p class="calibre8">Create a new Java class, say <code class="email">BookingQueueReceiver</code>, and enter the package name as <code class="email">com.packtpub.wflydevelopment.chapter6.jms</code>.</p><p class="calibre8">Once done, let's add the MDB configuration via an annotation, as shown here:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter6.jms;

import javax.ejb.ActivationConfigProperty;
import javax.ejb.MessageDriven;
import javax.inject.Inject;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import java.util.logging.Logger;

<span class="strong"><strong class="calibre9">@MessageDriven(name = "BookingQueueReceiver", activationConfig = {</strong></span>
<span class="strong"><strong class="calibre9">        @ActivationConfigProperty(propertyName = "destinationLookup",</strong></span>
<span class="strong"><strong class="calibre9">             propertyValue = "java:jboss/jms/queue/ticketQueue"),  [1]</strong></span>
<span class="strong"><strong class="calibre9">        @ActivationConfigProperty(propertyName = "destinationType",</strong></span>
<span class="strong"><strong class="calibre9">             propertyValue = "javax.jms.Queue"),}</strong></span>
<span class="strong"><strong class="calibre9">)</strong></span>
public class BookingQueueReceiver implements MessageListener {

    @Inject
    private Logger logger;

    @Override
    public void onMessage(Message message) {
        try {
            final String text = message.getBody(String.class);
            logger.info("Received message " + text);
        } catch (JMSException ex) {
            logger.severe(ex.toString());
        }
    }
}</pre></div><p class="calibre8">Here we have connected the MDB to our <code class="email">ticketQueue</code> destination <code class="email">[1]</code> bound at <code class="email">java:jboss/jms/queue/ticketQueue</code>. The purpose of this component will be to trace the message receipt via <code class="email">java.util.Logger</code>.</p><p class="calibre8">Java EE 7 introduces<a id="id703" class="calibre1"/> an additional way of the queue definition. Now, you don't have to add a queue from the application server management tool. It is possible to define queues and their properties in the code using some basic annotations:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter6.jms;

import javax.jms.JMSDestinationDefinition;

@JMSDestinationDefinition(
        name = <span class="strong"><strong class="calibre9">BookingQueueDefinition.BOOKING_QUEUE</strong></span>,
        interfaceName = "javax.jms.Queue"
)
public class BookingQueueDefinition {

    public static final String BOOKING_QUEUE = <span class="strong"><strong class="calibre9">"java:global/jms/bookingQueue</strong></span>";
}</pre></div><p class="calibre8">Then, in <code class="email">BookingQueueReceiver</code>, you can just change <code class="email">propertyValue = "java:jboss/jms/queue/ticketQueue"</code> to <code class="email">propertyValue = BookingQueueDefinition.BOOKING_QUEUE</code>.</p></div><div class="book" title="Adding the JMS producer"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec37" class="calibre1"/>Adding the JMS producer</h3></div></div></div><p class="calibre8">Once <a id="id704" class="calibre1"/>we're done with the JMS consumer, we<a id="id705" class="calibre1"/> need a component that will take care of sending JMS messages. For this purpose, we will add an Application Scoped CDI Bean, say <code class="email">BookingQueueProducer</code>, which gets injected in the JMS resources:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter6.jms;

import javax.annotation.Resource;
import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;
import javax.jms.JMSContext;
import javax.jms.Queue;

@ApplicationScoped
public class BookingQueueProducer {

    @Inject
    private JMSContext context;
    @Resource(mappedName = BookingQueueDefinition.BOOKING_QUEUE)
    private Queue syncQueue;

    public void sendMessage(String txt) {
        context.createProducer().send(syncQueue, txt);
    }
}</pre></div><p class="calibre8">This<a id="id706" class="calibre1"/> might be a bit shocking for those who<a id="id707" class="calibre1"/> have used the previous versions of the JMS. For those who haven't, in the following code we present this code's equivalent in JMS 1.1:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter6.jms;

Import javax.annotation.Resource;
Import javax.enterprise.context.ApplicationScoped;
Import javax.jms.*;
Import java.util.logging.Logger;

@ApplicationScoped
public class BookingQueueProducer {

    @Inject
    private Logger logger;

    @Resource(mappedName = "java:/ConnectionFactory")
    private ConnectionFactorycf;

    @Resource(mappedName = BookingQueueDefinition.BOOKING_QUEUE)
    private Queue queueExample;  

    public void sendMessage(String txt) {
        try {
            final Connection connection = cf.createConnection();
            Session session = connection
                  .createSession(false, Session.AUTO_ACKNOWLEDGE);

            final MessageProducer publisher = 
                session.createProducer(queueExample);

            connection.start();

            final TextMessage message = 
                session.createTextMessage(txt);
            publisher.send(message);
        }
        catch (Exception exc) {
           logger.error("Error ! "+exc);
        }
        finally {
            if (connection != null) {
                try {
                    connection.close();
                } catch (JMSException e) { 
                    logger.error(e); 
                } 
            }
        }
    }
}</pre></div><p class="calibre8">Code amount <a id="id708" class="calibre1"/>change is impressive. API <a id="id709" class="calibre1"/>simplification was one of the major features of the new JMS version, and the specification authors did great work on it.</p><p class="calibre8">Now, you can use your service to notify some application-specific actions. For example, we will inject <code class="email">BookingQueueProducer</code> into the <code class="email">BookerService</code> bean and send a message whenever a user is registered:</p><div class="informalexample"><pre class="programlisting">public class BookerService implements Serializable {
 
<span class="strong"><strong class="calibre9">    @Inject</strong></span>
<span class="strong"><strong class="calibre9">    private BookingQueueProducer bookingQueueProducer;</strong></span>

    // Some code

    public void bookSeat(long seatId, int price) {
        logger.info("Booking seat " + seatId);

        if (price &gt; money) {
            final FacesMessage m = 
                  new FacesMessage(FacesMessage.SEVERITY_ERROR, 
                    "Not enough Money!",
                    "Registration successful");
            facesContext.addMessage(null, m);
            return;
        }

        ticketService.bookSeat(seatId);

        final FacesMessage m = 
              new FacesMessage(FacesMessage.SEVERITY_INFO, 
                  "Registered!", 
                  "Registration successful");
        facesContext.addMessage(null, m);
        logger.info("Seat booked.");

        money = money - price;

<span class="strong"><strong class="calibre9">        bookingQueueProducer.sendMessage("[JMS Message] User registered seat " + seatId);</strong></span>
    }
    // Some code

}</pre></div><p class="calibre8">From JMS 2.0, messages <a id="id710" class="calibre1"/>can be sent <a id="id711" class="calibre1"/>asynchronously, but then it is important to control whether the operations are successful or not. To do this, we have to create an object that implements the <code class="email">CompletionListener</code> interface, as follows:</p><div class="informalexample"><pre class="programlisting">@ApplicationScoped
public class BookingCompletionListener implements <span class="strong"><strong class="calibre9">CompletionListener</strong></span> {

    @Inject
    private Logger logger;

<span class="strong"><strong class="calibre9">    @Override</strong></span>
<span class="strong"><strong class="calibre9">    public void onCompletion(Message message) {</strong></span>
        try {
            final String text = message.getBody(String.class);
            logger.info("Send was successful: " + text));
        } catch (Throwable e) {
            logger.severe("Problem with message format");
        }
    }

<span class="strong"><strong class="calibre9">    @Override</strong></span>
<span class="strong"><strong class="calibre9">    public void onException(Message message, Exception exception) {</strong></span>
        try {
            final String text = message.getBody(String.class);
            logger.info("Send failed..." + text);
        } catch (Throwable e) {
            logger.severe("Problem with message format");
        }
    }
}</pre></div><p class="calibre8">During the <code class="email">send</code> operation, we have to specify the asynchronous and use this <code class="email">listener</code> object. To do this, inject <code class="email">BookingCompletionListener</code> to <code class="email">BookingQueueProducer</code> and send messages with an updated call:</p><div class="informalexample"><pre class="programlisting">public void sendMessage(String txt) {
    context.createProducer()
        <span class="strong"><strong class="calibre9">.setAsync(bookingCompletionListener).</strong></span>send(syncQueue, txt);
}</pre></div><p class="calibre8">Now, appropriate <a id="id712" class="calibre1"/>listener methods will be<a id="id713" class="calibre1"/> executed when the message <code class="email">send</code> is completed or failed:</p><div class="informalexample"><pre class="programlisting">[com.packtpub.wflydevelopment.chapter6.jms.BookingCompletionListener] (Thread-3 (HornetQ-client-global-threads-269763340)) Send was successful: [JMS Message] User registered seat 2 </pre></div></div><div class="book" title="Compiling and deploying the application"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec38" class="calibre1"/>Compiling and deploying the application</h3></div></div></div><p class="calibre8">We <a id="id714" class="calibre1"/>have based our code on the JPA <a id="id715" class="calibre1"/>application from the previous chapter. Thanks<a id="id716" class="calibre1"/> to <code class="email">javaee-api</code>, you don't have to add any new<a id="id717" class="calibre1"/> project dependencies in order to use JMS! The only thing you have to do is to start WildFly in full profile using, for example, <code class="email">standalone-full.xml standalone-full.xml</code>—the standard full profile configuration:</p><div class="informalexample"><pre class="programlisting">standalone.sh –c standalone-full.xml</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note31" class="calibre1"/>Note</h3><p class="calibre8">Remember, when switching to another server configuration, you will need to recreate all the example resources, such as data sources, that were set up initially for your standalone configuration.</p></div><p class="calibre8">Now deploy your application using either Eclipse's Server view or Maven and access the application at <code class="email">http://localhost:8080/ticket-agency-jms/</code>.</p><p class="calibre8">Everything should work just like the earlier JPA project; however, in your application server console, you should notice the messages that confirm a seat has been booked.</p></div><div class="book" title="Specifying which message to receive using selectors"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec39" class="calibre1"/>Specifying which message to receive using selectors</h3></div></div></div><p class="calibre8">Message selectors<a id="id718" class="calibre1"/> allow an MDB to be<a id="id719" class="calibre1"/> more selective about the messages it receives from a particular topic or queue. Message selectors use message properties as criteria in conditional expressions. Message properties, upon which message selectors are based, are additional headers that can be assigned to a message. They give the application developer the ability to attach more information to a message. This information can be stored using several primitive values (<code class="email">boolean</code>, <code class="email">byte</code>, <code class="email">short</code>, <code class="email">int</code>, <code class="email">long</code>, <code class="email">float</code>, and <code class="email">double</code>) or as <code class="email">String</code>.</p><p class="calibre8">For example, let's suppose that we want to process two kinds of messages with the same queue:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A <a id="id720" class="calibre1"/>trace message<a id="id721" class="calibre1"/> indicating that a user has booked a seat</li><li class="listitem">A warning message indicating that an error has occurred</li></ul></div><p class="calibre8">Hence, our <code class="email">sendMessage</code> method can be changed slightly to include a <code class="email">String</code> property that can be attached to the message:</p><div class="informalexample"><pre class="programlisting">@ApplicationScoped
public class BookingQueueProducer {

    @Inject
    private JMSContext context;

    @Inject
    private BookingCompletionListener bookingCompletionListener;

    @Resource(mappedName = BookingQueueDefinition.BOOKING_QUEUE)
    private Queue syncQueue;

    public void sendMessage(String txt, Priority priority) {
        context.createProducer()
                .setAsync(bookingCompletionListener)
                .setProperty("priority", priority.toString())
                .send(syncQueue, txt);
    }
} 

public enum Priority {
    LOW, HIGH
}</pre></div><p class="calibre8">Now, in our application context, we might use the <code class="email">sendMessage</code> method, attaching a <code class="email">LOW</code> value for priority when the user is registered:</p><div class="informalexample"><pre class="programlisting">bookingQueueProducer.sendMessage("[JMS Message] User registered seat " + seatId, Priority.LOW);</pre></div><p class="calibre8">On the other hand, we could attach a <code class="email">HIGH</code> priority when an error occurs:</p><div class="informalexample"><pre class="programlisting">bookingQueueProducer.sendMessage("Error during Transaction", Priority. HIGH);</pre></div><p class="calibre8">From the MDB perspective, all you need to do in order to filter through messages is include the message selector as part of your <code class="email">ActivationConfigProperty</code> class as follows:</p><div class="informalexample"><pre class="programlisting">@MessageDriven(name = "BookingQueueReceiver", activationConfig = {
        @ActivationConfigProperty(propertyName = "destinationLookup",
                propertyValue = BookingQueueDefinition.BOOKING_QUEUE),
        @ActivationConfigProperty(propertyName = "destinationType",
                propertyValue = "javax.jms.Queue"),
        <span class="strong"><strong class="calibre9">@ActivationConfigProperty(propertyName = "messageSelector",</strong></span>
<span class="strong"><strong class="calibre9">                propertyValue = "priority = 'HIGH'"),}</strong></span>
)
public class BookingQueueReceiver implements MessageListener {

    // Some code 
}</pre></div><p class="calibre8">At the <a id="id722" class="calibre1"/>same time, you can deploy <a id="id723" class="calibre1"/>another MDB that is in charge of consuming messages that are sent with a <code class="email">LOW</code> priority:</p><div class="informalexample"><pre class="programlisting">@MessageDriven(name = " LowPriorityBookingQueueReceiver", activationConfig = {
        @ActivationConfigProperty(propertyName = "destinationLookup",
                propertyValue = BookingQueueDefinition.BOOKING_QUEUE),
        @ActivationConfigProperty(propertyName = "destinationType",
                propertyValue = "javax.jms.Queue"),
<span class="strong"><strong class="calibre9">        @ActivationConfigProperty(propertyName = "messageSelector",</strong></span>
<span class="strong"><strong class="calibre9">                propertyValue = "priority = 'LOW'"),}</strong></span>
)
public class LowPriorityBookingQueueReceiver implements MessageListener {

    // Some code
} </pre></div><p class="calibre8">When talking about filtering, we have to say a few words concerning performance. In HornetQ queues and topics, there are filtering messages on a different stage. In the case of queues, properties are filtered when they have already been received by the listener, while in topics, they are filtered before being added. Keep in mind this is not guaranteed by JMS specification (since a specification describes the API) and might act differently in other <a id="id724" class="calibre1"/>implementations. There are a lot of performance options that can be tuned in JMS providers; however, most of the configurations must be specifically chosen for every project. Be sure to check additional tuning tips<a id="id725" class="calibre1"/> in HornetQ's documentation at <a class="calibre1" href="http://docs.jboss.org/hornetq/2.4.0.Final/docs/user-manual/html_single/#perf-tuning">http://docs.jboss.org/hornetq/2.4.0.Final/docs/user-manual/html_single/#perf-tuning</a>.</p></div></div></div>

<div class="book" title="The building blocks of JMS">
<div class="book" title="Transaction and acknowledgment modes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch06lvl2sec52" class="calibre1"/>Transaction and acknowledgment modes</h2></div></div></div><p class="calibre8">In order<a id="id726" class="calibre1"/> to control the overall performance and reliability of an <a id="id727" class="calibre1"/>asynchronous messaging system, we need to take two factors into <a id="id728" class="calibre1"/>account: persisting of messages and acknowledgment. Let's<a id="id729" class="calibre1"/> take a look at those characteristics.</p><p class="calibre8">Reliability of the system is focused on the ability to deliver messages exactly once. This means that no message is lost, and there are no duplicates. For most systems, it is a strong requirement that you don't miss or duplicate any orders (like in an e-commerce site). However, usually it is not a problem to miss an update from the stock market because a newer one would overwrite it in a moment. Of course, additional features such as reliability come at a price, and in the case of JMS, the price is paid in performance. The more reliable the system, the lower its message throughput is.</p><p class="calibre8">When a message is processed, it can be held only in the memory or persisted somewhere on the disk. Messages stored in the memory are lost in the case of a failure or when the messaging service is stopped. Persisted messages can be retrieved from the disk after the service is restarted and therefore delivered to the consumers at least once (but still without any guarantees about the acknowledgment). Without this mechanism, messages can potentially be lost in the system because a failure might occur before they are delivered. However, the overhead of storing them can have a serious impact on the system's performance characteristics.</p><p class="calibre8">Acknowledgment is important to inform the JMS service that the message was really received and processed by the consumer. Different levels of acknowledgments can be used to avoid duplicates or to trigger JMS to send the message once more, possibly to another consumer. A JMS provider will ensure that an acknowledged message is delivered only once. The application is responsible for properly handling rolled back messages that were redelivered (such messages are marked with the <code class="email">JMSRedelivered</code> header).</p><p class="calibre8">If the consumer session is handled in a transaction, then the messages are acknowledged only when the transaction is committed. However, there is an option to disable transactional message-driven beans and manually handle the acknowledgment. In this case, there are the following three types of acknowledgement options:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">AUTO_ACKNOWLEDGE</strong></span>: With this, the consumed messages are being acknowledged<a id="id730" class="calibre1"/> automatically</li><li class="listitem"><span class="strong"><strong class="calibre9">DUPS_OK_ACKNOWLEDGE</strong></span>: With this, the delivered messages are being <a id="id731" class="calibre1"/>lazily acknowledged; this means that the client might receive some duplicated messages</li><li class="listitem"><span class="strong"><strong class="calibre9">CLIENT_ACKNOWLEDGES</strong></span>: With this, the client manually acknowledges<a id="id732" class="calibre1"/> received messages using the <code class="email">acknowledge</code> method</li></ul></div><p class="calibre8">The <a id="id733" class="calibre1"/>modes<a id="id734" class="calibre1"/> can be set when you retrieve<a id="id735" class="calibre1"/> <code class="email">JMSContext</code> from a connection factory:</p><div class="informalexample"><pre class="programlisting">JMSContext context = connectionFactory.createContext(JMSContext.CLIENT_ACKNOWLEDGE)</pre></div><p class="calibre8">The<a id="id736" class="calibre1"/> first argument is an integer flag that accepts the values mentioned previously along with a <code class="email">SESSION_TRANSACTED</code> entry (which is the standard mode for JTA-managed message-driven beans).</p></div></div>

<div class="book" title="The building blocks of JMS">
<div class="book" title="Using JMS to integrate with external systems"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch06lvl2sec53" class="calibre1"/>Using JMS to integrate with external systems</h2></div></div></div><p class="calibre8">At<a id="id737" class="calibre1"/> the beginning of this chapter, we <a id="id738" class="calibre1"/>mentioned that the JCA adaptor handles the communication between the application server and the HornetQ server.</p><p class="calibre8">As a <a id="id739" class="calibre1"/>matter of fact, one possible way to perform <span class="strong"><strong class="calibre9">Enterprise Application Integration</strong></span> (<span class="strong"><strong class="calibre9">EAI</strong></span>) is via <span class="strong"><strong class="calibre9">Java Connector Architecture</strong></span> (<span class="strong"><strong class="calibre9">JCA</strong></span>), which <a id="id740" class="calibre1"/>can be used to drive JMS's inbound and outbound connections.</p><p class="calibre8">Initially, Java connectors were intended to access legacy transaction servers on mainframes in a synchronous request/reply mode, and this is how the majority of the connectors worked in the beginning. The standard is currently evolving toward more asynchronous and two-way connectivity; this is exactly the case with JMS communication, which is inherently asynchronous (but also offers the capability of simulating a synchronous request/response mode). In the next section, we will show you how to use a Java Resource Adapter to enable communication between JBoss' HornetQ Messaging system and a standalone instance of the Apache ActiveMQ broker (which can be used, for instance, by a non-Java EE application).</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip06" class="calibre1"/>Tip</h3><p class="calibre8"><span class="strong"><strong class="calibre9">JMS/JCA integration versus web services</strong></span></p><p class="calibre8">If we are discussing EAI, we cannot help but talk about the difference between web services, which is the de facto standard for integrating heterogeneous systems.</p><p class="calibre8">One advantage of using the JMS/JCA integration is that it provides support for resource adaptation, which maps the Java EE security, transaction, and communication pooling to the corresponding EIS technology. This makes this technology<a id="id741" class="calibre1"/> fairly attractive, especially if you are trying to connect some existing, well-consolidated, and homogeneous systems (remember that if you are using JMS as the <a id="id742" class="calibre1"/>driver, you are bound to a Java-to-Java interaction).</p><p class="calibre8">On the other hand, if you are planning to connect different business partners (for example, Java and .NET applications) or simply build a new system from scratch with no clear interactions defined, it would be better to use web services for transport and connection.</p><p class="calibre8">We will learn more about web services in <a class="calibre1" title="Chapter 7. Adding Web Services to Your Applications" href="part0038_split_000.html#page">Chapter 7</a>, <span class="strong"><em class="calibre10">Adding Web Services to Your Applications</em></span>, which should provide you with quite a complete overview of your EAI alternatives.</p></div></div></div>

<div class="book" title="The building blocks of JMS">
<div class="book" title="A real-world example – HornetQ and ActiveMQ integration"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch06lvl2sec54" class="calibre1"/>A real-world example – HornetQ and ActiveMQ integration</h2></div></div></div><p class="calibre8">In <a id="id743" class="calibre1"/>this section, we will provide an example<a id="id744" class="calibre1"/> scenario, which includes an external <a id="id745" class="calibre1"/>component such as the Apache ActiveMQ (Apache 2.0 open source licensed) message broker that fully implements <span class="strong"><strong class="calibre9">Java Message Service 1.1</strong></span> (<span class="strong"><strong class="calibre9">JMS</strong></span>). Another application could be communicating with our ticketing<a id="id746" class="calibre1"/> system using this broker, but in our sample, we will simulate the external system using the ActiveMQ administration console.</p><p class="calibre8">In order to run this example, we will need to pick up the ActiveMQ resource adapter, <code class="email">activemq-rar-5.9.0.rar</code>, which <a id="id747" class="calibre1"/>can be downloaded from the Maven repository at <a class="calibre1" href="http://repo1.maven.org/maven2/org/apache/activemq/activemq-rar/5.9.0/">http://repo1.maven.org/maven2/org/apache/activemq/activemq-rar/5.9.0/</a>. You will also need <a id="id748" class="calibre1"/>the ActiveMQ broker, which you can download from <a class="calibre1" href="https://activemq.apache.org/activemq-590-release.html">https://activemq.apache.org/activemq-590-release.html</a>. Simply extract the binary distribution and run the <code class="email">/apache-activemq-5.9.0/bin/activemq.bat</code> file to start the broker.</p><div class="book" title="Installing the ActiveMQ resource adapter"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec40" class="calibre1"/>Installing the ActiveMQ resource adapter</h3></div></div></div><p class="calibre8">Resource <a id="id749" class="calibre1"/>adapters (<code class="email">.rar</code>) can be deployed using either WildFly management instruments or by copying the resource adapter into the deployments directory for standalone servers. Before doing this, we need to configure the Resource adapter in your server configuration. This can be done by adding the configuration to the JCA subsystem or (suggested choice) by creating a JCA descriptor of the external resource.</p><p class="calibre8">JCA descriptors can be created by using an utility contained in JBoss' JCA implementation <a id="id750" class="calibre1"/>named <span class="strong"><strong class="calibre9">IronJacamar</strong></span> (<a class="calibre1" href="http://www.jboss.org/ironjacamar">http://www.jboss.org/ironjacamar</a>). Within IronJacamar 1.1 or later distributions (accessible at <a class="calibre1" href="http://www.jboss.org/ironjacamar/downloads">http://www.jboss.org/ironjacamar/downloads</a>), you can find a resource adapter information <a id="id751" class="calibre1"/>tool (<code class="email">rar-info.bat</code>) that can be used to create the resource adapter deployment descriptor by generating a report file containing all the necessary information.</p><p class="calibre8">The <code class="email">rar-info.bat</code> tool can be found in the <code class="email">doc/as</code> folder of your IronJacamar distribution. So let's move to this folder:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ cd doc/as</strong></span>
</pre></div><p class="calibre8">Now issue the following command, which assumes that you have saved your resource adapter in the <code class="email">/usr/doc</code> folder:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">rar-info.bat /usr/doc/activemq-rar-5.9.0.rar</strong></span>
</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip07" class="calibre1"/>Tip</h3><p class="calibre8"><span class="strong"><strong class="calibre9">Troubleshooting the rar-info shell</strong></span></p><p class="calibre8">The <code class="email">rar-info</code> command shell<a id="id752" class="calibre1"/> includes a set of libraries that are used to execute the main utility class. In order to inspect the JMS adapter, however, you need to manually edit the shell file and add <code class="email">jboss-jms-api_2.0_spec-1.0.0.Final</code> and <code class="email">jboss-transaction-api_1.2_spec-1.0.0.Final.jar</code> to the classpath. Those JAR files are contained in the main folder under <code class="email">JBOSS_HOME/modules/system/layers/base/javax/jms/api/</code> and <code class="email">JBOSS_HOME/modules/system/layers/base/javax/transaction/api/</code>. Simply add paths for them in the <code class="email">rar-info.bat</code> file (separated by character); for example, refer to the following (assuming the jars are in the same directory as <code class="email">rar-info.bat</code>):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">java -classpath ironjacamar-as.jar;..\..\lib\ironjacamar-common-spi.jar;..\..\lib\jboss-logging.jar;..\..\lib\jboss-common-core.jar;..\..\lib\ironjacamar-spec-api.jar;..\..\lib\jandex.jar;..\..\lib\ironjacamar-common-impl.jar;..\..\lib\ironjacamar-common-api.jar;..\..\lib\ironjacamar-core-impl.jar;..\..\lib\ironjacamar-core-api.jar;..\..\lib\ironjacamar-validator.jar;..\..\lib\jandex.jar;..\..\lib\validation-api.jar;..\..\lib\hibernate-validator.jar;jboss-jms-api_2.0_spec-1.0.0.Final.jar;jboss-transaction-api_1.2_spec-1.0.0.Final.jar org.jboss.jca.as.rarinfo.Main %*</strong></span>
</pre></div></div><p class="calibre8">This will generate a file called <code class="email">activemq-rar-5.9.0-report.txt</code>, which will provide you with the required information to construct your own JBoss' JCA configuration file that needs to be named <code class="email">ironjacamar.xml</code>. Feel free to check out its contents.</p><p class="calibre8">In the following<a id="id753" class="calibre1"/> code, you can find a sample <code class="email">ironjacamar.xml</code> file that defines a new queue (<code class="email">java:jboss/activemq/queue/TicketQueue</code>):</p><div class="informalexample"><pre class="programlisting">&lt;ironjacamar&gt;
     &lt;connection-definitions&gt;
        &lt;connection-definition class-name="org.apache.activemq.ra.ActiveMQManagedConnectionFactory" jndi-name="java:jboss/activemq/TopicConnectionFactory" pool-name="TopicConnectionFactory"&gt;
     &lt;pool&gt;
        &lt;min-pool-size&gt;1&lt;/min-pool-size&gt;
        &lt;max-pool-size&gt;200&lt;/max-pool-size&gt;
        &lt;prefill&gt;false&lt;/prefill&gt;
      &lt;/pool&gt;
      &lt;security&gt;
        &lt;application /&gt;
      &lt;/security&gt;
      &lt;timeout&gt;
        &lt;blocking-timeout-millis&gt;30000&lt;/blocking-timeout-millis&gt;
        &lt;idle-timeout-minutes&gt;3&lt;/idle-timeout-minutes&gt;
      &lt;/timeout&gt;
      &lt;validation&gt;
        &lt;background-validation&gt;false&lt;/background-validation&gt;
        &lt;use-fast-fail&gt;false&lt;/use-fast-fail&gt;
      &lt;/validation&gt; 
   &lt;/connection-definition&gt;
   &lt;connection-definition class-name="org.apache.activemq.ra.ActiveMQManagedConnectionFactory" jndi-name="java:jboss/activemq/QueueConnectionFactory" pool-name="QueueConnectionFactory"&gt;
      &lt;pool&gt;
        &lt;min-pool-size&gt;1&lt;/min-pool-size&gt;
        &lt;max-pool-size&gt;200&lt;/max-pool-size&gt;
        &lt;prefill&gt;false&lt;/prefill&gt;
      &lt;/pool&gt;
      &lt;security&gt;
        &lt;application /&gt;
      &lt;/security&gt;
      &lt;timeout&gt;
        &lt;blocking-timeout-millis&gt;30000&lt;/blocking-timeout-millis&gt;
        &lt;idle-timeout-minutes&gt;3&lt;/idle-timeout-minutes&gt;
      &lt;/timeout&gt;
      &lt;validation&gt;
        &lt;background-validation&gt;false&lt;/background-validation&gt;
        &lt;use-fast-fail&gt;false&lt;/use-fast-fail&gt;
      &lt;/validation&gt;
    &lt;/connection-definition&gt;
    &lt;/connection-definitions&gt;
     &lt;admin-objects&gt;
<span class="strong"><strong class="calibre9">    &lt;admin-object class-name="org.apache.activemq.command.ActiveMQQueue" jndi-name="java:jboss/activemq/queue/TicketQueue"&gt;</strong></span>
<span class="strong"><strong class="calibre9">        &lt;config-property name="PhysicalName"&gt;</strong></span>
<span class="strong"><strong class="calibre9">               activemq/queue/TicketQueue</strong></span>
<span class="strong"><strong class="calibre9">          &lt;/config-property&gt;</strong></span>
    &lt;/admin-object&gt;
    &lt;/admin-objects&gt;
&lt;/ironjacamar&gt;</pre></div><p class="calibre8">As you <a id="id754" class="calibre1"/>can see, this file contains the definition of ActiveMQ connection factories along with the mapping of JMS administration objects, which will be imported by the resource adapter. The <code class="email">ironjacamar.xml</code> file needs to be copied into the <code class="email">META-INF</code> folder of <code class="email">activemq-rar-5.9.0.rar</code> (you can open the RAR file using the compressed files manager of your choice, for example, 7-Zip).</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip08" class="calibre1"/>Tip</h3><p class="calibre8"><span class="strong"><strong class="calibre9">Additional configuration requirements of the resource adapter</strong></span></p><p class="calibre8">Along with the <code class="email">ironjacamar.xml</code> file, there is another configuration file that is contained in the <code class="email">META-INF</code> folder of your <code class="email">activemq-rar-5.9.0.rar</code> file. The <code class="email">ra.xml</code> file<a id="id755" class="calibre1"/> is the standard JCA configuration file and describes the resource-adapter-related attribute's type and its deployment properties. We, however, do not need to alter its contents for our basic sample.</p></div><p class="calibre8">Now that we have completed the configuration, let's deploy the resource adapter (<code class="email">activemq-rar-5.9.0.rar</code>) into our WildFly and check that the JCA factories and objects have been correctly bound to the application server. After the deployment, you should see the following similar messages in WildFly's console:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">19:52:51,521 INFO  [org.jboss.as.connector.deployment] (MSC service thread 1-5) JBAS010401: Bound JCA AdminObject [java:jboss/activemq/queue/TicketQueue]</strong></span>
<span class="strong"><strong class="calibre9">19:52:51,521 INFO  [org.jboss.as.connector.deployment] (MSC service thread 1-5) JBAS010401: Bound JCA ConnectionFactory [java:jboss/jms/TopicConnectionFactory]</strong></span>
<span class="strong"><strong class="calibre9">19:52:51,521 INFO  [org.jboss.as.connector.deployment] (MSC service thread 1-8) JBAS010401: Bound JCA ConnectionFactory [java:jboss/jms/ConnectionFactory]</strong></span>
<span class="strong"><strong class="calibre9">19:52:51,542 INFO  [org.jboss.as.server] (DeploymentScanner-threads - 1) JBAS018559: Deployed "activemq-rar-5.9.0.rar" (runtime-name : "activemq-rar-5.9.0.rar")</strong></span>
</pre></div></div><div class="book" title="Consuming ActiveMQ messages"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec41" class="calibre1"/>Consuming ActiveMQ messages</h3></div></div></div><p class="calibre8">Well<a id="id756" class="calibre1"/> done! The hardest part is done. Now in order to consume JMS messages sent by the ActiveMQ broker, we will add a <code class="email">@ResourceAdapter</code> annotation to a message-driven bean. This MDB will intercept bookings from the ActiveMQ broker. In order to be able to use the <code class="email">@ResourceAdapter</code> annotation, we will need to add a JBoss-specific dependency to our <code class="email">pom.xml</code>:</p><div class="informalexample"><pre class="programlisting">         &lt;dependency&gt;
            &lt;groupId&gt;org.jboss.ejb3&lt;/groupId&gt;
            &lt;artifactId&gt;jboss-ejb3-ext-api&lt;/artifactId&gt;
            &lt;version&gt;2.1.0&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;</pre></div><p class="calibre8">Our new annotated message bean is presented as follows (note that the property <code class="email">destinationType</code> is the destination now):</p><div class="informalexample"><pre class="programlisting">@MessageDriven(name = "MDBService", activationConfig = {
<span class="strong"><strong class="calibre9">        @ActivationConfigProperty(propertyName = "destination",</strong></span>
<span class="strong"><strong class="calibre9">                propertyValue = "java:jboss/activemq/queue/TicketQueue"),</strong></span>
        @ActivationConfigProperty(propertyName = "destinationType",
                propertyValue = "javax.jms.Queue"),}
)
<span class="strong"><strong class="calibre9">@ResourceAdapter(value="activemq-rar-5.9.0.rar")</strong></span>
public class BookingQueueReceiver implements MessageListener {

    @Inject
    private Logger logger;

    @Override
    public void onMessage(Message message) {
        try {
             final String text = message.getBody(String.class);
            logger.info("Received message " + text);
        } catch (JMSException ex) {
            logger.severe(ex.toString());
        }
    }
}</pre></div><p class="calibre8">Once a message is received, it is written to a console. This means that it is time to deploy our application. If your ActiveMQ broker is running, you should see the following similar messages during the deployment phase:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">19:59:59,452 INFO  [org.apache.activemq.ra.ActiveMQEndpointWorker] (ServerService Thread Pool -- 65) Starting</strong></span>
<span class="strong"><strong class="calibre9">19:59:59,458 INFO  [org.apache.activemq.ra.ActiveMQEndpointWorker] (default-threads - 1) Establishing connection to broker [tcp://localhost:61616]</strong></span>
<span class="strong"><strong class="calibre9">19:59:59,573 INFO  [javax.enterprise.resource.webcontainer.jsf.config] (MSC service thread 1-5) Initializing Mojarra 2.2.5-jbossorg-3 20140128-1641 for context '/ticket-agency-jms'</strong></span>
<span class="strong"><strong class="calibre9">19:59:59,618 INFO  [org.apache.activemq.ra.ActiveMQEndpointWorker] (default-threads - 1) Successfully established connection to broker [tcp://localhost:61616]</strong></span>
<span class="strong"><strong class="calibre9">20:00:00,053 INFO  [org.wildfly.extension.undertow] (MSC service thread 1-5) JBAS017534: Registered web context: /ticket-agency-jms</strong></span>
<span class="strong"><strong class="calibre9">20:00:00,081 INFO  [org.jboss.as.server] (DeploymentScanner-threads - 1) JBAS018559: Deployed "ticket-agency-jms.war" (runtime-name : "ticket-agency-jms.war")</strong></span>
</pre></div><p class="calibre8">Now it is<a id="id757" class="calibre1"/> time to test our connection using the ActiveMQ console, which will send a message straight to the ActiveMQ broker. ActiveMQ 5.9.0 is<a id="id758" class="calibre1"/> equipped with a bundled <span class="strong"><strong class="calibre9">hawt.io</strong></span> console. It is a pluggable web dashboard that can be configured to administer various applications. One of them is ActiveMQ. And, one of the benefits of using this console is that you can deploy it on almost any JVM-based container, including WildFly. Check out <a class="calibre1" href="http://hawt.io/">http://hawt.io/</a> along <a id="id759" class="calibre1"/>with the ActiveMQ plugin (<a class="calibre1" href="http://hawt.io/plugins/activemq/">http://hawt.io/plugins/activemq/</a>) for more information.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note32" class="calibre1"/>Note</h3><p class="calibre8">From Version 5.10.0, ActiveMQ is not prebundled with hawt.io anymore. You can prepare your own hawt.io console by following the guidelines available at <a class="calibre1" href="http://hawt.io/getstarted/index.html">http://hawt.io/getstarted/index.html</a>; installing the ActiveMQ plugin; or (which we strongly recommend) using Version 5.9.0 in your samples, which is conveniently preconfigured.</p></div><p class="calibre8">Go to <code class="email">http://localhost:8161/hawtio/</code> and log in using the <code class="email">admin/admin</code> credentials:</p><div class="mediaobject"><img src="../images/00059.jpeg" alt="Consuming ActiveMQ messages" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">After <a id="id760" class="calibre1"/>the login, you should see the hawt.io web console. It is worth noting that it was created using Twitter Bootstrap, the same front-end framework that we are using in our application.</p><p class="calibre8">Select the first tab (ActiveMQ) and you should see a tree that represents the current configuration of the broker. Find the node <code class="email">localhost/Queue/</code>. When you expand it, you should see the queue we defined earlier in our resource adapter: <code class="email">java_jboss/activemq/queue/TicketQueue</code>. After selecting it, you can choose the <span class="strong"><strong class="calibre9">Send</strong></span> tab on the right-hand side. You should see a screen similar to the following one:</p><div class="mediaobject"><img src="../images/00060.jpeg" alt="Consuming ActiveMQ messages" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Enter the<a id="id761" class="calibre1"/> desired message into the big text area in the center and click on the <span class="strong"><strong class="calibre9">Send Message</strong></span> button. After switching to our WildFly console, we should see a log entry with the message we passed to the ActiveMQ broker, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00061.jpeg" alt="Consuming ActiveMQ messages" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Congratulations! If you have gone successfully through this example, you have just mastered a real-world integration scenario. To make the sample more realistic, you could improve the message bean so that it would book tickets if the message were to contain the required information (for example, message <code class="email">55,10</code> would book a seat with ID 55 for 10$). Feel free to experiment!</p></div></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec32" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we discussed JBoss' message-oriented middleware that allows you to loosely couple heterogeneous systems together while typically providing reliability, transactions, and many other features.</p><p class="calibre8">We saw how to configure JMS destinations using the web console and create some message-driven beans, which are the standard way to consume messages from within the EJB container.</p><p class="calibre8">We will now move on to another component, which is typically used for integrating heterogeneous systems—web services.</p></div></body></html>