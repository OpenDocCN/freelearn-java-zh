<html><head></head><body>
<div id="_idContainer022">
<h1 class="hapter-number" id="_idParaDest-29"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-30"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.2.1">Inverting Dependencies</span></h1>
<p><span class="koboSpan" id="kobo.3.1">After the talk about layered architecture in the previous chapter, you’re right to expect this chapter to discuss an alternative approach. </span><span class="koboSpan" id="kobo.3.2">We’ll start by discussing two of the </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">SOLID</span></strong><span id="footnote-015-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-015"><span class="koboSpan" id="kobo.5.1">1</span></a></span><span class="koboSpan" id="kobo.6.1"> principles and then </span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.7.1">apply them to create a </span><em class="itali"><span class="koboSpan" id="kobo.8.1">Clean</span></em><span class="koboSpan" id="kobo.9.1"> or </span><em class="itali"><span class="koboSpan" id="kobo.10.1">Hexagonal</span></em><span class="koboSpan" id="kobo.11.1"> Architecture that addresses the problems of a </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">layered architecture.</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-015">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-015-backlink"><span class="koboSpan" id="kobo.13.1">1</span></a><span class="koboSpan" id="kobo.14.1">	SOLID stands for Single Responsibility Principle, Open-Closed Principle, Liskov Substitution Principle, Interface Segregation Principle, and Dependency Inversion Principle. </span><span class="koboSpan" id="kobo.14.2">You can read more about these Principles in </span><em class="itali"><span class="koboSpan" id="kobo.15.1">Clean Architecture</span></em><span class="koboSpan" id="kobo.16.1"> by Robert C. </span><span class="koboSpan" id="kobo.16.2">Martin or on Wikipedia </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">at </span></span><a href="https://en.wikipedia.org/wiki/SOLID"><span class="No-Break"><span class="koboSpan" id="kobo.18.1">https://en.wikipedia.org/wiki/SOLID</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.19.1">.</span></span></p>
</div>
<h1 id="_idParaDest-31"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.20.1">The Single Responsibility Principle</span></h1>
<p><span class="koboSpan" id="kobo.21.1">Everyone </span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.22.1">in software development probably knows the </span><strong class="bold"><span class="koboSpan" id="kobo.23.1">Single Responsibility Principle</span></strong><span class="koboSpan" id="kobo.24.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.25.1">SRP</span></strong><span class="koboSpan" id="kobo.26.1">) or at least assumes to know it. </span><span class="koboSpan" id="kobo.26.2">A common interpretation of this principle </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">is this:</span></span></p>
<p><em class="itali"><span class="koboSpan" id="kobo.28.1">A component should do only one thing and do </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.29.1">it right.</span></em></span></p>
<p><span class="koboSpan" id="kobo.30.1">That’s good advice, but not the actual intent of </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">the SRP.</span></span></p>
<p><em class="itali"><span class="koboSpan" id="kobo.32.1">Doing only one thing</span></em><span class="koboSpan" id="kobo.33.1"> is actually the most obvious interpretation of “single responsibility,” so it’s no wonder that the SRP is frequently interpreted like this. </span><span class="koboSpan" id="kobo.33.2">Let’s just observe that the name of the SRP </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">is misleading.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">Here’s the actual definition of </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">the SRP:</span></span></p>
<p><em class="itali"><span class="koboSpan" id="kobo.37.1">A component should have only one reason </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.38.1">to change.</span></em></span></p>
<p><span class="koboSpan" id="kobo.39.1">As we see, “responsibility” should actually be translated to “reason to change” instead of “do only one thing.” </span><span class="koboSpan" id="kobo.39.2">Perhaps we should rename the SRP to the “Single Reason to </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">Change Principle.”</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">If a component has only one reason to change, it might end up doing only one thing, but the more important part is that it has only this one reason </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">to change.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">What does that mean for </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">our architecture?</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">If a component has only one reason to change, we don’t have to worry about this component at all if we change the software for any other reason because we know that it will still work </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">as expected.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">Sadly, it’s very easy for a reason to change to propagate through code via the dependencies of a component to other components (see </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.48.1">Figure 3</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.49.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">).</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.51.1"><img alt="Figure 3.1 – Each dependency of a component is a possible reason to change this component, even if it is only a transitive dependency (dashed arrows)" src="image/Figure_03.1_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.52.1">Figure 3.1 – Each dependency of a component is a possible reason to change this component, even if it is only a transitive dependency (dashed arrows)</span></p>
<p><span class="koboSpan" id="kobo.53.1">In the preceding figure, component </span><strong class="bold"><span class="koboSpan" id="kobo.54.1">A</span></strong><span class="koboSpan" id="kobo.55.1"> depends on many other components (either directly or transitively) while component </span><strong class="bold"><span class="koboSpan" id="kobo.56.1">E</span></strong><span class="koboSpan" id="kobo.57.1"> has no dependencies </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">at all.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">The only reason to change component </span><strong class="bold"><span class="koboSpan" id="kobo.60.1">E</span></strong><span class="koboSpan" id="kobo.61.1"> is when the functionality of </span><strong class="bold"><span class="koboSpan" id="kobo.62.1">E</span></strong><span class="koboSpan" id="kobo.63.1"> must change due to some new requirement. </span><span class="koboSpan" id="kobo.63.2">Component </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">A</span></strong><span class="koboSpan" id="kobo.65.1">, however, might have to change when any of the other components change because it depends </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">on them.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">Many code bases </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.68.1">grow harder – and thus more expensive – to change over time because the SRP is violated. </span><span class="koboSpan" id="kobo.68.2">Over time, components collect more and more reasons to change. </span><span class="koboSpan" id="kobo.68.3">Having collected many reasons to change, changing one component might cause another component </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">to fail.</span></span></p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.70.1">A tale about side effects</span></h1>
<p><span class="koboSpan" id="kobo.71.1">I once was part of a project where my </span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.72.1">team inherited a ten-year-old code base built by another software shop. </span><span class="koboSpan" id="kobo.72.2">The client had decided to replace the development team to reduce the ongoing maintenance costs and improve the development speed for new features. </span><span class="koboSpan" id="kobo.72.3">So, we got </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">the contract.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">As was to be expected, it was not easy to gain an understanding of what the code actually did, and the changes we made in one area of the code base often had side effects in other areas. </span><span class="koboSpan" id="kobo.74.2">But we managed by testing exhaustively, adding automated tests, and refactoring </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">a lot.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">After some time of successfully maintaining and extending the code base, the client requested a new feature. </span><span class="koboSpan" id="kobo.76.2">And they wanted us to build it in a way that was very awkward for the users of the software. </span><span class="koboSpan" id="kobo.76.3">So, I proposed to do it in a more user-friendly way that was even less expensive to implement since it needed fewer overall changes. </span><span class="koboSpan" id="kobo.76.4">It needed a small change in a certain very central </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">component, however.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">The client declined and ordered the </span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.79.1">more awkward and expensive solution. </span><span class="koboSpan" id="kobo.79.2">When I asked for the reason, they said that they were afraid of the side effects because changes made to that one component by the previous development team had always broken something else in </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">the past.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">Sadly, this is an example of how you can indoctrinate your client to pay extra for modifying badly architected software. </span><span class="koboSpan" id="kobo.81.2">Luckily, most clients will not play along with this game, so let’s try to build well-architected </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">software instead.</span></span></p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.83.1">The Dependency Inversion Principle</span></h1>
<p><span class="koboSpan" id="kobo.84.1">In our</span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.85.1"> layered architecture, the cross-layer dependencies always point down to the next layer. </span><span class="koboSpan" id="kobo.85.2">When we apply the Single Responsibility Principle on a high level, we notice that the upper layers have more reasons to change than the </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">lower layers.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">Thus, due to the domain layer’s dependency on the persistence layer, each change in the persistence layer potentially requires a change in the domain layer. </span><span class="koboSpan" id="kobo.87.2">But the domain code is the most important code in our application! </span><span class="koboSpan" id="kobo.87.3">We don’t want to have to change it when something changes in the </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">persistence code!</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">So, how can we get rid of </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">this dependency?</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.92.1">Dependency Inversion Principle</span></strong><span class="koboSpan" id="kobo.93.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.94.1">DIP</span></strong><span class="koboSpan" id="kobo.95.1">) provides </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">the answer.</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">In contrast to the SRP, the DIP means what the </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">name suggests:</span></span></p>
<p><em class="itali"><span class="koboSpan" id="kobo.99.1">We can turn around (invert) the direction of any dependency within our </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.100.1">code base</span></em></span><span class="No-Break"><em class="itali"><span id="footnote-014-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-014"><span class="koboSpan" id="kobo.101.1">2</span></a></span></em></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-014">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-014-backlink"><span class="koboSpan" id="kobo.102.1">2</span></a><span class="koboSpan" id="kobo.103.1">	Actually, we can only invert dependencies when we have control over the code on both ends of the dependency. </span><span class="koboSpan" id="kobo.103.2">If we have a dependency on a third-party library, we cannot invert it, since we don't control the code of </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">that library.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.105.1">How does that work? </span><span class="koboSpan" id="kobo.105.2">Let’s try to invert the dependency between our domain and persistence code so that the persistence code depends on the domain code, reducing the number of reasons to change the </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">domain code.</span></span></p>
<p><span class="koboSpan" id="kobo.107.1">We start with a structure like that in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.108.1">Figure 2</span></em></span><em class="itali"><span class="koboSpan" id="kobo.109.1">.2</span></em><span class="koboSpan" id="kobo.110.1"> from </span><a href="B19916_03.xhtml"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.111.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.112.1">, </span><em class="itali"><span class="koboSpan" id="kobo.113.1">What’s Wrong with Layers?</span></em><span class="koboSpan" id="kobo.114.1"> We have a service in the domain layer that works with entities and repositories from the </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">persistence layer.</span></span></p>
<p><span class="koboSpan" id="kobo.116.1">First of all, we want to pull up the entities into the domain layer because they represent our domain objects and our domain code pretty much revolves around changing the state of </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">those entities.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">But now, we have a circular dependency between both layers since the repository from the persistence layer depends on the entity, which is now in the domain layer. </span><span class="koboSpan" id="kobo.118.2">This is where we apply the</span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.119.1"> DIP. </span><span class="koboSpan" id="kobo.119.2">We create an interface for the repository in the domain layer and let the actual repository in the persistence layer implement it. </span><span class="koboSpan" id="kobo.119.3">The result is something like that in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.120.1">Figure 3</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.121.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<span class="koboSpan" id="kobo.123.1"><img alt="Figure 3.2 – By introducing an interface in the domain layer, we can invert the dependency so that the persistence layer depends on the domain layer" src="image/Figure_03.2_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.124.1">Figure 3.2 – By introducing an interface in the domain layer, we can invert the dependency so that the persistence layer depends on the domain layer</span></p>
<p><span class="koboSpan" id="kobo.125.1">With this trick, we have liberated our domain logic from the oppressive dependency on the persistence code. </span><span class="koboSpan" id="kobo.125.2">This is a core feature of the two architectural styles we’re going to discuss in the </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">upcoming sections.</span></span></p>
<h1 id="_idParaDest-34"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.127.1">Clean Architecture</span></h1>
<p><span class="koboSpan" id="kobo.128.1">Robert C. </span><span class="koboSpan" id="kobo.128.2">Martin coined the term “</span><strong class="bold"><span class="koboSpan" id="kobo.129.1">Clean Architecture</span></strong><span class="koboSpan" id="kobo.130.1">” in his book with the same name.</span><span id="footnote-013-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-013"><span class="koboSpan" id="kobo.131.1">3</span></a></span><span class="koboSpan" id="kobo.132.1"> In a Clean Architecture, in his </span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.133.1">opinion, the business rules are testable by design and independent of frameworks, databases, UI technologies, and other external applications </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">or interfaces.</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-013">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-013-backlink"><span class="koboSpan" id="kobo.135.1">3</span></a> <em class="itali"><span class="koboSpan" id="kobo.136.1">Clean Architecture</span></em><span class="koboSpan" id="kobo.137.1"> by Robert C. </span><span class="koboSpan" id="kobo.137.2">Martin, Prentice Hall, 2017, </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.138.1">Chapter 22</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.140.1">This means that the domain code must not have any outward-facing dependencies. </span><span class="koboSpan" id="kobo.140.2">Instead, with the help of the DIP, all dependencies point toward the </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">domain code.</span></span></p>
<p><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.142.1">Figure 3</span></em></span><em class="itali"><span class="koboSpan" id="kobo.143.1">.3</span></em><span class="koboSpan" id="kobo.144.1"> shows what such an architecture might look like on an </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">abstract level.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<span class="koboSpan" id="kobo.146.1"><img alt="Figure 3.3 – In a Clean Architecture, all dependencies point inward toward the domain logic (Source: Clean Architecture by Robert C. Martin)" src="image/Figure_03.3_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.147.1">Figure 3.3 – In a Clean Architecture, all dependencies point inward toward the domain logic (Source: Clean Architecture by Robert C. </span><span class="koboSpan" id="kobo.147.2">Martin)</span></p>
<p><span class="koboSpan" id="kobo.148.1">The layers in this architecture are wrapped around each other in concentric circles. </span><span class="koboSpan" id="kobo.148.2">The main rule in such an architecture is the “</span><strong class="bold"><span class="koboSpan" id="kobo.149.1">Dependency Rule</span></strong><span class="koboSpan" id="kobo.150.1">,” which states that all dependencies between those layers must </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">point inward.</span></span></p>
<p><span class="koboSpan" id="kobo.152.1">The core of the</span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.153.1"> architecture contains the domain entities, which are accessed by the surrounding use cases. </span><span class="koboSpan" id="kobo.153.2">The use cases are what we have called services earlier, but are more fine-grained to have a single responsibility (i.e., a single reason to change), thus avoiding the problem of </span><em class="itali"><span class="koboSpan" id="kobo.154.1">broad services</span></em><span class="koboSpan" id="kobo.155.1">, as we </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">discussed earlier.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">Around this core, we can find all the other components of our application that support the business rules. </span><span class="koboSpan" id="kobo.157.2">This support can mean providing persistence or providing a UI, for example. </span><span class="koboSpan" id="kobo.157.3">Also, the outer layers may provide adapters to any other </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">third-party component.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">Since the domain code knows nothing about which persistence or UI framework is used, it cannot contain any code specific to those frameworks and will concentrate on the business rules. </span><span class="koboSpan" id="kobo.159.2">We have all the freedom we can</span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.160.1"> wish for to model the domain code. </span><span class="koboSpan" id="kobo.160.2">We could, for example, apply </span><strong class="bold"><span class="koboSpan" id="kobo.161.1">Domain-Driven Design</span></strong><span class="koboSpan" id="kobo.162.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.163.1">DDD</span></strong><span class="koboSpan" id="kobo.164.1">) in its purest form. </span><span class="koboSpan" id="kobo.164.2">Not having to think about persistence or UI-specific problems makes that so </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">much easier.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">As we might expect, Clean Architecture comes at a cost. </span><span class="koboSpan" id="kobo.166.2">Since the domain layer is completely decoupled from the outer layers such as the persistence and UI layers, we have to maintain a model of our application’s entities in each of </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">the layers.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">Let’s assume, for instance, that we’re</span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.169.1"> using an </span><strong class="bold"><span class="koboSpan" id="kobo.170.1">object-relational mapping</span></strong><span class="koboSpan" id="kobo.171.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.172.1">ORM</span></strong><span class="koboSpan" id="kobo.173.1">) framework in our persistence layer. </span><span class="koboSpan" id="kobo.173.2">An ORM framework usually expects specific entity classes that contain metadata describing the database structure and the mapping of object fields to database columns. </span><span class="koboSpan" id="kobo.173.3">Since the domain layer doesn’t know the persistence layer, we cannot use the same entity classes in the domain layer and have to create them in both layers. </span><span class="koboSpan" id="kobo.173.4">This means that the persistence layer needs to map the domain entities to its own representation. </span><span class="koboSpan" id="kobo.173.5">A similar mapping applies between the domain layer and other </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">outer layers.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">But that’s a good thing! </span><span class="koboSpan" id="kobo.175.2">This decoupling is exactly what we wanted to achieve to free the domain code from framework-specific problems. </span><span class="koboSpan" id="kobo.175.3">The Java Persistence API (the standard object-relational API in the Java world), for instance, requires the ORM-managed entities to have a default constructor without arguments that we might want to avoid in our domain model. </span><span class="koboSpan" id="kobo.175.4">In </span><a href="B19916_09.xhtml#_idTextAnchor081"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.176.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.177.1">, </span><em class="itali"><span class="koboSpan" id="kobo.178.1">Mapping </span></em><em class="itali"><span class="koboSpan" id="kobo.179.1">b</span></em><em class="itali"><span class="koboSpan" id="kobo.180.1">etween Boundaries</span></em><span class="koboSpan" id="kobo.181.1">, we’ll talk about different mapping strategies, including a </span><em class="itali"><span class="koboSpan" id="kobo.182.1">no-mapping</span></em><span class="koboSpan" id="kobo.183.1"> strategy that just accepts the coupling between the domain and </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">persistence layers.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">Since </span><em class="itali"><span class="koboSpan" id="kobo.186.1">Clean Architecture</span></em><span class="koboSpan" id="kobo.187.1"> by Robert C. </span><span class="koboSpan" id="kobo.187.2">Martin is somewhat abstract, let’s go a level of detail deeper and look at </span><em class="itali"><span class="koboSpan" id="kobo.188.1">Hexagonal Architecture</span></em><span class="koboSpan" id="kobo.189.1">, which gives the </span><em class="itali"><span class="koboSpan" id="kobo.190.1">Clean Architecture</span></em><span class="koboSpan" id="kobo.191.1"> principles a more </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">concrete shape.</span></span></p>
<h1 id="_idParaDest-35"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.193.1">Hexagonal Architecture</span></h1>
<p><span class="koboSpan" id="kobo.194.1">The term </span><strong class="bold"><span class="koboSpan" id="kobo.195.1">Hexagonal Architecture</span></strong><span class="koboSpan" id="kobo.196.1"> stems </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.197.1">from Alistair Cockburn and has been around for quite some time.</span><span id="footnote-012-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-012"><span class="koboSpan" id="kobo.198.1">4</span></a></span><span class="koboSpan" id="kobo.199.1"> It applies the same principles that Robert C. </span><span class="koboSpan" id="kobo.199.2">Martin later described in more general</span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.200.1"> terms in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.201.1">Clean Architecture</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">.</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-012">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-012-backlink"><span class="koboSpan" id="kobo.203.1">4</span></a><span class="koboSpan" id="kobo.204.1">	The primary source for the term "Hexagonal Architecture" seems to be an article on Alistair Cockburn's website </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">at </span></span><a href="https://alistair.cockburn.us/hexagonal-architecture/"><span class="No-Break"><span class="koboSpan" id="kobo.206.1">https://alistair.cockburn.us/hexagonal-architecture/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.207.1">.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.208.1"><img alt="Figure 3.4 – A Hexagonal Architecture is also called a “Ports and Adapters” architecture since the application core provides specific ports for each adapter to interact with" src="image/Figure_03.4_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.209.1">Figure 3.4 – A Hexagonal Architecture is also called a “Ports and Adapters” architecture since the application core provides specific ports for each adapter to interact with</span></p>
<p><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.210.1">Figure 3</span></em></span><em class="itali"><span class="koboSpan" id="kobo.211.1">.4 </span></em><span class="koboSpan" id="kobo.212.1">shows what a Hexagonal Architecture might look like. </span><span class="koboSpan" id="kobo.212.2">The application core is represented as a hexagon, giving this architectural style its name. </span><span class="koboSpan" id="kobo.212.3">The hexagon shape has no meaning, however, so we might just as well draw an octagon and call it “Octagonal Architecture.” </span><span class="koboSpan" id="kobo.212.4">According to legend, the hexagon was simply used instead of the common rectangle to show that an application can have more than four sides connecting it to other systems </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">or adapters.</span></span></p>
<p><span class="koboSpan" id="kobo.214.1">Within the hexagon, we find our domain entities and the use cases that work with those entities. </span><span class="koboSpan" id="kobo.214.2">Note that the hexagon has no outgoing dependencies so the Dependency Rule from Martin’s Clean Architecture </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.215.1">holds true. </span><span class="koboSpan" id="kobo.215.2">Instead, all dependencies point toward </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">the center.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">Outside the hexagon, we find various </span><strong class="bold"><span class="koboSpan" id="kobo.218.1">adapters</span></strong><span class="koboSpan" id="kobo.219.1"> that interact with the application. </span><span class="koboSpan" id="kobo.219.2">There might be a web adapter that interacts with a web browser, some adapters interacting with external systems, and an adapter that interacts with a database </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">for persistence.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">The adapters on the left side are adapters that drive our application (because they call our application core) while the adapters on the right side are driven by our application (because they are called by our </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">application core).</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">To allow communication between the application core and the adapters, the application core provides specific </span><strong class="bold"><span class="koboSpan" id="kobo.224.1">ports</span></strong><span class="koboSpan" id="kobo.225.1">. </span><span class="koboSpan" id="kobo.225.2">For driving adapters, such a port might be an interface that is implemented by one of the use case classes in the core and called by the adapter. </span><span class="koboSpan" id="kobo.225.3">For a driven adapter, it might be an interface that is implemented by the adapter and called by the core. </span><span class="koboSpan" id="kobo.225.4">We might even have multiple adapters implementing the same port: one for communicating with a real external system, and one for communicating with a mock to be used in testing, </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">for example.</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">To clearly call out a central attribute of Hexagonal Architecture, </span><em class="itali"><span class="koboSpan" id="kobo.228.1">the application core (the hexagon) defines and owns the interface to the outside</span></em><span class="koboSpan" id="kobo.229.1"> (</span><em class="itali"><span class="koboSpan" id="kobo.230.1">the ports</span></em><span class="koboSpan" id="kobo.231.1">). </span><span class="koboSpan" id="kobo.231.2">The adapters then work with this interface. </span><span class="koboSpan" id="kobo.231.3">This is the</span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.232.1"> Dependency Inversion Principle applied at the </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">architecture level.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">Due to its central concepts, this architecture</span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.235.1"> style is also known as a </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">Ports and </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.237.1">Adapters </span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">Just like Clean Architecture, we can organize this Hexagonal Architecture into layers. </span><span class="koboSpan" id="kobo.239.2">The outermost layer consists of the adapters that translate between the application and </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">other systems.</span></span></p>
<p><span class="koboSpan" id="kobo.241.1">Next, we can combine the ports and use case implementations to form the application layer because they define the interface of our application. </span><span class="koboSpan" id="kobo.241.2">The final layer contains the domain entities implementing the </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">business rules.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">The business logic is implemented in the use case classes and entities. </span><span class="koboSpan" id="kobo.243.2">The use case classes are narrow </span><strong class="bold"><span class="koboSpan" id="kobo.244.1">domain services</span></strong><span class="koboSpan" id="kobo.245.1">, implementing just a single use case. </span><span class="koboSpan" id="kobo.245.2">We can choose to combine multiple use cases to a broader domain service, of course, but ideally, we do this only when the use cases are often used together, to </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">increase maintainability.</span></span></p>
<p><span class="koboSpan" id="kobo.247.1">Potentially, we will want to introduce the concept of application services, too. </span><span class="koboSpan" id="kobo.247.2">An </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">application service</span></strong><strong class="bold"><a id="_idIndexMarker060"/></strong><span class="koboSpan" id="kobo.249.1"> is a service that coordinates calls to use cases (</span><strong class="bold"><span class="koboSpan" id="kobo.250.1">domain services</span></strong><span class="koboSpan" id="kobo.251.1">), as shown in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.252.1">Figure 3</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.253.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.255.1"><img alt="Figure 3.5 – A Hexagonal Architecture using the DDD concepts of application and domain services" src="image/Figure_03.5_B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.256.1">Figure 3.5 – A Hexagonal Architecture using the DDD concepts of application and domain services</span></p>
<p><span class="koboSpan" id="kobo.257.1">Here, the application services translate between the input and output ports and the domain services, shielding the domain services from the outside world, and potentially coordinating between the domain </span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.258.1">services. </span><span class="koboSpan" id="kobo.258.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.259.1">Domain Service</span></strong><span class="koboSpan" id="kobo.260.1"> boxes are synonymous with the </span><strong class="bold"><span class="koboSpan" id="kobo.261.1">Use Case</span></strong><span class="koboSpan" id="kobo.262.1"> boxes from </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.263.1">Figure 3</span></em></span><em class="itali"><span class="koboSpan" id="kobo.264.1">.4</span></em><span class="koboSpan" id="kobo.265.1">; we’re just now using terminology borrowed </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">from DDD.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">As this discussion implies, we’re free to design our application code as we see fit inside the hexagon. </span><span class="koboSpan" id="kobo.267.2">We can go simple or sophisticated, matching the complexity and size of our application. </span><span class="koboSpan" id="kobo.267.3">We will learn more about managing code within our hexagon in </span><a href="B19916_13.xhtml#_idTextAnchor112"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.268.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.269.1">, </span><em class="itali"><span class="koboSpan" id="kobo.270.1">Managing Multiple </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.271.1">Bounded Contexts</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">In the next chapter, we’ll discuss a way to organize such an architecture </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">in code.</span></span></p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.275.1">How does this help me build maintainable software?</span></h1>
<p><span class="koboSpan" id="kobo.276.1">Call it “Clean Architecture,” “Hexagonal Architecture,” or “Ports and Adapters Architecture” – by inverting our dependencies so that the domain code has no dependencies on the outside, we can decouple our domain logic from all those persistence- and UI-specific problems and reduce the number of reasons to make changes throughout the code base. </span><span class="koboSpan" id="kobo.276.2">And fewer reasons to change lead to </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">better maintainability.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">The domain code is free to be modeled as best fits the business problems, while the persistence and UI code are free to be modeled as best fits the persistence and </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">UI problems.</span></span></p>
<p><span class="koboSpan" id="kobo.280.1">In the rest of this book, we’ll apply the Hexagonal Architecture style to a web application. </span><span class="koboSpan" id="kobo.280.2">We’ll start by creating the package structure of our application and discussing the role of </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">dependency injection.</span></span></p>
</div>
</body></html>