- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Desktop Graphical User Interface Coding with Swing and JavaFX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce a simple but complete application for providing
    three common financial calculations. These are loan payments, the future value
    of money, and a savings goal. We will look at two versions of this application,
    one written using the Swing library and the second using the JavaFX library. The
    server-side coding for this application will be covered in [*Chapter 15*](B19088_15.xhtml#_idTextAnchor301),
    *Jakarta* *Faces Application*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief history of Java GUIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A financial calculator program design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Swing GUI framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the JavaFX GUI framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which should I use?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the basics of GUI coding using
    the two most widely used frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the tools required to run the examples in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A text editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven 3.8.6 or a newer version installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sample code for this chapter is available at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter13](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter13).
  prefs: []
  type: TYPE_NORMAL
- en: A brief history of Java GUIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first user interfaces in personal computers mimicked the terminals of mainframes
    or minicomputers. Apple introduced the Mac in 1984 and Microsoft introduced Windows
    a year later. Yet, most personal computers sold in the 1980s had terminal interfaces.
    What changed everything was the general availability of the internet and the creation
    of the technology behind the World Wide Web by Tim Berners-Lee, starting in 1989\.
    By the end of the 20th century, we expected the computers we used to have a GUI.
    In [*Chapter 15*](B19088_15.xhtml#_idTextAnchor301), *Jakarta Faces Application*,
    we will look at web programming in Java, while in this chapter, we will look at
    desktop GUI programming.
  prefs: []
  type: TYPE_NORMAL
- en: When Java was introduced in 1995, its original purpose was the creation of applets,
    small programs that run from web pages inside a web browser. These pages delivered
    compiled applets that ran in the JVM rather than in the browser. JavaScript, also
    developed around the same time, ran inside the browser. This led to the first
    GUI library, which is still included in Java today, called the **Abstract Window
    Toolkit** (**AWT**), still usable for desktop apps. Applets are no more, having
    been deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: The AWT depends on the underlying operating system for rendering a GUI. An AWT
    program running on an Apple Mac had a look and feel like a native Mac app. If
    you ran the same code on a Windows PC, its look and feel were like a native Windows
    app. As Java became popular in the application rather than web space, an enhanced
    GUI library, Swing – first introduced in 1996 – gained traction. Unlike AWT, Swing
    could render its own controls. Now, it was possible to develop a user interface
    that looked nearly identical on Windows, Mac, and Linux. In the *Further reading*
    list is a link to a Swing look-and-feel library called **Napkin**. It is an extreme
    example of how you could style Swing applications. Swing remains in wide use today.
    It is a standard library, included with all distributions of Java. It is maintained
    with bug fixes and minor enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: In 2008, JavaFX 1.0, an alternative to Swing, was introduced. The version we
    will be looking at began as JavaFX 2.0 in 2011\. The original purpose of JavaFX
    was to have a common platform for GUI apps on the desktop, the web, and mobile
    devices. Like Swing, it took care of its own rendering. It also introduced a declarative
    approach to defining a user interface, based on the XML language FXML. In this
    chapter, we will look at the imperative or coding approach to defining an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us look at the application we will construct.
  prefs: []
  type: TYPE_NORMAL
- en: Financial calculator program design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we took the loan calculation that used doubles and
    changed it to use `BigDecimal`. We will continue to use this calculation plus
    two additional ones. One is a savings goal, whereby you indicate how much you
    wish to save, what the expected interest rate will be, and the number of months
    in which you wish to reach your goal. The second is the future value, whereby
    you can determine the amount of money you will have after saving the same amount
    for a specific number of months at an expected interest rate.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the same data class and business class from the previous chapter.
    To the business class, we will add the two new calculations. We will not go over
    the new calculations in this chapter, as you can see them in the chapter’s source
    code. For now, we will consider the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application will present the user with three choices for the calculation.
    We want a single form into which we can enter the three values each calculation
    requires and where the result will appear. Finally, we want a button to signal
    that the calculation can be carried out. I usually work out the actual design
    on paper or a whiteboard, such as this figure:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.1 – A \uFEFF\uFEFFhand-drawn design](img/B19088_13_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – A hand-drawn design
  prefs: []
  type: TYPE_NORMAL
- en: 'When we finish, it will look like this when doing a calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – The Swing version](img/B19088_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – The Swing version
  prefs: []
  type: TYPE_NORMAL
- en: The choice of calculation is determined by a group of three radio buttons. These
    are controls that are either selected or not, and you can only select one. When
    the user selects a calculation, the description of the title that follows the
    radio buttons will change, all fields will become zero, the first input field
    description will change, and pressing the **Calculate** button will use the calculation
    that matches the radio button selected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – The future value and savings goal screens](img/B19088_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – The future value and savings goal screens
  prefs: []
  type: TYPE_NORMAL
- en: As you already know, users cannot always be trusted to enter valid information.
    There is always a user who will enter `Bob` for a loan amount. We could throw
    up message boxes informing the user of their error. In certain situations, this
    does make sense. In this user interface, we can recognize that the only allowable
    input in the first three fields must be a number and only allow a single decimal
    point. You just cannot enter `Bob`. A field that is blank will be changed to contain
    a zero. The last field is not editable, as it displays the result.
  prefs: []
  type: TYPE_NORMAL
- en: Internationalization – i18n
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One last element of the design is internationalization, commonly referred to
    as i18n. This means that this program can present itself in multiple languages.
    I live in Canada, where we have two official languages – English and French. This
    means that anything that has written text in the interface must have a version
    in each language. Here it is in French:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – The French version](img/B19088_13_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – The French version
  prefs: []
  type: TYPE_NORMAL
- en: 'We accomplish i18n by placing all text that will appear in the GUI into a properties
    file, one for each language you plan to support. Here is the English properties
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can see the French version in the project. These properties files are commonly
    called `ResourceBundle`, you must first load the properties file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the default `Locale`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Set `Locale` in the code, which can be quite useful for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Internationalization works the same in JavaFX. Let us look at how this application
    is coded in Swing.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Swing GUI framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the GUI library chosen, we can now decide what classes this application
    will need and how they will be packaged. Here is the finished project layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – The Swing project layout](img/B19088_13_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – The Swing project layout
  prefs: []
  type: TYPE_NORMAL
- en: The source code on GitHub is extremely commented, and I encourage you to download
    it while reading this. Let us begin by looking at the basic components and controls
    of a Swing application. We begin with `JFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: JFrame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every Swing application needs a main or top-level container. There are four
    classes for this purpose, but one is now deprecated for removal. They are `JFrame`,
    `JDialog`, `JWindow`, and the deprecated `JApplet`. The `JWindow` class is ideal
    for splash screens, as they have no decorations, such as a border, title bar,
    or window controls. You commonly use `JDialog` as part of an application to interact
    with a user over details you do not want in the top-level container you are using.
    It can also be used for simple applications that require minimal interaction with
    the user and so can also be used as a top-level container. `JApplet` brought Swing
    to the web browser, but it is now headed to the dustbin of history. Let us talk
    about `JFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: The `JFrame` class is a decorated container, meaning it has a border and title
    bar. It supports `JMenuBar` should you want a menu. It can be resizable or a fixed
    size. Into `JFrame` goes all other components and controls. In my sample code,
    I have used inheritance to extend `JFrame` in the `FinanceCalculatorMain` class.
    This simplifies the coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code that sets up the frame. You will see an additional step in
    the *JPanel* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: JPanel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `JPanel` class is a container for other components and controls. While the
    `JFrame` class already has the `JPanel` class, which is commonly referred to as
    the content pane, we rarely use it for anything more than adding a user-designed
    `JPanel`. This is exactly what my sample does. There is a second class called
    `FinanceCalculatorUI` that extends `JPanel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add controls such as buttons, text fields, or other JPanels to a `JPanel`
    class, we must first decide on a `LayoutManager` class. These are objects that
    are responsible for the placement of items in `JPanel`. The main panel in the
    app is `FinancialCalculatorUI`, which extends `JPanel`. In its constructor, we
    write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Later in the code, another `JPanel` is created that does not extend another
    class. We can pass the layout manager through the `JPanel` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It is quite common to create a user interface with multiple panels. The following
    diagram shows all the panels used:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.6 – The J\uFEFFPanel layout](img/B19088_13_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – The JPanel layout
  prefs: []
  type: TYPE_NORMAL
- en: The first `JPanel`, `FinancialCalculatorUI`, is assigned to the content pane
    of `JFrame`. It will have a `BorderLayout` that has north, south, east, west,
    and center zones. In each zone of a layout, you can add another panel or control.
    Anything you place in this layout will fill the zone. In the north, we placed
    a panel with `JRadioButtons`. In the center, we placed another `JPanel` with `BorderLayout`.
    In the north of this panel, we place a panel that contains the title. In the south,
    there is a panel with the calculate button. In the center, we place another panel
    with `GridBagLayout` that allows us to treat the panel as rows and columns, which
    is ideal for forms.
  prefs: []
  type: TYPE_NORMAL
- en: Event handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any component that can accept user input from either the keyboard or mouse
    can generate an event. You can choose to ignore an event, or you can register
    an event handler you have written. Here is the code that registers a method in
    the same class as the handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `calculateButtonHandler` method accepts an `ActionEvent` object. The object
    contains information on the event, but in this case, we do not need it. The method
    validates that the fields can be `BigDecimal`, assigns them to `FinanceBean`,
    and, if all is well, calls on the `FinanceCalculations` object to do the calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Document filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our design, we decided to only allow the end user to enter a number. This
    number can only have one decimal point and without a sign, because all values
    must be positive. In Swing, `JTextField` has inside it an object of type `Document`,
    and from this, we can access and replace the `DocumentFilter` object. In the filter,
    there is a method called `replace` that is called with every keystroke. We will
    install our own filter that inherits/extends `DocumentFilter`.
  prefs: []
  type: TYPE_NORMAL
- en: The `replace` method receives the string that you entered and the location where
    in the current text field this string is inserted. It is called before the text
    is entered in the document; we have access to the contents of the text field before
    it is changed. This means that should the user input turn out to be invalid, we
    can restore what was in the text field prior to the new string we entered.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching with regular expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *regular expression* or *regex* is a description of what may or may not be
    allowed in a string. Pattern matching employs a regex to determine whether a string
    that a pattern is being applied to meets the requirements of the regex. These
    expressions define a pattern that will be applied to the user input string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first line takes a regular expression and compiles it. Regular expressions
    are compiled every time you use them, if not compiled in advance. This is the
    role of creating a `Pattern` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second line creates a `Matcher` object. Here, we create a `Matcher` object
    built from the `Pattern` object that can evaluate the string in the parenthesis
    and return `true` or `false`. In the `Matcher` declaration, it might seem strange
    to search in an empty string, but as we will see, you can change the string that
    you want to search for after you create the `Matcher` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `reset` method of `Matcher` is what allows us to change a string to search
    through. The `newText` object is the string after the new characters are added
    to the original string. If the match fails, then the string already in the text
    field is unchanged. The approach taken here will work if the user is pasting strings
    into the text field.
  prefs: []
  type: TYPE_NORMAL
- en: There are many developers who believe that pattern matching is costly, meaning
    it uses a lot of CPU time. Exceptions are also costly. If they are both costly,
    then the simpler exception approach will have the edge for most users. However,
    a simple test comparing the performance of pattern matching versus exception throwing,
    using the Java **Microbenchmark Harness** library, showed that pattern matching
    can be between 8 and 10 times faster than using an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Controls and panels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us look at two controls that are placed in a panel with `GridBagLayout`.
    We begin with `JLabel`. We provide the text to display in its constructor. The
    actual text is coming from the appropriate `ResourceBundle` that the `form` object
    represents. We set the font next. This font is used in more than one place, so
    it has already been defined as `labelFont`. Finally, we add `JLabel` to the panel.
    To do this, we need an object of type `GridBagConstraints`. There are five details
    about how this control is added. The number `0` represents the column and the
    number `2` represents the row. The next two numbers represent how many columns
    and rows this control will use in the grid. Finally, we indicate the alignment
    of the control in the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `JTextField` control has added settings for horizontal alignment and the
    width of the field measured in columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we extract the control’s `Document` and use this reference to install
    our filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add `JTextField` to the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You will find more details on this Swing version in the source code. Now, let
    us look at the JavaFX version.
  prefs: []
  type: TYPE_NORMAL
- en: Using the JavaFX GUI framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This version of the program is like the Swing version. The design of the user
    interface is identical in that it employs panes in panes. Here is the finished
    project layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – The JavaFX program layout](img/B19088_13_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – The JavaFX program layout
  prefs: []
  type: TYPE_NORMAL
- en: Let us now look at the classes from the JavaFX framework that we will need for
    our program.
  prefs: []
  type: TYPE_NORMAL
- en: Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A JavaFX program must contain a class that extends `Application`. Within this
    class, we can construct the user interface or delegate this work to another class.
    A class that extends `Application` must implement a method called `start` and,
    optionally, a method called `init`. What you rarely have is a constructor. The
    JavaFX framework is not available to a constructor of a class that extends `Application`.
    This is where `init` comes in. It plays the role of the constructor but in an
    environment where JavaFX is up and running. You do not call `init`; JavaFX will.
  prefs: []
  type: TYPE_NORMAL
- en: The `start` method is where the creation of the GUI commences. The method is
    called by JavaFX right after `init`.
  prefs: []
  type: TYPE_NORMAL
- en: PrimaryStage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `PrimaryStage` object is akin to `JFrame`. You do not create an instance
    of it. The `Application` class you are extending creates a `PrimaryStage` object
    and passes it on to `start`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Pane
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike Swing, where you define a panel and assign a layout manager to it, FX
    uses panes that include the layout. The first pane that we are creating is `BorderPane`,
    which has top, bottom, left, right, and center zones. We are adding to it a pane
    that contains the radio buttons at the top and another pane in the center:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The story goes that the original developer of JavaFX was a performing arts aficionado,
    and this led him to use theater names for parts of the framework. A `Stage` object
    must contain a `Scene` object that, in turn, contains a pane object. You can create
    multiple scenes and switch between them if required. For me, one of the most noteworthy
    features of JavaFX is its use of **Cascading Style Sheet** (**CSS**), and the
    second line will load it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The next four lines should be self-explanatory. The last line calls the show
    method to get the program going.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: CSS style sheets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You style components using CSS. This is similar but not identical to CSS used
    in web development. In the *Further reading* section, there is a link to the CSS
    reference document. Here is the style sheet used in this application. Class names
    beginning with a period are predefined. Class names beginning with an octothorpe
    are the ones that you assign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can assign a custom class name for a control by using the control’s `setId`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also enter the CSS styling directly in the source code. CSS entered
    this way will override what is in the external style sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: JavaFX bean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A JavaFX bean is designed to support binding a field in the bean with a control.
    Any change to the control is written to the bean, and anything written to the
    bean will update the control. This is commonly called the observer pattern. To
    accomplish this, we must wrap all the data types into a family of objects called
    properties. A JavaFX bean can be used where a JavaBean is expected. This means
    that there is no need to alter the `FinancialCalculations` class, as it will work
    with the JavaFX bean without any changes to its code. Here is our `FinanceFXBean`
    class as a JavaFX bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than declare primitive or class types directly, they must be wrapped
    into an appropriate `Property` class. There are such classes for all the primitive
    data types, such as `DoubleProperty` or `StringProperty`. In our example, we are
    using `BigDecimal`, for which there is no property. This is where the `ObjectProperty`
    class comes in. This allows you to use any class as a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two constructors. The first is a default constructor that calls upon
    the non-default constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The non-default constructor must instantiate each of the `Property` objects
    and initialize them, with `BigDecimal` passed to it. There is a simple property
    for each of the defined properties. `SimpleObjectProperty` is used when there
    is not a named property, such as `SimpleDoubleProperty`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike a JavaBean, there are three methods for each property. The first two,
    the getter and setter, retrieve the value from inside the property or change the
    value in the property. This is how a JavaFX bean can replace a Java bean, as the
    getter and setters are named the same and return or receive the same data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The last of the three methods returns the property. This is used to implement
    binding and the observable pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: BigDecimalTextField
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a class that extends the JavaFX `TextField`. Unlike Swing’s `JTextField`,
    there is no `Document`. Pressing a key will invoke a method in `TextField` that
    we override to meet our needs. These methods use regular expressions for pattern
    matching. There is now a second regular expression that is used to modify the
    string by removing leading zeros.
  prefs: []
  type: TYPE_NORMAL
- en: There are two methods that we override. The first is `replaceText` for handling
    keyboard input. The second is `replaceSelection` for handling changes that arise
    from selecting text and then replacing it, either from the keyboard or by pasting.
  prefs: []
  type: TYPE_NORMAL
- en: Controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a similarity in how we create controls and add them to a pane. You
    create `GridPane` to hold the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`inputLabel` is instantiated using `ResourceBundle`. A custom CSS-style `id`
    is assigned next. Finally, we add the label to the `financeGrid` pane, indicating
    the column and row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`inputValue` is constructed from our custom `BigDecimalTextField`. We assign
    it a custom CSS `id`, change its alignment, and add it to `financeGrid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Binding a primitive data type to a field in a JavaFX bean requires a converter.
    There are some standard converters, one of which is for `BigDecimal` to convert
    from a string to a BigDecimal. Here is the binding method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We are creating a `BigDecimalStringConverter` object that we can reuse in each
    of the bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For each binding, we pass `textProperty` of each `TextField`, the property
    for each field in the `FinanceFXBean`, and our converter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Which should you use? Read the following summary to decide.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swing is a mature GUI framework that is maintained as part of the Java distribution.
    Having been around for so long, there has been much written on how to use it.
    Choosing Swing for your GUI project is a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: JavaFX is the new kid on the block, so to speak. The two most significant differences
    are binding and CSS style sheets. Although not covered here, JavaFX also has much
    better graphics support. In JavaFX graphics, primitives such as a line or a rectangle
    are on par with controls. JavaFX has an `Animation` class that simplifies creating
    moving graphics. There is a also chart library to create line charts, pie charts,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Users today expect a GUI in the software they use. Swing projects do not need
    to be rewritten using JavaFX, and new projects using Swing continue to be written.
    So, which should you use? In my opinion, new projects should use JavaFX. Swing
    is, for the most part, in maintenance mode to ensure that it works, taking advantage
    of changes in the core language. JavaFX, on the other hand, is actively maintained
    as an open source project, with both maintenance and new features added to each
    release.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will look at how Java is used to write software for
    the World Wide Web that runs in a container called an application server.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Napkin look and feel: [https://napkinlaf.sourceforge.net/](https://napkinlaf.sourceforge.net/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Java Microbenchmark Harness: [https://medium.com/javarevisited/understanding-java-microbenchmark-harness-or-jmh-tool-5b9b90ccbe8d](https://medium.com/javarevisited/understanding-java-microbenchmark-harness-or-jmh-tool-5b9b90ccbe8d'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Pattern matching: [https://xperti.io/blogs/pattern-matching-java-feature-spotlight/](https://xperti.io/blogs/pattern-matching-java-feature-spotlight/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '*JavaFX CSS Reference* *Guide*: [https://openjfx.io/javadoc/17/javafx.graphics/javafx/scene/doc-files/cssref.html](https://openjfx.io/javadoc/17/javafx.graphics/javafx/scene/doc-files/cssref.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
