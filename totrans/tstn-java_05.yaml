- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Language Fundamentals – Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **object-oriented** (**OO**) program is based on the design of structures
    called classes that are used as the blueprint for objects. An object is the implementation
    of a class. This means that the first step in coding in **OO programming** (**OOP**)
    is to create classes. This chapter will examine how the features of OOP are implemented
    in Java. We begin by looking at how we define variables in a class followed by
    how we control access to members of a class and the class itself. From here, we
    will look at the class structure Java provides us for creating or working with
    classes and objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Class fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding access control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to define classes, instantiate
    them into objects, and interact with other classes. Let’s begin by looking at
    access control. Before we begin, let’s look at the two categories of variables
    that you can declare in a class.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the tools required to run the examples in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 17 installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven 3.8.6 or a newer version installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code from this chapter in the GitHub repository at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter05](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Class fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Variables declared in a class and not in a method call are referred to as fields.
    They fall into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Instance variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double` in a class and we created 100 instances of the object, we would have
    100 doubles.'
  prefs: []
  type: TYPE_NORMAL
- en: In Java, you can have a variable in a class that is shared by all objects created
    from the class. In other words, every object has a unique set of instance variables,
    but all share the **class variables**. This is accomplished by designating the
    variable as static. There is only one memory allocation for a static variable.
    In our 100 instances of an object, there is just one double if you declare the
    double as static.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another characteristic of a static or class variable is that assuming it has
    public access control, you can access it without instantiating the object. For
    example, consider the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this fragment, we can access the `class` variable `bob` by simply writing
    `TestBed.bob`. We don’t have to instantiate the object. If we do instantiate it,
    we can use the reference, though this is rare.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that class variables are shared by all objects makes them an ideal
    tool for objects created from the same class to communicate with each other. If
    one object changes the value of a class variable, then even another object of
    the same class can see the updated value.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to the next section on access control, let’s clarify one more
    term. We refer to all variables declared in a class as **fields**. This includes
    both class and instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding access control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One significant and invaluable feature of OOP is **access control**. If you
    have already worked with an OO language, then you may be familiar with this concept;
    if not, let me explain what access control means.
  prefs: []
  type: TYPE_NORMAL
- en: Access control in Java concerns the visibility of classes, fields, and methods
    to other classes. You must have sufficient access to create objects and access
    fields and methods in a class.
  prefs: []
  type: TYPE_NORMAL
- en: Access control, in other languages, may imply a security mechanism that can
    ensure that a request for access to a method–for example–is coming from an authenticated
    user. This is not what Java does; in Java, it is about how objects can interact
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the options for visibility; the first will be Java packages.
  prefs: []
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first piece of the access control puzzle is the Java package and its corresponding
    `import` statement. In [*Chapter 3*](B19088_03.xhtml#_idTextAnchor062), *The Maven
    Build Tool*, we learned about Java packages and how they are simply a folder that
    contains Java code. Code in one package cannot access code in another package
    unless you give access by including an `import` statement. The class that imports
    can access code in what it imports. Without an `import` class, the `statement`
    classes in different packages cannot interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the interaction is one way. For example, class A has an `import`
    statement for class B. Class A can call or send messages to code in class B but
    not vice versa. You could add an `import` statement to class B for class A, and
    then they can each send a message to the other.
  prefs: []
  type: TYPE_NORMAL
- en: Using packages for access control is simplistic; it is a simple binary setting.
    You can either see an object of a class that you are importing or you cannot see
    the class at all if you did not import it. All classes in the same package have
    an implicit import for the other classes in the same package, and, in this case,
    there is no need to import fellow package classes explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to look at the four access control specifiers available to
    us.
  prefs: []
  type: TYPE_NORMAL
- en: The public specifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `import` statement, if required, any other object can create objects of
    that public class.
  prefs: []
  type: TYPE_NORMAL
- en: You can access a public class’s fields from any object that has a reference
    to a second object. We should always keep class fields private so that we cannot
    directly assign values to the field. To interact with a private variable, you
    will need methods in the same class that will be your proxy to read or write to
    the private variable. When writing to the field, you will be able to validate
    the new value before it is assigned to the field.
  prefs: []
  type: TYPE_NORMAL
- en: You can call class methods that are public from any other object that has a
    reference to the object containing the public method. We refer to the public methods
    of a class as its interface. We will look at interfaces in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The private specifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **private specifier** in Java is the same as in C++ and C#–you use this
    specifier to define access control for fields and methods.
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned, class fields should always be private. You will need to
    validate the data that you want to store in a private field. A common way to do
    this is with a mutator, commonly called a setter method. Here, you can add validation
    and reject invalid data by throwing an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Methods designated as private can only be called upon by other methods in the
    same class. Using private methods allows us to break down complex tasks into smaller
    units. As they are private, they cannot be called upon from other objects, and
    this ensures that all the necessary steps of a complex task will be carried out
    in the correct order.
  prefs: []
  type: TYPE_NORMAL
- en: Java permits you to define a new class within another class. This is the only
    situation where a class may be private. A private non-inner class could not be
    instantiated. You cannot use a private inner class outside the class you declare
    it in. You can instantiate a private inner class in the class that declared it.
    As already mentioned, instance variables should always be private while methods
    may be any of the four access designations.
  prefs: []
  type: TYPE_NORMAL
- en: The protected specifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `protected/package`, is only used when you are employing **inheritance**.
    In a non-inheritance situation, protected behaves the same as package access.
    In C++ and C#, the concept of package does not exist, so in a non-inheritance
    situation, these languages treat protected as private.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance, as we will see in the next chapter, is an arrangement between two
    classes where one class is a **superclass** and the other is a **subclass**. A
    subclass can access all the public members of its superclass, including the instance
    variable designated as protected in the superclass. Other objects with references
    to the superclass not involved with inheritance see protected members as private
    or–if these objects are defined in the same package–as package.
  prefs: []
  type: TYPE_NORMAL
- en: Methods and class variables that you designate as protected also possess package
    access, as described in the next section. You cannot have a protected class.
  prefs: []
  type: TYPE_NORMAL
- en: The package specifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This final access specifier, package, has no equivalent in C++ or C#, although
    there is some similarity to the friend concept in these languages. It defines
    the visibility of classes, fields, and methods in other objects that are defined
    in the same package. There is no designator such as public, private, or protected.
    When not explicitly using a specifier on a class, field, or method, then the implicit
    access control is package.
  prefs: []
  type: TYPE_NORMAL
- en: An object that has a reference to another object defined in a different package
    or folder sees protected as private. The objects of two different classes in the
    same package can access protected elements as if they were public.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: One last point before we move on–use protected and package specifiers sparingly.
    They exist for situations where the interaction between objects can be speeded
    up. The problem is that they expose fields and methods to objects that should
    not have access to them. I recommend that you only ever use public and private
    when you start designing and coding a program. Only if you can demonstrate that
    the system performance is suffering by only using public or private components
    should you consider protected and package.
  prefs: []
  type: TYPE_NORMAL
- en: One last point to reiterate–access control does not exist inside a class. This
    means that a public method can call a `private` method in the same class. Every
    method has access to every field no matter its access control designation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to look at how classes work. We will first look at the classes
    from the last chapter’s program, and then we will create an updated version of
    the program.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java, as with other OO languages, uses a syntax that revolves around the source
    code structure called a **class**. But first, what is a class? The theorists who
    introduced the concept of objects envisioned a class as a custom data type. Think
    of the primitive integer type–it has a range of allowable values and a pre-defined
    set of operations such as addition, subtraction, and the other usual operators.
    Imagine a class as a custom primitive in which you decide which operations, in
    the form of methods, your type will perform. One goal of OOP is to focus on problem-solving
    by developing custom data types that combine data and actions as opposed to the
    structured programming approach where data and actions are separate.
  prefs: []
  type: TYPE_NORMAL
- en: This means that you develop a class by first listing all the fields of the class,
    either primitives or references to other classes. Next come the methods that conduct
    useful tasks that make use of these fields. These variables are visible to every
    method in a class regardless of the access control level.
  prefs: []
  type: TYPE_NORMAL
- en: Classes are not executable code, with one exception we will see shortly. Instead,
    a class is a blueprint that must be instantiated or created at runtime using the
    `new` keyword. When your program begins execution, the **Java virtual machine**
    (**JVM**) stores the class definition in a region of memory called the **class-method
    region**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `new` operator conducts two tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Allocates sufficient memory for all the instance variables in a class blueprint.
    We refer to this region of memory as the `Class-Method` region.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigns the address of the allocated regions of memory to the appropriate reference
    variable. A reference variable is always just 4 bytes long. Accessing objects
    through a reference variable is called indirect addressing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a third region of memory that comes into play called the stack. The
    JVM stores all local variables–variables declared in methods–in the stack data
    structure as required. The stack is a dynamic structure that can allocate space
    for variables and then deallocate them by just moving a pointer. If you are interested
    in memory management, see the *Further reading* section at the end of this chapter
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go any further, we need to understand the two methods that the JVM
    can invoke whenever we create an object.
  prefs: []
  type: TYPE_NORMAL
- en: constructor and finalize methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two special methods found in most OO languages related to memory management.
    The `constructor` method runs as the last step in the creation of an object whereas
    the `destructor` method, called `finalize` in Java, runs as the first step when
    an object goes out of scope. How this happens in Java is different than in other
    languages such as C++.
  prefs: []
  type: TYPE_NORMAL
- en: finalize
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There can be only one `finalize` method in a class. You cannot overload it.
    Do not use it–Java 9 deprecated it. If you are a C++ developer, you may mistakenly
    believe that `finalize` is the Java equivalent of a C++ destructor. However, that’s
    not true–here’s why.
  prefs: []
  type: TYPE_NORMAL
- en: In C++, the `delete` operator runs the `destructor` method first. Once the `destructor`
    method runs, the `delete` operator releases the memory used by the object, which
    can now be reallocated. This works because when you execute the `delete` operator
    on a valid pointer to an object, the actions in the `destructor` function execute
    immediately.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, there is no `delete` operator; instead, the JVM monitors all references
    to objects. When an object reference goes out of scope, the JVM enters it on a
    list of references that the JVM will release for you. However, for efficiency
    and performance, the JVM does not immediately release memory. Instead, it puts
    it off for as long as possible. This is due to the time necessary to release memory,
    which can impact the current programs running in the JVM. We call the release
    of memory **garbage collection**.
  prefs: []
  type: TYPE_NORMAL
- en: The JVM runs the `finalize` method just before garbage collection. This garbage
    collection could be occurring every few minutes or less, but that’s very unlikely.
    Given a great deal of RAM (my system has 32 GB), this can mean that garbage collection
    could happen every few hours or even days. Therefore, `finalize` is non-deterministic.
    It may want to effect changes or send messages to parts of your program for reasons
    no longer valid, or that part of the program has already been garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: For this and other reasons, the Java architects made the decision to deprecate
    `finalize`. So, do not use it. If you want a method called before an object goes
    out of scope, then you will have to explicitly call a method you created.
  prefs: []
  type: TYPE_NORMAL
- en: With the `finalize` method discussed and then assigned to the rubbish or deprecated
    bin, let’s look at the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The purpose of the constructor is to conduct any actions necessary as the last
    step in object creation. Typically, you use the constructor to initialize class
    instance variables. We have seen that we can initialize these variables right
    at the point of declaration in the class. Sometimes, the initialization requires
    more steps than just assigning a value, and this is where the constructor is invaluable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You create an object by invoking the `new` operator. The `new` operator conducts
    tasks that result in the creation of an object. I am simplifying how this works,
    but it conveys what you need to know:'
  prefs: []
  type: TYPE_NORMAL
- en: Memory is allocated in the heap region of memory for all instance variables,
    along with other required structures that the JVM requires. The address of this
    memory is what the `this` reference captures. Subsequently, every call to non-static
    methods in this class now has a first parameter, which is the invisible `this`
    parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s code the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we’ll instantiate it, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The non-static methods become the following after being compiled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can never write the code this way. `MyClass this` is implied and so may
    not be written.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we’ll call this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It then becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once memory is allocated, along with other housekeeping chores, the JVM calls
    the appropriate `constructor` method. It does not have a return type as it does
    not have a variable to return a result to. You must name them with the same name
    as the class they belong to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Constructors fall into two categories: default and non-default. A **default
    constructor**, of which there can only be one, has no parameters. A **non-default
    constructor** is one with parameters. It is subject to overloading, so there can
    be more than one non-default constructor if the parameter types are different.'
  prefs: []
  type: TYPE_NORMAL
- en: Java provides the capability of having one constructor call another constructor.
    The first constructor called is determined by the rules of overloading. The called
    constructor can then call upon one other constructor. This call must be the first
    line of code. Watch out for a possible `recursive constructor invocation` error
    where constructor A calls constructor B and constructor B calls constructor A.
  prefs: []
  type: TYPE_NORMAL
- en: Revising the compound interest program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now ready to review our compound interest program and apply what we have
    just covered to the classes in this project.
  prefs: []
  type: TYPE_NORMAL
- en: For this, let’s look in more depth at the `CompoundInterest04` program that
    we discussed in [*Chapter 2*](B19088_02.xhtml#_idTextAnchor043), *Code, Compile,*
    *and Execute*.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by declaring the package in the `CompoundInterestCalculator04.java`
    file. Packages, the folders we place our source code into, allow us to manage
    our code by functionality. The only time you might not want to use a package is
    if you are creating a single-file source-code or Linux shebang application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the package declaration. The file will be in a folder named `business`,
    which is in the `com/kenfogel/compoundinterest04` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This program will be using the `NumberFormat` class. This class is part of
    Java’s standard library, and we know this because the first name in its package
    designation is `java`. To make use of this class, we must import it into our file,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of the class declaration shows us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: This class is public and so can be instantiated in any other class that declares
    a reference to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The public class name, `CompoundInterestCalculator04`, must also be the name
    of the file. You can have more than one class structure in a file but only one
    of them may be public.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the first line of the declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the fields in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We are declaring four instance variables of type `double`. The access control
    designation of `private` means that you cannot access these variables from any
    other class that may have a reference to this class. The `final` modifier defines
    these variables as immutable. In a class, access control does not apply but modifiers
    do. You must initialize a `final` variable where you declared it or in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are declaring references to objects that we will use in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We are declaring two instances of a `NumberFormat` class. You can see from the
    variable names that we planned each one for a different format. These are final,
    meaning we must initialize them with a value and they cannot be instantiated a
    second time. Rather than instantiate the `NumberFormat` references in their declaration,
    we can also instantiate them in a constructor, and that is what we will do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following method is the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The constructor is easy to recognize as it must have the same name as the class.
    It does not return a value as the JVM calls the constructor as part of the `new`
    operation. There is nothing to assign a result from a `return` statement to. This
    is a default constructor as there are no arguments inside the parentheses. A class
    may have only one default constructor but may overload the constructor with constructors
    that take as arguments different data types.
  prefs: []
  type: TYPE_NORMAL
- en: The task that this constructor conducts is the initialization and configuration
    of the `NumberFormat` objects. Rather than just using the `new` operator, this
    class is instantiated by using a factory method. Factory methods conduct additional
    tasks before invoking `new`. Also, take note that we call the methods through
    the class name and not through an object name, very much like the `Math` library
    methods. This tells us that `getCurrencyInstance` and `getPercentInstance` are
    static methods that are available. We will discuss static methods later in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is the method we want to call after the object is instantiated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The name `perform` is just a name of my choosing. All that is important to remember
    is that, except for the constructor, all methods should be verbs. Keep in mind
    that class and variable identifiers should be nouns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line of the method calls upon the `calculateCompoundInterest` method
    to perform the calculation and stores the result in the `result` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This next line displays the result formatted appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The plus symbols in the code mean concatenation. As the string is quite long,
    it has been broken up into multiple strings joined by the plus operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we see the method that carries out the calculation of the answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using the instance variables, calculate the result to a variable named `result`
    that the method returns to whoever called it. It is a private method, so only
    other methods in this class can see it.
  prefs: []
  type: TYPE_NORMAL
- en: The second class from the compound interest example holds just the `main` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, let’s declare the package this file is in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This program will be using the `CompoundInterestCalculator04` class that we
    have written. As with all imports, we are referencing a class that we wrote in
    a package/folder we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the first line that declares the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It shows us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: This class is public and so can be instantiated in any other class that declares
    a reference to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class name, `CompoundInterest04`, must also be the name of the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have more than one class structure in a file but only one of them may
    be public.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Java program must have a `main` method. This is where the JVM begins
    the execution of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `main` method is a static method. What sets static methods apart from non-static
    ones is that we can call these static methods without instantiating the object,
    such as what we did with the static methods for `NumberFormat`. The `Math` library
    works the same way. To use the `pow` function, we just write `Math.pow`. We do
    not need to instantiate the `Math` object first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we instantiate the `CompoundInterestCalculator04` class into an object
    with a reference named `banker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We end `main` with a call to the perform method in `CompoundInterestCalculator04`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We have now reviewed how the `CompoundInterest04` program is constructed and
    how we make use of access control and packages.
  prefs: []
  type: TYPE_NORMAL
- en: Class organization based on functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The compound interest program we have been using from the start of this book
    conducts its specific task correctly. However, the problem with this approach
    is that the program is a dead end–not that being a dead end is necessarily bad.
    Sometimes, you just want a *one-off* program that can determine the answer to
    a specific problem.
  prefs: []
  type: TYPE_NORMAL
- en: But what if we were to write a complex program? In the real world, meaning coding
    in your job, you will seldom be writing programs such as our compound interest
    calculator. Imagine you wanted to create a more thorough banking system. In this
    system, it will be necessary to gather input from the user rather than hardcoding
    it in the program’s source code. Taking it further, you may want to store the
    input and the result in an external storage such as a database. You may also want
    to generate reports based on the stored data.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now reorganize the `CompoundInterest04` program, now renamed `CompoundInterest05`,
    based on functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The data class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step is to design a class that just holds the data. There will be
    no domain methods, such as for calculating, storing in a database, or interacting
    with the end user for input and output methods. We are creating a new data type
    that we can use in classes that perform other actions. This type of class follows
    a pattern first described as a **JavaBean**. Java introduced it as a reusable
    software component.
  prefs: []
  type: TYPE_NORMAL
- en: What we are creating is not a pure JavaBean, but a variant. I frequently refer
    to this type of class as a simple box of variables. Let’s look at one for our
    compound interest problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with the `package` statement. We will use the package name in any
    class that needs to use this by importing the name, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the standard public class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the four variables required to perform the calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We declare the four instance variables here. They are final so that once assigned
    a value, it becomes immutable. We expect these to come from the program’s user
    rather than hardcoding the values as we have done up until now. This means that
    every new calculation will need a new `CompoundInterestData` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This last variable is where we plan to store the result of the calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As there are no actions in this class, we cannot determine when this value will
    be set, so it cannot be final.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It has four required arguments when this class is instantiated. Once assigned
    to the class variables, you cannot change the value they hold. Take note of the
    `this` keyword. As we used the same name for the instance variables and the arguments
    of the method, we use `this` to designate an instance variable. Remember that
    `this` is the address of the instance variables in the class. There is not a `this`
    reference for class or static variables as there is ever only one of them per
    class. Without using `this`, you are referring to the method’s argument of the
    same name. The `result` instance variable is not one of the arguments as you will
    calculate its value later in the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next four methods are getters for the four class instance variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The JavaBean specification that this class is based on requires that all instance
    variables be private. The spec goes on to define setter and getter methods. As
    these first four are immutable by virtue of being `final`, you can only have a
    getter. You will be providing the initial value when you create an object using
    `new`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These last two methods are special because the `result` variable is not final:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We determine the value after this class is instantiated. We assign values to
    the four input values in the constructor. Frameworks such as the Java Persistence
    API or Jakarta expect this getter and setter syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The business class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s write the `calculation` class. Its sole purpose will be to calculate
    the result and store it in the bean. We are importing the data class we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This class has only one method and does not have any instance variables. As
    all the values are in `CompoundInterestData05`, we retrieve the values with a
    call to the property’s `getter` method. We end by assigning the result to the
    bean’s result variable by calling the only setter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The user interface class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last component is the user interface where we can ask the user for the
    four pieces of information required to perform the calculation. This is where
    we will create this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `package` statement, we have imports for the classes and libraries
    we will use. We have a new import, and that is for the `Scanner` library class.
    Objects of the `Scanner` class allow us to gather end-user input, such as from
    the keyboard, in a console application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In Java, there are no rules covering the order of methods or the locations of
    fields, unlike in C and C++ where the order can be significant. My personal style
    is, as you see in these examples, to place the instance variables first and the
    constructors right after. My advice on this point is to have the team you work
    with all agree to the coding style. This will make reading each other’s code far
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the constructor that instantiates the `NumberFormat` objects and the
    `Scanner` class. You must provide the `Scanner` class’s constructor with the source
    of input. It could be from a file on disk, but for this program, it is coming
    from the keyboard. We call the object that interacts with the keyboard’s `System.in`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is the entry point for this user interface class. This will be the
    only public method in this class. I use the `do` prefix as it ensures that the
    name is a verb or action. The four values we must request from the user exist
    as local or method variables. We assign the result of user input to each one.
    We instantiate the data object with the four local variables as parameters in
    this expression. The `new` operator copies the values from the local variables
    to the instance variables of the `CompoundInterestData05` object through the constructor.
    We then call upon `calculateCompoundInterest` in our `Calculator` class to calculate
    the result. The last step is to display the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This version of the `CompoundInterest` program follows the classic pattern
    of input, process, and output. The first method we now encounter is `output`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This next method is part of the input process. It could provide additional
    instructions on the screen to the end user, but I have kept it simple here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we come to the user input. Each input will display a prompt and wait for
    input. Once you enter the string, the `nextDouble` method attempts to convert
    it to the appropriate type–in this case, `double`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: But wait–there is something terribly wrong with the four input methods. They
    are identical except for the `String` prompt. As a teacher, I described repeated
    code as an invitation to failure. If we decided to make a change, such as switching
    from `double` to `float`, we must remember to make this change four times in eight
    separate places. The potential for inadvertently neglecting one of the changes
    is too high. Let’s turn this from four methods to one.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s simple–just make the prompt an argument to a single input method, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the `doUserInput` method for all four user inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: All user input is a `String` object; you cannot enter pure numbers, Booleans,
    or characters. The `Scanner` class is responsible for converting from a string
    to the destination type, as expressed by the next methods.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, they are all doubles. What happens if we enter the `bob` string
    instead of a number? Java will throw an exception. This is an error condition.
    When we look at loops, we will learn how to create user-proof input, and when
    we look at GUI programming, we will learn about other ways we can manage user
    input. In all situations, all input arrives–as already mentioned–as strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last class is the `app` class. We commonly use the designation app to define
    a package that contains the class that holds the `main` method. This is a convention,
    and you can freely change this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this new version, this will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The program requests from the user the four values it requires, and then using
    those values, it calculates the result and displays it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored the basic components of a class. Once we reviewed
    how we assembled the `CompoundInterest04` example, we broke the program apart
    and created classes to hold the data, display a user interface, and calculate
    the result. We also learned about the constructor and the deprecated `finalize`
    methods. We gained insight into what `new` does and how the JVM manages a program’s
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: The second version, `CompoundInterest05`, presents how a program is organized
    professionally based on functionality. It kept separate the data, the user interface,
    and the action, usually called the business. To gather user input, we had our
    first look at the Java library `Scanner` class. You should now have a good understanding
    of how a Java class is organized and how you can control access to members of
    the class.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look more closely at the methods that carry out
    the actions of a class and how we manage the relationships between classes.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Stack Memory and Heap Space in* *Java*: [https://www.baeldung.com/java-stack-heap](https://www.baeldung.com/java-stack-heap)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
