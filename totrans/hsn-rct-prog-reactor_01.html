<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Getting Started with Reactive Streams</h1>
                </header>
            
            <article>
                
<p class="western"><span>Over the years, application architecture has evolved. Businesses increasingly need to build systems that remain responsive and can scale when required. Systems should also be maintainable and quickly releasable. In accordance with these needs, we have started to build applications as loosely coupled services. We no longer build a system as one big application. Instead, we split systems into multiple independent, autonomous services. The objective for such services is to do one thing, and do it well.</span></p>
<p class="western"><span>In this chapter, we will discuss concerns associated with building such services. We will also look at how to address those concerns.<br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements </h1>
                </header>
            
            <article>
                
<ul>
<li class="western">Java Standard Edition, JDK 8 or above</li>
<li>IntelliJ IDEA IDE, 2018.1 or above</li>
</ul>
<p>The GitHub link for this chapter is <a href="https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter01">https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter01</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive architecture</h1>
                </header>
            
            <article>
                
<p class="western"><span>When we start to build microservice architecture, we try to involve different services to deliver business solutions. We often build services as traditional API models, where each of the services can interact with other services. This is referred to as <strong>distributed architecture</strong>. If a distributed architecture is designed incorrectly, performance issues surface very quickly. It can be difficult to have numerous distributed services that work concurrently to deliver the intended performance. Companies that offer services requiring large data exchange (such as Netflix, Amazon, or Lightbend) have therefore seen a need for alternative paradigms, which can be used for systems with the following characteristics:</span></p>
<ul>
<li class="mce-root"><span>Consisting of very loosely coupled components</span></li>
<li><span>Responding to user inputs</span></li>
<li><span>Resilient to varying load conditions</span></li>
<li><span>Always available</span></li>
</ul>
<p>In order to achieve the preceding characteristics, we need to build event-driven, modular services that communicate with each other by using notifications. In turn, we can respond to the system's flow of events. The modular services are more scalable, as we can add or remove service instances without halting the complete application. The complete architecture will be fault tolerant if we can isolate errors and take corrective actions. <span>The preceding four characteristics are the basic principles of the <strong>Reactive Manifesto</strong>. The Reactive Manifesto states that each reactive system should consist of loosely coupled components that rely on asynchronous, message-driven architecture. They must remain responsive to user input and isolate failures to individual components. Replication must be done in order to respond to varying load conditions. The following is a diagram of the Reactive Manifesto:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/09d66062-f536-4a4c-95e0-6b797161a8a7.jpg" style=""/></div>
<p class="western"><span>The Reactive Manifesto describes a reactive system. It does not required that the system be based on reactive programming, or any other reactive library. We can build a message-driven, resilient, scalable, and responsive application without using a reactive library, but it is easier to build an application based on reactive libraries.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive programming</h1>
                </header>
            
            <article>
                
<p class="western"><span>Most of us write imperative applications, where statements are required in order to change the application state. The code is executed and a final state is arrived at. After the state's computation, the state does not change when the underlying factors do. Let's consider the following code as an example:</span></p>
<pre class="western"><span>int value1 = 5;</span>
<span>int value2 = 10;</span>
<span>int sum = val1 + val2;</span>
<span>System.out.println(sum); // 15</span>
<span>value1 = 15;</span>
<span>System.out.println(sum); // 15<br/></span></pre>
<p>The sum is still <kbd>15</kbd>, even though <kbd>value1</kbd> has been changed.</p>
<p class="western"><span>On the other hand, reactive programming is about the propagation of change. It is also referred to as <strong>declarative programming</strong>, where we express our intent and application state as dynamically determined by changes to underlying factors. The preceding sum program example, under a reactive paradigm, would behave as follows:</span></p>
<pre class="western"><span>int value1 = 5;</span>
<span>int value2 = 10;</span>
<span>int sum = val1 + val2;</span>
<span>System.out.println(sum); // 15</span>
<span>value1 = 15;</span>
<span><span>System.out.println(sum); // 25</span></span></pre>
<p class="western"><span>Consequently, if a program reacts to changes in the underlying factors, it can be called reactive. Reactive programs can be built using imperative techniques, like callbacks. This may be fine for a program that has a single event. However, for applications where hundreds of events are happening, this could easily lead to callback hell; we could have numerous callbacks relying on one another, and it would be really difficult to figure out which ones were being executed. As a result, we require a new set of abstractions that enable us to seamlessly build asynchronous, event-driven interactions across a network boundary. There are libraries in different imperative languages, like Java, that provide us with these abstractions. These libraries are</span> <span>referred to as <strong>Reactive Extensions</strong></span><span>.</span> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ReactiveX</h1>
                </header>
            
            <article>
                
<p class="western"><span>Reactive Extensions, also known as ReactiveX, enable us to express the asynchronous events in an application as a set of observable sequences. Other applications can subscribe to these observables, in order to receive notifications of events that are occurring. A producer can then push these notification events to a consumer as they arrive. Alternatively, if a consumer is slow, it can pull notification events according to its own consumption rate. The end-to-end system of a producer and its consumers is known as a <strong>pipeline</strong>.</span><span> It is important to note that pipelines are lazy by default and do not materialize until they are subscribed to by a consumer. This is very different from eager Java types, like Future, which represent active work. The ReactiveX API consists of the following components:<br/></span></p>
<ol>
<li class="western"><span><strong>Observables</strong>:</span> <span>Observables represent the core concept of ReactiveX. They represent the sequences of emitted items, and they generate events that are propagated to the intended subscribers.</span></li>
</ol>
<ol start="2">
<li class="western"><strong>Observer:</strong> Any application can express its intent for events published by an observable by creating an observer and subscribing to the respective observable. The intent is expressed in terms of the <kbd>OnNext</kbd>, <kbd>OnCompleted</kbd>, and <kbd>OnError</kbd> methods. Each observable sends a stream of events, followed by a completion event, which executes these methods.</li>
<li class="western"><span><strong>Operators</strong>:</span> <span>O</span>perators enable us to transform, combine, and manipulate the sequences of items emitted by observables. The operators on an observable provide a new observable, and thus, they can be tied together. They do not work independently on the original observable; instead, they work on the observable generated by the previous operator to generate a new observable. <span>The complete operator chain is lazy. It is not evaluated until an observer is subscribed to it. The complete chain is shown as follows:</span></li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/1aa05938-c82e-4355-a74f-705c5be58ca7.png" style=""/></div>
<p><span>ReactiveX provides the architecture design to build reactive applications. Individual libraries were built around it in different imperative languages to enable its use. These abstractions allow us to build asynchronous, non-blocking applications, and provide the additional benefits listed in the following sections.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composite streams</h1>
                </header>
            
            <article>
                
<p>In software design, <strong>composition</strong> refers to grouping different entities and treating each group as a single entity. Additionally, the single entity exhibits the same behavior as the type it refers to. ReactiveX streams are composite in nature. They make it possible to combine existing data streams, add transformations, and generate new data streams. Moreover, all of this can be done in a declarative manner, making the overall solution maintainable in the long run. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Flexible operators</h1>
                </header>
            
            <article>
                
<p><span>The libraries offer a range of operators for all kinds of functions. Each of the operators accomplishes its tasks similarly to that of a workstation on an assembly line. It takes input from the previous workstation and provides input to the next workstation. These operators offer all kinds of data transformation, stream orchestration, and error handlers.</span></p>
<p><span>ReactiveX makes its easier to build event-based applications. However, the framework does not present the ways in which different event-driven applications should interact with each other. In a microservice architecture consisting of numerous event-driven services, the gains made are often offset by the workarounds required for inter-process communication.<br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive Streams</h1>
                </header>
            
            <article>
                
<p class="western"><span>Reactive Streams is a specification that determines the minimum set of interfaces required to build</span> the <span>asynchronous processing of a large volume of unbounded data. It is a specification</span><span> aimed at JVM and </span>JavaScript <span>runtime.</span> The main goal of the Reactive Streams specification is to standardize the exchange of stream data across an asynchronous boundary of applications. The API consists of the following four interfaces:</p>
<ol>
<li>
<p class="western"><strong>Publisher</strong>: The publisher is responsible for the generation of an unbounded number of asynchronous events and pushing those events to the associated subscribers.</p>
</li>
<li>
<p class="western"><strong>Subscriber</strong>: The subscriber is a consumer of the events published by a publisher. The subscriber gets events for subscription, data, completion, and error. It can choose to perform actions on any of them.</p>
</li>
<li>
<p class="western"><strong>Subscription</strong>: A subscription is a shared context between the publisher and subscriber, for the purpose of mediating the data exchange between the two. The subscription is available with the subscriber only, and enables it to control the flow of events from the publisher. The subscription becomes invalid if there is an error or a completion. A subscriber can also cancel the subscriptions, in order to close its stream.</p>
</li>
<li>
<p class="western"><strong>Processor</strong>: The processor represents a stage of data processing between a subscriber and a publisher. Consequently, it is bound by both of them. The processor has to obey the contract between the publisher and the subscriber. If there is an error, it must propagate it back to the subscriber.</p>
</li>
</ol>
<p class="mce-root"/>
<div class="western packt_tip">The Reactive Streams specification is the result of a collaborative effort of engineers from Kaazing, Netflix, Pivotal, Red Hat, Twitter, Typesafe, and many other companies.</div>
<p class="western">While there are only four interfaces, there are around 30 rules that govern the data exchange between the publisher and the subscriber. These rules are based on the two principles covered in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asynchronous processing</h1>
                </header>
            
            <article>
                
<p class="western">Asynchronous execution refers to the ability to execute tasks without having to wait to finish previously executed tasks first. The execution model decouples tasks, so that each of them can be performed simultaneously, utilizing the available hardware.</p>
<p class="western">The Reactive Streams API delivers events in an asynchronous manner. A publisher can generate event data in a synchronous blocking manner. On the other hand, each of the on-event handlers can process the events in a synchronously blocking manner. However, event publishing must occur asynchronously. It must not be blocked by the subscriber while processing events.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Subscriber backpressure</h1>
                </header>
            
            <article>
                
<p class="western">A subscriber can control events in its queue to avoid any overruns. It can also request more events if there is additional capacity. Backpressure enforces the publisher to bound the event queues according to the subscriber. Furthermore, a subscriber can ask to receive one element at a time, building a stop-and-wait protocol. It can also ask for multiple elements. On the other hand, a publisher can apply the appropriate buffers to hold non-delivered events, or it can just start to drop events if the production rate is more than the consumption rate.</p>
<p class="western">It is important to note that the Reactive Streams API is aimed at the flow of events between different systems. Unlike ReactiveX, it does not provide any operators to perform transformations. The API has been adopted as a part of the <kbd>java.util.concurrent.Flow</kbd> package in JDK 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">David Karnok's classification</h1>
                </header>
            
            <article>
                
<p class="western">David Karnok, a veteran of various reactive projects like Rxjava and Reactor, has categorized the evolution of reactive libraries into the following generations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Zero generation</h1>
                </header>
            
            <article>
                
<p>The zero generation revolves around the <kbd>java.util.observable</kbd> interface and the related callbacks. It essentially uses the observable design pattern for reactive development. It lacks the necessary support of composition, operators, and backpressure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">First generation</h1>
                </header>
            
            <article>
                
<p>The first generation represents Erik Mejer's attempt to address reactive issues by building Rx.NET. This referred to implementations in the form of the <kbd>IObserver</kbd> and <kbd>IObservable</kbd> interfaces. The overall design was synchronous and lacked backpressure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Second generation</h1>
                </header>
            
            <article>
                
<p>The first generation deficiencies of backpressure and synchronous handling were handled in the second generation APIs. This generation refers to the first implementations of Reactive Extensions, such as RxJava 1.X and Akka.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Third generation</h1>
                </header>
            
            <article>
                
<p>The third generation refers to the Reactive Streams specification, which enables library implementors to be compatible with each other and compose sequences, cancellations, and backpressure across boundaries. It also enables an end user to switch between implementations at their own will.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fourth generation</h1>
                </header>
            
            <article>
                
<p>The fourth generation refers to the fact that reactive operators can be combined in an external or internal fashion, leading to performance optimization. A fourth generation reactive API looks like a third generation, but internally, the operators have changed significantly to yield intended benefits. Reactor 3.0 and RxJava 2.x belong to this generation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fifth generation</h1>
                </header>
            
            <article>
                
<p class="western">The fifth generation refers to a future work, in which there will be a need for bidirectional reactive I/O operations over the streams.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactor</h1>
                </header>
            
            <article>
                
<p>Reactor is an implementation completed by the Pivotal Open Source team, conforming to the Reactive Streams API. The framework enables us to build reactive applications, taking care of backpressure and request handling. The library offers the following features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Infinite data streams</h1>
                </header>
            
            <article>
                
<p class="western">Reactor offers implementations for generating infinite sequences of data. At the same time, it offers an API for publishing a single data entry. This is suited to the request-response model. Each API offers methods aimed at handling the specific data cardinality.</p>
<p>Rather than waiting for the entire data collection to arrive, subscribers to each data stream can process items as they arrive. This yields optimized data processing, in terms of space and time. The memory requirement is limited to a subset of items arriving at the same time, rather than the entire collection. In terms of time, results start to arrive as soon as the first element is received, rather than waiting for the entire dataset.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Push-pull model</h1>
                </header>
            
            <article>
                
<p>Reactor is a push-pull system. A fast producer raises events and waits for the slower subscriber to pull them. In the case of a slow publisher and a fast subscriber, the subscriber waits for events to be pushed from the producer. The Reactive Streams API allows this data flow to be dynamic in nature. It only depends on the real-time rate of production and the rate of consumption.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Concurrency agnostic</h1>
                </header>
            
            <article>
                
<p>The Reactor execution model is a concurrency agnostic. It does not cover how different streams should be processed. The library facilitates different execution models, which can be used at a developer's discretion. All transformations are thread safe. There are various operators that can influence the execution model by combining different synchronous streams.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Operator vocabulary</h1>
                </header>
            
            <article>
                
<p>Reactor provides a wide range of operators. These operators allow us to select, filter, transform, and combine streams. The operations are performed as a workstation in a pipeline. They can be combined with each other to build high-level, easy-to-reason data pipelines.</p>
<p class="western">Reactor has been adopted in Spring Framework 5.0 to provide reactive features. The complete project consists of the following sub-projects:</p>
<ul>
<li class="western"><strong>Reactor-Core</strong>: This project provides the implementation for the Reactive Streams API. The project is also the foundation for Spring Framework 5.0 Reactive Extensions.</li>
<li class="western"><strong>Reactor-Extra</strong>: This project complements the Reactor-Core project. It provides the necessary operators to work on top of the Reactive Streams API.</li>
<li class="western"><strong>Reactor-Tests</strong>: This project contains utilities for test verification.</li>
<li><strong>Reactor-IPC</strong>: This project provides non-blocking, inter-process communication. It also provides backpressure-ready network engines for HTTP (including WebSockets), TCP, and UDP. The module can also be used to build microservices.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project setup</h1>
                </header>
            
            <article>
                
<p class="body-text-first-western">This book follows a hands-on approach; you will learn Reactor by working with examples. This chapter will set up the project that we will use throughout this book. Before we can move on, we will have to do some setting up. Please install the following items on your machine:</p>
<ul>
<li>
<p><span><span><strong>Java 8</strong>: Reactor works with Java 8 or above. Please download the latest update of Java 8 from the official Oracle website at</span></span> <span><span><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a>. At the time of writing, the Java version was <kbd>1.8.0_101</kbd>. You can check your Java version by running the following command:</span></span></p>
</li>
</ul>
<pre class="mce-root" style="padding-left: 60px"><strong>$ java -version</strong><br/>java version "1.8.0_101"<br/>Java(TM) SE Runtime Environment (build 1.8.0_101-b13)<br/>Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)</pre>
<ul>
<li>
<p><span><span><strong>IntelliJ IDEA 2018.1 or above</strong>: We will be using the latest community edition of IntelliJ. You can download the latest version from the JetBrains website at <a href="https://www.jetbrains.com/idea/download/">https://www.jetbrains.com/idea/download/</a>. We will be using version 2018.1.1.</span></span></p>
</li>
<li>
<p><span><span><strong>Gradle</strong>: Gradle is a one of the most popular build tools in the JVM ecosystem. It is used for dependency management and for running automated tasks. You don't have to install Gradle on your local machine; we will use a Gradle wrapper that downloads and installs Gradle for your project. To learn more about Gradle, you can refer to the Gradle documentation at <a href="https://docs.gradle.org/current/userguide/userguide.html">https://docs.gradle.org/current/userguide/userguide.html</a>.</span></span></p>
</li>
</ul>
<p class="body-text-first-western">Now that we have all the prerequisites, let's create a Gradle project by using IntelliJ IDEA itself:</p>
<ol>
<li class="body-text-first-western">Launch IntelliJ IDEA and you will see the following screen, where you can begin to create a project:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b81d6ae3-2d6e-4ece-87aa-086a7577f93d.png" style=""/></div>
<ol start="2">
<li class="body-text-first-western">Click on <span class="packt_screen">Create New Project</span> to start the process of creating a Java Gradle project. You will see a screen for creating a new project. Here, select <span class="packt_screen">Gradle</span> and <span class="packt_screen">Java</span>, as shown in the following screenshot. <span>You will also have to specify th</span><span>e</span> <span class="packt_screen">Project SDK</span><span>. </span><span>Click</span><span> on</span><span> the </span><span><span class="packt_screen">New</span> </span><span>button to select <span class="packt_screen">JDK 8</span>. Then, click on <span class="packt_screen">Next</span> to move to the next screen</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2a5bd061-a0c4-48a5-a4da-d8d9930d3ee0.png" style=""/></div>
<ol start="3">
<li class="body-text-first-western"><span>Now you will be asked to enter the </span><span class="packt_screen">GroupId </span> <span>and</span> <span class="packt_screen">ArtifactId</span><span>. Click on </span><span class="packt_screen">Next</span> <span>to move to the next screen:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/218ab741-b398-4a48-859b-e2b3d1b912b3.png" style=""/></div>
<ol start="4">
<li class="western">The next screen will ask you to specify a few Gradle settings. We will select <span class="packt_screen">Use auto-import</span>, so that Gradle will automatically add new dependencies when we add them to the build file. <span>Click on </span><span class="packt_screen">Next</span> <span>to move to the final screen:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/454d0d88-0c2f-456b-930a-44dd3569bb04.png" style=""/></div>
<ol start="5">
<li class="body-text-first-western">On this screen, you will be asked for the location where you want to create the project. Select a convenient directory path for the application. Finally, click on <span class="packt_screen">Finish</span> to complete the project creation process:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e171409f-1c2b-45ab-9a11-38d35c2f014a.png"/></div>
<p>Now that the Java Gradle project has been created, we have to make a couple of changes in the Gradle build file, that is, <kbd>build.gradle</kbd>. Open the <kbd>build.gradle</kbd> file in IDE and change it to match the following contents:</p>
<pre>plugins {<br/>    id "io.spring.dependency-management" version "1.0.5.RELEASE"<br/>}<br/>group 'com.reactor'<br/>version '1.0-SNAPSHOT'<br/>apply plugin: 'java'<br/>sourceCompatibility = 1.8<br/>repositories {<br/>    mavenCentral()<br/>}<br/>dependencyManagement {<br/>    imports {<br/>        mavenBom "io.projectreactor:reactor-bom:Bismuth-RELEASE"<br/>    }<br/>}<br/>dependencies {<br/>    compile 'io.projectreactor:reactor-core'<br/>    testCompile group: 'junit', name: 'junit', version: '4.12'<br/>}</pre>
<p class="body-text-first-western">In the preceding <kbd>build.gradle</kbd> file, we have done the following:</p>
<ol>
<li class="body-text-first-western">Added the <kbd>io.spring.dependency-management</kbd> plugin. This plugin allows us to have a <kbd>dependency-management</kbd> section, for configuring dependency versions.</li>
<li class="body-text-first-western">Configured the <kbd>dependency-management</kbd> plugin to download the latest version of Reactor. We have used the maven BOM published by the Reactor project.</li>
<li class="body-text-first-western">Added the <kbd>reactor-core</kbd> dependency to the list of project dependencies.</li>
</ol>
<p class="body-text-first-western">That's all we need to do to start using Reactor.</p>
<div class="body-text-first-western packt_infobox">At the time of writing, Bismuth-RELEASE was the latest version of Reactor.</div>
<p class="body-text-first-western">Now, let's build a simple test case to see how <span>we</span><span> </span><span>can work with the Reactor API. We will build a simple test case for generating Fibonacci numbers. Wikipedia defines Fibonacci numbers as follows:</span></p>
<div class="packt_quote">"In mathematics, the Fibonacci numbers are the numbers in the following integer sequence, called the Fibonacci sequence, and characterized by the fact that every number after the first two is the sum of the two preceding ones:<br/>
<br/>
0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144, ..."</div>
<p class="body-text-first-western">Let's build our test for the Fibonacci generation. The test case will start to generate a series, from 0 and 1. It will generate the first 50 Fibonacci numbers, and will validate the 50<sup>th</sup> number as <kbd>7778742049</kbd>:</p>
<pre>@Test<br/>public void testFibonacci() {<br/>  Flux&lt;Long&gt; fibonacciGenerator = Flux.generate(<br/>    () -&gt; Tuples.&lt;Long, Long&gt;of(0L, 1L),<br/>     (state, sink) -&gt; {<br/>       sink.next(state.getT1());<br/>       return Tuples.of(state.getT2(), state.getT1() + state.getT2());<br/>     });<br/>     List&lt;Long&gt; fibonacciSeries = new LinkedList&lt;&gt;();<br/>     int size = 50;<br/>     fibonacciGenerator.take(size).subscribe(t -&gt; {<br/>       fibonacciSeries.add(t);<br/>     });<br/>     System.out.println(fibonacciSeries);<br/>     assertEquals( 7778742049L, fibonacciSeries.get(size-1).longValue());<br/>}</pre>
<div class="packt_infobox">The complete code can be found at <a href="https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter01">https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter01</a>.<a href="https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter01"/></div>
<p class="mce-root">In the preceding test case, we are doing the following:</p>
<ol>
<li class="body-text-first-western">We create Fibonacci as <kbd>Flux&lt;Long&gt;</kbd>, by using the <kbd>Flux.generate()</kbd> call. The API has a <kbd>State</kbd> and <kbd>Sink</kbd>. For now, we will leave the Flux API details for the next chapter.</li>
<li>The API takes a seed as <kbd>Tuple [0 , 1]</kbd>. It then emits the first argument of the pair by using the <kbd>Sink.next()</kbd> call.</li>
</ol>
<ol start="3">
<li>The API also generates the next Fibonacci number by aggregating the pair.</li>
<li>Next, we select the first 50 Fibonacci numbers by using the <kbd>take()</kbd> operator.</li>
<li class="body-text-first-western">We subscribe to the published numbers, and then append the received number to a <kbd>List&lt;Long&gt;</kbd>.</li>
<li class="body-text-first-western"> Finally, we assert the published numbers.</li>
</ol>
<p class="body-text-first-western">In the preceding test case, we have used a number of Rector features. We will cover each of them in detail in our subsequent chapters. For now, let's execute the test case and check that our project is running fine.</p>
<p class="body-text-first-western">Running our unit test should give us a green bar, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/737b3e38-51ad-4d4c-9456-5498105fce64.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="western">In this chapter, we discussed the need for a reactive paradigm. We also looked at the evolution of the paradigm, from reactive programming to Reactive Extensions and then Reactive Streams. Furthermore, we discussed the Reactive Streams specification as a specification aimed at JVM for the following:</p>
<ul>
<li class="western">Processing a potentially unbounded number of elements in a sequence</li>
<li class="western">Asynchronously passing elements between components <span>with mandatory non-blocking backpressure</span></li>
</ul>
<p class="western">At the end of the chapter, we covered Reactor, an implementation by the Pivotal team, and built a sample project with it. In the next chapter, we will discuss the APIs available in Reactor.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What are the principles of the Reactive Manifesto?</li>
<li>What are Reactive Extensions?</li>
<li>What does the Reactive Stream specification cater for?</li>
<li>What are the principles upon which Reactive Streams are based?</li>
<li>What are the salient features of the Reactor Framework?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>To learn more about microservice design, please refer to <a href="https://www.packtpub.com/application-development/reactive-microservice-design-video">https://www.packtpub.com/application-development/reactive-microservice-design-video</a>.</li>
<li>The Reactive Streams specification is part of Java 9. To find out more about what is included in the Java Development Kit 9, please refer to <a href="https://www.packtpub.com/application-development/reactive-programming-java-9">https://www.packtpub.com/application-development/reactive-programming-java-9</a>.</li>
</ul>


            </article>

            
        </section>
    </body></html>