- en: Familiarizing Yourself with Basic Monads
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉基本单子
- en: In the previous chapter, we got to know Functors, an abstraction that gives
    the `map` method the effects defined in the standard library. Looking back at
    [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring Built-In Effects*,
    there is still something missing here—the source of the `flatMap` method, which
    all standard effects also have.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了Functors，这是一个抽象，它给`map`方法赋予了标准库中定义的效果。回顾[第6章](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml)，《探索内置效果》，这里仍然有些缺失——`flatMap`方法的来源，所有标准效果都有这个来源。
- en: In this chapter, we will finally meet the concept of a monad, the structure
    that defines `flatMap`. To learn about this function inside and out, we'll implement
    four different monads.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们终于将遇到单子的概念，这是定义`flatMap`的结构。为了深入了解这个函数，我们将实现四个不同的单子。
- en: 'By the end of this chapter, you''ll be familiar with the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将熟悉以下主题：
- en: Abstracting a monad and its properties
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象单子及其属性
- en: Implementing monads for standard effects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为标准效果实现单子
- en: 'The implementation and applicability of the following basic monads:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下基本单子的实现和应用：
- en: Id
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Id
- en: State
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态
- en: Reader
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读者
- en: Writer
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we begin, make sure you have the following installed:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请确保你已经安装了以下内容：
- en: JDK 1.8+
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 1.8+
- en: SBT 1.2+
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SBT 1.2+
- en: The source code for this chapter is available in our GitHub repository at [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter09](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter09).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在我们的GitHub仓库中找到，网址为[https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter09](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter09)。
- en: Introduction to monads
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单子简介
- en: It took us three chapters to get to the moment where we're ready to discuss
    the origins of the `flatMap` method in regards to the effects we looked at in
    [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring Built-In Effects*. The
    reason for this is not the complexity of the topic, but the richness of the family
    of abstractions related to it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用了三章的篇幅才到达这样一个时刻，即我们准备讨论`flatMap`方法的起源，这与我们在[第6章](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml)，《探索内置效果》中看到的效果有关。之所以需要这么多章节，并不是因为主题的复杂性，而是与之相关的抽象家族的丰富性。
- en: After this introduction, a suspicious reader will think with disappointment—OK,
    now they are going to use their usual trick and say that there is an abstraction
    for `flatMap`, `flattener` or `flatMapative`, pull some laws out of thin air,
    and consider themselves done. What cheaters!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个介绍之后，一个可疑的读者可能会失望地想——好吧，现在他们将要使用他们常用的伎俩，说有一个`flatMap`、`flattener`或`flatMapative`的抽象，从空中拉出一些法则，然后认为自己已经完成了。这些骗子！
- en: Well, technically we're not cheating because we're not pulling things out of
    anywhere. Instead, we're taking them from category theory, the branch of mathematics
    we mentioned previously. The rules our abstractions must obey are defined by mathematicians.
    There is an advantage to this approach, though—as soon as we can prove that our
    implementation obeys the required laws, we can use everything that has been proved
    by category theory to our advantage. One example of this is the possibility of
    combining two applicatives into one, just like in the example we discussed in
    the previous chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，从技术上讲，我们并没有作弊，因为我们并没有从任何地方拉取东西。相反，我们从范畴论中获取这些概念，这是我们之前提到的数学分支。我们的抽象必须遵守的规则是由数学家定义的。这种方法的优点在于——一旦我们能够证明我们的实现遵循所需的法则，我们就可以利用范畴论已经证明的一切来为我们所用。一个例子就是将两个应用项合并为一个，就像我们在上一章讨论的例子中那样。
- en: 'Going back to our `flatMap` method, there is still some intrigue there. The
    abstraction name is `Monad`, and it is defined by two methods, `flatMap`, and
    `unit`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`flatMap`方法，这里还有一些神秘之处。抽象的名称是`Monad`，它由两个方法定义，`flatMap`和`unit`：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The monad is defined for a container of type `F`. The `unit` method *lifts* its
    parameter into the context of `F`; the `flatMap` is similar to the plain `map`
    method in a sense that it applies `f` to `a`. What is different in `flatMap` and
    what makes it special is its ability to *collapse* or *flatten* two layers of
    `F` into one. This is easy to see from the type signatures of `a` and `f`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单子定义于类型`F`的容器。`unit`方法将它的参数提升到`F`的上下文中；`flatMap`在某种意义上类似于普通的`map`方法，它将`f`应用于`a`。`flatMap`与普通`map`的不同之处以及它之所以特殊的地方在于它能够*折叠*或*扁平化*两层`F`，将其合并为一层。这可以从`a`和`f`的类型签名中轻易看出。
- en: 'This possibility to flatten `F[F[A]]` into `F[A]` is the reason why monads
    are often expressed with a different set of methods; that is, `map` and `flatten`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将`F[F[A]]`扁平化为`F[A]`的可能性是为什么通常用一组不同的方法来表示monads；也就是说，`map`和`flatten`：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `flatten` method does exactly what we just said—it allows us to reduce the
    stack of Fs into a single `F`. Sometimes, the `flatten` method is also called
    a `join`. We will see in a moment why this name makes sense.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatten`方法正是我们刚才所说的那样——它允许我们将Fs的堆栈减少到单个`F`。有时，`flatten`方法也被称为`join`。我们很快就会看到为什么这个名字是有意义的。'
- en: Clearly, we have the same situation with monads that we had with applicatives—we
    can choose the set of primitive functions and implement the rest of functionality
    in terms of primitives. For instance, the `flatMap` is equally powerful as a combination
    of `map` and `flatten`, and we can choose one of these combinations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们与monads的情况与与applicatives的情况相同——我们可以选择原始函数集，并以原始函数的形式实现其余的功能。例如，`flatMap`与`map`和`flatten`的组合一样强大，我们可以选择这些组合中的任何一个。
- en: 'Let''s stick to the initial definition and implement other methods in terms
    of `flatMap`. This is what `map` will look like:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们坚持最初的定义，并以`flatMap`为其他方法实现。这就是`map`将看起来像：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What we're doing here is basically mapping with the function `f` and lifting
    the result in context of `F` as the types require.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是基本上用函数`f`进行映射，并将结果以`F`上下文的形式提升，正如类型要求的那样。
- en: Can you remember the name of the abstraction that is characterized by having
    a `map` method? Right, this is the functor. Our ability to define a `map` solely
    in terms of `flatMap` for every `Monad` proves that every `Monad` is a `Functor`.
    Because of this, we can state that `Monad extends Functor`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你能记得那个以具有`map`方法的抽象体为特征的名称吗？对，这就是functor。我们能够仅用`flatMap`来定义每个`Monad`的`map`的能力证明了每个`Monad`都是`Functor`。正因为如此，我们可以声明`Monad
    extends Functor`。
- en: 'The definition of the `flatten` method is similarly straightforward:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatten`方法的定义同样简单明了：'
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the `identity` function, we are using part of the `flatMap` power to convert
    two layers of `F` into one without actually doing anything with `a`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`identity`函数，我们正在使用`flatMap`的一部分力量将两层`F`转换为一层，而实际上并没有对`a`做任何事情。
- en: 'Can we go further and apply a function that is already in the context of `F`
    to the `a`? It turns out that we can, and we know the method that does this—this
    is the `apply` defined in `Applicative`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否更进一步，将已经存在于`F`上下文中的函数应用到`a`上？结果是我们可以，而且我们知道这个方法——这就是在`Applicative`中定义的`apply`：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we're pretending that `f` is a value, so we just need to represent `a`
    as a function that can be applied to this value. The `fab` function takes a function
    called `A => B` that we use to `map` over the original `a`, returning `B`, which
    becomes an `F[B]` because of the application of `map`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假装`f`是一个值，所以我们只需要将`a`表示为一个可以将此值应用于其上的函数。`fab`函数接受一个名为`A => B`的函数，我们用它来`map`原始的`a`，返回`B`，由于`map`的应用，它变成了`F[B]`。
- en: 'The `apply` function is also defined in terms of `flatMap` (and `map`, which
    is derived from `flatMap`) for every monad. This provides evidence that every
    `Monad` is an `Applicative`. Thus, our definition of `Monad` can be changed into
    the following form:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`函数也是针对每个monad以`flatMap`（以及从`flatMap`派生出的`map`）来定义的。这证明了每个`Monad`都是`Applicative`。因此，我们可以将`Monad`的定义改为以下形式：'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can see that the `flatMap` method is only available for the `Monad`, not
    for an `Applicative`. This leads to interesting consequences, which we will look
    at later in this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`flatMap`方法仅对`Monad`可用，而不是对`Applicative`。这导致了有趣的后果，我们将在本章后面讨论。
- en: Now, before switching gears and starting to implement the instances of specific
    monads, let's discuss the monadic laws first.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在切换到实现特定monads的实例之前，让我们首先讨论monadic laws。
- en: Fortunately, there are only two of them, and both are very similar to the functor
    laws we discussed in the previous chapter; that is, the *identity* and *associativity*
    laws.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，只有两个，而且它们都与我们在上一章中讨论的functor laws非常相似；即*恒等性*和*结合性*定律。
- en: 'The identity law states that applying `flatMap` and `unit` should return the
    original argument. Depending on the order of application, there are left and right
    identities. We''ll represent them formally as usual with `ScalaCheck` properties
    (the following snippet does not show the implicit parameters; please consult the
    accompanying code for the full definition):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 标识律指出，应用 `flatMap` 和 `unit` 应该返回原始参数。根据应用的顺序，存在左和右的标识律。我们将像往常一样使用 `ScalaCheck`
    属性（以下代码片段未显示隐式参数；请参阅附带的代码以获取完整定义）来正式表示它们：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The left identity stipulates that the result of using `flatMap` over the argument
    by lifting it into the context of the monad should be equal to the original argument.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 左标识律规定，通过将参数提升到单子的上下文中使用 `flatMap` 的结果应该等于原始参数。
- en: 'The right identity is a bit more complex:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 右标识律稍微复杂一些：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Basically, the rule is that lifting `a` into the context and then flatmapping
    it with some function, `f`, should produce the same result as applying this function
    to `a` directly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，规则是将 `a` 提升到上下文中，然后使用某个函数 `f` 进行扁平映射，应该产生与直接应用此函数到 `a` 相同的结果。
- en: 'Now, all we need to do is combine both of these properties into a single identity
    property. We''ll need quite a bit of different `implicit Arbitrary` arguments
    in order to generate input data, including `A, M[A]` and `A => M[B]`, but the
    property itself should be anything but surprising:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将这两个属性组合成一个单一的标识属性。我们需要相当多的不同 `implicit Arbitrary` 参数来生成输入数据，包括 `A,
    M[A]` 和 `A => M[B]`，但属性本身应该不会令人惊讶：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The associativity property says that flatmapping using functions in succession
    should be the same as applying functions in the context of the monad:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 结合律属性表明，连续使用函数进行扁平映射应该与在单子上下文中应用函数相同：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''ll omit the definition of the implicit parameters for this and a combination
    rule:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将省略隐式参数的定义以及组合规则：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Please look up the source code in GitHub to see the full signature of these
    properties.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请在 GitHub 上查找源代码以查看这些属性的完整签名。
- en: Now that we have an understanding of what methods we need to define and how
    they should behave, let's implement some monads! We'll need to know the internals
    of the respective containers in order to implement the `flatMap`. In the previous
    chapter, we implemented the `map` method by delegating to the underlying container.
    Now, we'll use a low-level approach to show that the knowledge of the structure
    is indeed necessary.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了需要定义哪些方法和它们应该如何表现，让我们来实现一些单子！为了实现 `flatMap`，我们需要了解相应容器的内部结构。在前一章中，我们通过委托给底层容器实现了
    `map` 方法。现在，我们将使用一种低级方法来展示确实需要了解结构知识。
- en: 'As usual, we will start with the simplest of the standard effects, `Option`.
    This is how we implement `Monad[Option]`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如往常一样，我们将从标准效果中最简单的一个开始，即 `Option`。这是我们实现 `Monad[Option]` 的方法：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The implementation of `unit` should be apparent—the only way to turn `A` into `Option[A]`
    is by wrapping it. Like we did previously, we're using the case class constructor
    directly to preserve the structure in the case that `a` is `null`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`unit` 的实现应该是显而易见的——将 `A` 转换为 `Option[A]` 的唯一方法是通过包装。就像我们之前做的那样，我们直接使用案例类构造函数来保留在
    `a` 为 `null` 的情况下的结构。'
- en: The `flatMap` implementation is also very transparent—we can't apply a given
    function to `None`, and hence we return `None` as is. In the case that we have
    provided `a` is defined, we unwrap the value and apply `f` to it. This *unwrapping* is
    exactly the moment where we're using our knowledge of the internals of `Option` to
    flatten the potentially nested result.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap` 的实现也非常透明——我们不能将给定的函数应用到 `None` 上，因此我们直接返回 `None`。在 `a` 已定义的情况下，我们解包值并应用
    `f` 到它上。这种 *解包* 正是我们使用对 `Option` 内部结构的了解来扁平化可能嵌套结果的时刻。'
- en: 'We can check that our implementation obeys monadic laws by defining a couple
    of properties for different types of `a` and `f`:. These properties need to be
    placed in a class extending `org.scalacheck.Properties`, as usual:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过为不同类型的 `a` 和 `f` 定义一些属性来检查我们的实现是否遵守单调律：这些属性需要放置在一个扩展 `org.scalacheck.Properties`
    的类中，就像往常一样：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Given that our properties hold for two different types of `a` and two different
    types of functions, we can be pretty sure that our code is correct and proceed
    with other containers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的属性对于两种不同的 `a` 类型以及两种不同的函数类型都成立，我们可以相当确信我们的代码是正确的，并继续处理其他容器。
- en: For `Either`, we have a small complication, exactly like we had when we defined
    a Functor for it - two type parameters instead of one required by the `Monad`.
    Are you ready to deal with it the same way as before—by fixing the second type
    parameter and using the type lambda to define the final type of the monad? The
    good news is that we won't need to do this! The type lambda is such a common thing
    that's used in type class programming that many people craved an easier way to
    do this. This is the projector that plugin was created for. It allows us to use
    simplified syntax for type lambdas in Scala.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Either`，我们遇到了一个小麻烦，就像我们定义它的 `Functor` 时一样——需要两个类型参数而不是 `Monad` 所需要的那个。你准备好以同样的方式处理它了吗——通过修复第二个类型参数并使用类型
    lambda 来定义 monad 的最终类型？好消息是，我们不需要这样做！类型 lambda 是类型类编程中非常常见的东西，以至于许多人渴望有一个更简单的方式来完成这个任务。这就是插件被创建的原因。它允许我们在
    Scala 中使用简化的语法来处理类型 lambda。
- en: 'All we need to do so that we can start using the plugin is add the dependency
    to our project configuration in the `build.sbt` file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始使用插件，我们只需要在我们的项目配置文件 `build.sbt` 中添加依赖项：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we have this, we can simplify the type lambda syntax from our usual `({type
    T[A] = Either[L, A]})#T` to just `Either[L, ?]`. The plugin is feature-rich, and
    we will not go into further details here; visiting the documentation page at [https://index.scala-lang.org/non/kind-projector/kind-projector/0.9.7](https://index.scala-lang.org/non/kind-projector/kind-projector/0.9.7)
    is highly recommended.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个，我们可以将我们的类型 lambda 语法从通常的 `({type T[A] = Either[L, A]})#T` 简化为 `Either[L,
    ?]`。插件功能丰富，我们在这里不会进一步详细介绍；强烈建议访问文档页面 [https://index.scala-lang.org/non/kind-projector/kind-projector/0.9.7](https://index.scala-lang.org/non/kind-projector/kind-projector/0.9.7)。
- en: 'With our new tool, the definition of `eitherMonad` is easy to read:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的新工具，`eitherMonad` 的定义很容易阅读：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The type class constructor takes a type parameter, `L`, for the left side of
    `Either`. The rest of the implementation should be very familiar by now. It's
    worth reminding yourself that `Either` is right-biased—this it the reason we're
    returning `Right` from the `unit` method. It's also worth mentioning the last
    case in the `flatMap` pattern match where we repacked `l` from `Left[L, A]` into
    `Left[L, B]`. This is done to help the compiler infer the correct return type.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类构造函数接受一个类型参数 `L`，用于 `Either` 的左侧。其余的实现现在应该非常熟悉了。值得提醒的是，`Either` 是右偏的——这就是我们从
    `unit` 方法返回 `Right` 的原因。还值得提到的是在 `flatMap` 模式匹配中的最后一个情况，我们将从 `Left[L, A]` 中的 `l`
    重新打包到 `Left[L, B]`。这样做是为了帮助编译器推断正确的返回类型。
- en: 'For the property definition, we also have to fix a type of the left side. We
    can do this by defining a type alias, which will improve readability:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于属性定义，我们还需要修复左侧的类型。我们可以通过定义一个类型别名来完成这个任务，这将提高可读性：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Except for the type alias, the definition of properties is the same as we had
    for `Option`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类型别名之外，属性的定义与我们对 `Option` 的定义相同。
- en: The definition of `Monad[Try]` is done by analogy, and we'll leave it as an
    exercise for the reader.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Monad[Try]` 的定义是通过类比完成的，我们将把它留给读者作为练习。'
- en: 'In contrast, `Monad[List]` (or `Monad[Bucket]`, if we''re to use terms from
    the previous chapter) is quite different as the `List` can contain more than one
    element:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`Monad[List]`（或者如果我们使用前一章的术语，是 `Monad[Bucket]`）相当不同，因为列表可以包含多个元素：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `unit` is implemented in the same way as the other effects were—just by
    wrapping its argument. The `flatMap` is defined in a recursive manner. For `Nil`,
    we return `Nil`. This case is analogous to the case of `None` in `Monad[Option]`.
    In the case of a non-empty list, we have to apply the given function to all of
    the elements of the list and flatten the result at the same time. This is done
    in the second matching case.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`unit` 的实现方式与其他效果相同——只是通过包装它的参数。`flatMap` 是以递归方式定义的。对于 `Nil`，我们返回 `Nil`。这种情况类似于
    `Monad[Option]` 中的 `None` 的情况。在非空列表的情况下，我们必须将给定的函数应用于列表的所有元素，并同时展平结果。这是在第二个匹配情况中完成的。'
- en: 'Let''s see if our property holds:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的属性是否成立：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It looks like it is, but the only reason for this is that the list generator
    in `ScalaCheck` does not generate input lists of a significant size. If it did,
    our property would fail with `StackOverflowError` because it is not tail-recursive!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来是这样的，但唯一的原因是 `ScalaCheck` 中的列表生成器不会生成具有显著大小的输入列表。如果它做到了，我们的属性会因为 `StackOverflowError`
    而失败，因为这不是尾递归！
- en: 'Let''s fix this by using the techniques that we discussed in [Chapter 3](9f67be8e-4fee-4050-ab96-8444bb795138.xhtml),
    *Deep Dive into Functions*:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用在[第3章](9f67be8e-4fee-4050-ab96-8444bb795138.xhtml)，“深入函数”中讨论的技术来解决这个问题：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have made our implementation tail-recursive by introducing the
    accumulator, we can safely use it with lists of an arbitrary length. But this
    approach is still quite direct and slow because of that. On my laptop, this implementation
    consumed approximately five times more time than the "native" optimized implementation
    of List''s `flatMap` method. It turns out that this is exactly the case where
    delegating makes sense:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过引入累加器使我们的实现尾递归，我们可以安全地使用任意长度的列表。但是，由于这种方法仍然相当直接且速度较慢，所以这种方法仍然相当直接且速度较慢。在我的笔记本电脑上，这个实现消耗了比List的“原生”优化实现`flatMap`方法大约五倍的时间。结果证明，这正是委托有意义的场合：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: OK, so we have ignored `Future`, but have implemented type class instances for
    all of the containers we discussed in [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml),
    *Exploring Built-In Effects*. Are we done with monads? It turns out that we're
    not—not by a long shot. Just like it's possible to define an indefinite number
    of applicatives for different types constructors as long as the applicative properties
    hold, it is possible to do the same with monads.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以我们忽略了`Future`，但已经为我们在[第6章](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml)，“探索内置效果”中讨论的所有容器实现了类型类实例。我们关于单子的任务完成了吗？结果证明，我们还没有——远远没有。就像只要适用性属性保持不变，就可以为不同的类型构造器定义无限数量的适用性一样，也可以用单子做同样的事情。
- en: In the following section, we'll put some widely used monads such as Id, State,
    Reader, and Writer into code and discuss what are they good for.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将一些广泛使用的单子，如Id、State、Reader和Writer，放入代码中，并讨论它们有什么好处。
- en: Id Monad
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Id单子
- en: 'The same way `Option` encodes optionality, the `Id` represents *nothing special*.
    It wraps a value but does nothing with it. Why would we need something that''s
    *not a thing*? The `Id` is kind of a *meta-lifting*, which can represent anything
    as an effect without changing it. How can this be done? Well, first of all, we
    have to say to the compiler that an `Id[A]` is the same thing as an `A`. This
    is easily done with a type alias:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Option`编码可选性一样，`Id`代表*没有什么特别之处*。它包装了一个值，但对它不做任何事情。我们为什么需要*不是东西*的东西呢？`Id`是一种*元提升*，可以代表任何东西作为效果，而不改变它。这该如何做到呢？首先，我们必须告诉编译器`Id[A]`与`A`是同一件事。这可以通过一个类型别名轻松完成：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This type definition will dictate the details of the monad''s implementation:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类型定义将决定单子实现的细节：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Obviously, `unit(a)` is just `a`, and by having the type alias we just defined,
    we're making the compiler believe that it is not of type `A`, but an `Id[A]`.
    Similarly, with the `flatMap`, we can't do anything fancy, so we're just applying
    the given function `f` to `a`, utilizing the fact that `Id[A]` is actually just
    `A`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`unit(a)`只是`a`，通过我们刚刚定义的类型别名，我们让编译器相信它不是`A`类型，而是一个`Id[A]`。同样，对于`flatMap`，我们无法做任何花哨的事情，所以我们只是将给定的函数`f`应用到`a`上，利用`Id[A]`实际上只是`A`的事实。
- en: 'Obviously, as we''re doing nothing, the monadic laws should hold. But just
    to be 100% sure, we''ll encode them as properties:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，由于我们不做任何事情，单子定律应该成立。但为了100%确定，我们将它们编码为属性：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The property holds—what else would you expect from something that does nothing?
    But why do we need this something in the first place?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是成立的——你还能期望从什么不做的事情中得到什么呢？但我们为什么一开始就需要这个“东西”呢？
- en: This question has multiple answers. From an abstract perspective, the `Id` monad
    carries the function of (surprise!) an identity element in the space of monads
    in the same way that zero or one are the identity elements in the space of numbers
    under addition or multiplication. Because of this, it can be used as a placeholder
    for monad transformers (we'll learn about them in the next chapter). It can also
    be useful in a situation where in existing code expects a monad but we don't need
    one. We will see how this approach works later in this chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有多个答案。从抽象的角度来看，`Id`单子承担了（惊喜！）在单子空间中的恒等元素的功能，就像零或一在加法或乘法下的数字空间中的恒等元素一样。正因为如此，它可以作为单子变换的占位符（我们将在下一章中了解它们）。在现有代码期望单子但不需要单子的情况下，它也可能很有用。我们将在本章后面看到这种方法是如何工作的。
- en: Now that we have got our feet wet with the simplest monad, it is time to do
    something more involving—implementing the State monad.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用最简单的单子打好了基础，是时候做一些更复杂的事情了——实现State单子。
- en: State monad
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: State单子
- en: In imperative programming, we have the concept of global variables—variables
    that are available anywhere in the program. This approach is considered to be
    a bad practice, but is still used quite often. The concept of global state extends
    global variables by including system resources. As there is only one filesystem
    or system clock, it totally makes sense to make them globally and universally
    accessible from anywhere in the program code, right?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，我们有全局变量的概念——在程序中的任何地方都可以访问的变量。这种方法被认为是一种不好的做法，但仍然被相当频繁地使用。全局状态的概念通过包括系统资源扩展了全局变量的概念。由于只有一个文件系统或系统时钟，因此从程序代码的任何地方都可以全局和普遍地访问它们，这是完全有道理的，对吧？
- en: In JVM, some of these global resources are available via the `java.lang.System`
    class. It contains, for instance, references to "standard" input, output, and
    error streams, the system timer, environment variables, and properties. The global
    state should definitely be a good idea, then, if Java exposes it on a language
    level!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在JVM中，一些这些全局资源可以通过`java.lang.System`类获得。例如，它包含对“标准”输入、输出和错误流的引用，系统计时器，环境变量和属性。那么，如果Java在语言级别上公开全局状态，这绝对是一个好主意！
- en: The problem with global state is that it breaks the *referential transparency*
    of the code. In essence, referential transparency means that it should always
    be possible to replace a part of the code, for example, a function call, with
    the result of the evaluation of this call everywhere in the program, and this
    change should not cause observable changes in program behaviour.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 全局状态的问题在于它破坏了代码的*引用透明性*。本质上，引用透明性意味着应该始终可以在程序中的任何地方用评估的结果替换代码的一部分，例如函数调用，并且这种更改不应该导致程序行为可观察的变化。
- en: The concept of referential transparency is closely related to the concept of
    a `pure function`—a function is pure if it is referentially transparent for all
    its referentially transparent arguments.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 引用透明性的概念与纯函数的概念密切相关——一个函数是纯的，如果对于所有引用透明的参数，它都是引用透明的。
- en: 'We will see how this works in a moment, but for starters, please consider the
    following example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后看到它是如何工作的，但首先，请考虑以下示例：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the case of `incGlobal`, the function is not pure because it is not referentially
    transparent (because we cannot replace a call of it with the result of evaluation
    since these results are different each time the function is called). This makes
    it impossible to reason about the possible outcomes of the program without knowing
    the global state at every moment it is accessed or modified.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`incGlobal`的情况下，该函数不是纯函数，因为它不是引用透明的（因为我们不能用它的评估结果替换它的调用，因为这些结果每次调用函数时都不同）。这使得在没有知道每次访问或修改全局状态的情况下，无法对程序的可能的输出进行推理。
- en: 'In contrast, the following function is referentially transparent and pure:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，以下函数是引用透明的且是纯函数：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In functional programming, we are expected to use only pure functions. This
    makes global state as a concept unsuitable for functional programming.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，我们期望只使用纯函数。这使得全局状态作为一个概念不适合函数式编程。
- en: But there are still many cases where it is necessary to accumulate and modify
    state, but how should we deal with that?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，仍然有许多情况下需要积累和修改状态，但我们应该如何处理这种情况呢？
- en: 'This is where the `State` monad comes into play. The state monad is build around
    a function that takes a relevant part of the *global state* as an argument and
    returns a result and modified state (of course, without changing anything in a
    *global* sense). The signature of such a function looks like this: `type StatefulFunction[S,
    A] = S => (A, S)`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`State`单子发挥作用的地方。状态单子是围绕一个函数构建的，该函数将相关部分的全局状态作为参数，并返回一个结果和修改后的状态（当然，不会在全局意义上改变任何东西）。此类函数的签名看起来像这样：`type
    StatefulFunction[S, A] = S => (A, S)`。
- en: 'We can wrap this definition into a case class to simplify the definition of
    helper methods on it. This `State` class will denote our effect:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个定义包装成一个案例类，以简化对其辅助方法的定义。这个`State`类将表示我们的效果：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can also define a few constructors in the companion object so that we''re
    able to create a state in three different situations (to do this in REPL you need
    to use `:paste` command and paste *both* the case class and a companion object,
    then press *Ctrl* + *D*:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在伴随对象中定义几个构造函数，以便在三种不同情况下创建状态（要在REPL中这样做，您需要使用`:paste`命令粘贴案例类和伴随对象，然后按*Ctrl*
    + *D*：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The default constructor lifts some value, `a: A`, into the context of `State`
    by returning the given argument as a result and propagating the existing state
    without changes. The getter creates a `State` that wraps some function, returning
    the given argument both as the state and as a result. The setter wraps the `State`
    over the function, which takes a state to be wrapped and produces no result. The
    semantics of these are similar to reading the global state (hence the result is
    the equal state) and setting it (hence the result is `Unit`), but applied to `s:
    S`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '默认构造函数通过返回给定的参数作为结果，并传播现有的状态而不做任何改变，将一些值`a: A`提升到`State`的上下文中。获取器创建一个`State`，它包装了一个函数，返回给定的参数既作为状态也作为结果。设置器将`State`包装在函数上，该函数接受一个要包装的状态并产生没有结果。这些语义与读取全局状态（因此结果是相同的状态）和设置它（因此结果是`Unit`）相似，但应用于`s:
    S`。'
- en: For now, the `State` is nothing but a thin wrapper around some computation which
    involves pushing through (and potentially changing) a bit of state. What we would
    like to be able to do is compose this computation with the next one. We'd like
    to do this similarly to how we compose functions, but instead of `(A => B) compose
    (B => C)`, we now have `State[S, A] compose State[S, B]`. How can we do this?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`State`只是围绕一些涉及通过（并可能改变）一些状态的计算的一个薄包装。我们希望能够将这个计算与下一个计算组合起来。我们希望以与组合函数类似的方式做到这一点，但现在我们有`State[S,
    A]`和`State[S, B]`。我们该如何做到这一点？
- en: 'By definition, our second computation accepts the result of the first one as
    its argument, hence we start with `(a: A) =>` . We also stated that, as a result
    (because of the possible state change and return type of the second state), we''ll
    have a `State[S, B]`  which gives us a full signature for the computation to compose
    with the first one: `f: A => State[S, B]` .'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '根据定义，我们的第二次计算接受第一次计算的结果作为其参数，因此我们以`(a: A) =>`开始。我们还指出，由于可能的状态变化和第二个状态的返回类型，我们将有一个`State[S,
    B]`，这为我们提供了与第一个计算组合的完整签名：`f: A => State[S, B]`。'
- en: 'We can implement this composition as a method on `State`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这种组合实现为`State`上的一个方法：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We define our composed computation as a combination of two runs. The first is
    done with the input provided to the first state, which we decompose into the result
    and a next state. We then call the provided transformation `f` on the result and
    `run` it with the next state. These two successive runs might seem strange at
    first glance, but they just represent the fact that we're fusing two `run` functions
    from different states into one function defined on the composed state.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将组合的计算定义为两次运行的组合。第一次使用提供给第一个状态的输入，我们将它分解为结果和下一个状态。然后我们在结果上调用提供的转换`f`，并使用下一个状态来运行它。这两次连续的运行一开始看起来可能有些奇怪，但它们只是表示我们将来自不同状态的两个`run`函数融合为一个定义在组合状态上的函数。
- en: Now, we have an effect and can create a monad for it. You should have noticed
    by now that the signature of the `compose` method we just defined is the same
    as that of the monadic `flatMap`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个效果，可以为其创建一个单子。你应该已经注意到，我们刚刚定义的`compose`方法的签名与单调的`flatMap`方法的签名相同。
- en: The `compose` in this and the following cases does not refer to the function
    composition we learned about in [Chapter 3](9f67be8e-4fee-4050-ab96-8444bb795138.xhtml), *Deep
    Dive into Functions*, but to the concept of Kleisli composition. It is often called
    Kleisli arrow, and in essence is just a wrapper over the `A => F[B]` function,
    which allows for the composition of functions returning monadic values. It is
    frequently named `>>=`, but we'll stick to `compose` here.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例及以下情况中的`compose`并不指代我们在[第3章](9f67be8e-4fee-4050-ab96-8444bb795138.xhtml)“深入函数”中学习的函数组合，而是指Kleisli组合的概念。它通常被称为Kleisli箭头，本质上只是`A
    => F[B]`函数的一个包装，允许对返回单调值的函数进行组合。它通常命名为`>>=`，但在这里我们将坚持使用`compose`。
- en: 'This allows us to delegate monadic behavior to the logic we already have in
    the `State`, the same way as we could do for standard effects:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们将单调行为委托给我们在`State`中已有的逻辑，就像我们可以为标准效果做的那样：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Luckily, we can also delegate the lifting done by the `unit` to the default
    constructor! This means that we're done with the definition of the monad and can
    continue with our rigorous testing approach by specifying a property check for
    it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们还可以将`unit`所做的提升委托给默认构造函数！这意味着我们已经完成了单子的定义，可以继续使用严格的测试方法，通过指定对其的属性检查来继续。
- en: Except in this case, we won't.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种情况，我们不会这么做。
- en: The rationale behind this is the fact that the `State` is quite different from
    the other effects we looked at until now in regard to the value it incorporates.
    The `State` is the first effect which is built *exclusively* around some function.
    Technically, because functions are first-class values in Scala, other effects
    such as `Option` could also contain a function and not a value, but this is an
    exception.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 其背后的原因是`State`与到目前为止我们所考虑的其他效果在所包含的值方面相当不同。`State`是第一个完全围绕某个函数构建的效果。技术上，因为函数在Scala中是一等值，其他效果如`Option`也可以包含一个函数而不是一个值，但这是一种例外。
- en: This brings complications to our testing attempts. Earlier, we modified the
    value contained in the effect in different ways and checked that the results we
    equal, as required by the monadic laws, by comparing them. With the requirement
    to have a function as a value of the effect, we face the challenge of comparing
    two functions for equality. At the time of writing this book, this is a topic
    of active academic research. For our practical purposes, there is currently no
    other way to prove that two functions are equal other than testing them for each
    possible input parameter(s) and checking whether they return same results—which
    we obviously cannot afford to do in our properties.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们的测试尝试带来了复杂性。以前，我们以不同的方式修改了效果中的值，并通过比较它们来检查结果是否相等，这是符合单调律的要求。现在，我们需要将函数作为效果的值，这就面临了比较两个函数是否相等的问题。在撰写本书时，这是一个活跃的学术研究课题。就我们的实际目的而言，目前还没有其他方法可以证明两个函数相等，除了测试它们对每个可能的输入参数(s)并检查它们是否返回相同的结果——这显然是我们无法承担的。
- en: Instead, we will *prove* that our implementation is correct. We will use a method
    called the *substitution model* for this. The essence of the method is in using
    referential transparency in order to substitute all of the variables and function
    calls with values they return repeatedly until the resulting code can't be simplified
    anymore—very much like solving an algebraic equation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将证明我们的实现是正确的。我们将使用一种称为*替换模型*的方法来做这件事。该方法的核心在于使用引用透明性，用它们返回的值来替换所有的变量和函数调用，直到结果代码不能再简化为止——这非常类似于解代数方程。
- en: Let's see how this works.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的。
- en: To get us prepared before proving the monadic laws, we'll prove a useful lemma
    first.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在证明单调律之前，我们将首先证明一个有用的引理。
- en: 'The lemma is stated as follows: having `as: M[A], f: A => M[B]` and `M = State` so
    that `as.run = s => (a, s1)` (the run method returns a pair of `a` and `s1` for
    some input `s` and `f(b) = (b: A) => State(s1 => (b, s2)`), `M.flatMap(as)(f)`
    will always yield `State(s => (b, s2))`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '该引理表述如下：对于`as: M[A], f: A => M[B]`和`M = State`，使得`as.run = s => (a, s1)`（`run`方法返回一对`a`和`s1`，对于某个输入`s`和`f(b)
    = (b: A) => State(s1 => (b, s2))`），`M.flatMap(as)(f)`将始终产生`State(s => (b, s2))`。'
- en: 'This is how we''re getting this formula:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的公式是如何得出来的：
- en: By definition, `as.run = s => (a, s1)`, which gives us `as = State(s => (a,
    s1))`
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据定义，`as.run = s => (a, s1)`，这给我们`as = State(s => (a, s1))`。
- en: The `flatMap` delegates to the `compose` method defined on `State`, and therefore
    `M.flatMap(a)(f)` for `M = State` becomes `a.compose(f)`
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`flatMap`方法委托给定义在`State`上的`compose`方法，因此对于`M = State`，`M.flatMap(a)(f)`变为`a.compose(f)`。'
- en: In terms of `as` and `f`, `as.compose(f)` can be formulated as `State(s => (a,
    s1)).compose(f)`
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`as`和`f`的术语中，`as.compose(f)`可以表示为`State(s => (a, s1)).compose(f)`。
- en: 'Now, we''re going to substitute the call of the `compose` method with its definition:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将用其定义来替换`compose`方法的调用：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, we have proved our assumption that `Monad[State].flatMap(as)(f) = State(s
    => (b, s2))` for `as = State(s => (a, s1))` and `f(a) = (b: A) => State(s1 =>
    (b, s2))`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们已经证明了我们的假设，即对于`as = State(s => (a, s1))`和`f(a) = (b: A) => State(s1 =>
    (b, s2))`，`Monad[State].flatMap(as)(f) = State(s => (b, s2))`。'
- en: Now, we can use this lemma while proving the monadic laws for `State`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在证明`State`的单调律时使用这个引理。
- en: 'We''ll start with the identity laws, and more specifically, with the left identity.
    This is how we formulated it in our `ScalaCheck` property:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从恒等律开始，更具体地说，从左恒等律开始。这是我们如何在`ScalaCheck`属性中表述它的：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Thus, we want to prove that if we let `M = State`, then every `as: M[A]` following
    it is always true:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，我们想要证明的是，如果我们让`M = State`，那么随后的每个`as: M[A]`总是正确的：'
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s simplify the left side of the equation first. By definition, we can
    replace `as` with `State` implementation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先简化等式的左边。根据定义，我们可以用`State`实现来替换`as`：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The next step that we must do is substitute the call of the `unit` method with
    its implementation. We''re just delegating to the default constructor of the `State`,
    which is defined as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的下一步是替换 `unit` 方法的调用及其实现。我们只是在委托给 `State` 的默认构造函数，它定义如下：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Hence, our definition becomes the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的定义变成了以下形式：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To substitute the `flatMap` call, we have to recall that all it does is just
    delegate to the `compose` method defined on `State`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了替换 `flatMap` 调用，我们必须记住它所做的只是委托给定义在 `State` 上的 `compose` 方法：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we can use our lemma for state composition, which gives us the following
    simplified form:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们的状态组合引理，这给我们以下简化的形式：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This can''t be simplified further, so we will now take a look at the right
    side of equation, `as`. Again, by definition, `as` can be represented as `State(s
    => (a, s1))`. This gives us final proof that `State(s => (a, s1)) == State(s =>
    (a, s1))`, which always holds for any `a: A`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '这不能再简化了，所以我们现在将查看等式的右侧，`as`。同样，根据定义，`as` 可以表示为 `State(s => (a, s1))`。这给我们最终的证明，即
    `State(s => (a, s1)) == State(s => (a, s1))`，这对于任何 `a: A` 总是成立的。'
- en: The right side identity is proved similarly to the left side, and we leave this
    as an exercise to the reader.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的恒等性证明与左侧类似，我们将其留给读者作为练习。
- en: 'The second law we need to prove is the associative law. Let''s recall how it
    is described in ScalaCheck terms:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要证明的第二条定律是结合律。让我们回顾一下在 ScalaCheck 术语中它是如何描述的：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Let's see what we can do with that, starting with the  `leftSide`,  `M.flatMap(M.flatMap(as)(f))(g)`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们能用它做什么，从 `leftSide` 开始，`M.flatMap(M.flatMap(as)(f))(g)`。
- en: By substituting `M` with `State` in the internal part, `M.flatMap(as)(f)` becomes
    `State(s => (a, s1)).compose(f)`, which by the application of our lemma transforms
    it into `State(s => (b, s2))`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在内部部分将 `M` 替换为 `State`，`M.flatMap(as)(f)` 变成了 `State(s => (a, s1)).compose(f)`，通过应用我们的引理，它变成了
    `State(s => (b, s2))`。
- en: 'Now, we can substitute the outer `flatMap`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以替换外部的 `flatMap`：
- en: '`M.flatMap(State(s => (b, s2)))(g)` is the same as  `State(s => (b, s2)).compose(g)` **(1)**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`M.flatMap(State(s => (b, s2)))(g)` 等同于 `State(s => (b, s2)).compose(g)` **(1**)。'
- en: Let's leave it in this form and look at the `rightSide`: `M.flatMap(as)(a =>
    M.flatMap(f(a))(g))`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保持这种形式，并查看`rightSide`：`M.flatMap(as)(a => M.flatMap(f(a))(g))`。
- en: 'First we substitute the internal `flatMap` with the `compose`, before turning `a
    => M.flatMap(f(a))(g)` into `(a: A) => f(a).compose(g)`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们将内部 `flatMap` 替换为 `compose`，然后再将 `(a: A) => M.flatMap(f(a))(g)` 转换为 `(a:
    A) => f(a).compose(g)`。'
- en: Now, by the definition of `f` we used for the left side, we have `f(a) = a =>
    State(s1 => (b, s2))` and thus the internal `flatMap` becomes `a => State(b, s2).compose(g)`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，根据我们用于左侧的 `f` 的定义，我们有 `f(a) = a => State(s1 => (b, s2))`，因此内部 `flatMap` 变成了
    `a => State(b, s2).compose(g)`。
- en: Replacing the outer `flatMap` with `compose` gives us—in combination with the
    previous definition—`State(s => (a, s1)).compose(a => State(s1 => (b, s2)).compose(g))`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将外部的 `flatMap` 替换为 `compose`，结合先前的定义，我们得到 `State(s => (a, s1)).compose(a =>
    State(s1 => (b, s2)).compose(g))`。
- en: We'll use our lemma again to substitute the first application of `compose`,
    which will have `State(s => (b, s2)).compose(g)` as the outcome. **(2)**
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用我们的引理来替换第一次应用的 `compose`，这将得到 `State(s => (b, s2)).compose(g)` 作为结果。**(2**)。
- en: '**(1)** and **(2)** are identical, which means that the `leftSide` and `rightRide`
    of our property are always equal; we just proved the associativity law.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**(1**) 和 **(2**) 是相同的，这意味着我们属性的 `leftSide` 和 `rightSide` 总是相等的；我们刚刚证明了结合律。'
- en: 'Great, we have an implementation of the `State` and the corresponding monad,
    which has been proven to be correct. It''s time to look at them in action. As
    an example, let''s imagine that we''re going fishing by boat. The boat has a position
    and direction, and can go forward for some time or change direction:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们已经实现了 `State` 和相应的 monad，并且已经证明它是正确的。现在是时候看看它们在实际中的应用了。作为一个例子，让我们想象我们正乘船去钓鱼。这艘船有一个位置和方向，可以在一段时间内前进或改变方向：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We could go around with this boat by calling its methods:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用其方法来绕着这条船走：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There is a problem with this approach, though—it does not include fuel consumption.
    Unfortunately, this aspect was not envisioned at the time the boat''s navigation
    was developed, and has been added later as a global state. We will now refactor
    the old style with the state monad. If the quantity of fuel is modelled as a number
    of litres, the most straightforward way to define the state is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法有一个问题——它不包括燃油消耗。不幸的是，在开发船的导航时，这个方面没有被预见，后来作为全局状态添加。现在，我们将使用状态单子重构旧风格。如果燃油量被建模为升数，定义状态的最直接方式如下：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, we can define our boat moving logic that takes fuel consumption into account.
    But before doing that, we are going to simplify the syntax of our monadic calls
    a bit. Currently, the `flatMap` and `map` methods of our Monad take two parameters—the
    container and the function to apply to the container.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义我们的船移动逻辑，该逻辑考虑了燃油消耗。但在做之前，我们将稍微简化一下我们的单子调用语法。目前，我们的单子 `flatMap` 和 `map`
    方法接受两个参数——容器和应用于容器的函数。
- en: 'We would like to create a wrapper that will incorporate both the effect and
    a monad so that we have an instance of the effect and only need to pass the transforming
    function to the mapping methods. This is how we can express this approach:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望创建一个包装器，它将结合效果和单子，这样我们就有了一个效果实例，并且只需要传递转换函数给映射方法。这就是我们表达这种方法的途径：
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The implicit conversion `MonadF` will wrap any effect, `F[A]`, as soon as there
    is an implicit monad definition available for `F`. Having `value`, we can use
    it as a first parameter for the `flatMap` and `map` methods defined on monad—thus,
    in the case of `MonadF`, they are reduced to higher-order functions taking single
    parameters. By importing this implicit conversion, we now can call `flatMap` and
    `map` directly on `State`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `F` 有隐式单子定义可用时，隐式转换 `MonadF` 将任何效果 `F[A]` 包装起来。有了 `value`，我们可以将其用作定义在单子上的
    `flatMap` 和 `map` 方法的第一个参数——因此，在 `MonadF` 的情况下，它们被简化为接受单个参数的高阶函数。通过导入这个隐式转换，我们现在可以直接在
    `State` 上调用 `flatMap` 和 `map`：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We also need to create pure functions that will take fuel consumption into
    account while moving the boat. Assuming that we can''t change the original definition
    of `Boat`, we have to pass the `boat` as a parameter to these functions:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建一些纯函数，在移动船时考虑燃油消耗。假设我们无法更改 `Boat` 的原始定义，我们必须将这些函数的 `boat` 作为参数传递：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `consume` function calculates fuel consumption based on `speed` and `time`.
    In the `turn` function, we're taking a `boat`, turning it by the specified `angle`
    (by delegating to the default implementation), and returning the result as an
    instance of `FuelState`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`consume` 函数根据 `speed` 和 `time` 计算燃油消耗。在 `turn` 函数中，我们接受一个 `boat`，通过委托到默认实现来将其旋转指定的
    `angle`，并将结果作为 `FuelState` 实例返回。'
- en: A similar approach is used in the `go` method—to compute the boat's position,
    we are delegating to the boat logic. To sum the new volume of fuel available,
    we reduce the initial fuel quantity (which is passed as a parameter) and return
    the result as a part of the state.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `go` 方法中也使用了类似的方法——为了计算船的位置，我们委托给船的逻辑。为了计算可用的燃油新总量，我们减少初始燃油量（作为参数传递），并将结果作为状态的一部分返回。
- en: 'We can finally create the same chain of actions we had defined initially, but
    this time by tracking fuel consumption:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终可以创建与最初定义相同的动作链，但这次是通过跟踪燃油消耗来实现的：
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you compare this snippet with the original definition, you'll see that the
    path of the boat is the same. However, much more is happening behind the scenes.
    Each call of the `flatMap` passes the state over—this is how it is defined in
    the code of the monad. In our case, the definition is the `compose` method defined
    on the `State`. The function given as a parameter to the `flatMap` method describes
    what should happen with the result and possibly with the passed state. In a sense,
    using monads gives us a responsibility separation—*the monad describes what should
    happen between computation steps* as the result of one step being passed to the
    next step, and *our logic describes what should happen with the result before
    it is passed over to the next computation*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个片段与原始定义进行比较，你会看到船的路径是相同的。然而，幕后发生的事情要多得多。每次调用`flatMap`都会传递状态——这是在monad的代码中定义的。在我们的例子中，定义是`State`上定义的`compose`方法。传递给`flatMap`方法的函数描述了结果应该发生什么，以及可能传递的状态。从某种意义上说，使用monads给我们带来了责任分离——*monad描述了计算步骤之间应该发生什么*，作为一步的结果传递给下一步，*我们的逻辑描述了在传递给下一步计算之前结果应该发生什么*。
- en: 'We defined our logic with partially applied functions, which obscure what is
    really happening a bit—to make this obvious, the last step is defined using explicit
    syntax. We could also make the process of passing results between steps more explicit
    by using for-comprehension:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用部分应用函数定义我们的逻辑，这使真正发生的事情变得有些模糊——为了使这一点明显，最后一步使用显式语法定义。我们也可以通过使用for-comprehension使步骤之间传递结果的过程更加明确：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The approach is the same as before, but just the syntax has changed—Now, passing
    the boat between steps is done explicitly, but the state passing had visually
    disappeared—The for-comprehension makes monadic code look like it''s imperative.
    This is the result of executing both of these approaches:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 方法与之前相同，但只是语法有所改变——现在，在步骤之间传递船是显式的，但状态传递在视觉上消失了——for-comprehension使monadic代码看起来像命令式。这是执行这两种方法的结果：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'How can we be sure that the state has been passed correctly? Well, this is
    what monad law guarantees. For those of you that are curious, we can even manipulate
    the state using methods we''ve defined in the state''s companion object:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确保状态被正确传递？嗯，这正是monad法则保证的。对于那些好奇的人，我们甚至可以使用我们在状态伴生对象中定义的方法来操作状态：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We augmented our previous for-comprehension with logging statements to output
    the current state after each step—These are the statements of the form:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加日志语句来增强我们之前的for-comprehension，以输出每一步后的当前状态——这些是如下形式的语句：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Does it feel like we're really reading some global state? Well, in reality,
    what is happening is that we're getting the current `State` as a result (this
    is how we defined `State.get` earlier), which is passed then over to the next
    computation—the logging statement. Further computations just use the results of
    the previous steps explicitly, just like they had before.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 是否感觉我们真的在读取某个全局状态？嗯，实际上，正在发生的事情是我们正在获取当前的`State`作为结果（这就是我们之前定义`State.get`的方式），然后将其传递给下一个计算——日志语句。后续的计算只是显式地使用前一步的结果，就像之前一样。
- en: 'Using this technique, we''re also modifying the state:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，我们也在修改状态：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we're simulating that our boat has a fuel tank of a maximal capacity equal
    to 700\. We're doing this by first reading the current state and then setting
    back whatever is smaller—the state passed by the caller of the `run` method or
    our tank capacity. The `State.set` method returns `Unit`—this is why we ignore
    it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们模拟我们的船有一个最大容量为700的油箱。我们通过首先读取当前状态，然后设置较小的值——`run`方法的调用者传递的状态或我们的油箱容量。`State.set`方法返回`Unit`——这就是我们忽略它的原因。
- en: 'The output of the definition augmented with the logging looks like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 增加日志后的定义输出如下：
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As we can see, the limit of 700 was applied before the first movements of the
    boat.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，700的限制是在船的第一步移动之前应用的。
- en: 'There is still an issue with our implementation of `move`—it uses hardcoded
    `go` and `turn` functions as if we would only be able to navigate one specific
    boat. However, this is not the case—we should be able to do this with any boat
    which has `go` and `turn` functionality, even if they are implemented slightly
    differently. We could model this by passing the `go` and `turn` functions as parameters
    to the `move` method:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`move`实现仍然存在问题——它使用硬编码的`go`和`turn`函数，好像我们只能导航一艘特定的船。然而，事实并非如此——我们应该能够使用任何具有`go`和`turn`功能的船，即使它们的实现略有不同。我们可以通过将`go`和`turn`函数作为参数传递给`move`方法来模拟这种情况：
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This definition will allow us to have different implementations for the `go`
    and `turn` functions in different situations, but still, steer the boat along
    the given hardcoded path.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义将允许我们在不同情况下为`go`和`turn`函数有不同的实现，但仍然沿着给定的硬编码路径引导船只。
- en: If we look carefully, we'll see that after creating the initial wrapper over
    the provided boat parameter, the definition of the `move` method has no further
    notion of the `State`—we need it to be a monad to be able to use for-comprehension,
    but this requirement is much more generic than the State we currently have.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察，我们会发现创建初始包装器后，`move`方法的定义不再有关于`State`的概念——我们需要它是一个monad才能使用for-comprehension，但这个要求比我们目前拥有的State要通用得多。
- en: 'We can make the definition of the `move` function generic by improving on these
    two aspects—by passing the effect instead of creating it and making the method
    polymorphic:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过改进这两个方面来使`move`函数的定义通用——通过传递效果而不是创建它，并使方法多态：
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, we can follow the given path with any type which has a monad and the `go`
    and `turn` functions with specified signatures. Given the fact that this functionality
    is now generic, we can also move it into the `Boat` companion object along with
    the definition of the default boat.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用任何具有单子以及具有指定签名的`go`和`turn`函数的类型来遵循给定的路径。鉴于这种功能现在是通用的，我们也可以将它与默认船的定义一起移动到`Boat`伴随对象中。
- en: 'Let''s see how this approach works together with the state monad. It turns
    out that our definition of the `go` and `turn` methods does not need to change
    at all. All we need to do is call the new generic `move` method:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这种方法与状态monad一起是如何工作的。结果是，我们的`go`和`turn`方法定义根本不需要改变。我们唯一需要做的就是调用新的通用`move`方法：
- en: '[PRE53]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It looks much nicer, but still there is some room for improvement. Specifically,
    the `turn` method does nothing but propagate the call to the default implementation.
    We can make it generic in the same way as we did for the `move` method:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来更美观，但仍然有一些改进的空间。特别是，`turn`方法什么也不做，只是传播对默认实现的调用。我们可以像对`move`方法做的那样，使它通用：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We can't make it polymorphic in regard to the `Boat` because we need to propagate
    a call to the specific type, but we still have the generic monad type. This specific
    code uses the implicit definition of `Monad.apply` to summon the monad of a specific
    type.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使它关于`Boat`多态，因为我们需要传播对特定类型的调用，但我们仍然有通用的monad类型。这个特定的代码使用了`Monad.apply`的隐式定义来召唤特定类型的monad。
- en: 'Actually, we can also do the same for the `go` method—provide a default facade
    implementation—and place them both into the companion object of the `Boat`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们也可以对`go`方法做同样的事情——提供一个默认的伪装实现，并将它们都放入`Boat`的伴随对象中：
- en: '[PRE55]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Again, to put this definition into the REPL you need to use the `:paste` command,
    followed by both the definition of `boat` case class and a companion object, and
    a combination of *Ctrl* +*D*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，要将这个定义放入REPL，你需要使用`:paste`命令，然后是`boat`案例类的定义和伴随对象，以及*Ctrl* + *D*的组合。
- en: 'Now, we can use the default implementations for the cases where we don''t need
    to override the default behavior. For instance, we can get rid of the default
    `turn` implementation for the case of State and call `move` with the default one:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于不需要覆盖默认行为的场景，我们可以使用默认实现。例如，对于状态的情况，我们可以去除默认的`turn`实现，并使用默认值调用`move`方法：
- en: '[PRE56]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We have to help the compiler to infer the correct type of monad to use by providing
    the type parameter, but now our definition of stateful behavior is reduced to
    the overriden definition of the `go` method—the rest of the code is generic.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须通过提供类型参数来帮助编译器推断要使用的正确monad类型，但我们的状态行为定义现在简化为覆盖的`go`方法定义——其余的代码是通用的。
- en: 'As an illustration, we can reuse everything we have used so far with the `Id`
    monad—the result should be the same as executing the chain of calls directly on
    `Boat`. This is the complete implementation that''s done with the `Id` monad:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 作为说明，我们可以重用我们迄今为止与`Id`单子一起使用的一切——结果应该与直接在`Boat`上执行调用链相同。这是使用`Id`单子完成的完整实现：
- en: '[PRE57]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Again, we're providing the type of monad to use, but this is pretty much it.
    Since `Id[Boat] = Boat`, we even can pass the `boat` directly without wrapping
    it into the `Id`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们提供了要使用的单子类型，但这基本上就是全部了。由于`Id[Boat] = Boat`，我们甚至可以直接传递`boat`，而无需将其包装到`Id`中。
- en: Isn't that nice? We could use any monad we've defined so far to pass different
    effects to the main logic formulated in monadic terms. We'll leave the easy part—using
    existing definitions—as an exercise for the reader, and will now implement two
    other monads representing the read and write side of the `State`, that is, the
    `Reader` and `Writer` monads.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很好吗？我们可以使用我们迄今为止定义的任何单子来传递不同的效果到以单子形式表述的主要逻辑中。我们将把使用现有定义的简单部分留给读者作为练习，现在我们将实现两个其他单子，代表`State`的读取和写入方面，即`Reader`和`Writer`单子。
- en: Reader monad
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取单子
- en: The `State` monad represents an external (to the definition of the logic) state,
    which needs to be taken into account and possibly modified. The `Reader` monad
    is similar in the taking into account part—it accepts an external context and
    passes it over unchanged to every computation down the queue. In terms of the
    global state we discussed during the examination of the state monad, the `Reader`
    will have access to read-only system properties. Because of this, the reader monad
    is often known as a mechanism for dependency injection—because it takes some outside
    configuration (not necessarily basic things like strings or numbers, but also
    possibly other complex components, database access mechanisms, network sockets,
    or other resources) and makes it available for the function it wraps.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`State`单子代表一个外部（相对于逻辑定义）的状态，这个状态需要被考虑并可能被修改。《Reader》单子在这方面相似——它接受一个外部上下文并将其不变地传递给队列中的每个计算。在讨论状态单子时提到的全局状态方面，`Reader`将能够访问只读的系统属性。正因为如此，读取单子通常被称为依赖注入的机制——因为它接受一些外部配置（不一定是基本的东西，如字符串或数字，也可能是其他复杂的组件、数据库访问机制、网络套接字或其他资源），并将其提供给它包装的函数。'
- en: 'Let''s see how `Reader` is defined. We have already compared `State` and `Reader`,
    and the definition is also quite similar—with the only difference that we don''t
    need to return the changed context (it is read-only, after all). In code, it looks
    like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Reader`是如何定义的。我们已经在`State`和`Reader`之间进行了比较，定义也非常相似——唯一的区别是我们不需要返回更改后的上下文（毕竟它是只读的）。在代码中，它看起来是这样的：
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `Reader` type is just a wrapper over a function which takes a context of
    type `R` and returns some result of type `A`. The `flatMap` combines two `run`
    functions together—we're doing this by calling `run` with a given context, applying
    the given transformation to the result, and then calling the `run` for the result.
    The first call of the `run` is basically for `this`, while the second is for the
    `Reader` we're getting by applying `f`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reader`类型只是对函数的一个包装，该函数接受一个类型为`R`的上下文并返回一些类型为`A`的结果。《flatMap`将两个`run`函数组合在一起——我们通过使用给定上下文调用`run`，将给定的转换应用于结果，然后对结果调用`run`来实现这一点。第一次调用`run`基本上是为了`this`，而第二次是为了通过应用`f`得到的`Reader`。'
- en: 'We can also define a constructor for some value that ignores any given context:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以定义一个构造器，它忽略任何给定的上下文：
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now that we have this model, we can have a monad for it, just like we did with
    the state monad—by using the kind-projector syntax:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个模型，我们可以为它创建一个单子，就像我们为状态单子所做的那样——通过使用kind-projector语法：
- en: '[PRE60]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Unsurprisingly, the monad just delegates to both the constructor and the `compose`
    method we just defined. Surprisingly, now that we've done this, we're done defining
    the reader monad and can use it with our definition of the move function!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，这个单子只是委托给刚刚定义的构造器和`compose`方法。令人惊讶的是，现在我们做了这件事，我们就完成了读取单子的定义，并且可以使用我们的移动函数定义来使用它！
- en: Let's imagine that we have a regulation that defines a speed limit for boats
    and the maximal angle they are allowed to turn at once (sounds strange, but in
    the place, we're fishing we have case law, so this is what we've got).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们有一个规定，它定义了船只的速度限制以及它们一次允许的最大转向角度（听起来很奇怪，但在我们钓鱼的地方有判例法，所以我们就是这样做的）。
- en: 'As this is external regulation, we have to model it with a case class:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是外部规则，我们必须用案例类来建模它：
- en: '[PRE61]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We'll also define an alias fixes the type of context for a `Reader` to be `Limits`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将定义一个别名，将 `Reader` 的上下文类型固定为 `Limits`。
- en: 'Now, we can redefine our `go` and `turn` methods by applying these limits,
    like so:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过应用这些限制来重新定义我们的 `go` 和 `turn` 方法，如下所示：
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: There is nothing special about the implementation itself. The type signature
    of functions are predefined by the `move` method. After each action, we return
    `Reader[Limits, Boat]`. To calculate the new state of the boat, we delegate to
    its methods after figuring out the maximal speed or angle we can apply.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 实现本身并没有什么特别之处。函数的类型签名由 `move` 方法预定义。在每个动作之后，我们返回 `Reader[Limits, Boat]`。为了计算船的新状态，我们在确定可以应用的最大速度或角度后，委托给其方法。
- en: 'As we designed the rest of the code in a generic way, this is all we need to
    do—Let''s `move`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们以通用方式设计了其余的代码，这就足够了——让我们 `move`：
- en: '[PRE63]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: To run this example, please use the SBT `run` command.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，请使用 SBT 的 `run` 命令。
- en: We're passing the `go` and `turn` functions we just defined to the generic `move`
    method, along with the properly wrapped `boat`, and `run` it afterward. By looking
    at the result, we can say that the speed limits were properly applied.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将刚刚定义的 `go` 和 `turn` 函数传递给通用的 `move` 方法，以及正确包装的 `boat`，然后运行它。通过查看结果，我们可以断定速度限制得到了适当的运用。
- en: After scrutinizing the state monad, there is not much left to discuss the reader,
    so we're good to proceed to the Writer monad.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在仔细审查了状态模态之后，关于读者就没有太多可讨论的了，因此我们可以继续到 Writer 模态。
- en: Writer monad
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Writer 模态
- en: The `Writer` monad is a sibling of the state and the reader, oriented on modifying
    the state. Its main purpose is to provide a facility to write into some kind of
    log by passing this log between computations. The type of the log is not specified,
    but usually, some structure with a possibly low overhead of the append operation
    is chosen. To name a few suitable possibilities, you could use a `Vector` from
    the standard library or a `List`. In the case of the List, we need to prepend
    the log entries and revert the resulting log at the very end.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`Writer` 模态是状态和读者模态的兄弟，它侧重于修改状态。其主要目的是通过在计算之间传递日志来提供一个写入某种日志的便利设施。日志的类型没有指定，但通常会选择具有可能低开销的追加操作的结构。举几个合适的例子，你可以使用标准库中的
    `Vector` 或 `List`。在 `List` 的情况下，我们需要在最后将日志条目添加到前面，并反转生成的日志。'
- en: Before we get too deep into the discussion about the type of log, it is good
    to realize that we can defer the decision until later. All we need to know is
    how to append an entry to the existing log. Or, in other words, how to combine
    two logs, one of which contains just a single entry, together. We already know
    about the structure with such a functionality—it is a `Semigroup`. Actually, we
    also need to be able to represent an empty log, and so our end decision will be
    to have a `Monoid`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论日志类型之前，最好意识到我们可以推迟这个决定。我们只需要知道如何将条目追加到现有日志中。或者换句话说，如何将两个日志结合起来，其中一个只包含单个条目。我们已经知道具有这种功能的结构——它是
    `Semigroup`。实际上，我们还需要能够表示一个空日志，因此我们的最终决定是拥有一个 `Monoid`。
- en: 'Let''s bring this together. The Writer takes two type arguments, one for the
    log entry, and one for the result. We also need to be able to have a `Monoid`
    for the log. The logic itself does not take anything from outside; it just returns
    the result and updated log:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这些放在一起。Writer 类接受两个类型参数，一个用于日志条目，另一个用于结果。我们还需要能够有一个 `Monoid` 用于日志。逻辑本身不依赖外部任何东西；它只返回结果和更新后的日志：
- en: '[PRE64]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, we want to compose our writer with another monadic function, just like
    we did before:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要将我们的 writer 与另一个模态函数组合起来，就像我们之前做的那样：
- en: '[PRE65]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The signature of the method is very similar to other monads we had in this chapter.
    Inside, we are decomposing the state of our current `Writer` into the result `a`
    and log `w`. Then, we apply the given function to the result and collect the next
    result and the log entries. Finally, we combine the log entries by utilizing the
    monoid operation and returning the result and the combined log.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的签名与其他我们在本章中遇到的模态非常相似。在内部，我们将当前 `Writer` 的状态分解为结果 `a` 和日志 `w`。然后，我们将给定的函数应用于结果，收集下一个结果和日志条目。最后，我们通过利用模态操作来组合日志条目，并返回结果和组合后的日志。
- en: 'We can also define the default constructor, which just returns a given argument
    with an empty log:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义默认构造函数，它只是返回一个带有空日志的给定参数：
- en: '[PRE66]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The monad definition is now a mechanical delegation to these methods. The only
    small difference is the requirement for the `Monoid[W]` to be available:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 单子的定义现在是对这些方法的机械委托。唯一的小区别是要求`Monoid[W]`可用：
- en: '[PRE67]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Yet again, we are done, and we can start to use our new abstraction. Let''s
    suppose that now regulations require us to write every bot movement into the journal.
    We are happy to comply. As long as it is only about movements, we don''t need
    to touch the `turn` function—we''ll only need to extend the `go` definition:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们已经完成了，现在我们可以开始使用我们的新抽象了。假设现在规定要求我们将每个机器人的移动记录到日志中。我们很高兴遵守。只要它只涉及移动，我们就不需要修改`turn`函数——我们只需要扩展`go`的定义：
- en: '[PRE68]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We are writing the position of the boat in the journal represented by a `Vector`.
    In the definition, we merely propagate the call to the boat again and return the
    position of the boat before the move as the log entry. We also need to satisfy
    the monoid requirement. The monoid is defined in a similar fashion to the one
    we had in [Chapter 7](c1798142-6829-479c-bb7b-d50ccd16e629.xhtml), *Understanding
    Algebraic Structures*:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将船的位置写入日志，位置由`Vector`表示。在定义中，我们只是再次调用船，并将移动前的船的位置作为日志条目返回。我们还需要满足单子要求。单子定义的方式与我们在[第7章](c1798142-6829-479c-bb7b-d50ccd16e629.xhtml)中提到的类似，*理解代数结构*：
- en: '[PRE69]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'With these preparations, we are ready to move our boat once again in SBT session
    using the `run` command:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 准备就绪后，我们再次使用SBT会话中的`run`命令来移动我们的船：
- en: '[PRE70]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We are passing the augmented `go` function and the original `turn` function
    (though typed with the `WriterTracking`) as a first parameter list and a `boat`
    wrapped in the `Writer` as a second parameter list. The output speaks for itself—it
    is the original result and vector containing positions of our boat before each
    move—all without touching the definition of the steering logic!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将增强的`go`函数和原始的`turn`函数（尽管使用`WriterTracking`类型）作为第一个参数列表，以及包裹在`Writer`中的`boat`作为第二个参数列表传递。输出不言自明——它是原始结果和包含每次移动前船的位置的向量——所有这些都无需触及转向逻辑的定义！
- en: The `Writer` monad concludes our tour of the land of monads. In the next chapter,
    we'll take a look at combining them. If your intuition tells you that it can be
    a bit more involving than combining applicatives—after all, there is a whole chapter
    dedicated to that topic—then you're right. It is more complex, but also more interesting.
    Let's take a look!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`Writer`单子结束了我们对单子王国的探索。在下一章中，我们将看看如何将它们结合起来。如果你的直觉告诉你这比结合应用性更复杂——毕竟，有一个整章是专门讨论这个主题的——那么你是正确的。它更复杂，但也更有趣。让我们看看吧！'
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we looked at monads as a way of sequencing computations. We
    studied how the meaning of this sequencing changes among the different monads
    we've implemented. The `Id` just composes computations as is. The `Option` adds
    a possibility to stop with no result if one of the steps returns no result. `Try`
    and `Either` have semantics similar to `Option` but allow you to specify the meaning
    of *no result* in terms of an `Exception` or as a `Left` side of `Either`. The
    `Writer` makes an append-only log available for computation in the chain. The
    `Reader` provides some configuration to every computation step. The `State` carries
    a *mutable* state between actions.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了将单子作为计算序列化的一种方式。我们研究了这种序列化在不同我们实现的单子之间的意义变化。`Id`只是按原样组合计算。`Option`在某个步骤返回无结果时提供了停止并返回无结果的可能性。`Try`和`Either`与`Option`具有类似的语义，但允许你指定`no
    result`的意义，无论是作为一个`Exception`还是`Either`的`Left`部分。`Writer`在链式计算中提供了一个只读日志。`Reader`为每个计算步骤提供了一些配置。`State`在动作之间携带一个*可变*状态。
- en: We discussed how the two primitive methods defining a monad, `unit` and `flatMap`,
    allow you to implement other useful methods such as `map`, `map2`, and `apply`,
    thus proving that every monad is a functor and an applicative.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了定义单子的两个原始方法`unit`和`flatMap`如何允许你实现其他有用的方法，如`map`、`map2`和`apply`，从而证明每个单子都是一个函子和一个应用性。
- en: In terms of `map` and `flatMap`—as for-comprehensions—we defined some small
    business logic to steer a boat. We then demonstrated how this logic can be reused
    without changes, even if the implementation of the underlying monad was reshaped.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在`map`和`flatMap`——作为for-comprehensions——方面，我们定义了一些小的业务逻辑来控制船的移动。然后我们展示了即使底层单子的实现被重塑，这种逻辑也可以无变化地重用。
- en: Questions
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Implement `Monad[Try]`.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Monad[Try]`。
- en: Prove the right identity law for the `State` monad.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明`State`单子的右单位律。
- en: Pick one of the monads we defined in this chapter and implement the `go` function,
    which will encode the notion of sinking the boat with a probability of 1%.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本章定义的单子中选择一个，实现`go`函数，该函数将以1%的概率编码船只沉没的概念。
- en: Please do the same as question 3, but encode the notion of motor breaking in
    1% of the moves, leaving the boat immobilized.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请与第3个问题做同样的事情，但在1%的移动中编码引擎故障的概念，使船只无法移动。
- en: Describe the essence of the monads we defined in this chapter by using the (loosely)
    following template—The state monad passes state between chained computations.
    The computation itself accepts the outcome of the previous calculation and returns
    the result, along with the new state.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下模板（松散地）描述本章定义的单子本质——状态单子通过链式计算传递状态。计算本身接受前一次计算的结果，并返回结果以及新的状态。
- en: 'Define a `go` method that both tracks the position of the boat and takes the
    possibility of sinking the boat by using the structure with the following type:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`go`方法，该方法既跟踪船只的位置，又使用以下类型的结构来采取船只沉没的可能性：
- en: '[PRE71]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Compare the answer to the 6th question and the way we combined `Applicatives`
    in the previous chapter.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将答案与第6个问题的答案以及我们在上一章中组合`Applicatives`的方式进行比较。
- en: Further reading
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Atul S. Khot, *Scala Functional Programming Patterns*: *Grok and performing
    effective functional programming in Scala*
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阿图尔·S·霍特，《Scala函数式编程模式：掌握Scala中的有效函数式编程》
- en: Ivan Nikolov, *Scala Design Patterns - Second Edition: Learn how to write efficient,
    clean, and reusable code with Scala*
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伊万·尼古洛夫，《Scala设计模式 第二版：学习如何使用Scala编写高效、简洁和可重用的代码》
