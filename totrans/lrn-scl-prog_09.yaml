- en: Familiarizing Yourself with Basic Monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we got to know Functors, an abstraction that gives
    the `map` method the effects defined in the standard library. Looking back at
    [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring Built-In Effects*,
    there is still something missing here—the source of the `flatMap` method, which
    all standard effects also have.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will finally meet the concept of a monad, the structure
    that defines `flatMap`. To learn about this function inside and out, we'll implement
    four different monads.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you''ll be familiar with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting a monad and its properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing monads for standard effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation and applicability of the following basic monads:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Id
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reader
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Writer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin, make sure you have the following installed:'
  prefs: []
  type: TYPE_NORMAL
- en: JDK 1.8+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SBT 1.2+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for this chapter is available in our GitHub repository at [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter09](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It took us three chapters to get to the moment where we're ready to discuss
    the origins of the `flatMap` method in regards to the effects we looked at in
    [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring Built-In Effects*. The
    reason for this is not the complexity of the topic, but the richness of the family
    of abstractions related to it.
  prefs: []
  type: TYPE_NORMAL
- en: After this introduction, a suspicious reader will think with disappointment—OK,
    now they are going to use their usual trick and say that there is an abstraction
    for `flatMap`, `flattener` or `flatMapative`, pull some laws out of thin air,
    and consider themselves done. What cheaters!
  prefs: []
  type: TYPE_NORMAL
- en: Well, technically we're not cheating because we're not pulling things out of
    anywhere. Instead, we're taking them from category theory, the branch of mathematics
    we mentioned previously. The rules our abstractions must obey are defined by mathematicians.
    There is an advantage to this approach, though—as soon as we can prove that our
    implementation obeys the required laws, we can use everything that has been proved
    by category theory to our advantage. One example of this is the possibility of
    combining two applicatives into one, just like in the example we discussed in
    the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our `flatMap` method, there is still some intrigue there. The
    abstraction name is `Monad`, and it is defined by two methods, `flatMap`, and
    `unit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The monad is defined for a container of type `F`. The `unit` method *lifts* its
    parameter into the context of `F`; the `flatMap` is similar to the plain `map`
    method in a sense that it applies `f` to `a`. What is different in `flatMap` and
    what makes it special is its ability to *collapse* or *flatten* two layers of
    `F` into one. This is easy to see from the type signatures of `a` and `f`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This possibility to flatten `F[F[A]]` into `F[A]` is the reason why monads
    are often expressed with a different set of methods; that is, `map` and `flatten`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `flatten` method does exactly what we just said—it allows us to reduce the
    stack of Fs into a single `F`. Sometimes, the `flatten` method is also called
    a `join`. We will see in a moment why this name makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, we have the same situation with monads that we had with applicatives—we
    can choose the set of primitive functions and implement the rest of functionality
    in terms of primitives. For instance, the `flatMap` is equally powerful as a combination
    of `map` and `flatten`, and we can choose one of these combinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s stick to the initial definition and implement other methods in terms
    of `flatMap`. This is what `map` will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What we're doing here is basically mapping with the function `f` and lifting
    the result in context of `F` as the types require.
  prefs: []
  type: TYPE_NORMAL
- en: Can you remember the name of the abstraction that is characterized by having
    a `map` method? Right, this is the functor. Our ability to define a `map` solely
    in terms of `flatMap` for every `Monad` proves that every `Monad` is a `Functor`.
    Because of this, we can state that `Monad extends Functor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of the `flatten` method is similarly straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With the `identity` function, we are using part of the `flatMap` power to convert
    two layers of `F` into one without actually doing anything with `a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we go further and apply a function that is already in the context of `F`
    to the `a`? It turns out that we can, and we know the method that does this—this
    is the `apply` defined in `Applicative`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're pretending that `f` is a value, so we just need to represent `a`
    as a function that can be applied to this value. The `fab` function takes a function
    called `A => B` that we use to `map` over the original `a`, returning `B`, which
    becomes an `F[B]` because of the application of `map`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `apply` function is also defined in terms of `flatMap` (and `map`, which
    is derived from `flatMap`) for every monad. This provides evidence that every
    `Monad` is an `Applicative`. Thus, our definition of `Monad` can be changed into
    the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `flatMap` method is only available for the `Monad`, not
    for an `Applicative`. This leads to interesting consequences, which we will look
    at later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, before switching gears and starting to implement the instances of specific
    monads, let's discuss the monadic laws first.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are only two of them, and both are very similar to the functor
    laws we discussed in the previous chapter; that is, the *identity* and *associativity*
    laws.
  prefs: []
  type: TYPE_NORMAL
- en: 'The identity law states that applying `flatMap` and `unit` should return the
    original argument. Depending on the order of application, there are left and right
    identities. We''ll represent them formally as usual with `ScalaCheck` properties
    (the following snippet does not show the implicit parameters; please consult the
    accompanying code for the full definition):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The left identity stipulates that the result of using `flatMap` over the argument
    by lifting it into the context of the monad should be equal to the original argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The right identity is a bit more complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Basically, the rule is that lifting `a` into the context and then flatmapping
    it with some function, `f`, should produce the same result as applying this function
    to `a` directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we need to do is combine both of these properties into a single identity
    property. We''ll need quite a bit of different `implicit Arbitrary` arguments
    in order to generate input data, including `A, M[A]` and `A => M[B]`, but the
    property itself should be anything but surprising:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The associativity property says that flatmapping using functions in succession
    should be the same as applying functions in the context of the monad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll omit the definition of the implicit parameters for this and a combination
    rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Please look up the source code in GitHub to see the full signature of these
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of what methods we need to define and how
    they should behave, let's implement some monads! We'll need to know the internals
    of the respective containers in order to implement the `flatMap`. In the previous
    chapter, we implemented the `map` method by delegating to the underlying container.
    Now, we'll use a low-level approach to show that the knowledge of the structure
    is indeed necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we will start with the simplest of the standard effects, `Option`.
    This is how we implement `Monad[Option]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of `unit` should be apparent—the only way to turn `A` into `Option[A]`
    is by wrapping it. Like we did previously, we're using the case class constructor
    directly to preserve the structure in the case that `a` is `null`.
  prefs: []
  type: TYPE_NORMAL
- en: The `flatMap` implementation is also very transparent—we can't apply a given
    function to `None`, and hence we return `None` as is. In the case that we have
    provided `a` is defined, we unwrap the value and apply `f` to it. This *unwrapping* is
    exactly the moment where we're using our knowledge of the internals of `Option` to
    flatten the potentially nested result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check that our implementation obeys monadic laws by defining a couple
    of properties for different types of `a` and `f`:. These properties need to be
    placed in a class extending `org.scalacheck.Properties`, as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Given that our properties hold for two different types of `a` and two different
    types of functions, we can be pretty sure that our code is correct and proceed
    with other containers.
  prefs: []
  type: TYPE_NORMAL
- en: For `Either`, we have a small complication, exactly like we had when we defined
    a Functor for it - two type parameters instead of one required by the `Monad`.
    Are you ready to deal with it the same way as before—by fixing the second type
    parameter and using the type lambda to define the final type of the monad? The
    good news is that we won't need to do this! The type lambda is such a common thing
    that's used in type class programming that many people craved an easier way to
    do this. This is the projector that plugin was created for. It allows us to use
    simplified syntax for type lambdas in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do so that we can start using the plugin is add the dependency
    to our project configuration in the `build.sbt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have this, we can simplify the type lambda syntax from our usual `({type
    T[A] = Either[L, A]})#T` to just `Either[L, ?]`. The plugin is feature-rich, and
    we will not go into further details here; visiting the documentation page at [https://index.scala-lang.org/non/kind-projector/kind-projector/0.9.7](https://index.scala-lang.org/non/kind-projector/kind-projector/0.9.7)
    is highly recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our new tool, the definition of `eitherMonad` is easy to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The type class constructor takes a type parameter, `L`, for the left side of
    `Either`. The rest of the implementation should be very familiar by now. It's
    worth reminding yourself that `Either` is right-biased—this it the reason we're
    returning `Right` from the `unit` method. It's also worth mentioning the last
    case in the `flatMap` pattern match where we repacked `l` from `Left[L, A]` into
    `Left[L, B]`. This is done to help the compiler infer the correct return type.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the property definition, we also have to fix a type of the left side. We
    can do this by defining a type alias, which will improve readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Except for the type alias, the definition of properties is the same as we had
    for `Option`.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of `Monad[Try]` is done by analogy, and we'll leave it as an
    exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, `Monad[List]` (or `Monad[Bucket]`, if we''re to use terms from
    the previous chapter) is quite different as the `List` can contain more than one
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `unit` is implemented in the same way as the other effects were—just by
    wrapping its argument. The `flatMap` is defined in a recursive manner. For `Nil`,
    we return `Nil`. This case is analogous to the case of `None` in `Monad[Option]`.
    In the case of a non-empty list, we have to apply the given function to all of
    the elements of the list and flatten the result at the same time. This is done
    in the second matching case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see if our property holds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It looks like it is, but the only reason for this is that the list generator
    in `ScalaCheck` does not generate input lists of a significant size. If it did,
    our property would fail with `StackOverflowError` because it is not tail-recursive!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix this by using the techniques that we discussed in [Chapter 3](9f67be8e-4fee-4050-ab96-8444bb795138.xhtml),
    *Deep Dive into Functions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have made our implementation tail-recursive by introducing the
    accumulator, we can safely use it with lists of an arbitrary length. But this
    approach is still quite direct and slow because of that. On my laptop, this implementation
    consumed approximately five times more time than the "native" optimized implementation
    of List''s `flatMap` method. It turns out that this is exactly the case where
    delegating makes sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: OK, so we have ignored `Future`, but have implemented type class instances for
    all of the containers we discussed in [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml),
    *Exploring Built-In Effects*. Are we done with monads? It turns out that we're
    not—not by a long shot. Just like it's possible to define an indefinite number
    of applicatives for different types constructors as long as the applicative properties
    hold, it is possible to do the same with monads.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we'll put some widely used monads such as Id, State,
    Reader, and Writer into code and discuss what are they good for.
  prefs: []
  type: TYPE_NORMAL
- en: Id Monad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The same way `Option` encodes optionality, the `Id` represents *nothing special*.
    It wraps a value but does nothing with it. Why would we need something that''s
    *not a thing*? The `Id` is kind of a *meta-lifting*, which can represent anything
    as an effect without changing it. How can this be done? Well, first of all, we
    have to say to the compiler that an `Id[A]` is the same thing as an `A`. This
    is easily done with a type alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This type definition will dictate the details of the monad''s implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, `unit(a)` is just `a`, and by having the type alias we just defined,
    we're making the compiler believe that it is not of type `A`, but an `Id[A]`.
    Similarly, with the `flatMap`, we can't do anything fancy, so we're just applying
    the given function `f` to `a`, utilizing the fact that `Id[A]` is actually just
    `A`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, as we''re doing nothing, the monadic laws should hold. But just
    to be 100% sure, we''ll encode them as properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The property holds—what else would you expect from something that does nothing?
    But why do we need this something in the first place?
  prefs: []
  type: TYPE_NORMAL
- en: This question has multiple answers. From an abstract perspective, the `Id` monad
    carries the function of (surprise!) an identity element in the space of monads
    in the same way that zero or one are the identity elements in the space of numbers
    under addition or multiplication. Because of this, it can be used as a placeholder
    for monad transformers (we'll learn about them in the next chapter). It can also
    be useful in a situation where in existing code expects a monad but we don't need
    one. We will see how this approach works later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have got our feet wet with the simplest monad, it is time to do
    something more involving—implementing the State monad.
  prefs: []
  type: TYPE_NORMAL
- en: State monad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In imperative programming, we have the concept of global variables—variables
    that are available anywhere in the program. This approach is considered to be
    a bad practice, but is still used quite often. The concept of global state extends
    global variables by including system resources. As there is only one filesystem
    or system clock, it totally makes sense to make them globally and universally
    accessible from anywhere in the program code, right?
  prefs: []
  type: TYPE_NORMAL
- en: In JVM, some of these global resources are available via the `java.lang.System`
    class. It contains, for instance, references to "standard" input, output, and
    error streams, the system timer, environment variables, and properties. The global
    state should definitely be a good idea, then, if Java exposes it on a language
    level!
  prefs: []
  type: TYPE_NORMAL
- en: The problem with global state is that it breaks the *referential transparency*
    of the code. In essence, referential transparency means that it should always
    be possible to replace a part of the code, for example, a function call, with
    the result of the evaluation of this call everywhere in the program, and this
    change should not cause observable changes in program behaviour.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of referential transparency is closely related to the concept of
    a `pure function`—a function is pure if it is referentially transparent for all
    its referentially transparent arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see how this works in a moment, but for starters, please consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the case of `incGlobal`, the function is not pure because it is not referentially
    transparent (because we cannot replace a call of it with the result of evaluation
    since these results are different each time the function is called). This makes
    it impossible to reason about the possible outcomes of the program without knowing
    the global state at every moment it is accessed or modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, the following function is referentially transparent and pure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In functional programming, we are expected to use only pure functions. This
    makes global state as a concept unsuitable for functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: But there are still many cases where it is necessary to accumulate and modify
    state, but how should we deal with that?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the `State` monad comes into play. The state monad is build around
    a function that takes a relevant part of the *global state* as an argument and
    returns a result and modified state (of course, without changing anything in a
    *global* sense). The signature of such a function looks like this: `type StatefulFunction[S,
    A] = S => (A, S)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can wrap this definition into a case class to simplify the definition of
    helper methods on it. This `State` class will denote our effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also define a few constructors in the companion object so that we''re
    able to create a state in three different situations (to do this in REPL you need
    to use `:paste` command and paste *both* the case class and a companion object,
    then press *Ctrl* + *D*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The default constructor lifts some value, `a: A`, into the context of `State`
    by returning the given argument as a result and propagating the existing state
    without changes. The getter creates a `State` that wraps some function, returning
    the given argument both as the state and as a result. The setter wraps the `State`
    over the function, which takes a state to be wrapped and produces no result. The
    semantics of these are similar to reading the global state (hence the result is
    the equal state) and setting it (hence the result is `Unit`), but applied to `s:
    S`.'
  prefs: []
  type: TYPE_NORMAL
- en: For now, the `State` is nothing but a thin wrapper around some computation which
    involves pushing through (and potentially changing) a bit of state. What we would
    like to be able to do is compose this computation with the next one. We'd like
    to do this similarly to how we compose functions, but instead of `(A => B) compose
    (B => C)`, we now have `State[S, A] compose State[S, B]`. How can we do this?
  prefs: []
  type: TYPE_NORMAL
- en: 'By definition, our second computation accepts the result of the first one as
    its argument, hence we start with `(a: A) =>` . We also stated that, as a result
    (because of the possible state change and return type of the second state), we''ll
    have a `State[S, B]`  which gives us a full signature for the computation to compose
    with the first one: `f: A => State[S, B]` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement this composition as a method on `State`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We define our composed computation as a combination of two runs. The first is
    done with the input provided to the first state, which we decompose into the result
    and a next state. We then call the provided transformation `f` on the result and
    `run` it with the next state. These two successive runs might seem strange at
    first glance, but they just represent the fact that we're fusing two `run` functions
    from different states into one function defined on the composed state.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have an effect and can create a monad for it. You should have noticed
    by now that the signature of the `compose` method we just defined is the same
    as that of the monadic `flatMap`.
  prefs: []
  type: TYPE_NORMAL
- en: The `compose` in this and the following cases does not refer to the function
    composition we learned about in [Chapter 3](9f67be8e-4fee-4050-ab96-8444bb795138.xhtml), *Deep
    Dive into Functions*, but to the concept of Kleisli composition. It is often called
    Kleisli arrow, and in essence is just a wrapper over the `A => F[B]` function,
    which allows for the composition of functions returning monadic values. It is
    frequently named `>>=`, but we'll stick to `compose` here.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to delegate monadic behavior to the logic we already have in
    the `State`, the same way as we could do for standard effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Luckily, we can also delegate the lifting done by the `unit` to the default
    constructor! This means that we're done with the definition of the monad and can
    continue with our rigorous testing approach by specifying a property check for
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Except in this case, we won't.
  prefs: []
  type: TYPE_NORMAL
- en: The rationale behind this is the fact that the `State` is quite different from
    the other effects we looked at until now in regard to the value it incorporates.
    The `State` is the first effect which is built *exclusively* around some function.
    Technically, because functions are first-class values in Scala, other effects
    such as `Option` could also contain a function and not a value, but this is an
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: This brings complications to our testing attempts. Earlier, we modified the
    value contained in the effect in different ways and checked that the results we
    equal, as required by the monadic laws, by comparing them. With the requirement
    to have a function as a value of the effect, we face the challenge of comparing
    two functions for equality. At the time of writing this book, this is a topic
    of active academic research. For our practical purposes, there is currently no
    other way to prove that two functions are equal other than testing them for each
    possible input parameter(s) and checking whether they return same results—which
    we obviously cannot afford to do in our properties.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we will *prove* that our implementation is correct. We will use a method
    called the *substitution model* for this. The essence of the method is in using
    referential transparency in order to substitute all of the variables and function
    calls with values they return repeatedly until the resulting code can't be simplified
    anymore—very much like solving an algebraic equation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: To get us prepared before proving the monadic laws, we'll prove a useful lemma
    first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lemma is stated as follows: having `as: M[A], f: A => M[B]` and `M = State` so
    that `as.run = s => (a, s1)` (the run method returns a pair of `a` and `s1` for
    some input `s` and `f(b) = (b: A) => State(s1 => (b, s2)`), `M.flatMap(as)(f)`
    will always yield `State(s => (b, s2))`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we''re getting this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: By definition, `as.run = s => (a, s1)`, which gives us `as = State(s => (a,
    s1))`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `flatMap` delegates to the `compose` method defined on `State`, and therefore
    `M.flatMap(a)(f)` for `M = State` becomes `a.compose(f)`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In terms of `as` and `f`, `as.compose(f)` can be formulated as `State(s => (a,
    s1)).compose(f)`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we''re going to substitute the call of the `compose` method with its definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have proved our assumption that `Monad[State].flatMap(as)(f) = State(s
    => (b, s2))` for `as = State(s => (a, s1))` and `f(a) = (b: A) => State(s1 =>
    (b, s2))`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can use this lemma while proving the monadic laws for `State`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with the identity laws, and more specifically, with the left identity.
    This is how we formulated it in our `ScalaCheck` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, we want to prove that if we let `M = State`, then every `as: M[A]` following
    it is always true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s simplify the left side of the equation first. By definition, we can
    replace `as` with `State` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step that we must do is substitute the call of the `unit` method with
    its implementation. We''re just delegating to the default constructor of the `State`,
    which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Hence, our definition becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To substitute the `flatMap` call, we have to recall that all it does is just
    delegate to the `compose` method defined on `State`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use our lemma for state composition, which gives us the following
    simplified form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This can''t be simplified further, so we will now take a look at the right
    side of equation, `as`. Again, by definition, `as` can be represented as `State(s
    => (a, s1))`. This gives us final proof that `State(s => (a, s1)) == State(s =>
    (a, s1))`, which always holds for any `a: A`.'
  prefs: []
  type: TYPE_NORMAL
- en: The right side identity is proved similarly to the left side, and we leave this
    as an exercise to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second law we need to prove is the associative law. Let''s recall how it
    is described in ScalaCheck terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Let's see what we can do with that, starting with the  `leftSide`,  `M.flatMap(M.flatMap(as)(f))(g)`.
  prefs: []
  type: TYPE_NORMAL
- en: By substituting `M` with `State` in the internal part, `M.flatMap(as)(f)` becomes
    `State(s => (a, s1)).compose(f)`, which by the application of our lemma transforms
    it into `State(s => (b, s2))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can substitute the outer `flatMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`M.flatMap(State(s => (b, s2)))(g)` is the same as  `State(s => (b, s2)).compose(g)` **(1)**'
  prefs: []
  type: TYPE_NORMAL
- en: Let's leave it in this form and look at the `rightSide`: `M.flatMap(as)(a =>
    M.flatMap(f(a))(g))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we substitute the internal `flatMap` with the `compose`, before turning `a
    => M.flatMap(f(a))(g)` into `(a: A) => f(a).compose(g)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, by the definition of `f` we used for the left side, we have `f(a) = a =>
    State(s1 => (b, s2))` and thus the internal `flatMap` becomes `a => State(b, s2).compose(g)`.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the outer `flatMap` with `compose` gives us—in combination with the
    previous definition—`State(s => (a, s1)).compose(a => State(s1 => (b, s2)).compose(g))`.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use our lemma again to substitute the first application of `compose`,
    which will have `State(s => (b, s2)).compose(g)` as the outcome. **(2)**
  prefs: []
  type: TYPE_NORMAL
- en: '**(1)** and **(2)** are identical, which means that the `leftSide` and `rightRide`
    of our property are always equal; we just proved the associativity law.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, we have an implementation of the `State` and the corresponding monad,
    which has been proven to be correct. It''s time to look at them in action. As
    an example, let''s imagine that we''re going fishing by boat. The boat has a position
    and direction, and can go forward for some time or change direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We could go around with this boat by calling its methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a problem with this approach, though—it does not include fuel consumption.
    Unfortunately, this aspect was not envisioned at the time the boat''s navigation
    was developed, and has been added later as a global state. We will now refactor
    the old style with the state monad. If the quantity of fuel is modelled as a number
    of litres, the most straightforward way to define the state is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can define our boat moving logic that takes fuel consumption into account.
    But before doing that, we are going to simplify the syntax of our monadic calls
    a bit. Currently, the `flatMap` and `map` methods of our Monad take two parameters—the
    container and the function to apply to the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to create a wrapper that will incorporate both the effect and
    a monad so that we have an instance of the effect and only need to pass the transforming
    function to the mapping methods. This is how we can express this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The implicit conversion `MonadF` will wrap any effect, `F[A]`, as soon as there
    is an implicit monad definition available for `F`. Having `value`, we can use
    it as a first parameter for the `flatMap` and `map` methods defined on monad—thus,
    in the case of `MonadF`, they are reduced to higher-order functions taking single
    parameters. By importing this implicit conversion, we now can call `flatMap` and
    `map` directly on `State`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to create pure functions that will take fuel consumption into
    account while moving the boat. Assuming that we can''t change the original definition
    of `Boat`, we have to pass the `boat` as a parameter to these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `consume` function calculates fuel consumption based on `speed` and `time`.
    In the `turn` function, we're taking a `boat`, turning it by the specified `angle`
    (by delegating to the default implementation), and returning the result as an
    instance of `FuelState`.
  prefs: []
  type: TYPE_NORMAL
- en: A similar approach is used in the `go` method—to compute the boat's position,
    we are delegating to the boat logic. To sum the new volume of fuel available,
    we reduce the initial fuel quantity (which is passed as a parameter) and return
    the result as a part of the state.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can finally create the same chain of actions we had defined initially, but
    this time by tracking fuel consumption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If you compare this snippet with the original definition, you'll see that the
    path of the boat is the same. However, much more is happening behind the scenes.
    Each call of the `flatMap` passes the state over—this is how it is defined in
    the code of the monad. In our case, the definition is the `compose` method defined
    on the `State`. The function given as a parameter to the `flatMap` method describes
    what should happen with the result and possibly with the passed state. In a sense,
    using monads gives us a responsibility separation—*the monad describes what should
    happen between computation steps* as the result of one step being passed to the
    next step, and *our logic describes what should happen with the result before
    it is passed over to the next computation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined our logic with partially applied functions, which obscure what is
    really happening a bit—to make this obvious, the last step is defined using explicit
    syntax. We could also make the process of passing results between steps more explicit
    by using for-comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The approach is the same as before, but just the syntax has changed—Now, passing
    the boat between steps is done explicitly, but the state passing had visually
    disappeared—The for-comprehension makes monadic code look like it''s imperative.
    This is the result of executing both of these approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we be sure that the state has been passed correctly? Well, this is
    what monad law guarantees. For those of you that are curious, we can even manipulate
    the state using methods we''ve defined in the state''s companion object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We augmented our previous for-comprehension with logging statements to output
    the current state after each step—These are the statements of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Does it feel like we're really reading some global state? Well, in reality,
    what is happening is that we're getting the current `State` as a result (this
    is how we defined `State.get` earlier), which is passed then over to the next
    computation—the logging statement. Further computations just use the results of
    the previous steps explicitly, just like they had before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this technique, we''re also modifying the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're simulating that our boat has a fuel tank of a maximal capacity equal
    to 700\. We're doing this by first reading the current state and then setting
    back whatever is smaller—the state passed by the caller of the `run` method or
    our tank capacity. The `State.set` method returns `Unit`—this is why we ignore
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the definition augmented with the logging looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the limit of 700 was applied before the first movements of the
    boat.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is still an issue with our implementation of `move`—it uses hardcoded
    `go` and `turn` functions as if we would only be able to navigate one specific
    boat. However, this is not the case—we should be able to do this with any boat
    which has `go` and `turn` functionality, even if they are implemented slightly
    differently. We could model this by passing the `go` and `turn` functions as parameters
    to the `move` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This definition will allow us to have different implementations for the `go`
    and `turn` functions in different situations, but still, steer the boat along
    the given hardcoded path.
  prefs: []
  type: TYPE_NORMAL
- en: If we look carefully, we'll see that after creating the initial wrapper over
    the provided boat parameter, the definition of the `move` method has no further
    notion of the `State`—we need it to be a monad to be able to use for-comprehension,
    but this requirement is much more generic than the State we currently have.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make the definition of the `move` function generic by improving on these
    two aspects—by passing the effect instead of creating it and making the method
    polymorphic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can follow the given path with any type which has a monad and the `go`
    and `turn` functions with specified signatures. Given the fact that this functionality
    is now generic, we can also move it into the `Boat` companion object along with
    the definition of the default boat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this approach works together with the state monad. It turns
    out that our definition of the `go` and `turn` methods does not need to change
    at all. All we need to do is call the new generic `move` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks much nicer, but still there is some room for improvement. Specifically,
    the `turn` method does nothing but propagate the call to the default implementation.
    We can make it generic in the same way as we did for the `move` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We can't make it polymorphic in regard to the `Boat` because we need to propagate
    a call to the specific type, but we still have the generic monad type. This specific
    code uses the implicit definition of `Monad.apply` to summon the monad of a specific
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, we can also do the same for the `go` method—provide a default facade
    implementation—and place them both into the companion object of the `Boat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Again, to put this definition into the REPL you need to use the `:paste` command,
    followed by both the definition of `boat` case class and a companion object, and
    a combination of *Ctrl* +*D*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use the default implementations for the cases where we don''t need
    to override the default behavior. For instance, we can get rid of the default
    `turn` implementation for the case of State and call `move` with the default one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We have to help the compiler to infer the correct type of monad to use by providing
    the type parameter, but now our definition of stateful behavior is reduced to
    the overriden definition of the `go` method—the rest of the code is generic.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an illustration, we can reuse everything we have used so far with the `Id`
    monad—the result should be the same as executing the chain of calls directly on
    `Boat`. This is the complete implementation that''s done with the `Id` monad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Again, we're providing the type of monad to use, but this is pretty much it.
    Since `Id[Boat] = Boat`, we even can pass the `boat` directly without wrapping
    it into the `Id`.
  prefs: []
  type: TYPE_NORMAL
- en: Isn't that nice? We could use any monad we've defined so far to pass different
    effects to the main logic formulated in monadic terms. We'll leave the easy part—using
    existing definitions—as an exercise for the reader, and will now implement two
    other monads representing the read and write side of the `State`, that is, the
    `Reader` and `Writer` monads.
  prefs: []
  type: TYPE_NORMAL
- en: Reader monad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `State` monad represents an external (to the definition of the logic) state,
    which needs to be taken into account and possibly modified. The `Reader` monad
    is similar in the taking into account part—it accepts an external context and
    passes it over unchanged to every computation down the queue. In terms of the
    global state we discussed during the examination of the state monad, the `Reader`
    will have access to read-only system properties. Because of this, the reader monad
    is often known as a mechanism for dependency injection—because it takes some outside
    configuration (not necessarily basic things like strings or numbers, but also
    possibly other complex components, database access mechanisms, network sockets,
    or other resources) and makes it available for the function it wraps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how `Reader` is defined. We have already compared `State` and `Reader`,
    and the definition is also quite similar—with the only difference that we don''t
    need to return the changed context (it is read-only, after all). In code, it looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `Reader` type is just a wrapper over a function which takes a context of
    type `R` and returns some result of type `A`. The `flatMap` combines two `run`
    functions together—we're doing this by calling `run` with a given context, applying
    the given transformation to the result, and then calling the `run` for the result.
    The first call of the `run` is basically for `this`, while the second is for the
    `Reader` we're getting by applying `f`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define a constructor for some value that ignores any given context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have this model, we can have a monad for it, just like we did with
    the state monad—by using the kind-projector syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Unsurprisingly, the monad just delegates to both the constructor and the `compose`
    method we just defined. Surprisingly, now that we've done this, we're done defining
    the reader monad and can use it with our definition of the move function!
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that we have a regulation that defines a speed limit for boats
    and the maximal angle they are allowed to turn at once (sounds strange, but in
    the place, we're fishing we have case law, so this is what we've got).
  prefs: []
  type: TYPE_NORMAL
- en: 'As this is external regulation, we have to model it with a case class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We'll also define an alias fixes the type of context for a `Reader` to be `Limits`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can redefine our `go` and `turn` methods by applying these limits,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing special about the implementation itself. The type signature
    of functions are predefined by the `move` method. After each action, we return
    `Reader[Limits, Boat]`. To calculate the new state of the boat, we delegate to
    its methods after figuring out the maximal speed or angle we can apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we designed the rest of the code in a generic way, this is all we need to
    do—Let''s `move`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: To run this example, please use the SBT `run` command.
  prefs: []
  type: TYPE_NORMAL
- en: We're passing the `go` and `turn` functions we just defined to the generic `move`
    method, along with the properly wrapped `boat`, and `run` it afterward. By looking
    at the result, we can say that the speed limits were properly applied.
  prefs: []
  type: TYPE_NORMAL
- en: After scrutinizing the state monad, there is not much left to discuss the reader,
    so we're good to proceed to the Writer monad.
  prefs: []
  type: TYPE_NORMAL
- en: Writer monad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Writer` monad is a sibling of the state and the reader, oriented on modifying
    the state. Its main purpose is to provide a facility to write into some kind of
    log by passing this log between computations. The type of the log is not specified,
    but usually, some structure with a possibly low overhead of the append operation
    is chosen. To name a few suitable possibilities, you could use a `Vector` from
    the standard library or a `List`. In the case of the List, we need to prepend
    the log entries and revert the resulting log at the very end.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get too deep into the discussion about the type of log, it is good
    to realize that we can defer the decision until later. All we need to know is
    how to append an entry to the existing log. Or, in other words, how to combine
    two logs, one of which contains just a single entry, together. We already know
    about the structure with such a functionality—it is a `Semigroup`. Actually, we
    also need to be able to represent an empty log, and so our end decision will be
    to have a `Monoid`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s bring this together. The Writer takes two type arguments, one for the
    log entry, and one for the result. We also need to be able to have a `Monoid`
    for the log. The logic itself does not take anything from outside; it just returns
    the result and updated log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to compose our writer with another monadic function, just like
    we did before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The signature of the method is very similar to other monads we had in this chapter.
    Inside, we are decomposing the state of our current `Writer` into the result `a`
    and log `w`. Then, we apply the given function to the result and collect the next
    result and the log entries. Finally, we combine the log entries by utilizing the
    monoid operation and returning the result and the combined log.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define the default constructor, which just returns a given argument
    with an empty log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The monad definition is now a mechanical delegation to these methods. The only
    small difference is the requirement for the `Monoid[W]` to be available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Yet again, we are done, and we can start to use our new abstraction. Let''s
    suppose that now regulations require us to write every bot movement into the journal.
    We are happy to comply. As long as it is only about movements, we don''t need
    to touch the `turn` function—we''ll only need to extend the `go` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We are writing the position of the boat in the journal represented by a `Vector`.
    In the definition, we merely propagate the call to the boat again and return the
    position of the boat before the move as the log entry. We also need to satisfy
    the monoid requirement. The monoid is defined in a similar fashion to the one
    we had in [Chapter 7](c1798142-6829-479c-bb7b-d50ccd16e629.xhtml), *Understanding
    Algebraic Structures*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'With these preparations, we are ready to move our boat once again in SBT session
    using the `run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We are passing the augmented `go` function and the original `turn` function
    (though typed with the `WriterTracking`) as a first parameter list and a `boat`
    wrapped in the `Writer` as a second parameter list. The output speaks for itself—it
    is the original result and vector containing positions of our boat before each
    move—all without touching the definition of the steering logic!
  prefs: []
  type: TYPE_NORMAL
- en: The `Writer` monad concludes our tour of the land of monads. In the next chapter,
    we'll take a look at combining them. If your intuition tells you that it can be
    a bit more involving than combining applicatives—after all, there is a whole chapter
    dedicated to that topic—then you're right. It is more complex, but also more interesting.
    Let's take a look!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at monads as a way of sequencing computations. We
    studied how the meaning of this sequencing changes among the different monads
    we've implemented. The `Id` just composes computations as is. The `Option` adds
    a possibility to stop with no result if one of the steps returns no result. `Try`
    and `Either` have semantics similar to `Option` but allow you to specify the meaning
    of *no result* in terms of an `Exception` or as a `Left` side of `Either`. The
    `Writer` makes an append-only log available for computation in the chain. The
    `Reader` provides some configuration to every computation step. The `State` carries
    a *mutable* state between actions.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed how the two primitive methods defining a monad, `unit` and `flatMap`,
    allow you to implement other useful methods such as `map`, `map2`, and `apply`,
    thus proving that every monad is a functor and an applicative.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of `map` and `flatMap`—as for-comprehensions—we defined some small
    business logic to steer a boat. We then demonstrated how this logic can be reused
    without changes, even if the implementation of the underlying monad was reshaped.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implement `Monad[Try]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prove the right identity law for the `State` monad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick one of the monads we defined in this chapter and implement the `go` function,
    which will encode the notion of sinking the boat with a probability of 1%.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please do the same as question 3, but encode the notion of motor breaking in
    1% of the moves, leaving the boat immobilized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe the essence of the monads we defined in this chapter by using the (loosely)
    following template—The state monad passes state between chained computations.
    The computation itself accepts the outcome of the previous calculation and returns
    the result, along with the new state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a `go` method that both tracks the position of the boat and takes the
    possibility of sinking the boat by using the structure with the following type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Compare the answer to the 6th question and the way we combined `Applicatives`
    in the previous chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Atul S. Khot, *Scala Functional Programming Patterns*: *Grok and performing
    effective functional programming in Scala*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ivan Nikolov, *Scala Design Patterns - Second Edition: Learn how to write efficient,
    clean, and reusable code with Scala*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
