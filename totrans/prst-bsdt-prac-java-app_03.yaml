- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Architectural Strategies and Cloud Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will delve into the topic of architecture from the perspective
    of services. Specifically, we will explore the relationship between monolithic
    and microservices architectures and consider the benefits and drawbacks of each
    approach. We will also examine the use of event-driven architecture as a means
    of integrating these services. In addition to providing technical foundations,
    we will aim to provide strategic and contextual insights into how these concepts
    fit together and why they drive the adoption of various cloud service offerings.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will aim to not only provide a solid foundation in technical
    Java persistence concepts but also offer strategic and contextual insights into
    how these ideas are interconnected and why they contribute to the growing adoption
    of various cloud service offerings.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the aforementioned topics throughout the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: The cloud’s influence on software architecture design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns – the essential building blocks for software architects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monolithic architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a deeper understanding of how the
    overall solution architecture affects data integration design and the pros and
    cons of using a combination of on-premises and cloud solutions, resulting in hybrid
    and/or multi-cloud models.
  prefs: []
  type: TYPE_NORMAL
- en: The cloud’s influence on software architecture design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we could start by delving into the specific details of multiple architectural
    topics – including monolithic, microservices, SOA, event-driven, and event sourcing
    – we’re going to take a different approach. We’ll start by providing you with
    a deeper understanding of these patterns and their importance in software design.
    Having this background will help to broaden your horizons. Let’s explore a few
    design patterns in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns – the essential building blocks for software architects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Over the past few decades, we’ve identified and shared “*ideas that have been
    useful in one practical context and will probably be useful in others*,” as wisely
    said by Martin Fowler:'
  prefs: []
  type: TYPE_NORMAL
- en: The constant flow of ideas, experiences, and solutions shared by tech enthusiasts
    worldwide converge into a rich knowledge base that drives and accelerates technological
    evolution.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns describe solutions at different levels, from code-level practices to
    application-level practices. Among the hundreds of patterns out there, we will
    highlight the practices of design patterns, enterprise application patterns, and
    software architecture patterns to help us build a solid persistence layer.
  prefs: []
  type: TYPE_NORMAL
- en: The **Gang of Four** (**GoF**) design patterns and the **Service-Oriented Architecture**
    (**SOA**) pattern were important foundations for the more recent Microservices
    Architecture and Event-Driven Architecture patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices architecture, which has gained popularity in recent years, is
    an approach to designing and building software systems as a collection of small,
    independently deployable services. This architecture pattern builds on the ideas
    of modularity and separation of concerns that were central to SOA but takes them
    to a deeper level.
  prefs: []
  type: TYPE_NORMAL
- en: People often adopt solutions that they don’t actually need because they lack
    the ability to analyze trends and navigate tech hype. It’s important to remember
    that the goal should be to identify the best solution to a specific problem using
    available technologies, rather than simply targeting the delivery of cloud-native
    microservices or other trendy solutions. The key is to understand how to solve
    a set of business problems using the right technology.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about tech trends – a few things to keep in mind
  prefs: []
  type: TYPE_NORMAL
- en: A common way to decide whether a specific trend is appropriate for your scenario
    is to refer to its *technology adoption life cycle*. It brings market adoption
    insights that help you understand the topic’s current maturity; in other words,
    the more people adopting a specific solution, the more success cases will show
    up. Not only that but also horror stories, adoption challenges, pros and cons,
    recommendations, and so on will appear. Looking at the bigger picture, the different
    maturity groups provide more understanding about the market segments that are
    embracing the technology.
  prefs: []
  type: TYPE_NORMAL
- en: We now understand that patterns are a set of building blocks that can be used
    to achieve specific business goals. There are hundreds of patterns covering multiple
    levels and aspects of application solutions, and new patterns can be derived from
    the concepts of previous ones. It’s important to keep in mind that patterns can
    be combined and used in different ways to address different goals. For example,
    a Java service could adopt the repository pattern for its persistence layer, be
    built on best practices for a microservices architecture, use enterprise integration
    patterns to communicate with other services, follow the recommendations of 12-factor
    applications for cloud-native applications, and adopt design patterns for automated
    pipeline delivery.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, let’s delve into the pros and cons of different architectural
    options such as microservices and monolithic apps, taking into consideration fundamental
    needs and features.
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A traditional way to build a solution is using **monolithic** applications,
    which are large, standalone software systems that are built as single, cohesive
    units, with all components being contained within a single package and compiled,
    managed, and deployed together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Monolithic application characteristics](img/Figure_3.01_B19375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Monolithic application characteristics
  prefs: []
  type: TYPE_NORMAL
- en: This means that both the frontend and backend are included in the same artifact
    and must be compiled, managed, and deployed together. While this method can make
    it easier to initially develop and maintain the application, as the team grows,
    the maintenance of the code becomes more complex, and deploying updates becomes
    more challenging and time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: Performance-wise, scalability is impacted since it is very difficult to upscale
    or downscale specific features or components.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the relationship between a database and a monolith is not a complex
    task. Instead of huge databases, some opt to develop monoliths that store and
    consume data from multiple databases – further increasing maintenance complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Surprisingly, it is possible to create modular applications using a monolithic
    architecture. Such applications can be designed in a modular fashion, with each
    module responsible for a specific set of functions and developed independently
    of the other modules.
  prefs: []
  type: TYPE_NORMAL
- en: Next, to verify its maturity, let’s refer to the broad market adoption and feedback.
    According to trend reports [2] from 2022, the modular monolithic architectural
    approach has already crossed the chasm and gained widespread adoption among the
    early majority group.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with every architectural design, this approach has its advantages and disadvantages.
    We can analyze the benefits from multiple angles, including (but not restricted
    to) characteristics such as maintainability, deployment processes and frequency,
    validation processes, automation pipelines, and others. *Figure 3**.2* displays
    key topics to analyze when designing an app that can result in requiring different
    levels of effort and cost during each phase of the application life cycle. Some
    prioritize long-term benefits such as ease of maintenance. Others will prefer
    to adopt strategies with an easier and faster start:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Fi\uFEFFgure 3.2 – Decision points during application design](img/Figure_3.02_B19375.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Decision points during application design
  prefs: []
  type: TYPE_NORMAL
- en: The best choice will depend on each business need being addressed. In regard
    to the monolithic architectural style, it is established that its characteristics
    can represent a significant roadblock for the organization, particularly as the
    application grows in complexity with multiple development teams and numerous features.
    Changes and additions to the application in this environment become costly and
    scaling becomes difficult.
  prefs: []
  type: TYPE_NORMAL
- en: In the face of the downsides of a monolith design inspired by the SOA approach,
    the concept of microservices comes into play. Microservices propose the decoupling
    of the components/modules into smaller services, each of which having their own
    unique responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Even though microservices involve managing more failure points, a successful
    implementation allows for benefits such as independent teams, changes, deployments,
    and scaling of each service within the ecosystem, without affecting the other
    microservices. This is achieved when maintaining the principle of integrity of
    each individual service. Let’s delve further into the topic and examine the details
    more closely.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservice-oriented architecture brings the idea of creating applications
    decoupled from each other and modeled according to their business domain. These
    applications are integrated through different protocols, and various communication
    patterns (REST, GRPC, and asynchronous events, among others) and integration patterns
    can be adopted. Using a microservice-oriented architecture facilitates quicker
    and more regular deliveries, as well as introducing a language-agnostic ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'A microservices architecture has services that are decoupled and independent
    of other microservices that compose the broader solution. As Sam Newman states
    in his book *Building Microservices*, there are implicit concepts and behaviors
    expected from a microservice, as described in *Figure 3**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Microservices characteristics](img/Figure_3.03_B19375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Microservices characteristics
  prefs: []
  type: TYPE_NORMAL
- en: 'Architects and developers should have in mind not only a core set of characteristics
    of a microservices architecture but also the critical elements that can result
    in immense risk to the project, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integration latency**: In a monolithic application, the components communicate
    directly in memory rather than over a network. The result is faster communication
    compared to the microservices scenario. However, as the number of services and
    architectural complexity increases, the risk of performance issues and latency
    increases – potentially becoming a catastrophic problem. To mitigate this risk,
    take it as a good practice to have proper monitoring and management of thresholds
    for a service’s invocation response time, including the capability of a client
    service to handle such issues by itself. A recommendation and good practice is
    to have fault tolerance capabilities in client microservices. For instance, clients
    should be able to retry previously failed invocations, have proper fallbacks (instead
    of shutting down due to errors), and be able to reestablish themselves once the
    requested service comes back to normal functioning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separation of duties**: Pay attention to the separation of duties of the
    backend and frontend components. One frontend may depend on multiple backend services.
    Frontend solutions must be implemented so that, in the event of failure of one
    of the requested backend services, only the specific associated features have
    their normal functioning interrupted – all other frontend components should still
    work properly, guaranteeing the best possible experience possible for the end
    user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polyglot environment trap**: The microservice architecture is agnostic to
    languages and frameworks. Consequently, your environment can become a polyglot.
    From an architectural and technical leadership perspective, be thrifty in evaluating
    the technologies to be used so that you don’t end up with services implemented
    with technologies for whose maintenance you lack the required staff. The scope
    definition and the microservice size should be taken as measures for such definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service size and responsibility**: Determining an appropriate size and scope
    of a microservice may require the investment of time and effort upfront, at the
    beginning of the journey to decoupling. Remember to carefully consider the principle
    of single responsibility (**SOLID**) when measuring a service’s scope and size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forgotten services**: One of the governance challenges is to avoid the existence
    of orphaned applications in a productive environment. Try to avoid services without
    owners by establishing a team for each service, including during productive phases.
    With that, in the face of an unexpected problem or a new change request, it will
    be simpler to map and define who should be responsible for the tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Granular repositories**: Avoid breaking up projects into too many repositories,
    as this over-granulation can become an unmanageable scenario with more repositories
    than collaborators in the company.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common pitfalls of microservices adoption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Microservices architecture adoption brings multiple implications and challenges,
    and as we should know by now, and as stated in the book *Fundamentals of Software
    Architecture: An Engineering Approach* ([https://www.amazon.com/dp/B08X8H15BW](https://www.amazon.com/dp/B08X8H15BW)),
    everything has trade-offs – and *microservices are* *no exception.*'
  prefs: []
  type: TYPE_NORMAL
- en: While initially thought to be a promising approach, the microservices journey
    has proven to be more complex than estimated by the broader tech industry, especially
    for small teams. As its adoption increased, we also observed more reports about
    a range of design issues and missteps. To avoid common pitfalls, it is important
    to watch out for the following mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Improperly breaking down domains into microservices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is very easy to make mistakes when mapping the business problems down to
    domains, and domains to microservices, especially when starting the move to a
    microservices approach. This domain leads to solutions that require requests to
    multiple services to be able to retrieve a relevant set of business data, instead
    of providing it efficiently through a single request. In other words, regarding
    data retrieval and querying, an incorrect scope definition can lead to complex
    code implementation and poorly performing solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some pointers to help guide you find the right path:'
  prefs: []
  type: TYPE_NORMAL
- en: Stakeholders and business experts are involved in the process of domain definition
    as they can give helpful inputs concerning domain boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices should have well-defined scope; be responsible for one “thing”
    and be able to do it well; have functionalities that easily fit together (in other
    words, that are cohesive); be independently deployable and scalable; and keep
    in mind that a monolith has higher chances of being more performant since processing
    happens all in memory, without extra network latency added during microservices
    integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generally speaking, cross-domain services integration can rely on multiple
    strategies, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Usage of an API gateway to route requests back and forth and filter, transform,
    and aggregate requested data from multiple sources in one client request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data denormalization across services which may result in data duplication in
    exchange of more efficient data retrieval and querying, relying on techniques
    such as event-driven architecture to reduce the number of requests needed to retrieve
    data, or, having event-driven services that can asynchronously filter, aggregate,
    enrich and provide access to relevant data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation gap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As development teams are broken down into smaller and more numerous groups,
    they start delivering more services, more frequently. The operations of these
    services’ life cycle shouldn’t obstruct their potential fast-paced evolution.
    **Continuous Integration and Continuous Deployment** (**CI/CD**) is a best practice
    for microservices and is essential for managing multiple services deployed across
    multiple deployment environments, ranging from on-premises machines to cloud services.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting as many languages and technologies as teams desire
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Deciding on programming languages is certainly one of the most intriguing topics.
    Even though programmers love to brag about programming languages that allow them
    to write ultra-short “Hello World” examples and base their decisions on this type
    of argument, to this day, we have not come across a single project that had a
    core business goal to output text into some sort of console, terminal, or even
    write HTML.
  prefs: []
  type: TYPE_NORMAL
- en: A critical decision such as the programming language of a service should not
    be solely based on the number of lines or the line simplicity of a sample.
  prefs: []
  type: TYPE_NORMAL
- en: An application must become a microservice because it is big
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Kindly realize that not every large application *needs* to be a microservice.
    Here’s an interesting metric we’d like you to be familiar with: *cost per line*
    *of code.*'
  prefs: []
  type: TYPE_NORMAL
- en: ([https://medium.com/swlh/stop-you-dont-need-microservices-dc732d70b3e0](https://medium.com/swlh/stop-you-dont-need-microservices-dc732d70b3e0)).
  prefs: []
  type: TYPE_NORMAL
- en: The cost mentioned in the link includes computational resources and manpower,
    including potential changes the organization processes will go through, and potential
    new software solutions such as containers and container orchestrators.
  prefs: []
  type: TYPE_NORMAL
- en: Different from its counterpart, the monolith, in a microservices architecture,
    the smaller its code size, the higher the *cost per line of code*, as everything
    and everyone involved in the service’s existence is still required. Sadly, a successfully
    delivered microservice is only one part of what’s needed to solve the actual business
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Not taking the best out of independent microservices scaling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Scalability is one of the key advantages of microservices. However, it’s important
    to consider whether it makes sense to scale a component individually. In some
    cases, it may be more effective to scale the entire system together. Think about
    it: would it make sense to exclusively scale up unique, smaller parts of the broader
    solution?'
  prefs: []
  type: TYPE_NORMAL
- en: Inconsistent data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microservices rely on data, and just as with any other distributed database,
    they’re subject to the CAP theorem. This means that whenever you have to update
    multiple services, you will end up with an added layer of complexity in your application.
  prefs: []
  type: TYPE_NORMAL
- en: One way to work through this is to adopt the SAGA pattern. However, this additional
    layer of complexity can often have a negative impact on the overall consistency
    of your data as well.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with microservices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s generally a bad idea to assume your project will be based on microservices.
    This can lead to big problems down the road, especially when it comes to domain
    definition. Small mistakes can result in several incorrect interdependencies between
    services and tight coupling. This is why many experts recommend using joins when
    handling relational data or subdocuments when working with a NoSQL database such
    as MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: While joins are a powerful feature in relational databases that allow us to
    combine data from different tables using foreign keys, they can be inefficient
    and time-consuming in NoSQL databases, especially for large datasets. This is
    because joins require multiple queries to be executed and can result in significant
    network traffic and resource consumption.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, NoSQL databases are optimized for query performance based on the
    access patterns and usage of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is generally recommended to model the data to minimize the need
    for joins and use denormalization and embedding techniques to combine related
    data into a single document.
  prefs: []
  type: TYPE_NORMAL
- en: However, there may be some cases where joins are necessary for NoSQL databases.
    In those cases, NoSQL databases offer different ways to perform joins, such as
    using `$lookup` in MongoDB or MapReduce, designed to work more efficiently with
    the NoSQL data model.
  prefs: []
  type: TYPE_NORMAL
- en: Tip – references for common mistakes when adopting microservices
  prefs: []
  type: TYPE_NORMAL
- en: There’s no need to feel discouraged by the challenges presented here; when the
    architecture is used correctly and in favorable scenarios, it fits perfectly.
    The point is, *there is no Holy Grail or* *silver bullet*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to keep on learning about common mistakes when adopting microservices,
    refer to the following reading recommendations: Ebin John’s *Stop, you don’t need
    microservices* ([https://medium.com/swlh/stop-you-dont-need-microservices-dc732d70b3e0](https://medium.com/swlh/stop-you-dont-need-microservices-dc732d70b3e0))
    and *Should I use Microservices? by Sam* *Newman* ([https://www.oreilly.com/content/should-i-use-microservices/](https://www.oreilly.com/content/should-i-use-microservices/)).'
  prefs: []
  type: TYPE_NORMAL
- en: We have so far outlined the concepts of monolithic and microservices architecture,
    explored the three main cloud delivery models, IaaS, PaaS, and SaaS, and learned
    that they can be combined to best fit an organization’s needs.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s expand on cloud deployment models and how having multiple cloud
    deployment options can help teams to shorten development cycles, fill knowledge
    gaps, and allow teams to apply their knowledge and effort more productively.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud deployment strategies that favor modern stateful solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A cloud deployment model allows applications to rely on an infrastructure that
    has on-demand usage, elasticity, resiliency, measured access, and other fundamental
    aspects. Let’s have a look at deployment model strategies, such as public and
    private clouds, how to derive two combinations of them through the hybrid and
    multi-cloud models, and how best to leverage the available cloud deployment strategies
    to deliver stateful applications efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Why the hybrid and multi-cloud models matter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the search for better flexibility, access to vendor-specific capabilities,
    integration options, and cost reduction, combinations of cloud deployment models
    have started to be used more frequently. Organizations have started to combine
    public and private deployment models and benefit from both private cloud with
    public cloud services, with a **hybrid cloud** model. Another strategy used is
    the **multi-cloud** model, which isused when there’s a need to run or consume
    the same service type from different vendors.
  prefs: []
  type: TYPE_NORMAL
- en: When you combine both public and private clouds and leverage similar cloud services
    from multiple vendors, you are then working with a **hybrid multi-cloud** **deployment
    model**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that the best deployment model isn’t the one with the highest number of
    words in its name – the best model is the one that solves your organization’s
    existing problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'What with the amount of different technologies and solutions out there, it
    is natural that teams won’t be able to build expertise in every single technology.
    The fact that it is hard to build a suitably diverse team – in terms of expertise
    – results in one of two possibilities: a poorly managed and maintained underlying
    persistence infrastructure or a restricted set of options to be used by developers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since data management is such a business-critical component, it shouldn’t be
    overlooked. That is where we can relate to our cloud story: *would it be possible
    for our business to delegate the management of data storage responsibility to
    someone else?* At this point, we understand that hybrid and multi-cloud models
    can provide the easy scaling up and down of several types of cloud computing resources.
    *If only we had a database with* *such capabilities…*'
  prefs: []
  type: TYPE_NORMAL
- en: It turns out we do have one – it is called **Database as a** **Service** (**DBaaS**).
  prefs: []
  type: TYPE_NORMAL
- en: Besides being able to get everything up and running quickly, using DBaaS, it
    is possible to delegate complex tasks such as monitoring, version maintenance,
    security patches maintenance, disaster recovery, and backup. Beyond that, it makes
    it possible to adopt data storage technologies for which there are no specialized
    professionals in the team yet, facilitating the freedom of choice to pick the
    best solution for each scenario. However, if there’s a need to directly access
    the servers that are running the databases or have full control over sensitive
    data being transferred and stored, DBaaS is not a viable solution. Examples of
    DBaaS offerings available in the market today are Amazon RDS, AWS Aurora MySQL,
    Microsoft Azure SQL Database, ScyllaDB, and MongoDB Atlas.
  prefs: []
  type: TYPE_NORMAL
- en: 'And this is where you get the best of both worlds when architecting solutions:
    by using decoupled and independent services, you can rely on public cloud services
    such as DBaaS offerings where they fit, exclusively for the particular services
    in need, and rely on on-premises data storage solutions for the services that
    can’t deal with the disadvantages of a public cloud offering.'
  prefs: []
  type: TYPE_NORMAL
- en: With distributed services across these different deployment models, services
    integration is a critical architectural aspect to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed systems and their impact on data systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Microservices are small pieces of a big puzzle: each piece can only serve its
    true value once the whole puzzle is put together. The qualities of reliability,
    resiliency, and scalability should not be catered to at each individual service
    level, but actually, for the proposed integration solution; after all, we agree
    with Martin Fowler’s idea that integration should be treated as strategic to businesses.'
  prefs: []
  type: TYPE_NORMAL
- en: '*“A microservice-based solution’s performance is only as good as the ability
    of its individual components to* *communicate efficiently.”*'
  prefs: []
  type: TYPE_NORMAL
- en: Example – architecting a food delivery solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In distributed architectures, handling data integration across services can
    be difficult. Therefore, we are about to explore architectural concepts and mistakes
    around integration through a simple example – a microservice-based solution for
    a food delivery website. Narrowing down the scope, the discussion takes into consideration
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The microservices backend layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The microservices data storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cross-services integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s look at how the solution is initially drafted as a microservice
    architecture, and how the integration of these services can highly affect data
    management and consistency across services.
  prefs: []
  type: TYPE_NORMAL
- en: The basic scenario
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the early development phases, it may look like a non-problematic scenario.
    For the food delivery example, picture a solution, represented in *Figure 3**.4*,
    composed of four microservices, each backed by its persistence and data storage
    strategy: **Order Service**, **Payment Service**, **Kitchen Service**, and **Delivery
    Service**. The figure represents the microservices, each with its own persistent
    storage.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Food delivery service’s representation](img/Figure_3.04_B19375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Food delivery service’s representation
  prefs: []
  type: TYPE_NORMAL
- en: 'The happy path of this sample is this: whenever a customer creates and pays
    for a new *order*, the kitchen cooks it and sends it over to the delivery team,
    which in turn delivers the order to the customer. *Figure 3**.5* demonstrates
    the new-order process from creation to delivery, where the business flow is processed
    across the four independent microservices.'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.5 – Food delivery business’s requirement\uFEFFs](img/Figure_3.05_B19375.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Food delivery business’s requirements
  prefs: []
  type: TYPE_NORMAL
- en: 'From a technical standpoint, this business requirement can be described as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Order Service**: Registers a new order 0001'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Payment Service**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Registers the required payment for order 0001
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Registers a successful payment of order 0001
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Kitchen Service**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notifies incoming order 0001
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Registers that order 0001 is being prepared
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Registers that order 0001 is ready for delivery
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Delivery Service**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notifies that order 0001 is ready to go to its customer
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Registers delivery of 0001 as completed
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To grasp the nuances of this seemingly straightforward business requirement,
    we must go into the technicalities and explore the various obstacles and potential
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Could this solution be a monolith? Yes, it could. However, delivery services,
    especially those that are spread across multiple customers/order providers/delivery
    providers, are built on an extensive list of business needs not covered in a simple
    example used for learning purposes. The architectural solutions for and business
    needs of real-world delivery services such as Uber Eats and DoorDash are good
    examples of complex, real-world scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: This solution’s microservice has an independent database, which not only aligns
    with the microservice’s ideas but also brings a good level of encapsulation and
    reduces the number of errors caused by changes (e.g., schema changes).
  prefs: []
  type: TYPE_NORMAL
- en: The challenges of integrating services around a central piece of data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though all four services are designed to be *independent*, they all function
    around one key feature: the *order*. And a problem regarding this data appears:
    *how do you manage and handle order data across the* *four services*?'
  prefs: []
  type: TYPE_NORMAL
- en: Microservices’ shared database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some could leverage data storage as the integration layer for these services,
    having a single schema holding not only the order details but also the payment,
    kitchen, and delivery information as well. Unfortunately, this is an inadvisable
    solution known as shared databases (a.k.a. integration databases). *Figure 3**.6*.
    shows that in this case, all services rely on a single schema to maintain an order’s
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.6 – Shared database ant\uFEFFi-pattern](img/Figure_3.06_B19375.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Shared database anti-pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, a service implementation may look simple since it
    doesn’t have to handle integration aspects. However, multiple problems were added
    to the solution, and design principles were broken:'
  prefs: []
  type: TYPE_NORMAL
- en: Microservices should be decoupled and independent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bottlenecks and performance impacts, as well as unexpected exceptions such as
    lock exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Involvement of multiple business areas since bounded contexts are not respected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes to the database may require changes to all services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple services acting on the same data might lead to inconsistency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher risk of bugs and errors. For instance, a change made to one service that
    is not expected by all other services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering the aforementioned problems and many more, it becomes easy to see
    that this is not a good route.
  prefs: []
  type: TYPE_NORMAL
- en: Dual-write anti-pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Trying to avoid the aforementioned problems, we might consider having independent
    services, each with its respective database. However, in this solution, services
    do not maintain a copy of the order on their databases, but they should also update
    the order status both in their databases and in the order service’s database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 3**.6*, observe that the order service is independent and maintains
    order data in its data storage. However, other services rely on replicating order
    data in their own databases and maintaining an order’s status in both databases
    – their own and the order service’s:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.7 – Dual-write anti-pattern\uFEFF](img/Figure_3.07_B19375.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Dual-write anti-pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'And this, dear reader, is yet another anti-pattern: the *dual-write* anti-pattern.
    It brings high chances of ending up with inconsistent data and integrity issues,
    as it is not possible to ensure that both writes will complete successfully or
    none at all, as in a single transaction. It’s a common mistake in scenarios such
    as handling distributed data systems, using exclusive data storage for analytics,
    implementing dedicated search index tools, and designing event-driven solutions
    (e.g., writing the same data to a database and Kafka).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right upfront, we’ve highlighted two red flags for distributed architecture
    regarding data access and management:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is that a service should not directly change any data owned and consumed
    by another service, as represented by the arrows in *Figure 3**.7*, where all
    services are modifying data in the order service’s database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is that one service should *not* be responsible for, or act upon,
    the manipulation and maintenance of data persistence and consistency across multiple
    data storage solutions, including not only cross-services as shown in *Figure
    3**.5* but also between different data storage types as exemplified in *Figure
    3**.6*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both anti-patterns, as well as use cases and potential solutions and strategies
    for data integration, are explored in great depth in [*Chapter 10*](B19375_10.xhtml#_idTextAnchor175)
    and [*Chapter 11*](B19375_11.xhtml#_idTextAnchor184). For now, it is enough to
    have the awareness that *there are anti-patterns in distributed data service integration*
    that can result in performance bottlenecks, data inconsistency, and reliability
    loss.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can better comprehend why integration shows itself as a crucial
    architectural aspect for delivering modern microservices-based solutions. Next,
    let’s take a look at another way to integrate distributed services by relying
    on event-driven architecture for asynchronous data integration.
  prefs: []
  type: TYPE_NORMAL
- en: Unveiling change data capture for data integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Services integration can be synchronous or asynchronous and can use different
    mechanisms and take different forms, such as file-based, shared database, message-based,
    API-based (e.g., REST, SOAP), event-driven, and many more. For the purposes of
    this book, we will consider aspects of **Event-Driven Architecture** (**EDA**),
    as it enables the usage of data integration patterns such as **change** **data
    capture**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technologies around event-driven patterns were created to allow databases –
    even traditional ones – to have a new capability: emit events. You read that correctly;
    it is possible for traditional relational databases (and other databases as well)
    to go beyond the basics and allow developers to rely on Change Data Capture.'
  prefs: []
  type: TYPE_NORMAL
- en: With Change Data Capture, database operations can be captured and emitted as
    events by a component external to the database and microservices of the solution.
    With this, developers are able to create event-driven services that can then react
    and respond to the aforementioned data events, or “notifications.”
  prefs: []
  type: TYPE_NORMAL
- en: As you might have expected, EDA is not all sunshine and roses. Understanding
    what’s happening throughout a single business flow can be quite overwhelming in
    this architectural style when multiple services and a high number of events are
    involved. Troubleshooting can also be extremely complex since the tracking process
    isn’t linear and does not happen in unique transactions. When working with EDA,
    forget about automatic rollbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Even though each of the mentioned challenges can be addressed or mitigated,
    notice these are only some of the items in a list of potential drawbacks for EDA;
    therefore, don’t forget to do your evaluations for the scenario in question, and
    validate whether EDA is the best solution for it or not.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the integration benefits offered by EDA is crucial to integrating your
    services without breaking patterns, best practices, and recommendations, and is
    critical to ensuring that you reap the benefits of asynchronous, highly scalable
    integration.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have examined the influence of cloud technology on software
    architecture design and the importance of design patterns as building blocks for
    software architects. We compared monolithic and microservices architectures, shedding
    light on their advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored cloud deployment strategies such as hybrid and multi-cloud
    models, and how these strategies, combined with managed services such as DbaaS,
    can speed up the development and delivery of stateful solutions. On the other
    hand, we also discovered that how we integrate data in distributed systems can
    impact data management and usage directly. When integrating distributed stateful
    service, we now know we must be cautious about using anti-patterns such as shared
    databases and “dual-writes”.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we unveiled the potential of Change Data Capture
    for data integration in EDA, which increases architectural complexity (more components
    and technologies) in exchange for a completely decoupled and asynchronous integration.
  prefs: []
  type: TYPE_NORMAL
- en: After discussing architectural and deployment model choices, we will next dive
    deeper into leveraging design patterns for data management in cloud-native applications,
    building upon the foundations laid in this chapter.
  prefs: []
  type: TYPE_NORMAL
