<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Type Inference</h1>
                </header>
            
            <article>
                
<p>The ability to use type inference with local variables (<kbd>var</kbd>) is one of the star features of Java 10. It reduces the verbosity of the language without compromising Java's dependable static binding and type safety. The compiler infers the type by using the information available in the code, and adds it to the bytecode that it generates.</p>
<p>Every new concept has its own set of benefits, limitations, and complexities. Using type inference with <kbd>var</kbd> is no exception. As you work through this chapter, using <kbd>var</kbd> will enthrall and frustrate you, but you will emerge triumphantly.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>What is type inference?</li>
<li>Type inference with <kbd>var</kbd></li>
<li>Dos and don'ts of working with <kbd>var</kbd></li>
<li>Type inference versus dynamic binding</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is type inference?</h1>
                </header>
            
            <article>
                
<p>Imagine solving a riddle, such as the one shown in the following image, with multiple constraints in the form of hints. You resolve the constraints to derive the answer. You can compare type inference to generating constraints and then resolving them, in order to determine the data types in a programming language. Type inference is the capability of the compiler to determine the type of the data, by using the information that is already available in the code—literal values, method invocations, and their declarations. For a developer, type inference reduces verbosity, as indicated by the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4af82659-f9ce-473f-8cbe-c161f66fc7c3.png" style="width:26.08em;height:13.83em;"/></p>
<p>For your reference, the answer to the preceding riddle is 87 (just turn the image upside down, and you'll find the numbers in a sequence).</p>
<div class="packt_infobox">Type inference is not new to Java. It has been taken to the next level with the introduction of <kbd>var</kbd> (with local variables) in Java 10.</div>
<p>Let's dive into the topic by looking at some examples of <kbd>var</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type inference with var</h1>
                </header>
            
            <article>
                
<p>The following lines of code show how local variables (and all other variables) were defined prior to Java 10:</p>
<pre>String name = "Java Everywhere"; 
LocalDateTime dateTime = new LocalDateTime.now();</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Starting with Java 10, by using <kbd>var</kbd>, you can drop the mandatory explicit type in the declaration of local variables, as follows:</p>
<pre>var name = "Java Everywhere";            // variable 'name' inferred as <br/>                                         // String 
var dateTime = new LocalDateTime.now();  // var 'dateTime' inferred as <br/>                                         // LocalDateTime </pre>
<p>Does it look like the preceding code doesn't offer a lot of benefits? Imagine you could take the following code:</p>
<pre>HashMap&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(); </pre>
<p>And replace it with this code, instead:</p>
<pre>var map = new HashMap&lt;Integer, String&gt;();  </pre>
<p>By replacing <kbd>HashMap&lt;Integer, String&gt;</kbd> with <kbd>var</kbd>, the preceding line of code is much shorter.</p>
<p>When you move away from explicitly stating the data type of the variables, the compiler takes over to determine, or infer, the variable type. Type inference is the compiler's ability to evaluate the information that is already present in the code, like the literal values, operations, and method invocations or their declarations, to determine the variable type. It follows a set of rules to infer the variable type. As a developer, when you choose type inference with <kbd>var</kbd>, you should be aware of the compiler's inference algorithm, so that you don't get unexpected results.</p>
<p>With every new feature, you should adhere to a few rules and restrictions and try to follow the best practices to benefit from that feature. Let's start with the compulsory initialization of the variables that are defined using <kbd>var</kbd>.</p>
<div class="packt_infobox">Type inference with <kbd>var</kbd> is not dynamic typing; Java is still a strong, static-typed language. The usage of <kbd>var</kbd> makes your code leaner; you can drop the type of the local variable from its definition.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compulsory non-null initialization</h1>
                </header>
            
            <article>
                
<p>A local variable defined with <kbd>var</kbd> must be initialized with its declaration, or the code won't compile. The compiler can't infer the type of an uninitialized variable or a variable that is assigned a <kbd>null</kbd> value. The following code won't compile:</p>
<pre>var minAge;                   // uninitialized variable 
var age = null;               // variable assigned a null value  </pre>
<p>The following image illustrates what would happen if the uninitialized variable <kbd>age</kbd> went to seek entrance to the Mr. Java compiler place. The compiler won't let <kbd>age</kbd> in:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0c52345b-2379-4400-8a0a-a2aea3e251bb.png" style="width:31.67em;height:18.58em;"/></p>
<div class="packt_infobox">Variable definition using <kbd>var</kbd> must always be accompanied by its initialization, or the code will fail to compile.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Local variables</h1>
                </header>
            
            <article>
                
<p>The usage of <kbd>var</kbd> is limited to local variables. These variables are used to store intermediate values and have the shortest life span, as compared to the instance and static variables. The local variables are defined within a method, constructor, or initializer block (both instance and static). Within a method or initializer, they can be defined within constructs, such as <kbd>if..else</kbd> loops, <kbd>switch</kbd> statements, and the <kbd>try-with-resources</kbd> construct.</p>
<p class="mce-root"/>
<p>The following is an example of  <kbd>Person</kbd> <span>class</span>, showing possible usage of <kbd>var</kbd> to define local variables in initializer blocks, methods (including constructors), loops, as a local variable within <kbd>switch</kbd> branches, or a <kbd>try with resources</kbd> statement:</p>
<pre>public class Person { 
    { 
        var name = "Aqua Blue";         // instance initializer block 
    } 
 
    static { 
        var anotherLocalVar = 19876;    // static initializer block 
    } 
 
    Person() { 
        var ctr = 10;                   // constructor 
        for (var loopCtr = 0; loopCtr &lt; 10; ++loopCtr) {   // loop -                                                            <br/>                                                           // for
            switch(loopCtr) { 
                case 7 :{ 
                    var probability = ctr / loopCtr;       // switch 
                    System.out.println(probability); 
                    break; 
                } 
            } 
        } 
    } 
 
    public String readFile() throws IOException { 
        var filePath = "data.txt"; <br/>        // try with resources<br/>        try (var reader = new BufferedReader(new FileReader(filePath))) {    
            return reader.readLine(); 
        } 
    } 
}  </pre>
<p>As you can notice from the preceding code, a local variable can be declared using <kbd>var</kbd> at varied places in a class. Do you remember most of them? If not, let's make it simple for you.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Let's use an application to <em>find</em> all possible places where you could define local variables using <kbd>var</kbd> and mark it pictorially:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6a261681-49a1-4214-8854-6f01e24711bd.png" style="width:20.75em;height:26.58em;"/></p>
<div class="packt_infobox">This chapter includes a couple of code-check exercises for you to try. The exercises use the names of two hypothetical programmers—Pavni and Aarav.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code check – part 1</h1>
                </header>
            
            <article>
                
<p>One of our programmers, Aarav, refactored some code by his team member, Pavni. The code no longer provides <kbd>char</kbd> and the corresponding ASCII numbers of the values stored by the <kbd>char</kbd> array. Can you help Aarav? The following is the code to use:</p>
<pre>class Foo {   
    public static void main(String args[]) {   
        try {   
           char[] name = new char[]{'S','t','r','i','n','g'};   
           for (var c : name) {   
               System.out.println(c + ":"   + (c + 1 - 1));   
           }   
        }   
        catch (var e) {   
            //code   
        }   
    }   
}   </pre>
<p>The answer to the code check: The <kbd>var</kbd> type can't be used to specify the types of exceptions in the <kbd>catch</kbd> handler, <kbd>(var e)</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using var with primitive data types</h1>
                </header>
            
            <article>
                
<p>Using <kbd>var</kbd> with primitive data types seems to be the simplest scenario, but appearances can be deceptive. Try to execute the following code:</p>
<pre>var counter = 9_009_998_992_887;       // code doesn't compile </pre>
<p>You might assume that an integer literal value (<kbd>9_009_998_992_887</kbd>, in this case) that doesn't fit into the range of primitive <kbd>int</kbd> types will be inferred to be a <kbd>long</kbd> type. However, this doesn't happen. Since the default type of an integer literal value is <kbd>int</kbd>, you'll have to append the preceding value with the suffix <kbd>L</kbd> or <kbd>l</kbd>, as follows:</p>
<pre>var counter = 9_009_998_992_887L;       // code compiles </pre>
<p>Similarly, for an <kbd>int</kbd> literal value to be inferred as a <kbd>char</kbd> type, you must use an explicit cast, as follows:</p>
<pre>var aChar = (char)91; </pre>
<p>What is the result when you divide <kbd>5</kbd> by <kbd>2</kbd>? Did you think it's <kbd>2.5</kbd>? This isn't how it (always) works in Java! When integer values are used as operands in the division, the result is not a decimal number, but an integer value. The fraction part is dropped, to get the result as an integer. Though this is normal, it might seem weird when you expect the compiler to infer the type of your variable. The following is an example of this:</p>
<pre>// type of result inferred as int; 'result' stores 2 <br/>var divResult = 5/2; <br/><br/>// result of (5/2), that is 2 casted to a double; divResult stores 2.0 <br/>var divResult = (double)(5/ 2); <br/><br/>// operation of a double and int results in a double; divResult stores <br/>// 2.5 <br/>var divResult = (double)5/ 2;</pre>
<p class="mce-root"/>
<p>Though these cases aren't specifically related to the <kbd>var</kbd> type, the developer's assumption that the compiler will infer a specific type results in a mismatch. Here's a quick diagram to help you remember this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/047f3487-368c-4b58-8308-b0a3e7637726.png" style="width:29.00em;height:19.33em;"/></p>
<div class="packt_infobox">The default type of integer literals is <kbd>int</kbd>, and the default type of floating point numbers is <kbd>double</kbd>. Assigning <kbd>100</kbd> to a variable defined with <kbd>var</kbd> will infer its type as <kbd>int</kbd>, not <kbd>byte</kbd> or <kbd>short</kbd>.</div>
<p>In arithmetic operation, if either of the operands is <kbd>char</kbd>, <kbd>byte</kbd>, <kbd>short</kbd>, or <kbd>int</kbd>, the result is at least promoted to <kbd>int</kbd>:</p>
<pre>byte b1 = 10; 
char c1 = 9; 
var sum = b1 + c1;        // inferred type of sum is int  </pre>
<p>Similarly, for an arithmetic operation that includes at least one operand as a <kbd>long</kbd>, <kbd>float</kbd>, or <kbd>double</kbd> value, the result is promoted to the type <kbd>long</kbd>, <kbd>float</kbd>, or <kbd>double</kbd>, respectively:</p>
<pre>byte cupsOfCoffee = 10; 
long population = 10L; 
float weight = 79.8f; 
double distance = 198654.77; 
 
var total1 = cupsOfCoffee + population;     // inferred type of total1 <br/>                                           // is long 
var total2 = distance + population;        // inferred type of total2 <br/>                                           // is double 
var total3 = weight + population;    // inferred type of total3 is <br/>                                          // float  </pre>
<div class="packt_infobox">The rules of the implicit widening of primitive variables play an important role in understanding how the Java compiler infers variables with primitive values.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type inference with derived classes</h1>
                </header>
            
            <article>
                
<p>In JDK 9 and other previous versions, you could define a variable of the base class and assign an instance of its derived class to it. The members that you could access using the variable were limited to the ones that were defined in the base class. This is no longer the case with <kbd>var</kbd>, since the type of the variable is inferred by using the specific type of the instance that is assigned to it.</p>
<p>Imagine a class  <span><kbd>Child</kbd> </span>extends<span> a class <kbd>Parent</kbd></span>. When you create a local variable and assign it an instance of the <kbd>Child</kbd> class, the type of the variable is inferred as <kbd>Child</kbd>. This looks simple. The following is an example:</p>
<pre>class Parent { 
    void whistle() { 
        System.out.println("Parent-Whistle"); 
    } 
} 
class Child extends Parent { 
    void whistle() { 
        System.out.println("Child-Whistle"); 
    } 
    void stand() { 
        System.out.println("Child-stand"); 
    } 
} 
class Test{ 
    public static void main(String[] args) { 
        var obj = new Child();                             
        obj.whistle(); 
        obj.stand();     // type of obj inferred as Child 
    } 
}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>What happens if you assign the value of the <kbd>obj</kbd> variable using a method that can return an instance of the <kbd>Child</kbd> class or <kbd>Parent</kbd> classes? Here's the modified code:</p>
<pre>class Parent { 
    void whistle() { 
        System.out.println("Parent-Whistle"); 
    } 
} 
 
class Child extends Parent { 
    void whistle() { 
        System.out.println("Child-Whistle"); 
    } 
    void stand() { 
        System.out.println("Child-stand"); 
    } 
} 
 
class Test{ 
    public static Parent getObject(String type) { 
        if (type.equals("Parent")) 
            return new Parent(); 
        else 
            return new Child(); 
    } 
 
    public static void main(String[] args) { 
        var obj = getObject("Child"); 
        obj.whistle(); 
        obj.stand();              // This line doesn't compile 
    } 
} </pre>
<p>In the preceding code, the type of the instance returned by the <kbd>getObject()</kbd> method can't be determined before the code execution. During compilation, the type of the <kbd>obj</kbd> variable is inferred as <kbd>Parent</kbd>, the return type of the <kbd>getObject()</kbd> <span>method.</span> Since the <kbd>Parent</kbd> <span>class </span>doesn't define <kbd>stand()</kbd>, the <kbd>main()</kbd> <span>methods</span> fail to compile.</p>
<div class="packt_infobox">The types of variables defined using <kbd>var</kbd> are inferred at compile time. If the return type of a method is used to assign a variable that is defined using <kbd>var</kbd>, its inferred type is the return type of the method, not the type of the instance returned during runtime.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type inference with interfaces</h1>
                </header>
            
            <article>
                
<p>Let's extend the content of the preceding section to the use of interfaces. Imagine that the <kbd>Child</kbd> <span>class</span> implements a <kbd>MarathonRunner</kbd> <span>interface, as follows:</span></p>
<pre>interface MarathonRunner{ 
    default void run() { 
        System.out.println("I'm a marathon runner"); 
    } 
} 
 
class Child implements MarathonRunner { 
    void whistle() { 
        System.out.println("Child-Whistle"); 
    } 
    void stand() { 
        System.out.println("Child-stand"); 
    } 
}  </pre>
<p>Let's define an <kbd>obj</kbd> <span>local variable, </span>assigning it an instance of the <kbd>Child</kbd> class:</p>
<pre>class Test{ 
    public static void main(String[] args) { 
        var obj = new Child();              // inferred type of var obj <br/>                                            // is Child 
        obj.whistle(); 
        obj.stand();                     
        obj.run(); 
    } 
}  </pre>
<p>If the same variable is initialized using a method whose return type is <kbd>MarathonRunner</kbd>, its inferred type is <kbd>MarathonRunner</kbd> (irrespective of the type of the instance returned by it):</p>
<pre>class Test{ 
    public static MarathonRunner getObject() { 
        return new Child(); 
    } 
    public static void main(String[] args) { 
        var obj = getObject();     // inferred type of var obj is <br/>                                   // MarathonRunner 
        obj.whistle(); 
        obj.stand(); 
        obj.run(); 
    } 
}</pre>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using var with arrays</h1>
                </header>
            
            <article>
                
<p>Using <kbd>var</kbd> doesn't imply just dropping the type of the local variable; what remains should enable the compiler to infer its type. Imagine a method that defines an array of the <kbd>char</kbd> type, as follows:</p>
<pre>char name[] = {'S','t','r','i','n','g'};</pre>
<p>You can't replace the data type name, that is, <kbd>char</kbd>, in the preceding code with <kbd>var</kbd> and define it using any of the following code samples:</p>
<pre>var name[] = {'S','t','r','i','n','g'};
var[] name = {'S','t','r','i','n','g'};
var name = {'S','t','r','i','n','g'};</pre>
<p>Here's one of the ways to include relevant information, so that the compiler can infer the type:</p>
<pre>var name = new char[]{'S','t','r','i','n','g'};</pre>
<p>It seems like the Java compiler is already struggling with this assumption from the programmers, as shown in the following image:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c93bfaae-5ff6-45cf-b181-b12079a8a95e.png" style="width:34.17em;height:16.42em;"/></p>
<p>You can't just drop the data types in order to use <kbd>var</kbd>. What remains should enable the compiler to infer the type of the value being assigned.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type inference with generics</h1>
                </header>
            
            <article>
                
<p>Generics were introduced in Java to promote type safety. It enabled developers to specify their intentions of using classes, interfaces, and collection classes with fixed types or a range of types. Violations of these intentions were enforced with compilation errors, rather than runtime exceptions, raising the compliance bar.</p>
<p>For example, the following shows how you would define <kbd>ArrayList</kbd> to store <kbd>String</kbd> values (repeating <kbd>&lt;String&gt;</kbd> is optional, on the right-hand side of the assignment):</p>
<pre>List&lt;String&gt; names = new ArrayList&lt;&gt;();  </pre>
<p>However, replacing <kbd>List&lt;String&gt;</kbd> with <kbd>var</kbd> will put the type safety of the generics at stake:</p>
<pre>var names = new ArrayList&lt;&gt;(); 
names.add(1); 
names.add("Mala"); 
names.add(10.9); 
names.add(true); </pre>
<p>The preceding code allows for the addition of multiple data types to <kbd>names</kbd>, which is not the intention. With generics, the preferred approach is to make relevant information available to the compiler, so that it can infer its type correctly:</p>
<pre>var names = new ArrayList&lt;String&gt;(); </pre>
<div class="packt_tip">When using <kbd>var</kbd> with generics, ensure that you pass the relevant data types within the angular brackets on the right-hand side of the assignment, so that you don't lose type safety.</div>
<p>Now, it's time for our next code check.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code check – part 2</h1>
                </header>
            
            <article>
                
<p>One of our programmers, Pavni, tried using <kbd>var</kbd> with generics and collection classes, but her code doesn't seem to output the sorted collection of pens. Can you help? Check out the following code:</p>
<pre>class Pen implements Comparable&lt;Pen&gt; {   
    String name;   
    double price;   
    public Pen(String name, double price) {   
        this.name = name;   
        this.price = price;   
    }   
    public int compareTo(Pen pen) {   
        return ((int)(this.price - pen.price));   
    }   
    public String toString() {   
        return name;   
    }   
   
    public static void main(String   args[]) {   
        var pen1 = new Pen("Lateral",   219.9);   
        var pen2 = new Pen("Pinker",   19.9);   
        var pen3 = new Pen("Simplie",   159.9);   
   
        var penList = List.of(pen1, pen2,   pen3);   
   
        Collections.sort(penList);   
        for (var a : penList)    
            System.out.println(a);   
    }   
}   </pre>
<p>The answer to the code check: The issue here is trying to modify the immutable collection by using <kbd>Collections.sort()</kbd>. This is to emphasize that not all issues are related to the use of <kbd>var</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing inferred variables to a method</h1>
                </header>
            
            <article>
                
<p>Though the use of <kbd>var</kbd> is limited to the declaration of local variables, these variables (both primitive and reference) can be passed to methods as values. The inferred types and the types expected by the methods must match, to allow the code to compile.</p>
<p>In the following example code, the <kbd>Child</kbd> class implements the <kbd>MarathonRunner</kbd> <span>interface.</span> The <kbd>start()</kbd> <span>method</span> in the <kbd>Marathon</kbd> class expects the <kbd>MarathonRunner</kbd> object (the instances of the class implementing this interface) as its method argument. The inferred type of the <kbd>aRunner</kbd> <span>variable</span> is <kbd>Child</kbd>. Since the <kbd>Child</kbd> class implements <kbd>MarathonRunner</kbd>, <kbd>aRunner</kbd> can be passed to the <kbd>start()</kbd> <span>method,</span> the inferred type of <kbd>aRunner</kbd> (<kbd>Child</kbd>) and the expected type of <kbd>start()</kbd> (<kbd>MarathonRunner</kbd>) match, allowing the code to compile.</p>
<p>The code is as follows:</p>
<pre>interface MarathonRunner { 
    default void run() { 
        System.out.println("I'm a marathon runner"); 
    } 
} 
class Child implements MarathonRunner { 
    void whistle() { 
        System.out.println("Child-Whistle"); 
    } 
    void stand() { 
        System.out.println("Child-stand"); 
    } 
} 
class Marathon { 
    public static void main(String[] args) { 
        var aRunner = new Child();         // Inferred type is Child 
        start(aRunner);                    // ok to pass it to method start <br/>                                           // (param - MarathonRunner) 
    } 
    public static void start(MarathonRunner runner) { 
        runner.run(); 
    } 
}  </pre>
<div class="packt_infobox">As long as the inferred type of a variable matches the type of the method parameter, it can be passed to it as an argument.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reassigning values to inferred variables</h1>
                </header>
            
            <article>
                
<p>As is applicable to all non-final variables, you can reassign value to inferred variables. Just ensure that the reassigned value matches its inferred type. In the following code, since the type of the <kbd>age</kbd> <span>variable </span>is inferred as <kbd>int</kbd>, you can't assign a decimal value of <kbd>10.9</kbd> to it. Similarly, since the type of the <kbd>query</kbd> variable is inferred as <kbd>StringBuilder</kbd>. The type of a variable is inferred just once, as follows:</p>
<pre>var age = 9;     // type of variable age inferred as int 
age = 10.9;      // can't assign 10.9 to variable of type int 
 
var query = new StringBuilder("SELECT");         // Type of variable <br/>                                              // query is StringBuilder 
query = query.toString() + "FROM" + "TABLE";     // won't compile;  
                                                 // can't assign String                                                                                                 <br/>                                                // to variable query</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<div class="packt_infobox">The type of a local variable defined using <kbd>var</kbd> is inferred only once.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Explicit casting with inferred variables</h1>
                </header>
            
            <article>
                
<p><span>Imagine that a co-programmer assigned <kbd>29</kbd> to an inferred local variable (let's say <kbd>age</kbd>), assuming that the compiler would infer the type of the variable <kbd>age</kbd> as <kbd>byte</kbd>:</span></p>
<pre>var age = 29;           // inferred type of age is int </pre>
<p><span>However, the compiler would infer the type of the variable <kbd>age</kbd> as <kbd>int</kbd>, since the default type of an integer literal value is <kbd>int</kbd>. To fix the preceding assumption, y</span>ou can either use the explicit data type or override the compiler's default inference mechanism by using explicit casting, as follows:</p>
<pre>byte age = 29;                // Option 1 - no type inference <br/>var age = (byte)29;           // Option 2 - explicit casting </pre>
<div class="packt_tip">By using explicit casting type inference, you can override the compiler's default type inference mechanism. This might be required to fix the assumptions in the existing code. </div>
<p><span><span>Similarly,</span></span> you can use explicit casting with other primitive data types, like <kbd>char</kbd> and <kbd>float</kbd>:</p>
<pre>var letter = (char)97;        // inferred type of letter is char 
var debit = (float)17.9;      // inferred type of debit is float  </pre>
<p>Without the explicit casting in the preceding examples, variables that are assigned integer literal values would be inferred as <kbd>int</kbd>, and decimal as <kbd>double</kbd>.</p>
<p class="mce-root">The following example shows explicit casting with reference variables:</p>
<pre>class Automobile {} 
class Car extends Automobile { 
    void check() {} 
} 
class Test{ 
    public static void main(String[] args) { 
        var obj = (Automobile)new Car();                             
        obj.check();     // Won't compile; type of obj is Automobile 
    } 
} </pre>
<div class="packt_infobox">Use explicit casting with type inference to fix any existing assumptions. I wouldn't recommend using explicit casting to initialize inferred variables; it defeats the purpose of using <kbd>var</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Assigning null with explicit casting</h1>
                </header>
            
            <article>
                
<p>Again, although it doesn't make sense to use explicit casting with <kbd>null</kbd> to assign it to a <kbd>var</kbd> type, it is a valid code, shown as follows:</p>
<pre>var name = (String)null;             // Code compiles </pre>
<p>Though the preceding line of code is correct syntax-wise, it is a bad coding practice. Avoid it!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type inference in previous versions of Java</h1>
                </header>
            
            <article>
                
<p>Although <kbd>var</kbd> takes inference to a new level in Java 10, the concept of type inference existed in Java's previous versions. Let's look at some examples of type inference in the previous versions of Java.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type inference in Java 5</h1>
                </header>
            
            <article>
                
<p>Generics introduced a type system to enable the developers to abstract over types. It restricted a class, interface, or method to working with instances of specified types, providing compile type safety. Generics were defined to add compile type safety to the Collections framework. Generics enable programs to detect certain bugs during compilation, so they can't creep into the runtime code. </p>
<p>Java used type inference for generic method type arguments in Java 5. Consider the following code:</p>
<pre>List&lt;Integer&gt; myListOfIntegers = Collections.&lt;Integer&gt;emptyList(); // 1</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Instead of the preceding code, you could use the following code:</p>
<pre> List&lt;Integer&gt; myListOfIntegers = Collections.emptyList(); // 1 </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type inference in Java 7</h1>
                </header>
            
            <article>
                
<p>Java 7 introduced type inference for constructor arguments with generics. Consider the following line of code:</p>
<pre>List&lt;String&gt; myThings = new ArrayList&lt;String&gt;(); </pre>
<p>In Java 7, the preceding line of code could be replaced with the following:</p>
<pre>List&lt;String&gt; myThings = new ArrayList&lt;&gt;();  </pre>
<p>The preceding code shouldn't be confused with the following, which is trying to mix the generics with the raw types:</p>
<pre>List&lt;String&gt; myThings = new ArrayList();  </pre>
<p>Java 7 also allowed type inference to invoke generic methods. For a generic method (say, <kbd>print()</kbd>) defined in a class (say, <kbd>MyClass</kbd>), the code would be as follows:</p>
<pre>class MyClass&lt;T&gt; { 
   public &lt;X&gt; void print(X x) { 
         System.out.println(x.getClass()); 
   } 
}  </pre>
<p>The preceding code can be called in either of the following ways (the third line of code uses type inference to infer the type of the argument passed to the <kbd>print()</kbd><span> method):</span></p>
<pre>MyClass&lt;String&gt; myClass = new MyClass&lt;&gt;(); 
myClass.&lt;Boolean&gt;deliver(new Boolean("true"));     
myClass.deliver(new Boolean("true")); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type inference in Java 8</h1>
                </header>
            
            <article>
                
<p>Java, version 8, introduced functional programming, with lambda functions. The lambda expression can infer the type of its formal parameters. Consider the following code:</p>
<pre>Consumer&lt;String&gt; consumer = (String s) -&gt; System.out.println(s);</pre>
<p> </p>
<p>Instead of the preceding code, you could type the following code:</p>
<pre>Consumer&lt;String&gt; consumer = s -&gt; System.out.print(s);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Challenges</h1>
                </header>
            
            <article>
                
<p>The use of <kbd>var</kbd> doesn't come without its share of challenges, for both the developers of the Java language and its users. Let's start with the reasons why <kbd>var</kbd> has limited usage.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Limiting the scope of failed assumptions</h1>
                </header>
            
            <article>
                
<p>As you know, the use of <kbd>var</kbd> types is limited to local variables in Java. They are not allowed in the public API, as method parameters or as the return type of methods. Some languages support type inference for all types of variables. Java may allow us to do so in the future, but we don't know when.</p>
<p>However, there are strong reasons for limiting the scope of the inferred variables, to spot the errors due to mismatch of assumptions and the actual, early on. The contracts of the public APIs should be explicit. Type inference with public APIs would allow for these errors to be caught and corrected much later.</p>
<div class="packt_infobox">The contract of the public APIs should be explicit; they shouldn't depend on type inference.</div>
<p>The following is a practical example of how a mismatch between an assumption and the actual case can lead to errors.</p>
<p>Recently, my daughter was traveling overseas with her school for a student exchange program. The school asked me to send back a set of photographs for her visa application. I called a photographer, requesting that he print photos for the visa (and specifying the country). Two days later, the school asked me to resubmit the photos because they didn't match the rules.</p>
<p>What went wrong? Neither the school nor myself were explicit with the specifications of the photograph. The school assumed that I would know the specifications; I assumed that the photographer would know the specifications (because he had been doing it for years). In this case, at least one person assumed that the result conformed to a specific output, without explicitly specifying the output. Without an explicit contract, there is always the chance of mismatching the expectation with the actual case.</p>
<p>Despite the confusion, the mistake was spotted and corrected before the applications were submitted to the embassy.</p>
<p>The following is a fun image, included showing why the use of type inference is limited to local variables. The local instances and static variables are competing in a race, and only the local variables can make it to the finish line:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/309764b7-7013-437e-a81c-0bbdae2884b9.png" style="width:39.92em;height:35.50em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Breaking existing code</h1>
                </header>
            
            <article>
                
<p>As of Java 10, <kbd>var</kbd> is a restricted local variable type and cannot be used for type declarations. Code that uses <kbd>var</kbd> as the name of a class, interface, method, method parameters, or variables, will no longer compile in JDK 10 and later releases.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The following is an example of code that uses <kbd>var</kbd> at multiple places and won't compile:</p>
<pre>class var {}          // can't use var as class name<br/>interface var {}      // can't use var as interface name<br/>class Demo {<br/>    int var = 100;               // can't use var as instance variable <br/>                                 // name<br/>    static long var = 121;       // can't use var as static variable <br/>                                 // name<br/><br/>    void var() {                 // can't use var as method name<br/>        int var = 10;            // cant use var as the name of a local <br/>                                 // variable<br/>    }<br/>    void aMethod(String var) {}  // can't use var as the name of method parameter<br/>}</pre>
<div class="packt_tip">It is important to test your production code with the latest Java release versions, even if you are not planning to deploy your production code to them. It will help to iron out any compatibility issues with your production code, helping to migrate it to a future version of Java.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Non-denotable types</h1>
                </header>
            
            <article>
                
<p>Java types that you can use in a program, like <kbd>int</kbd>, <kbd>Byte</kbd>, <kbd>Comparable</kbd>, or <kbd>String</kbd>, are called <strong>denotable</strong> types. The types used by a compiler internally, like the subclass of an anonymous class, which you can't write in your program, are called <strong>non-denotable</strong> types.</p>
<p>Up until now, type inference with variables seemed quite easy to implement—just get the information about the values passed to a method and returned from a method, and infer the type. However, it isn't as simple as that when it comes to inference with non-denotable types—<kbd>null</kbd> types, intersection types, anonymous class types, and capture types.</p>
<p>For example, consider the following code and think about the type of the inferred variables:</p>
<pre>// inferred type java.util.ImmutableCollections$ListN 
var a = List.of(1, "2", new StringBuilder());<br/>var b = List.of(new ArrayList&lt;String&gt;(), LocalTime.now());</pre>
<p class="mce-root"/>
<p>Type of variable <kbd>a</kbd> and <kbd>b</kbd> isn't a type that you would have read before. But that doesn't stop them from being inferred. The compiler infers them to a non-denotable type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Meaningful variable names</h1>
                </header>
            
            <article>
                
<p>Type inference with <kbd>var</kbd> should be used responsibly. When you remove explicit data type from a variable declaration, the variable name takes the center stage. With inferred types, it is your responsibility to use descriptive and appropriate variable names, so that they make more sense in code. As you know, a piece of code is written once, but read many times.</p>
<p>For example, the following line of code won't make much sense to you or to your team members (especially with a big or distributed team) after a period of time:</p>
<pre>var i = getData();             // what does getData() return? Is 'i' a <br/>                              // good name? </pre>
<p>The key questions are—what is the variable <kbd>i</kbd> used for? What does the method <kbd>getData()</kbd> return? Imagine the plight of the other team members that will work with this code after you leave.</p>
<p>Also, it doesn't help to define variable names that are mismatched with their purposes. For example, it doesn't make much sense to create a connection object named <kbd>database</kbd> and assign a <kbd>URL</kbd> instance to it, or to define a variable with the name <kbd>query</kbd> and assign a <kbd>Connection</kbd> instance to it:</p>
<pre>var database = new URL("http://www.eJavaGuru.com/malagupta.html"); 
var query = con.getConnection(); </pre>
<div class="packt_infobox">When variables are defined using <kbd>var</kbd>, variable names become more important. Without a type, it can become difficult to understand the purpose of a variable, especially if its name is not expressive enough. Choose variable names carefully and responsibly, making their purpose clear.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code refactoring</h1>
                </header>
            
            <article>
                
<p>Type inference with <kbd>var</kbd> was introduced to reduce the verbosity of the Java language. It will help the programmers to be more concise in their methods. The compiler infers the type of the variables declared using <kbd>var</kbd> and inserts it in the bytecode. There is no need to refactor existing or legacy code, replacing explicit data types of local variables with <kbd>var</kbd>. </p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type inference versus dynamic binding</h1>
                </header>
            
            <article>
                
<p>The use of type inference with <kbd>var</kbd> isn't pushing Java towards the dynamic binding domain. Java is still a strongly-typed static language. The type inference in Java is syntactic sugar. The compiler infers the type and adds it to the bytecode. In dynamic binding, a variable type is inferred at runtime. This can lead to more errors being discovered later.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered local variable inference, or <kbd>var</kbd>, as introduced in Java 10. The <kbd>var</kbd> type enables you to drop the explicit data type for a local variable in a method. We covered the various dos and don'ts for the usage of <kbd>var</kbd>. Limited to local variables, variables defined using <kbd>var</kbd> must be initialized with a value. They can be used with all types of variables—primitives and objects. Variables defined with <kbd>var</kbd> can also be passed to methods and returned from methods; method declaration compatibility rules apply.</p>
<p>To avoid risking your type safety with generics, ensure that you pass relevant information when using <kbd>var</kbd> with generics. Although it doesn't make a lot of sense, the use of explicit casting is allowed with variables defined using <kbd>var</kbd>.</p>
<p>We also covered ways in which type inference existed in previous versions of Java (5, 7, and 8). Toward the end, we covered why type inference is limited to local variables and is not allowed in the public API.</p>
<p>The use of meaningful variable names has always been recommended, and it is important. With <kbd>var</kbd>, it becomes even more important. Since <kbd>var</kbd> offers syntactic sugar, it doesn't make any sense to refactor your existing or legacy code to add the use of <kbd>var</kbd>.</p>


            </article>

            
        </section>
    </body></html>