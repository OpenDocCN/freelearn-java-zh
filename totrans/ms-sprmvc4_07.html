<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Leaving Nothing to Luck &#x2013; Unit Tests and Acceptance Tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Leaving Nothing to Luck – Unit Tests and Acceptance Tests</h1></div></div></div><p>In this chapter, we will see why and how our application should be tested. We will see the differences between unit tests and acceptance tests, and learn how to do both.</p><p>This chapter is divided in two parts. In the first part, we will write tests in Java while studying the different ways of testing. In the second part, which is shorter, we will write the exact same tests in Groovy, and see how we can improve our code readability with this awesome language.</p><p>If you do everything in this chapter, you will have double tests, so feel free to keep only the tests that are most readable for you.</p><div class="section" title="Why should I test my code?"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec61"/>Why should I test my code?</h1></div></div></div><p>Working in the Java world has made a lot of developers aware of the importance of tests. A good series of tests can catch regressions early and allows us to be more confident when we ship our product.</p><p>A lot of people are now familiar with the notion of continuous integration (<a class="ulink" href="http://www.thoughtworks.com/continuous-integration">http://www.thoughtworks.com/continuous-integration</a>). This is a practice where a server is<a id="id396" class="indexterm"/> in charge of building the application every time a change is made on the source control system.</p><p>The build should be <a id="id397" class="indexterm"/>as fast as possible and capable of self testing. The main idea of this practice is to get a fast feedback loop; you should get details about what went wrong as soon as something in the system breaks.</p><p>Why should you care? After all, testing your application is an additional cost; the time spent designing and maintaining tests will necessarily eat into some development time.</p><p>Actually, the later a bug is found, the costlier it gets. If you think about it, even a bug found by your QA team begins to cost more than a bug you find on your own. It forces you to switch back to the context you were in when writing the code: why did I write this line? What was the underlying business rule of that function?</p><p>If you write tests early on and are able to launch them in a few seconds, it will certainly cost less time to address potential bugs in your code.</p><p>Another benefit <a id="id398" class="indexterm"/>of tests is that they act as a living documentation of your code. While writing extensive documentation, and even code comments, can prove ineffective because they easily become outdated, forming the habit of writing a good test for limit cases or surprising behaviors will act as a safety net for the future.</p><p>What is this line of code for? Have you ever found yourself asking this kind of question? Well, if you have a good set of unit tests, you can just remove it and see what breaks! Tests give us an unprecedented confidence in our code and in our ability to refactor it. Software is very fragile. If you stop caring, it will slowly rot and die.</p><p>Be responsible—don't let your code die!</p></div></div>
<div class="section" title="How should I test my code?"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec62"/>How should I test my code?</h1></div></div></div><p>There are different kinds of tests that we can perform on a piece of software, such as security tests, performances test, and so on. As developers, we will focus on the tests we can automate <a id="id399" class="indexterm"/>and<a id="id400" class="indexterm"/> that will help<a id="id401" class="indexterm"/> improve <a id="id402" class="indexterm"/>our code.</p><p>The tests fall under two categories: unit tests and acceptance tests. The test pyramid (<a class="ulink" href="http://martinfowler.com/bliki/TestPyramid.html">http://martinfowler.com/bliki/TestPyramid.html</a>) shows in what proportions these tests should be written:</p><div class="mediaobject"><img src="graphics/2117_07_01.jpg" alt="How should I test my code?"/></div><p>At the<a id="id403" class="indexterm"/> bottom of the pyramid, you have the unit tests (fast to launch and<a id="id404" class="indexterm"/> relatively easy to maintain), and at the top, UI tests (costlier and slower to execute). Integration tests sit in the middle: they can be<a id="id405" class="indexterm"/> viewed <a id="id406" class="indexterm"/>as big unit tests with complex interactions between units.</p><p>The idea of the pyramid is to remind you to put your focus where you have the most impact and get the best feedback loops.</p></div>
<div class="section" title="Test-driven development"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec63"/>Test-driven development</h1></div></div></div><p>Many developers develop the healthy habit of <span class="strong"><strong>Test-driven Development</strong></span> (<span class="strong"><strong>TTD</strong></span>). This practice, inherited<a id="id407" class="indexterm"/> from Extreme Programming (XP), is the process of splitting each development stage into small steps and then writing a failing test for every one of them. You make the necessary modifications so that the tests pass again (test are green). You can then refactor your code as long as the tests remain green. The following figure illustrates the TDD cycle:</p><div class="mediaobject"><img src="graphics/2117_07_02.jpg" alt="Test-driven development"/></div><p>You can iterate<a id="id408" class="indexterm"/> until the feature is done with very short feedback loops, with the insurance of no regressions, and the guarantee that all the code you write will be tested from the very beginning.</p><p>TDD gets its share of criticisms. The most interesting ones are these:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It takes more time to write the tests than to do the actual implementation</li><li class="listitem" style="list-style-type: disc">It can lead to poorly designed applications</li></ul></div><p>The truth of the matter is that it takes time to become a good TDD practitioner. Once you get the feeling of what should be tested and know your tools well enough, you won't lose much time at all.</p><p>It also takes experienced developers to craft an application with a proper design using TDD (or with any other methodology). Poor design can be a side effect of TDD if you get trapped in the baby steps mantra and forget to look at the big picture. It is true that TDD won't magically lead to great application design, so be careful and remember to take a step back after completing each feature.</p><p>From the beginning of the book, we have only had one autogenerated unit test in our code. This is bad! We didn't follow good practice. This chapter is here to address this problem.</p></div>
<div class="section" title="The unit tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec64"/>The unit tests</h1></div></div></div><p>The lower level tests we can write are called unit tests. They should test a small portion of code, hence<a id="id409" class="indexterm"/> the notion of unit. How you define a unit is up to you; it can be a class or a bunch of closely related classes. Defining this notion will determine what will be mocked (replaced with a dummy object). Are you going to replace the database with a lightweight alternative? Are you going to replace interactions with external services? Are you going to mock-up closely related objects whose behavior is not relevant to the context of what's being tested?</p><p>My advice here is to keep a balanced approach. Keep your tests clean and fast, and everything else will follow.</p><p>I rarely completely mock the data layer. I tend to use embedded databases for testing. They provide an easy way to load data while testing.</p><p>As a rule, I always mock collaboration with external services for two reasons, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The speed of the tests and the possibility to run the tests without connecting to the network</li><li class="listitem" style="list-style-type: disc">To be able to test error cases while communicating with those services</li></ul></div><p>Additionally, there is a subtle difference between mocking and stubbing. We will try to use both approaches to see how they relate to each other.</p><div class="section" title="The right tools for the job"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec53"/>The right tools for the job</h2></div></div></div><p>The first barrier for test novices is the lack of knowledge of the good tools and libraries for writing relevant <a id="id410" class="indexterm"/>and maintainable tests.</p><p>I'm going<a id="id411" class="indexterm"/> to list a few here. This list is by no means exhaustive, but it contains the tools we are going to use and that are easily compatible with Spring:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>JUnit</p>
</td><td style="text-align: left" valign="top">
<p>The<a id="id412" class="indexterm"/> most universally adopted Java test runner. Launched by default by all build tools.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>AssertJ</p>
</td><td style="text-align: left" valign="top">
<p>A fluent <a id="id413" class="indexterm"/>assertion library. It's way easier to use than Hamcrest.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Mockito</p>
</td><td style="text-align: left" valign="top">
<p>An easy <a id="id414" class="indexterm"/>mocking framework.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>DbUnit</p>
</td><td style="text-align: left" valign="top">
<a id="id415" class="indexterm"/>
<p>For mocking and asserting your database content with XML datasets.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Spock</p>
</td><td style="text-align: left" valign="top">
<p>An elegant<a id="id416" class="indexterm"/> Groovy DSL to write tests with Behaviour Driven Development (BDD) style (Given/When/Then).</p>
</td></tr></tbody></table></div><p>Groovy has a place of choice in my testing toolset. Even if you're not ready yet to put some<a id="id417" class="indexterm"/> Groovy code into production, you can easily use the convenience of the language in your tests. With Gradle, this is very easy to do, but we will see that in a few minutes.</p></div></div>
<div class="section" title="The acceptance tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec65"/>The acceptance tests</h1></div></div></div><p>In the context of a web application, "acceptance test" will often refer to in-browser, end-to-end testing. In the Java world, Selenium is clearly one of the most reliable and mature libraries.</p><p>In the JavaScript<a id="id418" class="indexterm"/> world, we can find other alternatives, such as PhantomJS or Protractor. PhantomJS is very relevant in our case because there is a web driver available to run Selenium tests inside of this headless browser, which will improve launch time and won't require emulating an X Server or launching a separate Selenium server:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>Selenium 2</p>
</td><td style="text-align: left" valign="top">
<p>This provides web drivers to pilot browsers for automated testing.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PhantomJS</p>
</td><td style="text-align: left" valign="top">
<p>A headless browser (without GUI). Probably the fastest browser.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>FluentLenium</p>
</td><td style="text-align: left" valign="top">
<p>A fluent library for piloting Selenium tests.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Geb</p>
</td><td style="text-align: left" valign="top">
<p>A Groovy library for piloting Selenium tests.</p>
</td></tr></tbody></table></div></div>
<div class="section" title="Our first unit test"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Our first unit test</h1></div></div></div><p>It is now time to write our first unit test.</p><p>We will focus <a id="id419" class="indexterm"/>on writing tests at the controller level because we have little to no business code or service. The key to writing tests for Spring MVC is the <code class="literal">org.springframework.boot:spring-boot-starter-test</code> dependency in our classpath. It will add a few very useful libraries, such as these:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">hamcrest</code>: This is JUnit's assertion library</li><li class="listitem" style="list-style-type: disc"><code class="literal">mockito</code>: This is a mocking library</li><li class="listitem" style="list-style-type: disc"><code class="literal">spring-test</code>: This is the Spring testing library</li></ul></div><p>We will test the redirection to the profile page that is created when the user hasn't created their profile yet.</p><p>We already have an autogenerated test called <code class="literal">MasterSpringMvc4ApplicationTests</code>. It is the most basic kind of test one can write with the Spring test framework: it does nothing but blow up if the context cannot be loaded:</p><div class="informalexample"><pre class="programlisting">@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = MasterSpringMvc4Application.class)
@WebAppConfiguration
public class MasterSpringMvc4ApplicationTests {

    @Test
    public void contextLoads() {
    }
}</pre></div><p>We can delete<a id="id420" class="indexterm"/> this test and create one that will ensure that a user with no profile will be redirected to the profile page by default. It will actually test the code of the <code class="literal">HomeController</code> class, so let's call it <code class="literal">HomeControllerTest</code> class and put it in the same package as <code class="literal">HomeController</code>, in <code class="literal">src/test/java</code>. All IDEs have shortcuts for creating a JUnit test case from a class. Find out how to do it with yours now!</p><p>Here is the test:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.controller;

import masterSpringMvc.MasterSpringMvcApplication;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = MasterSpringMvcApplication.class)
@WebAppConfiguration
public class HomeControllerTest {
    @Autowired
    private WebApplicationContext wac;

    private MockMvc mockMvc;

    @Before
    public void setup() {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
    }

    @Test
    public void should_redirect_to_profile() throws Exception {
        this.mockMvc.perform(get("/"))
                .andDo(print())
                .andExpect(status().isFound())
                .andExpect(redirectedUrl("/profile"));
    }
}</pre></div><p>We use <code class="literal">MockMvc</code> to simulate interactions with a Spring controller without the actual overhead of a <a id="id421" class="indexterm"/>Servlet container.</p><p>We also use a couple of matchers that Spring provides to assert our result. They actually implement Hamcrest matchers.</p><p>The <code class="literal">.andDo(print())</code> statement will produce a neat debug output for the request and response of the scenario under test. You can comment it if you find it too verbose.</p><p>That's all there is to it! The syntax is a bit tricky at the beginning, but an IDE with good completion will be able to help you.</p><p>Now we want to test whether, if the user has filled in the test part of their profile, we can redirect them to the correct search. For that, we will need to stub the session with the <code class="literal">MockHttpSession</code> class:</p><div class="informalexample"><pre class="programlisting">import org.springframework.mock.web.MockHttpSession;
import masterSpringMvc.profile.UserProfileSession;

// put this test below the other one
@Test
public void should_redirect_to_tastes() throws Exception {
    MockHttpSession session = new MockHttpSession();
    UserProfileSession sessionBean = new UserProfileSession();
    sessionBean.setTastes(Arrays.asList("spring", "groovy"));
    session.setAttribute("scopedTarget.userProfileSession", sessionBean);

    this.mockMvc.perform(get("/").session(session))
        .andExpect(status().isFound())
        .andExpect(redirectedUrl("/search/mixed;keywords=spring,groovy"));
}</pre></div><p>You will have to add the <code class="literal">setTastes()</code> setter to the <code class="literal">UserProfileSession</code> bean for the test to work.</p><p>There are a lot of mocking utilities for the Servlet environment in the <code class="literal">org.springframework.mock.web</code> package.</p><p>Note that the <a id="id422" class="indexterm"/>attribute representing our bean in session is prefixed by <code class="literal">scopedTarget</code>. That's because session beans are proxified by Spring. Therefore, there are actually two objects in the Spring context, the actual bean that we defined and its proxy that will end up in the session.</p><p>The mock session is a neat class, but we can refactor the test with a builder that will hide implementation details and can be reused later:</p><div class="informalexample"><pre class="programlisting">@Test
public void should_redirect_to_tastes() throws Exception {

    MockHttpSession session = new SessionBuilder().userTastes("spring", "groovy").build();
    this.mockMvc.perform(get("/")
        .session(session))
        .andExpect(status().isFound())
        .andExpect(redirectedUrl("/search/mixed;keywords=spring,groovy"));
}</pre></div><p>The code for the builder is as follows:</p><div class="informalexample"><pre class="programlisting">public class SessionBuilder {
    private final MockHttpSession session;
    UserProfileSession sessionBean;

    public SessionBuilder() {
        session = new MockHttpSession();
        sessionBean = new UserProfileSession();
        session.setAttribute("scopedTarget.userProfileSession", sessionBean);
    }

    public SessionBuilder userTastes(String... tastes) {
        sessionBean.setTastes(Arrays.asList(tastes));
        return this;
    }

    public MockHttpSession build() {
        return session;
    }
}</pre></div><p>After this<a id="id423" class="indexterm"/> refactoring, your test should always pass, of course.</p></div>
<div class="section" title="Mocks and stubs"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec67"/>Mocks and stubs</h1></div></div></div><p>If we wanted to test the search request handled by the <code class="literal">SearchController</code> class, we would <a id="id424" class="indexterm"/>certainly<a id="id425" class="indexterm"/> want to mock <code class="literal">SearchService</code>.</p><p>There are two ways of doing this: with a mock or with a stub.</p><div class="section" title="Mocking with Mockito"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec54"/>Mocking with Mockito</h2></div></div></div><p>First, we can <a id="id426" class="indexterm"/>create a mock object with Mockito:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.search;

import masterSpringMvc.MasterSpringMvcApplication;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;

import java.util.Arrays;

import static org.hamcrest.Matchers.*;
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = MasterSpringMvcApplication.class)
@WebAppConfiguration
public class SearchControllerMockTest {
    @Mock
    private SearchService searchService;

    @InjectMocks
    private SearchController searchController;

    private MockMvc mockMvc;

    @Before
    public void setup() {
        MockitoAnnotations.initMocks(this);
        this.mockMvc = MockMvcBuilders
                .standaloneSetup(searchController)
                .setRemoveSemicolonContent(false)
                .build();
    }

    @Test
    public void should_search() throws Exception {

        when(searchService.search(anyString(), anyListOf(String.class)))
                .thenReturn(Arrays.asList(
                        new LightTweet("tweetText")
                ));

        this.mockMvc.perform(get("/search/mixed;keywords=spring"))
                .andExpect(status().isOk())
                .andExpect(view().name("resultPage"))
                .andExpect(model().attribute("tweets", everyItem(
                        hasProperty("text", is("tweetText"))
                )));

        verify(searchService, times(1)).search(anyString(), anyListOf(String.class));
    }
}</pre></div><p>You can see that instead of setting up <code class="literal">MockMvc</code> with the web application context, we have created a standalone context. This context will only contain our controller. That means we have full control over the instantiation and initialization of controllers and their dependencies. It will allow us to easily inject a mock inside of our controller.</p><p>The downside is that we have to redeclare pieces of our configuration like the one saying we don't want to remove URL characters after a semicolon.</p><p>We use a couple<a id="id427" class="indexterm"/> of Hamcrest matchers to assert the properties that will end up in the view model.</p><p>The mocking approach has its benefits, such as the ability to verify interactions with the mock and create expectations at runtime.</p><p>This will also couple your test with the actual implementation of the object. For instance, if you changed how a tweet is fetched in the controller, you would likely break the tests related to this controller because they still try to mock the service we no longer rely on.</p></div><div class="section" title="Stubbing our beans while testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec55"/>Stubbing our beans while testing</h2></div></div></div><p>Another approach is to replace the implementation of our <code class="literal">SearchService</code> class with another one in<a id="id428" class="indexterm"/> our test.</p><p>We were a bit lazy early on and did not define an interface for <code class="literal">SearchService</code>. <span class="emphasis"><em>Always program to an interface and not to an implementation</em></span>. Behind this proverbial wisdom lies the most important lesson from the <span class="emphasis"><em>Gang of Four</em></span>.</p><p>One of the benefits of the Inversion of Control is to allow for the easy replacement of our implementations in tests or in a real system. For this to work, we will have to modify all the usages <code class="literal">SearchService</code> with the new interface. With a good IDE, there is a refactoring called <code class="literal">extract interface</code> that will do just that. This should create an interface that contains the public method <code class="literal">search()</code> of our <code class="literal">SearchService</code> class:</p><div class="informalexample"><pre class="programlisting">public interface TwitterSearch {
    List&lt;LightTweet&gt; search(String searchType, List&lt;String&gt; keywords);
}</pre></div><p>Of course, our two controllers, <code class="literal">SearchController</code> and <code class="literal">SearchApiController</code>, must now use the interface and not the implementation.</p><p>We now have the ability to create a test double for the <code class="literal">TwitterSearch</code> class specially for our test case. For this to work, we will need to declare a new Spring configuration named <code class="literal">StubTwitterSearchConfig</code> that will contain another implementation for <code class="literal">TwitterSearch</code>. I placed it in the search package, next to <code class="literal">SearchControllerMockTest</code>:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.search;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

import java.util.Arrays;

@Configuration
public class StubTwitterSearchConfig {
    @Primary @Bean
    public TwitterSearch twitterSearch() {
        return (searchType, keywords) -&gt; Arrays.asList(
                new LightTweet("tweetText"),
                new LightTweet("secondTweet")
        );
    }
}</pre></div><p>In this <a id="id429" class="indexterm"/>configuration class, we redeclare the <code class="literal">TwitterSearch</code> bean with the <code class="literal">@Primary</code> annotation, which will tell Spring to use this implementation on priority if other implementations are found in the classpath.</p><p>Since the <code class="literal">TwitterSearch</code> interface contains only one method, we can implement it with a lambda expression.</p><p>Here is the complete test that uses our <code class="literal">StubConfiguration</code> class along with our main configuration with the <code class="literal">SpringApplicationConfiguration</code> annotation:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.search;

import masterSpringMvc.MasterSpringMvcApplication;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;

import static org.hamcrest.Matchers.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = {
        MasterSpringMvcApplication.class,
        StubTwitterSearchConfig.class
})
@WebAppConfiguration
public class SearchControllerTest {
    @Autowired
    private WebApplicationContext wac;

    private MockMvc mockMvc;

    @Before
    public void setup() {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
    }

    @Test
    public void should_search() throws Exception {

        this.mockMvc.perform(get("/search/mixed;keywords=spring"))
                .andExpect(status().isOk())
                .andExpect(view().name("resultPage"))
                .andExpect(model().attribute("tweets", hasSize(2)))
                .andExpect(model().attribute("tweets",
                                hasItems(
                                        hasProperty("text", is("tweetText")),
                                        hasProperty("text", is("secondTweet"))
                                ))
                );
    }
}</pre></div></div><div class="section" title="Should I use mocks or stubs?"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec56"/>Should I use mocks or stubs?</h2></div></div></div><p>Both <a id="id430" class="indexterm"/>approaches have their own merits. For a detailed <a id="id431" class="indexterm"/>explanation, check out this great essay by Martin Fowler: <a class="ulink" href="http://martinfowler.com/articles/mocksArentStubs.html">http://martinfowler.com/articles/mocksArentStubs.html</a>.</p><p>My testing<a id="id432" class="indexterm"/> routine is more about writing stubs because I like the idea of testing the output of my objects more than their inner workings. But that's up to you. Spring being a dependency injection framework at its core means that you can easily choose what your favorite approach is.</p></div></div>
<div class="section" title="Unit testing REST controllers"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec68"/>Unit testing REST controllers</h1></div></div></div><p>We have just tested a traditional controller redirecting to a view. Testing a REST controller is<a id="id433" class="indexterm"/> very similar in principle, but there are a few subtleties.</p><p>Since we are going<a id="id434" class="indexterm"/> to test the JSON output of our controller, we need a JSON assertion library. Add the following dependency to your <code class="literal">build.gradle</code> file:</p><div class="informalexample"><pre class="programlisting">testCompile 'com.jayway.jsonpath:json-path'</pre></div><p>Let's write a test for the <code class="literal">SearchApiController</code> class, the controller that allows searching for a tweet and returns results as JSON or XML:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.search.api;

import masterSpringMvc.MasterSpringMvcApplication;
import masterSpringMvc.search.StubTwitterSearchConfig;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.http.MediaType;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;

import static org.hamcrest.Matchers.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = {
        MasterSpringMvcApplication.class,
        StubTwitterSearchConfig.class
})
@WebAppConfiguration
public class SearchApiControllerTest {
    @Autowired
    private WebApplicationContext wac;

    private MockMvc mockMvc;

    @Before
    public void setup() {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
    }

    @Test
    public void should_search() throws Exception {

        this.mockMvc.perform(
                get("/api/search/mixed;keywords=spring")
                        .accept(MediaType.APPLICATION_JSON))
                .andDo(print())
                .andExpect(status().isOk())
                .andExpect(content().contentTypeCompatibleWith(MediaType.APPLICATION_JSON))
                .andExpect(jsonPath("$", hasSize(2)))
                .andExpect(jsonPath("$[0].text", is("tweetText")))
                .andExpect(jsonPath("$[1].text", is("secondTweet")));
    }
}</pre></div><p>Note the<a id="id435" class="indexterm"/> simple and elegant assertions on the JSON output. Testing <a id="id436" class="indexterm"/>our user controller will require a bit more work.</p><p>First, let's add <code class="literal">assertj</code> to the classpath; it will help us write cleaner tests:</p><div class="informalexample"><pre class="programlisting">testCompile 'org.assertj:assertj-core:3.0.0'</pre></div><p>Then, to simplify testing, add a <code class="literal">reset()</code> method to our <code class="literal">UserRepository</code> class that will help us with the test:</p><div class="informalexample"><pre class="programlisting">void reset(User... users) {
        userMap.clear();
        for (User user : users) {
                save(user);
        }
}</pre></div><p>In real life, we<a id="id437" class="indexterm"/> should probably extract an interface and create a stub <a id="id438" class="indexterm"/>for testing. I will leave that as an exercise for you.</p><p>Here is the first test that gets the list of users:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.user.api;

import masterSpringMvc.MasterSpringMvcApplication;
import masterSpringMvc.user.User;
import masterSpringMvc.user.UserRepository;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.http.MediaType;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;

import static org.hamcrest.Matchers.*;
   import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = MasterSpringMvcApplication.class)
@WebAppConfiguration
public class UserApiControllerTest {

    @Autowired
    private WebApplicationContext wac;

    @Autowired
    private UserRepository userRepository;

    private MockMvc mockMvc;

    @Before
    public void setup() {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
        userRepository.reset(new User("bob@spring.io"));
    }

    @Test
    public void should_list_users() throws Exception {
        this.mockMvc.perform(
                get("/api/users")
                        .accept(MediaType.APPLICATION_JSON)
        )
                .andExpect(status().isOk())
                .andExpect(content().contentTypeCompatibleWith(MediaType.APPLICATION_JSON))
                .andExpect(jsonPath("$", hasSize(1)))
                .andExpect(jsonPath("$[0].email", is("bob@spring.io")));
    }
}</pre></div><p>For this to<a id="id439" class="indexterm"/> work, add a constructor to the <code class="literal">User</code> class, taking the<a id="id440" class="indexterm"/> e-mail property as a parameter. Be careful: you also need to have a default constructor for Jackson.</p><p>The test is very similar to the previous test with the additional setup of <code class="literal">UserRepository</code>.</p><p>Let's test the <code class="literal">POST</code> method that creates a user now:</p><div class="informalexample"><pre class="programlisting">import static org.assertj.core.api.Assertions.assertThat;

// Insert this test below the previous one
@Test
public void should_create_new_user() throws Exception {
        User user = new User("john@spring.io");
        this.mockMvc.perform(
                post("/api/users")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(JsonUtil.toJson(user))
        )
                .andExpect(status().isCreated());

        assertThat(userRepository.findAll())
                .extracting(User::getEmail)
                .containsOnly("bob@spring.io", "john@spring.io");
}</pre></div><p>There are two<a id="id441" class="indexterm"/> things to be noted. The first one is the use of AssertJ to <a id="id442" class="indexterm"/>assert the content of the repository after the test. You will need the following static import for that to work:</p><div class="informalexample"><pre class="programlisting">import static org.assertj.core.api.Assertions.assertThat;</pre></div><p>The second is that we use a utility method to convert our object to JSON before sending it to the controller. For that purpose, I created a simple utility class in the <code class="literal">utils</code> package, as follows:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.utils;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;

public class JsonUtil {
    public static byte[] toJson(Object object) throws IOException {
        ObjectMapper mapper = new ObjectMapper();
        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        return mapper.writeValueAsBytes(object);
    }
}</pre></div><p>The tests for the <code class="literal">DELETE</code> method are as follows:</p><div class="informalexample"><pre class="programlisting">@Test
public void should_delete_user() throws Exception {
        this.mockMvc.perform(
                delete("/api/user/bob@spring.io")
                        .accept(MediaType.APPLICATION_JSON)
        )
                .andExpect(status().isOk());

        assertThat(userRepository.findAll()).hasSize(0);
}

@Test
public void should_return_not_found_when_deleting_unknown_user() throws Exception {
        this.mockMvc.perform(
                delete("/api/user/non-existing@mail.com")
                        .accept(MediaType.APPLICATION_JSON)
        )
                .andExpect(status().isNotFound());
}</pre></div><p>Finally, here's the test for the <code class="literal">PUT</code> method, which updates a user:</p><div class="informalexample"><pre class="programlisting">@Test
public void put_should_update_existing_user() throws Exception {
        User user = new User("ignored@spring.io");
        this.mockMvc.perform(
                put("/api/user/bob@spring.io")
                        .content(JsonUtil.toJson(user))
                        .contentType(MediaType.APPLICATION_JSON)
        )
                .andExpect(status().isOk());

        assertThat(userRepository.findAll())
                .extracting(User::getEmail)
                .containsOnly("bob@spring.io");
}</pre></div><p>Whoops! The last test does not pass! By checking the implementation of <code class="literal">UserApiController</code>, we can easily see why:</p><div class="informalexample"><pre class="programlisting">   @RequestMapping(value = "/user/{email}", method = RequestMethod.PUT)
    public ResponseEntity&lt;User&gt; updateUser(@PathVariable String email, @RequestBody User user) throws EntityNotFoundException {
        User saved = userRepository.update(email, user);
        return new ResponseEntity&lt;&gt;(saved, HttpStatus.CREATED);
    }</pre></div><p>We returned the <a id="id443" class="indexterm"/>wrong status in the controller! Change<a id="id444" class="indexterm"/> it to <code class="literal">HttpStatus.OK</code> and the test should be green again.</p><p>With Spring, one can easily write controller tests using the same configuration of our application, but we can just as efficiently override or change some elements in our testing setup.</p><p>Another interesting thing that you will notice while running all the tests is that the application context is only loaded once, which means that the overhead is actually very small.</p><p>Our application is small too, so we did not make any effort to split our configuration into reusable chunks. It can be a really good practice not to load the full application context inside of every test. You can actually split the component scanned into different units with the <code class="literal">@ComponentScan</code> annotation.</p><p>This annotation has several attributes that allow you to define filters with <code class="literal">includeFilter</code> and <code class="literal">excludeFilter</code> (loading only the controller for instance) and scan specific<a id="id445" class="indexterm"/> packages with the <code class="literal">basePackageClasses</code> and <code class="literal">basePackages</code> annotations.</p><p>You can also<a id="id446" class="indexterm"/> split your configuration into multiple <code class="literal">@Configuration</code> classes. A good example would be splitting the code for the users and for the tweet parts of our application into two independent parts.</p><p>We will now have a look at acceptance tests, which are a very different kind of beast.</p></div>
<div class="section" title="Testing the authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec69"/>Testing the authentication</h1></div></div></div><p>If you wish to set up<a id="id447" class="indexterm"/> Spring Security in a MockMvc test, you can write this test next to our previous test:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.user.api;

import masterSpringMvc.MasterSpringMvcApplication;
import masterSpringMvc.user.User;
import masterSpringMvc.user.UserRepository;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.http.MediaType;
import org.springframework.security.web.FilterChainProxy;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;

import java.util.Base64;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = MasterSpringMvcApplication.class)
@WebAppConfiguration
public class UserApiControllerAuthTest {

    @Autowired
    private FilterChainProxy springSecurityFilter;

    @Autowired
    private WebApplicationContext wac;

    @Autowired
    private UserRepository userRepository;

    private MockMvc mockMvc;

    @Before
    public void setup() {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).addFilter(springSecurityFilter).build();
        userRepository.reset(new User("bob@spring.io"));
    }

    @Test
    public void unauthenticated_cannot_list_users() throws Exception {
        this.mockMvc.perform(
                get("/api/users")
                        .accept(MediaType.APPLICATION_JSON)
        )
                .andExpect(status().isUnauthorized());
    }

    @Test
    public void admin_can_list_users() throws Exception {
        this.mockMvc.perform(
                get("/api/users")
                        .accept(MediaType.APPLICATION_JSON)
                        .header("Authorization", basicAuth("admin", "admin"))
        )
                .andExpect(status().isOk());
    }

    private String basicAuth(String login, String password) {
        byte[] auth = (login + ":" + password).getBytes();
        return "Basic " + Base64.getEncoder().encodeToString(auth);
    }
}</pre></div><p>In the preceding<a id="id448" class="indexterm"/> example, we added <code class="literal">SpringSecurityFilter</code> to our configuration. This will activate Spring Security checks. To test if the authentication works, we simply send the correct headers along with the request we would like to perform.</p><p>The advantage of basic authentication is that it's really straightforward to simulate. With a more complicated setup, you would have to perform a mock request on the authentication endpoint.</p><p>At the time of writing, Spring Boot is at version 1.2.3 and depends on Spring Security 3.</p><p>In a few weeks, Spring Boot 1.3.0 will be available, it will update Spring Security and use version 4.</p><p>This is good <a id="id449" class="indexterm"/>news because Spring Security 4 includes a really easy setup of the authenticated user with simple annotations. See <a class="ulink" href="http://docs.spring.io/spring-security/site/docs/4.0.x/reference/htmlsingle/#test">http://docs.spring.io/spring-security/site/docs/4.0.x/reference/htmlsingle/#test</a> for more details.</p></div>
<div class="section" title="Writing acceptance tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec70"/>Writing acceptance tests</h1></div></div></div><p>Unit tests can <a id="id450" class="indexterm"/>only cover a subset of the different interactions between the components of our application. To go a little further, we will need to set up acceptance tests, tests that will actually boot up the complete application and allow us to interact with its interface.</p><div class="section" title="The Gradle configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec57"/>The Gradle configuration</h2></div></div></div><p>The first thing we will want to do when we add integration tests to a project is to put them in a<a id="id451" class="indexterm"/> different location to that of the unit tests.</p><p>The reason for<a id="id452" class="indexterm"/> this is, essentially, that acceptance tests are slower than unit tests. They can be part of a different integration job, such as a nightly build, and we want developers to be able to launch the different kinds of tests easily from their IDE. To do this with Gradle, we will have to add a new configuration called <code class="literal">integrationTest</code>. For Gradle, a configuration is a group of artifacts and their dependencies. We already have several configurations in our project: <code class="literal">compile</code>, <code class="literal">testCompile</code>, and so on.</p><p>You can have a look at the configurations of your project, and much more, by typing <code class="literal">./gradlew properties</code> at the root of your project.</p><p>Add a new configuration at the end of <code class="literal">build.gradle</code> file:</p><div class="informalexample"><pre class="programlisting">configurations {
    integrationTestCompile.extendsFrom testCompile
    integrationTestRuntime.extendsFrom testRuntime
}</pre></div><p>This will allow you to declare dependencies for <code class="literal">integrationTestCompile</code> and <code class="literal">integrationTestRuntime</code>. More importantly, by inheriting the test configurations, we have access to their dependencies.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip21"/>Tip</h3><p>I do not recommend declaring your integration test dependencies as <code class="literal">integrationTestCompile</code>. It will work as far as Gradle is concerned, but support inside of IDE is non-existent. What I usually do is declare my integration test dependencies as <code class="literal">testCompile</code> dependencies instead. This is only a small inconvenience.</p></div></div><p>Now that <a id="id453" class="indexterm"/>we have our new configurations, we <a id="id454" class="indexterm"/>must create a <code class="literal">sourceSet</code> class associated with them. A <code class="literal">sourceSet</code> class represents a logical group of Java source and resources. Naturally, they also have to inherit from the test and main classes; see the following code:</p><div class="informalexample"><pre class="programlisting">sourceSets {
    integrationTest {
        compileClasspath += main.output + test.output
        runtimeClasspath += main.output + test.output
    }
}</pre></div><p>Finally, we need to add a task to run them from our build, as follows:</p><div class="informalexample"><pre class="programlisting">task integrationTest(type: Test) {
    testClassesDir = sourceSets.integrationTest.output.classesDir
    classpath = sourceSets.integrationTest.runtimeClasspath
    reports.html.destination = file("${reporting.baseDir}/integrationTests")
}</pre></div><p>To run our test, we can type <code class="literal">./gradlew integrationTest</code>. Besides configuring our classpath and where to find our test classes, we also defined a directory where the test report will be generated.</p><p>This configuration allows us to write our tests in <code class="literal">src/integrationTest/java</code> or <code class="literal">src/integrationTest/groovy</code>, which will make it easier to identify them and run them separately from our unit tests.</p><p>By default, they will be generated in <code class="literal">build/reports/tests</code>. If we do not override them, if we launch both tests and integration tests with <code class="literal">gradle clean test integrationTest</code>, they <a id="id455" class="indexterm"/>will override each other.</p><p>It's also worth mentioning that a young plugin in the Gradle ecosystem aims to simplify declaring <a id="id456" class="indexterm"/>new test configurations, visit <a class="ulink" href="https://plugins.gradle.org/plugin/org.unbroken-dome.test-sets">https://plugins.gradle.org/plugin/org.unbroken-dome.test-sets</a> for detailed information.</p></div><div class="section" title="Our first FluentLenium test"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec58"/>Our first FluentLenium test</h2></div></div></div><p>FluentLenium is<a id="id457" class="indexterm"/> an amazing library for piloting Selenium tests. Let's add<a id="id458" class="indexterm"/> a few dependencies to our <a id="id459" class="indexterm"/>build script:</p><div class="informalexample"><pre class="programlisting">testCompile 'org.fluentlenium:fluentlenium-assertj:0.10.3'
testCompile 'com.codeborne:phantomjsdriver:1.2.1'
testCompile 'org.seleniumhq.selenium:selenium-java:2.45.0'</pre></div><p>By default, <code class="literal">fluentlenium</code> comes with <code class="literal">selenium-java</code>. We redeclare it just to explicitly require the latest version available. We also added a dependency to the <code class="literal">PhantomJS</code> driver, which is not officially supported by Selenium. The problem with the <code class="literal">selenium-java</code> library is that it comes bundled with all the supported web drivers.</p><p>You can see the dependency tree of our project by typing <code class="literal">gradle dependencies</code>. At the bottom, you will see something like this:</p><div class="informalexample"><pre class="programlisting">+--- org.fluentlenium:fluentlenium-assertj:0.10.3
|    +--- org.fluentlenium:fluentlenium-core:0.10.3
|    |    \--- org.seleniumhq.selenium:selenium-java:2.44.0 -&gt; 2.45.0
|    |         +--- org.seleniumhq.selenium:selenium-chrome-driver:2.45.0

|    |         +--- org.seleniumhq.selenium:selenium-htmlunit-driver:2.45.0

|    |         +--- org.seleniumhq.selenium:selenium-firefox-driver:2.45.0

|    |         +--- org.seleniumhq.selenium:selenium-ie-driver:2.45.0

|    |         +--- org.seleniumhq.selenium:selenium-safari-driver:2.45.0

|    |         +--- org.webbitserver:webbit:0.4.14 (*)
|    |         \--- org.seleniumhq.selenium:selenium-leg-rc:2.45.0
|    |              \--- org.seleniumhq.selenium:selenium-remote-driver:2.45.0 (*)
|    \--- org.assertj:assertj-core:1.6.1 -&gt; 3.0.0</pre></div><p>Having all those dependencies in the classpath is highly unnecessary since we will just use the <code class="literal">PhantomJS</code> driver. To exclude the dependencies we won't need, we can add the following part to our buildscript, right before the dependencies declaration:</p><div class="informalexample"><pre class="programlisting">configurations {
    testCompile {
        exclude module: 'selenium-safari-driver'
        exclude module: 'selenium-ie-driver'
        //exclude module: 'selenium-firefox-driver'
        exclude module: 'selenium-htmlunit-driver'
        exclude module: 'selenium-chrome-driver'
    }
}</pre></div><p>We just keep<a id="id460" class="indexterm"/> the <code class="literal">firefox</code> driver at hand. <code class="literal">PhantomJS</code> driver is a headless browser, so understanding what happens without a GUI can prove tricky. It<a id="id461" class="indexterm"/> can be nice to switch to Firefox to debug a complex test.</p><p>With our classpath correctly configured, we can now write our first integration test. Spring Boot has a very convenient annotation to support this test:</p><div class="informalexample"><pre class="programlisting">import masterSpringMvc.MasterSpringMvcApplication;
import masterSpringMvc.search.StubTwitterSearchConfig;
import org.fluentlenium.adapter.FluentTest;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.phantomjs.PhantomJSDriver;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.boot.test.WebIntegrationTest;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import static org.assertj.core.api.Assertions.assertThat;

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = {
        MasterSpringMvcApplication.class,
        StubTwitterSearchConfig.class
})
@WebIntegrationTest(randomPort = true)
public class FluentIntegrationTest extends FluentTest {

    @Value("${local.server.port}")
    private int serverPort;

    @Override
    public WebDriver getDefaultDriver() {
        return new PhantomJSDriver();
    }

    public String getDefaultBaseUrl() {
        return "http://localhost:" + serverPort;
    }

    @Test
    public void hasPageTitle() {
        goTo("/");
        assertThat(findFirst("h2").getText()).isEqualTo("Login");
    }
}</pre></div><p>Note that <a id="id462" class="indexterm"/>FluentLenium has a neat API for requesting DOM <a id="id463" class="indexterm"/>elements. With AssertJ, we can then write easy-to read-assertions on the page content.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Have a<a id="id464" class="indexterm"/> look at the documentation at <a class="ulink" href="https://github.com/FluentLenium/FluentLenium">https://github.com/FluentLenium/FluentLenium</a> for further information.</p></div></div><p>With the <code class="literal">@WebIntegrationTest</code> annotation, Spring will actually create the embedded Servlet container (Tomcat) and launch our web application on a random port! We need to retrieve this port number at runtime. This will allow us to provide a base URL for our tests, a URL that will be the prefix for all the navigation we do in our tests.</p><p>If you try to run the test at this stage, you will see the following error message:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>java.lang.IllegalStateException: The path to the driver executable must be set by the phantomjs.binary.path capability/system property/PATH variable; for more information, see https://github.com/ariya/phantomjs/wiki. The latest version can be downloaded from http://phantomjs.org/download.html</strong></span>
</pre></div><p>Indeed, PhantomJS needs to be installed on your machine for this to work correctly. On a Mac, simply <a id="id465" class="indexterm"/>use <code class="literal">brew install phantomjs</code>. For other platforms, see the documentation at <a class="ulink" href="http://phantomjs.org/download.html">http://phantomjs.org/download.html</a>.</p><p>If you don't want to install a new binary on your machine, replace <code class="literal">new PhantomJSDriver()</code> with <code class="literal">new FirefoxDriver()</code>. Your test will be a bit slower, but you will have a GUI.</p><p>Our first test is landing on the profile page, right? We need to find a way to log in now.</p><p>What about <a id="id466" class="indexterm"/>faking login with a stub?</p><p>Put this<a id="id467" class="indexterm"/> class in the test sources (<code class="literal">src/test/java</code>):</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.auth;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.social.connect.ConnectionFactoryLocator;
import org.springframework.social.connect.UsersConnectionRepository;
import org.springframework.social.connect.web.ProviderSignInController;
import org.springframework.social.connect.web.SignInAdapter;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.servlet.view.RedirectView;

@Configuration
public class StubSocialSigninConfig {

    @Bean
    @Primary
    @Autowired
    public ProviderSignInController signInController(ConnectionFactoryLocator factoryLocator,
                                                     UsersConnectionRepository usersRepository,
                                                     SignInAdapter signInAdapter) {
        return new FakeSigninController(factoryLocator, usersRepository, signInAdapter);
    }

    public class FakeSigninController extends ProviderSignInController {
        public FakeSigninController(ConnectionFactoryLocator connectionFactoryLocator,
                                    UsersConnectionRepository usersConnectionRepository,
                                    SignInAdapter signInAdapter) {
            super(connectionFactoryLocator, usersConnectionRepository, signInAdapter);
        }

        @Override
        public RedirectView signIn(String providerId, NativeWebRequest request) {
            UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken("geowarin", null, null);
            SecurityContextHolder.getContext().setAuthentication(authentication);
            return new RedirectView("/");
        }
    }
}</pre></div><p>This will <a id="id468" class="indexterm"/>authenticate any user clicking on the Twitter <a id="id469" class="indexterm"/>sign in button as geowarin.</p><p>We will write a second test that will fill the profile form and assert that the search result is displayed:</p><div class="informalexample"><pre class="programlisting">import masterSpringMvc.MasterSpringMvcApplication;
import masterSpringMvc.auth.StubSocialSigninConfig;
import masterSpringMvc.search.StubTwitterSearchConfig;
import org.fluentlenium.adapter.FluentTest;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.phantomjs.PhantomJSDriver;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.boot.test.WebIntegrationTest;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import static org.assertj.core.api.Assertions.assertThat;
import static org.fluentlenium.core.filter.FilterConstructor.withName;

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = {
        MasterSpringMvcApplication.class,
        StubTwitterSearchConfig.class,
        StubSocialSigninConfig.class
})
@WebIntegrationTest(randomPort = true)
public class FluentIntegrationTest extends FluentTest {

    @Value("${local.server.port}")
    private int serverPort;

    @Override
    public WebDriver getDefaultDriver() {
        return new PhantomJSDriver();
    }

    public String getDefaultBaseUrl() {
        return "http://localhost:" + serverPort;
    }

    @Test
    public void hasPageTitle() {
        goTo("/");
        assertThat(findFirst("h2").getText()).isEqualTo("Login");
    }

    @Test
    public void should_be_redirected_after_filling_form() {
        goTo("/");
        assertThat(findFirst("h2").getText()).isEqualTo("Login");

        <span class="strong"><strong>find("button", withName("twitterSignin")).click();</strong></span>
<span class="strong"><strong>        assertThat(findFirst("h2").getText()).isEqualTo("Your profile");</strong></span>

        fill("#twitterHandle").with("geowarin");
        fill("#email").with("geowarin@mymail.com");
        fill("#birthDate").with("03/19/1987");

        find("button", withName("addTaste")).click();
        fill("#tastes0").with("spring");

        find("button", withName("save")).click();

        takeScreenShot();
        assertThat(findFirst("h2").getText()).isEqualTo("Tweet results for spring");
        assertThat(findFirst("ul.collection").find("li")).hasSize(2);
    }
}</pre></div><p>Note that<a id="id470" class="indexterm"/> we can easily ask our web driver to take a screenshot<a id="id471" class="indexterm"/> of the current browser used for testing. This will produce the following output:</p><div class="mediaobject"><img src="graphics/2117_07_03.jpg" alt="Our first FluentLenium test"/></div></div><div class="section" title="Page Objects with FluentLenium"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec59"/>Page Objects with FluentLenium</h2></div></div></div><p>The previous test<a id="id472" class="indexterm"/> was a bit messy. We have hardcoded all the selectors in our test. This can become very risky when we write a lot of tests using the same <a id="id473" class="indexterm"/>elements because whenever we change the page layout, all the tests will break. Moreover, the test is a little difficult to read.</p><p>To fix this, a common practice is to use a page object that will represent a specific web page in our application. With FluentLenium, page objects must inherit the <code class="literal">FluentPage</code> class.</p><p>We will create three pages, one for each element of our GUI. The first one will be the login page with the option to click on the <code class="literal">twitterSignin</code> button, the second one will be the profile page with convenience methods for filling in the profile form, and the last one will be the result page on which we can assert the results displayed.</p><p>Let's create the login page at once. I put all the three pages in a <code class="literal">pages</code> package:</p><div class="informalexample"><pre class="programlisting">package pages;

import org.fluentlenium.core.FluentPage;
import org.fluentlenium.core.domain.FluentWebElement;
import org.openqa.selenium.support.FindBy;

import static org.assertj.core.api.Assertions.assertThat;

public class LoginPage extends FluentPage {
    @FindBy(name = "twitterSignin")
    FluentWebElement signinButton;

    public String getUrl() {
        return "/login";
    }

    public void isAt() {
        assertThat(findFirst("h2").getText()).isEqualTo("Login");
    }

    public void login() {
        signinButton.click();
    }
}</pre></div><p>Let's create one page for our profile page:</p><div class="informalexample"><pre class="programlisting">package pages;

import org.fluentlenium.core.FluentPage;
import org.fluentlenium.core.domain.FluentWebElement;
import org.openqa.selenium.support.FindBy;

import static org.assertj.core.api.Assertions.assertThat;

public class ProfilePage extends FluentPage {
    @FindBy(name = "addTaste")
    FluentWebElement addTasteButton;
    @FindBy(name = "save")
    FluentWebElement saveButton;

    public String getUrl() {
        return "/profile";
    }

    public void isAt() {
        assertThat(findFirst("h2").getText()).isEqualTo("Your profile");
    }

    public void fillInfos(String twitterHandle, String email, String birthDate) {
        fill("#twitterHandle").with(twitterHandle);
        fill("#email").with(email);
        fill("#birthDate").with(birthDate);
    }

    public void addTaste(String taste) {
        addTasteButton.click();
        fill("#tastes0").with(taste);
    }

    public void saveProfile() {
        saveButton.click();
    }
}</pre></div><p>Let's also <a id="id474" class="indexterm"/>create another one for the search result<a id="id475" class="indexterm"/> page:</p><div class="informalexample"><pre class="programlisting">package pages;

import com.google.common.base.Joiner;
import org.fluentlenium.core.FluentPage;
import org.fluentlenium.core.domain.FluentWebElement;
import org.openqa.selenium.support.FindBy;

import static org.assertj.core.api.Assertions.assertThat;

public class SearchResultPage extends FluentPage {
    @FindBy(css = "ul.collection")
    FluentWebElement resultList;

    public void isAt(String... keywords) {
        assertThat(findFirst("h2").getText())
                .isEqualTo("Tweet results for " + Joiner.on(",").join(keywords));
    }

    public int getNumberOfResults() {
        return resultList.find("li").size();
    }
}</pre></div><p>We can now refactor the test using those Page Objects:</p><div class="informalexample"><pre class="programlisting">@Page
private LoginPage loginPage;
@Page
private ProfilePage profilePage;
@Page
private SearchResultPage searchResultPage;

@Test
public void should_be_redirected_after_filling_form() {
    goTo("/");
    loginPage.isAt();

    loginPage.login();
    profilePage.isAt();

    profilePage.fillInfos("geowarin", "geowarin@mymail.com", "03/19/1987");
    profilePage.addTaste("spring");

    profilePage.saveProfile();

    takeScreenShot();
    searchResultPage.isAt();
    assertThat(searchResultPage.getNumberOfResults()).isEqualTo(2);
}</pre></div><p>Much<a id="id476" class="indexterm"/> more<a id="id477" class="indexterm"/> readable, isn't it?</p></div><div class="section" title="Making our tests more Groovy"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec60"/>Making our tests more Groovy</h2></div></div></div><p>If you don't know Groovy, consider it like a close cousin of Java, without the verbosity. Groovy is a <a id="id478" class="indexterm"/>dynamic language with optional typing. This means <a id="id479" class="indexterm"/>that you can have the guarantees of a type system <a id="id480" class="indexterm"/>when it matters and the versatility of duck typing when you know what you are doing.</p><p>With this language, you can write POJOs without getters, setters, <code class="literal">equals</code> and <code class="literal">hashcode</code> methods. Everything is handled for you.</p><p>Writing <code class="literal">==</code> will actually call the <code class="literal">equals</code> method. The operators can be overloaded, which allows a neat syntax with little arrows, such as <code class="literal">&lt;&lt;</code>, to write text to a file, for instance. It also means that you can add integers to <code class="literal">BigIntegers</code> and get a correct result.</p><p>The <span class="strong"><strong>Groovy Development Kit</strong></span> (<span class="strong"><strong>GDK</strong></span>) also adds several very interesting methods to classic <a id="id481" class="indexterm"/>Java objects. It also considers regular expressions and closures as first-class citizens.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>If you want a <a id="id482" class="indexterm"/>solid introduction to Groovy, check out the Groovy style guide at <a class="ulink" href="http://www.groovy-lang.org/style-guide.html">http://www.groovy-lang.org/style-guide.html</a>.</p><p>You can also watch this amazing presentation by Peter Ledbrook at <a class="ulink" href="http://www.infoq.com/presentations/groovy-for-java">http://www.infoq.com/presentations/groovy-for-java</a>.</p></div></div><p>As far as I am concerned, I always try to push Groovy on the testing side of the application I work on. It really improves the readability of the code and the productivity of developers.</p></div><div class="section" title="Unit tests with Spock"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec61"/>Unit tests with Spock</h2></div></div></div><p>To be able to <a id="id483" class="indexterm"/>write Groovy tests in our project, we need to use the <a id="id484" class="indexterm"/>Groovy plugin instead of the Java plugin.</p><p>Here's what you have in your build script:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'</pre></div><p>Change it to the following:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'groovy'</pre></div><p>This modification is perfectly harmless. The Groovy plugin extends the Java plugin, so the only difference it makes is that it gives the ability to add Groovy source in <code class="literal">src/main/groovy</code>, <code class="literal">src/test/groovy</code> and <code class="literal">src/integrationTest/groovy</code>.</p><p>Obviously, we also need to add Groovy to the classpath. We will also add Spock, the most popular Groovy testing library, via the <code class="literal">spock-spring</code> dependency, which will enable compatibility with Spring:</p><div class="informalexample"><pre class="programlisting">testCompile 'org.codehaus.groovy:groovy-all:2.4.4:indy'
testCompile 'org.spockframework:spock-spring'</pre></div><p>We can<a id="id485" class="indexterm"/> now rewrite <code class="literal">HomeControllerTest</code> with a different <a id="id486" class="indexterm"/>approach. Let's create a <code class="literal">HomeControllerSpec</code> class in <code class="literal">src/test/groovy</code>. I added it to the <code class="literal">masterSpringMvc.controller</code> package just like our first instance of <code class="literal">HomeControllerTest</code>:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.controller

import masterSpringMvc.MasterSpringMvcApplication
import masterSpringMvc.search.StubTwitterSearchConfig
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.SpringApplicationContextLoader
import org.springframework.test.context.ContextConfiguration
import org.springframework.test.context.web.WebAppConfiguration
import org.springframework.test.web.servlet.MockMvc
import org.springframework.test.web.servlet.setup.MockMvcBuilders
import org.springframework.web.context.WebApplicationContext
import spock.lang.Specification

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@ContextConfiguration(loader = SpringApplicationContextLoader,
        classes = [MasterSpringMvcApplication, StubTwitterSearchConfig])
@WebAppConfiguration
class HomeControllerSpec extends Specification {
    @Autowired
    WebApplicationContext wac;

    MockMvc mockMvc;

    def setup() {
        mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
    }

    def "User is redirected to its profile on his first visit"() {
        when: "I navigate to the home page"
        def response = this.mockMvc.perform(get("/"))

        then: "I am redirected to the profile page"
        response
                .andExpect(status().isFound())
                .andExpect(redirectedUrl("/profile"))
    }
}</pre></div><p>Our test instantaneously became more readable with the ability to use strings as method names and the little BDD DSL (Domain Specific Language) provided by Spock. This is not directly visible here, but every statement inside of a <code class="literal">then</code> block will implicitly be an assertion.</p><p>At the time <a id="id487" class="indexterm"/>of writing, because Spock doesn't read meta annotations, the <code class="literal">@SpringApplicationConfiguration</code> annotation cannot be used so we just replaced it<a id="id488" class="indexterm"/> with <code class="literal">@ContextConfiguration(loader = SpringApplicationContextLoader)</code>, which is essentially the same thing.</p><p>We now have two versions of the same test, one in Java and the other in Groovy. It is up to you to choose the one that best fits your style of coding and remove the other one. If you decide to stick with Groovy, you will have to rewrite the <code class="literal">should_redirect_to_tastes()</code> test in Groovy. It should be easy enough.</p><p>Spock also has powerful support for mocks. We can rewrite the previous <code class="literal">SearchControllerMockTest</code> class a bit differently:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.search

import masterSpringMvc.MasterSpringMvcApplication
import org.springframework.boot.test.SpringApplicationContextLoader
import org.springframework.test.context.ContextConfiguration
import org.springframework.test.context.web.WebAppConfiguration
import org.springframework.test.web.servlet.setup.MockMvcBuilders
import spock.lang.Specification

import static org.hamcrest.Matchers.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@ContextConfiguration(loader = SpringApplicationContextLoader,
        classes = [MasterSpringMvcApplication])
@WebAppConfiguration
class SearchControllerMockSpec extends Specification {
    def twitterSearch = Mock(TwitterSearch)
    def searchController = new SearchController(twitterSearch)

    def mockMvc = MockMvcBuilders.standaloneSetup(searchController)
            .setRemoveSemicolonContent(false)
            .build()

    def "searching for the spring keyword should display the search page"() {
        when: "I search for spring"
        def response = mockMvc.perform(get("/search/mixed;keywords=spring"))

        then: "The search service is called once"
        1 * twitterSearch.search(_, _) &gt;&gt; [new LightTweet('tweetText')]

        and: "The result page is shown"
        response
                .andExpect(status().isOk())
                .andExpect(view().name("resultPage"))

        and: "The model contains the result tweets"
        response
                .andExpect(model().attribute("tweets", everyItem(
                hasProperty("text", is("tweetText"))
        )))
    }
}</pre></div><p>All the <a id="id489" class="indexterm"/>verbosity of Mockito is now gone. The <code class="literal">then</code> block actually asserts<a id="id490" class="indexterm"/> that the <code class="literal">twitterSearch</code> method is called once (<code class="literal">1 *</code>) with any parameter (<code class="literal">_, _</code>). Like with mockito, we could have expected specific parameters.</p><p>The double arrow <code class="literal">&gt;&gt;</code> syntax is used to return an object from the mocked method. In our case, it's a list containing only one element.</p><p>With only a little dependency in our classpath, we have already written more readable tests, but we're<a id="id491" class="indexterm"/> not done yet. We will also refactor our acceptance tests<a id="id492" class="indexterm"/> to use Geb, a Groovy library that pilots Selenium tests.</p></div><div class="section" title="Integration tests with Geb"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec62"/>Integration tests with Geb</h2></div></div></div><p>Geb is the de facto library for writing tests in the Grails framework. Although its version is 0.12.0, it is very<a id="id493" class="indexterm"/> stable and extremely comfortable to work<a id="id494" class="indexterm"/> with.</p><p>It provides a<a id="id495" class="indexterm"/> selector API à la jQuery, which makes tests easy to write, even for frontend developers. Groovy is also a language that has some JavaScript influences that will also appeal to them.</p><p>Let's add Geb with the support for Spock specifications to our classpath:</p><div class="informalexample"><pre class="programlisting">testCompile 'org.gebish:geb-spock:0.12.0'</pre></div><p>Geb can be configured via a Groovy script found directly at the root of <code class="literal">src/integrationTest/groovy</code>, called <code class="literal">GebConfig.groovy</code>:</p><div class="informalexample"><pre class="programlisting">import org.openqa.selenium.Dimension
import org.openqa.selenium.firefox.FirefoxDriver
import org.openqa.selenium.phantomjs.PhantomJSDriver

reportsDir = new File('./build/geb-reports')
driver = {
        def driver = new FirefoxDriver()
    // def driver = new PhantomJSDriver()
    driver.manage().window().setSize(new Dimension(1024, 768))
    return driver
}</pre></div><p>In this configuration, we indicate where Geb will generate its reports and which driver to use. Reports in Geb are an enhanced version of screenshots, which also contains the current page in HTML. Their generation can be triggered at any moment by calling the <code class="literal">report</code> function inside a Geb test.</p><p>Let's rewrite out first integration test with Geb:</p><div class="informalexample"><pre class="programlisting">import geb.Configuration
import geb.spock.GebSpec
import masterSpringMvc.MasterSpringMvcApplication
import masterSpringMvc.search.StubTwitterSearchConfig
import org.springframework.beans.factory.annotation.Value
import org.springframework.boot.test.SpringApplicationContextLoader
import org.springframework.boot.test.WebIntegrationTest
import org.springframework.test.context.ContextConfiguration

@ContextConfiguration(loader = SpringApplicationContextLoader,
        classes = [MasterSpringMvcApplication, StubTwitterSearchConfig])
@WebIntegrationTest(randomPort = true)
class IntegrationSpec extends GebSpec {

    @Value('${local.server.port}')
    int port

    Configuration createConf() {
        def configuration = super.createConf()
        configuration.baseUrl = "http://localhost:$port"
        configuration
    }

    def "User is redirected to the login page when not logged"() {
        when: "I navigate to the home page"
        go '/'
//        report 'navigation-redirection'

        then: "I am redirected to the profile page"
        $('h2', 0).text() == 'Login'
    }
}</pre></div><p>For the <a id="id496" class="indexterm"/>moment, it is very similar to FluentLenium. We can already<a id="id497" class="indexterm"/> see the <code class="literal">$</code> function, which will allow us to grab a DOM element via its selector. Here, we also state that we want the first <code class="literal">h2</code> in the page by giving the <code class="literal">0</code> index.</p></div><div class="section" title="Page Objects with Geb"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec63"/>Page Objects with Geb</h2></div></div></div><p>Page objects with Geb are a real pleasure to work with. We will create the same page objects that we <a id="id498" class="indexterm"/>did previously so that you can appreciate the differences.</p><p>With Geb, the<a id="id499" class="indexterm"/> Page Objects must inherit from the <code class="literal">geb.Page</code> class. First, let's create the <code class="literal">LoginPage</code>. I suggest avoiding putting it in the same package as the previous one. I created a package called <code class="literal">geb.pages</code>:</p><div class="informalexample"><pre class="programlisting">package geb.pages

import geb.Page

class LoginPage extends Page {

    static url = '/login'
    static at = { $('h2', 0).text() == 'Login' }
    static content = {
        twitterSignin { $('button', name: 'twitterSignin') }
    }

    void loginWithTwitter() {
        twitterSignin.click()
    }
}</pre></div><p>Then <a id="id500" class="indexterm"/>we <a id="id501" class="indexterm"/>can create the <code class="literal">ProfilePage</code>:</p><div class="informalexample"><pre class="programlisting">package geb.pages

import geb.Page

class ProfilePage extends Page {

    static url = '/profile'
    static at = { $('h2', 0).text() == 'Your profile' }
    static content = {
        addTasteButton { $('button', name: 'addTaste') }
        saveButton { $('button', name: 'save') }
    }

    void fillInfos(String twitterHandle, String email, String birthDate) {
        $("#twitterHandle") &lt;&lt; twitterHandle
        $("#email") &lt;&lt; email
        $("#birthDate") &lt;&lt; birthDate
    }

    void addTaste(String taste) {
        addTasteButton.click()
        $("#tastes0") &lt;&lt; taste
    }

    void saveProfile() {
        saveButton.click();
    }
}</pre></div><p>This is basically the same page as before. Note the little <code class="literal">&lt;&lt;</code> to assign values to an input element. You could also call <code class="literal">setText</code> on them.</p><p>The <code class="literal">at</code> method is completely part of the framework, and Geb will automatically assert those when you navigate to the corresponding page.</p><p>Let's create the <code class="literal">SearchResultPage</code>:</p><div class="informalexample"><pre class="programlisting">package geb.pages

import geb.Page

class SearchResultPage extends Page {
    static url = '/search'
    static at = { $('h2', 0).text().startsWith('Tweet results for') }
    static content = {
        resultList { $('ul.collection') }
        results { resultList.find('li') }
    }
}</pre></div><p>It's a bit shorter, thanks<a id="id502" class="indexterm"/> to the ability to reuse previously defined content for the results.</p><p>With out the<a id="id503" class="indexterm"/> Page Object set up, we can write the test as follows:</p><div class="informalexample"><pre class="programlisting">import geb.Configuration
import geb.pages.LoginPage
import geb.pages.ProfilePage
import geb.pages.SearchResultPage
import geb.spock.GebSpec
import masterSpringMvc.MasterSpringMvcApplication
import masterSpringMvc.auth.StubSocialSigninConfig
import masterSpringMvc.search.StubTwitterSearchConfig
import org.springframework.beans.factory.annotation.Value
import org.springframework.boot.test.SpringApplicationContextLoader
import org.springframework.boot.test.WebIntegrationTest
import org.springframework.test.context.ContextConfiguration

@ContextConfiguration(loader = SpringApplicationContextLoader,
        classes = [MasterSpringMvcApplication, StubTwitterSearchConfig, StubSocialSigninConfig])
@WebIntegrationTest(randomPort = true)
class IntegrationSpec extends GebSpec {

    @Value('${local.server.port}')
    int port

    Configuration createConf() {
        def configuration = super.createConf()
        configuration.baseUrl = "http://localhost:$port"
        configuration
    }

    def "User is redirected to the login page when not logged"() {
        when: "I navigate to the home page"
        go '/'

        then: "I am redirected to the login page"
        $('h2').text() == 'Login'
    }

    def "User is redirected to its profile on his first visit"() {
        when: 'I am connected'
        to LoginPage
        loginWithTwitter()

        and: "I navigate to the home page"
        go '/'

        then: "I am redirected to the profile page"
        $('h2').text() == 'Your profile'
    }

    def "After filling his profile, the user is taken to result matching his tastes"() {
        given: 'I am connected'
        to LoginPage
        loginWithTwitter()

        and: 'I am on my profile'
        to ProfilePage

        when: 'I fill my profile'
        fillInfos("geowarin", "geowarin@mymail.com", "03/19/1987");
        addTaste("spring")

        and: 'I save it'
        saveProfile()

        then: 'I am taken to the search result page'
        at SearchResultPage
        page.results.size() == 2
    }
}</pre></div><p>My, what a <a id="id504" class="indexterm"/>beauty! You can certainly write your user stories directly with <a id="id505" class="indexterm"/>Geb!</p><p>With our simple tests, we only scratched the surface of Geb. There is much more functionality available, and I encourage you to read the <span class="emphasis"><em>Book of Geb</em></span>, a very fine piece of documentation <a id="id506" class="indexterm"/>available at <a class="ulink" href="http://www.gebish.org/manual/current/">http://www.gebish.org/manual/current/</a>.</p></div></div>
<div class="section" title="The check point"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec71"/>The check point</h1></div></div></div><p>In this chapter, we added a bunch of tests in <code class="literal">src/test/java</code>. I chose to go with Groovy, so I deleted the duplicated tests:</p><div class="mediaobject"><img src="graphics/2117_07_04.jpg" alt="The check point"/></div><p>In the <code class="literal">src/test/groovy</code> directory, I have refactored two tests as follows:</p><div class="mediaobject"><img src="graphics/2117_07_05.jpg" alt="The check point"/></div><p>In <code class="literal">src/integrationTest/groovy</code>, we have an integration test written with Geb:</p><div class="mediaobject"><img src="graphics/2117_07_06.jpg" alt="The check point"/></div><p>Finally, we added an <code class="literal">integrationTest</code> task to the Gradle build. Run <code class="literal">gradle clean test</code> and <code class="literal">gradle clean integrationTest</code> to make sure that all your tests pass.</p><p>If the build is successful, we are ready for the next chapter.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec72"/>Summary</h1></div></div></div><p>In this chapter, we've studied the differences between unit and integration tests.</p><p>We saw how testing is a healthy habit that will give us confidence in what we build and what we ship. It will save us money and spare some headaches in the long run.</p><p>Spring works well with classical JUnit tests written in Java, and it has first-class support for integration tests. But we can also easily use other languages, such as Groovy, to make the tests more readable and easier to write.</p><p>Testing is undeniably one of the strongest points of the Spring framework and one of the main reasons to use dependency injection in the first place.</p><p>Stay tuned for the next chapter, where we will optimize our application so that it is ready to be deployed in the cloud!</p></div></body></html>