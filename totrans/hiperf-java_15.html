<html><head></head><body>
		<div id="_idContainer045">
			<h1 class="chapter-number" id="_idParaDest-289"><a id="_idTextAnchor288"/>15</h1>
			<h1 id="_idParaDest-290"><a id="_idTextAnchor289"/>Optimizing Your Database and SQL Queries</h1>
			<p>Databases are a key component of large software systems. These systems constantly retrieve and update data using database connections and queries. The scale of data in modern systems is extremely large, resulting in more data to query, update, and display. This increased scale can result in negative performance issues for our Java application, underscoring the significance of ensuring our databases and queries <span class="No-Break">are optimized.</span></p>
			<p>This chapter examines critical database design concepts, including database schemas, indexing strategies, and data partitioning techniques. Database queries are also examined, with a specific focus on <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) queries. Our coverage of query optimizations<a id="_idIndexMarker799"/> includes best practices for writing efficient queries, query execution planning, and advanced <span class="No-Break">SQL techniques.</span></p>
			<p>The chapter also covers advanced SQL techniques such as database configuration, performance monitoring, and database maintenance. The chapter ends with several real-world case studies that help demonstrate how to identify and resolve database-related performance issues in <span class="No-Break">existing systems.</span></p>
			<p>By the end of this chapter, you should have a foundational understanding of strategies to optimize your databases and database queries. Armed with this understanding, and leveraging your experience gained from hands-on exercises, you should be able to improve the performance of your Java applications that incorporate databases and <span class="No-Break">database queries.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li><span class="No-Break">Database design</span></li>
				<li>SQL <span class="No-Break">query optimizations</span></li>
				<li><span class="No-Break">Additional strategies</span></li>
				<li><span class="No-Break">Case studies</span></li>
			</ul>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor290"/>Database design</h1>
			<p>For new systems, we have <a id="_idIndexMarker800"/>the luxury of designing our databases with performance in mind. Our database’s design can have a significant impact on the efficiency of our SQL queries. In this section, we will examine key principles of database design, including schema, indexing, partitioning, <span class="No-Break">and sharding.</span></p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor291"/>Schema principles</h2>
			<p class="callout-heading">Database schema</p>
			<p class="callout">A database schema is the design of the database, serving as a blueprint to <span class="No-Break">create it.</span></p>
			<p>Before we create our database, we <a id="_idIndexMarker801"/>should create a <strong class="bold">schema</strong> to document how our <a id="_idIndexMarker802"/>data will be organized and to indicate how it is interrelated. Our goal is to design a schema that makes querying the database <span class="No-Break">more efficient.</span></p>
			<p>An early decision to make is whether our database will be <strong class="bold">normalized</strong> or <strong class="bold">denormalized</strong>. A denormalized database<a id="_idIndexMarker803"/> involves reducing the number of tables to decrease the complexity of queries. Conversely, normalization involves creating separate tables to eliminate duplicative data. Let’s look at <span class="No-Break">an example.</span></p>
			<p>The following table shows duplicative data for both the author and <span class="No-Break">publisher fields.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-7">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">BookID</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Author</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Title</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Publisher</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Price ($)</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>1</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">N. Anderson</span></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">Introduction </em><span class="No-Break"><em class="italic">to Zion</em></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Packt</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">65.99</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>2</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">N. Anderson</span></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">Illustrated History </em><span class="No-Break"><em class="italic">of Zion</em></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Packt</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">123.99</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>3</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">W. Rabbit</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><em class="italic">Astro Mechanics</em></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Packt</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">89.99</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>4</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">W. Rabbit</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><em class="italic">Gyro Machinery</em></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Forest Press</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">79.99</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 15.1 – A Denormalized table</p>
			<p>As you can see in the preceding table, there are two entries for two different authors, and one publisher is<a id="_idIndexMarker804"/> listed more than once. This is an unnormalized table. To normalize the table, we will create three tables, one each for the books, authors, <span class="No-Break">and publishers.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">BookID</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Title</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">AuthorID</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">PublisherID</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Price ($)</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>1</p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">Introduction </em><span class="No-Break"><em class="italic">to Zion</em></span></p>
						</td>
						<td class="No-Table-Style">
							<p>1</p>
						</td>
						<td class="No-Table-Style">
							<p>1</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">65.99</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>2</p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">Illustrated History </em><span class="No-Break"><em class="italic">of Zion</em></span></p>
						</td>
						<td class="No-Table-Style">
							<p>1</p>
						</td>
						<td class="No-Table-Style">
							<p>1</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">123.99</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>3</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><em class="italic">Astro Mechanics</em></span></p>
						</td>
						<td class="No-Table-Style">
							<p>2</p>
						</td>
						<td class="No-Table-Style">
							<p>1</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">89.99</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>4</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><em class="italic">Gyro Machinery</em></span></p>
						</td>
						<td class="No-Table-Style">
							<p>2</p>
						</td>
						<td class="No-Table-Style">
							<p>2</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">79.99</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 15.2 – The Books table</p>
			<p>The <strong class="source-inline">Books</strong> table references the <strong class="source-inline">AuthorID</strong> and <strong class="source-inline">PublisherID</strong> fields. Those are established in the following tables. Here is the <span class="No-Break"><strong class="source-inline">Authors</strong></span><span class="No-Break"> table:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table003">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">AuthorID</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Author</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>1</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">N. Anderson</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>2</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">W. Rabbit</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 15.3 – The Authors table</p>
			<p>Our final table is for <span class="No-Break">the </span><span class="No-Break"><strong class="bold">Publishers</strong></span><span class="No-Break">:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table004">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">PublisherID</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Publisher</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>1</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Packt</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>2</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Forest Press</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 15.4 – The Publishers table</p>
			<p>The decision to implement a normalized or denormalized database involves considering the complexity of queries, the size of your database, and the read-write load on <span class="No-Break">your database.</span></p>
			<p>Another important <a id="_idIndexMarker805"/>database design consideration is the data type for each of your columns. For example, it is appropriate to use an <strong class="bold">integer</strong> (<strong class="bold">INT</strong>) for our ID fields<a id="_idIndexMarker806"/> instead of a less efficient implementation. Here is how we would create our <strong class="source-inline">Authors</strong> table with appropriate data types <span class="No-Break">using SQL:</span></p>
			<pre class="source-code">
CREATE TABLE Authors {
  Author_ID INT,
  Author VARCHAR(80)
);</pre>			<p>After we have designed our database tables and decided on data types, we need to implement indexing. Let’s look at that in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-293"><a id="_idTextAnchor292"/>Indexing</h2>
			<p>We index our<a id="_idIndexMarker807"/> databases so that data can be found quickly. Our indexing strategy has a direct impact on our query performance, so due diligence is required. There are two types of indexing. The first type is <strong class="bold">balanced tree</strong> (<strong class="bold">B-tree</strong>), which is what is implemented in most <a id="_idIndexMarker808"/>databases. This type of index keeps data sorted and permits sequential access, insertions, <span class="No-Break">and deletions.</span></p>
			<p>The second type of database <a id="_idIndexMarker809"/>indexing is <strong class="bold">hash indexes</strong>. This type of indexing is ideal when equality comparisons are needed but is not adequate for <span class="No-Break">range queries.</span></p>
			<p>Index creation is simple and demonstrated by the following <span class="No-Break">SQL statement:</span></p>
			<pre class="source-code">
CREATE INDEX idx_authors_authorid ON Authors (AuthorID);</pre>			<p>If you have an existing database and frequently use <strong class="source-inline">WHERE</strong>, <strong class="source-inline">JOIN</strong>, <strong class="source-inline">ORDER BY</strong>, or <strong class="source-inline">GROUP BY</strong>, you can likely benefit from indexing. Let’s look at <span class="No-Break">an example.</span></p>
			<p>We could use the following SQL statement when we do not have <span class="No-Break">an index:</span></p>
			<pre class="source-code">
SELECT * FROM Authors WHERE Author = 'N. Anderson';</pre>			<p>The following SQL<a id="_idIndexMarker810"/> statement searches for the same author but uses <span class="No-Break">an index:</span></p>
			<pre class="source-code">
CREATE INDEX idx_authors_authorid ON Authors (AuthorID);
SELECT * FROM Authors WHERE Author = 'N. Anderson';</pre>			<p>Using the second example will provide results a bit faster than the non-indexed approach. Note that indexes do take up additional storage space and add additional processing overhead when using the <strong class="source-inline">INSERT</strong>, <strong class="source-inline">DELETE</strong>, and <span class="No-Break"><strong class="source-inline">UPDATE</strong></span><span class="No-Break"> operations.</span></p>
			<p>In the next section, we will examine partitioning and sharding as approaches to improve the efficiency of our database and <span class="No-Break">database queries.</span></p>
			<h2 id="_idParaDest-294"><a id="_idTextAnchor293"/>Partitioning and sharding</h2>
			<p>Partitioning and sharding are strategies used to improve the performance of large databases and their queries by dividing large datasets into <span class="No-Break">smaller components.</span></p>
			<h3>Partitioning</h3>
			<p>There are two types of partitioning, <strong class="bold">horizontal partitioning</strong> and <strong class="bold">vertical partitioning</strong>. Horizontal partitioning is accomplished by splitting tables into rows, and each horizontal partition contains<a id="_idIndexMarker811"/> a subset of those rows. A typical use case for this is creating a partition based on date ranges. The following example creates three<a id="_idIndexMarker812"/> tables, each with a specific year’s worth of <span class="No-Break">order information:</span></p>
			<pre class="source-code">
CREATE TABLE Book_Orders_2021 (
    CHECK (OrderDate &gt;= '2021-01-01' AND OrderDate &lt; '2022-01-01')
) INHERITS (Book_Orders);
CREATE TABLE Book_Orders_2022 (
    CHECK (OrderDate &gt;= '2022-01-01' AND OrderDate &lt; '2023-01-01')
) INHERITS (Book_Orders);
CREATE TABLE Book_Orders_2023 (
    CHECK (OrderDate &gt;= '2023-01-01' AND OrderDate &lt; '2024-01-01')
) INHERITS (Book_Orders);</pre>			<p>Vertical partitioning splits the<a id="_idIndexMarker813"/> database table into columns, each partition containing a <a id="_idIndexMarker814"/>subset of columns. To demonstrate vertical partitioning, let’s look at a <strong class="source-inline">Books</strong> table that has not <span class="No-Break">been partitioned:</span></p>
			<pre class="source-code">
CREATE TABLE Books (
    BookID INT PRIMARY KEY,
    Title VARCHAR(100),
    AuthorID INT,
    Pages INT,
    Genre VARCHAR(50),
    PublisherID INT,
    PublishedDate DATE,
    OriginalPrice DECIMAL(10, 2),
    DiscountPrice DECIMAL(10, 2)
);</pre>			<p>Now, using vertical partitioning, let’s create two tables, each with a subset <span class="No-Break">of columns:</span></p>
			<pre class="source-code">
CREATE TABLE Books_CatalogData (
    BookID INT PRIMARY KEY,
    Title VARCHAR(100),
    AuthorID INT,
    Pages INT,
    Genre VARCHAR(50),
    PublisherID INT,
    PublishedDate DATE,
);
CREATE TABLE Books_SalesData (
    BookID INT PRIMARY KEY,
    OriginalPrice DECIMAL(10, 2),
    DiscountPrice DECIMAL(10, 2),
    FOREIGN KEY (BookID) REFERENCES Books_CatalogData(BookID)
);</pre>			<p>By splitting our table into two <a id="_idIndexMarker815"/>partitions, we can search more efficiently, since<a id="_idIndexMarker816"/> we do not need to process any unrelated data (i.e., when searching the catalog data, we are not concerned with <span class="No-Break">sales data).</span></p>
			<p>Let’s now look at another strategy to increase the efficiency of our databases, <span class="No-Break">called sharding.</span></p>
			<h3>Sharding</h3>
			<p><strong class="bold">Sharding</strong> is the process of <a id="_idIndexMarker817"/>distributing our data over multiple servers, moving the data closer to users. This strategy has<a id="_idIndexMarker818"/> two primary benefits – moving the data to servers closer to users reduces network latency and the load on individual servers. A common use case is to shard based on geographic region. Here is an example of<a id="_idIndexMarker819"/> how we can <span class="No-Break">accomplish that:</span></p>
			<pre class="source-code">
CREATE TABLE Users_US (
    UserID INT PRIMARY KEY,
    UserName VARCHAR(100),
    Region CHAR(2) DEFAULT 'US'
);
CREATE TABLE Users_EU (
    UserID INT PRIMARY KEY,
    UserName VARCHAR(100),
    Region CHAR(2) DEFAULT 'EU'
);</pre>			<p>The preceding example creates two tables. The next step would be to store each table on <span class="No-Break">different servers.</span></p>
			<p>A purposeful approach to partitioning <a id="_idIndexMarker820"/>and sharding can result in a performance-ready database design. It can make your SQL queries more efficient, thereby improving the overall performance of your <span class="No-Break">Java application.</span></p>
			<h1 id="_idParaDest-295"><a id="_idTextAnchor294"/>Query optimizations</h1>
			<p>Now that we have a basic understanding of how to design our databases with performance in mind, we are<a id="_idIndexMarker821"/> ready to look at best practices for writing efficient queries. We will also look at query execution plans and some advanced SQL techniques. To make our example SQL statements relatable, we will use a book inventory and order processing database throughout <span class="No-Break">this section.</span></p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor295"/>Query execution</h2>
			<p>Understanding how <a id="_idIndexMarker822"/>queries are handled by our database is key to being able to <a id="_idIndexMarker823"/><span class="No-Break">optimize them.</span></p>
			<p class="callout-heading">A query execution plan</p>
			<p class="callout">A query execution plan provides details on how a database engine <span class="No-Break">executes queries</span></p>
			<p>A query execution plan<a id="_idIndexMarker824"/> includes details on database query operations, such as joins and sorts. Let’s look at a simple <a id="_idIndexMarker825"/>query that gives us a specific book’s <span class="No-Break">total sales:</span></p>
			<pre class="source-code">
FROM Orders o
JOIN Books b ON o.BookID = b.BookID
WHERE b.Title = 'High Performance with Java';</pre>			<p>Now, let’s add an <strong class="source-inline">EXPLAIN</strong> command to the same query to reveal the steps the database engine follows to execute <span class="No-Break">our query:</span></p>
			<pre class="source-code">
EXPLAIN SELECT SUM(o.Qty * o.Price) AS TotalSales
FROM Orders o
JOIN Books b ON o.BookID = b.BookID
WHERE b.Title = 'High Performance with Java';</pre>			<p>By viewing the query execution plan, we can identify potential bottlenecks, providing us with an opportunity to further optimize our database <span class="No-Break">and queries.</span></p>
			<p>Next, let’s look at some best practices for writing <span class="No-Break">efficient queries.</span></p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor296"/>Best practices</h2>
			<p>Our goals when writing SQL queries are to minimize resource use and reduce execution time. To achieve these<a id="_idIndexMarker826"/> goals, we should follow best practices, including the<a id="_idIndexMarker827"/> ones detailed as follows<a id="_idIndexMarker828"/> for the <strong class="source-inline">SELECT</strong> statement, <strong class="source-inline">JOIN</strong> operations, <strong class="bold">subqueries</strong>, and <strong class="bold">common table </strong><span class="No-Break"><strong class="bold">expressions</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CTEs</strong></span><span class="No-Break">).</span></p>
			<h3>SELECT statement</h3>
			<p>There are three best practices<a id="_idIndexMarker829"/> involved with using the <strong class="source-inline">SELECT</strong> statement. First, we should avoid using <strong class="source-inline">SELECT *</strong> and only specify the<a id="_idIndexMarker830"/> columns we need. For example, instead of using <strong class="source-inline">SELECT * FROM Books;</strong>, use <strong class="source-inline">SELECT Title, AuthorID, Genre </strong><span class="No-Break"><strong class="source-inline">FROM Books;</strong></span><span class="No-Break">.</span></p>
			<p>Another best practice is to use the <strong class="source-inline">WHERE</strong> clause to narrow down our results to the maximum extent possible. Here is <span class="No-Break">an example:</span></p>
			<pre class="source-code">
SELECT Title, AuthorID, Genre FROM Books WHERE Genre = 'Non-Fiction';</pre>			<p>A third best practice for <a id="_idIndexMarker831"/>using the <strong class="source-inline">SELECT</strong> statement is to limit the number of rows returned by our query. We can use the <strong class="source-inline">LIMIT</strong> clause, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
SELECT Title, AuthorID, Genre FROM Books WHERE Genre = 'Non-Fiction' LIMIT 10;</pre>			<p>The three best practices for working with the <strong class="source-inline">SELECT</strong> statement are key to improving the efficiency of our queries. Next, let’s look at best practices for using <span class="No-Break"><strong class="source-inline">JOIN</strong></span><span class="No-Break"> operations.</span></p>
			<h3>JOIN operations</h3>
			<p>There are two best practices for <a id="_idIndexMarker832"/>using <strong class="source-inline">JOIN</strong> operations. First, we<a id="_idIndexMarker833"/> should ensure that all columns used in <strong class="source-inline">JOIN</strong> conditions are indexed. This will improve the efficiency of <span class="No-Break">these operations.</span></p>
			<p>Another best practice is to use the appropriate <strong class="source-inline">JOIN</strong> type, as indicated in the <span class="No-Break">following table.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table005">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Type</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Purpose</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">INNER JOIN</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to <span class="No-Break">match rows</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">LEFT JOIN</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>To include all rows from the <span class="No-Break">left table</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">RIGHT JOIN</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>To include all rows from the <span class="No-Break">right table</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 15.5: JOIN type and its purpose</p>
			<p>Next, let’s look at the concept of subqueries and their related <span class="No-Break">best practices.</span></p>
			<h3>Subqueries</h3>
			<p>As the title suggests, <strong class="bold">subqueries</strong> are used to break<a id="_idIndexMarker834"/> a complex query into multiple, simpler queries. Here is <a id="_idIndexMarker835"/><span class="No-Break">an example:</span></p>
			<pre class="source-code">
SELECT b.Title, b.Genre
FROM Books b
WHERE b.BookID IN (SELECT o.BookID FROM Orders o WHERE o.Qty &gt; 100);</pre>			<p>Next, let’s look <span class="No-Break">at CTEs.</span></p>
			<h3>CTEs</h3>
			<p>CTEs can be used to <a id="_idIndexMarker836"/>make complex queries more readable. This <a id="_idIndexMarker837"/>increases their reusability and eases their maintainability. Here is <span class="No-Break">an example:</span></p>
			<pre class="source-code">
WITH HighSales AS (
    SELECT BookID, SUM(Qty) AS TotalQty
    FROM Orders
    GROUP BY BookID
    HAVING SUM(Qty) &gt; 100
)
SELECT b.Title, b.Genre
FROM Books b
JOIN HighSales hs ON b.BookID = hs.BookID;</pre>			<p>Now that we have reviewed several best practices for writing queries, let’s look at some advanced <span class="No-Break">SQL techniques.</span></p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor297"/>Advanced SQL techniques</h2>
			<p>This section demonstrates<a id="_idIndexMarker838"/> three advanced SQL <a id="_idIndexMarker839"/>techniques – window functions, recursive queries, and temporary tables <span class="No-Break">and views.</span></p>
			<h3>Window functions</h3>
			<p>A <strong class="bold">window function</strong> is used to <a id="_idIndexMarker840"/>calculate across a set of rows related to<a id="_idIndexMarker841"/> a current row. Here is <span class="No-Break">an example:</span></p>
			<pre class="source-code">
SELECT BookID, Title, Genre,
      SUM(Quantity) OVER (PARTITION BY Genre) AS TotalSalesByGenre
FROM Books b
JOIN Orders o ON b.BookID = o.BookID;</pre>			<h3>Recursive queries</h3>
			<p>Recursive queries are <a id="_idIndexMarker842"/>complicated and can be useful when you have<a id="_idIndexMarker843"/> hierarchical data, such as book categories and subcategories. Here is <span class="No-Break">an example:</span></p>
			<pre class="source-code">
WITH RECURSIVE CategoryHierarchy AS (
    SELECT CategoryID, CategoryName, ParentCategoryID
    FROM Categories
    WHERE ParentCategoryID IS NULL
    UNION ALL
    SELECT c.CategoryID, c.CategoryName, c.ParentCategoryID
    FROM Categories c
    JOIN CategoryHierarchy ch ON c.ParentCategoryID = ch.CategoryID
)
SELECT * FROM CategoryHierarchy;</pre>			<h3>Temporary tables and views</h3>
			<p>Another advanced technique is to<a id="_idIndexMarker844"/> use temporary tables and views to <a id="_idIndexMarker845"/>achieve better performance and help manage complex queries. Here is an example of a <span class="No-Break">temporary table:</span></p>
			<pre class="source-code">
CREATE TEMPORARY TABLE TempHighSales AS
SELECT BookID, SUM(Qty) AS TotalQty
FROM Orders
GROUP BY BookID
HAVING SUM(Qty) &gt; 100;
SELECT b.Title, b.Genre
FROM Books b
JOIN TempHighSales ths ON b.BookID = ths.BookID;</pre>			<p>The following SQL statement is an example of a <span class="No-Break">temporary view:</span></p>
			<pre class="source-code">
CREATE VIEW HighSalesView AS
SELECT BookID, SUM(Qty) AS TotalQty
FROM Orders
GROUP BY BookID
HAVING SUM(Qty) &gt; 100;
SELECT b.Title, b.Genre
FROM Books b
JOIN HighSalesView hsv ON b.BookID = hsv.BookID;</pre>			<p>Experimenting with the advanced techniques presented in this section can improve your ability to write efficient <a id="_idIndexMarker846"/>queries, contributing to the<a id="_idIndexMarker847"/> overall performance of your <span class="No-Break">Java application.</span></p>
			<h1 id="_idParaDest-299"><a id="_idTextAnchor298"/>Additional strategies</h1>
			<p>So far, this chapter has covered designing a database schema for efficiency and how to write efficient SQL queries. There are several additional strategies we can employ, including fine-tuning, monitoring, and maintenance. Each of these strategies is explored in this section and uses the same book inventory and ordering example from the <span class="No-Break">previous section.</span></p>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor299"/>Fine-tuning</h2>
			<p>We can fine-tune our database server’s configuration parameters to ensure that our queries make efficient use of resources. This fine-tuning can <a id="_idIndexMarker848"/>be categorized <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Database </strong><span class="No-Break"><strong class="bold">server parameters</strong></span></li>
				<li><strong class="bold">Memory allocation</strong>: It is important to ensure we allocate sufficient memory for buffering and caching. For example, we can adjust the <strong class="source-inline">innodb_buffer_pool_size</strong> parameter in MySQL with the <strong class="source-inline">SET shared_buffers = '3GB';</strong> <span class="No-Break">SQL statement.</span></li>
				<li><strong class="bold">Connection pooling</strong>: As detailed in <a href="B21942_10.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Connection Pooling</em>, we can pool our database connections to reduce overhead and improve overall <span class="No-Break">application performance.</span></li>
				<li><strong class="bold">Query caching</strong>: Query caching can be used to store the results of commonly executed queries. Using an SQL statement such as <strong class="source-inline">SET query_cache_size = 256MB';</strong> will enable <span class="No-Break">query caching.</span></li>
				<li><span class="No-Break"><strong class="bold">Memory management</strong></span></li>
				<li><strong class="bold">Database caching</strong>: We can cache databases to speed up read operations for frequently accessed data. Tools <a id="_idIndexMarker849"/>such as <strong class="bold">Redis</strong> can be used to aid in <span class="No-Break">this technique.</span></li>
			</ul>
			<p>Next, let’s explore how we can monitor and profile our <span class="No-Break">database’s performance.</span></p>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor300"/>Database performance monitoring</h2>
			<p>Once our database is up and running and all our queries are established, we are ready to monitor our database’s<a id="_idIndexMarker850"/> performance. Monitoring can help us identify potential bottlenecks and allow us to make refinements to improve <span class="No-Break">overall performance.</span></p>
			<p>A proven approach to identify bottlenecks is <a id="_idIndexMarker851"/>to enable <strong class="bold">slow query logging</strong>. This can help us identify which queries take longer than we desire to execute. Here is how this can <span class="No-Break">be enabled:</span></p>
			<pre class="source-code">
SET long_query_time = 1;
SET slow_query_log = 'ON';</pre>			<p>The use of query profiling tools can help us analyze and optimize slow queries. There are various tools available, depending on your database type <span class="No-Break">and service.</span></p>
			<p>Monitoring and profiling can help identify opportunities for refinement. In the next section, we will explore <span class="No-Break">database maintenance.</span></p>
			<h2 id="_idParaDest-302"><a id="_idTextAnchor301"/>Database maintenance</h2>
			<p>Databases are dynamic and <a id="_idIndexMarker852"/>need to be maintained with regularly scheduled maintenance. This is a proactive, vice reactive approach to maintaining your databases. Here are <span class="No-Break">some tips:</span></p>
			<ul>
				<li>Regularly run <strong class="source-inline">VACUUM</strong> to <span class="No-Break">reclaim storage.</span></li>
				<li>After each run of <strong class="source-inline">VACUUM</strong>, run <strong class="source-inline">ANALYZE</strong> so that the query planner has <span class="No-Break">updated statistics.</span></li>
				<li>Use <strong class="source-inline">REINDEX</strong> to periodically reindex your database. This will improve <span class="No-Break">query performance.</span></li>
				<li>Archive old data that is no longer needed. You can partition this data into a <span class="No-Break">historical database.</span></li>
				<li>Purge data that is not needed. This will free up storage and should improve <span class="No-Break">query performance.</span></li>
			</ul>
			<p>The strategies presented in this section can help you further enhance your query performance, the database performance, and the overall performance of your Java application. These strategies are especially important for large databases and those with high <span class="No-Break">transaction rates.</span></p>
			<p>In the next section, we <a id="_idIndexMarker853"/>will review several real-world case studies to help you contextualize the concepts presented in <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-303"><a id="_idTextAnchor302"/>Case studies</h1>
			<p>This section presents three<a id="_idIndexMarker854"/> real-world case studies using the book inventory and order processing database featured throughout this chapter. A review of the case studies will demonstrate how the strategies and techniques presented in this chapter can be used to solve common database <span class="No-Break">performance problems.</span></p>
			<p>Each case study is presented in the <span class="No-Break">following format:</span></p>
			<ul>
				<li><span class="No-Break">The scenario</span></li>
				<li>The initial <span class="No-Break">SQL query</span></li>
				<li><span class="No-Break">The problem</span></li>
				<li>The <span class="No-Break">optimization steps</span></li>
				<li><span class="No-Break">The result</span></li>
			</ul>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor303"/>Case study 1</h2>
			<p><strong class="bold">Scenario</strong>: Every time the bookstore’s administrator runs the sales report, it takes several minutes – much longer than it should. The report simply summarizes total sales by title. The database schema is the same as the one presented earlier in <span class="No-Break">this chapter.</span></p>
			<p><strong class="bold">Initial </strong><span class="No-Break"><strong class="bold">SQL query</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
SELECT b.Title, SUM(o.Qty * o.Price) AS TotalSales
FROM Orders o
JOIN Books b ON o.BookID = b.BookID
GROUP BY b.Title;</pre>			<p><strong class="bold">Problem</strong>: The query performs a full table scan of both the <strong class="source-inline">Books</strong> and <strong class="source-inline">Orders</strong> tables. This results in <span class="No-Break">slow performance.</span></p>
			<p><span class="No-Break"><strong class="bold">Optimization steps</strong></span><span class="No-Break">:</span></p>
			<ol>
				<li>The database administrator<a id="_idIndexMarker855"/> added indexes to the <strong class="source-inline">BookID</strong> columns in both the <strong class="source-inline">Books</strong> and <span class="No-Break"><strong class="source-inline">Orders</strong></span><span class="No-Break"> tables:</span><pre class="source-code">
CREATE INDEX idx_books_bookid ON Books (BookID);
CREATE INDEX idx_orders_bookid ON Orders (BookID);</pre></li>				<li>The query was refined to only include columns that were needed to retrieve the <span class="No-Break">desired data:</span><pre class="source-code">
EXPLAIN ANALYZE
SELECT b.Title, SUM(o.Qty * o.Price) AS TotalSales
FROM Orders o
JOIN Books b ON o.BookID = b.BookID
GROUP BY b.Title;</pre></li>			</ol>
			<p><strong class="bold">Result</strong>: The execution plan, revealed by using the <strong class="source-inline">EXPLAIN ANALYZE</strong> command, showed a significant query time reduction. The sales report now runs in less than <span class="No-Break">one minute.</span></p>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor304"/>Case study 2</h2>
			<p><strong class="bold">Scenario</strong>: The database has grown exponentially, and the <strong class="source-inline">Orders</strong> table now contains millions of records. Running queries for specific years is <span class="No-Break">extremely slow.</span></p>
			<p><strong class="bold">Initial </strong><span class="No-Break"><strong class="bold">SQL query</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
SELECT * FROM Orders WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31';</pre>			<p><strong class="bold">Problem</strong>: The query performs a full table scan, which results in <span class="No-Break">slow performance.</span></p>
			<p><span class="No-Break"><strong class="bold">Optimization steps</strong></span><span class="No-Break">:</span></p>
			<ol>
				<li>The database administrator performed horizontal partitioning, creating tables for <span class="No-Break">each year:</span><pre class="source-code">
CREATE TABLE Orders_2023 (
    CHECK (OrderDate &gt;= '2023-01-01' AND OrderDate &lt; '2024-01-
    01')
) INHERITS (Orders);
CREATE TABLE Orders_2024 (
    CHECK (OrderDate &gt;= '2024-01-01' AND OrderDate &lt; '2025-01-
    01')
) INHERITS (Orders);</pre></li>				<li>After partitioning the data, the administrator updated the queries to target the <span class="No-Break">specific partitions:</span><pre class="source-code">
SELECT * FROM Orders_2023 WHERE OrderDate BETWEEN '2023-01-01' AND '2023-12-31';</pre></li>			</ol>
			<p><strong class="bold">Result</strong>: The query performance<a id="_idIndexMarker856"/> significantly improved, running at a fraction of the <span class="No-Break">previous time.</span></p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor305"/>Case study 3</h2>
			<p><strong class="bold">Scenario</strong>: The bookstore has a web application that is used to display book data on product pages. The repeated querying of the <strong class="source-inline">Books</strong> table resulted in a significant and unnecessary load on <span class="No-Break">the database.</span></p>
			<p><strong class="bold">Initial </strong><span class="No-Break"><strong class="bold">SQL query</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
SELECT * FROM Books WHERE BookID = 1;</pre>			<p><strong class="bold">Problem</strong>: Identical queries were repeatedly sent to the database, creating a high load and slow <span class="No-Break">response time.</span></p>
			<p><strong class="bold">Optimization step</strong>: The database administrator used <strong class="bold">Redis</strong> to cache <span class="No-Break">book details.</span></p>
			<p><strong class="bold">Result</strong>: The database load was significantly reduced, and the response times were <span class="No-Break">drastically shorter.</span></p>
			<h1 id="_idParaDest-307"><a id="_idTextAnchor306"/>Summary</h1>
			<p>This chapter explored essential strategies and techniques to optimize databases and SQL queries. The chapter’s overall aim was to introduce database-related enhancements and best practices to improve the performance of your data-driven applications. We began with the fundamentals of database design, including schema normalization, appropriate indexing, and partitioning strategies. We then explored how to write efficient SQL queries. Our coverage also included query execution plans and leveraging advanced SQL techniques, such as window functions and recursive queries. Additional strategies, including database configuration, monitoring, profiling, and regular maintenance, were also discussed. The chapter ended with real-world case studies to demonstrate the practical application of the strategies and techniques covered in the chapter. You should now be confident in implementing these best practices and ensuring your database systems can handle large datasets and complex queries <span class="No-Break">with ease.</span></p>
			<p>In the next chapter, we will examine the concepts of code monitoring and code maintenance, with an ever-vigilant eye on the high performance of our Java applications. Our approaches to code monitoring and maintenance will include conducting code reviews to identify potential performance issues before they become problematic. Specifically, we will look at <strong class="bold">application performance management</strong> (<strong class="bold">APM</strong>) tools, code reviews, log analysis, and <span class="No-Break">continuous improvement.</span></p>
		</div>
	</body></html>