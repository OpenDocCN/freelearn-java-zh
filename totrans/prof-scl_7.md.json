["```java\ncase class Person(var name: String, var age: Int)\n\ndef birthday(p: Person) = p.age += 1\n\ndef getName(p: Person) = {\n  println(s\"Getting the name of ${p.name}\")\n  p.name\n}\n\ndef rename(p: Person, name: String) = \n  Person(name, p.age)\n```", "```java\nval p = Person(\"Jack\", 41)\nbirthday(p)\nprintln(p) // prints Person(Jack,42)\nbirthday(p)\nprintln(p) // prints Person(Jack,43)\n```", "```java\nval n1 = getName(p) // Getting the name of Jack\nval n2 = getName(p) // Getting the name of Jack\nprintln(n1) // Jack\nprintln(n2) // Jack\n```", "```java\nval r1 = rename(p, \"John\")\nval r2 = rename(p, \"John\")\nprintln(r1) // Person(John,43)\nprintln(r2) // Person(John,43)\n```", "```java\n    scala> val x = \"test\"\n    x: String = test\n\n    scala> x = \"test 2\"\n    <console>:12: error: reassignment to val\n           x = \"test 2\"\n    ```", "```java\n    scala> case class Person(var name: String)\n    defined class Person\n\n    scala> val p = Person(\"Jack\")\n    p: Person = Person(Jack)\n\n    scala> p.name\n    res0: String = Jack\n    scala> p.name = \"John\"\n    p.name: String = John\n\n    scala> p\n    res1: Person = Person(John)\n    ```", "```java\nscala> val xs = List(1,2,3)\nxs: List[Int] = List(1, 2, 3)\n\nscala> xs.reverse\nres0: List[Int] = List(3, 2, 1)\nscala> xs\nres1: List[Int] = List(1, 2, 3)\n```", "```java\nscala> val xs = List(1,2,3,4,5)\nxs: List[Int] = List(1, 2, 3, 4, 5)\n\nscala> xs.map(_ * 2)\nres0: List[Int] = List(2, 4, 6, 8, 10)\n```", "```java\ndef negate[A](f: A => Boolean): A => Boolean =\n  (a: A) => !f(a)\n```", "```java\ndef sndWhere[A](xs: List[A])(pred: A => Boolean): Option[A] = ???\n```", "```java\nprintln(sndWhere(List(1,3,2,4,4))(_ > 2)) // Some(4)\nprintln(sndWhere(List(1,3,2,4,4))(_ > 10)) // None\n```", "```java\n    object HOExample extends App {\n      def sndWhere[A](xs: List[A])(pred: A => Boolean): Option[A] = ???\n      println(sndWhere(List(1, 3, 2, 4, 4))(_ > 2)) // Some(4)\n      println(sndWhere(List(1, 3, 2, 4, 4))(_ > 10)) // None\n    }\n    ```", "```java\n    Some(4) \n    None\n    ```", "```java\n      def sndWhere[A](xs: List[A])(pred: A => Boolean): Option[A] =  \n\n        xs.filter(pred) match { \n\n          case _ :: snd :: _ => Some(snd) \n\n          case _             => None \n\n        }\n    ```", "```java\ntrait Monoid[A] {\n  def combine(x: A, y: A): A\n  def empty: A\n}\n```", "```java\n    implicit val strMonoid = new Monoid[String] {\n      def combine(x: String, y: String): String = x + y\n     def empty: String = \"\"\n    }\n    ```", "```java\n    strMonoid.combine(\"Monoids are \", \"great\")\n    strMonoid.combine(\"Hello\", strMonoid.empty)\n    ```", "```java\n    implicit val intMonoid = new Monoid[Int] {\n        def combine(x: Int, y: Int): Int = x + y\n        def empty: Int = 0\n      }\n    ```", "```java\n    implicit def listMonoid[A]: Monoid[List[A]] = \n      new Monoid[List[A]] {\n       def combine(x: List[A], y: List[A]): List[A] = ???\n        def empty: List[A] = ???\n      }\n    ```", "```java\ndef sum[A](xs: List[A])(implicit m: Monoid[A]): A = xs.foldLeft(m.empty)(m.combine)\n```", "```java\nsum(List(\"Monoids\", \" are\", \" cool\")) // \"Monoids are cool\"\nsum(List(1,2,3)) // 6\nsum(List(List(1,2),List(3,4)) // List(1,2,3,4)\n```", "```java\ntrait Functor[F[_]] {\n  def map[A, B](fa: F[A])(f: A => B): F[B]\n}\n```", "```java\n    def compute[F[_]](fa: F[Int])(implicit f: Functor[F]): F[Int] = {\n     val fx = f.map(fa) { _ + 2 }\n      f.map(fx) { _ * 2}\n    }\n    ```", "```java\n    compute(List(1,2,3)) // List(6, 8, 10)compute(Option(2) // Some(8)\n    compute(Right(2): Either[String, Int]) // Right(8)\n    ```", "```java\n    implicit val listFunctor = new Functor[List] {\n      def map[A, B](fa: List[A])(f: A => B): List[B] = fa.map(f)\n    }\n    ```", "```java\n    listFunctor.map(List(1,2,3))(_ * 2)\n    ```", "```java\n     implicit val optionFunctor = new Functor[Option] {\n        def map[A, B](fa: Option[A])(f: A => B): Option[B] = fa match {\n          case None => None\n          case Some(x) => Some(f(x))\n        }\n    ```", "```java\ntrait Monad[F[_]] extends Functor[F] {\n  def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B]\n  def pure[A](x: A): F[A]\ndef map[A, B](fa: F[A])(f: A => B): F[B] =\n    flatMap(fa)(f andThen pure)\n}\n```", "```java\nOption(10).map(_ + 1).map(_ * 4)\nres3: Option[Int] = Some(44)\n```", "```java\ndef big(i: Int): Option[Int] = \n  if (i > 5) Some(i) \n  else None\n\nbig(10).map(_ - 5).map(big)\nres3: Option[Option[Int]] = Some(None)\n```", "```java\nimplicit val optionMonad = new Monad[Option] {\n  def pure[A](x: A): Option[A] = Some(x)\n  def flatMap[A, B](fa: Option[A])(f: A => Option[B]): Option[B] = fa match {\n    case Some(x) => f(x)\n    case None => None\n  }\n}\n```", "```java\nflatMap(map(big(10))(_ - 5))(big)\n```", "```java\n    name := \"cats-example\"\n\n    scalaVersion := \"2.12.4\"\n    libraryDependencies += \"org.typelevel\" %% \"cats-core\" % \"1.0.0\"\n\n    scalacOptions ++= Seq(\n      \"-Xfatal-warnings\",\n      \"-Ypartial-unification\"\n    )\n    ```", "```java\n    import cats._\n    import cats.implicits._\n    ```", "```java\nfinal case class User(\n  username: String,\n  age: Int\n)\n```", "```java\nsealed trait Error {\n  def message: String\n}\n\ncase object SpecialCharacters extends Error {\n  val message: String = \"Value can't contain special characters\"\n}\n\ncase object TooShort extends Error {\n  val message: String = \"Value is too short\"\n}\n\ncase object ValueTooLow extends Error {\n  val message: String = \"Value is too low\"\n}\n```", "```java\nsealed abstract class Validated[+E, +A] extends Product with Serializable\nfinal case class Valid[+A](a: A) extends Validated[Nothing, A]\nfinal case class Invalid[+E](e: E) extends Validated[E, Nothing]\n```", "```java\ndef validateAge(age: Int): Validated[NonEmptyList[Error], Int] =\n    if (age >= 1) age.validNel\n    else ValueTooLow.invalidNel\n```", "```java\nprivate def checkLength(str: String): Validated[NonEmptyList[Error], String] =\n  if (str.length > 3) str.validNel\n  else TooShort.invalidNel\n\nprivate def checkSpecialCharacters(str: String): Validated[NonEmptyList[Error], String] =\n  if (str.matches(\"^[a-zA-Z]+$\")) str.validNel\n  else SpecialCharacters.invalidNel\n\ndef validateUsername(username: String): Validated[NonEmptyList[Error], String] =\n  (checkLength(username), checkSpecialCharacters(username)).mapN { \n    case (a, _) => a \n  }\n```", "```java\ndef validate(username: String, age: Int) =\n    (validateUsername(username), validateAge(age)).mapN { User.apply }\n```", "```java\nUser.validate(\"!!\", -1)\n// Invalid(NonEmptyList(TooShort, SpecialCharacters, ValueTooLow))\n\nUser.validate(\"jack\", 42)\n// Valid(User(jack,42))\n```", "```java\nscalaVersion := \"2.12.4\"\n\nlazy val doobieVersion = \"0.5.0-M13\"\n\nlibraryDependencies ++= Seq(\n  \"org.tpolecat\" %% \"doobie-core\"   % doobieVersion,\n  \"org.tpolecat\" %% \"doobie-h2\"     % doobieVersion\n)\n```", "```java\nCREATE TABLE user (\n  userId INT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(255) NOT NULL,\n  age INT NOT NULL\n);\n\nCREATE TABLE todo (\n  todoId INT AUTO_INCREMENT PRIMARY KEY,\n  userId INT NOT NULL,\n  title VARCHAR(255) NOT NULL,\n  completed BOOL DEFAULT false,\n  FOREIGN KEY (userId) references user(userId)\n);\n```", "```java\npackage com.example\n\nimport doobie._\nimport doobie.implicits._\nimport cats.effect.IO\n\nobject ExampleConnection extends App {\n\n  val transactor =\n    Transactor.fromDriverManager[IO](\n      \"org.h2.Driver\", \"jdbc:h2:mem:test\", \"\", \"\"\n    )\n val program: ConnectionIO[Int] =\n    sql\"select 42\".query[Int].unique\n\n  val task: IO[Int] =\n    program.transact(transactor)\n\n  val result: Int =\n    task.unsafeRunSync\n\n  println(s\"Got result ${result}\")\n\n}\n```", "```java\nval fragment: Fragment = sql\"select 42\"\nval query: Query0[Int] = fragment.query[Int]\nval program = query.unique\n```", "```java\ncase class User(userId: Int, username: String, age: Int)\n\ndef allManual(limit: Int): ConnectionIO[List[User]] = sql\"\"\"\n    SELECT userId, username, age\n    FROM user\n    LIMIT $limit\n  \"\"\"\n    .query[(Int, String, Int)]\n    .map { case (id, username, age) => User(id, username, age) }\n    .list\n\ndef withUsername(username: String): ConnectionIO[User] = sql\"\"\"\n    SELECT userId, username, age\n    FROM user\n    WHERE username = $username\n  \"\"\".query[User].unique\n```", "```java\ndef delete(username: String): ConnectionIO[Int] = sql\"\"\"\n    DELETE FROM user\n    WHERE username = $username\n  \"\"\".update.run\n```", "```java\ndef setAge(userId: Int, age: Int): ConnectionIO[Int] = sql\"\"\"\n    UPDATE user\n    SET age = $age\n    WHERE userId = $userId\n  \"\"\".update.run\n\ndef create(username: String, age: Int): ConnectionIO[Int] = sql\"\"\"\n    INSERT INTO user (username, age)\n    VALUES ($username, $age)\n  \"\"\".update.withUniqueGeneratedKeys[Int](\"userId\")\n```", "```java\nval program = for {\n    _  <- Tables.create\n    userId <- User.create(\"Jack\", 41)\n    _ <- User.setAge(userId, 42)\n    _ <- Todo.create(userId, \"Buy Milk\", false)\n    _ <- Todo.create(userId, \"Read the newspaper\", false)\n    _ <- Todo.create(userId, \"Read the full documentation for Doobie\", false)\n    uncompleted <- Todo.uncompleted(userId)\n  } yield uncompleted\n```", "```java\n val all: IO[Unit] = for {\n    todos <- program.transact(xa)\n    users <- User.all(10).transact(xa)\n  } yield {\n    todos.foreach(println)\n    users.foreach(println)\n  }\n```", "```java\n all.unsafeRunSync\n```"]