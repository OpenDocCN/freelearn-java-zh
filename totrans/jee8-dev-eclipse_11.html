<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Microservices</h1>
                
            
            <article>
                
<p class="calibre3">In the previous chapter<span class="calibre12">, we learned how to profile Java applications in order to troubleshoot performance issues.</span><br class="calibre6"/></p>
<p class="calibre3">In this chapter, we will learn how to develop JEE microservices using Eclipse. We will also learn how to deploy microservices in Docker containers. We will develop simple microservices for our <em class="calibre21">Course Management</em> use case.</p>
<p class="calibre3">We will cover<span class="calibre12"> the</span> following topics:</p>
<ul class="calibre10">
<li class="calibre11">Introduction to microservices and Eclipse MicroProfile</li>
<li class="calibre11">Developing JEE microservices using<span> the</span> WildFly Swarm and Spring Boot frameworks</li>
<li class="calibre11">Introduction to Docker and Docker Compose</li>
<li class="calibre11">Deploying microservices in Docker containers</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What is a microservice?</h1>
                
            
            <article>
                
<p class="calibre3">A microservice is a small application designed to perform a specific business task well. Microservices are typically implemented as RESTful web services. The following are some of the characteristics of a microservice: </p>
<ul class="calibre10">
<li class="calibre11"><span>Smaller in size (compared to monolithic applications), and focuses on a single business task/module</span></li>
<li class="calibre11">Has its own database, in contrast to a monolithic application that has one database for all business functionalities</li>
<li class="calibre11">Is typically a standalone application, with a web container bundled into it</li>
</ul>
<p class="calibre3">A large business application can be built by assembling smaller microservices. Compared to a large <span class="calibre12">monolithic </span>application, a microservice architecture provides the following benefits:</p>
<ul class="calibre10">
<li class="calibre11">They are easy to deploy. In a monolithic application, deployment can be quite cumbersome because of<span> the</span> complexity of the application. Microservices are small and can be easily deployed on servers.</li>
<li class="calibre11">Microservices are loosely coupled, so changes in one can be isolated from other services in an application. Also, having a separate database for each service can further insulate the main application and other services from changes made in the schema of the database.</li>
</ul>
<p class="calibre3">To understand<span class="calibre12"> the</span> contrast between monolithic application architecture and microservice architecture, let’s see an example. Throughout this book, we have been following the <em class="calibre21">Course Management</em> example. Let’s say this module is part of a larger <strong class="calibre5">University Management System</strong>, which has many more modules. A monolithic architecture for this application can be viewed as follows:</p>
<div class="mce-root1"><img src="../images/00224.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 12.1: Monolithic application architecture</div>
<p class="calibre3">We have one large application, the <strong class="calibre5">University Management System</strong>, with multiple modules and a single database.</p>
<p class="calibre3">The same application can be architected using microservices as follows:</p>
<div class="mce-root1"><img src="../images/00225.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 12.2: Microservice application architecture</div>
<p class="calibre3">In the microservice architecture, the <strong class="calibre5">University Management System</strong> is composed of many microservices, each with its own database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Eclipse MicroProfile</h1>
                
            
            <article>
                
<p class="calibre3">Microservices can be built with<span class="calibre12"> the</span> current JEE specification (JEE 8). However, there are certain specifications within JEE that are more important for developing microservices, such as JAX-RS (for RESTful Web Services) and JSON-P (for processing JSON data). So, a group of organizations has come together to create specifications for developing and running microservices, which are categorized as MicroProfile. Many of the specifications under MicroProfile are already part of<span class="calibre12"> the</span> JEE specification (such as JAX-RS and JSON-P), but some are new specifications, such as for configuring and monitoring microservices.</p>
<p class="calibre3">The group has come up with two profiles so far. Each MicroProfile-compliant implementation is expected to implement each specification in the supported profile. This ensures that a microservice created with a particular profile runs on all Microprofile implementations supporting that profile. At the time of writing this chapter, the group has come up with two profiles. Here is the list of MicroProfiles and specifications that they include:</p>
<ul class="calibre10">
<li class="calibre11">MicroProfile 1.0 (released in Sep 2016):
<ul class="calibre119">
<li class="calibre11">CDI 1.2</li>
<li class="calibre11">JSON-P 1.0</li>
<li class="calibre11">JAX-RS 2.0</li>
</ul>
</li>
<li class="calibre11">MicroProfile 1.1 (released in August 2017):
<ul class="calibre119">
<li class="calibre11">Config 1.0</li>
<li class="calibre11">CDI 1.2</li>
<li class="calibre11">JSON-P 1.0</li>
<li class="calibre11">JAX-RS 2.0</li>
</ul>
</li>
</ul>
<p class="calibre3">MicroProfile 2.0 is expected to be released in June 2018, and it will include updates to some of the specifications as per JEE 8. Some of the implementations of MicroProfiles are WildFly Swarm (<a href="http://wildfly-swarm.io/" class="calibre9">http://wildfly-swarm.io/</a>), WebSphere Liberty (<a href="https://developer.ibm.com/wasdev/websphere-liberty/" class="calibre9">https://developer.ibm.com/wasdev/websphere-liberty/</a>), Payara (<a href="http://www.payara.fish/" class="calibre9">http://www.payara.fish/</a>), and Apache TomEE (<a href="http://tomee.apache.org/" class="calibre9">http://tomee.apache.org/</a>). Visit<span class="calibre12"> the</span> official website for MicroProfiles at <a href="https://microprofile.io/" class="calibre9">https://microprofile.io/</a> for more information.</p>
<p class="calibre3">In the next section, we will see how to implement a microservice for our <em class="calibre21">Course Management</em> use case using two solutions:</p>
<ul class="calibre10">
<li class="calibre11">Using<span> a </span>MicroProfile implementation (WildFly Swarm)</li>
<li class="calibre11">Using Spring Boot, which is not part of MicroProfile</li>
</ul>
<p class="calibre3">Later, we will see how to deploy microservices in Docker containers.</p>
<div class="packt_infobox"><br class="calibre26"/>
To follow<span class="calibre23"> the</span> code examples in this chapter, you need to be familiar with JPA and REST APIs. Refer to <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre17">Chapter 4</a>, <em class="calibre129">Creating JEE Database Applications</em>, for JPA concepts and <a target="_blank" href="part0176.html#57R300-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre17">Chapter 9</a>, <em class="calibre129">Creating Web Services</em>, for RESTful web services.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up a database for a microservice project</h1>
                
            
            <article>
                
<p class="calibre3">We are going to implement a microservice to get a list of courses.  We will use the same MySQL database, <kbd class="calibre13">course_management</kbd>, that we have been using in this book. Refer to <em class="calibre21">Installing MySQL</em> in <a target="_blank" href="part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9">Chapter 1</a>, <em class="calibre21">Introducing JEE and Eclipse</em>, if you need information on how to install and set up MySQL. If you haven’t already created<span class="calibre12"> the</span> <kbd class="calibre13">course_management</kbd> schema, then refer to<span class="calibre12"> the</span> <em class="calibre21">Creating database schema</em> section in <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9">Chapter 4</a>, <em class="calibre21">Creating JEE Database Applications</em>. At this point, we will assume that<span class="calibre12"> the</span> MySQL database is running and<span class="calibre12"> the</span> <kbd class="calibre13">course_management</kbd> schema with<span class="calibre12"> the</span> <kbd class="calibre13">Course</kbd>, <kbd class="calibre13">Course_Student</kbd>, <kbd class="calibre13">Student</kbd>, and <kbd class="calibre13">Teacher</kbd> <span class="calibre12">tables </span>exists.</p>
<p class="calibre3">We will use JPA to access this database. See the <em class="calibre21">Creating a database application using JPA</em> <span class="calibre12">section</span><span class="calibre12"> </span><span class="calibre12">in</span> <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9">Chapter 4</a><span class="calibre12">,</span> <em class="calibre21">Creating JEE Database Applications</em><span class="calibre12">, if you are not familiar with JPA. We are going to use EclipseLink as the JPA provider.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing microservices using WildFly Swarm</h1>
                
            
            <article>
                
<p class="calibre3">WildFly Swarm ( <a href="http://wildfly-swarm.io/" class="calibre9">http://wildfly-swarm.io/</a> ) is a MicroProfile implementation from Red Hat. It allows you to assemble an application container for running microservices with just the specifications you need.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a WildFly Swarm project</h1>
                
            
            <article>
                
<p class="calibre3">Let’s use WildFly Swarm Project Generator at <a href="http://wildfly-swarm.io/generator/" class="calibre9">http://wildfly-swarm.io/generator/</a> to select<span class="calibre12"> the</span> specifications we want to include in our application and to create the starter project:</p>
<div class="mce-root1"><img src="../images/00226.jpeg" class="calibre231"/></div>
<div class="packt_figure1"><span>Figure 12.3: WildFly Swarm Project Generator</span></div>
<p class="calibre3">Enter <span class="calibre12">Group ID</span> and <span class="calibre12">Artifact ID</span> as shown in the previous screenshot. In the <span class="calibre12">Dependencies</span> textbox, start typing features such as <span class="calibre12">JPA</span> or <span class="calibre12">JAX-RS</span> and then select them from<span class="calibre12"> the</span> auto-suggested options. Make sure <span class="calibre12">JPA EclipseLink</span> , <span class="calibre12">JAX-RS</span>, and <span class="calibre12">CDI</span> are selected as dependencies. If you want to see all available dependencies and select from that list, then click<span class="calibre12"> the</span> <span class="calibre12">View all available dependencies</span> link.</p>
<p class="calibre3">Click<span class="calibre12"> the</span> <span class="calibre12">Generate Project</span> button to create the project and download the ZIP file. This is a Maven project. Unzip the file in a folder and import the project as a Maven project in Eclipse (by selecting<span class="calibre12"> the</span> menu option <span class="calibre12">File</span> | <span class="calibre12">Import</span> and then selecting <span class="calibre12">Existing Maven Projects</span> in<span class="calibre12"> the</span> <span class="calibre12">Maven</span> category).</p>
<p class="calibre3">Right-click on the <span class="calibre12">Eclipse</span><span class="calibre12"> </span><span class="calibre12">Project Explorer</span> <span class="calibre12">and select</span> <span class="calibre12">Run As</span> <span class="calibre12">|</span> <span class="calibre12">Maven Build</span><span class="calibre12">. In the configuration window, type</span> <kbd class="calibre13">wildfly-swarm:run</kbd> <span class="calibre12">in<span class="calibre12"> the</span></span> <span class="calibre12">Goals</span> <span class="calibre12">field:</span></p>
<div class="mce-root1"><img src="../images/00227.jpeg" class="calibre232"/></div>
<div class="packt_figure1">Figure 12.4: Maven Build Configuration to create a WildFly Swarm application</div>
<p class="calibre3">Click <span class="calibre12">Run</span>. Maven will download and install the dependencies and then run the application (you will see a <span class="calibre12">Wildfly Swarm is Ready</span> message in the console when the application is ready). Open <kbd class="calibre13">http://localhost:8080/hello</kbd> to test the default endpoint created by the application generator. You should see the <kbd class="calibre13">hello</kbd> message.</p>
<p class="calibre3">If you look into the target folder of the project, you will see <kbd class="calibre13">demo-swarm.jar</kbd> and <kbd class="calibre13">demo.war</kbd>. When we executed<span class="calibre12"> the</span> <span class="calibre12">wildfly-swarm:run</span> goal, Maven starts a JBoss container and deploys the WAR file. The microservice can also be run by executing the single JAR file, <kbd class="calibre13">demo-swarm.jar</kbd>. This JAR contains all the packages, including the application server to run the microservice. Simply run this <span class="calibre12">from the command line</span><span class="calibre12">:</span></p>
<pre class="calibre25"><strong class="calibre1">java –jar demo-swarm.jar</strong></pre>
<p class="calibre3">To change the name of the output file from demo to, say, <kbd class="calibre13">coursemanagement</kbd>, change the name in <kbd class="calibre13">pom.xml</kbd> in <kbd class="calibre13">&lt;filename&gt;</kbd> under the <kbd class="calibre13">&lt;build&gt;</kbd> tag.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring JPA</h1>
                
            
            <article>
                
<p class="calibre3">Now, let’s add a dependency for MySQL in the project. Refer to <em class="calibre21">Figure 4.11</em> in <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9">Chapter 4</a>, <em class="calibre21">Creating JEE Database Applications</em>, for adding a Maven dependency for the MySQL JDBC driver, or simply add<span class="calibre12"> the</span> following dependency to <kbd class="calibre13">pom.xml</kbd>:</p>
<pre class="calibre25">&lt;dependency&gt;<br class="title-page-name"/>  &lt;groupId&gt;mysql&lt;/groupId&gt;<br class="title-page-name"/>  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br class="title-page-name"/>  &lt;version&gt;8.0.8-dmr&lt;/version&gt;<br class="title-page-name"/>&lt;/dependency&gt;</pre>
<p class="calibre3">Convert the project to a JPA project so that we can use<span class="calibre12"> the</span> JPA tooling provided by Eclipse. Right-click on the project in the <span class="calibre12">Project Explorer</span> and select<span class="calibre12"> the</span> <span class="calibre12">Configure</span> | <span class="calibre12">Convert to JPA Project</span> option. Make sure<span class="calibre12"> the</span> following <span class="calibre12">Project Facets</span> are selected, along with the default facets:</p>
<ul class="calibre10">
<li class="calibre11">Dynamic Web Module</li>
<li class="calibre11">JAX-RS (RESTful web services)</li>
<li class="calibre11">JPA</li>
</ul>
<p class="calibre3">Click<span class="calibre12"> the</span> <span class="calibre12">Next</span> button (refer to <em class="calibre21">Figure 4.20</em> <q class="calibre207">Add JPA facet to the project</q> of <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9">Chapter 4</a>, <em class="calibre21">Creating JEE Database Applications</em>) and configure<span class="calibre12"> the</span> JPA facet as shown in <q class="calibre207">Figure 4.21</q>. Click <span class="calibre12">Finish</span>.</p>
<p class="calibre3">Let’s now configure<span class="calibre12"> the</span> JDBC connection in <kbd class="calibre13">persistence.xml</kbd>. Follow steps 7 through 9 in<span class="calibre12"> the</span> <em class="calibre21">Converting project into a JPA project</em> <span class="calibre12">section</span><span class="calibre12"> </span><span class="calibre12">in</span> <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9">Chapter 4</a>, <em class="calibre21">Creating JEE Database Applications</em><span class="calibre12">. Your <kbd class="calibre13">persistence.xml</kbd> should now have<span class="calibre12"> the</span> following persistence unit:</span></p>
<pre class="calibre25">&lt;persistence-unit name="coursemanagement" transaction-type="RESOURCE_LOCAL"&gt;<br class="title-page-name"/>  &lt;properties&gt;<br class="title-page-name"/>    &lt;provider&gt;org.eclipse.persistence.jpa.PersistenceProvider&lt;/provider&gt;<br class="title-page-name"/>       &lt;class&gt;packt.book.jeeeclipse.wildflyswarm.coursemanagement.rest.Course&lt;/class&gt;<br class="title-page-name"/>    &lt;property name="javax.persistence.jdbc.driver" value="com.mysql.cj.jdbc.Driver"/&gt;<br class="title-page-name"/>    &lt;property name="javax.persistence.jdbc.url" value="jdbc:mysql://localhost/course_management"/&gt;<br class="title-page-name"/>    &lt;property name="javax.persistence.jdbc.user" value="&lt;enter_your_user_name&gt; "/&gt;<br class="title-page-name"/>    &lt;property name="javax.persistence.jdbc.password" value="&lt;enter_your_password&gt; "/&gt;<br class="title-page-name"/>  &lt;/properties&gt;<br class="title-page-name"/>&lt;/persistence-unit&gt;</pre>
<p class="calibre3">In the previous XML file, we are specifying the <kbd class="calibre13">org.eclipse.persistence.jpa.PersistenceProvider</kbd> class as our JPA provider and then setting properties for connecting to the MySQL database.</p>
<p class="calibre3">Next, create folders named <kbd class="calibre13">resources/META-INF</kbd> under <kbd class="calibre13">src/main</kbd> and copy <kbd class="calibre13">persistence.xml</kbd> into<span class="calibre12"> the</span> <kbd class="calibre13">src/main/resources</kbd> folder. If Eclipse displays errors in JPA configuration, right-click on the project name in <span class="calibre12">Project Explorer</span> and select <span class="calibre12">Maven</span> | <span class="calibre12">Update Project</span>. The reason for doing this is that Maven expects files that you want to copy to the <kbd class="calibre13">classes</kbd> folder to be in <span class="calibre12">the</span> <kbd class="calibre13">src/main/resources</kbd> folder. We need to have <kbd class="calibre13">META-INF/persistence.xml</kbd> in<span class="calibre12"> the</span> <kbd class="calibre13">classes</kbd> folder so that<span class="calibre12"> the</span> JPA provider can load it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a course entity bean and a JPA factory</h1>
                
            
            <article>
                
<p class="calibre3">If you are not familiar with JPA, refer to<span class="calibre12"> the</span> <em class="calibre21">JPA concepts</em> section in <a target="_blank" href="part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9">Chapter 4</a>, <em class="calibre21">Creating JEE Database Applications</em>.</p>
<p class="calibre3">We will now create <kbd class="calibre13">Course.java</kbd> in<span class="calibre12"> the</span> <kbd class="calibre13">packt.book.jeeeclipse.wildflyswarm.coursemanagement.rest</kbd> package:</p>
<pre class="calibre25">package packt.book.jeeeclipse.wildflyswarm.coursemanagement.rest;<br class="title-page-name"/><br class="title-page-name"/>// skipping imports to save space<br class="title-page-name"/><br class="title-page-name"/>@Entity<br class="title-page-name"/>@Table(name="\"Course\"")<br class="title-page-name"/>@NamedQuery(name="Course.findAll", query="SELECT c FROM Course c")<br class="title-page-name"/>public class Course implements Serializable {<br class="title-page-name"/>  private static final long serialVersionUID = 2550281519279297343L;<br class="title-page-name"/><br class="title-page-name"/>  @Id<br class="title-page-name"/>  @GeneratedValue(strategy=GenerationType.IDENTITY)<br class="title-page-name"/>  @Column(name="id")<br class="title-page-name"/>  private int id;<br class="title-page-name"/><br class="title-page-name"/>  @NotNull<br class="title-page-name"/>  @Column(name="name")<br class="title-page-name"/>  private String name;<br class="title-page-name"/><br class="title-page-name"/>  @Min(1)<br class="title-page-name"/>  @Column(name="credits")<br class="title-page-name"/>  private int credits;<br class="title-page-name"/><br class="title-page-name"/>  // skipping getter and setters to save space<br class="title-page-name"/>}</pre>
<p class="calibre3">This is a simple JPA entity class with appropriate annotations. We need to tell JPA that this is a managed bean. To do this, open <kbd class="calibre13">persistence.xml</kbd> and in the <span class="calibre12">General</span> tab of the editor, click<span class="calibre12"> the</span> <span class="calibre12">Add</span> button in<span class="calibre12"> the</span> <span class="calibre12">Managed Classes</span> section. Add<span class="calibre12"> the</span> <kbd class="calibre13">Course</kbd> entity class to the list.</p>
<p class="calibre3">Create a JPA <kbd class="calibre13">EntityManagerFactory</kbd> class called <kbd class="calibre13">CourseManagementJPAFactory</kbd>:</p>
<pre class="calibre25">package packt.book.jeeeclipse.wildflyswarm.coursemanagement.rest;<br class="title-page-name"/><br class="title-page-name"/>// skipping imports to save space<br class="title-page-name"/><br class="title-page-name"/>@ApplicationScoped<br class="title-page-name"/>public class CourseManagementJPAFactory {<br class="title-page-name"/>  private EntityManager _entityManager;<br class="title-page-name"/><br class="title-page-name"/>  public EntityManager getEntityManager() {<br class="title-page-name"/>    if (_entityManager != null) return _entityManager;<br class="title-page-name"/><br class="title-page-name"/>    EntityManagerFactory factory = Persistence.createEntityManagerFactory("coursemanagement");<br class="title-page-name"/><br class="title-page-name"/>    _entityManager = factory.createEntityManager();<br class="title-page-name"/><br class="title-page-name"/>    return _entityManager;<br class="title-page-name"/> }<br class="title-page-name"/>}</pre>
<p class="calibre3">In this class, we are creating an instance of <kbd class="calibre13">EntityManager</kbd> from <kbd class="calibre13">EntityManagerFactory</kbd>. Note that name passed to<span class="calibre12"> the</span> <kbd class="calibre13">Persistence.createEntityManagerFactory</kbd> method is<span class="calibre12"> the</span> same as the name we specified in <kbd class="calibre13">persistence.xml</kbd>.</p>
<p class="calibre3">Finally, we will create the main class, called <kbd class="calibre13">CourseManagementEndpoint</kbd>, and also<span class="calibre12"> the</span> REST endpoint function to handle<span class="calibre12"> the</span> <kbd class="calibre13">/course_management/courses</kbd> URL path:</p>
<pre class="calibre25">package packt.book.jeeeclipse.wildflyswarm.coursemanagement.rest;<br class="title-page-name"/>// skipping imports to save space<br class="title-page-name"/><br class="title-page-name"/>@ApplicationScoped<br class="title-page-name"/>@Path("/course_management")<br class="title-page-name"/>public class CourseManagementEndpoint {<br class="title-page-name"/>  @Inject<br class="title-page-name"/>  private CourseManagementJPAFactory jpaFactory;<br class="title-page-name"/><br class="title-page-name"/>  @GET<br class="title-page-name"/>  @Path("/courses")<br class="title-page-name"/>  @Produces(MediaType.APPLICATION_JSON)<br class="title-page-name"/>  public List&lt;Course&gt; doGet() {<br class="title-page-name"/>    EntityManager entityManager = jpaFactory.getEntityManager();<br class="title-page-name"/>    TypedQuery&lt;Course&gt; courseQuery = entityManager.createNamedQuery("Course.findAll", Course.class);<br class="title-page-name"/>    List&lt;Course&gt; courses = courseQuery.getResultList();<br class="title-page-name"/>    return courses;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre3">If the application is not already running, right-click on the project in <span class="calibre12">Project Explorer</span> and select <span class="calibre12">Run As</span> | <span class="calibre12">Maven build</span>. Open <kbd class="calibre13">http://localhost:8080/course_managment/courses</kbd> in the browser and you should see a JSON list of courses in the database.</p>
<p class="calibre3">To change the default server port from <kbd class="calibre13">8080</kbd> to any other port number, say <kbd class="calibre13">8000</kbd>, set<span class="calibre12"> the</span> <kbd class="calibre13">swarm.http.port=8000</kbd> <span class="calibre12">environment variable</span>. You can set this in the run configuration for the project (select <span class="calibre12">Run</span> | <span class="calibre12">Run Configurations</span> from the main menu and look for the configuration for your project in <span class="calibre12">the</span> <span class="calibre12">Maven Build</span> section):</p>
<div class="mce-root1"><img src="../images/00228.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 12.5: Set the environment variable in the run configuration</div>
<p class="calibre3">Click on<span class="calibre12"> the</span> <span class="calibre12">Environment</span> tab and add the environment variable and its value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing microservices using Spring Boot</h1>
                
            
            <article>
                
<p class="calibre3">A microservice can be implemented in many ways; in the previous section, we saw one way to implement it, using WildFly Swarm, which is a MicroProfile implementation. In this section, we will see how to implement a microservice using Spring Boot, which is not a MicroProfile implementation but is a popular framework.</p>
<p class="calibre3">Spring Boot (<a href="http://spring.io/projects/spring-boot" class="calibre9">https://spring.io/projects/spring-boot/</a>) is a framework to create standalone Spring applications. Refer to <a target="_blank" href="part0154.html#4IRMK0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55" class="calibre9">Chapter 8</a>, <em class="calibre21">Creating Web Applications with Spring MVC</em>, for more information on Spring and specific information on<span class="calibre12"> the</span> Spring MVC framework. Similar to<span class="calibre12"> the</span> WildFly Swarm Project Generator, Spring Boot also has a web page for creating a starter application for Spring Boot, where you can select<span class="calibre12"> the</span> features/specifications of JEE that you want to be included in the application. Go to <a href="https://start.spring.io/" class="calibre9">https://start.spring.io/</a>:</p>
<div class="mce-root1"><img src="../images/00229.jpeg" class="calibre233"/></div>
<div class="packt_figure1">Figure 12.6: Spring Boot project generator</div>
<p class="calibre3">Select<span class="calibre12"> the</span> <span class="calibre12">Web</span>, <span class="calibre12">JPA</span>, and <span class="calibre12">Jersey(JAX-RS)</span> dependencies. Download the starter project and unzip it in a folder. We won’t be able to run the application yet. Since we have selected JPA as one of the dependencies of the application, Spring Boot expects us to configure database connection properties in<span class="calibre12"> the</span> application.properties file, located in <kbd class="calibre13">src/main/resources</kbd>. Add<span class="calibre12"> the</span> following properties to <kbd class="calibre13">application.properties</kbd>:</p>
<pre class="calibre25">spring.datasource.url = jdbc:mysql://localhost/course_management?autoReconnect=true&amp;useSSL=false<br class="title-page-name"/>spring.datasource.driver-class-name = com.mysql.cj.jdbc.Driver<br class="title-page-name"/>spring.datasource.username=&lt;your_user_name&gt;<br class="title-page-name"/>spring.datasource.password=&lt;your_passwod&gt;<br class="title-page-name"/>spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl</pre>
<p class="calibre3">We can run the server now, but we haven’t defined any REST endpoints yet. So, let’s do that. We will use<span class="calibre12"> the</span> <kbd class="calibre13">Course</kbd> entity bean that we created for<span class="calibre12"> the</span> WildFly Swarm project in the previous section. So, copy the same file to this project, in<span class="calibre12"> the</span> <kbd class="calibre13">packt.book.jeeeclipse.springboot.coursemanagementspring</kbd> package. See<span class="calibre12"> the</span> <em class="calibre21">Create course entity bean and JPA factory</em> <span class="calibre12">section</span><span class="calibre12"> </span><span class="calibre12">for listings of<span class="calibre12"> the</span></span> <kbd class="calibre13">Course</kbd> <span class="calibre12">class.</span></p>
<p class="calibre3">Spring provides a utility interface named <kbd class="calibre13">CrudRepository</kbd> that tells the framework to create CRUD boilerplate code for the given entity/class. We will create a repository interface that extends <kbd class="calibre13">CrudRepository</kbd> and create a CRUD implementation for<span class="calibre12"> the</span> <kbd class="calibre13">Course</kbd> class. See <a href="https://docs.spring.io/spring-data/data-commons/docs/1.6.1.RELEASE/reference/html/repositories.html" class="calibre9">https://docs.spring.io/spring-data/data-commons/docs/1.6.1.RELEASE/reference/html/repositories.html</a> for more information on <kbd class="calibre13">CrudRepository</kbd>:</p>
<pre class="calibre25">package packt.book.jeeeclipse.springboot.coursemanagementspring;<br class="title-page-name"/>import org.springframework.data.repository.CrudRepository;<br class="title-page-name"/>public interface CourseRepository extends CrudRepository&lt;Course, Long&gt;{<br class="title-page-name"/>}</pre>
<p class="calibre3">This is just a marker interface to tell Spring Framework to create CRUD code for<span class="calibre12"> the</span> <kbd class="calibre13">Course</kbd> class/entity that has the primary key of type <kbd class="calibre13">Long</kbd>.</p>
<p class="calibre3">In Spring, a REST endpoint is created by creating a controller, actually annotating the class with <kbd class="calibre13">@RestController</kbd>. See <a href="https://spring.io/guides/gs/rest-service/" class="calibre9">https://spring.io/guides/gs/rest-service/</a> for information on creating RESTful web services using Spring. So, let’s create<span class="calibre12"> the</span> <kbd class="calibre13">CourseController</kbd> class:</p>
<pre class="calibre25">package com.example.demo;<br class="title-page-name"/>// skipping imports to save space<br class="title-page-name"/><br class="title-page-name"/>@RestController<br class="title-page-name"/>public class CourseController {<br class="title-page-name"/>  @Autowired<br class="title-page-name"/>  private CourseRepository courseRepository;<br class="title-page-name"/><br class="title-page-name"/>  @RequestMapping(value = "/course_management/courses", method = RequestMethod.GET)<br class="title-page-name"/>  public Iterable&lt;Course&gt; getCourses() {<br class="title-page-name"/>    return courseRepository.findAll();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre3">In this class, we are mapping the GET HTTP request to the <kbd class="calibre13">/course_management/courses</kbd> URL to<span class="calibre12"> the</span> <kbd class="calibre13">getCourses</kbd> method.</p>
<p class="calibre3">An instance of <kbd class="calibre13">CourseRepository</kbd> is auto injected into this class using<span class="calibre12"> the</span> <kbd class="calibre13">@Autowired</kbd> annotation.</p>
<p class="calibre3">We are now ready to run the application. Create a run configuration for this application by right-clicking on the project in <span class="calibre12">Project Explorer</span> and selecting <span class="calibre12">Run As</span> <strong class="calibre5">|</strong> <span class="calibre12">Maven Build</span>. Then, type <kbd class="calibre13">spring-boot:run</kbd> in<span class="calibre12"> the</span> <span class="calibre12">Goals</span> field ( see <em class="calibre21">Figure 12.4</em> for reference) and click<span class="calibre12"> the</span> <span class="calibre12">Run</span> button. Once the server is ready, browse to <kbd class="calibre13">http://localhost:8080/course_management/courses</kbd> and you should see JSON output (for <kbd class="calibre13">Courses</kbd>).</p>
<p class="calibre3">To change<span class="calibre12"> the</span> default server port from <kbd class="calibre13">8080</kbd> to any other port number, say <kbd class="calibre13">8000</kbd>, set<span class="calibre12"> the</span> environment variable <kbd class="calibre13">server.port=8000</kbd>. See <em class="calibre21">Figure 12.5</em> for reference.</p>
<p class="calibre3">See <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/" class="calibre9">https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/</a> for a complete reference to<span class="calibre12"> </span><span class="calibre12">Spring Boot</span><span class="calibre12">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Deploying microservices in a Docker container</h1>
                
            
            <article>
                
<p class="calibre3">In this section, we will learn how to deploy a microservice in a Docker container, but let’s first understand what Docker is.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What is Docker?</h1>
                
            
            <article>
                
<p class="calibre3">Docker is container management software. In general, software containers allow you to package your application with all dependencies, including the OS, in one package. Your application runs in isolation in the container in which it is packaged. This reduces discrepancies in environments when developing, testing, and deploying. Since all the dependencies for your application are already resolved and packaged with it, you generally do not run into situations where your application ran fine in a dev/test environment, but failed in production—maybe because some of the dependencies were not met. For example, even if you have developed and tested in the same OS version, in production some of the dependencies may fail because of OS updates.</p>
<p class="calibre3">Docker is the most popular container management technology currently. Docker makes it easy to package and run your application in a container. It is often compared with virtual machines. The following diagram shows the difference between them:</p>
<div class="mce-root1"><img src="../images/00230.gif" class="calibre29"/></div>
<div class="packt_figure1"><span>Figure 12.7: Difference between Virtual Machines Technology and Docker Container Technology</span></div>
<p class="calibre3">VMs are guest operating systems in <em class="calibre21">Figure 12.7</em>, running on top of hypervisor software (a hypervisor isolates the guest OS from the host OS and manages them). Docker containers run on top of Docker Engine and a shared OS kernel (for example, Linux or Windows). Docker containers are not full-fledged OSes; they are processes with isolated resources such as filesystems and networks.</p>
<p class="calibre3">Compared to VMs, Docker containers are easy to package and deploy, and they start much more quickly (because they are just processes and not complete OSes). Docker containers also take up a lot fewer resources than VMs. So, you can run more Docker containers in the same environment than VMs.</p>
<div class="packt_infobox">See this official Docker link, <a href="https://www.docker.com/what-docker" class="calibre17">https://www.docker.com/what-docker</a>, for more information.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to get Docker</h1>
                
            
            <article>
                
<p class="calibre3">Download Docker for Mac from here: <a href="https://docs.docker.com/docker-for-mac/install/" class="calibre9">https://docs.docker.com/docker-for-mac/install/</a></p>
<p class="calibre3">Download Docker for Windows from here: <a href="https://docs.docker.com/docker-for-windows/install/" class="calibre9">https://docs.docker.com/docker-for-windows/install/</a></p>
<p class="calibre3">Download Docker for Linux: <a href="https://docs.docker.com/engine/installation/" class="calibre9">https://docs.docker.com/engine/installation/</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to use Docker</h1>
                
            
            <article>
                
<p class="calibre3">In this section, we will briefly see how to use Docker. To create a new container, you typically create a Dockerfile. In this file, you need to specify the base image to extend your container from, for example, the base image for Ubuntu or Debian. You can think of Docker images as templates, and containers as running instances of those templates. Docker Hub, <a href="https://hub.docker.com/" class="calibre9">https://hub.docker.com/</a>, is a repository of Docker images.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dockerfile</h1>
                
            
            <article>
                
<p class="calibre3">You create a Dockerfile to create an image for your own container. You can specify<span class="calibre12"> the</span> base image for your container, commands to execute when setting up the container, ports to expose, files to copy to the container, and the entry point (the program to run when the container starts). Here are some of the frequently used instructions in a Dockerfile:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">FROM</kbd>: Specify the base image for your Docker container, for example, <kbd class="calibre13">FROM Ubuntu</kbd>.</li>
<li class="calibre11"><kbd class="calibre13">ADD</kbd>: Add file(s) from the host machine to<span> the</span> Docker container. For example, to copy<span> the</span> <kbd class="calibre13">setup.sh</kbd> file from the directory from where Docker commands are run to a container. For example, <kbd class="calibre13">ADD ./setup.sh /setup.sh</kbd>.</li>
<li class="calibre11"><kbd class="calibre13">RUN</kbd>: Runs a command in the container. For example, to make<span> the</span> <kbd class="calibre13">setup.sh</kbd> file executable after copying to a container. Example, <kbd class="calibre13">RUN chmod +x /setup.sh</kbd>.</li>
<li class="calibre11"><kbd class="calibre13">ENTRYPOINT</kbd>: Docker containers are meant to have one main application, and when it stops running, the container stops. That main program is specified using<span> the</span> <kbd class="calibre13">ENTRYPOINT</kbd> directive. For example, to run<span> the</span> Apache server after it is installed (possibly using<span> the</span> <kbd class="calibre13">RUN</kbd> command) <kbd class="calibre13">ENTRYPOINT apachectl start</kbd>.</li>
<li class="calibre11"><kbd class="calibre13">CMD</kbd><strong class="calibre1">:</strong> A command to execute. In the absence of <kbd class="calibre13">ENTRYPOINT</kbd>, <kbd class="calibre13">CMD</kbd> specifies the main application in the container. If specified along with <kbd class="calibre13">ENTRYPOINT</kbd>, then<span> the</span> value of <kbd class="calibre13">CMD</kbd> is passed as arguments to the application specified in <kbd class="calibre13">ENTRYPOINT</kbd>.</li>
<li class="calibre11"><kbd class="calibre13">EXPOSE</kbd>:  Tells Docker that the container listens on specified port(s) at runtime. For example, if<span> the</span> Apache server is listening on port <kbd class="calibre13">80</kbd> in a container, then you would specify <kbd class="calibre13">EXPOSE 80</kbd>.</li>
<li class="calibre11"><kbd class="calibre13">ENV</kbd>: Sets environment variable(s) in a container. An example is <kbd class="calibre13">ENV PATH=/some/path:$PATH</kbd>.</li>
<li class="calibre11"><kbd class="calibre13">VOLUME</kbd>: Creates a mountable point for a volume. A volume is just like a folder or virtual folder. From within the container, it can be accessed as any other folder. Volumes can be used to share folders across different running containers. One container can also import volumes from another container.</li>
</ul>
<div class="packt_infobox">This is a list of commonly used Docker instructions in a Dockerfile. See the Dockerfile reference at <a href="https://docs.docker.com/engine/reference/builder/" class="calibre17">https://docs.docker.com/engine/reference/builder/</a> for all instructions.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Docker commands</h1>
                
            
            <article>
                
<p class="calibre3">Here is a short list of Docker commands for operations such as start, stop, and delete:</p>
<table border="1" class="calibre49">
<tbody class="calibre50">
<tr class="calibre51">
<td class="calibre234">
<p class="calibre3"><strong class="calibre5">Operation</strong></p>
</td>
<td class="calibre52">
<p class="calibre3"><strong class="calibre5">Command</strong></p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre234">
<p class="calibre3">Run a container from an image</p>
</td>
<td class="calibre52">
<p class="calibre3">The syntax is as follows:</p>
<pre class="calibre25"><strong class="calibre1">docker run –name &lt;container_name&gt; &lt;options&gt; &lt;base_image&gt; &lt;command_to_run&gt;</strong></pre>
<p class="calibre3">For example, to run a container from an Ubuntu image, open a Terminal and execute the bash shell with the following command:</p>
<pre class="calibre25"><strong class="calibre1">docker run -name my-ubuntu -it ubuntu bash</strong></pre></td>
</tr>
<tr class="calibre51">
<td class="calibre234">
<p class="calibre3">Create an image from a Dockerfile</p>
</td>
<td class="calibre52">
<p class="calibre3">The syntax is as follows:</p>
<pre class="calibre25"><strong class="calibre1">docker build &lt;options&gt; &lt;folder_of_dockerfile&gt;</strong></pre>
<p class="calibre3">For example, to create <kbd class="calibre13">my_image</kbd> from a Dockerfile in the current folder, run the following Docker command:</p>
<pre class="calibre25"><strong class="calibre1">docker build -t image_name</strong></pre></td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3">List currently running containers</p>
</td>
<td class="calibre234">
<pre class="calibre25"><strong class="calibre1">docker ps</strong></pre></td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3">List all containers, including stopped containers</p>
</td>
<td class="calibre234">
<pre class="calibre25"><strong class="calibre1">docker ps -a</strong></pre></td>
</tr>
<tr class="calibre51">
<td class="calibre234">
<p class="calibre3">Start (a stopped) container</p>
</td>
<td class="calibre52">
<p class="calibre3">The syntax is as follows:</p>
<pre class="calibre25"><strong class="calibre1">docker start -i &lt;container&gt;</strong></pre>
<p class="calibre3">The <kbd class="calibre13">-i</kbd> option keeps <kbd class="calibre13">stdin</kbd> (standard input) open and allows you to run commands in the container. To identify the container, you can either use the container name or ID.</p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3">Remove a container</p>
</td>
<td class="calibre52">
<pre class="calibre25"><strong class="calibre1">docker rm &lt;container&gt;</strong></pre></td>
</tr>
<tr class="calibre51">
<td class="calibre234">
<p class="calibre3">Execute command in running container</p>
</td>
<td class="calibre52">
<p class="calibre3">The syntax is as follows:</p>
<pre class="calibre25"><strong class="calibre1">docker exec &lt;options&gt; &lt;container&gt; &lt;command&gt;</strong></pre>
<p class="calibre3">For example, to open a bash shell in a running container called <kbd class="calibre13">my_container</kbd>, execute the following command:</p>
<pre class="calibre25"><strong class="calibre1">docker exec –it my_container bash</strong></pre></td>
</tr>
<tr class="calibre51">
<td class="calibre52">
<p class="calibre3">Listing all images</p>
</td>
<td class="calibre52">
<pre class="calibre25"><strong class="calibre1">docker images</strong></pre></td>
</tr>
<tr class="calibre51">
<td class="calibre234">
<p class="calibre3">Deleting images</p>
</td>
<td class="calibre52">
<p class="calibre3"><span class="calibre12">Image IDs are space separated in this command:</span></p>
<pre class="calibre25"><strong class="calibre1">docker rmi &lt;image_ids&gt;</strong></pre>
<p class="calibre3"> </p>
</td>
</tr>
<tr class="calibre51">
<td class="calibre234">
<p class="calibre3">Get information about running container</p>
</td>
<td class="calibre234">
<pre class="calibre25"><strong class="calibre1">docker inspect &lt;container&gt;</strong></pre></td>
</tr>
</tbody>
</table>
<div class="packt_infobox">See <a href="https://docs.docker.com/engine/reference/commandline/docker/" class="calibre17">https://docs.docker.com/engine/reference/commandline/docker/</a> for the complete reference.</div>
<p class="calibre3">That was a short introduction to Docker. There are many more details of Docker that are out of<span class="calibre12"> the</span> scope of this book. Please refer to<span class="calibre12"> the</span> links provided and also<span class="calibre12"> the</span> Docker website (<a href="https://www.docker.com/" class="calibre9">https://www.docker.com/</a>) for more information. We will now focus on Eclipse tooling for Docker and deploying microservices in Docker containers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up Docker Tooling in Eclipse</h1>
                
            
            <article>
                
<p class="calibre3">There is a Docker plugin for Eclipse, using which you can perform many of the mentioned Docker tasks from within Eclipse. To install the plugin in Eclipse, from the menu, select <span class="calibre12">Help</span> | <span class="calibre12">Eclipse Marketplace...</span>. Search for <kbd class="calibre13">Eclipse Docker Tooling</kbd> and install it:</p>
<div class="packt_figure1"><img src="../images/00231.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 12.8: Install Eclipse Docker Tooling from Eclipse Marketplace</div>
<p class="calibre3">Switch to<span class="calibre12"> the</span> <span class="calibre12">Docker Tooling</span> perspective (either click on the <span class="calibre12">Open Perspective</span> toolbar button at<span class="calibre12"> the</span> top-right of the editor window, or select from<span class="calibre12"> the</span> <span class="calibre12">Window</span> | <span class="calibre12">Perspective</span> | <span class="calibre12">Open Perspective</span> | <span class="calibre12">Other</span><span class="calibre12"> </span><span class="calibre12">menu</span><span class="calibre12">).</span></p>
<p class="calibre3">We will now add a Docker connection in Eclipse (make sure<span class="calibre12"> the</span> Docker daemon is running):</p>
<div class="mce-root1"><img src="../images/00232.jpeg" class="calibre235"/></div>
<div class="packt_figure1"><span>Figure 12.9: Add Docker connection</span></div>
<p class="calibre3">Click on<span class="calibre12"> the</span> <span class="calibre12">Add Connection</span> toolbar button in <span class="calibre12">Docker Explorer</span> and create a connection, as shown in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00233.jpeg" class="calibre236"/></div>
<div class="packt_figure1"><span>Figure 12.10: Add connection dialog box</span></div>
<p class="calibre3">On Windows, you need to select <span class="calibre12">TCP Connection</span> and specify the URI where Docker daemon is listening. You can find the URI in Docker settings, in <span class="calibre12">General</span> tab. Make sure <span class="calibre12">Expose daemon on...</span> option is selected. Copy the TCP URI from this option and paste it in <span class="calibre12">TCP Connection</span> | <span class="calibre12">URI</span> textbox in the dialog box shown in <em class="calibre21">Fig. 12.10</em>.</p>
<p class="calibre3">Once the connection is added successfully, you will see lists of existing containers and images, if any, on your local machine.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a Docker network</h1>
                
            
            <article>
                
<p class="calibre3">We are going to deploy two servers in two separate Docker containers in the same machine: a MySQL DB server and an application server to run our microservice. The application server will need to know about the DB server to access it. The recommended way to allow two Docker containers to access each other is by deploying them in the same Docker network. A complete discussion of Docker networks is out of scope of this book, so readers are encouraged to read about Docker networks at <a href="https://docs.docker.com/engine/userguide/networking" class="calibre9">https://docs.docker.com/engine/userguide/networking</a>.</p>
<p class="calibre3">Knowing that the two containers we are going to create shortly need to run in the same Docker network, let’s create a Docker network by running<span class="calibre12"> the</span> following command:</p>
<pre class="calibre25"><strong class="calibre1">docker network create --driver bridge coursemanagement</strong></pre>
<p class="calibre3">In this command, <kbd class="calibre13">coursemanagment</kbd> is<span class="calibre12"> the</span> name of the network we are creating.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating MySQL container</h1>
                
            
            <article>
                
<p class="calibre3">We have been using a MySQL server installed on the host machine so far in this book. We will now see how to create a Docker container with MySQL. If you are running an instance of MySQL on your host OS (the OS in which Docker is running), then stop the instance or configure MySQL to run on a different port than <kbd class="calibre13">3306</kbd> in the Docker container (we will see how to do this shortly).</p>
<p class="calibre3">We will use the official MySQL Docker image; see <a href="https://hub.docker.com/_/mysql/" class="calibre9">https://hub.docker.com/_/mysql/</a>. Run<span class="calibre12"> the</span> following command:</p>
<pre class="calibre25"><strong class="calibre1">docker run --name course-management-mysql -e MYSQL_ROOT_PASSWORD=your_password –p 3306:3306 --network=coursemanagement -d mysql</strong></pre>
<p class="calibre3">Replace <kbd class="calibre13">your_password</kbd> with the root password you want to set. This command will install the latest version of MySQL. The <kbd class="calibre13">-d</kbd> option runs the container in detached/background mode. Also note that the container is created in the <kbd class="calibre13">coursemanagement</kbd> network that we created in the previous section. If you want to use a specific version of MySQL, then tag that version; for example, to install MySQL Version 5.5.58, use<span class="calibre12"> the</span> following command:</p>
<pre class="calibre25"><strong class="calibre1">docker run --name course-management-mysql -e MYSQL_ROOT_PASSWORD=your_password -d –p 3306:3306 --network=coursemanagement mysql:5.5.58</strong></pre>
<p class="calibre3"><kbd class="calibre13">MySQL</kbd> will run on port <kbd class="calibre13">3306</kbd> in the container, and the container exposes the service at the same port on the host machine. To expose this service at a different port on the host machine, say port <kbd class="calibre13">3305</kbd>, use the <kbd class="calibre13">–p</kbd> or <kbd class="calibre13">--publish</kbd> option:</p>
<pre class="calibre25"><strong class="calibre1">docker run --name course-management-mysql -e MYSQL_ROOT_PASSWORD=your_password –p 3305:3306 --network=coursemanagement –d mysql</strong></pre>
<p class="calibre3">The <kbd class="calibre13">-p</kbd> option in this command maps port <kbd class="calibre13">3306</kbd> in the Docker container to port <kbd class="calibre13">3305</kbd> on the host machine.</p>
<p class="calibre3">Once the command is executed successfully, you can verify that the container is running by executing the <kbd class="calibre13">docker ps</kbd> command. The container will also be visible in <span class="calibre12">Docker Explorer</span> in Eclipse. Switch to the <span class="calibre12">Docker Tooling</span> perspective in Eclipse and expand the <span class="calibre12">Containers</span> group under the <span class="calibre12">Local</span> connection:</p>
<div class="packt_figure1"><img src="../images/00234.jpeg" class="calibre237"/></div>
<div class="packt_figure1">Figure 12.11: Docker Explorer listing containers and images</div>
<p class="calibre3">Right-click on the container name to show menu options for different actions on the container, such as <span class="calibre12">Start</span>, <span class="calibre12">Stop</span>, and <span class="calibre12">Restart</span>.</p>
<p class="calibre3">The <span class="calibre12">Execute Shell</span> option is very useful for opening a shell in the container and executing commands. For example, to execute MySQL commands from within the container, select the <span class="calibre12">Execute Shell</span> option and execute the <kbd class="calibre13">mysql -u root –p</kbd> command:</p>
<div class="packt_figure1"><img src="../images/00235.jpeg" class="calibre29"/></div>
<div class="packt_figure1">Figure 12.12: The Execute Shell in a Docker container</div>
<p class="calibre3">Assuming you have mapped port <kbd class="calibre13">3306</kbd> from the container to the same port on the host machine, you can connect to the instance of MySQL in the container from the host machine as follows:</p>
<pre class="calibre25"><strong class="calibre1">mysql -h 127.0.0.1 –u root -p</strong></pre>
<p class="calibre3">Make sure you specify<span class="calibre12"> the</span> <kbd class="calibre13">-h</kbd> or <kbd class="calibre13">--host</kbd> option, or it will try to connect using the local <kbd class="calibre13">.sock</kbd> file and that will fail. You can also connect to this MySQL instance from MySQL Workbench.</p>
<p class="calibre3">Next, create<span class="calibre12"> the</span> <kbd class="calibre13">course_management</kbd> schema in the database. See<span class="calibre12"> the</span> <em class="calibre21">Setting up Database</em> section of this chapter for details.</p>
<p class="calibre3">If you do not want to type long Docker commands and remember options, you can use Docker Explorer’s user interface to create containers. We used<span class="calibre12"> the</span> <kbd class="calibre13">run</kbd> command of Docker to run a MySQL container using the <kbd class="calibre13">mysql</kbd> image. The command first checks whether the required image is already downloaded on the local machine, and if not, it downloads it. Docker images can also be downloaded explicitly using<span class="calibre12"> the</span> <kbd class="calibre13">docker pull</kbd> command. For example, we could have first downloaded the <kbd class="calibre13">mysql</kbd> image by executing<span class="calibre12"> the</span> following command:</p>
<pre class="calibre25"><strong class="calibre1">docker pull mysql</strong></pre>
<p class="calibre3">Once the image is downloaded, it will be displayed in <span class="calibre12">Docker Explorer</span>. Right-click the image and select <span class="calibre12">Run</span>:</p>
<div class="packt_figure1"><img src="../images/00236.jpeg" class="calibre238"/></div>
<div class="packt_figure1">Figure 12.13: Create Docker container from image in Docker Explorer</div>
<p class="calibre3">Follow the wizard to create a container. You can use this option to create multiple instances from the same image, for example, to run multiple MySQL containers.</p>
<div class="packt_tip"><br class="calibre26"/>
The last page in this wizard lets you specify a network for the container.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Deploying microservices in a Docker container</h1>
                
            
            <article>
                
<p class="calibre3">We will now deploy<span class="calibre12"> the</span> <kbd class="calibre13">CourseManagement</kbd> microservice that we created earlier in this chapter (the one using WildFly Swarm) in a Docker container. You can either copy the project and paste it in Eclipse Project Explorer with a different name, or use the same project. The example code has a project called <kbd class="calibre13">coursemanagement-docker</kbd> for this section.</p>
<p class="calibre3">We need to make one change in <kbd class="calibre13">persistence.xml</kbd>. Recall that in our earlier example,<span class="calibre12"> the</span> JDBC URL in this file referred to <kbd class="calibre13">127.0.0.1</kbd> or localhost. This worked then because both the application and the database were running in the same environment. But now our database and application are going to run in separate Docker containers, with isolated runtime environments. Therefore, we can no longer access the database using the localhost URL in the microservice. So, how do we access a database running in a separate container? The answer is using the container name, if both containers are running in the same Docker network mode. We configured the container for the DB to run in the <kbd class="calibre13">coursemanagment</kbd> network, and later in this section we are going to do the same for the microservice container. So, we will need to change the JDBC URL in <kbd class="calibre13">persistence.xml</kbd> to refer to name of the container running our database server, which is <kbd class="calibre13">course-management-mysql</kbd>.</p>
<p class="calibre3">Open <kbd class="calibre13">persistence.xml</kbd> and replace IP <kbd class="calibre13">127.0.0.1</kbd> in the JDBC URL with <kbd class="calibre13">course-management-mysql</kbd>:</p>
<pre class="calibre25">&lt;property name="javax.persistence.jdbc.url" value="jdbc:mysql://course-management-mysql/course_management?autoReconnect=true&amp;amp;useSSL=false"/&gt;</pre>
<p class="calibre3">Next, create a file named Dockerfile in root of the project with<span class="calibre12"> the</span> following content:</p>
<pre class="calibre25">FROM openjdk:8<br class="title-page-name"/>ENV swarm.http.port 8080<br class="title-page-name"/>RUN mkdir microservices<br class="title-page-name"/>COPY ./target/coursemanagement-swarm.jar ./microservices<br class="title-page-name"/>EXPOSE 8080<br class="title-page-name"/>ENTRYPOINT java -jar -Djava.net.preferIPv4Stack=true ./microservices/coursemanagement-swarm.jar</pre>
<p class="calibre3">We will be using this Dockerfile to create the image for our microservice container. Let’s understand each of the instructions in this file:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">FROM openjdk:8</kbd>: The base image for this container is OpenJDK, Version 8.</li>
<li class="calibre11"><kbd class="calibre13">ENV swarm.http.port 8080</kbd>: We are setting the <kbd class="calibre13">swarm.http.port</kbd> <span>environment variable </span>in the container. This is really not necessary for this example, because the WildFly Swarm server runs on port <kbd class="calibre13">8080</kbd> by default. Change the port number if you want to run the server on a different port.</li>
<li class="calibre11"><kbd class="calibre13">RUN mkdir microservices</kbd>: We are creating a folder named <kbd class="calibre13">microservices</kbd> in the container.</li>
<li class="calibre11"><kbd class="calibre13">COPY ./target/coursemanagement-swarm.jar ./microservices</kbd>: We are <kbd class="calibre13">copying coursemanagement-swarm.jar</kbd> from the target folder in our project to<span> the</span> <kbd class="calibre13">microservices</kbd> folder in the container.</li>
<li class="calibre11"><kbd class="calibre13">EXPOSE 8080</kbd>:  We ask Docker Engine to expose port <kbd class="calibre13">8080</kbd> from the container. Our application server listens for requests on port <kbd class="calibre13">8080</kbd> in the container.</li>
<li class="calibre11"><kbd class="calibre13">ENTRYPOINT java -jar -Djava.net.preferIPv4Stack=true ./microservices/coursemanagement-swarm.jar</kbd>: Finally, we specify the main application to execute in the container, which is running the standalone microservice application.</li>
</ul>
<p class="calibre3">We need to build the application to create a single JAR file that we will run in the Docker container. If you try to build the application by running<span class="calibre12"> the</span> Maven goal <kbd class="calibre13">wildfly-swarm:run</kbd> (we did that to run the application earlier), it is going to fail because it will also try to run the application. This is not going to work because we modified the JDBC URL in <kbd class="calibre13">persistence.xml</kbd> with the name of the DB container. So, run the Maven goal to only package the application, without running tests. Right-click on the project in <span class="calibre12">Project Explorer</span> and select <span class="calibre12">Run As</span> | <span class="calibre12">Maven Build</span>:</p>
<div class="packt_figure1"><img src="../images/00237.jpeg" class="calibre239"/></div>
<div class="packt_figure1">Figure 12.14: Eclipse run configuration to package the Docker-microservice project</div>
<p class="calibre3">Enter <kbd class="calibre13">package</kbd> in the <span class="calibre12">Goals</span> field. Select<span class="calibre12"> the</span> <span class="calibre12">Skip Tests</span> option and click <span class="calibre12">Run</span> to create<span class="calibre12"> the</span> application JAR file in the target folder.</p>
<p class="calibre3">Let’s now create<span class="calibre12"> the</span> Docker image from the Dockerfile we created. Right-click on the file in <span class="calibre12">Project Explorer</span> and select<span class="calibre12"> the</span> <span class="calibre12">Run As</span> | <span class="calibre12">Docker Image Build</span> menu option.  </p>
<div class="packt_figure1"><img src="../images/00238.jpeg" class="calibre240"/></div>
<div class="packt_figure1">Figure 12.15: Building a Docker image from a Dockerfile</div>
<p class="calibre3">This will create a Docker image named <span class="calibre12">coursemanagement-microservice</span> and tag it as<span class="calibre12"> the</span> <span class="calibre12">1.0</span> version. Switch to<span class="calibre12"> the</span> <span class="calibre12">Docker Tooling</span> perspective in Eclipse and you should see this image listed.</p>
<p class="calibre3">We are going to create an instance of this image, that is, create a container from this image that will actually run our microservice. Right-click on the image and select <span class="calibre12">Run...</span>:</p>
<div class="packt_figure1"><img src="../images/00239.jpeg" class="calibre241"/></div>
<div class="packt_figure1">Figure 12.16: Creating a container from an image</div>
<p class="calibre3">This opens a wizard to configure the container:</p>
<div class="mce-root1"><img src="../images/00240.jpeg" class="calibre242"/></div>
<div class="packt_figure1"><span>Figure 12.17: Configuring a Docker container</span></div>
<p class="calibre3">Specify a name for the container in the first page of the wizard. Leave <span class="calibre12">Endpoint</span> and <span class="calibre12">Command</span> empty; the image is already created with the <kbd class="calibre13">ENTRYPOINT</kbd> that we specified in the Dockerfile. You can override that in this page, but we are not going to do that.<br class="calibre6"/>
Make sure<span class="calibre12"> the</span> <span class="calibre12">Publish all exposed ports to random ports on the host interfaces</span> option is unchecked. We want to publish port <kbd class="calibre13">8080</kbd> from the container as the same port number to the host. Click <span class="calibre12">Next</span>. Leave the default options on the second page and click <span class="calibre12">Next</span> again.</p>
<div class="mce-root1"><img src="../images/00241.jpeg" class="calibre243"/></div>
<div class="packt_figure1"><span>Figure 12.18: Setting network mode for a Docker container</span></div>
<p class="calibre3">The last page (see <em class="calibre21">Figure 12.18</em>) allows you to specify a network for the container. Here, we are going to specify the network we created earlier, <kbd class="calibre13">coursemanagement</kbd>. Recall that we <span class="calibre12">also</span><span class="calibre12"> </span><span class="calibre12">created a MySQL container with the same network, so that microservice container can access the MySQL container with the container name.</span></p>
<p class="calibre3">Once the application starts in the microservice container, browse to <kbd class="calibre13">http://localhost:8080/course_management/courses</kbd> and you should see list of courses in the database.</p>
<p class="calibre3">The process to deploy the microservice we created using Spring Boot earlier is also similar to the one we saw in this section. One main difference is that in the Spring Boot project, you need to update the JDBC URL in <kbd class="calibre13">application.properties</kbd>, instead of the <kbd class="calibre13">persistence.xml</kbd> that we modified in this section. For your reference, the sample code has a project named <kbd class="calibre13">coursemanagementspring-docker</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Running containers using Docker Compose</h1>
                
            
            <article>
                
<p class="calibre3">We have seen in the preceding sections how to create Docker containers separately by running command-line Docker commands (or from Eclipse plugins). If you want to run multiple containers on a host machine, you should consider using Docker Compose. It allows you to configure multiple Docker containers in one file and also specify dependencies between them. A <kbd class="calibre13">docker-compose</kbd> command reads configuration/instructions from <kbd class="calibre13">docker-compose.yml</kbd>, and creates and runs containers. The <kbd class="calibre13">.yml</kbd> file requires the version number of <kbd class="calibre13">docker-compose</kbd> at the top, followed by a services section, which lists container definitions—specifying image or Dockerfile location, environment variables to be set in the container, ports to be exposed and mapped to<span class="calibre12"> the</span> host OS, and many other configurations. See <a href="https://docs.docker.com/compose/overview/" class="calibre9">https://docs.docker.com/compose/overview/</a> for more details.</p>
<p class="calibre3">In this section, we will use <kbd class="calibre13">docker-compose</kbd> to run MySQL and our webservice containers together. In the later chapter on deploying JEE applications in the cloud, we will use this configuration for deployment. First, install <kbd class="calibre13">docker-compose</kbd> from <a href="https://docs.docker.com/compose/install/" class="calibre9">https://docs.docker.com/compose/install/</a>.</p>
<p class="calibre3">Create a new <span class="calibre12">General</span> Eclipse project (<span class="calibre12">File</span> | <span class="calibre12">New</span> | <span class="calibre12">Project</span> and then <span class="calibre12">General</span> | <span class="calibre12">Project</span>) and name it <kbd class="calibre13">coursemanagement-docker-compose</kbd>. We don’t need a JEE project for this section because we are going to take the single JAR file that we created in the last section for our microservice and deploy it in a Docker container. So, copy <kbd class="calibre13">coursemanagementspring-docker/coursemanagementspring-0.0.1-SNAPSHOT.jar</kbd> to the project folder.</p>
<p class="calibre3">We need to create and initialize a MySQL database in the container. We are going to use a SQL script with <strong class="calibre5">data definition language</strong> (<strong class="calibre5">DDL</strong> for example, <kbd class="calibre13">CREATE</kbd>) statements to create database schema and tables. The source code project for this section, <kbd class="calibre13">coursemanagement-docker-compose</kbd>, has a file, <kbd class="calibre13">course-management-db.sql</kbd>, containing DDL statements. This script creates empty tables with no data.</p>
<p class="calibre3">If you want <span class="calibre12">also</span><span class="calibre12"> </span><span class="calibre12">to export data from your existing database, then you can create the script from MySQL Workbench. From MySQL Workbench, select</span> <span class="calibre12">Server</span> <span class="calibre12">|</span> <span class="calibre12">Data Export</span><span class="calibre12">. Select the schema to export, <kbd class="calibre13">course_management</kbd>. From the</span> drop-down<span class="calibre12"> options, select</span> <span class="calibre12">Dump Structure and Data</span><span class="calibre12">. In</span> <span class="calibre12">Export Options</span><span class="calibre12">, select</span> <span class="calibre12">Export to Self-Contained File</span> <span class="calibre12">and specify<span class="calibre12"> the</span> path of the file, for example, <kbd class="calibre13">&lt;your_project_path&gt;/course-management-db.sql</kbd>. Then, click<span class="calibre12"> the</span></span> <span class="calibre12">Start Export</span> <span class="calibre12">button.</span></p>
<p class="calibre3">Now, let’s create two Dockerfiles in the project:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre13">course-management-db.dockerfile</kbd> for<span> the</span> MySQL container </li>
<li class="calibre11"><kbd class="calibre13">course-management-service.dockerfile</kbd> for<span> the</span> microservice container</li>
</ul>
<p class="calibre3">Create <kbd class="calibre13">course-management-db.dockerfile</kbd> with the following content:</p>
<pre class="calibre25"><strong class="calibre1"> FROM mysql:5.7</strong><br class="title-page-name"/><strong class="calibre1"> COPY ./course-management-db.sql /docker-entrypoint-initdb.d</strong><br class="title-page-name"/><strong class="calibre1"> ENV MYSQL_ROOT_PASSWORD root</strong></pre>
<p class="calibre3">With the <kbd class="calibre13">COPY</kbd> statement in this file, we are copying <kbd class="calibre13">course-management-db.sql</kbd> from the project folder to<span class="calibre12"> the</span> <kbd class="calibre13">docker-entrypoint-initdb.d</kbd> folder in the container. Any SQL script in this file will be executed by the base MySQL image to initialize the database. See the <em class="calibre21">Initializing a fresh instance</em> section at <a href="https://hub.docker.com/_/mysql/" class="calibre9">https://hub.docker.com/_/mysql/</a>.</p>
<p class="calibre3">Create <kbd class="calibre13">course-management-service.dockerfile</kbd> with the following content:</p>
<pre class="calibre25"><strong class="calibre1">FROM openjdk:8</strong><br class="title-page-name"/><strong class="calibre1">RUN mkdir microservices</strong><br class="title-page-name"/><strong class="calibre1">COPY ./coursemanagementspring-0.0.1-SNAPSHOT.jar ./microservices</strong><br class="title-page-name"/><strong class="calibre1">EXPOSE 8080</strong><br class="title-page-name"/><strong class="calibre1">ENTRYPOINT java -jar -Djava.net.preferIPv4Stack=true ./microservices/coursemanagementspring-0.0.1-SNAPSHOT.jar</strong></pre>
<p class="calibre3">In this Dockerfile, we are creating the container from<span class="calibre12"> the</span> <kbd class="calibre13">openjdk:8</kbd> base image. Then, we are creating a folder, <kbd class="calibre13">microservices</kbd>, in the container and then copying <kbd class="calibre13">coursemanagementspring-0.0.1-SNAPSHOT.jar</kbd> from the project folder to<span class="calibre12"> the</span> <kbd class="calibre13">microservices</kbd> folder in the container. We then set the <kbd class="calibre13">ENTRYPOINT</kbd> for the container with the command to execute the copied JAR file.</p>
<p class="calibre3">Lastly, create <kbd class="calibre13">docker-compose.yml</kbd> with<span class="calibre12"> the</span> following content:</p>
<pre class="calibre25">version: "3"<br class="title-page-name"/>services: <br class="title-page-name"/>  course-managemnt-db:<br class="title-page-name"/>    build: <br class="title-page-name"/>      context: .<br class="title-page-name"/>      dockerfile: course-management-db.dockerfile<br class="title-page-name"/>    container_name: course-management-mysql<br class="title-page-name"/>    ports:<br class="title-page-name"/>      - 3306:3306<br class="title-page-name"/>  course-management-service:<br class="title-page-name"/>    build:<br class="title-page-name"/>      context: .<br class="title-page-name"/>      dockerfile: course-management-service.dockerfile<br class="title-page-name"/>    container_name: course-management-service<br class="title-page-name"/>    ports:<br class="title-page-name"/>      - 80:8080<br class="title-page-name"/>    depends_on:<br class="title-page-name"/>      - course-managemnt-db  </pre>
<p class="calibre3">We are creating two services in this file: <kbd class="calibre13">course-managemnt-db</kbd> for the DB container and <kbd class="calibre13">course-management-service</kbd> for the microservice container. Both are built from separate Dockerfiles. The context field specifies<span class="calibre12"> the</span> path of the folder containing the Dockerfile; in this case it is the present folder (which is the project folder). Note that we have specified the dependency of <kbd class="calibre13">course-management-service</kbd> container on <kbd class="calibre13">course-managemnt-db</kbd>. This results in the DB container getting started before the microservice container.</p>
<p class="calibre3">We are mapping port <kbd class="calibre13">8080</kbd> from the microservice container to port <kbd class="calibre13">80</kbd> on the host. The reason is that we are going to deploy these services later in the cloud with the default web server on port <kbd class="calibre13">80</kbd>.</p>
<div class="packt_infobox"><strong class="calibre182">Warning<br class="calibre26"/></strong>The deployment of JEE container in this chapter is meant for the purpose of development and testing only. It is not meant for production and does not follow best practices for a production environment. That falls under the realm of DevOps, which is not within the scope of this book.</div>
<p class="calibre3">Since both the services are in the same <kbd class="calibre13">docker-compose.yml</kbd>, <kbd class="calibre13">docker-compose</kbd> creates a network and adds both containers to the network. So,<span class="calibre12"> the</span> <kbd class="calibre13">course-management-service</kbd> container can access<span class="calibre12"> the</span> <kbd class="calibre13">course-management-mysql</kbd> container by its name. We do not need to create a separate network as we did in the previous section.</p>
<p class="calibre3">See<span class="calibre12"> the</span> <kbd class="calibre13">docker-compose</kbd> file reference at <a href="https://docs.docker.com/compose/compose-file/" class="calibre9">https://docs.docker.com/compose/compose-file/</a> for more configuration options.</p>
<p class="calibre3">To start all the containers configured in <kbd class="calibre13">docker-compose.yml</kbd> together, run<span class="calibre12"> the</span> following command from the Command Prompt (make sure port <kbd class="calibre13">80</kbd> is not taken by another process, because we have mapped microservice container port <kbd class="calibre13">8080</kbd> to port <kbd class="calibre13">80</kbd> on the host):</p>
<pre class="calibre25"><strong class="calibre1">docker-compose up</strong></pre>
<p class="calibre3">Once the containers have started successfully, browse to <kbd class="calibre13">http://localhost/course_management/courses</kbd> and you should see a list of courses, or an empty list if there are no courses in the database.</p>
<p class="calibre3">To run containers in detached/background mode, run the following command:</p>
<pre class="calibre25"><strong class="calibre1">docker-compose up –d</strong></pre>
<p class="calibre3">To stop containers started with <kbd class="calibre13">docker-compose</kbd>, run the following command:</p>
<pre class="calibre25"><strong class="calibre1">docker-compose down</strong></pre>
<p class="calibre3">If you make any changes to Dockerfiles or to <kbd class="calibre13">docker-compose.yml</kbd>, then you need to rebuild the images. Run<span class="calibre12"> the</span> following command to do so:</p>
<pre class="calibre25"><strong class="calibre1">docker-compose build</strong></pre>
<div class="packt_infobox">Refer to <a href="https://docs.docker.com/compose/reference/overview/" class="calibre17">https://docs.docker.com/compose/reference/overview/</a> for details on <kbd class="calibre48">docker-compose</kbd> command-line options.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre3">A microservice is a small application serving a single use case. Microservices are typically REST services and can be deployed quickly. Docker containers are ideally suited to deploying microservices because they allow applications to run in isolation, with little or no difference in development, testing, and production environments. Docker containers can also be deployed very quickly and can scale well.</p>
<p class="calibre3">In this chapter, we saw how to develop microservices using WildFly Swarm and Spring Boot. We created a simple microservice to list courses for our <em class="calibre21">Course Management</em> application. The concepts we learned can be extended to create microservices using other frameworks. We also learned how to deploy these services in Docker containers using the Eclipse plugin for <span class="calibre12">Docker Tooling</span>.</p>
<p class="calibre3">In the next chapter, we will learn how to deploy a JEE application in the cloud.</p>


            </article>

            
        </section>
    </body></html>