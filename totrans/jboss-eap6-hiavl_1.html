<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;JBoss EAP6 Overview"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. JBoss EAP6 Overview</h1></div></div></div><p>In this chapter, we will learn the basic concepts about high availability and have an overview of the functions that JBoss EAP6 provides to us in this field. Then we'll learn how to install JBoss EAP6 and see its basic usages.</p><div class="section" title="Understanding high availability"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Understanding high availability</h1></div></div></div><p>To understand the term <a id="id0" class="indexterm"/>high availability, here is its definition from Wikipedia:</p><div class="blockquote"><blockquote class="blockquote"><p>"High availability is a system design approach and associated service implementation that ensures that a prearranged level of operational performance will be met during a contractual measurement period. Users want their systems, for example, hospitals, production computers, and the electrical grid to be ready to serve them at all times. ... If a user cannot access the system, it is said to be unavailable."</p></blockquote></div><p>In the IT field, when we mention the words "high availability", we usually think of the uptime of the server, and technologies such as clustering and load balancing can be used to achieve this.</p><p>Clustering<a id="id1" class="indexterm"/> means to use multiple servers to form a group. From their perspective, users see the cluster as a single entity and access it as if it's just a single point. The following figure shows the structure<a id="id2" class="indexterm"/> of a cluster:</p><div class="mediaobject"><img src="graphics/2432OS_01_01.jpg" alt="Understanding high availability"/></div><p>To achieve the previously mentioned goal, we usually use a controller of the cluster, called <a id="id3" class="indexterm"/>load balancer<a id="id4" class="indexterm"/>, to sit in front of the cluster. Its job is to receive and dispatch user requests to a node inside the cluster, and the node will do the real work of processing the user requests. After the node processes the user request, the response will be sent to the load balancer, and the load balancer will send it back to the users. The following figure shows the <a id="id5" class="indexterm"/>workflow:</p><div class="mediaobject"><img src="graphics/2432OS_01_02.jpg" alt="Understanding high availability"/></div><p>Besides load balancing user requests, the clustering system can also do failover inside itself.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>Failover means when a node has crashed, the load balancer can switch to other running nodes to process user requests.</p></div></div><p>In a cluster, some <a id="id6" class="indexterm"/>nodes<a id="id7" class="indexterm"/> may fail during runtime. If this happens, the requests to the failed nodes should be redirected to the healthy nodes. The process is shown in the following figure:</p><div class="mediaobject"><img src="graphics/2432OS_01_03.jpg" alt="Understanding high availability"/></div><p>To make failover possible, the node in a cluster should be able to replicate user data from one to another.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>In JBoss EAP6, the Infinispan module, which is a data-grid solution provided by the JBoss community, does the web session replication.</p></div></div><p>If one node fails, the user request could be redirected to another node; however, the session with the user won't be lost. The following figure illustrates failover:</p><div class="mediaobject"><img src="graphics/2432OS_01_04.jpg" alt="Understanding high availability"/></div><p>To achieve the previously mentioned goals, the JBoss community has provided us a powerful set of tools. In the next section we'll have an overview on it.</p></div></div>
<div class="section" title="JBoss EAP6 high availability"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>JBoss EAP6 high availability</h1></div></div></div><p>As a <a id="id8" class="indexterm"/>Java EE application server, <a id="id9" class="indexterm"/>JBoss EAP6 uses modules coming from different open source projects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Web server (JBossWeb)</li><li class="listitem" style="list-style-type: disc">EJB (JBoss EJB3)</li><li class="listitem" style="list-style-type: disc">Web service (JBossWS/RESTEasy)</li><li class="listitem" style="list-style-type: disc">Messaging (HornetQ)</li><li class="listitem" style="list-style-type: disc">JPA and transaction management (Hibernate/Narayana)</li></ul></div><p>As we can see, JBoss EAP6 uses many more open source projects, and each part may have its own consideration to achieve the goal of high availability. Now let's have a brief on these parts with respect to high availability:</p><div class="section" title="JBoss Web, Apache httpd, mod_jk, and mod_cluster"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec06"/>JBoss Web, Apache httpd, mod_jk, and mod_cluster</h2></div></div></div><p>The<a id="id10" class="indexterm"/> clustering for <a id="id11" class="indexterm"/>a web server may be the most popular topic and is well understood by the majority. There are a lot of good solutions in the market.</p><p>For JBoss EAP6, the solution it adopted is to use <a id="id12" class="indexterm"/>Apache <code class="literal">httpd</code>
<a id="id13" class="indexterm"/> as the load balancer. <code class="literal">httpd</code> will dispatch the user requests to the EAP server. Red Hat has led two open source projects to work with <code class="literal">httpd</code>, which are called <a id="id14" class="indexterm"/>
<code class="literal">mod_jk</code>
<a id="id15" class="indexterm"/> and <a id="id16" class="indexterm"/>
<code class="literal">mod_cluster</code>
<a id="id17" class="indexterm"/>. In this book we'll learn how to use these two projects.</p></div><div class="section" title="EJB session bean"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>EJB session bean</h2></div></div></div><p>JBoss EAP6 <a id="id18" class="indexterm"/>has<a id="id19" class="indexterm"/> provided the <code class="literal">@org.jboss.ejb3.annotation.Clustered</code> annotation that we can use on both the <code class="literal">@Stateless</code> and <a id="id20" class="indexterm"/>
<code class="literal">@Stateful</code> session beans.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>The clustered annotation is JBoss EAP6/WildFly specific implementation.</p></div></div><p>When using<a id="id21" class="indexterm"/> <code class="literal">@Clustered</code> with <code class="literal">@Stateless</code>, the session bean can be load balanced; and when <code class="literal">@Clustered</code> is used with the <a id="id22" class="indexterm"/>
<code class="literal">@Stateful</code> bean, the state of the bean will be replicated in the cluster.</p></div><div class="section" title="JBossWS and RESTEasy"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>JBossWS and RESTEasy</h2></div></div></div><p>JBoss EAP6 provides<a id="id23" class="indexterm"/> two web service solutions out of the box. One is JBossWS and the other is RESTEasy. <a id="id24" class="indexterm"/>JBossWS<a id="id25" class="indexterm"/> is a web service framework that implements the JAX-WS specification. RESTEasy<a id="id26" class="indexterm"/> is an implementation of the JAX-RS specification to help you to build RESTFul web services.</p></div><div class="section" title="HornetQ"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>HornetQ</h2></div></div></div><p>HornetQ <a id="id27" class="indexterm"/>is <a id="id28" class="indexterm"/>a high-performance messaging system provided by the JBoss community. The messaging system is designed to be asynchronous and has its own consideration on load balancing and failover.</p></div><div class="section" title="Hibernate and Narayana"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Hibernate and Narayana</h2></div></div></div><p>In the database<a id="id29" class="indexterm"/> and transaction management field, high availability is a huge topic. For example, each database vendor may have their own solutions on load balancing the database queries. For example, PostgreSQL has some open source solutions, for example, Slony and pgpool, which can let us replicate the database from master to slave and which distributes the user queries to <a id="id30" class="indexterm"/>different database nodes in a cluster.</p><p>In the ORM layer, Hibernate also has projects such as <span class="strong"><strong>Hibernate Shards</strong></span> that can deploy a database in a distributed way.</p></div><div class="section" title="JGroups and JBoss Remoting"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>JGroups and JBoss Remoting</h2></div></div></div><p>JGroups<a id="id31" class="indexterm"/> and <a id="id32" class="indexterm"/>JBoss Remoting<a id="id33" class="indexterm"/> are the cornerstone of JBoss EAP6 clustering features, <a id="id34" class="indexterm"/>which enable it to support high availability. JGroups is a reliable communication system based on IP multicasting.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>JGroups is not limited to multicast and can use TCP too.</p></div></div><p>JBoss Remoting is the underlying communication framework for multiple parts in JBoss EAP6.</p></div></div>
<div class="section" title="Domain management"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Domain management</h1></div></div></div><p>Besides<a id="id35" class="indexterm"/> the topics discussed previously, JBoss EAP6 has also introduced a new feature called <span class="strong"><strong>domain management</strong></span>
<a id="id36" class="indexterm"/>. This feature can help us to centralize the management of the EAP6 servers deployed as a cluster. In later chapters of this book we'll learn how to use this feature.</p></div>
<div class="section" title="Installing JBoss EAP6"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Installing JBoss EAP6</h1></div></div></div><p>In the <a id="id37" class="indexterm"/>previous sections, we had an overview of high availability and what <a id="id38" class="indexterm"/>JBoss EAP6 provides to us in relation to this topic. It doesn't matter if you haven't understood all the things. We'll touch these parts in this book step by step to help you build the whole picture. The first step is to install JBoss EAP6. Please download <code class="literal">JBoss EAP 6.1.0.Final</code> from the following URL:</p><p>
<a class="ulink" href="http://www.jboss.org/jbossas/downloads/">http://www.jboss.org/jbossas/downloads/</a>
</p><p>Locate the <span class="strong"><strong>6.1.0.Final</strong></span> version and download the ZIP file. After the ZIP file has been downloaded, extract it. The contents are shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2432OS_01_14.jpg" alt="Installing JBoss EAP6"/></div><p>From the <a id="id39" class="indexterm"/>previous screenshot, we can see a JAR file named <code class="literal">jboss-modules.jar</code>. This JAR file will help us to load the components of the server. The components<a id="id40" class="indexterm"/> of the EAP6 server are located in the <code class="literal">modules</code> directory. This directory contains the components of EAP6 that could be loaded by <code class="literal">jboss-modules.jar</code>.</p><p>The <code class="literal">bin</code> directory contains the start script and other tools that we'll use later.</p><p>The <code class="literal">standalone</code> and <code class="literal">domain</code> directories are related with the EAP6 startup mode. We'll cover it in more detail in the next section.</p></div>
<div class="section" title="The JBoss EAP6 startup mode"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>The JBoss EAP6 startup mode</h1></div></div></div><p>The <a id="id41" class="indexterm"/>startup mode<a id="id42" class="indexterm"/> is a new concept introduced in JBoss EAP6. There are currently two modes provided by EAP6:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The standalone mode</li><li class="listitem" style="list-style-type: disc">The domain mode</li></ul></div><p>And there are two startup scripts in the <code class="literal">bin</code> directory for these two modes:</p><div class="informalexample"><pre class="programlisting">domain.sh     standalone.sh</pre></div><p>Let's see the meanings of these two modes.</p><div class="section" title="The domain mode"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>The domain mode</h2></div></div></div><p>The domain mode <a id="id43" class="indexterm"/>is a new concept introduced in EAP6. A domain means a group of servers that can share configuration/deployment information, which is very useful in a clustering environment.</p><p>For example, we have the three JBoss EAP6 servers running, and they form a cluster. Suppose we have a project called <code class="literal">cluster-demo</code> and want to deploy it to the cluster. The traditional method is to deploy this project to each EAP6 instance manually.</p><p>Fortunately, <a id="id44" class="indexterm"/>with the help of the domain management function in EAP6, we can now configure many EAP6 servers as a server group and deploy a project into this group. Then the project will be deployed into all the EAP6 servers that belong to this group. The domain mode provides a centralized management point to our cluster. The server group also shares the same configuration that is automatically distributed to all nodes. We'll see its usage in later chapters.</p></div><div class="section" title="The standalone mode"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>The standalone mode</h2></div></div></div><p>The <a id="id45" class="indexterm"/>standalone mode is like the traditional JBoss AS running mode, and it doesn't have any domain management features supported during runtime.</p></div></div>
<div class="section" title="Starting JBoss EAP6 in the standalone mode"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Starting JBoss EAP6 in the standalone mode</h1></div></div></div><p>Let's <a id="id46" class="indexterm"/>now <a id="id47" class="indexterm"/>try to start JBoss EAP6 in the standalone mode. Go to the <code class="literal">bin</code> directory and run <code class="literal">standalone.sh</code>. The server output is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2432OS_01_06.jpg" alt="Starting JBoss EAP6 in the standalone mode"/></div><p>Now let's look<a id="id48" class="indexterm"/> at some details on the server output to understand the startup process.</p><div class="section" title="Understanding the startup process"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Understanding the startup process</h2></div></div></div><p>We can<a id="id49" class="indexterm"/> see several important things from the server output. The following is the first one:</p><div class="informalexample"><pre class="programlisting">Started 123 of 177 services (53 services are passive or on-demand)</pre></div><p>From the previous log, we can see that not all the components are started during the EAP6 startup process. This design greatly speeds up the startup time of EAP6. We can see that some services are started by default during the start process:</p><div class="mediaobject"><img src="graphics/2432OS_01_11.jpg" alt="Understanding the startup process"/></div><p>These <a id="id50" class="indexterm"/>components are called subsystems. These subsystems are configured in the <code class="literal">standalone.xml</code> file upon navigating through <code class="literal">standalone/configuration</code>.</p><p>Now let's see the actual command in <code class="literal">standalone.sh</code> that starts the EAP6 server:</p><div class="informalexample"><pre class="programlisting">eval \"$JAVA\" -D\"[Standalone]\" $JAVA_OPTS \
     \"-Dorg.jboss.boot.log.file=$JBOSS_LOG_DIR/server.log\" \
     \"-Dlogging.configuration=file:$JBOSS_CONFIG_DIR/logging.properties\"   \
     -jar \"$JBOSS_HOME/jboss-modules.jar\" \
     -mp \"${JBOSS_MODULEPATH}\" \
     -jaxpmodule "javax.xml.jaxp-provider" \
org.jboss.as.standalone \
     -Djboss.home.dir=\"$JBOSS_HOME\" \
-Djboss.server.base.dir=\"$JBOSS_BASE_DIR\" \
     "$SERVER_OPTS" "&amp;"</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt Publishing books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>From the <a id="id51" class="indexterm"/>previous command, we can see that <code class="literal">jboss-modules.jar</code> is the bootstrap JAR file for the whole EAP6 server, and the entry point is <code class="literal">org.jboss.as.standalone</code>, which is specified in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>-jar \"$JBOSS_HOME/jboss-modules.jar\" org.jboss.as.standalone</strong></span>
</pre></div><p>We'll see more details about the startup process later. Now let's check the configuration file of the standalone mode.</p></div><div class="section" title="The standalone.xml file"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>The standalone.xml file</h2></div></div></div><p>The<a id="id52" class="indexterm"/> structure of <code class="literal">standalone.xml</code> is as follows:</p><div class="mediaobject"><img src="graphics/2432OS_01_07.jpg" alt="The standalone.xml file"/></div><p>As shown in the previous screenshot, <span class="strong"><strong>standalone.xml</strong></span> defines multiple aspects of the standalone service. Let's have a brief view:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>extensions</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>This section<a id="id53" class="indexterm"/> contains a list of extension modules. The components listed here will be loaded by <code class="literal">jboss-modules</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>management</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id54" class="indexterm"/>section contains the configuration related to management interfaces of EAP6 and its security settings.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>profile</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>In this<a id="id55" class="indexterm"/> section, we can configure the settings for each subsystem. Most of the subsystems are the components loaded in the extensions section, and some subsystems are required by EAP6 internally and loaded at startup by default.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>interfaces</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id56" class="indexterm"/>section defines a list of named network interfaces. </p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>socket-binding group</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id57" class="indexterm"/>section contains a list of socket-binding groups, including the set of interfaces that could be used by different modules.</p>
</td></tr></tbody></table></div></div><div class="section" title="Alternative configuration files"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Alternative configuration files</h2></div></div></div><p>Besides the default <a id="id58" class="indexterm"/>file <code class="literal">standalone.xml</code>, EAP6 has provided some other profiles for the standalone mode.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>There is only one profile per standalone configuration file. In contrast, multiple profiles could be defined in the domain configuration file.</p></div></div><p>We can check them in the <code class="literal">standalone/configuration</code> directory:</p><div class="mediaobject"><img src="graphics/2432OS_01_16.jpg" alt="Alternative configuration files"/></div><p>These files define the different profiles for different purposes. The following is a summary of their differences:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>standalone.xml</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the <a id="id59" class="indexterm"/>default setting of standalone mode.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>standalone-full.xml</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>Compared <a id="id60" class="indexterm"/>with the default settings, this profile has added the messaging subsystem (HornetQ and relative components).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>standalone-ha.xml</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>Compared<a id="id61" class="indexterm"/> with the default settings, this profile has added clustering-related components: <code class="literal">mod_cluster</code> and <code class="literal">JGroups</code>, replicable caches powered by Infinispan, and other relative components.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>standalone-full-ha.xml</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>Compared<a id="id62" class="indexterm"/> with the default setting, this profile provides a combination of functions in '-full' and '-ha'.</p>
</td></tr></tbody></table></div><p>To use these alternative configurations during startup, we can use the <code class="literal">-c</code> option when calling <code class="literal">standalone.sh</code>. For example, <a id="id63" class="indexterm"/>if we want to use <code class="literal">standalone-ha.xml</code>, the command is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ./standalone.sh -c standalone-ha.xml</strong></span>
</pre></div><p>Please note that the <code class="literal">-c</code> option assumes that the configuration is located at <code class="literal">$JBOSS_HOME/standalone/</code>.</p></div><div class="section" title="The --help option"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>The --help option</h2></div></div></div><p>Both <code class="literal">standalone.sh</code> and <code class="literal">domain.sh</code> provide us with the help document. We can always use the <code class="literal">--help</code> option<a id="id64" class="indexterm"/> to check it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ standalone.sh --help</strong></span>
</pre></div></div><div class="section" title="Configuration files"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Configuration files</h2></div></div></div><p>In the <code class="literal">bin</code> directory, <a id="id65" class="indexterm"/>there are several configuration files that will be included during the startup process:</p><div class="mediaobject"><img src="graphics/2432OS_01_17.jpg" alt="Configuration files"/></div><p>We can put our own configuration into these files, and it will be included by the startup scripts.</p></div></div>
<div class="section" title="Starting JBoss EAP6 in the domain mode"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Starting JBoss EAP6 in the domain mode</h1></div></div></div><p>In this <a id="id66" class="indexterm"/>section, <a id="id67" class="indexterm"/>let's have a look at the domain mode. Use the following command in the <code class="literal">bin</code> directory to start the EAP6 server in the domain mode:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ./domain.sh</strong></span>
</pre></div><p>We can see that the startup process is different with the standalone mode. Firstly, there are many more <a id="id68" class="indexterm"/>components loaded in the domain mode:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Started 274 of 401 services (126 services are passive or on-demand)</strong></span>
</pre></div><p>And in <code class="literal">domain.sh</code>, we can see that the startup command<a id="id69" class="indexterm"/> is also different:</p><div class="informalexample"><pre class="programlisting">eval \"$JAVA\" -D\"[Process Controller]\" $PROCESS_CONTROLLER_JAVA_OPTS \
      \"-Dorg.jboss.boot.log.file=$JBOSS_LOG_DIR/process-controller.log\" \
      \"-Dlogging.configuration=file:$JBOSS_CONFIG_DIR/logging.properties\"   \
      -jar \"$JBOSS_HOME/jboss-modules.jar\" \
      -mp \"${JBOSS_MODULEPATH}\" \
org.jboss.as.process-controller \
      -jboss-home \"$JBOSS_HOME\" \
      -jvm \"$JAVA_FROM_JVM\" \
      -mp \"${JBOSS_MODULEPATH}\" \
      -- \
      \"-Dorg.jboss.boot.log.file=$JBOSS_LOG_DIR/host-controller.log\" \
      \"-Dlogging.configuration=file:$JBOSS_CONFIG_DIR/logging.properties\"   \
      $HOST_CONTROLLER_JAVA_OPTS \
      -- \
      -default-jvm \"$JAVA_FROM_JVM\" \
      '"$@"'
'jboss-modules.jar' is still used for bootstrap:
-jar \"$JBOSS_HOME/jboss-modules.jar\" \</pre></div><p>Compared with the standalone mode, the entry point is no longer <code class="literal">org.jboss.as.standalone</code>; instead, it becomes <code class="literal">process-contoller</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>org.jboss.as.process-controller</strong></span>
</pre></div><p>There is also a process called <code class="literal">host-controller</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>-Dorg.jboss.boot.log.file=$JBOSS_LOG_DIR/host-controller.log</strong></span>
</pre></div><p>The following figure shows the relationship of these processes when EAP6 is running in the domain mode:</p><div class="mediaobject"><img src="graphics/2432OS_01_08.jpg" alt="Starting JBoss EAP6 in the domain mode"/></div><p>As in the domain mode, a lightweight <a id="id70" class="indexterm"/>
<span class="strong"><strong>Process Controller</strong></span>
<a id="id71" class="indexterm"/> is started first, and then it spawns a <a id="id72" class="indexterm"/>
<span class="strong"><strong>Host Controller</strong></span> process<a id="id73" class="indexterm"/> <a id="id74" class="indexterm"/>that will control multiple server processes. This is because in the domain mode it allows multiple server instances to run at the same time, and each server will have its own JVM process.</p><div class="section" title="The domain mode"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>The domain mode</h2></div></div></div><p>As we have seen previously, when EAP6 is <a id="id75" class="indexterm"/>running in the domain mode, multiple severs can run at the same time. In addition, these servers can belong to different server groups. The servers that belong to the same group will share the deployment and configuration information.</p><p>For example, we have a server group called the <span class="strong"><strong>main-server-group</strong></span>
<a id="id76" class="indexterm"/>, and in this group, we have two servers called <span class="strong"><strong>server-</strong></span>
<a id="id77" class="indexterm"/>
<span class="strong"><strong>one</strong></span> and <span class="strong"><strong>server-two</strong></span>
<a id="id78" class="indexterm"/>. If we deploy a project called <code class="literal">cluster-demo.war</code> in the <span class="strong"><strong>main-server-group</strong></span>, then it will be deployed into both the servers at the same time. And if we change some settings in this group, the settings of these two servers will all get synced:</p><div class="mediaobject"><img src="graphics/2432OS_01_09.jpg" alt="The domain mode"/></div><p>In the previous example the two servers of the same group are in the same machine and the same EAP6 instance. <a id="id79" class="indexterm"/>But actually they can exist in different EAP6 servers, and the servers in the same group can be synced across the network.</p></div><div class="section" title="Configuration files"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Configuration files</h2></div></div></div><p>Unlike the <a id="id80" class="indexterm"/>standalone mode, the domain mode uses two configuration files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">domain.xml</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">host.xml</code></li></ul></div><p>These configuration files are in the location <code class="literal">domain/configuration/</code>. Now let's have a look at <code class="literal">dom</code>
<code class="literal">ain.xml</code> first.</p><div class="section" title="The domain.xml file"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>The domain.xml file</h3></div></div></div><p>The<a id="id81" class="indexterm"/> structure of the <code class="literal">domain.xml</code> file<a id="id82" class="indexterm"/> and its difference with <code class="literal">standalone.xml</code> are shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2432OS_01_10.jpg" alt="The domain.xml file"/></div><p>If we <a id="id83" class="indexterm"/>compare its structure with the standalone mode, we can see the differences. Firstly there are three sections in plural form:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>profiles</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>interfaces</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>socket-binding-groups</strong></span></li></ul></div><p>The reason for this difference is easy to guess. In the domain mode, there are multiple servers running in different server groups, and EAP6 supports each server group to have its own set of settings. So, different profiles, interfaces, and socket-binding-groups will be needed.</p><p>In addition, we can see a new section called <span class="strong"><strong>server-groups</strong></span>. Here is its default setting in <code class="literal">domain.xml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;server-groups&gt;
  &lt;server-group name="main-server-group" profile="full"&gt;
  &lt;socket-binding-group ref="full-sockets"/&gt;
&lt;/server-group&gt;
&lt;server-group name="other-server-group" profile="full-ha"&gt;
  &lt;socket-binding-group ref="full-ha-sockets"/&gt;
  &lt;/server-group&gt;
&lt;/server-groups&gt;</pre></div><p>The previous settings are shown in the following figure:</p><div class="mediaobject"><img src="graphics/2432OS_01_12.jpg" alt="The domain.xml file"/></div><p>In this way,<a id="id84" class="indexterm"/> different server groups are bound to different settings.</p></div><div class="section" title="The host.xml file"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>The host.xml file</h3></div></div></div><p>Now<a id="id85" class="indexterm"/> let's <a id="id86" class="indexterm"/>check <code class="literal">host.xml</code>. The following screenshot shows its <a id="id87" class="indexterm"/>structure:</p><div class="mediaobject"><img src="graphics/2432OS_01_13.jpg" alt="The host.xml file"/></div><p>The <code class="literal">host.xml</code> file<a id="id88" class="indexterm"/> is the setting file for the host controller. It has some parts similar to <code class="literal">standalone.xml</code> such as management and interfaces. Their purposes are also the same. Now let's see the <span class="strong"><strong>domain-controller</strong></span> section.</p></div><div class="section" title="The domain-controller section"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>The domain-controller section</h3></div></div></div><p>The<a id="id89" class="indexterm"/> <span class="strong"><strong>domain-controller</strong></span> section defines <a id="id90" class="indexterm"/>which host is used as the domain controller. The domain controller is actually a host controller, but it acts as the manager of the domain. The default <span class="strong"><strong>domain-controller</strong></span> is set to <code class="literal">local</code>, which means EAP6 will use its host controller as its domain controller by default.</p><p>We can also define a remote host controller as the domain controller. Then multiple EAP6 could connect to the same domain controller and accept its management. Now let's see the <span class="strong"><strong>servers</strong></span> section.</p><div class="section" title="The servers section"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec03"/>The servers section</h4></div></div></div><p>The<a id="id91" class="indexterm"/> <span class="strong"><strong>servers</strong></span> section is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2432OS_01_15.jpg" alt="The servers section"/></div><p>In the domain mode, a host controller can manage several servers at the same time, and each server has their own name and belongs to a server group; these servers are bound to different sockets to avoid conflicts.</p><p>The <span class="strong"><strong>auto-start</strong></span> option<a id="id92" class="indexterm"/> checks whether to start this server during the EAP6 startup. We may choose which server to start during the EAP6 startup by this option.</p><p>The <span class="strong"><strong>port-offset</strong></span> option<a id="id93" class="indexterm"/> is used to bind different servers into different ports to avoid conflict. Let's see the default configuration in <code class="literal">host.xml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;servers&gt;
  &lt;server name="server-one" group="main-server-group"&gt;
    &lt;socket-bindings port-offset="0"/&gt;
  &lt;/server&gt;
  &lt;server name="server-two" group="main-server-group"&gt;
    &lt;socket-bindings port-offset="150"/&gt;
  &lt;/server&gt;
  &lt;server name="server-three" group="other-server-group"&gt;
    &lt;socket-bindings port-offset="250"/&gt;
  &lt;/server&gt;
&lt;/servers&gt;</pre></div><p>The following is the deployment diagram that shows the relationship between the previously discussed servers and server groups:</p><div class="mediaobject"><img src="graphics/2432OS_01_18.jpg" alt="The servers section"/></div><p>Here are the server group settings<a id="id94" class="indexterm"/> in <code class="literal">domain.xml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;server-groups&gt;
  &lt;server-group name="main-server-group" profile="full"&gt;
    &lt;socket-binding-group ref="full-sockets"/&gt;
  &lt;/server-group&gt;
  &lt;server-group name="other-server-group" profile="full-ha"&gt;
    &lt;socket-binding-group ref="full-ha-sockets"/&gt;
  &lt;/server-group&gt;
&lt;/server-groups&gt;</pre></div><p>We can see that the <span class="strong"><strong>main-server-group</strong></span> is bound to <code class="literal">full-sockets</code>, and the <span class="strong"><strong>other-server-group</strong></span> is bound to <code class="literal">full-ha-sockets</code>. These two sockets are defined as follows:</p><div class="informalexample"><pre class="programlisting">&lt;socket-binding-group name="full-sockets" default-interface="public"&gt;
  &lt;socket-binding name="http" port="8080"/&gt;
&lt;/socket-binding-group&gt;
&lt;socket-binding-group name="full-ha-sockets" default-interface="public"&gt;
  &lt;socket-binding name="http" port="8080"/&gt;
&lt;/socket-binding-group&gt;</pre></div><p>The <code class="literal">full-sockets</code> binds to the HTTP port 8080, and <code class="literal">port-offset</code> is 0. So the web port used by <span class="strong"><strong>server-one</strong></span> is 8080; for <span class="strong"><strong>server-two</strong></span>, because its <code class="literal">port-offset</code> is 150, its web port is 8080 + 150 = 8230. Similarly, the HTTP port used by <span class="strong"><strong>server-three</strong></span> is 8080 + 250 = 8330.</p><p>Now let's set <a id="id95" class="indexterm"/>
<span class="strong"><strong>auto-start</strong></span> for all three servers to <code class="literal">true</code> so that they will be started during the EAP6 startup:</p><div class="informalexample"><pre class="programlisting">&lt;servers&gt;
  &lt;server name="server-one" group="main-server-group" auto-start="true"&gt;...&lt;/server&gt;
  &lt;server name="server-two" group="main-server-group" auto-start="true"&gt;...&lt;/server&gt;
  &lt;server name="server-three-master" group="other-server-group" auto-start="true"&gt;...&lt;/server&gt;
&lt;/servers&gt;</pre></div><p>Now let's start EAP6 in the domain mode by calling <code class="literal">domain.sh</code>. After EAP6 starts, let's try to access 8080, 8230, and 8330 with <code class="literal">telnet</code> commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ telnet localhost 8080</strong></span>
<span class="strong"><strong>Trying localhost...</strong></span>
<span class="strong"><strong>Connected to localhost.</strong></span>

<span class="strong"><strong>$ telnet localhost 8230</strong></span>
<span class="strong"><strong>Trying localhost...</strong></span>
<span class="strong"><strong>Connected to localhost.</strong></span>

<span class="strong"><strong>$ telnet localhost 8330</strong></span>
<span class="strong"><strong>Trying localhost...</strong></span>
<span class="strong"><strong>Connected to localhost.</strong></span>
</pre></div><p>We can see all the servers are listening for connections now.</p></div></div></div></div>
<div class="section" title="XSD documents"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>XSD documents</h1></div></div></div><p>JBoss EAP6 has <a id="id96" class="indexterm"/>provided the schema documents in <code class="literal">docs/schema</code>. Each <a id="id97" class="indexterm"/>schema has defined a namespace used by the EAP6 configuration file. For example, we can check the beginning of <code class="literal">standalone.xml</code> and see the xml namespace it's using:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;server &gt;
...</pre></div><p>We can see that the namespace used is <code class="literal">urn:jboss:domain:1.4</code>. Let's find the defined namespace in the <code class="literal">docs/schema</code> directory by using the <code class="literal">grep</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ grep -rl 'urn:jboss:domain:1.4' *</strong></span>
<span class="strong"><strong>jboss-as-config_1_4.xsd</strong></span>
</pre></div><p>We can see that <code class="literal">jboss-as-config_1_4.xsd</code> contains the definition of the xml namespace we are searching for. Now we can check the definitions for each element in this namespace. For example, if we want to understand the meaning of the <span class="strong"><strong>server</strong></span> section in <code class="literal">standalone.xml</code>, we can check its definition in the <code class="literal">xsd</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;xs:element name="server"&gt;
  &lt;xs:annotation&gt;
  &lt;xs:documentation&gt;
    Root element for a document specifying the configuration
    of a single "standalone" server that does not operate
    as part of a domain...
  &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
    ...
&lt;/xs:element&gt;</pre></div><p>As we have seen<a id="id98" class="indexterm"/> in the <a id="id99" class="indexterm"/>previous code snippet, the <code class="literal">xsd</code> schemas are very useful documents. They can help us to understand the meaning of the elements in configuration files.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Summary</h1></div></div></div><p>In this chapter, we have learned the basic concepts of high availability, and we have learned how to install JBoss EAP6 and run it in different modes. We also learned about the two running modes of EAP6. In the next chapter, we will learn to use the EAP6 management console, and we'll use it to deploy projects into EAP6.</p></div></body></html>