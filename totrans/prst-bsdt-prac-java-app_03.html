<html><head></head><body>
		<div id="_idContainer028">
			<h1 class="chapter-number" id="_idParaDest-33"><a id="_idTextAnchor045"/>3</h1>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor046"/>Exploring Architectural Strategies and Cloud Usage</h1>
			<p>In this chapter, we will delve into the topic of architecture from the perspective of services. Specifically, we will explore the relationship between monolithic and microservices architectures and consider the benefits and drawbacks of each approach. We will also examine the use of event-driven architecture as a means of integrating these services. In addition to providing technical foundations, we will aim to provide strategic and contextual insights into how these concepts fit together and why they drive the adoption of various cloud <span class="No-Break">service offerings.</span></p>
			<p>In this book, we will aim to not only provide a solid foundation in technical Java persistence concepts but also offer strategic and contextual insights into how these ideas are interconnected and why they contribute to the growing adoption of various cloud <span class="No-Break">service offerings.</span></p>
			<p>This chapter covers the aforementioned topics throughout the <span class="No-Break">following sections:</span></p>
			<ul>
				<li>The cloud’s influence on software <span class="No-Break">architecture design</span></li>
				<li>Design patterns – the essential building blocks for <span class="No-Break">software architects</span></li>
				<li><span class="No-Break">Monolithic architecture</span></li>
				<li><span class="No-Break">Microservices architecture</span></li>
			</ul>
			<p>By the end of this chapter, you will have a deeper understanding of how the overall solution architecture affects data integration design and the pros and cons of using a combination of on-premises and cloud solutions, resulting in hybrid and/or <span class="No-Break">multi-cloud models.</span></p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor047"/>The cloud’s influence on software architecture design</h1>
			<p>While we could start by delving into the specific details of multiple architectural topics – including monolithic, microservices, SOA, event-driven, and event sourcing – we’re going to take a different approach. We’ll start by providing you with a deeper understanding of these patterns and their importance in software design. Having this background will help to broaden your horizons. Let’s explore a few design patterns in <span class="No-Break">more detail.</span></p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor048"/>Design patterns – the essential building blocks for software architects</h2>
			<p>Over the past few decades, we’ve identified and shared “<em class="italic">ideas that have been useful in one practical context and will probably be useful in others</em>,” as wisely said by <span class="No-Break">Martin Fowler:</span></p>
			<p class="author-quote">The constant flow of ideas, experiences, and solutions shared by tech enthusiasts worldwide converge into a rich knowledge base that drives and accelerates technological evolution.</p>
			<p>Patterns describe solutions at different levels, from code-level practices to application-level practices. Among the hundreds of patterns out there, we will highlight the practices of design patterns, enterprise application patterns, and software architecture patterns to help us build a solid <span class="No-Break">persistence layer.</span></p>
			<p>The <strong class="bold">Gang of Four</strong> (<strong class="bold">GoF</strong>) design patterns and the <strong class="bold">Service-Oriented Architecture </strong>(<strong class="bold">SOA</strong>) pattern were important foundations for the more recent Microservices Architecture and Event-Driven <span class="No-Break">Architecture patterns.</span></p>
			<p>Microservices architecture, which has gained popularity in recent years, is an approach to designing and building software systems as a collection of small, independently deployable services. This architecture pattern builds on the ideas of modularity and separation of concerns that were central to SOA but takes them to a <span class="No-Break">deeper level.</span></p>
			<p>People often adopt solutions that they don’t actually need because they lack the ability to analyze trends and navigate tech hype. It’s important to remember that the goal should be to identify the best solution to a specific problem using available technologies, rather than simply targeting the delivery of cloud-native microservices or other trendy solutions. The key is to understand how to solve a set of business problems using the <span class="No-Break">right technology.</span></p>
			<p class="callout-heading"><a id="_idTextAnchor049"/>Thinking about tech trends – a few things to keep in mind</p>
			<p class="callout"><a id="_idTextAnchor050"/>A common way to decide whether a specific trend is appropriate for your scenario is to refer to its <em class="italic">technology adoption life cycle</em>. It brings market adoption insights that help you understand the topic’s current maturity; in other words, the more people adopting a specific solution, the more success cases will show up. Not only that but also horror stories, adoption challenges, pros and cons, recommendations, and so on will appear. Looking at the bigger picture, the different maturity groups provide more understanding about the market segments that are embracing <span class="No-Break">the technology.</span></p>
			<p>We now understand that patterns are a set of building blocks that can be used to achieve specific business goals. There are hundreds of patterns covering multiple levels and aspects of application solutions, and new patterns can be derived from the concepts of previous ones. It’s important to keep in mind that patterns can be combined and used in different ways to address different goals. For example, a Java service could adopt the repository pattern for its persistence layer, be built on best practices for a microservices architecture, use enterprise integration patterns to communicate with other services, follow the recommendations of 12-factor applications for cloud-native applications, and adopt design patterns for automated <span class="No-Break">pipeline delivery.</span></p>
			<p>With this in mind, let’s delve into the pros and cons of different architectural options such as microservices and monolithic apps, taking into consideration fundamental needs <span class="No-Break">and features.</span></p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor051"/>Monolithic architecture</h2>
			<p>A traditional way to build a solution is using <strong class="bold">monolithic</strong> applications, which are large, standalone software systems that are built as single, cohesive units, with all components being contained within a single package and compiled, managed, and <span class="No-Break">deployed together:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer021">
					<img alt="Figure 3.1 – Monolithic application characteristics" src="image/Figure_3.01_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Monolithic application characteristics</p>
			<p>This means that both the frontend and backend are included in the same artifact and must be compiled, managed, and deployed together. While this method can make it easier to initially develop and maintain the application, as the team grows, the maintenance of the code becomes more complex, and deploying updates becomes more challenging <span class="No-Break">and time-consuming.</span></p>
			<p>Performance-wise, scalability is impacted since it is very difficult to upscale or downscale specific features <span class="No-Break">or components.</span></p>
			<p>Defining the relationship between a database and a monolith is not a complex task. Instead of huge databases, some opt to develop monoliths that store and consume data from multiple databases – further increasing <span class="No-Break">maintenance complexity.</span></p>
			<p>Surprisingly, it is possible to create modular applications using a monolithic architecture. Such applications can be designed in a modular fashion, with each module responsible for a specific set of functions and developed independently of the <span class="No-Break">other modules.</span></p>
			<p>N<a id="_idTextAnchor052"/>ext, to verify its maturity, let’s refer to the broad market adoption and feedback. According to trend reports [2] from 2022, the modular monolithic architectural approach has already crossed the chasm and gained widespread adoption among the early <span class="No-Break">majority group.</span></p>
			<p>A<a id="_idTextAnchor053"/>s with every architectural design, this approach has its advantages and disadvantages. We can analyze the benefits from multiple angles, including (but not restricted to) characteristics such as maintainability, deployment processes and frequency, validation processes, automation pipelines, and others. <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.2</em> displays key topics to analyze when designing an app that can result in requiring different levels of effort and cost during each phase of the application life cycle. Some prioritize long-term benefits such as ease of maintenance. Others will prefer to adopt strategies with an easier and <span class="No-Break">faster start:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer022">
					<img alt="Fi﻿gure 3.2 – Decision points during application design" src="image/Figure_3.02_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Fi<a id="_idTextAnchor054"/>gure 3.2 – Decision points during application design</p>
			<p>Th<a id="_idTextAnchor055"/>e best choice will depend on each business need being addressed. In regard to the monolithic architectural style, it is established that its characteristics can represent a significant roadblock for the organization, particularly as the application grows in complexity with multiple development teams and numerous features. Changes and additions to the application in this environment become costly and scaling <span class="No-Break">becomes difficult.</span></p>
			<p>In the face of the downsides of a monolith design inspired by the SOA approach, the concept of microservices comes into play. Microservices propose the decoupling of the components/modules into smaller services, each of which having their own <span class="No-Break">unique responsibility.</span></p>
			<p>Even though microservices involve managing more failure points, a successful implementation allows for benefits such as independent teams, changes, deployments, and scaling of each service within the ecosystem, without affecting the other microservices. This is achieved when maintaining the principle of integrity of each individual service. Let’s delve further into the topic and examine the details <span class="No-Break">more closely.</span></p>
			<h2 id="_idParaDest-38">Mi<a id="_idTextAnchor056"/>croservices architecture</h2>
			<p>Mi<a id="_idTextAnchor057"/>croservice-oriented architecture brings the idea of creating applications decoupled from each other and modeled according to their business domain. These applications are integrated through different protocols, and various communication patterns (REST, GRPC, and asynchronous events, among others) and integration patterns can be adopted. Using a microservice-oriented architecture facilitates quicker and more regular deliveries, as well as introducing a <span class="No-Break">language-agnostic ecosystem.</span></p>
			<p>A microservices architecture has services that are decoupled and independent of other microservices that compose the broader solution. As Sam Newman states in his book <em class="italic">Building Microservices</em>, there are implicit concepts and behaviors expected from a microservice, as described in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer023">
					<img alt="Figure 3.3 – Microservices characteristics" src="image/Figure_3.03_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Microservices characteristics</p>
			<p>Architects and developers should have in mind not only a core set of characteristics of a microservices architecture but also the critical elements that can result in immense risk to the project, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Integration latency</strong>: In a monolithic application, the components communicate directly in memory rather than over a network. The result is faster communication compared to the microservices scenario. However, as the number of services and architectural complexity increases, the risk of performance issues and latency increases – potentially becoming a catastrophic problem. To mitigate this risk, take it as a good practice to have proper monitoring and management of thresholds for a service’s invocation response time, including the capability of a client service to handle such issues by itself. A recommendation and good practice is to have fault tolerance capabilities in client microservices. For instance, clients should be able to retry previously failed invocations, have proper fallbacks (instead of shutting down due to errors), and be able to reestablish themselves once the requested service comes back to <span class="No-Break">normal functioning.</span></li>
				<li><strong class="bold">Separation of duties</strong>: Pay attention to the separation of duties of the backend and frontend components. One frontend may depend on multiple backend services. Frontend solutions must be implemented so that, in the event of failure of one of the requested backend services, only the specific associated features have their normal functioning interrupted – all other frontend components should still work properly, guaranteeing the best possible experience possible for the <span class="No-Break">end user.</span></li>
				<li><strong class="bold">Polyglot environment trap</strong>: The microservice architecture is agnostic to languages and frameworks. Consequently, your environment can become a polyglot. From an architectural and technical leadership perspective, be thrifty in evaluating the technologies to be used so that you don’t end up with services implemented with technologies for whose maintenance you lack the required staff. The scope definition and the microservice size should be taken as measures for <span class="No-Break">such definitions.</span></li>
				<li><strong class="bold">Service size and responsibility</strong>: Determining an appropriate size and scope of a microservice may require the investment of time and effort upfront, at the beginning of the journey to decoupling. Remember to carefully consider the principle of single responsibility (<strong class="bold">SOLID</strong>) when measuring a service’s scope <span class="No-Break">and size.</span></li>
				<li><strong class="bold">Forgotten services</strong>: One of the governance challenges is to avoid the existence of orphaned applications in a productive environment. Try to avoid services without owners by establishing a team for each service, including during productive phases. With that, in the face of an unexpected problem or a new change request, it will be simpler to map and define who should be responsible for <span class="No-Break">the tasks.</span></li>
				<li><strong class="bold">Granular repositories</strong>: Avoid breaking up projects into too many repositories, as this over-granulation can become an unmanageable scenario with more repositories than collaborators in <span class="No-Break">the company.</span></li>
			</ul>
			<h2 id="_idParaDest-39">Com<a id="_idTextAnchor058"/>mon pitfalls of microservices adoption</h2>
			<p>Microservices architecture adoption brings multiple implications and challenges, and as we should know by now, and as stated in the book <em class="italic">Fundamentals of Software Architecture: An Engineering Approach</em> (<a href="https://www.amazon.com/dp/B08X8H15BW">https://www.amazon.com/dp/B08X8H15BW</a>), everything has trade-offs – and<em class="italic"> microservices are </em><span class="No-Break"><em class="italic">no exception.</em></span></p>
			<p>While initially thought to be a promising approach, the microservices journey has proven to be more complex than estimated by the broader tech industry, especially for small teams. As its adoption increased, we also observed more reports about a range of design issues and missteps. To avoid common pitfalls, it is important to watch out for the <span class="No-Break">following mistakes.</span></p>
			<h3>Imp<a id="_idTextAnchor059"/>roperly breaking down domains into microservices</h3>
			<p>It is very easy to make mistakes when mapping the business problems down to domains, and domains to microservices, especially when starting the move to a microservices approach. This domain leads to solutions that require requests to multiple services to be able to retrieve a relevant set of business data, instead of providing it efficiently through a single request. In other words, regarding data retrieval and querying, an incorrect scope definition can lead to complex code implementation and poorly <span class="No-Break">performing solutions.</span></p>
			<p>Here are some pointers to help guide you find the <span class="No-Break">right path:</span></p>
			<ul>
				<li>Stakeholders and business experts are involved in the process of domain definition as they can give helpful inputs concerning <span class="No-Break">domain boundaries</span></li>
				<li>Microservices should have well-defined scope; be responsible for one “thing” and be able to do it well; have functionalities that easily fit together (in other words, that are cohesive); be independently deployable and scalable; and keep in mind that a monolith has higher chances of being more performant since processing happens all in memory, without extra network latency added during <span class="No-Break">microservices integration</span></li>
			</ul>
			<p>Generally speaking, cross-domain services integration can rely on multiple strategies, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li>Usage of an API gateway to route requests back and forth and filter, transform, and aggregate requested data from multiple sources in one <span class="No-Break">client request</span></li>
				<li>Data denormalization across services which may result in data duplication in exchange of more efficient data retrieval and querying, relying on techniques such as event-driven architecture to reduce the number of requests needed to retrieve data, or, having event-driven services that can asynchronously filter, aggregate, enrich and provide access to <span class="No-Break">relevant data</span></li>
			</ul>
			<h3>Au<a id="_idTextAnchor060"/>tomation gap</h3>
			<p>As development teams are broken down into smaller and more numerous groups, they start delivering more services, more frequently. The operations of these services’ life cycle shouldn’t obstruct their potential fast-paced evolution. <strong class="bold">Continuous Integration and Continuous Deployment </strong>(<strong class="bold">CI/CD</strong>) is a best practice for microservices and is essential for managing multiple services deployed across multiple deployment environments, ranging from on-premises machines to <span class="No-Break">cloud services.</span></p>
			<h3>Ado<a id="_idTextAnchor061"/>pting as many languages and technologies as teams desire</h3>
			<p>Deciding on programming languages is certainly one of the most intriguing topics. Even though programmers love to brag about programming languages that allow them to write ultra-short “Hello World” examples and base their decisions on this type of argument, to this day, we have not come across a single project that had a core business goal to output text into some sort of console, terminal, or even <span class="No-Break">write HTML.</span></p>
			<p>A critical decision such as the programming language of a service should not be solely based on the number of lines or the line simplicity of <span class="No-Break">a sample.</span></p>
			<h3>An <a id="_idTextAnchor062"/>application must become a microservice because it is big</h3>
			<p>Kindly realize that not every large application <em class="italic">needs </em>to be a microservice. Here’s an interesting metric we’d like you to be familiar with: <em class="italic">cost per line </em><span class="No-Break"><em class="italic">of code.</em></span></p>
			<p>(<a href="https://medium.com/swlh/stop-you-dont-need-microservices-dc732d70b3e0"><span class="No-Break">https://medium.com/swlh/stop-you-dont-need-microservices-dc732d70b3e0</span></a><span class="No-Break">).</span></p>
			<p>The cost mentioned in the link includes computational resources and manpower, including potential changes the organization processes will go through, and potential new software solutions such as containers and <span class="No-Break">container orchestrators.</span></p>
			<p>Different from its counterpart, the monolith, in a microservices architecture, the smaller its code size, the higher the <em class="italic">cost per line of code</em>, as everything and everyone involved in the service’s existence is still required. Sadly, a successfully delivered microservice is only one part of what’s needed to solve the actual <span class="No-Break">business problem.</span></p>
			<h3>Not<a id="_idTextAnchor063"/> taking the best out of independent microservices scaling</h3>
			<p>Scalability is one of the key advantages of microservices. However, it’s important to consider whether it makes sense to scale a component individually. In some cases, it may be more effective to scale the entire system together. Think about it: would it make sense to exclusively scale up unique, smaller parts of the <span class="No-Break">broader solution?</span></p>
			<h3>Inc<a id="_idTextAnchor064"/>onsistent data</h3>
			<p>Microservices rely on data, and just as with any other distributed database, they’re subject to the CAP theorem. This means that whenever you have to update multiple services, you will end up with an added layer of complexity in <span class="No-Break">your application.</span></p>
			<p>One way to work through this is to adopt the SAGA pattern. However, this additional layer of complexity can often have a negative impact on the overall consistency of your data <span class="No-Break">as well.</span></p>
			<h3>Beg<a id="_idTextAnchor065"/>inning with microservices</h3>
			<p>It’s generally a bad idea to assume your project will be based on microservices. This can lead to big problems down the road, especially when it comes to domain definition. Small mistakes can result in several incorrect interdependencies between services and tight coupling. This is why many experts recommend using joins when handling relational data or subdocuments when working with a NoSQL database such <span class="No-Break">as MongoDB.</span></p>
			<p>While joins are a powerful feature in relational databases that allow us to combine data from different tables using foreign keys, they can be inefficient and time-consuming in NoSQL databases, especially for large datasets. This is because joins require multiple queries to be executed and can result in significant network traffic and <span class="No-Break">resource consumption.</span></p>
			<p>In addition, NoSQL databases are optimized for query performance based on the access patterns and usage of <span class="No-Break">the application.</span></p>
			<p>Therefore, it is generally recommended to model the data to minimize the need for joins and use denormalization and embedding techniques to combine related data into a <span class="No-Break">single document.</span></p>
			<p>However, there may be some cases where joins are necessary for NoSQL databases. In those cases, NoSQL databases offer different ways to perform joins, such as using <strong class="source-inline">$lookup</strong> in MongoDB or MapReduce, designed to work more efficiently with the NoSQL <span class="No-Break">data model.</span></p>
			<p class="callout-heading">Tip – references for common mistakes when adopting microservices</p>
			<p class="callout">There’s no need to feel discouraged by the challenges presented here; when the architecture is used correctly and in favorable scenarios, it fits perfectly. The point is, <em class="italic">there is no Holy Grail or </em><span class="No-Break"><em class="italic">silver bullet</em></span><span class="No-Break">.</span></p>
			<p class="callout">If you want to keep on learning about common mistakes when adopting microservices, refer to the following reading recommendations: Ebin John’s <em class="italic">Stop, you don’t need microservices </em>(<a href="https://medium.com/swlh/stop-you-dont-need-microservices-dc732d70b3e0">https://medium.com/swlh/stop-you-dont-need-microservices-dc732d70b3e0</a>) and <em class="italic">Should I use Microservices? by Sam </em><span class="No-Break"><em class="italic">Newman</em></span><span class="No-Break"> (</span><a href="https://www.oreilly.com/content/should-i-use-microservices/"><span class="No-Break">https://www.oreilly.com/content/should-i-use-microservices/</span></a><span class="No-Break">).</span></p>
			<p>We have so far outlined the concepts of monolithic and microservices architecture, explored the three main cloud delivery models, IaaS, PaaS, and SaaS, and learned that they can be combined to best fit an <span class="No-Break">organization’s needs.</span></p>
			<p>Next, let’s expand on cloud deployment models and how having multiple cloud deployment options can help teams to shorten development cycles, fill knowledge gaps, and allow teams to apply their knowledge and effort <span class="No-Break">more productively.</span></p>
			<h1 id="_idParaDest-40">Clo<a id="_idTextAnchor066"/>ud deployment strategies that favor modern stateful solutions</h1>
			<p>A cloud deployment model allows applications to rely on an infrastructure that has on-demand usage, elasticity, resiliency, measured access, and other fundamental aspects. Let’s have a look at deployment model strategies, such as public and private clouds, how to derive two combinations of them through the hybrid and multi-cloud models, and how best to leverage the available cloud deployment strategies to deliver stateful <span class="No-Break">applications efficiently.</span></p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor067"/>Why the hybrid and multi-cloud models matter</h2>
			<p>In the search for better flexibility, access to vendor-specific capabilities, integration options, and cost reduction, combinations of cloud deployment models have started to be used more frequently. Organizations have started to combine public and private deployment models and benefit from both private cloud with public cloud services, with a <strong class="bold">hybrid cloud</strong> model. Another strategy used is the <strong class="bold">multi-cloud</strong> model, which isused when there’s a need to run or consume the same service type from <span class="No-Break">different vendors.</span></p>
			<p>When you combine both public and private clouds and leverage similar cloud services from multiple vendors, you are then working with a <strong class="bold">hybrid multi-cloud </strong><span class="No-Break"><strong class="bold">deployment model</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that the best deployment model isn’t the one with the highest number of words in its name – the best model is the one that solves your organization’s <span class="No-Break">existing problems.</span></p>
			<p>What with the amount of different technologies and solutions out there, it is natural that teams won’t be able to build expertise in every single technology. The fact that it is hard to build a suitably diverse team – in terms of expertise – results in one of two possibilities: a poorly managed and maintained underlying persistence infrastructure or a restricted set of options to be used <span class="No-Break">by developers.</span></p>
			<p>Since data management is such a business-critical component, it shouldn’t be overlooked. That is where we can relate to our cloud story:<em class="italic"> would it be possible for our business to delegate the management of data storage responsibility to someone else?</em> At this point, we understand that hybrid and multi-cloud models can provide the easy scaling up and down of several types of cloud computing resources. <em class="italic">If only we had a database with </em><span class="No-Break"><em class="italic">such capabilities…</em></span></p>
			<p>It turns out we do have one – it is called <strong class="bold">Database as a </strong><span class="No-Break"><strong class="bold">Service</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">DBaaS</strong></span><span class="No-Break">).</span></p>
			<p>Besides being able to get everything up and running quickly, using DBaaS, it is possible to delegate complex tasks such as monitoring, version maintenance, security patches maintenance, disaster recovery, and backup. Beyond that, it makes it possible to adopt data storage technologies for which there are no specialized professionals in the team yet, facilitating the freedom of choice to pick the best solution for each scenario. However, if there’s a need to directly access the servers that are running the databases or have full control over sensitive data being transferred and stored, DBaaS is not a viable solution. Examples of DBaaS offerings available in the market today are Amazon RDS, AWS Aurora MySQL, Microsoft Azure SQL Database, ScyllaDB, and <span class="No-Break">MongoDB Atlas.</span></p>
			<p>And this is where you get the best of both worlds when architecting solutions: by using decoupled and independent services, you can rely on public cloud services such as DBaaS offerings where they fit, exclusively for the particular services in need, and rely on on-premises data storage solutions for the services that can’t deal with the disadvantages of a public <span class="No-Break">cloud offering.</span></p>
			<p>With distributed services across these different deployment models, services integration is a critical architectural aspect <span class="No-Break">to consider.</span></p>
			<h1 id="_idParaDest-42">Dis<a id="_idTextAnchor068"/>tributed systems and their impact on data systems</h1>
			<p>Microservices are small pieces of a big puzzle: each piece can only serve its true value once the whole puzzle is put together. The qualities of reliability, resiliency, and scalability should not be catered to at each individual service level, but actually, for the proposed integration solution; after all, we agree with Martin Fowler’s idea that integration should be treated as strategic <span class="No-Break">to businesses.</span></p>
			<p><em class="italic">“A microservice-based solution’s performance is only as good as the ability of its individual components to </em><span class="No-Break"><em class="italic">communicate efficiently.”</em></span></p>
			<h2 id="_idParaDest-43">Exa<a id="_idTextAnchor069"/>mple – architecting a food delivery solution</h2>
			<p>In distributed architectures, handling data integration across services can be difficult. Therefore, we are about to explore architectural concepts and mistakes around integration through a simple example – a microservice-based solution for a food delivery website. Narrowing down the scope, the discussion takes into consideration <span class="No-Break">the following:</span></p>
			<ul>
				<li>The microservices <span class="No-Break">backend layer</span></li>
				<li>The microservices <span class="No-Break">data storage</span></li>
				<li>The <span class="No-Break">cross-services integration</span></li>
			</ul>
			<p>Next, let’s look at how the solution is initially drafted as a microservice architecture, and how the integration of these services can highly affect data management and consistency <span class="No-Break">across services.</span></p>
			<h2 id="_idParaDest-44">The<a id="_idTextAnchor070"/> basic scenario</h2>
			<p>In the early development phases, it may look like a non-problematic scenario. For the food delivery example, picture a solution, represented in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.4</em>, composed of four microservices, each backed by its persistence and data storage strategy: <strong class="bold">Order Service</strong>, <strong class="bold">Payment Service</strong>, <strong class="bold">Kitchen Service</strong>, and <strong class="bold">Delivery Service</strong>. The figure represents the microservices, each with its own <span class="No-Break">persistent storage.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer024">
					<img alt="Figure 3.4 – Food delivery service’s representation" src="image/Figure_3.04_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Food delivery service<span xml:lang="en-GB">’</span>s representation</p>
			<p>The happy path of this sample is this: whenever a customer creates and pays for a new <em class="italic">order</em>, the kitchen cooks it and sends it over to the delivery team, which in turn delivers the order to the customer. <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.5</em> demonstrates the new-order process from creation to delivery, where the business flow is processed across the four <span class="No-Break">independent microservices.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer025">
					<img alt="Figure 3.5 – Food delivery business’s requirement﻿s" src="image/Figure_3.05_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Food delivery business<span xml:lang="en-GB">’</span>s requirements</p>
			<p>From a technical standpoint, this business requirement can be described <span class="No-Break">as follows:</span></p>
			<ol>
				<li><strong class="bold">Order Service</strong>: Registers a new <span class="No-Break">order 0001</span></li>
				<li><span class="No-Break"><strong class="bold">Payment Service</strong></span><span class="No-Break">:</span><ol><li>Registers the required payment for <span class="No-Break">order 0001</span></li><li>Registers a successful payment of <span class="No-Break">order 0001</span></li></ol></li>
				<li><span class="No-Break"><strong class="bold">Kitchen Service</strong></span><span class="No-Break">:</span><ol><li>Notifies incoming <span class="No-Break">order 0001</span></li><li>Registers that order 0001 is <span class="No-Break">being prepared</span></li><li>Registers that order 0001 is ready <span class="No-Break">for delivery</span></li></ol></li>
				<li><span class="No-Break"><strong class="bold">Delivery Service</strong></span><span class="No-Break">:</span><ol><li>Notifies that order 0001 is ready to go to <span class="No-Break">its customer</span></li><li>Registers delivery of 0001 <span class="No-Break">as completed</span></li></ol></li>
			</ol>
			<p>To grasp the nuances of this seemingly straightforward business requirement, we must go into the technicalities and explore the various obstacles and <span class="No-Break">potential solutions.</span></p>
			<p>Could this solution be a monolith? Yes, it could. However, delivery services, especially those that are spread across multiple customers/order providers/delivery providers, are built on an extensive list of business needs not covered in a simple example used for learning purposes. The architectural solutions for and business needs of real-world delivery services such as Uber Eats and DoorDash are good examples of complex, <span class="No-Break">real-world scenarios.</span></p>
			<p>This solution’s microservice has an independent database, which not only aligns with the microservice’s ideas but also brings a good level of encapsulation and reduces the number of errors caused by changes (e.g., <span class="No-Break">schema changes).</span></p>
			<h2 id="_idParaDest-45">T<a id="_idTextAnchor071"/>he challenges of integrating services around a central piece of data</h2>
			<p>Even though all four services are designed to be <em class="italic">independent</em>, they all function around one key feature: the <em class="italic">order</em>. And a problem regarding this data appears: <em class="italic">how do you manage and handle order data across the </em><span class="No-Break"><em class="italic">four services</em></span><span class="No-Break">?</span></p>
			<h3>M<a id="_idTextAnchor072"/>icroservices’ shared database</h3>
			<p>Some could leverage data storage as the integration layer for these services, having a single schema holding not only the order details but also the payment, kitchen, and delivery information as well. Unfortunately, this is an inadvisable solution known as shared databases (a.k.a. integration databases). <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.6</em>. shows that in this case, all services rely on a single schema to maintain an <span class="No-Break">order’s information:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer026">
					<img alt="Figure 3.6 – Shared database ant﻿i-pattern" src="image/Figure_3.06_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Shared database anti-pattern</p>
			<p>In the preceding example, a service implementation may look simple since it doesn’t have to handle integration aspects. However, multiple problems were added to the solution, and design principles <span class="No-Break">were broken:</span></p>
			<ul>
				<li>Microservices should be decoupled <span class="No-Break">and independent.</span></li>
				<li>Bottlenecks and performance impacts, as well as unexpected exceptions such as <span class="No-Break">lock exceptions.</span></li>
				<li>Involvement of multiple business areas since bounded contexts are <span class="No-Break">not respected.</span></li>
				<li>Changes to the database may require changes to <span class="No-Break">all services.</span></li>
				<li>Multiple services acting on the same data might lead <span class="No-Break">to inconsistency.</span></li>
				<li>Higher risk of bugs and errors. For instance, a change made to one service that is not expected by all <span class="No-Break">other services.</span></li>
			</ul>
			<p>Considering the aforementioned problems and many more, it becomes easy to see that this is not a <span class="No-Break">good route.</span></p>
			<h3><a id="_idTextAnchor073"/>Dual-write anti-pattern</h3>
			<p>Trying to avoid the aforementioned problems, we might consider having independent services, each with its respective database. However, in this solution, services do not maintain a copy of the order on their databases, but they should also update the order status both in their databases and in the order <span class="No-Break">service’s database.</span></p>
			<p>In <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.6</em>, observe that the order service is independent and maintains order data in its data storage. However, other services rely on replicating order data in their own databases and maintaining an order’s status in both databases – their own and the <span class="No-Break">order service’s:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer027">
					<img alt="Figure 3.7 – Dual-write anti-pattern﻿" src="image/Figure_3.07_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Dual-write anti-pattern</p>
			<p>And this, dear reader, is yet another anti-pattern: the <em class="italic">dual-write</em> anti-pattern. It brings high chances of ending up with inconsistent data and integrity issues, as it is not possible to ensure that both writes will complete successfully or none at all, as in a single transaction. It’s a common mistake in scenarios such as handling distributed data systems, using exclusive data storage for analytics, implementing dedicated search index tools, and designing event-driven solutions (e.g., writing the same data to a database <span class="No-Break">and Kafka).</span></p>
			<p>Right upfront, we’ve highlighted two red flags for distributed architecture regarding data access <span class="No-Break">and management:</span></p>
			<ul>
				<li>The first is that a service should not directly change any data owned and consumed by another service, as represented by the arrows in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.7</em>, where all services are modifying data in the order <span class="No-Break">service’s database</span></li>
				<li>The second is that one service should <em class="italic">not</em> be responsible for, or act upon, the manipulation and maintenance of data persistence and consistency across multiple data storage solutions, including not only cross-services as shown in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.5</em> but also between different data storage types as exemplified in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.6</em></span></li>
			</ul>
			<p>Both anti-patterns, as well as use cases and potential solutions and strategies for data integration, are explored in great depth in <a href="B19375_10.xhtml#_idTextAnchor175"><span class="No-Break"><em class="italic">Chapter 10</em></span></a> and <a href="B19375_11.xhtml#_idTextAnchor184"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>. For now, it is enough to have the awareness that <em class="italic">there are anti-patterns in distributed data service integration</em> that can result in performance bottlenecks, data inconsistency, and <span class="No-Break">reliability loss.</span></p>
			<p>At this point, we can better<a id="_idIndexMarker116"/> comprehend why integration shows itself as a crucial architectural aspect for delivering modern microservices-based solutions. Next, let’s take a look at another way to integrate distributed services by relying on event-driven architecture for asynchronous <span class="No-Break">data integration.</span><a id="_idTextAnchor074"/></p>
			<h3>Unveiling change data capture for data integration</h3>
			<p>Services integration can be synchronous<a id="_idIndexMarker117"/> or asynchronous<a id="_idIndexMarker118"/> and can use different mechanisms and take different forms, such as file-based, shared database, message-based, API-based (e.g., REST, SOAP), event-driven, and many<a id="_idIndexMarker119"/> more. For the purposes of this book, we will consider aspects of <strong class="bold">Event-Driven Architecture</strong> (<strong class="bold">EDA</strong>), as it enables the usage<a id="_idIndexMarker120"/> of data integration patterns such as <strong class="bold">change </strong><span class="No-Break"><strong class="bold">data capture</strong></span><span class="No-Break">.</span></p>
			<p>Technologies around event-driven patterns were created to allow databases – even traditional ones – to have a new capability: emit events. You read that correctly; it is possible for traditional relational databases (and other databases as well) to go beyond the basics and allow developers to rely on Change <span class="No-Break">Data Capture.</span></p>
			<p>With Change Data Capture, database operations can be captured and emitted as events by a component external to the database and microservices of the solution. With this, developers are able to create event-driven services that can then react and respond to the aforementioned data events, <span class="No-Break">or “notifications.”</span></p>
			<p>As you might have expected, EDA is not all sunshine and roses. Understanding what’s happening throughout a single business flow can be quite overwhelming in this architectural style when multiple services and a high number of events are involved. Troubleshooting can also be extremely complex since the tracking process isn’t linear and does not happen in unique transactions. When working with EDA, forget about <span class="No-Break">automatic rollbacks.</span></p>
			<p>Even though each of the mentioned challenges can be addressed or mitigated, notice these are only some of the items in a list of potential drawbacks for EDA; therefore, don’t forget to do your evaluations for the scenario in question, and validate whether EDA is the best solution for it <span class="No-Break">or not.</span></p>
			<p>Knowing the integration<a id="_idIndexMarker121"/> benefits offered by EDA<a id="_idIndexMarker122"/> is crucial to integrating your services without breaking patterns, best practices, and recommendations, and is critical to ensuring that you reap the benefits of asynchronous, highly <span class="No-Break">scalable integration.</span></p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor075"/>Summary</h1>
			<p>At this point, we have examined the influence of cloud technology on software architecture design and the importance of design patterns as building blocks for software architects. We compared monolithic and microservices architectures, shedding light on their advantages <span class="No-Break">and disadvantages.</span></p>
			<p>We also explored cloud deployment strategies such as hybrid and multi-cloud models, and how these strategies, combined with managed services such as DbaaS, can speed up the development and delivery of stateful solutions. On the other hand, we also discovered that how we integrate data in distributed systems can impact data management and usage directly. When integrating distributed stateful service, we now know we must be cautious about using anti-patterns such as shared databases <span class="No-Break">and “dual-writes”.</span></p>
			<p>At the end of the chapter, we unveiled the potential of Change Data Capture for data integration in EDA, which increases architectural complexity (more components and technologies) in exchange for a completely decoupled and <span class="No-Break">asynchronous integration.</span></p>
			<p>After discussing architectural and deployment model choices, we will next dive deeper into leveraging design patterns for data management in cloud-native applications, building upon the foundations laid in <span class="No-Break">this chapter.</span></p>
		</div>
	</body></html>