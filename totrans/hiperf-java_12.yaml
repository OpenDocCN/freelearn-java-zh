- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Frameworks for Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimization frameworks are libraries, tools, and guidelines designed to help
    developers enhance the performance of their Java applications. Examples include
    streamlining processes, reducing resource utilization, and reducing processor
    burdens. That is the focus of this chapter. We will start by looking at asynchronous
    input and output, its importance, and associated libraries and frameworks. The
    chapter then explores buffered input and output to include use cases and performance
    impacts. You can learn how both asynchronous and buffered input/output operations
    can improve efficiency and reduce latency. The benefits of batch operations, and
    related frameworks and APIs, will be explored. We will review techniques to optimize
    batch operations, minimizing resource utilization and maximizing data flow.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter introduces microservices and covers specific frameworks that can
    be used with microservices. These frameworks, along with those for cloud-native
    applications, will be explored, as these advanced architectures are pervasive
    in modern software development. We will highlight how those frameworks can be
    implemented to optimize the performance of our Java applications. To conclude
    the chapter, we will review several case studies and performance analyses, providing
    practical context to use the chapter’s featured frameworks in real-world scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have a foundational understanding of
    key frameworks to optimize Java applications. The case studies should help deepen
    your understanding of how these frameworks can impact application performance.
    You should also be comfortable creating and implementing optimization strategies,
    based on the frameworks presented in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous input/output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffered input/output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Batch operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frameworks for microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frameworks for cloud-native applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case studies and performance analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples and instructions in this chapter, you will need the ability
    to load, edit, and run Java code. If you have not set up your development environment,
    refer to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014), *Peeking Inside the
    Java Virtual* *Machine (JVM)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The finished code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter12](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter12).'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous input/output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Asynchronous** refers to uncoordinated (unsynchronized) communication operations.
    In the context of input/output operations, data does not have to be transmitted
    in a steady stream. This is a technique that we can use in Java to allow our programs
    to handle input and output operations without blocking the main thread’s execution.
    While it may not always be necessary to employ this technique, it can offer great
    performance advantages when dealing with systems that rely on high responsiveness
    and performance.'
  prefs: []
  type: TYPE_NORMAL
- en: For brevity, let’s refer to **asynchronous input/output** using the **AIO**
    acronym. With AIO, we can initiate processes and then have them run independently,
    which allows our main application to continue running other processes. Consider
    the **synchronous** alternative, where the main application must wait for one
    operation to complete before running another one. The synchronous approach can
    result in latency, longer response times, and other inefficiencies.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a foundational understanding of asynchronous input/output,
    let’s examine the advantages and best practices of using this technique to improve
    Java application performance.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several advantages to AIO, and they are best leveraged when following
    industry best practices. First, we will review the advantages, followed by the
    best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are three advantages to implementing AIO in our Java applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Efficiency**: AIO implementation can result in resource efficiency because
    we can use threads for processing, instead of waiting on input/output operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Responsiveness**: When we decouple input/output operations from the main
    thread execution, we increase the application’s overall responsiveness. With AIO,
    the main application can remain responsive to input (i.e., user interactions)
    while other input/output operations are occurring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: If your application needs to be scalable, you will most certainly
    want to consider implementing AIO, which is essential for building scalable applications.
    AIO helps us manage multiple simultaneous connections without the need for additional
    threads. This significantly reduces overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping these advantages in mind, let’s review the best practices to optimize
    them in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are several best practices to help guide your use of AIO:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Error handling**: Your AIO implementation strategy should include robust
    error handling to catch and handle exceptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handlers**: The use of **callback handlers** to react to input/output events
    is advisable to help you keep your code organized and maintainable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource management**: As with most programming, you should ensure that all
    resources used in your application (i.e., network sockets) are closed after their
    associated operation concludes. This will help prevent resource/memory leaks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have established that implementing AIO is an approach that can positively
    impact the performance of our applications. In the next section, we will look
    at how to implement AIO in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing AIO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Java platform includes a **New Input/Output** (**NIO**) library that includes
    the following capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AsynchronousFileChannel`: This class enables us to read and write from and
    to files without blocking other tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsynchronousServerSocketChannel` and `AsynchronousSocketChannel`: These classes
    are used to handle asynchronous network operations, which helps make our applications
    scalable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Channels** and **buffers**: Java’s NIO library relies heavily on channels
    and buffers. Channels are the connections to components that perform input/output
    operations, such as network sockets. Buffers handle the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several AIO-related frameworks and libraries available to us, in
    addition to Java NIO. Here are two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Akka**: This is a toolkit consisting of libraries to help us build resilient
    Java applications, with a focus on distributed and current systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Netty**: This is a framework for high-performance applications that makes
    it easy for developers to create network applications. It supports both AIO and
    event-driven communication models.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at AIO in code. The following example application demonstrates the
    `AsynchronousFileChannel` class to conduct an asynchronous file read operation.
    As you will see, the application employs a callback mechanism to handle the read
    operation’s completion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application starts with a series of `import` statements required by it.
    As you can see, we are leveraging Java’s NIO library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is our `main()` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the preceding code, we open the `ch12.txt` file using `AsychnronousFileChannel`.
    We open it asynchronously using `AsynchronousFileChannel.open()`, specify the
    path, and set the read-only open option. Next, we use a `ByteBuffer` to hold the
    data we read from the file. This is a non-blocking method, which immediately returns
    a `Future` object that represents the pending result. We simulate processing other
    tasks during the read operation and print a message from the main thread. Lastly,
    we implemented a while loop to determine whether the read operation was completed
    using `isDone()`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing AIO in our Java applications can help us achieve high performance
    and increased responsiveness and scalability. Next, we will examine buffered input/output.
  prefs: []
  type: TYPE_NORMAL
- en: Buffered input/output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The buffered approach to input/output, commonly referred to as **buffered input/output**,
    can be implemented to reduce the number of input/output operations required. This
    approach is accomplished using temporary storage, known as a **buffer**. Buffers
    temporarily hold data during the transfer process. The goal of this approach is
    to minimize direct interactions with hardware and data streams. Java delivers
    on this promise by accumulating data in a buffer before processing it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a foundational understanding of buffered input/output, let’s
    examine the advantages and best practices of using this technique to improve Java
    application performance.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several advantages to buffered input/output, and they are best leveraged
    when following industry best practices. Next, we will review the advantages followed
    by best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are three advantages to implementing buffered input/output in our Java
    applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data handling**: Buffered input/output can increase the efficiency of data
    handling because it allows for data to be temporarily stored during read and write
    operations. This is especially beneficial when working with data streams and large
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: We can use buffered classes to encapsulate our input and output
    streams. This makes them more adaptable for varied uses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Buffered input/output aims to reduce the number of input/output
    operations, thereby reducing interaction overhead and ultimately increasing the
    overall application performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping these advantages in mind, let’s review the best practices for optimizing
    them in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are several best practices to help guide your use of buffered input/output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Buffer size**: Testing should be conducted to determine what the most optimal
    buffer size is. Each use case is different and depends on the data, application,
    and hardware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling**: It is always good practice to add robust error handling
    to your applications. This is especially pertinent for situations where input/output
    operations could fail due to external issues (e.g., file access permissions or
    network issues).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource management**: Closing buffered streams will free up system resources
    and help avoid memory leaks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have established that implementing buffered input/output is an approach that
    can positively impact the performance of our applications. In the next section,
    we will look at how to implement buffered input/output in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing buffered input/output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Java platform includes several classes in the `java.io` library with the
    following capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BufferedInputStream`: This class is used to read binary data from a stream.
    The data is stored in a buffer, permitting efficient data retrieval.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BufferedOutputStream`: This class writes bytes to a stream, collecting the
    data in a buffer, and then writes to the output device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BufferedReader`: This class reads from an input stream and buffers the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BufferedWriter`: This class writes data to an output stream, buffering the
    data to enable efficient writing operations from the buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at buffered input/output in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the example code, we use `BufferedReader` and `BufferedWriter`
    to read and write to a file. The `readLine` method is used to efficiently read
    lines from the input file, and `BufferedWriter` can quickly write to a file with
    minimal input/output operations.
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging the buffered input/output classes covered in this section, and
    following the provided best practices, we can significantly increase the performance
    of our Java applications, especially those that have frequent read/write operations.
  prefs: []
  type: TYPE_NORMAL
- en: Batch operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of **batch operations** suggests that we process a lot of data at
    once or combine multiple tasks into a single operation. This type of processing,
    as opposed to doing things individually, can result in tremendous efficiencies
    and reduce overhead. Implementing batch operations is usually a good method of
    improving performance, especially with large-scale data operations, file processing,
    and database interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Batch operations in practice involve executing a series of jobs, usually with
    large datasets treated as groups. These groupings are based on natural or logical
    groupings, with the goal of reducing the computational overhead associated with
    the repetitive starting and stopping processes.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several advantages to batch operations, and they are best leveraged
    when following industry best practices. Next, we will review the advantages followed
    by best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are three advantages to implementing batch operations in our Java applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance**: Batch operations represent a tremendous increase in performance.
    Given the scenario where 100 files need to be processed if handled individually,
    100 operations would be required. Handling these 100 files with a batch operation
    would run faster because there would be a significant reduction in system calls.
    Network latency would also be improved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource usage**: Implementing batch operations reduces overhead and maximizes
    resource utilization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Batch operations make it easier for our systems to process
    large datasets. This approach is inherently scalable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping these advantages in mind, let’s review the best practices to optimize
    them in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are several best practices to help guide your use of batch operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Batch size**: There is a balance between having a batch size that is too
    small and one that is too big. If it is too small, you are not likely to gain
    the performance benefits, and if it is too large, your application may run into
    memory issues. Determining the right size requires testing and is influenced by
    the type of processing and the type of data involved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling**: As part of your error handling of batch operations, be
    sure to account for each part of the batch operations if one part fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring**: As with all major systems, the importance of logging and monitoring
    those logs cannot be overstated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s see how to implement batch operations in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing batch operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Java platform includes the following APIs and frameworks to help us implement
    batch operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java batch**: The **Java Specification Request** (**JSR**) specification
    352 provides a standard approach to batch processing implementation. It includes
    definitions and steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JDBC batch processing**: **Java Database Connectivity** (**JDBC**) batch
    processing is used to handle batch **Structured Query Language** (**SQL**) statements.
    We will demonstrate this in the following section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring batch**: This is a framework that provides a host of batch processing
    capabilities to include job processing statistics, resource optimization, and
    transaction management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at an example using JDBC batch processing. The following sample program
    demonstrates how to use JDBC batch processing to efficiently insert multiple records
    into a database. Note that the database is simulated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example starts with the `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create our class and `main()` method. This section includes connecting
    to and logging into the simulated database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following statement is the SQL statement we plan to use in our batch operation.
    Following that statement, we use encase our batch operations in a `try`-`catch`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Our simple example program grouped multiple `INSERT` statements into a batch,
    and they were executed in a single request to the simulated database.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating batch operations in our Java applications, if applicable, can
    significantly enhance application performance. It can also increase scalability
    and system maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks for microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Microservices** are a software architectural approach that consists of loosely
    coupled modules (microservices) that comprise an entire application. The benefits
    of microservices include the ability to have teams working on individual ones
    simultaneously, the ability to update one independent of an entire application,
    increased scalability, and more efficient maintainability. This section focuses
    on optimization frameworks for microservices.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a foundational understanding of frameworks for microservices,
    let’s examine the advantages and best practices of using this technique to improve
    Java application performance.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several advantages to implementing frameworks for microservices, and
    they are best leveraged when following industry best practices. Next, we will
    review the advantages followed by best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are three advantages to implementing frameworks for microservices in our
    Java applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fault isolation**: One of the key advantages of using microservices is to
    isolate faults. This is possible because each microservice is loosely coupled
    with another one. This means a fault in one microservice will not necessarily
    impact others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: Adopting the microservice framework provides greater agility
    and flexibility when developing and maintaining systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Microservices’ distributed nature enables great scalability;
    they are inherently scalable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping these advantages in mind, let’s review the best practices to optimize
    them in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are several best practices to help guide your use of frameworks for microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API design**: When designing and developing APIs, it is important to thoroughly
    vet their stability and backward compatibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration management**: A formal version control system should be used
    so that there is consistency across all microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring**: It is imperative to create a robust logging system and for
    those logs to be monitored. This can help identify issues before they become critical.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have established that implementing frameworks for microservices is an approach
    that can positively impact the performance of our applications. In the next section,
    we will look at how to implement a framework for microservices in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing microservices frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Systems designed with a microservice architecture essentially consist of individual
    services (microservices) that are standalone applications, based on a business
    function. Each microservice has its own data. There are several frameworks available
    to implement microservices in Java. Here are four of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Helidon**: This framework is provided by Oracle and helps us create applications
    using the microservices architecture. This is a modern framework, and the API
    offers many options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Micronaut**: This is a modern and robust JVM-based framework that includes
    features such as dependency injection and container management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quarkus**: If you use Kubernetes for containerization, Quarkus is a good
    option to create microservices applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring boot**: This is the most used framework to implement microservices
    in Java. It is easy to set up, configure, and use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at a simple microservice application using Micronaut. We will use
    a three-step approach:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to set up our project. This can be done with the Micronaut
    **command-line interface** (**CLI**) or a supported **Integrated Development**
    **Environment** (**IDE**), such as IntelliJ IDEA. Using the CLI, here is what
    the setup code might look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to create a controller to handle HTTP requests. Here is how that
    can be done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The third and final step is to simply run the application. Note that the following
    example refers to the **Gradle Wrapper**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Examining the code further, we can see that we use the `@Controller` annotation
    to identify our class as a controller, whose base URI is `/ch12`. When the application
    is run, the service will be located at `http://localhost:8080/ch12`.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices frameworks such as Helidon, Micronaut, Quarkus, and Spring Boot
    provide us with a multitude of capabilities to create Java applications using
    the microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks for cloud-native applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing **cloud-native applications** is a strategic decision, typically
    based on the desire to exploit the scalability, resiliency, security, and flexibility
    inherent in cloud computing.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native
  prefs: []
  type: TYPE_NORMAL
- en: In the context of software development, cloud-native refers to the use of cloud
    computing to create applications from the ground up and deploy them.
  prefs: []
  type: TYPE_NORMAL
- en: There are several frameworks available to us that support cloud-native application
    development in Java. Cloud-native applications are built from start to finish
    using the cloud environment. These applications are typically built as microservices,
    which are packaged into containers, orchestrated, and managed using **DevOps**-accepted
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a foundational understanding of cloud-native applications,
    let’s examine the advantages and best practices of using this technique to improve
    Java application performance.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several advantages to cloud-native frameworks, and they are best leveraged
    when following industry best practices. Next, we will review the advantages followed
    by the best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are three advantages to implementing cloud-native frameworks in our Java
    applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Efficiencies**: One of the greatest advantages of using cloud-native frameworks
    for our Java applications is the great efficiencies that are introduced, due to
    automation, development consistency, and testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fault tolerance**: Because cloud-native applications are written as microservices,
    a fault in one service will not necessarily impact others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: The microservices architecture is inherently scalable, as
    is the cloud environment. This empowers us to build highly scalable Java applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping these advantages in mind, let’s review the best practices to optimize
    them in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are several best practices to help guide your use of frameworks for cloud-native
    applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Containerization**: Applications should be packaged along with their dependencies
    in containers. This will help ensure that there is consistency with each service,
    regardless of the runtime environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous Integration/Continuous Delivery (CI/CD)**: Adopting the CI/CD
    approach with automated deployment and testing can significantly increase the
    speed of development and minimize errors inherent in non-automated processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring**: Creating robust logs and continuously monitoring them can help
    identify potential issues before they come to fruition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have established that implementing cloud-native frameworks is an approach
    that can positively impact the performance of our applications. In the next section,
    we will look at how to implement them in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a cloud-native application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several frameworks available to us to help develop cloud-native applications
    in Java. Here are three popular frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eclipse MicroProfile**: This is a portable API designed for Java enterprise
    application optimization, specific to microservice architectures. It has many
    capabilities, including health checks, metrics, and fault tolerance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quarkus**: This framework uses a **container-first** philosophy and works
    best with Kubernetes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Cloud**: Part of the Spring environment (i.e., Spring Boot), this
    is a set of development tools to build common software patterns, such as configurations
    and service discovery, specific to the cloud environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at a simple cloud-native application using Eclipse MicroProfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet demonstrates how MicroProfile can be used to inject
    configuration properties (e.g., a username). This very simple example underscores
    the benefit of using this type of framework to effectively handle configuration
    and other microservices-related concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Case studies and performance analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we have argued that implementing optimization frameworks
    can greatly increase the performance and scalability of our Java applications.
    This section reviews two case studies and explores performance analysis to help
    determine the impact framework adoption has on our Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Case studies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reviewing case studies based on plausible real-world situations can help demonstrate
    the advantages of adopting optimization frameworks. Here are two case studies.
  prefs: []
  type: TYPE_NORMAL
- en: Case study 1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Name**: A microservices-based e-commerce application'
  prefs: []
  type: TYPE_NORMAL
- en: '**Background**: The Reinstate LLC company is a large e-commerce retailer that
    recently transitioned to a microservices architecture from its previous monolithic
    architecture. They used Spring Boot and Spring Cloud to improve scalability, reliability,
    and maintainability.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Opportunity**: Reinstate LLC had difficulty scaling its monolithic system
    during peak times. They also noted that their development cycles were too long
    and attributed it to the interconnected nature of their application’s components.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Each application component was refactored into a microservice,
    based on a business function or logic. These microservices included customer profiles,
    inventory management, order management, and cart management. Spring Boot was used
    to create individual microservices, and Spring Cloud was used for service discovery,
    load balancing, and configuration management.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Result**: After implementing the microservices architecture, Reinstate LLC
    experienced a 65% reduction in downtime and a 42% improvement in response time.'
  prefs: []
  type: TYPE_NORMAL
- en: Case study 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Name**: Financial services’ batch processing.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Background**: CashNow, a financial services company, wanted to process large
    volumes of transactions each data while ensuring high accuracy and reliability,
    using batch processing.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Opportunity**: CashNow’s existing system was inefficient and commonly experienced
    transaction delays. This wreaked havoc on its reporting and end-of-day reconciliation
    process.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: CashNow implemented Spring Batch to help them manage and optimize
    their batch processing. This framework empowered them to implement job processing,
    processing chunks, and error handling.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Result**: CashNow noted a 92% reduction in batch processing time as well
    as a significant decrease in errors. This change helped them streamline their
    daily processes to include end-of-day reconciliation and reporting.'
  prefs: []
  type: TYPE_NORMAL
- en: Performance analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementing optimization frameworks is only one part of the solution. Once
    they are implemented, we want to ensure they result in improvements. We also want
    to make sure the changes work the way we intend them to. This is typically accomplished
    by observing metrics over time.
  prefs: []
  type: TYPE_NORMAL
- en: A common performance analysis approach involves profiling tools (see [*Chapter
    14*](B21942_14.xhtml#_idTextAnchor250), *Profiling Tools*) and monitoring tools.
    Examples include **JProfiler** and **VisualVM**. Using robust profiling and monitoring
    tools can help us identify potential bottlenecks, such as memory leaks and slow
    database queries.
  prefs: []
  type: TYPE_NORMAL
- en: The case studies and performance analysis presented in this section underscore
    the importance of implementing optimization frameworks in our Java applications
    to help increase performance, scalability, and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored various optimization frameworks and techniques to help
    increase the performance of our Java applications, support scalability, make our
    code more maintainable, and provide efficient development cycles. We covered asynchronous
    input/output, buffered input/output, batch operations, frameworks for microservices,
    and frameworks for cloud-native applications. We concluded the chapter with a
    review of two realistic case studies and an overview of performance analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, the comprehensive overview provided in this chapter will help you
    further optimize your Java applications. The frameworks and techniques covered
    in this chapter can help you enhance the performance of your applications and
    increase scalability, consistency, reliability, and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter ([*Chapter 13*](B21942_13.xhtml#_idTextAnchor227), *Performance-Focused
    Libraries*), we will explore several open source Java libraries designed to provide
    high performance. These fully optimized libraries can be leveraged to our advantage.
    Notable libraries covered include **Java Microbenchmark Harness** (**JHM**), which
    is part of the OpenJDK project; Netty to work with network protocols, which can
    be used to reduce latency; and FasterXML Jackson, which is a suite of data processing
    tools.
  prefs: []
  type: TYPE_NORMAL
