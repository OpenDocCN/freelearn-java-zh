- en: Chapter 2. Using Controllers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 使用控制器
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Using HTTP headers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP头
- en: Using HTTP cookies
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP cookies
- en: Using the session
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用会话
- en: Using custom actions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义操作
- en: Using filters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过滤器
- en: Using path binders
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用路径绑定器
- en: Serving JSON
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供JSON
- en: Receiving JSON
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收JSON
- en: Uploading files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传文件
- en: Using futures and Akka actors
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用futures和Akka actors
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will dive in a little deeper into Play controllers and discuss
    some advanced topics regarding controllers in web applications. We will also learn
    how Play can handle and address more modern web app requirements besides the common
    use cases such as data manipulation and data retrieval. As we rely on controllers
    to route web requests and responses, we want to ensure that our controllers are
    as lightweight and as decoupled as possible, to ensure page responsiveness and
    predictable page load times. Providing a clean separation from the model and other
    data-related processing and services also provides developers a clearer understanding
    of what each layer's responsibilities are.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨Play控制器，并讨论关于Web应用程序中控制器的一些高级主题。我们还将了解Play如何处理和解决除了数据操作和数据检索等常见用例之外更现代的Web应用程序需求。由于我们依赖于控制器来路由Web请求和响应，我们希望确保我们的控制器尽可能轻量级和松耦合，以确保页面响应性和可预测的页面加载时间。从模型和其他数据相关处理和服务中提供清晰的分离，也为开发者提供了对每一层职责的更清晰理解。
- en: Using HTTP headers
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTP头
- en: For this recipe, we will explore how Play applications can manipulate HTTP headers.
    We will use the `curl` tool to validate if our changes to the HTTP response headers
    were applied correctly. For Windows users, it is recommended to install Cygwin
    in order to have a unix-like environment for Windows machines ([https://www.cygwin.com/](https://www.cygwin.com/)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将探讨Play应用程序如何操作HTTP头。我们将使用`curl`工具来验证我们对HTTP响应头所做的更改是否正确应用。对于Windows用户，建议安装Cygwin以在Windows机器上获得类似Unix的环境（[https://www.cygwin.com/](https://www.cygwin.com/))。
- en: How to do it…
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'For Java, we need to take the following steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，我们需要采取以下步骤：
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以启用热重载的方式运行`foo_java`应用程序：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Modify `foo_java/app/controllers/Application.java` by adding the following
    action:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下操作修改`foo_java/app/controllers/Application.java`：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add a new `routes` entry for the newly-added action in `foo_scala/conf/routes`:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/routes`中为新增的操作添加一个新的`routes`条目：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Request our new route and examine the response headers to confirm our modifications
    to the HTTP response header:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求我们的新路由并检查响应头以确认我们对HTTP响应头的修改：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For Scala, we need to take the following steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要采取以下步骤：
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以启用热重载的方式运行`foo_scala`应用程序：
- en: '[PRE4]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Modify `foo_scala/app/controllers/Application.scala` by adding the following
    action:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下操作修改`foo_scala/app/controllers/Application.scala`：
- en: '[PRE5]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add a new `routes` entry for the newly-added action in `foo_scala/conf/routes`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/routes`中为新增的操作添加一个新的`routes`条目：
- en: '[PRE6]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Request our new `routes` and examine the response headers to confirm our modifications
    to the HTTP response header:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求我们的新`routes`并检查响应头以确认我们对HTTP响应头的修改：
- en: '[PRE7]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we created a new URL route and action. Within the action, we
    added a new HTTP header and assigned an arbitrary value to it. We then accessed
    this new action using the command-line tool, `curl` so that we can view the response
    HTTP headers in raw text. The output should contain our custom header key and
    its assigned arbitrary value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们创建了一个新的URL路由和操作。在操作内部，我们添加了一个新的HTTP头并为其分配了一个任意值。然后我们使用命令行工具`curl`访问这个新操作，以便我们可以查看以纯文本形式显示的响应HTTP头。输出应包含我们的自定义头键及其分配的任意值。
- en: Using HTTP cookies
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTP cookies
- en: For this recipe, we will explore how Play applications can manipulate HTTP cookies.
    We will use the `curl` tool to validate our changes to the HTTP response headers
    containing the new cookie we added to the response.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将探讨Play应用程序如何操作HTTP cookies。我们将使用`curl`工具来验证我们对包含我们添加到响应中的新cookie的HTTP响应头所做的更改。
- en: How to do it…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'For Java, we need to take the following steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，我们需要采取以下步骤：
- en: Run the `foo_java` application with Hot-Reloading enabled.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以启用热重载的方式运行`foo_java`应用程序。
- en: 'Modify `foo_java/app/controllers/Application.scala` by adding the following
    action:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下操作修改`foo_java/app/controllers/Application.scala`：
- en: '[PRE8]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add a new route entry for the newly-added action in `foo_java/conf/routes`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/conf/routes`中为新增的操作添加一个新的路由条目：
- en: '[PRE9]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Request our new route and examine the response headers to confirm our modifications
    to the HTTP response header:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求我们的新路由并检查响应头以确认我们对HTTP响应头的修改：
- en: '[PRE10]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For Scala, we need to take the following steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要采取以下步骤：
- en: Run the `foo_scala` application with Hot-Reloading enabled.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以启用热重载的方式运行`foo_scala`应用程序。
- en: 'Modify `foo_scala/app/controllers/Application.scala` by adding the following
    action:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下操作修改`foo_scala/app/controllers/Application.scala`：
- en: '[PRE11]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add a new routes entry for the newly-added action in `foo_scala/conf/routes`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/routes`中为新增的操作添加一个新的路由条目：
- en: '[PRE12]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Request our new route and examine the response headers to confirm our modifications
    to the HTTP response header:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求我们的新路由并检查响应头以确认我们对HTTP响应头的修改：
- en: '[PRE13]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In this recipe, we created a new URL route and action. Within the action, we
    added a new cookie named `source` and assigned it an arbitrary value "`tw`" and
    an optional expiration time (in this recipe, an hour):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个新的URL路由和操作。在操作中，我们添加了一个名为`source`的新cookie，并为其分配了一个任意值"`tw`"和一个可选的过期时间（在这个菜谱中，是一个小时）：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We then accessed this new action using the command-line tool `curl` so that
    we can view the response HTTP headers in raw text. The output should contain the
    `Set-Cookie` header with the cookie name and value we assigned in the action.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用命令行工具`curl`访问这个新的操作，以便我们可以查看操作中分配的原始文本HTTP响应头。输出应该包含我们分配的cookie名称和值的`Set-Cookie`头。
- en: Using the session
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用会话
- en: For this recipe, we will explore how Play applications handle a session state.
    This sounds counterintuitive, as Play claims to be a stateless and lightweight
    web framework. However, as sessions and session states have become major components
    for web applications, Play implements sessions as cookies and therefore, are actually
    stored on the client side or the user browser.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将探讨Play应用程序如何处理会话状态。这听起来有些反直觉，因为Play声称是一个无状态和轻量级的Web框架。然而，由于会话和会话状态已成为Web应用程序的主要组件，Play将会话实现为cookie，因此实际上存储在客户端或用户浏览器上。
- en: How to do it…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'For Java, we need to take the following steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，我们需要采取以下步骤：
- en: Run the `foo_java` application with Hot-Reloading enabled.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以启用热重载的方式运行`foo_java`应用程序。
- en: 'Modify `foo_java/app/controllers/Application.scala` by adding the following
    action:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下操作修改`foo_java/app/controllers/Application.scala`：
- en: '[PRE15]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add a new routes entry for the newly-added action in `foo_java/conf/routes`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/conf/routes`中为新增的操作添加一个新的路由条目：
- en: '[PRE16]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![](img/RN4C8LXY.jpg)'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/RN4C8LXY.jpg)'
- en: 'Access this new URL route (`http://localhost:9000/session_example`) using a
    web browser. You should see the text **Setting session var: user_pref**:![](img/gYiaaaWd.jpg)'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网络浏览器访问这个新的URL路由（`http://localhost:9000/session_example`）。您应该看到文本**设置会话变量：user_pref**：![](img/gYiaaaWd.jpg)
- en: 'Access this new URL route again using the same web browser and you see the
    text **Found userPref: tw**.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '再次使用相同的网络浏览器访问这个新的URL路由，您会看到文本**找到userPref: tw**。'
- en: 'Our new session variable is assigned using `curl`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`curl`分配了新的会话变量：
- en: '[PRE17]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For Scala, we need to take the following steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要采取以下步骤：
- en: Run the `foo_scala` application with Hot-Reloading enabled.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以启用热重载的方式运行`foo_scala`应用程序。
- en: 'Modify `foo_scala/app/controllers/Application.scala` by adding the following
    action:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下操作修改`foo_scala/app/controllers/Application.scala`：
- en: '[PRE18]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add a new routes entry for the newly-added `Action` in `foo_scala/conf/routes`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/routes`中为新增的`Action`添加一个新的路由条目：
- en: '[PRE19]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Access this new URL route (`http://localhost:9000/session_example`) using a
    web browser and you should see the text **Setting session var: user_pref**'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网络浏览器访问这个新的URL路由（`http://localhost:9000/session_example`），您应该看到文本**设置会话变量：user_pref**
- en: 'Access this new URL route again using the same web browser and you see the
    text **Found userPref: tw**.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '再次使用相同的网络浏览器访问这个新的URL路由，您会看到文本**找到userPref: tw**。'
- en: 'You can also see how our new session variable is assigned using `curl`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您也可以使用`curl`查看我们新的会话变量是如何分配的：
- en: '[PRE20]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we created a new URL route and action. Within the action, we
    added some logic to understand whether the session var "`user_pref`" already existed
    in the session or not. If the session variable was indeed set, we print out the
    value of the session variable in the response body. If the session variable was
    not found in the current session, it would add the session variable to the session
    and display text, notifying the requestor that it did not find the session variable.
    We validated this by using a web browser and requesting the same URL route twice;
    first, to set the session variable and second, to print the value of the session
    variable. We also used `curl` to see how the session variable was set to the current
    session as an HTTP cookie header.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个新的URL路由和操作。在操作中，我们添加了一些逻辑来理解会话变量"`user_pref`"是否已经在会话中存在。如果会话变量确实已设置，我们将在响应体中打印出会话变量的值。如果当前会话中没有找到会话变量，它将添加会话变量到会话中并显示文本，通知请求者它没有找到会话变量。我们通过使用网络浏览器并请求相同的URL路由两次来验证这一点；首先，设置会话变量，其次，打印会话变量的值。我们还使用`curl`来查看会话变量是如何设置为当前会话的HTTP
    cookie头部的。
- en: Using custom actions
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义操作
- en: For this recipe, we will explore how Play Framework provides the building blocks
    for creating reusable, custom actions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将探索Play Framework如何提供创建可重用、自定义操作的构建块。
- en: How to do it…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'For Java, we need to take the following steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，我们需要采取以下步骤：
- en: Run the `foo_java` application with Hot-Reloading enabled.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用Hot-Reloading运行`foo_java`应用程序。
- en: 'Modify `foo_java/app/controllers/Application.java` by adding the following
    action:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下操作修改`foo_java/app/controllers/Application.java`：
- en: '[PRE21]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add our new action class to `foo_java/app/controllers/AuthAction.java` as well:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的新操作类添加到`foo_java/app/controllers/AuthAction.java`中：
- en: '[PRE22]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add new routes for the newly added action in `foo_java/conf/routes`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/conf/routes`中为新添加的操作添加新路由：
- en: '[PRE23]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Access the dashboard URL route using a web browser and notice that it redirects
    you to the login URL route. You will also notice a log entry in our console where
    the request is about to be redirected to the login page:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网络浏览器访问仪表板URL路由，并注意它会重定向您到登录URL路由。您还会在我们的控制台中注意到一条日志条目，其中请求即将被重定向到登录页面：
- en: '[PRE24]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For Scala, we need to take the following steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要采取以下步骤：
- en: Run the `foo_scala` application with Hot-Reloading enabled.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用Hot-Reloading运行`foo_scala`应用程序。
- en: 'Modify `foo_scala/app/controllers/Application.scala` by adding the following
    action:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下操作修改`foo_scala/app/controllers/Application.scala`：
- en: '[PRE25]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add our new action to `foo_scala/app/controllers/Application.scala` as well:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还将我们的新操作添加到`foo_scala/app/controllers/Application.scala`中：
- en: '[PRE26]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add new routes for the newly added action in `foo_scala/conf/routes`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/routes`中为新添加的操作添加新路由：
- en: '[PRE27]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Access the dashboard URL route using a web browser and notice that it redirects
    you to the login URL route. You will also notice a log entry in our console where
    the request is about to be redirected to the login page:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网络浏览器访问仪表板URL路由，并注意它会重定向您到登录URL路由。您还会在我们的控制台中注意到一条日志条目，其中请求即将被重定向到登录页面：
- en: '[PRE28]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In this recipe, we created two new URL routes and actions; one to display a
    user dashboard, and the other, to act as our login page. Within the dashboard
    action, we utilized our new action `AuthAction`. The `AuthAction` object checks
    for the existence of the `auth` cookie and if it does find the said cookie in
    the request, it calls the `ActionBuilder` in the chain:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了两个新的URL路由和操作；一个用于显示用户仪表板，另一个作为我们的登录页面。在仪表板操作中，我们使用了我们的新操作`AuthAction`。`AuthAction`对象检查`auth`cookie的存在，如果它在请求中找到了该cookie，它将调用链中的`ActionBuilder`：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the `auth` cookie is not found in the request, `AuthAction` redirects the
    current request to the `login` URL route, wrapping it around a completed `Future[Result]`
    object with `Future.successful()`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求中没有找到`auth`cookie，`AuthAction`将重定向当前请求到`login`URL路由，并用`Future.successful()`包装成一个完成的`Future[Result]`对象：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using filters
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用过滤器
- en: For this recipe, we will explore how Play Framework provide APIs for HTTP request
    and response filters. HTTP filters provide a way to transparently decorate a HTTP
    request or response and is useful for lower-level services (such as response compression),
    gathering metrics, and more in-depth logging.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将探索Play Framework如何提供HTTP请求和响应过滤器的API。HTTP过滤器提供了一种透明地装饰HTTP请求或响应的方法，对于底层服务（如响应压缩）、收集指标和更深入的日志记录非常有用。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is also worth noting that presently (as of Play 2.3.7), HTTP filters are
    best implemented using the Play Scala API with the *play.api.mvc.EssentialFilter*
    trait. So for this recipe, we will implement a Scala-based filter for our Java
    recipe.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，目前（截至Play 2.3.7版本），HTTP过滤器最好使用Play Scala API中的 *play.api.mvc.EssentialFilter*
    特性来实现。因此，对于这个菜谱，我们将为Java菜谱实现一个基于Scala的过滤器。
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'For Java, we need to take the following steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，我们需要采取以下步骤：
- en: Run the `foo_java` application with Hot-Reloading enabled.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用热重载功能运行 `foo_java` 应用程序。
- en: 'Create a new filter object by creating the file `foo_java/app/ResponseTimeLogFilter.scala`,
    and adding the following contents:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建文件 `foo_java/app/ResponseTimeLogFilter.scala` 并添加以下内容来创建一个新的过滤器对象：
- en: '[PRE31]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Utilize this new filter by declaring it in the `app/Global.java` file:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `app/Global.java` 文件中声明它来使用这个新的过滤器：
- en: '[PRE32]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Access any previous URL routes we''ve defined (`http://localhost:9000/session_example`)
    using a web browser. You will be able to see a new log entry with our response
    stats printed:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网络浏览器访问我们定义的任何之前的URL路由（`http://localhost:9000/session_example`）。你将能够看到一个包含我们响应统计的新日志条目：
- en: '[PRE33]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For Scala, we need to take the following steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要采取以下步骤：
- en: Run the `foo_scala` application with Hot-Reloading enabled.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用热重载功能运行 `foo_scala` 应用程序。
- en: 'Create a new filter object by creating the file `foo_scala/app/controllers/ResponseTimeLogFilter.scala`
    and adding the following contents:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建文件 `foo_scala/app/controllers/ResponseTimeLogFilter.scala` 并添加以下内容来创建一个新的过滤器对象：
- en: '[PRE34]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Utilize this new filter by declaring it in the `app/Global.scala` file:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `app/Global.scala` 文件中声明它来使用这个新的过滤器：
- en: '[PRE35]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Access any previous URL routes we''ve defined (`http://localhost:9000/session_example`)
    using a web browser. You will be able to see a new log entry with our response
    stats printed:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网络浏览器访问我们定义的任何之前的URL路由（`http://localhost:9000/session_example`）。你将能够看到一个包含我们响应统计的新日志条目：
- en: '[PRE36]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a new Scala-based filter. The filter simply calculates
    the total response time for request and prints it out in the log file. We then
    utilized the filter by referring to it in the global application configuration
    class `Global.java/Global.scala`. This will be applied to all requests of the
    Play application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个新的基于Scala的过滤器。该过滤器简单地计算请求的总响应时间并在日志文件中打印出来。然后，我们通过在全局应用程序配置类 `Global.java/Global.scala`
    中引用它来使用过滤器。这将应用于Play应用程序的所有请求。
- en: Using path binders
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路径绑定
- en: For this recipe, we will explore how Play applications allow us to use custom
    binders for path parameters. These come in handy when you want to simplify your
    declaration of routes and corresponding actions by dealing with model classes
    in the routes file and a method signature of actions instead of individual properties
    and fields declared as parameters.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将探讨Play应用程序如何允许我们使用自定义绑定器来处理路径参数。当您想通过在路由文件中处理模型类和方法签名而不是单独的属性和字段来简化路由和相应操作的声明时，这些绑定器非常有用。
- en: How to do it…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'For Java, we need to take the following steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，我们需要采取以下步骤：
- en: Run the `foo_java` application with Hot-Reloading enabled.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用热重载功能运行 `foo_java` 应用程序。
- en: 'Create a new products controller as `foo_java/app/controllers/Products.scala`.
    Once created, add a product case class and companion object, the product form
    object, and two routes (the first to display our selected product in a form and
    the second as the PUT action for form update submission):'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的产品控制器作为 `foo_java/app/controllers/Products.scala`。一旦创建，添加产品case类和伴随对象、产品表单对象以及两个路由（第一个用于在表单中显示所选产品，第二个作为表单更新提交的PUT操作）：
- en: '[PRE37]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add our new product model in `foo_java/app/models/Product.java` as well:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foo_java/app/models/Product.java` 中添加我们的新产品模型：
- en: '[PRE38]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add new routes for the newly added action in `foo_java/conf/routes`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foo_java/conf/routes` 中为新增的操作添加新的路由：
- en: '[PRE39]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create the product form view template in `foo_java/app/views/products/form.scala.html`
    with the following content:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foo_java/app/views/products/form.scala.html` 中创建产品表单视图模板，内容如下：
- en: '[PRE40]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Access our edited products URL route (`http://localhost:9000/products/ABC`).
    You should be able to view the edit form for our first product. Access our next
    edit products URL route (`http://localhost:9000/products/DEF`) and you should
    see the relevant product details loading in the form.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问我们编辑的产品URL路由（`http://localhost:9000/products/ABC`）。你应该能够查看我们第一个产品的编辑表单。访问我们的下一个编辑产品URL路由（`http://localhost:9000/products/DEF`），你应该能在表单中看到相关产品详情的加载。
- en: 'Access the URL `http://localhost:9000/products/XYZ` and see how Play automatically
    generates the error message with the custom message we specified:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问URL `http://localhost:9000/products/XYZ`，看看Play如何自动生成我们指定的自定义错误消息：
- en: '[PRE41]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For Scala, we need to take the following steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要采取以下步骤：
- en: Run the `foo_scala` application with Hot-Reloading enabled.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Hot-Reloading功能运行`foo_scala`应用程序。
- en: 'Create a new products controller as `foo_scala/app/controllers/Products.scala`.
    Once created, add a product case class and companion object, the product form
    object, and two routes (the first to display our selected product in a form and
    the second as the PUT action for the form update submission):'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的产品控制器作为`foo_scala/app/controllers/Products.scala`。一旦创建，添加一个产品case类和伴随对象、产品表单对象以及两个路由（第一个用于在表单中显示所选产品，第二个作为表单更新提交的PUT操作）：
- en: '[PRE42]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add new routes for the newly-added action in `foo_scala/conf/routes`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/routes`中为新增的操作添加新路由：
- en: '[PRE43]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create the product form view template in `foo_scala/app/views/products/form.scala.html`
    with the following content:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/app/views/products/form.scala.html`中创建产品表单视图模板，内容如下：
- en: '[PRE44]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Access our edit product URL route (`http://localhost:9000/products/ABC`) and
    you should be able to view the edit form for our first product. Access our next
    edit product URL route (`http://localhost:9000/products/DEF`) and you should see
    the relevant product details loading in the form.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问我们的编辑产品URL路由（`http://localhost:9000/products/ABC`），你应该能够查看我们第一个产品的编辑表单。访问我们的下一个编辑产品URL路由（`http://localhost:9000/products/DEF`），你应该能在表单中看到相关产品详情的加载。
- en: 'Access the URL `http://localhost:9000/products/XYZ` and see how Play automatically
    generates the error message with the custom message we specified:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问URL `http://localhost:9000/products/XYZ`，看看Play如何自动生成我们指定的自定义错误消息：
- en: '[PRE45]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we utilized Play''s `PathBindable` interface to use custom
    path binders. We created a new route, controller, and model to represent a product.
    We implemented the `PathBindable` bind and unbind methods for the product:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了Play的`PathBindable`接口来使用自定义路径绑定器。我们创建了一个新的路由、控制器和模型来表示产品。我们实现了产品的`PathBindable`绑定和解绑方法：
- en: 'Form binding is pretty straightforward for Java:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，表单绑定相当直接：
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As for Scala, we override two methods in the `PathBindable` class. During form
    binding, we first retrieve the product identifier `sku`, and then pass this same
    `sku` to retrieve the corresponding product in our product map:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们在`PathBindable`类中覆盖了两个方法。在表单绑定过程中，我们首先检索产品标识符`sku`，然后将这个相同的`sku`传递给产品映射以检索对应的产品：
- en: '[PRE47]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We defined a route that required the custom path binding:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个需要自定义路径绑定的路由：
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You will notice that in defining the earlier route, we mapped its product parameter
    to a product instance. The `PathBindable` class does all the work here in converting
    the passed `sku` to a product instance.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在定义早期路由时，我们将产品参数映射到了一个产品实例。`PathBindable`类在这里完成了所有工作，将传递的`sku`转换为产品实例。
- en: Serving JSON
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供JSON
- en: For this recipe, we will explore how Play Framework allows us to easily convert
    our model objects to JSON. Being able to write web services that deliver data
    in the JSON data format has been a very common requirement for modern web applications.
    Play provides a JSON processing library that we will utilize in this recipe.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将探索Play框架如何让我们轻松地将我们的模型对象转换为JSON。能够编写以JSON数据格式提供数据的Web服务，是现代Web应用的非常常见需求。Play提供了一个JSON处理库，我们将在本菜谱中使用它。
- en: How to do it…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'For Java, we need to take the following steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，我们需要采取以下步骤：
- en: Run the `foo_java` application with Hot-Reloading enabled.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Hot-Reloading功能运行`foo_java`应用程序。
- en: 'Modify the products controller in `foo_java/app/controllers/Products.java`
    by adding our product listing action:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/app/controllers/Products.java`中修改产品控制器，通过添加我们的产品列表操作：
- en: '[PRE49]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We need to add the following import statement for Play''s JSON libraries:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为Play的JSON库添加以下导入语句：
- en: '[PRE50]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Add a new route for the product listing action in `foo_java/conf/routes`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/conf/routes`中为产品列表操作添加一个新的路由：
- en: '[PRE51]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Access our product listing URL route (`http://localhost:9000/products`) using
    `curl`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`访问我们的产品列表URL路由（`http://localhost:9000/products`）：
- en: '[PRE52]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As we look at the output of our `curl` command, you will notice that our content
    type was automatically set accordingly (`application/json`) and that the response
    body contains an array of JSON products.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们查看`curl`命令的输出时，你会注意到我们的内容类型被自动设置为相应的内容（`application/json`），并且响应体包含一个JSON产品数组。
- en: 'For Scala, we need to take the following steps:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要采取以下步骤：
- en: Run the `foo_scala` application with Hot-Reloading enabled.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Hot-Reloading启用运行`foo_scala`应用程序。
- en: 'Modify the products controller in `foo_scala/app/controllers/Products.scala`
    by adding our product listing action:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`foo_scala/app/controllers/Products.scala`中添加我们的产品列表动作来修改产品控制器：
- en: '[PRE53]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We need to add the following import statement for Play''s JSON libraries:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加以下导入语句以使用Play的JSON库：
- en: '[PRE54]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We also need to add our implementation of writes for our product model inside
    our products controller:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在我们的产品控制器中添加我们产品模型的写入实现：
- en: '[PRE55]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add a new route for the product listing action in `foo_scala/conf/routes`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/routes`中为产品列表动作添加一个新的路由：
- en: '[PRE56]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Access our product listing URL route (`http://localhost:9000/products`) using
    `curl`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`通过我们的产品列表URL路由（`http://localhost:9000/products`）进行访问：
- en: '[PRE57]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As we look at the output of our `curl` command, you will notice that our content
    type was automatically set accordingly (`application/json`) and that the response
    body contains an array of JSON products.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们查看`curl`命令的输出时，你会注意到我们的内容类型已自动设置为相应值（`application/json`），并且响应体包含了一个JSON产品数组。
- en: How it works…
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In this recipe, we modified our products controller and added a new route that
    returns an array of products in the JSON format. We created the action in the
    controller and the new route entry in the `conf/routes` file. We then declared
    an implicit `writes` object which tells Play how to render our product model in
    the JSON format:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们修改了我们的产品控制器并添加了一个新的路由，该路由以JSON格式返回产品数组。我们在控制器中创建了动作，并在`conf/routes`文件中添加了新的路由条目。然后我们声明了一个隐式的`writes`对象，它告诉Play如何以JSON格式渲染我们的产品模型：
- en: '[PRE58]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the preceding code snippet, we explicitly declare the JSON key labels for
    the rendered JSON.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们明确声明了渲染JSON的JSON键标签。
- en: 'The action then converts the retrieved product to JSON as the response to the
    action request:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 动作然后将检索到的产品转换为JSON作为对动作请求的响应：
- en: '[PRE59]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Receiving JSON
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收JSON
- en: For this recipe, we will explore how Play Framework allow us to receive JSON
    objects easily and enable us to automatically convert them into model instances.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将探索Play框架如何使我们轻松接收JSON对象，并自动将它们转换为模型实例。
- en: How to do it…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'For Java, we need to take the following steps:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，我们需要采取以下步骤：
- en: Run the `foo_java` application with Hot-Reloading enabled.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Hot-Reloading启用运行`foo_java`应用程序。
- en: 'Modify the products controller in `foo_java/app/controllers/Products.java`
    by adding our product creation action:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`foo_java/app/controllers/Products.java`中添加我们的产品创建动作来修改产品控制器：
- en: '[PRE60]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We need to add the following import statement for Play''s JSON libraries:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加以下导入语句以使用Play的JSON库：
- en: '[PRE61]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Add a new route for the product listing action in `foo_java/conf/routes`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/conf/routes`中为产品列表动作添加一个新的路由：
- en: '[PRE62]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Access our product creation URL route (`http://localhost:9000/products`) using
    `curl`:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`通过我们的产品创建URL路由（`http://localhost:9000/products`）进行访问：
- en: '[PRE63]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As we look at the output of our `curl` command, you will notice that our response
    body now contains our newly added product.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们查看`curl`命令的输出时，你会注意到我们的响应体现在包含了我们新添加的产品。
- en: 'For Scala, we need to take the following steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要采取以下步骤：
- en: Run the `foo_scala` application with Hot-Reloading enabled.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Hot-Reloading启用运行`foo_scala`应用程序。
- en: 'Modify the products controller in `foo_scala/app/controllers/Products.scala`
    by adding our product creation action:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`foo_scala/app/controllers/Products.scala`中添加我们的产品创建动作来修改产品控制器：
- en: '[PRE64]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We need to add the following import statement for Play''s JSON libraries:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加以下导入语句以使用Play的JSON库：
- en: '[PRE65]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We will also need to add our implementation of reads for our product model
    inside our products controller:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在我们的产品控制器中添加我们产品模型的读取实现：
- en: '[PRE66]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Add a new route for the product listing action in `foo_scala/conf/routes`:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/routes`中为产品列表动作添加一个新的路由：
- en: '[PRE67]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Access our product creation URL route (`http://localhost:9000/products`) using
    `curl`:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`通过我们的产品创建URL路由（`http://localhost:9000/products`）进行访问：
- en: '[PRE68]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As we look at the output of our `curl` command, you will notice that our response
    body now contains our newly added product.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们查看`curl`命令的输出时，你会注意到我们的响应体现在包含了我们新添加的产品。
- en: How it works…
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In this recipe, we looked into how we can use Play to consume JSON objects
    by using the JSON `BodyParser` and be able to convert them to the appropriate
    model objects. For Java, we traversed the JSON tree, retrieved each property value,
    and assigned it to our local variables:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们探讨了如何使用 Play 通过 JSON `BodyParser` 消费 JSON 对象，并将它们转换为适当的模型对象。对于 Java，我们遍历
    JSON 树，检索每个属性值，并将其分配给我们的局部变量：
- en: '[PRE69]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'For Scala, this was a little more straightforward, using the JSON `BodyParser`
    from Play:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Scala，这要简单一些，使用 Play 的 JSON `BodyParser`：
- en: '[PRE70]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Uploading files
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传文件
- en: For this recipe, we will learn how to upload files in Play applications. The
    ability to upload files is one of the more important aspects of web applications,
    and we will see here how Play makes file uploads straightforward and easy to handle.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将学习如何在 Play 应用程序中上传文件。上传文件的能力是网络应用中更为重要的方面之一，我们将在这里看到 Play 如何使文件上传变得简单易处理。
- en: How to do it…
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'For Java, we need to take the following steps:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Java，我们需要采取以下步骤：
- en: Run the `foo_java` application with Hot-Reloading enabled.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以启用热重载的方式运行 `foo_java` 应用程序。
- en: 'Add a new view template in `foo_java/app/views/form.scala.html` for the file
    upload form with the following contents:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foo_java/app/views/form.scala.html` 中添加一个新的视图模板，用于文件上传表单，内容如下：
- en: '[PRE71]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Modify `foo_java/app/controllers/Application.java` by adding the following
    actions:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下操作修改 `foo_java/app/controllers/Application.java`：
- en: '[PRE72]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Add a new routes entry for the newly-added action in `foo_java/conf/routes`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foo_java/conf/routes` 中为新增的操作添加一个新的路由条目：
- en: '[PRE73]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Access the upload form URL route (`http://localhost:9000/upload_form`) using
    a web browser. You will now be able to select a file to upload in your filesystem.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网络浏览器访问上传表单 URL 路由（`http://localhost:9000/upload_form`）。现在你将能够在文件系统中选择要上传的文件。
- en: 'You can verify that the file was indeed uploaded by taking a look at the `/tmp`
    directory:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过查看 `/tmp` 目录来验证文件确实已上传：
- en: '[PRE74]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'For Scala, we need to take the following steps:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Scala，我们需要采取以下步骤：
- en: Run the `foo_scala` application with Hot-Reloading enabled.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以启用热重载的方式运行 `foo_scala` 应用程序。
- en: 'Add a new view template in `foo_scala/app/views/form.scala.html` for the file
    upload form with the following contents:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foo_scala/app/views/form.scala.html` 中添加一个新的视图模板，用于文件上传表单，内容如下：
- en: '[PRE75]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Modify `foo_scala/app/controllers/Application.scala` by adding the following
    action:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下操作修改 `foo_scala/app/controllers/Application.scala`：
- en: '[PRE76]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Add a new routes entry for the newly added action in `foo_scala/conf/routes`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foo_scala/conf/routes` 中为新增的操作添加一个新的路由条目：
- en: '[PRE77]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Access the upload form URL route (`http://localhost:9000/upload_form`) using
    a web browser. You will now be able to select a file to upload in your filesystem.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网络浏览器访问上传表单 URL 路由（`http://localhost:9000/upload_form`）。现在你将能够在文件系统中选择要上传的文件。
- en: 'You can verify that the file was indeed uploaded, by taking a look at the `/tmp`
    directory:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过查看 `/tmp` 目录来验证文件确实已上传：
- en: '[PRE78]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: How it works…
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created two new actions and URL routes; the first to display
    our upload form template and the second to handle the actual file upload action.
    We added our upload view form template `form.scala.html` in the `app/views` directory.
    We then handled the actual file upload submission by using Play's helper methods
    to retrieve the uploaded file, and then proceeded to store the file in a predefined
    location.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了两个新的操作和 URL 路由；第一个用于显示我们的上传表单模板，第二个用于处理实际的文件上传操作。我们在 `app/views`
    目录中添加了我们的上传视图表单模板 `form.scala.html`。然后我们通过使用 Play 的辅助方法来检索上传的文件，并将其存储在预定义的位置来处理实际的文件上传提交。
- en: Using futures with Akka actors
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Akka actors 与 futures
- en: For this recipe, we will explore how Play Framework allows us to create asynchronous
    controllers using futures, in conjunction with Akka actors. The ability to create
    asynchronous controllers provides a way for developers to trigger background jobs
    and execute long-running operations asynchronously without sacrificing endpoint
    responsiveness. Adding Akka to the mix brings a new dimension to fault-tolerant,
    resilient data services, which become valuable tools in a developer's toolchain
    in the age of maturing and sophisticating web application requirements.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将探讨 Play 框架如何允许我们使用 futures 和 Akka actors 创建异步控制器。创建异步控制器为开发者提供了一种触发后台作业和异步执行长时间运行操作的方法，而不会牺牲端点的响应性。将
    Akka 加入其中为容错、健壮的数据服务带来了新的维度，这些服务在成熟和复杂的网络应用需求时代成为了开发者工具链中的宝贵工具。
- en: How to do it…
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'For Java, we need to take the following steps:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，我们需要采取以下步骤：
- en: Run the `foo_java` application with Hot-Reloading enabled.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用热重载功能运行`foo_java`应用程序。
- en: 'Modify the application controller in `foo_java/app/controllers/Application.java`
    by adding the following contents:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下内容修改`foo_java/app/controllers/Application.java`中的应用控制器：
- en: '[PRE79]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We need to add the following import statement to include the necessary libraries,
    specifically the `Akka` libraries that we will be utilizing for this recipe:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加以下导入语句以包含必要的库，特别是我们将为本菜谱使用的`Akka`库：
- en: '[PRE80]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We also need to add our Akka actor in `foo_java/app/actors/FileReaderActor.java`
    with the following contents:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在`foo_java/app/actors/FileReaderActor.java`中添加我们的Akka actor，内容如下：
- en: '[PRE81]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We also need to create our actor protocol class for the `FileReaderActor` in
    `foo_java/app/actors/FileReaderProtocol.java` with the following content:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在`foo_java/app/actors/FileReaderProtocol.java`中为`FileReaderActor`创建我们的actor协议类，内容如下：
- en: '[PRE82]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Add a new route for the async example action in `foo_java/conf/routes`:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/conf/routes`中为异步示例操作添加新路由：
- en: '[PRE83]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Add the default `Akka` configs in `foo_java/conf/application.conf`:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/conf/application.conf`中添加默认的`Akka`配置：
- en: '[PRE84]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Access the async example URL route (`http://localhost:9000/async_example`) using
    a web browser. You should see the contents of the local file `/usr/share/dict/words`
    displayed in the web browser.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网络浏览器访问异步示例URL路由（`http://localhost:9000/async_example`）。你应该在浏览器中看到本地文件`/usr/share/dict/words`的内容。
- en: 'For Scala, we need to take the following steps:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要采取以下步骤：
- en: Run the `foo_scala` application with Hot-Reloading enabled.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用热重载功能运行`foo_scala`应用程序。
- en: 'Modify the application controller in `foo_scala/app/controllers/Application.scala`
    by adding the following contents:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下内容修改`foo_scala/app/controllers/Application.scala`中的应用控制器：
- en: '[PRE85]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We need to add the following import statements to include the necessary libraries,
    specifically the `Akka` libraries we will be utilizing for this recipe:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要添加以下导入语句以包含必要的库，特别是我们将为本菜谱使用的`Akka`库：
- en: '[PRE86]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We also need to add our Akka actor in the application controller for convenience:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了方便起见，我们还在应用程序控制器中添加了我们的Akka actor。
- en: '[PRE87]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Add a new route for the async example action in `foo_scala/conf/routes`:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/routes`中为异步示例操作添加新路由：
- en: '[PRE88]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Add the default `Akka` configs in `foo_scala/conf/application.conf`:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/application.conf`中添加默认的`Akka`配置：
- en: '[PRE89]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Access the async example URL route (`http://localhost:9000/async_example`) using
    a web browser. You should see the contents of the local file `/usr/share/dict/words`
    displayed in the web browser.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网络浏览器访问异步示例URL路由（`http://localhost:9000/async_example`）。你应该在浏览器中看到本地文件`/usr/share/dict/words`的内容。
- en: How it works…
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we modified our application controller and added a new route
    that returns the contents of a local file `/usr/share/dict/words`. We created
    the action in the controller and the new route entry in the `conf/routes` file.
    We then created the Akka actor class and protocol class that will do the actual
    work of reading the file and returning its contents.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们修改了应用程序控制器并添加了一个新路由，该路由返回本地文件`/usr/share/dict/words`的内容。我们在控制器中创建了动作，并在`conf/routes`文件中创建了新的路由条目。然后我们创建了将执行读取文件并返回其内容的实际工作的Akka
    actor类和协议类。
- en: 'For Java, we need to take the following steps:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，我们需要采取以下步骤：
- en: '[PRE90]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'For Scala, we need to take the following steps:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要采取以下步骤：
- en: '[PRE91]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We then configured our new action to invoke the `Actor` and configured it in
    such a way that it returns the results asynchronously:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们配置了新的动作以调用`Actor`，并以异步方式返回结果：
- en: '[PRE92]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We also added default `Akka` configuration settings in `conf/application.conf`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`conf/application.conf`中添加了默认的`Akka`配置设置：
- en: '[PRE93]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The preceding settings allow us to set the maximum size of our default dispatcher's
    thread pool. In this recipe, it is set to 64\. For more information about Akka
    dispatchers, please refer to [http://doc.akka.io/docs/akka/snapshot/java/dispatchers.html](http://doc.akka.io/docs/akka/snapshot/java/dispatchers.html).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 上述设置允许我们设置默认分发器线程池的最大大小。在本菜谱中，它被设置为64。有关Akka分发器的更多信息，请参阅[http://doc.akka.io/docs/akka/snapshot/java/dispatchers.html](http://doc.akka.io/docs/akka/snapshot/java/dispatchers.html)。
