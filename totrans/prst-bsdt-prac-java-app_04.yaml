- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design Patterns for Data Management in Cloud-Native Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regardless of whether the principles of monolithic or microservices architecture
    are chosen, we should certainly expect to enhance each service’s quality by incorporating
    yet another software design pattern – the **layered architecture** software design
    pattern. Recently, the term cloud-native has become quite popular and much discussed,
    describing a set of best practices for optimizing an application in the cloud
    through the use of containers, orchestration, and automation.
  prefs: []
  type: TYPE_NORMAL
- en: This approach recommends service design and organization in distinct layers,
    each owning specific responsibilities and well-defined interfaces. The potential
    guarantee of better abstraction and isolation characteristics is the payoff for
    the required extra source code and its aggregated code design complexity.
  prefs: []
  type: TYPE_NORMAL
- en: In exploring the reasons why a layered architecture pattern is crucial to healthy
    applications, particularly concerning persistence integration and data manipulation,
    this chapter will prepare and guide you throughout a service’s design transformation
    journey. You’ll start off by getting familiar with a set of key application-layer
    design strategies, which will technically explain and demonstrate how an unstructured
    application, without any level of abstraction, can be transformed into an elegantly
    designed service, composed of an appropriate set of layers able to provide decent
    separation and segregation between the persistence implementation technicalities
    and business context.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout a comparative analysis of each layer design strategy, we will discuss
    the gains and losses of mistakenly bringing the core ideals to an extreme. On
    top of the aforementioned solid background, you’ll learn through detailed code
    samples the *reason* for each layer’s existence and be able to determine *when*
    the circumstances present you with an excellent opportunity to use them.
  prefs: []
  type: TYPE_NORMAL
- en: The quality of persistence solutions is right at the core of this chapter’s
    motivation. As previous chapters focused on the broader solution’s architecture,
    integration, and deployment models, we should take a closer look into implementing
    individual services. We need to take into consideration the powerful outcomes
    of combining data-related patterns with other popular practices such as **domain-driven
    design** (**DDD**). And finally, but no less importantly, we *must* discuss a
    framework’s quality; after all, most Java solutions strongly depend on frameworks.
    We must, and in this chapter will, shed light on actual framework implementation
    strategies, to the point of evaluating the impacts of certain frameworks’ characteristics
    such as being built as a reflection or reflectionless technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content is broken down and discussed throughout the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns applied to the Java persistence layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating the Java mapping landscape – evaluating framework trade-offs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data transfer between the view and underlying layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Git client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A GitHub account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code samples demonstrated are available at [https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/](https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/).
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns applied to the Java persistence layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We, as software engineers, often discuss and adopt layered architectural solutions,
    but why? Why should we consider using this code style? What are its surrounding
    trade-offs? In order to provide a better understanding of code design patterns,
    we’ll illustrate a scenario around accomplishing a simple mission: storing and
    retrieving data from a database – more specifically, a library system that manages
    books and their respective data. At first glance, our task looks quite straightforward,
    right? Let’s get started.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we see the need to create an entity, a `Book` class, which we can use
    to handle the library’s domain – our business domain. The first characteristic
    we can assume is that our `Book` entity should be `Book` entity attributes should
    be `title`, `author`, `publisher`, and `genre`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sample represents the described `Book` class. Notice all
    fields are set as `final` to implement the immutability assumption. To enable
    developers to create instances of this class, the `Book` class brings a `constructor`
    method and a `builder` class (*removed* *for brevity*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first entity, `Book`, is implemented as an immutable class.
  prefs: []
  type: TYPE_NORMAL
- en: The instance variables are set as `final`. Therefore, it is not possible to
    change the value of them after the object is initialized. Notice as well that
    there are no setter methods. If you are interested in the detailed implementation
    of the inner class, refer to the `Book` class ([https://github.com/architects4j/mastering-java-persistence-book-samples/blob/e594bb17eab3dc97665b495b4245312bfd0f421b/chapter-04/src/main/java/dev/a4j/mastering/data/Book.java#L14-L66](https://github.com/architects4j/mastering-java-persistence-book-samples/blob/e594bb17eab3dc97665b495b4245312bfd0f421b/chapter-04/src/main/java/dev/a4j/mastering/data/Book.java#L14-L66))
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simulate the serialization from and to the database, we’ll use the `db`
    in-memory object of type `Map` of `Map`: `Map<String, Map<String,` `Object>> db`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The memory database is not fancy and does not cover any concurrency cases, but
    it is simple to put more focus on the layers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The core example’s goal is to assess a database layer, such as JDBC, so we won’t
    cover race conditions and other *real-life* challenges.
  prefs: []
  type: TYPE_NORMAL
- en: To keep our focus on entity mapping and code design, our simulated in-memory
    *database* exclusively addresses the four **create, read, update, and delete**
    (**CRUD**) operations.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward with the implementation, the next action would be to implement
    every CRUD database operation. Remember that at our scenario’s starting point,
    we currently *live a life with no layers*; therefore, all our methods should reside
    in the same class.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will take a look at the unstructured approach we’ve mentioned, followed
    by how it compares to the same solution implemented using the **data mapper**,
    **data access object** (**DAO**), **repository**, and **active** **record** patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Unstructured code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our scenario’s journey started off with the design of an application with a
    single layer. This layer is the one the application will rely on for its book
    data manipulation using operations for inserting a book, converting the underlying
    representation of a book as a database model from/into a Java domain object, and
    enabling the querying of a book instance. Well, there *is* good news: we have
    all we need in a centralized place/file. There should be no surprises or pain
    when, eventually, there’s a maintenance request that requires locating and modifying
    a database model’s field or updating the logic of the entity’s method – they reside
    in the same place.'
  prefs: []
  type: TYPE_NORMAL
- en: As this application’s capabilities grow and the class gets lengthier, it becomes
    harder and harder to spot which code is doing what. As we repeatedly noticed happening
    in real-world applications, unfortunately, such complication eventually and *most
    certainly* ends up in unnecessary code duplication. This is especially the case
    for applications with numerous entity classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the code, what follows is a code implementation that instances
    a new book, and uses our homemade database client to manipulate the book data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Book`, Java’s domain object, is instanced using CDI mechanisms and its constructor
    method.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The object’s attributes are mapped to their respective database model attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `database` client instance, using CDI, is created or retrieved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The book is saved using the `database` client’s API; the persisted information
    is composed of the actual Java’s model attribute reference plus the manually set
    database representation, `entry`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A book’s information is retrieved from the database by its ID – `title` – and
    stored in the database model representation of type `Map` – *not the class* *type*
    `Book`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using a builder, a `Book` object instance is created from the retrieved data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Some might get the impression that this code is simple to handle. However, it
    is also easy to predict the upcoming impact on long-term support. More code makes
    maintenance more error-prone, and the result is an application that now represents
    *risk* to the proper functioning of the *organization* and *business*, not to
    mention the multiple technical implications.
  prefs: []
  type: TYPE_NORMAL
- en: 'As software developers, we have likely all encountered (or even designed ourselves)
    systems that have become increasingly difficult to maintain and modify due to
    poor design choices. Robert Martin (a.k.a. Uncle Bob), in one of his presentations,
    named the four signs of a “rotting design” in software: rigidity, fragility, immobility,
    and viscosity. These four signs are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rigidity**: The tendency for software to change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fragility**: The trend of software breaking in many places every time it
    is changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immobility**: The inability to reuse software from other projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Viscosity**: The API making the code harder to hack when we need to change
    it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember we mentioned that duplicates could likely show up in our previous library
    example? The reason for this is that it’s harder to change the code than it is
    to duplicate it. Predictable results are a breach of the **single responsibility**
    principle (of the **SOLID** design principles) and a complex testing scenario.
    After all, how can you stick to the test practices of a test pyramid (see *Figure
    4**.1*)?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Test pyramid](img/Figure_4.01_B19375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Test pyramid
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We can draft a comparison line between the code design under discussion and
    the unstructured monolith (see *Building Evolutionary Architecture*); both have
    a tendency toward increased complexity and hard-to-move architecture – just like
    a “big ball of mud”.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to persistence, there are a couple more things to consider that
    we want to highlight:'
  prefs: []
  type: TYPE_NORMAL
- en: The design you choose will impact how much effort will be required when changing
    between database paradigms. For instance, changing a persistence provider (such
    as switching from SQL to NoSQL) can be a tough task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you seek to adopt the good practices of the pyramid testing method, having
    a high coupling between layers makes it hard to accurately write a proper amount
    of unit tests if compared to integration tests. Have in mind that using a script
    or a small tool for persistence can be worthwhile in the short term; the problem
    is that it can also turn into a nightmare in the long run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using more layers can be advantageous. For example, you will be able to abstract
    away the business logic from the technology specificities. Other than the common
    **model-view-controller** (**MVC**) basic layers, you can also consider adding
    an additional layer of abstraction between the model and the database, particularly
    when working with a three-tier architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unlike the MVC, which has three distinct layers, in an unstructured code design,
    the client has direct access to the database. It’s not about whether this is a
    good or bad solution, but rather about highlighting the trade-offs. This approach
    may be useful when creating a simple/fast migration script or any other piece
    of code that won’t be around for long or isn’t expected to grow. The following
    diagram illustrates this design:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.2 – Clien\uFEFFt-database integration in unstructured code design](img/Figure_4.02_B19375.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Client-database integration in unstructured code design
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, this model is simple, but as the solution grows in
    size, we may encounter duplicate code including boilerplate code for converting
    between the database and the business entity. To address these issues, we will
    create a first layer to centralize the mapping translation in one place and establish
    boundaries between the client and the database.
  prefs: []
  type: TYPE_NORMAL
- en: The data mapper pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to create the first layer between the client application and
    the database. This layer is a great opportunity to reduce the boilerplate and
    thus minimize bugs – less code, fewer bugs. In the previous example application,
    you may have noticed that the whole operation of mapping domains and manipulating
    data is part of a single block, which can make it difficult to read, maintain,
    and test.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the book *Just Enough Software Architecture: A Risk-Driven Approach*, we
    learn about the importance of considering these threats to competent design and
    using three weapons to combat complexity and risk: partition, knowledge, and *abstraction*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we’ll use abstraction to hide the technical details and concentrate
    them in a single place. Here’s how we can do that: let’s introduce our *treacherous*
    layer. While a layer can help isolate and abstract a functionality, it also adds
    more code. This is our trade-off.'
  prefs: []
  type: TYPE_NORMAL
- en: The conversion between the database and the Java domain models should also happen,
    and with more entities, it’s going to be even more recurring. In this first step,
    let’s abstract this conversion process in an abstraction layer using the data
    mapper pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BookMapper` class will centralize the conversion behavior in a single
    place: the layer. From now on, if there is a bug in the conversion, this is the
    class to check out for any changes in either entity- or database-related code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can observe in the preceding code, `BookMapper` centralizes the mapping
    operations of a database model and the application entity model. There are several
    effective frameworks on the market that can do this type of mapping task, such
    as the popular option `BookMapper`, has a more direct approach: it uses Java functions
    to encapsulate and execute these conversions.'
  prefs: []
  type: TYPE_NORMAL
- en: Info – Java functions
  prefs: []
  type: TYPE_NORMAL
- en: Java functions are a way to encapsulate a piece of code that can be reused throughout
    your application. They are defined with the `public static` keyword, followed
    by the return type, the function name, and a list of parameters within parentheses.
    Functions can make your code more organized and easier to read, as well as saving
    time by eliminating the need to write the same code multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at how we can use the `BookMapper` operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding sample code introduces the conversion process by using the `Mapper`
    class. By doing that, we are abstracting away the conversion operations from this
    method by moving them to the `BookMapper` class. Due to the encapsulation, *the
    client does not know the details of how the translation process is done* – great!
  prefs: []
  type: TYPE_NORMAL
- en: While this is a positive step, there are still improvements to be made as the
    client is still responsible for invoking the conversion operation. While we can
    test the conversion process, the high coupling between the client and the technology
    is still a concern.
  prefs: []
  type: TYPE_NORMAL
- en: To address these issues, our next design includes the addition of a *mapper
    layer*, which will reduce the friction between the client and the database. This
    mapper will be used repeatedly, making it a good candidate for a framework such
    as JPA or Hibernate to operate on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, introducing this mapper layer will help us improve the flexibility
    and maintainability of our solution, while also reducing complexity (see *Figure
    4**.3*):'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.3 – Mapper layer\uFEFF – code design now has an extra abstraction\
    \ layer](img/Figure_4.03_B19375.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Mapper layer – code design now has an extra abstraction layer
  prefs: []
  type: TYPE_NORMAL
- en: While the mapper layer does make things simpler for the client, it still requires
    the client to have some knowledge of the database details. This can be problematic
    as it opens up possibilities for errors when implementing the mapper and its operations.
    What if we could find a way to reduce this risk? What about creating a new layer,
    but this time, having it act on the entire database operation?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s introduce the DAO pattern! It will allow us to reduce the burden on the
    client and minimize the chances of implementation errors.
  prefs: []
  type: TYPE_NORMAL
- en: The DAO pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The DAO pattern is a way to structure the separation of the application/business
    layer from the persistence layer. Its main goal is to abstract the whole database
    operation from the API.
  prefs: []
  type: TYPE_NORMAL
- en: By encapsulating all the operations in a class or interface, the API can be
    updated whenever needed without affecting the persistence data implementation.
    This is especially useful in long-term systems, where the DAO implementation may
    need to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: '`BookDAO` introduces the contracts for inserting and retrieving a `Book`. As
    a client of this interface, you don’t need to know how it works internally. This
    makes the code safer by centralizing the database process in a single place. Now
    `BookDAO` will be the one working with the database mapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The DAO has an imperative style, which means it’s up to the client to define
    the specific operation. For example, if you are using the API and want to update
    a book, you must make sure the book exists first; otherwise, you’ll get an exception
    being thrown. If you are familiar with JPA from previous Java EE, you might consider
    abstracting `EntityManager` in a project such as this. In this example, we’ll
    use the mapper operations in the DAO layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The DAO pattern was made popular by Microsoft in Visual Basic, and later Java
    through the Sun organization. It was also stated in the early days in the *Core
    J2EE Patterns* book. It includes the names of the methods, but the goal is to
    isolate the database with an abstraction, so it doesn’t matter whether you are
    using SQL, NoSQL, or any service.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a trade-off perspective, we get isolation and better maintainability,
    and we can test a service unit by mocking the DAO if needed. However, keep in
    mind that because it’s generally an imperative API, it’s up to the client to make
    sure it’s using the right method (update or insert, for instance) in the right
    situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using the DAO pattern, from now on, a book client consuming `BookDAO` interacts
    with books without awareness of the database conversion processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'By abstracting away the database operations, our client doesn’t even need to
    know about mapping operations, and we can isolate a few things on the persistence
    side. However, the client still needs to be aware of the data operation. *Figure
    4**.4* shows the new layer where the client is moved, or abstracted, a bit further
    away from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.4 – U\uFEFFpfront design using DAO pattern brings even more abstraction\
    \ to the database integration](img/Figure_4.04_B19375.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Upfront design using DAO pattern brings even more abstraction to
    the database integration
  prefs: []
  type: TYPE_NORMAL
- en: From the client’s perspective, it’s an improvement compared to the beginning
    when the client had to handle the whole process, including the database and entity
    model conversions, plus the data manipulation operations themselves. But if the
    client tries to insert twice or update inexistent information, again, we’ll get
    exceptions being thrown. This is a database detail that might not make sense in
    some cases. So, how can we remove this and focus more on the business? That’s
    what we’ll explore in the next section with the repository pattern and the **domain-driven
    design** (**DDD**) practices.
  prefs: []
  type: TYPE_NORMAL
- en: Repository pattern boosted by DDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The repository is a pattern from DDD that focuses on a business perspective
    and abstracts away storage and infrastructure details. As a client using this
    API, we don’t need to worry about any implementation details. The main focus is
    on the **ubiquitous language**.
  prefs: []
  type: TYPE_NORMAL
- en: DDD and the universal language
  prefs: []
  type: TYPE_NORMAL
- en: In DDD, the concept of a‘‘ubiquitous language’’refers to a shared language that
    is used by all members of a development team to communicate about the domain model.
    This language helps to improve communication and reduce misunderstandings by ensuring
    that everyone is using the same terms to refer to the same concepts. It is an
    important part of the DDD process and should be fostered and refined throughout
    the development of a software project.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to our book example, let’s start by creating an interface to handle
    a `Library` book collection. `Library` should be able to save books, find books
    by title, and when appropriate, unregister books.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Library` contracts are going to do the job, and the client won’t even
    know whether the implementation is going to actually insert or update a book.
    The client’s need is to save a book; from the technical perspective, if it’s a
    new book, it’s inserted, and if it already exists, it’s then updated. The `Library`
    interface will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The interface contract uses a ubiquitous language that is closer to the business
    language and hosts the methods related to its operations. As a client, I don’t
    want to have to care about how the data is stored or where it comes from. If you’re
    a Java developer, you may be familiar with frameworks that implement repository
    patterns such as `save` method to put away the database operation.
  prefs: []
  type: TYPE_NORMAL
- en: Does this framework allow the use of DDD practices?
  prefs: []
  type: TYPE_NORMAL
- en: 'Some frameworks use a repository interface methodology, but not all of them
    follow the DDD practices. You can easily check whether a framework follows DDD
    practices: look for insert and update methods, such as in the Quarkus framework
    and JPA with PanacheRepository.'
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between a DAO and a repository pattern implementation is
    the distance, often called the proximity, between the client and the database.
    While a DAO exposes the behavior of the persistence layer, a repository tends
    to have a business-oriented exposure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Library` implementation will use the DAO layer, implemented on the `BookDAO`
    class. Our `DAO` already has the mapper conversion operations and database operations
    ready to go. The following code shows, through the `register` method, how to use
    the DAO `insert` and `update` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s take a look at the client code. From the client’s perspective, we
    can notice the abstraction primarily when registering a book – the business-oriented
    operation named `register` is simplified by delegating the technical decision
    of updating or inserting to the underlying implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Fameworks and the mapper pattern
  prefs: []
  type: TYPE_NORMAL
- en: There are several frameworks available to help simplify the work of Java developers
    when it comes to implementing a mapper layer. Some examples include Spring Data,
    Micronaut, Quarkus, and the Jakarta Data specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows the repository client implementation registering a book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By having the preceding repository as the client, there’s no need to implement
    any kind of details on where to obtain this data from. It simplifies and focuses
    on the business need – registering a book and finding it by its title. However,
    there’s a cost to this. Even when using frameworks, adding more layers also has
    its trade-offs, such as increased CPU consumption and more locations, which can
    be potential root causes to be checked in case of eventual bugs. The following
    figure shows that we’ve added another layer between the database and the business
    domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Up-front design using repository pattern](img/Figure_4.05_B19375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Up-front design using repository pattern
  prefs: []
  type: TYPE_NORMAL
- en: Yet again, we have to face the dilemma of software design – where there is no
    right or wrong answer, just trade-offs. On the one hand, we can move the database
    as far away as possible and simplify the client implementation. On the other hand,
    we might go too far and end up tightly integrating the entity and database operations
    while trying to simplify things.
  prefs: []
  type: TYPE_NORMAL
- en: Our next and final stop on this journey will be the active record pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The active record pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The active record is a way to reduce the complexity of using database operations
    in a model. Martin Fowler defined it in his 2003 book *Patterns of Enterprise
    Application Architecture*. And here’s our next stop – we’ll combine the entity
    with its database operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea behind this pattern is to use inheritance in Java by having an entity
    that extends a `Model` class. This gives the entity database capabilities like
    that of a model with superpowers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'But with great power comes great responsibility. One of the main benefits of
    this pattern is simplicity. If you look at it from an MVC perspective, the model
    will then hold both business-related logic and data manipulation logic. In our
    code sample, the `Book` class is able to do several database operations such as
    inserting, updating, deleting, and finding by ID. The following code shows the
    client’s implementation code, which can create the book and then use the `insert`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This pattern makes sense in certain situations, especially in simple applications.
    But just as with every other solution, this is not a silver bullet. This pattern
    has its own concerns, such as breaching the single responsibility principle of
    SOLID. Some Java frameworks rely on this pattern, such as Panache with Quarkus,
    ActiveJDBC, and ActiveJPA.
  prefs: []
  type: TYPE_NORMAL
- en: Discussing layers and abstractions can be quite a big topic because the decision
    you made can have positive and negative consequences.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen different ways to design a persistence integration layer,
    we will move on to analyzing how frameworks work under the covers and learn which
    of their characteristics can be weighted when choosing a persistence framework
    technology.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the Java mapping landscape – evaluating framework trade-offs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can now understand the motivations for using layers. It’s great that we
    have a mature Java ecosystem and don’t have to do everything manually – *thanks
    to the frameworks*. Since there are so many of them, we can categorize them based
    on API usability, proximity, and runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '**Usability:** One of the items to evaluate when looking at a framework is
    the usability of its API. For instance, you can ask a question such as “*How many
    times can we use the same API with different databases? Is it* *even possible?*”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Agnostic API**: A single API can be used with multiple database vendors,
    types, or paradigms. The positive aspect of this is that an agnostic API reduces
    the cognitive load since you don’t need to learn about a new API for every different
    database integration. However, you might lose particular database behaviors or
    have to wait longer to receive feature updates and bug fixes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Specific API**: The opposite of the agnostic API would be each database requiring
    a dedicated API – in other words, one API per database. Constantly updated versions
    are offered to support users to integrate with the latest version of the target
    database provider. Fortunately, it might have fewer layers and more performance;
    unfortunately, the cognitive load can be harder to manage when handling polyglot
    persistence.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proximity**: How close is the framework to the database storage engine?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communication**: Closer to the database and farther from the domain model;
    this enables data-driven design, but there might be more boilerplate code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mapping**: Closer to the model and farther from the database; this enables
    DDD and reduces boilerplate code, but being farther from the database can result
    in ignoring the best practices on the database side.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime**: This mainly affects mapping frameworks that rely on annotations
    usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reflection**: This framework explores the reflection in Java, which allows
    for more flexibility and variety of runtime plugins. However, the startup time
    is slower and the application consumes a large amount of memory to execute processes
    for reading the metadata.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reflectionless**: This type of framework avoids reflections, making startup
    faster and more economical. However, metadata processing happens at build time
    instead of runtime, resulting in longer build and packaging processes, and there
    is less flexibility for the framework to explore in real time.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, there are a variety of Java mapping frameworks to choose from,
    each with its own trade-offs in terms of API usability, proximity to database
    implementation details, and runtime capabilities. It’s important to consider the
    specific needs of your project and choose the framework that best fits those needs.
  prefs: []
  type: TYPE_NORMAL
- en: And now that we’ve split our *all-in-one* class, simplified the client implementation,
    reduced chances of development errors, and acknowledged the types of frameworks
    we can pick from the many options available on the market, we can’t go forward
    without discussing the view and controller layers (of MVC) from a data perspective.
    In the next section, we’ll explore how to handle data that travels between the
    view layer and the underlying layers when using **data transfer** **objects**
    (**DTOs**).
  prefs: []
  type: TYPE_NORMAL
- en: Data transfer between the view and underlying layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve discussed the importance of application layers for development
    and how they can impact the maintainability and complexity of a project. We’ve
    also looked at the application’s model and its relation to the database in an
    MVC architecture. But wait a moment… when it comes to the view and controller
    (of MVC), are there any potential impacts on the database integration and its
    performance?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is *yes*. Let’s take a better look at how data transfer from the
    presentation layer to the underlying layers can benefit or impact your solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, when developers decide to use the data model on the client
    side, challenges such as the following can show up:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Book`, for example – can directly impact the view layer and require changes
    to it as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Library` example, it wouldn’t be a good thing to expose sensitive data such
    as a book’s *price*. In a more concrete scenario, suppose you’re developing a
    client consumer of a social media API – it would be unacceptable to find a user
    by ID, for instance, and expose all non-sensitive and sensitive information, including
    things such as the user’s password! It’s strongly recommended to *share only what’s
    necessary – not all information should be visible to* *the client*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code evolution and versioning**: In typical scenarios, part of the code is
    constantly evolving while another part, the *legacy* side, must be maintained.
    In this case, if a new capability requires changes to the model that is used inside
    the view layer, it may break the legacy model side of this integration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To handle model differences between the old and current code, one approach is
    to use **versioning**. By versioning the model class used in the view (which is
    the client), it becomes possible to have the same model offered through different
    classes and enable the creation of different views, each with their respective
    adapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the set of problems in this approach, the conclusion is that the solution
    to transferring information through presentation layers is to separate the model
    from the view and controller. That’s when the DTO pattern comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: A look back at DTOs
  prefs: []
  type: TYPE_NORMAL
- en: A DTO is a design pattern that facilitates transferring data between a system’s
    layers or components. It can be used to decouple the presentation layer from the
    business logic, increasing the application’s flexibility and maintainability.
    These simple objects contain data but no associated business logic – they’re simple
    representations of data to be displayed in a view.
  prefs: []
  type: TYPE_NORMAL
- en: The DTOs represent different views from the actual domain models. A DTO could
    hold, for instance, just the necessary subset of books of information that needs
    to be presented. In summary, the DTO pattern has benefits such as *model simplification*
    due to the separation between business and database logic, *performance improvement*
    since fewer database calls are made, and *enhanced security* by preventing data
    leaks through the exposure of sensitive attributes.
  prefs: []
  type: TYPE_NORMAL
- en: However, potential drawbacks can also be seen, such as the *higher complexity*
    caused by an increasing number of layers and classes, the *reduced flexibility*
    resulting from restricted access to the model’s information, which may be needed
    but not exposed, and the *decreased performance* caused by additional processing
    on the mapping between DTOs and models.
  prefs: []
  type: TYPE_NORMAL
- en: It’s crucial to keep in mind that isolation is key, and too much code can increase
    complexity and impact performance.
  prefs: []
  type: TYPE_NORMAL
- en: Creating DTOs can denote a lot of work, especially when manually implemented.
    Fortunately, if you consider the DTO pattern a good fit for your project, there
    are frameworks available on the market that can make your life easier. Frameworks
    such as model mapper ([http://modelmapper.org/](http://modelmapper.org/)) and
    MapStruct ([https://mapstruct.org/](https://mapstruct.org/)) can facilitate and
    speed up the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t go too deep into the presentation layer and the DTO pattern. We want
    to remind you, though, to be cautious about the view space as well since there
    are more attention points than simply *persistence* – one example being visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Layers, layers, and more layers – sometimes, they’re excellent allies helping
    split responsibility, reducing and centralizing the development error risks, and
    facilitating the adoption of the single responsibility principle from SOLID. Eventually,
    too many layers can become counterproductive and increase the code design’s complexity.
    When should a new layer be added or removed? The answer will be hidden under each
    individual application’s contextual challenges, technical needs, and business
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Through a journey highlighted with code demonstrations, we explored several
    patterns, from the unstructured and zero-layer application design to the multiple
    types of multi-tier design adoption and business-oriented simplification techniques.
    On this journey, we learned about the benefits and drawbacks of using layers to
    abstract the database from the client in a software application.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we explicitly stated that there is more to the persistence layer
    for us developers and architects to care about, and that the way we’ll visualize
    and interact with the data on the layer view should also be taken into consideration
    as a layer that can be impacted by how we design our persistence solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the application’s requirements and context is the key to determining
    the best patterns to apply to your database integration, and the best cost-benefit
    level of abstraction and isolation. With that, we’re ready to understand and explore
    the enterprise Java standards made available through Jakarta EE and MicroProfile
    specifications. In the next chapter, we’ll introduce you to two persistence-related
    specifications that can address multiple challenges mentioned so far, and delve
    into the power of exploring the spaces of enterprise and microservices Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Jakarta EE, MicroProfile, Modern Persistence Technologies, and Their
    Trade-Offs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section of the book, we explore the intersection of Jakarta EE, MicroProfile,
    and modern persistence technologies. We dive into the trade-offs associated with
    different approaches to persistence, providing valuable insights and practical
    guidance for developers navigating the dynamic landscape of Java persistence.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B19375_05.xhtml#_idTextAnchor093)*, Jakarta EE and JPA: State
    of Affairs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19375_06.xhtml#_idTextAnchor122)*, NoSQL in Java Demystified:
    One API to Rule Them All*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19375_07.xhtml#_idTextAnchor138)*, The Missing Guide for jOOQ
    Adoption*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19375_08.xhtml#_idTextAnchor151)*, Ultra-Fast In-Memory Persistence
    with Eclipse Store*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
