<html><head></head><body>
<div id="_idContainer058">
<h1 class="chapter-number" id="_idParaDest-118"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-119"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.2.1">Building the Application Hexagon</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Once we have a foundation provided by the Domain hexagon, we can build the remaining part of the system on top of this. </span><span class="koboSpan" id="kobo.3.2">It’s time to think about how the system will coordinate the handling of different data and behaviors to fulfill the needs of different actors, and we will explore this through a discussion of use case examples. </span><span class="koboSpan" id="kobo.3.3">To accomplish this, we need to create the Application hexagon on top of the foundation defined by the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">Domain hexagon.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">To continue building the modular structure initiated in the previous chapter, where we configured the Domain </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.6.1">hexagon as a </span><strong class="bold"><span class="koboSpan" id="kobo.7.1">Java</span></strong><span class="koboSpan" id="kobo.8.1"> module, we will continue to use the modular approach by defining the Application hexagon as the second Java module of our </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">hexagonal system.</span></span><a id="_idTextAnchor154"/></p>
<p><span class="koboSpan" id="kobo.10.1">In order to provide a better view of the system’s capabilities, one recommended approach is to use </span><strong class="bold"><span class="koboSpan" id="kobo.11.1">Cucumber</span></strong><span class="koboSpan" id="kobo.12.1">, which is a </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.13.1">well-known behavior-driven development technology that uses concepts such as features and scenarios to describe the system’s behavior. </span><span class="koboSpan" id="kobo.13.2">So, for the Application hexagon, we’ll use Cucumber to help us shape the hexagonal system’s </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">use cases.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">Cucumber enables us to test the Application hexagon and explain the structure of use cases in a </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">non-technical way.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">In this chapter, we’ll learn about the </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.19.1">Bootstrapping the </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Application hexago</span><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.21.1">n</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Defining </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">use cases</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">Implementing use cases with </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">input ports</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">Testing the </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Application hexagon</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.28.1">By the end of this chapter, you’ll know how to utilize use cases as a blueprint to drive the development of the entire Application hexagon. </span><span class="koboSpan" id="kobo.28.2">By expressing the user intent through use cases and deriving objects from them to implement ports, you’ll be able to develop the code to accomplish use case goals in a </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">structured way.</span></span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.30.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.31.1">To compile </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.32.1">and run the code examples presented in this chapter, you </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.33.1">need the latest </span><strong class="bold"><span class="koboSpan" id="kobo.34.1">Java SE Development Kit</span></strong><span class="koboSpan" id="kobo.35.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.36.1">JDK</span></strong><span class="koboSpan" id="kobo.37.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.38.1">Maven 3.8</span></strong><span class="koboSpan" id="kobo.39.1"> installed on </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.40.1">your computer. </span><span class="koboSpan" id="kobo.40.2">They are all available for the </span><strong class="bold"><span class="koboSpan" id="kobo.41.1">Linux</span></strong><span class="koboSpan" id="kobo.42.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">Mac</span></strong><span class="koboSpan" id="kobo.44.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.45.1">Windows</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.46.1">operating systems.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">You can find the code files for this chapter on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">at </span></span><a href="https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter07"><span class="No-Break"><span class="koboSpan" id="kobo.49.1">https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter07</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.50.1">.</span></span></p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.51.1">Bootstrapping the Application hexagon</span></h1>
<p><span class="koboSpan" id="kobo.52.1">The Application hexagon orchestrates internal requests through the Domain hexagon and external requests through the Framework hexagon. </span><span class="koboSpan" id="kobo.52.2">We construct the system’s features based on the domain</span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.53.1"> model provided by the Domain hexagon, with ports and use cases. </span><span class="koboSpan" id="kobo.53.2">In the Application hexagon, we don’t specify any constraint or business rule. </span><span class="koboSpan" id="kobo.53.3">Instead, our aim for the Application hexagon is to define and control the data flow in the </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">hexagonal system.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">To continue developing the topology and inventory system, we have to bootstrap the Application hexagon as a Maven and Java module. </span><span class="koboSpan" id="kobo.55.2">Let’s start with the </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">Maven configuration:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.57.1">
mvn archetype:generate \
  -DarchetypeGroupId=de.rieckpil.archetypes  \
  -DarchetypeArtifactId=testing-toolkit \
  -DarchetypeVersion=1.0.0 \
  -DgroupId=dev.davivieira \
  -DartifactId=application \
  -Dversion=1.0-SNAPSHOT \
  -Dpackage=dev.davivieira.topologyinventory.application \
  -DinteractiveMode=false</span></pre> <p><span class="koboSpan" id="kobo.58.1">The preceding command creates the basic Maven project’s structure for the Application hexagon. </span><span class="koboSpan" id="kobo.58.2">Here, we set the module’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">groupId</span></strong><span class="koboSpan" id="kobo.60.1"> coordinate as </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">dev.davivieira</span></strong><span class="koboSpan" id="kobo.62.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">version</span></strong><span class="koboSpan" id="kobo.64.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">1.0-SNAPSHOT</span></strong><span class="koboSpan" id="kobo.66.1">, the same ones used for the parent project. </span><span class="koboSpan" id="kobo.66.2">We set </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">artifactId</span></strong><span class="koboSpan" id="kobo.68.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">application</span></strong><span class="koboSpan" id="kobo.70.1"> to uniquely identify this module in the </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">Maven project.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">You need to run the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">mvn</span></strong><span class="koboSpan" id="kobo.74.1"> command in the Maven project root directory by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">following commands:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.76.1">
$ cd topology-inventory
$ mvn archetype:generate ...</span></pre> <p><span class="koboSpan" id="kobo.77.1">This creates the skeleton</span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.78.1"> project structure for the Application hexagon. </span><span class="koboSpan" id="kobo.78.2">The directory structure will be like the </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<span class="koboSpan" id="kobo.80.1"><img alt="Figure 7.1 – The directory structure of the Application hexagon" src="image/B19777_07_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.81.1">Figure 7.1 – The directory structure of the Application hexagon</span></p>
<p><span class="koboSpan" id="kobo.82.1">The root </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">pom.xml</span></strong><span class="koboSpan" id="kobo.84.1"> file should contain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">application</span></strong><span class="koboSpan" id="kobo.86.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">domain</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.88.1">Maven modules:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.89.1">
&lt;modules&gt;
    &lt;module&gt;domain&lt;/module&gt;
    &lt;module&gt;application&lt;/module&gt;
&lt;/modules&gt;</span></pre> <p><span class="koboSpan" id="kobo.90.1">Following the Maven module project creation, we need to configure the Application hexagon as a Java module by creating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">module</span></strong><span class="koboSpan" id="kobo.92.1"> descriptor file </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">application/src/java/module-info.java</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.96.1">
module application {
    requires domain;
    requires static lombok;
}</span></pre> <p><span class="koboSpan" id="kobo.97.1">Note the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">requires</span></strong><span class="koboSpan" id="kobo.99.1"> entry – it states that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">application</span></strong><span class="koboSpan" id="kobo.101.1"> module depends on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">domain</span></strong><span class="koboSpan" id="kobo.103.1"> module. </span><span class="koboSpan" id="kobo.103.2">We need</span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.104.1"> to add the Domain hexagon dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">application/pom.xml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.108.1">
&lt;dependency&gt;
    groupId&gt;dev.davivieira&lt;/groupId&gt;
    &lt;artifactId&gt;domain&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</span></pre> <p><span class="koboSpan" id="kobo.109.1">The Maven coordinates </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">groupId</span></strong><span class="koboSpan" id="kobo.111.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">artifactId</span></strong><span class="koboSpan" id="kobo.113.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">version</span></strong><span class="koboSpan" id="kobo.115.1"> specify the correct parameters to fetch the Domain hexagon’s </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">Maven module.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">Because we’ll utilize Cucumber to provide a written description and also test our use cases, we need to add its dependencies </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">application/pom.xml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.121.1">
&lt;dependency&gt;
    &lt;groupId&gt;io.cucumber&lt;/groupId&gt;
    &lt;artifactId&gt;cucumber-java&lt;/artifactId&gt;
    &lt;version&gt;6.10.4&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.cucumber&lt;/groupId&gt;
    &lt;artifactId&gt;cucumber-junit&lt;/artifactId&gt;
    &lt;version&gt;6.10.4&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.cucumber&lt;/groupId&gt;
    &lt;artifactId&gt;cucumber-picocontainer&lt;/artifactId&gt;
    &lt;version&gt;6.10.4&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</span></pre> <p><span class="koboSpan" id="kobo.122.1">As stated in this chapter’s introduction, we’ll use Cucumber to structure and test use cases. </span><span class="koboSpan" id="kobo.122.2">The Maven dependencies</span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.123.1"> declared in the previous code examples are required to enable Cucumber in the </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">Application hexagon.</span></span></p>
<p><span class="koboSpan" id="kobo.125.1">Once the Application hexagon’s Maven module and Java module are properly configured for the topology and inventory system, we can move on and start defining use cases for </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">the system.</span></span></p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.127.1">Defining use cases</span></h1>
<p><span class="koboSpan" id="kobo.128.1">The topology </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.129.1">and inventory system allows users to manage network resources such as routers, switches, and networks. </span><span class="koboSpan" id="kobo.129.2">To enable this management, we created a domain model in the previous chapter that represents the relationship between those resources. </span><span class="koboSpan" id="kobo.129.3">What we have to do now is construct the system’s features in terms of the domain model. </span><span class="koboSpan" id="kobo.129.4">These features represent user intent when interacting with </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">To make it possible to express use cases in both written and code form, we use Cucumber, a valuable tool to enable non-technical people to grasp the use cases that exist in </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">By relying on Cucumber concepts such as features and scenarios, we can create use case descriptions that are easy to follow. </span><span class="koboSpan" id="kobo.133.2">The use case descriptions that are shaped using Cucumber can serve as references to develop use </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">case interfaces.</span></span></p>
<p><span class="koboSpan" id="kobo.135.1">Before creating the use case interfaces for the topology and inventory system, we first need to structure the use cases in feature files consumed by Cucumber. </span><span class="koboSpan" id="kobo.135.2">Feature files are where we’ll describe a sequence of written statements that define the </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.136.1">use case. </span><span class="koboSpan" id="kobo.136.2">This same written description is then used while implementing the classes to test the </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">use case.</span></span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.138.1">Creating written descriptions for router management use cases</span></h2>
<p><span class="koboSpan" id="kobo.139.1">To get </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.140.1">started, let’s create</span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.141.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">RouterAdd.feature</span></strong><span class="koboSpan" id="kobo.143.1"> file, which describes the use case related to adding routers to </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">the system:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.145.1">@RouterAdd</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.146.1">Feature</span></strong><span class="koboSpan" id="kobo.147.1">: Can I add an edge router to a core router?
</span><span class="koboSpan" id="kobo.147.2">  </span><strong class="bold"><span class="koboSpan" id="kobo.148.1">Scenario</span></strong><span class="koboSpan" id="kobo.149.1">: Adding an edge router to a core router
    </span><strong class="bold"><span class="koboSpan" id="kobo.150.1">Given</span></strong><span class="koboSpan" id="kobo.151.1"> I have an edge router
    </span><strong class="bold"><span class="koboSpan" id="kobo.152.1">And</span></strong><span class="koboSpan" id="kobo.153.1"> I have a core router
    </span><strong class="bold"><span class="koboSpan" id="kobo.154.1">Then</span></strong><span class="koboSpan" id="kobo.155.1"> I add an edge router to a core router
  </span><strong class="bold"><span class="koboSpan" id="kobo.156.1">Scenario</span></strong><span class="koboSpan" id="kobo.157.1">: Adding a core router to another core router
    </span><strong class="bold"><span class="koboSpan" id="kobo.158.1">Given</span></strong><span class="koboSpan" id="kobo.159.1"> I have a core router
    </span><strong class="bold"><span class="koboSpan" id="kobo.160.1">And</span></strong><span class="koboSpan" id="kobo.161.1"> I have another core router
    </span><strong class="bold"><span class="koboSpan" id="kobo.162.1">Then</span></strong><span class="koboSpan" id="kobo.163.1"> I add this core router to the core router</span></pre> <p><span class="koboSpan" id="kobo.164.1">This feature file describes two scenarios – the first is when a user wants to add an edge router to a core router; the second is when the user wants to add a core router to another </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">core router.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">After that, we have the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">RouterCreate.feature</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.168.1"> file:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.169.1">@RouterCreate</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.170.1">Feature</span></strong><span class="koboSpan" id="kobo.171.1">: Can I create a new router?
</span><span class="koboSpan" id="kobo.171.2">  </span><strong class="bold"><span class="koboSpan" id="kobo.172.1">Scenario</span></strong><span class="koboSpan" id="kobo.173.1">: Creating a new core router
    </span><strong class="bold"><span class="koboSpan" id="kobo.174.1">Given</span></strong><span class="koboSpan" id="kobo.175.1"> I provide all required data to create a core
          router
    </span><strong class="bold"><span class="koboSpan" id="kobo.176.1">Then</span></strong><span class="koboSpan" id="kobo.177.1"> A new core router is created
  </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">Scenario</span></strong><span class="koboSpan" id="kobo.179.1">: Creating a new edge router
    </span><strong class="bold"><span class="koboSpan" id="kobo.180.1">Given</span></strong><span class="koboSpan" id="kobo.181.1"> I provide all required data to create an edge
      router
    </span><strong class="bold"><span class="koboSpan" id="kobo.182.1">Then</span></strong><span class="koboSpan" id="kobo.183.1"> A new edge router is created</span></pre> <p><span class="koboSpan" id="kobo.184.1">Here, we have </span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.185.1">two scenarios describing the creation of both</span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.186.1"> core and </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">edge routers.</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">Finally, there is the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">RouterRemove.feature</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.190.1"> file:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.191.1">@RouterRemove</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.192.1">Feature</span></strong><span class="koboSpan" id="kobo.193.1">: Can I remove routers?
</span><span class="koboSpan" id="kobo.193.2">  </span><strong class="bold"><span class="koboSpan" id="kobo.194.1">Scenario</span></strong><span class="koboSpan" id="kobo.195.1">: Removing an edge router from a core router
    </span><strong class="bold"><span class="koboSpan" id="kobo.196.1">Given</span></strong><span class="koboSpan" id="kobo.197.1"> The core router has at least one edge
          router connected to it
    </span><strong class="bold"><span class="koboSpan" id="kobo.198.1">And</span></strong><span class="koboSpan" id="kobo.199.1"> The switch has no networks attached to it
    </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">And</span></strong><span class="koboSpan" id="kobo.201.1"> The edge router has no switches attached to it
    </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">Then</span></strong><span class="koboSpan" id="kobo.203.1"> I remove the edge router from the core router
  </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">Scenario</span></strong><span class="koboSpan" id="kobo.205.1">: Removing a core router from another core router
    </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">Given</span></strong><span class="koboSpan" id="kobo.207.1"> The core router has at least one core router
          connected to it
    </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">And</span></strong><span class="koboSpan" id="kobo.209.1"> The core router has no other routers connected to
        it
    </span><strong class="bold"><span class="koboSpan" id="kobo.210.1">Then</span></strong><span class="koboSpan" id="kobo.211.1"> I remove the core router from another core router</span></pre> <p><span class="koboSpan" id="kobo.212.1">For each of the two scenarios described, we define a specific set of constraints to allow the removal of the router. </span><span class="koboSpan" id="kobo.212.2">Once we have Cucumber scenarios describing the supported behaviors regarding router </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.213.1">management, we can define the use case interface that will allow the implementation</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.214.1"> of the operations. </span><span class="koboSpan" id="kobo.214.2">These operations will enable </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">such behaviors.</span></span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.216.1">Defining the use case interface for router management</span></h2>
<p><span class="koboSpan" id="kobo.217.1">A good use case interface for router</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.218.1"> management should contain</span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.219.1"> the operations that allow the system to fulfill the scenarios described by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">RouterAdd.feature</span></strong><span class="koboSpan" id="kobo.221.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">RouterCreate.feature</span></strong><span class="koboSpan" id="kobo.223.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">RouterRemove.feature</span></strong><span class="koboSpan" id="kobo.225.1"> files. </span><span class="koboSpan" id="kobo.225.2">The following use case interface is defined in reference to the scenarios we described in the Cucumber </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">feature files:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.227.1">
package dev.davivieira.topologyinventory.
</span><span class="koboSpan" id="kobo.227.2">  application.usecases;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.227.3">  entity.CoreRouter;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.227.4">  entity.Router;
import dev.davivieira.topologyinventory.domain.vo.IP;
import dev.davivieira.topologyinventory.domain.vo.Id;
import dev.davivieira.topologyinventory.domain.vo.Location;
import dev.davivieira.topologyinventory.domain.vo.Model;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.227.5">  vo.RouterType;
import dev.davivieira.topologyinventory.domain.vo.Vendor;
public interface RouterManagementUseCase {
    Router createRouter(
            Vendor vendor,
            Model model,
            IP ip,
            Location location,
            RouterType routerType);
    CoreRouter addRouterToCoreRouter(
            Router router, CoreRouter coreRouter);
    Router removeRouterFromCoreRouter(
            Router router, CoreRouter coreRouter);
    Router retrieveRouter(Id id);
    Router persistRouter(Router router);
}</span></pre> <p><span class="koboSpan" id="kobo.228.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">createRouter</span></strong><span class="koboSpan" id="kobo.230.1"> method is based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">RouterCreate.feature</span></strong><span class="koboSpan" id="kobo.232.1"> Cucumber file. </span><span class="koboSpan" id="kobo.232.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">addRouterToCoreRouter</span></strong><span class="koboSpan" id="kobo.234.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">removeRouterFromCoreRouter</span></strong><span class="koboSpan" id="kobo.236.1"> methods are for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">RouterAdd.feature</span></strong><span class="koboSpan" id="kobo.238.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">RouterRemove.feature</span></strong><span class="koboSpan" id="kobo.240.1"> files, respectively. </span><span class="koboSpan" id="kobo.240.2">Now, let’s move on to creating the written descriptions</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.241.1"> for </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.242.1">the switch management </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">use cases.</span></span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.244.1">Creating written descriptions for switch management use cases</span></h2>
<p><span class="koboSpan" id="kobo.245.1">We will</span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.246.1"> start by </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.247.1">creating the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">SwitchAdd.feature</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.249.1"> file:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.250.1">@SwitchAdd</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.251.1">Feature</span></strong><span class="koboSpan" id="kobo.252.1">: Can I add a switch to an edge router?
</span><span class="koboSpan" id="kobo.252.2">  </span><strong class="bold"><span class="koboSpan" id="kobo.253.1">Scenario</span></strong><span class="koboSpan" id="kobo.254.1">: Adding a switch to an edge router
    </span><strong class="bold"><span class="koboSpan" id="kobo.255.1">Given</span></strong><span class="koboSpan" id="kobo.256.1"> I provide a switch
    </span><strong class="bold"><span class="koboSpan" id="kobo.257.1">Then</span></strong><span class="koboSpan" id="kobo.258.1"> I add the switch to the edge router</span></pre> <p><span class="koboSpan" id="kobo.259.1">This is a very straightforward use case scenario. </span><span class="koboSpan" id="kobo.259.2">Given that we provide a valid switch, we can add it to an edge router. </span><span class="koboSpan" id="kobo.259.3">There is no mention of the core routers because they are not supposed to receive </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">switch connections.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">Then, we create the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">SwitchCreate.feature</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.263.1"> file:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.264.1">@SwitchCreate</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.265.1">Feature</span></strong><span class="koboSpan" id="kobo.266.1">: Can I create new switches?
</span><span class="koboSpan" id="kobo.266.2">  </span><strong class="bold"><span class="koboSpan" id="kobo.267.1">Scenario</span></strong><span class="koboSpan" id="kobo.268.1">: Creating a new switch
    </span><strong class="bold"><span class="koboSpan" id="kobo.269.1">Given</span></strong><span class="koboSpan" id="kobo.270.1"> I provide all required data to create a switch
    </span><strong class="bold"><span class="koboSpan" id="kobo.271.1">Then</span></strong><span class="koboSpan" id="kobo.272.1"> A new switch is created</span></pre> <p><span class="koboSpan" id="kobo.273.1">This scenario is similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">RouterCreate.feature</span></strong><span class="koboSpan" id="kobo.275.1"> file, in the sense that if we provide all the required data, a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">Switch</span></strong><span class="koboSpan" id="kobo.277.1"> object </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">is created.</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">Finally, we create the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">SwitchRemove.feature</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.281.1"> file:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.282.1">@SwitchRemove</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.283.1">Feature</span></strong><span class="koboSpan" id="kobo.284.1">: Can I remove a switch from an edge router?
</span><span class="koboSpan" id="kobo.284.2">  </span><strong class="bold"><span class="koboSpan" id="kobo.285.1">Scenario</span></strong><span class="koboSpan" id="kobo.286.1">: Removing a switch from an edge router
    </span><strong class="bold"><span class="koboSpan" id="kobo.287.1">Given</span></strong><span class="koboSpan" id="kobo.288.1"> I know the switch I want to remove
    </span><strong class="bold"><span class="koboSpan" id="kobo.289.1">And</span></strong><span class="koboSpan" id="kobo.290.1"> The switch has no networks
    </span><strong class="bold"><span class="koboSpan" id="kobo.291.1">Then</span></strong><span class="koboSpan" id="kobo.292.1"> I remove the switch from the edge router</span></pre> <p><span class="koboSpan" id="kobo.293.1">So, to remove a switch from an edge router, we have to make sure the switch has no networks connected to it. </span><span class="koboSpan" id="kobo.293.2">This is what the preceding </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">scenario asserts.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">Now, let’s define the </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.296.1">use case interface for switch management, based</span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.297.1"> on the Cucumber scenarios we </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">just created.</span></span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.299.1">Defining the use case interface for switch management</span></h2>
<p><span class="koboSpan" id="kobo.300.1">As we did </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.301.1">with routers, we will do the same for switches by creating</span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.302.1"> a use case interface to define the switch management operations, based on the written descriptions we made previously in our Cucumber </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">feature files:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.304.1">
package dev.davivieira.topologyinventory.
</span><span class="koboSpan" id="kobo.304.2">  application.usecases;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.304.3">  entity.EdgeRouter;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.304.4">  entity.Switch;
import dev.davivieira.topologyinventory.domain.vo.IP;
import dev.davivieira.topologyinventory.domain.vo.Location;
import dev.davivieira.topologyinventory.domain.vo.Model;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.304.5">  vo.SwitchType;
import dev.davivieira.topologyinventory.domain.vo.Vendor;
public interface SwitchManagementUseCase {
    Switch createSwitch(
            Vendor vendor,
            Model model,
            IP ip,
            Location location,
            SwitchType switchType
            );
    EdgeRouter addSwitchToEdgeRouter(Switch networkSwitch,
    EdgeRouter edgeRouter);
    EdgeRouter removeSwitchFromEdgeRouter(Switch
    networkSwitch,
    EdgeRouter edgeRouter);
}</span></pre> <p><span class="koboSpan" id="kobo.305.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">createSwitch</span></strong><span class="koboSpan" id="kobo.307.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">addSwitchToEdgeRouter</span></strong><span class="koboSpan" id="kobo.309.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">removeSwitchFromEdgeRouter</span></strong><span class="koboSpan" id="kobo.311.1"> methods correspond to the Cucumber </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">SwitchCreate.feature</span></strong><span class="koboSpan" id="kobo.313.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">SwitchAdd.feature</span></strong><span class="koboSpan" id="kobo.315.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">SwitchRemove.feature</span></strong><span class="koboSpan" id="kobo.317.1"> feature files, respectively. </span><span class="koboSpan" id="kobo.317.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">createSwitch</span></strong><span class="koboSpan" id="kobo.319.1"> method receives all the required parameters to construct a </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">Switch</span></strong><span class="koboSpan" id="kobo.321.1"> object. </span><span class="koboSpan" id="kobo.321.2">Both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">addSwitchToEdgeRouter</span></strong><span class="koboSpan" id="kobo.323.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">removeSwitchFromEdgeRouter</span></strong><span class="koboSpan" id="kobo.325.1"> methods receive a switch and an edge router as </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.326.1">parameters, and both</span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.327.1"> methods </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">return </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">EdgeRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.331.1">To finish the definition of use cases, we still need to create the Cucumber feature files and interfaces for networks. </span><span class="koboSpan" id="kobo.331.2">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">do that!</span></span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.333.1">Creating written descriptions for network management use cases</span></h2>
<p><span class="koboSpan" id="kobo.334.1">For networks, we will </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.335.1">continue to follow the same pattern of the add, create, and remove operations previously used on routers</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.336.1"> and switches. </span><span class="koboSpan" id="kobo.336.2">Let’s start with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">NetworkAdd.feature</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.338.1"> file:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.339.1">@NetworkAdd</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.340.1">Feature</span></strong><span class="koboSpan" id="kobo.341.1">: Can I add a network to a switch?
</span><span class="koboSpan" id="kobo.341.2">  </span><strong class="bold"><span class="koboSpan" id="kobo.342.1">Scenario</span></strong><span class="koboSpan" id="kobo.343.1">: Adding a network to a switch
    </span><strong class="bold"><span class="koboSpan" id="kobo.344.1">Given</span></strong><span class="koboSpan" id="kobo.345.1"> I have a network
    </span><strong class="bold"><span class="koboSpan" id="kobo.346.1">And</span></strong><span class="koboSpan" id="kobo.347.1"> I have a switch to add a network
    </span><strong class="bold"><span class="koboSpan" id="kobo.348.1">Then</span></strong><span class="koboSpan" id="kobo.349.1"> I add the network to the switch</span></pre> <p><span class="koboSpan" id="kobo.350.1">This is a simple scenario to ensure that we’re able to add networks to </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">a switch.</span></span></p>
<p><span class="koboSpan" id="kobo.352.1">Following the addition of networks, we have the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">NetworkCreate.feature</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.354.1"> file:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.355.1">@NetworkCreate</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.356.1">Feature</span></strong><span class="koboSpan" id="kobo.357.1">: Can I create new networks?
</span><span class="koboSpan" id="kobo.357.2">  </span><strong class="bold"><span class="koboSpan" id="kobo.358.1">Scenario</span></strong><span class="koboSpan" id="kobo.359.1">: Creating a new network
    </span><strong class="bold"><span class="koboSpan" id="kobo.360.1">Given</span></strong><span class="koboSpan" id="kobo.361.1"> I provide all required data to create a network
    </span><strong class="bold"><span class="koboSpan" id="kobo.362.1">Then</span></strong><span class="koboSpan" id="kobo.363.1"> A new network is created</span></pre> <p><span class="koboSpan" id="kobo.364.1">For network creation, as we did with routers and switches, we make sure that all required data is properly provided so that a new network </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">is created.</span></span></p>
<p><span class="koboSpan" id="kobo.366.1">Finally, we have the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">NetworkRemove.feature</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.368.1"> file:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.369.1">@NetworkRemove</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.370.1">Feature</span></strong><span class="koboSpan" id="kobo.371.1">: Can I remove a network from a switch?
</span><span class="koboSpan" id="kobo.371.2">  </span><strong class="bold"><span class="koboSpan" id="kobo.372.1">Scenario</span></strong><span class="koboSpan" id="kobo.373.1">: Removing a network from a switch
    </span><strong class="bold"><span class="koboSpan" id="kobo.374.1">Given</span></strong><span class="koboSpan" id="kobo.375.1"> I know the network I want to remove
    </span><strong class="bold"><span class="koboSpan" id="kobo.376.1">And</span></strong><span class="koboSpan" id="kobo.377.1"> I have a switch to remove a network
    </span><strong class="bold"><span class="koboSpan" id="kobo.378.1">Then</span></strong><span class="koboSpan" id="kobo.379.1"> I remove the network from the switch</span></pre> <p><span class="koboSpan" id="kobo.380.1">It follows the same</span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.381.1"> structure</span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.382.1"> as the adding scenario but checks the system’s capability to remove networks from </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">a switch.</span></span></p>
<p><span class="koboSpan" id="kobo.384.1">Now that we have Cucumber scenarios for network management, let’s define a use case interface to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">such scenarios.</span></span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.386.1">Defining the use case interface for network management</span></h2>
<p><span class="koboSpan" id="kobo.387.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">NetworkManagementUseCase</span></strong><span class="koboSpan" id="kobo.389.1"> interface</span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.390.1"> follows</span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.391.1"> the same structure as previously defined interfaces, where we declared methods for creation, addition, and </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">removal operations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.393.1">
package dev.davivieira.topologyinventory.
</span><span class="koboSpan" id="kobo.393.2">  application.usecases;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.393.3">  entity.Switch;
import dev.davivieira.topologyinventory.domain.vo.IP;
import dev.davivieira.topologyinventory.domain.vo.Network;
public interface NetworkManagementUseCase {
    Network createNetwork(
            IP networkAddress,
            String networkName,
            int networkCidr);
    Switch addNetworkToSwitch(Network network,
    Switch networkSwitch);
    Switch removeNetworkFromSwitch(Network network,
    Switch networkSwitch);
}</span></pre> <p><span class="koboSpan" id="kobo.394.1">Here, again, we declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">createNetwork</span></strong><span class="koboSpan" id="kobo.396.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">addNetworkToSwitch</span></strong><span class="koboSpan" id="kobo.398.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">removeNetworkFromSwitch</span></strong><span class="koboSpan" id="kobo.400.1"> methods based on the written descriptions from the Cucumber </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.401.1">feature files. </span><span class="koboSpan" id="kobo.401.2">These three method declarations in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">NetworkManagementUseCase</span></strong><span class="koboSpan" id="kobo.403.1"> interface represent the first step in implementing the capabilities that will </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.404.1">allow us to manage networks, as described in the scenarios we created </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">using Cucumber.</span></span></p>
<p><span class="koboSpan" id="kobo.406.1">In this section, we learned about an approach to start use case development by first describing the behaviors and scenarios expected from the system. </span><span class="koboSpan" id="kobo.406.2">Once the scenarios were thoroughly explored, we then utilized them as a reference to define the use case interfaces that will allow the system to perform the behaviors described in </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">the scenarios.</span></span></p>
<p><span class="koboSpan" id="kobo.408.1">Now that</span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.409.1"> we </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.410.1">have all the use case interfaces to manage routers, switches, and networks, we can provide an input port implementation for each of these use </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">case interfaces.</span></span></p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.412.1">Implementing use cases with input ports</span></h1>
<p><span class="koboSpan" id="kobo.413.1">Input ports are </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.414.1">a central element of the Application hexagon. </span><span class="koboSpan" id="kobo.414.2">They play a crucial integration role because it is through them that we bridge the gap between</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.415.1"> the Domain and Framework hexagons. </span><span class="koboSpan" id="kobo.415.2">We can get external data from an output port and forward that data to the Domain hexagon by using output ports. </span><span class="koboSpan" id="kobo.415.3">Once the Domain hexagon’s business logic is applied to the data, the Application hexagon moves that data downstream until it reaches one of the output adapters in the </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">Framework hexagon.</span></span></p>
<p><span class="koboSpan" id="kobo.417.1">When creating the Application hexagon, you’re able to define output port interfaces, but because there is no Framework hexagon yet to provide an output adapter as an implementation, you’re not able to use these </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">output ports.</span></span></p>
<p><span class="koboSpan" id="kobo.419.1">You’ll see output port declarations in the following code, but they are not being used yet. </span><span class="koboSpan" id="kobo.419.2">We’re just preparing the Application hexagon to work when we have the Framework hexagon to provide </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">the implementations.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">The following steps will help us to implement use cases with </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">input ports:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.423.1">We start by creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">RouterManagementOutputPort</span></strong><span class="koboSpan" id="kobo.425.1"> field in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">RouterManagementInputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.427.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.428.1">
package dev.davivieira.topologyinventory.application.
</span><span class="koboSpan" id="kobo.428.2">  ports.input;
import dev.davivieira.topologyinventory.application.
</span><span class="koboSpan" id="kobo.428.3">  ports.output.RouterManagementOutputPort;
import dev.davivieira.topologyinventory.application.
</span><span class="koboSpan" id="kobo.428.4">  usecases.RouterManagementUseCase;
import dev.davivieira.topologyinventory.domain.entity.
</span><span class="koboSpan" id="kobo.428.5">  CoreRouter;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.428.6">  entity.Router;
import dev.davivieira.topologyinventory.domain.entity.
</span><span class="koboSpan" id="kobo.428.7">  factory.RouterFactory;
import dev.davivieira.topologyinventory.domain.vo.IP;
import dev.davivieira.topologyinventory.domain.vo.Id;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.428.8">  vo.Location;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.428.9">  vo.Model;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.428.10">  vo.RouterType;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.428.11">  vo.Vendor;
import lombok.NoArgsConstructor;
@NoArgsConstructor
public class RouterManagementInputPort implements
  RouterManagementUseCase {
    RouterManagementOutputPort
    routerManagementOutputPort;
    /** Code omitted
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.429.1">We created this </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">RouterManagementOutputPort</span></strong><span class="koboSpan" id="kobo.431.1"> interface field because we don’t want to depend</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.432.1"> directly on its </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.433.1">implementation. </span><span class="koboSpan" id="kobo.433.2">Remember, output adapters implement </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">output ports.</span></span></p></li> <li><span class="koboSpan" id="kobo.435.1">Next, we implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">createRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.437.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.438.1">
@Override
public Router createRouter(Vendor vendor,
                           Model model,
                           IP ip,
                           Location location,
                           RouterType routerType) {
    return RouterFactory.getRouter(
           vendor,model,ip,location,routerType);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.439.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">createRouter</span></strong><span class="koboSpan" id="kobo.441.1"> method, we’ll receive all the required parameters to construct a </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">Router</span></strong><span class="koboSpan" id="kobo.443.1"> object. </span><span class="koboSpan" id="kobo.443.2">Object creation is delegated to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">getRouter</span></strong><span class="koboSpan" id="kobo.445.1"> method from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">RouterFactory</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.447.1"> class.</span></span></p></li> <li><span class="koboSpan" id="kobo.448.1">Next, we implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">retrieveRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.450.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.451.1">
@Override
public Router retrieveRouter(Id id) {
    return
      routerManagementOutputPort.retrieveRouter(id);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.452.1">It’s a very straightforward method that </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.453.1">uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">Id</span></strong><span class="koboSpan" id="kobo.455.1"> to obtain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">Router</span></strong><span class="koboSpan" id="kobo.457.1"> objects, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">retrieveRouter</span></strong><span class="koboSpan" id="kobo.459.1"> method</span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.460.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">RouterManagementOutputPort</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.462.1">output port.</span></span></p></li> <li><span class="koboSpan" id="kobo.463.1">Next, we implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">persistRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.465.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.466.1">
@Override
public Router persistRouter(Router router) {
    return
     routerManagementOutputPort.persistRouter(router);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.467.1">To persist a router, we need to pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">Router</span></strong><span class="koboSpan" id="kobo.469.1"> object we want to persist. </span><span class="koboSpan" id="kobo.469.2">This method is generally used after any operation that creates new </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">Router</span></strong><span class="koboSpan" id="kobo.471.1"> objects or causes changes in </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">existing ones.</span></span></p></li> <li><span class="koboSpan" id="kobo.473.1">Next, we implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">addRouterToCoreRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.475.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.476.1">
@Override
public CoreRouter addRouterToCoreRouter(Router router,
  CoreRouter coreRouter) {
    var addedRouter = coreRouter.addRouter(router);
    //persistRouter(addedRouter);
    return addedRouter;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.477.1">To add </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">Router</span></strong><span class="koboSpan" id="kobo.479.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.481.1">, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">addRouter</span></strong><span class="koboSpan" id="kobo.483.1"> method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.485.1">. </span><span class="koboSpan" id="kobo.485.2">We’re not persisting </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">Router</span></strong><span class="koboSpan" id="kobo.487.1"> because we don’t have an adapter to allow us to do that. </span><span class="koboSpan" id="kobo.487.2">So, we just return</span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.488.1"> the added </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">Router</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.490.1"> object.</span></span></p></li> <li><span class="koboSpan" id="kobo.491.1">Finally, we </span><a id="_idIndexMarker538"/><span class="No-Break"><span class="koboSpan" id="kobo.492.1">implement </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">removeRouterFromCoreRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.495.1">
@Override
public Router removeRouterFromCoreRouter(Router rout
  er,CoreRouter coreRouter) {
    var removedRouter =
    coreRouter.removeRouter(router);
    //persistRouter(removedRouter);
    return removedRouter;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.496.1">Again, we use one of the methods present in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">CoreRoute</span></strong><span class="koboSpan" id="kobo.498.1"> class. </span><span class="koboSpan" id="kobo.498.2">Here, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">removeRouter</span></strong><span class="koboSpan" id="kobo.500.1"> method to remove </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">Router</span></strong><span class="koboSpan" id="kobo.502.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.504.1">. </span><span class="koboSpan" id="kobo.504.2">Then, we return </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">removedRouter</span></strong><span class="koboSpan" id="kobo.506.1">, instead of actually removing it from an external </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">data source.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.508.1">The first method we implemented, </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">createRouter</span></strong><span class="koboSpan" id="kobo.510.1">, can produce either core or edge routers. </span><span class="koboSpan" id="kobo.510.2">To accomplish this, we need to provide a factory method directly in the Domain hexagon, in a class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">RouterFactory</span></strong><span class="koboSpan" id="kobo.512.1">. </span><span class="koboSpan" id="kobo.512.2">The following is how we implement this </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">getRouter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.514.1">factory method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.515.1">
public static Router getRouter(Vendor vendor,
                                   Model model,
                                   IP ip,
                                   Location location,
                                   RouterType routerType){
        switch (routerType){
            case CORE → { return CoreRouter.builder().
</span><span class="koboSpan" id="kobo.515.2">                            id(Id.withoutId()).
</span><span class="koboSpan" id="kobo.515.3">                            vendor(vendor).
</span><span class="koboSpan" id="kobo.515.4">                            model(model).
</span><span class="koboSpan" id="kobo.515.5">                            ip(ip).
</span><span class="koboSpan" id="kobo.515.6">                            location(location).
</span><span class="koboSpan" id="kobo.515.7">                            routerType(routerType).
</span><span class="koboSpan" id="kobo.515.8">                            build();
            }
/** Code omitted **/</span></pre> <p><span class="koboSpan" id="kobo.516.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">RouterType</span></strong><span class="koboSpan" id="kobo.518.1"> parameter, which we pass to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">getRouter</span></strong><span class="koboSpan" id="kobo.520.1"> method, has only two possible values – </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">CORE</span></strong><span class="koboSpan" id="kobo.522.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">EDGE</span></strong><span class="koboSpan" id="kobo.524.1">. </span><span class="koboSpan" id="kobo.524.2">The switch looks into one of these two values to determine which </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">builder</span></strong><span class="koboSpan" id="kobo.526.1"> method to use. </span><span class="koboSpan" id="kobo.526.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">RouterType</span></strong><span class="koboSpan" id="kobo.528.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">CORE</span></strong><span class="koboSpan" id="kobo.530.1">, then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">builder</span></strong><span class="koboSpan" id="kobo.532.1"> method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.534.1"> is called. </span><span class="koboSpan" id="kobo.534.2">Otherwise, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">builder</span></strong> <a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.536.1">method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.538.1"> is used, as</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.539.1"> we can </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">see here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.541.1">
case EDGE → {  return EdgeRouter.builder().
</span><span class="koboSpan" id="kobo.541.2">                 id(Id.withoutId()).
</span><span class="koboSpan" id="kobo.541.3">                 vendor(vendor).
</span><span class="koboSpan" id="kobo.541.4">                 model(model).
</span><span class="koboSpan" id="kobo.541.5">                 ip(ip).
</span><span class="koboSpan" id="kobo.541.6">                 location(location).
</span><span class="koboSpan" id="kobo.541.7">                 routerType(rou</span><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.542.1">terType).
</span><span class="koboSpan" id="kobo.542.2">                 build();
}
default → throw new UnsupportedOperationException(
    "No valid router type informed");</span></pre> <p><span class="koboSpan" id="kobo.543.1">If neither </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">CORE</span></strong><span class="koboSpan" id="kobo.545.1"> nor </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">EDGE</span></strong><span class="koboSpan" id="kobo.547.1"> is informed, the default behavior is to throw an exception saying that no </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.548.1">valid </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.549.1">router type </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">was informed.</span></span></p>
<p><span class="koboSpan" id="kobo.551.1">Let’s implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">SwitchManagementUseCase</span></strong><span class="koboSpan" id="kobo.553.1"> interface </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">SwitchManagementInputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.557.1">We will start by implementing the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">createSwitch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.559.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.560.1">
package dev.davivieira.topologyinventory.application.
</span><span class="koboSpan" id="kobo.560.2">  ports.input;
import dev.davivieira.topologyinventory.application.
</span><span class="koboSpan" id="kobo.560.3">  usecases.SwitchManagementUseCase;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.560.4">  entity.EdgeRouter;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.560.5">  entity.Switch;
import dev.davivieira.topologyinventory.domain.vo.IP;
import dev.davivieira.topologyinventory.domain.vo.Id;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.560.6">  vo.Location;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.560.7">  vo.Model;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.560.8">  vo.SwitchType;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.560.9">  vo.Vendor;
public class SwitchManagementInputPort implements
  SwitchManagementUseCase {
    @Override
    public Switch createSwitch(
            Vendor vendor,
            Model model,
            IP ip,
            Location location,
            SwitchType switchType) {
        return Switch.builder()
                .id(Id.withoutId())
                .vendor(vendor)
                .model(model)
                .ip(ip)
                .location(location).switchType
                  (switchType).build();
    }
/** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.561.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">createSwitch</span></strong><span class="koboSpan" id="kobo.563.1"> method, we don’t need a factory method to create objects because there</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.564.1"> are no </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">Switch</span></strong><span class="koboSpan" id="kobo.566.1"> object</span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.567.1"> variations as compared to routers. </span><span class="koboSpan" id="kobo.567.2">Instead, we generate </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">Switch</span></strong><span class="koboSpan" id="kobo.569.1"> objects, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">builder</span></strong><span class="koboSpan" id="kobo.571.1"> method directly from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">Switch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.573.1"> class.</span></span></p></li> <li><span class="koboSpan" id="kobo.574.1">Next, we implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">addSwitchToEdgeRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.576.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.577.1">
@Override
public EdgeRouter addSwitchToEdgeRouter(
  Switch networkSwitch, EdgeRouter edgeRouter) {
    edgeRouter.addSwitch(networkSwitch);
    return edgeRouter;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.578.1">Then, we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">addSwitchToEdgeRouter</span></strong><span class="koboSpan" id="kobo.580.1">, which receives </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">Switch</span></strong><span class="koboSpan" id="kobo.582.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.584.1"> as parameters, to add switches to an edge router. </span><span class="koboSpan" id="kobo.584.2">There is no way to persist switches without persisting routers as well. </span><span class="koboSpan" id="kobo.584.3">That’s why we did not put a persistence method here. </span><span class="koboSpan" id="kobo.584.4">By doing that, we enforce all switch persistence operations to occur only when we </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">persist routers.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.586.1">Remember </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.587.1">that </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">Router</span></strong><span class="koboSpan" id="kobo.589.1"> is an aggregate (a cluster of domain objects) that controls the life cycle of other entities and value objects, including </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">Switch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">-type objects.</span></span></p></li> <li><span class="koboSpan" id="kobo.592.1">Finally, we </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.593.1">implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">removeSwitchFromEdgeRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.595.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.596.1">
@Override
public EdgeRouter removeSwitchFromEdgeRouter(
  Switch networkSwitch,EdgeRouter edgeRouter) {
    edgeRouter.removeSwitch(networkSwitch);
    return edgeRouter;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.597.1">The last method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">removeSwitchFromEdgeRouter</span></strong><span class="koboSpan" id="kobo.599.1">, receives the same parameters, </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">Switch</span></strong><span class="koboSpan" id="kobo.601.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.603.1">, and removes switches from edge routers using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">removeSwitch</span></strong><span class="koboSpan" id="kobo.605.1"> method present in an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">EdgeRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.607.1"> instance.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.608.1">Now, let’s see how we can implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">NetworkManagementUseCase</span></strong><span class="koboSpan" id="kobo.610.1"> interface </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">NetworkManagementInputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.614.1">We start by</span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.615.1"> implementing </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.616.1">the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">createNetwork</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.618.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.619.1">
package dev.davivieira.topologyinventory.
</span><span class="koboSpan" id="kobo.619.2">  application.ports.input;
import dev.davivieira.topologyinventory.application.
</span><span class="koboSpan" id="kobo.619.3">  usecases.NetworkManagementUseCase;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.619.4">  entity.Switch;
import dev.davivieira.topologyinventory.domain.vo.IP;
import dev.davivieira.topologyinventory.domain.
</span><span class="koboSpan" id="kobo.619.5">  vo.Network;
import lombok.NoArgsConstructor;
@NoArgsConstructor
public class NetworkManagementInputPort implements
  NetworkManagementUseCase {
    @Override
    public Network createNetwork(
    IP networkAddress, String networkName,
    int networkCidr) {
        return  Network
                .builder()
                .networkAddress(networkAddress)
                .networkName(networkName)
                .networkCidr(networkCidr).build();
    }
/** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.620.1">To create</span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.621.1"> a new network, we use all the</span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.622.1"> received method parameters in conjunction with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">builder</span></strong><span class="koboSpan" id="kobo.624.1"> method from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">Network</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.626.1"> class.</span></span></p></li> <li><span class="koboSpan" id="kobo.627.1">Next, we </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">implement </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">addNetworkToSwitch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.631.1">
@Override
public Switch addNetworkToSwitch(
  Network network, Switch networkSwitch) {
    networkSwitch.addNetworkToSwitch(network);
    return networkSwitch;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.632.1">Here, we receive the </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">Network</span></strong><span class="koboSpan" id="kobo.634.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">Switch</span></strong><span class="koboSpan" id="kobo.636.1"> objects. </span><span class="koboSpan" id="kobo.636.2">Then, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">addNetworkToSwitch</span></strong><span class="koboSpan" id="kobo.638.1"> method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">Switch</span></strong><span class="koboSpan" id="kobo.640.1"> by passing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">Network</span></strong><span class="koboSpan" id="kobo.642.1"> object as a parameter. </span><span class="koboSpan" id="kobo.642.2">Then, we return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">Switch</span></strong><span class="koboSpan" id="kobo.644.1"> object with the added </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">Network</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.646.1"> object.</span></span></p></li> <li><span class="koboSpan" id="kobo.647.1">Finally, we implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">removeNetworkFromSwitch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.649.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.650.1">
@Override
public Switch removeNetworkFromSwitch(
  Network network, Switch networkSwitch) {
    networkSwitch.removeNetworkFromSwitch(network);
    return networkSwitch;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.651.1">We receive the </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">Network</span></strong><span class="koboSpan" id="kobo.653.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">Switch</span></strong><span class="koboSpan" id="kobo.655.1"> objects as parameters, like in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">addNetworkToSwitch</span></strong><span class="koboSpan" id="kobo.657.1"> method. </span><span class="koboSpan" id="kobo.657.2">However, to remove the network from a switch, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">removeNetworkFromSwitch</span></strong><span class="koboSpan" id="kobo.659.1"> from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">Switch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.661.1"> object.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.662.1">That completes implementing input ports </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.663.1">for router, switch, and </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.664.1">network management. </span><span class="koboSpan" id="kobo.664.2">To ensure everything works as expected, let’s create Cucumber tests based on the written use case descriptions and the input ports we </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">just created.</span></span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.666.1">Testing the Application hexagon</span></h2>
<p><span class="koboSpan" id="kobo.667.1">An interesting and useful thing about Cucumber is that we can use the written scenario description</span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.668.1"> provided in the feature file to tailor unit tests. </span><span class="koboSpan" id="kobo.668.2">In addition, these written scenarios provide an easy way to understand and implement the hexagonal system’s use cases. </span><span class="koboSpan" id="kobo.668.3">We’re also laying the groundwork for the development of unit tests in the </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">Application hexagon.</span></span></p>
<p><span class="koboSpan" id="kobo.670.1">So, the tests we’re about to build in this section are a continuation of the written scenario descriptions we created for the router, switch, and network management operations. </span><span class="koboSpan" id="kobo.670.2">Our goal here is to test input port implementations to ensure these ports work as expected when input adapters </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">call them.</span></span></p>
<p><span class="koboSpan" id="kobo.672.1">To get started, we need to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">ApplicationTest</span></strong><span class="koboSpan" id="kobo.674.1"> test class</span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.675.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">enable Cucumber:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.677.1">
package dev.davivieira.topologyinventory.application;
import io.cucumber.junit.Cucumber;
import io.cucumber.junit.CucumberOptions;
import org.junit.runner.RunWith;
@RunWith(Cucumber.class)
@CucumberOptions(
        plugin = {"pretty", "html:target/cucumber-result"}
)
public class ApplicationTest {
}</span></pre> <p><span class="koboSpan" id="kobo.678.1">The important part is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">@RunWith</span></strong><span class="koboSpan" id="kobo.680.1"> annotation, which triggers the initialization of the </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">Cucumber engine.</span></span></p>
<p><span class="koboSpan" id="kobo.682.1">Let’s start by creating tests to check whether the system is capable of </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">adding routers.</span></span></p>
<p><span class="koboSpan" id="kobo.684.1">In the same way that we created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">RouterAdd.feature</span></strong><span class="koboSpan" id="kobo.686.1"> file, we’ll create its counterpart as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">RouterAdd.java</span></strong><span class="koboSpan" id="kobo.688.1"> test class. </span><span class="koboSpan" id="kobo.688.2">The location for both files will resemble </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">src/test/java/dev/davivieira/topologyinventory/application/RouterAdd.java</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">src/test/resources/dev/davivieira/topologyinventory/application/routers/RouterAdd.feature</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.692.1">The following steps walk you through adding an edge router</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.693.1"> to a</span><a id="_idTextAnchor168"/> <span class="No-Break"><span class="koboSpan" id="kobo.694.1">core router:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.695.1">The first step is to get an </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">edge router:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.697.1">
@Given("I have an edge router")
public void assert_edge_router_exists(){
    edgeRouter = (EdgeRouter)
    this.routerManagementUseCase.createRouter(
            Vendor.HP,
            Model.XYZ0004,
            IP.fromAddress("20.0.0.1"),
            locationA,
            EDGE
    );
    assertNotNull(edgeRouter);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.698.1">Here, we </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.699.1">use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">createRouter</span></strong><span class="koboSpan" id="kobo.701.1"> method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.703.1"> to create edge router objects. </span><span class="koboSpan" id="kobo.703.2">We need to cast the returned object to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.705.1"> type because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">createRouter</span></strong><span class="koboSpan" id="kobo.707.1"> method returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">Router</span></strong><span class="koboSpan" id="kobo.709.1">. </span><span class="koboSpan" id="kobo.709.2">Then, to make sure that we received a proper router object, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">assertNotNull</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.711.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">edgeRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.714.1">Now that we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.716.1">, we need to create </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.718.1"> by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">createRouter</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.720.1">method again:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.721.1">
@And("I have a core router")
public void assert_core_router_exists(){
    coreRouter = (CoreRouter)
    this.routerManagementUseCase.createRouter(
            Vendor.CISCO,
            Model.XYZ0001,
            IP.fromAddress("30.0.0.1"),
            locationA,
            CORE
    );
    assertNotNull(coreRouter);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.722.1">This code follows the exact same pattern as the first step. </span><span class="koboSpan" id="kobo.722.2">The only difference is that we pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">CORE</span></strong><span class="koboSpan" id="kobo.724.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">RouterType</span></strong><span class="koboSpan" id="kobo.726.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">createRouter</span></strong><span class="koboSpan" id="kobo.728.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">RouterManagementUseCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.732.1">With these two</span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.733.1"> objects, </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.735.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.737.1">, we can now test adding the former</span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.738.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">the latter:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.740.1">
@Then("I add an edge router to a core router")
public void add_edge_to_core_router(){
    var actualEdgeId = edgeRouter.getId();
    var routerWithEdge =
    (CoreRouter)  this.routerManagementUseCase.
</span><span class="koboSpan" id="kobo.740.2">    addRouterToCoreRouter(edgeRouter, coreRouter);
    var expectedEdgeId =
    routerWithEdge.getRouters().get(actualEdgeId).
</span><span class="koboSpan" id="kobo.740.3">    getId();
    assertEquals(actualEdgeId, expectedEdgeId);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.741.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">addRouterToCoreRouter</span></strong><span class="koboSpan" id="kobo.743.1"> method receives </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.745.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.747.1"> as parameters. </span><span class="koboSpan" id="kobo.747.2">At the end of the method, we compare the actual and expected edge router IDs to confirm whether the edge router has been added correctly to the </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">core router.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.749.1">To test the execution of the Cucumber scenario steps from </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">RouterAdd.feature</span></strong><span class="koboSpan" id="kobo.751.1">, we have to run the following </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">Maven command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.753.1">
mvn test</span></pre> <p><span class="koboSpan" id="kobo.754.1">The output will be similar to the one </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">shown here:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.756.1">
@RouterAdd
Scenario: Adding an edge router to a core router # dev/davivieira/topologyinventory/application/routers/RouterAdd.feature:4
Given I have an edge router # dev.davivieira.topologyinventory.application.RouterAdd.assert_edge_router_exists()
And I have a core router # dev.davivieira.topologyinventory.application.RouterAdd.assert_core_router_exists()
Then I add an edge router to a core router # dev.davivieira.topologyinventory.application.RouterAdd.add_edge_to_core_router()</span></pre> <p><span class="koboSpan" id="kobo.757.1">The Cucumber test passes through the testing methods in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">RouterAdd.java</span></strong><span class="koboSpan" id="kobo.759.1"> file in the same order as they were declared in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">RouterAdd.feature</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.761.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.762.1">Now, let’s see how we can implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">RouterCreate.java</span></strong><span class="koboSpan" id="kobo.764.1"> test class for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">RouterCreate.feature</span></strong><span class="koboSpan" id="kobo.766.1"> file. </span><span class="koboSpan" id="kobo.766.2">Their file locations will resemble </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">RouterCreate.java</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.769.1">file: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">src/test/java/dev/davivieira/topologyinventory/application/RouterCreate.java</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">RouterCreate.feature</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.772.1">file: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">src/test/resources/dev/davivieira/topologyinventory/application/routers/RouterCreate.feature</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.774.1">The following </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.775.1">scenario steps walk through </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.776.1">creating a new core router in </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">the system:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.778.1">The first step is to create a new </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">core router:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.780.1">
@Given("I provide all required data to create a core
  router")
public void create_core_router(){
    router =  this.routerManagementUseCase.
</span><span class="koboSpan" id="kobo.780.2">            createRouter(
            Vendor.CISCO,
            Model.XYZ0001,
            IP.fromAddress("20.0.0.1"),
            locationA,
            CORE
    );
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.781.1">We provide all the required data to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">createRouter</span></strong><span class="koboSpan" id="kobo.783.1"> method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.785.1"> in order to create the new </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">core router.</span></span></p></li> <li><span class="koboSpan" id="kobo.787.1">Then, we proceed to confirm whether the router created was indeed a </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">core router:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.789.1">
@Then("A new core router is created")
public void a_new_core_router_is_created(){
   assertNotNull(router);
   assertEquals(CORE, router.getRouterType());
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.790.1">The first assertion checks whether we received a null pointer. </span><span class="koboSpan" id="kobo.790.2">The second assertion looks into the router’s type to confirm that it’s a </span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">core router.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.792.1">The following </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.793.1">scenario steps involve checking whether we can simply create </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.794.1">an edge router by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">createRouter</span></strong><span class="koboSpan" id="kobo.796.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">RouterManagementUseCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.800.1">First, we create an </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">edge router:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.802.1">
@Given("</span><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.803.1">I provide all required data to create an edge
  router")
public void create_edge_router(){
    router =
      this.routerManagementUseCase.createRouter(
            Vendor.HP,
            Model.XYZ0004,
            IP.fromAddress("30.0.0.1"),
            locationA,
            EDGE
    );
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.804.1">We follow the same procedure for creating the core router objects, but now, we set</span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.805.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">EDGE</span></strong><span class="koboSpan" id="kobo.807.1"> parameter as </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">RouterType</span></strong><span class="koboSpan" id="kobo.809.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">object creation.</span></span></p></li> <li><span class="koboSpan" id="kobo.811.1">In the last </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.812.1">scenario step, we just execute </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">the assertions:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.814.1">
@Then("A new edge router is created")
public void a_new_edge_router_is_created(){
    assertNotNull(router);
    assertEquals(EDGE, router.getRouterType());
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.815.1">The first assertion checks with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">assertNotNull</span></strong><span class="koboSpan" id="kobo.817.1"> method whether the router reference is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">null</span></strong><span class="koboSpan" id="kobo.819.1">. </span><span class="koboSpan" id="kobo.819.2">Then, it proceeds by executing </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">assertEquals</span></strong><span class="koboSpan" id="kobo.821.1"> to check whether the router created </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">EdgeRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.825.1">To run the tests related to the creation of routers, we will execute the following Maven command in the project </span><span class="No-Break"><span class="koboSpan" id="kobo.826.1">root directory:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.827.1">
mvn test</span></pre> <p><span class="koboSpan" id="kobo.828.1">The test result should contain the </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.830.1">
@RouterCreate
Scenario: Creating a new edge router # dev/davivieira/topologyinventory/application/routers/RouterCreate.feature:8
Given I provide all required data to create an edge router # dev.davivieira.topologyinventory.application.RouterCreate.create_edge_router()
Then A new edge router is created # dev.davivieira.topologyinventory.application.RouterCreate.a_new_edge_router_is_created()</span></pre> <p><span class="koboSpan" id="kobo.831.1">Now that we’re done with the scenario to create</span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.832.1"> routers, let’s see how to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">RouterRemove.java</span></strong><span class="koboSpan" id="kobo.834.1"> test class for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">RouterRemove.feature</span></strong><span class="koboSpan" id="kobo.836.1"> file. </span><span class="koboSpan" id="kobo.836.2">The file locations are </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">as follows:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">src/test/java/dev/davivieira/topologyinventory/application/RouterRemove.java</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">src/test/resources/dev/davivieira/topologyinventory/application/routers/RouterRemove.feature</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.840.1">We have to create the methods to test a scenario</span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.841.1"> where we want to remove an edge router from a </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">core router:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.843.1">To get started, we first need to know whether the core router we are working with has at least an edge</span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.844.1"> router connected </span><span class="No-Break"><span class="koboSpan" id="kobo.845.1">to it:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.846.1">
@Given("The core router has at least one edge router
  connected to it")
public void the_core_router_has_at_least_one_edge_
  router_connected_to_it(){
    var predicate =
      Router.getRouterTypePredicate(EDGE);
    edgeRouter = (EdgeRouter)
      this.coreRouter.getRouters().
</span><span class="koboSpan" id="kobo.846.2">            entrySet().
</span><span class="koboSpan" id="kobo.846.3">            stream().
</span><span class="koboSpan" id="kobo.846.4">            map(routerMap -&gt; routerMap.getValue()).
</span><span class="koboSpan" id="kobo.846.5">            filter(predicate).
</span><span class="koboSpan" id="kobo.846.6">            findFirst().get();
    assertEquals(EDGE, edgeRouter.getRouterType());
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.847.1">From a core router, we search for an edge router connected to it. </span><span class="koboSpan" id="kobo.847.2">Then, we store the </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.848.1">returned edge router in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">edgeRouter</span></strong><span class="koboSpan" id="kobo.850.1"> variable. </span><span class="koboSpan" id="kobo.850.2">Following that, we assert the type of router to confirm whether we have an </span><span class="No-Break"><span class="koboSpan" id="kobo.851.1">edge router.</span></span></p></li> <li><span class="koboSpan" id="kobo.852.1">Next, we have </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.853.1">to check that there are no networks attached to the switch connected to the edge router. </span><span class="koboSpan" id="kobo.853.2">We have to check this; otherwise, we will not be able to remove the switch from the </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">edge router:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.855.1">
@And("The switch has no networks attached to it")
public void the_switch_has_no_networks_
  attached_to_it(){
    var networksSize =
    networkSwitch.getSwitchNetworks().size();
    assertEquals(1, networksSize);
    networkSwitch.removeNetworkFromSwitch(network);
    networksSize =
      networkSwitch.getSwitchNetworks().size();
    assertEquals(0, networksSize);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.856.1">To assert a switch has no networks connected to it, we first check the size of the networks on the switch. </span><span class="koboSpan" id="kobo.856.2">It should return </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">1</span></strong><span class="koboSpan" id="kobo.858.1">. </span><span class="koboSpan" id="kobo.858.2">Then, we remove the network and check the size again. </span><span class="koboSpan" id="kobo.858.3">It should </span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">return </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.862.1">We must ensure that the switch has no networks attached to it to make that switch eligible </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">for removal.</span></span></p></li> <li><span class="koboSpan" id="kobo.864.1">Next, we can</span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.865.1"> proceed</span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.866.1"> to check that there are no switches connected to the </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">edge router:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.868.1">
@And("The edge router has no switches attached to it")
public void the_edge_router_has_no_switches_
  attached_to_it(){
    var switchesSize =
      edgeRouter.getSwitches().size();
    assertEquals(1, switchesSize);
    edgeRouter.removeSwitch(networkSwitch);
    switchesSize = edgeRouter.getSwitches().size();
    assertEquals(0, switchesSize);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.869.1">Here, we remove the switch using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">removeSwitch</span></strong><span class="koboSpan" id="kobo.871.1"> method, followed by an assertion to confirm that the edge router has no more </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">switches connected.</span></span></p></li> <li><span class="koboSpan" id="kobo.873.1">Now, we can test the removal of the edge router from the </span><span class="No-Break"><span class="koboSpan" id="kobo.874.1">core router:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.875.1">
@Then("I remove the edge router from the core router")
public void edge_router_is_removed_from_core_router(){
    var actualID = edgeRouter.getId();
    var expectedID = this.routerManagementUseCase.
</span><span class="koboSpan" id="kobo.875.2">           removeRouterFromCoreRouter(
           edgeRouter, coreRouter).
</span><span class="koboSpan" id="kobo.875.3">           getId();
    assertEquals(expectedID, actualID);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.876.1">To test the removal of an edge router from the core router, we first get the edge router ID </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.877.1">of the router</span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.878.1"> we intend to remove. </span><span class="koboSpan" id="kobo.878.2">We store this ID in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">actualID</span></strong><span class="koboSpan" id="kobo.880.1"> variable. </span><span class="koboSpan" id="kobo.880.2">Then, we proceed to the actual removal. </span><span class="koboSpan" id="kobo.880.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">removeRouterFromCoreRouter</span></strong><span class="koboSpan" id="kobo.882.1"> method returns the removed router. </span><span class="koboSpan" id="kobo.882.2">So, we can use the removed router ID, stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">expectedID</span></strong><span class="koboSpan" id="kobo.884.1"> variable, to check with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">assertEquals</span></strong><span class="koboSpan" id="kobo.886.1"> method whether the router was </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">really removed.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.888.1">To confirm the tests related to router removal are working, we execute the Maven test goal in the project </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">root directory:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.890.1">
mvn test</span></pre> <p><span class="koboSpan" id="kobo.891.1">The results you get after executing the tests should be similar to the </span><span class="No-Break"><span class="koboSpan" id="kobo.892.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.893.1">
@RouterRemove
Scenario: Removing an edge router from a core router # dev/davivieira/topologyinventory/application/routers/RouterRemove.feature:4
Given The core router has at least one edge router connected to it # dev.davivieira.topologyinventory.application.RouterRemove.the_core_router_has_at_least_one_edge_router_connected_to_it()
And The switch has no networks attached to it # dev.davivieira.topologyinventory.application.RouterRemove.the_switch_has_no_networks_attached_to_it()
And The edge router has no switches attached to it # dev.davivieira.topologyinventory.application.RouterRemove.the_edge_router_has_no_switches_attached_to_it()
Then I remove the edge router from the core router # dev.davivieira.topologyinventory.application.RouterRemove.edge_router_is_removed_from_core_router()</span></pre> <p><span class="koboSpan" id="kobo.894.1">The preceding output provides the execution details of the four testing methods involved in removing the edge router from the </span><span class="No-Break"><span class="koboSpan" id="kobo.895.1">core router.</span></span></p>
<p><span class="koboSpan" id="kobo.896.1">We have completed the testing</span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.897.1"> part of router management. </span><span class="koboSpan" id="kobo.897.2">For </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.898.1">switch and network management, we follow the same ideas. </span><span class="koboSpan" id="kobo.898.2">In the book’s GitHub repository, you can access the topology and inventory code with all </span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">its tests.</span></span></p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.900.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.901.1">In this chapter, on top of the Domain hexagon, we built the Application hexagon with use cases and ports. </span><span class="koboSpan" id="kobo.901.2">For use cases, we heavily relied on a behavior-driven development tool called Cucumber. </span><span class="koboSpan" id="kobo.901.3">With Cucumber, we can express use cases supported by the system not only in code terms but also in </span><span class="No-Break"><span class="koboSpan" id="kobo.902.1">written text.</span></span></p>
<p><span class="koboSpan" id="kobo.903.1">We started by creating Cucumber feature files containing the use case written descriptions, and then we used them as a reference to create use case interfaces. </span><span class="koboSpan" id="kobo.903.2">These interfaces were then implemented by input ports that provided a concrete way to achieve the use case goals. </span><span class="koboSpan" id="kobo.903.3">Finally, we built use case tests, based again on the written description provided </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">by Cucumber.</span></span></p>
<p><span class="koboSpan" id="kobo.905.1">By implementing and testing the Application hexagon in this way, we leveraged the special capabilities of Cucumber to express the system’s behavior in a declarative and straightforward form, and w</span><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.906.1">e used these same capabilities to implement and test the entire </span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">Application hexagon.</span></span></p>
<p><span class="koboSpan" id="kobo.908.1">On top of the Application hexagon and the features it provides, we need to decide how such features will be exposed. </span><span class="koboSpan" id="kobo.908.2">Also, some of these require access to external data sources. </span><span class="koboSpan" id="kobo.908.3">We’ll address all these concerns by developing the Framework hexagon in the </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">next chapter.</span></span></p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.910.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.911.1">What do we call files where we declare </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">Cucumber scenarios?</span></span></li>
<li><span class="koboSpan" id="kobo.913.1">On which other Java module does the Application </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">hexagon depend?</span></span></li>
<li><span class="koboSpan" id="kobo.915.1">Which hexagonal architecture component is used to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">use cases?</span></span></li>
</ol>
<h1 id="_idParaDest-133"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.917.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.918.1">They are called </span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">feature files.</span></span></li>
<li><span class="koboSpan" id="kobo.920.1">It depends on the Domain hexagon </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">Java module.</span></span></li>
<li><span class="koboSpan" id="kobo.922.1">Input ports are utilized to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.923.1">use cases.</span></span></li>
</ol>
</div>
</body></html>