<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Email and Spam Management with MailFilter</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In computer science, we have a number of <strong class="calibre8">laws</strong>, the most famous of which is, perhaps, Moore's Law, which addresses the rate at which the computer processing power increases. Another law, although not as well known, and certainly not as serious, is one known as <strong class="calibre8">Zawinski's Law</strong>. Jamie Zawinski, best known for his role at Netscape and Mozilla, once noted that "Every program attempts to expand until it can read mail. Those programs which cannot so expand are replaced by ones which can." While Zawinski's Law hasn't been quite as accurate as Moore's Law, there does seem to be a ring of truth to it, doesn't there?</p>
<p class="mce-root">In the spirit of Zawinski's Law, even if not quite the letter, we will turn our attention to email in this chapter and see if we can address something that plagues us all: email clutter. Ranging from spam to mailing list postings, those messages just keep coming, and they keep piling up.</p>
<p class="mce-root">I have several email accounts. As the head--and head geek--of my household, I'm often tasked with managing, whether they realize it or not, our digital assets, and while one little piece of spam might seem like nothing, over time, it can become a real problem. At a certain point, it almost seems too daunting to handle.</p>
<p class="mce-root">In this chapter, we'll take this very real, if perhaps somewhat overstated problem, and try to address it. That will give us the perfect excuse to use the standard Java email API, appropriately called JavaMail.</p>
<p class="mce-root">In this chapter, we'll cover the following topics:</p>
<ul class="calibre13">
<li class="calibre14">The JavaMail API</li>
<li class="calibre14">Email protocols</li>
<li class="calibre14">Some more JavaFX work (of course)</li>
<li class="calibre14">Creating job schedules in Java with Quartz</li>
<li class="calibre14">Installing OS-specific services written in Java</li>
</ul>
<p class="mce-root">It may be that you have your email inboxes well under control, in which case, congratulations! However, despite how tidy or overwhelming your mail client may be, we should have fun in this chapter while exploring the small but capable JavaMail API and the wonderful world of electronic mail.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Before we get too far into the application, let's stop and take a quick look at what is involved in email. For being such a ubiquitous tool, it seems that it's a fairly opaque topic for most people, even the technically minded who might be inclined to read a book such as this. If we're going to work with it, it will be extremely helpful to understand it, even if just a bit. If you are not interested in the details of the protocols themselves, then feel free to skip ahead to the next section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">A brief look at the history of email protocols</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Like many great computing concepts, <strong class="calibre8">email</strong>--<strong class="calibre8">electronic mail</strong>--was first introduced in the 1960s, though it looked much different then. A thorough history of email, while certainly a great technical curiosity, is beyond the scope of our purposes here, but I think it would be helpful to take a look at a few of the email protocols still relevant today, those being SMTP for sending mail, and POP3 and IMAP for (from your email client's perspective) receiving mail. (Technically, the email is received by the server via SMTP as that is the on-the-wire protocol used by <strong class="calibre8">Mail Transfer Agents</strong> (<strong class="calibre8">MTAs</strong>), to transfer mail from one server to another. We non-MTA authors never think of it in those terms, so we need not be overly concerned by that distinction).</p>
<p class="mce-root">We'll start with sending an email, as our focus in this chapter will be more on folder management. <strong class="calibre8">SMTP</strong> (<strong class="calibre8">Simple Mail Transport Protocol</strong>), created in 1982 and last updated in 1998, is the dominant protocol to send an email. Typically, in the days of SSL and TLS-secured connections, clients connected to the SMTP server via port 587. The conversation between the server and a client, often referred to as a dialog, may look like this (as taken from the SMTP RFC at <a href="https://tools.ietf.org/html/rfc5321" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://tools.ietf.org/html/rfc5321</span></a>):</p>
<pre class="calibre21">    S: 220 foo.com Simple Mail Transfer Service Ready<br class="calibre2"/>    C: EHLO bar.com<br class="calibre2"/>    S: 250-foo.com greets bar.com<br class="calibre2"/>    S: 250-8BITMIME<br class="calibre2"/>    S: 250-SIZE<br class="calibre2"/>    S: 250-DSN<br class="calibre2"/>    S: 250 HELP<br class="calibre2"/>    C: MAIL FROM:&lt;Smith@bar.com&gt;<br class="calibre2"/>    S: 250 OK<br class="calibre2"/>    C: RCPT TO:&lt;Jones@foo.com&gt;<br class="calibre2"/>    S: 250 OK<br class="calibre2"/>    C: RCPT TO:&lt;Green@foo.com&gt;<br class="calibre2"/>    S: 550 No such user here<br class="calibre2"/>    C: RCPT TO:&lt;Brown@foo.com&gt;<br class="calibre2"/>    S: 250 OK<br class="calibre2"/>    C: DATA<br class="calibre2"/>    S: 354 Start mail input; end with &lt;CRLF&gt;.&lt;CRLF&gt;<br class="calibre2"/>    C: Blah blah blah...<br class="calibre2"/>    C: ...etc. etc. etc.<br class="calibre2"/>    C: .<br class="calibre2"/>    S: 250 OK<br class="calibre2"/>    C: QUIT<br class="calibre2"/>    S: 221 foo.com Service closing transmission channel</pre>
<p class="mce-root">In this simple example, the client shakes hands with the server, then says who the email is from and who it's going to. Note that the email addresses are listed twice, but it is only these first instances (<kbd class="calibre16">MAIL FROM</kbd> and <kbd class="calibre16">RCPT TO</kbd>, the latter of which is repeated for each recipient) that matter. The second set is simply for the formatting and display of the email. That peculiarity noted, the actual email comes after the <kbd class="calibre16">DATA</kbd> line, which should be fairly self-explanatory. The lone period on a line marks the end of the message, at which point, the server confirms receipt of the message, and we sign off by saying <kbd class="calibre16">QUIT</kbd>. This example looks very simple, and it is, but things get much more complicated when the message has an attachment, such as an image or office document, or if the email is formatted in HTML.</p>
<p class="mce-root">While SMTP is used to send mail, the POP3 protocol is used to retrieve it. POP, or Post Office Protocol, was first introduced in 1984. The bulk of the current standard, POP3, was introduced in 1988 with an update released in 1996. POP3 servers are meant to receive or download mail by a client such as Mozilla Thunderbird. If the server allows, the client can make an unsecured connection on port 110, with secure connections typically being made on port 995.</p>
<p class="mce-root">POP3 at one point was the dominant protocol by which users downloaded their mail. It was quick and efficient, and, for a while, our only option. Folder management was something that had to be done on the client side, as POP3 sees the mailbox as one big store, with no notion of folders (POP4 was intended to add some notion of folders, among other things, but there has not been any progress on the proposed RFC for several years). The POP3 (RC 1939, found at <a href="https://tools.ietf.org/html/rfc1939" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://tools.ietf.org/html/rfc1939</span></a>) gives this example dialog:</p>
<pre class="calibre21">    S: &lt;wait for connection on TCP port 110&gt;<br class="calibre2"/>    C: &lt;open connection&gt;<br class="calibre2"/>    S:    +OK POP3 server ready &lt;1896.697170952@dbc.mtview.ca.us&gt;<br class="calibre2"/>    C:    APOP mrose c4c9334bac560ecc979e58001b3e22fb<br class="calibre2"/>    S:    +OK mrose's maildrop has 2 messages (320 octets)<br class="calibre2"/>    C:    STAT<br class="calibre2"/>    S:    +OK 2 320<br class="calibre2"/>    C:    LIST<br class="calibre2"/>    S:    +OK 2 messages (320 octets)<br class="calibre2"/>    S:    1 120<br class="calibre2"/>    S:    2 200<br class="calibre2"/>    S:    .<br class="calibre2"/>    C:    RETR 1<br class="calibre2"/>    S:    +OK 120 octets<br class="calibre2"/>    S:    &lt;the POP3 server sends message 1&gt;<br class="calibre2"/>    S:    .<br class="calibre2"/>    C:    DELE 1<br class="calibre2"/>    S:    +OK message 1 deleted<br class="calibre2"/>    C:    RETR 2<br class="calibre2"/>    S:    +OK 200 octets<br class="calibre2"/>    S:    &lt;the POP3 server sends message 2&gt;<br class="calibre2"/>    S:    .<br class="calibre2"/>    C:    DELE 2<br class="calibre2"/>    S:    +OK message 2 deleted<br class="calibre2"/>    C:    QUIT<br class="calibre2"/>    S:    +OK dewey POP3 server signing off (maildrop empty)<br class="calibre2"/>    C:  &lt;close connection&gt;<br class="calibre2"/>    S:  &lt;wait for next connection&gt;</pre>
<p class="mce-root">Note that the client sends a <kbd class="calibre16">RETR</kbd> command to retrieve the message, followed by a <kbd class="calibre16">DELE</kbd> command to remove it from the server. This seems to be the standard/default configuration for most POP3 clients.</p>
<p class="mce-root">Although, many clients can be configured to leave the mail on the server either for a certain number of days, or forever, possibly deleting the message from the server when it is deleted locally. If you've ever managed your mail this way, you've seen firsthand how this can complicate email management.</p>
<p class="mce-root">For example, back in the days before laptops, imagine you have one desktop computer at the office and one at the house. You'd like to be able to read your email in both locations, so you set up your POP3 client on both machines. You spend your work day reading, deleting, and maybe sorting email. When you get home, those, say, 40 messages you managed at work are now sitting in your inbox, in big bold letters to indicate an unread message. You now have to repeat your email management tasks at home if you have any hope of keeping the two clients in similar states. It was tedious and error prone, and that led us to the creation of IMAP.</p>
<p class="mce-root"><strong class="calibre8">IMAP</strong> or <strong class="calibre8">Internet Access Message Protocol</strong>, was created in 1986, with one of its design goals being permitting the complete management of a mailbox, folders, and all, by multiple clients. It has seen several revisions over the years, with IMAP 4 revision 1 being the current standard. Clients connect to an IMAP server on port 143 for unsecured connections, and 993 for SSL to TLS-based connections.</p>
<p class="mce-root">IMAP, since it offers much more robust functionality than POP, is a more complicated protocol. From the RFC (<a href="https://tools.ietf.org/html/rfc3501" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://tools.ietf.org/html/rfc3501</span></a>), we can look at the following sample dialog:</p>
<pre class="calibre21">    S:   * OK IMAP4rev1 Service Ready 
    C:   a001 login mrc secret 
    S:   a001 OK LOGIN completed 
    C:   a002 select inbox 
    S:   * 18 EXISTS 
    S:   * FLAGS (Answered Flagged Deleted Seen Draft) 
    S:   * 2 RECENT 
    S:   * OK [UNSEEN 17] Message 17 is the first unseen message 
    S:   * OK [UIDVALIDITY 3857529045] UIDs valid 
    S:   a002 OK [READ-WRITE] SELECT completed 
    C:   a003 fetch 12 full 
    S:   * 12 FETCH (FLAGS (Seen) INTERNALDATE <br class="calibre2"/>         "17-Jul-1996 02:44:25 -0700" 
      RFC822.SIZE 4286 ENVELOPE ("Wed,<br class="calibre2"/>         17 Jul 1996 02:23:25 -0700 (PDT)" 
      "IMAP4rev1 WG mtg summary and minutes" 
      (("Terry Gray" NIL "gray" "cac.washington.edu")) 
      (("Terry Gray" NIL "gray" "cac.washington.edu")) 
      (("Terry Gray" NIL "gray" "cac.washington.edu")) 
      ((NIL NIL "imap" "cac.washington.edu")) 
      ((NIL NIL "minutes" "CNRI.Reston.VA.US") 
      ("John Klensin" NIL "KLENSIN" "MIT.EDU")) NIL NIL 
      "&lt;B27397-0100000@cac.washington.edu&gt;") 
       BODY ("TEXT" "PLAIN" ("CHARSET" "US-ASCII") NIL NIL "7BIT" 3028 
       92)) 
    S:    a003 OK FETCH completed 
    C:    a004 fetch 12 body[header] 
    S:    * 12 FETCH (BODY[HEADER] {342} 
    S:    Date: Wed, 17 Jul 1996 02:23:25 -0700 (PDT) 
    S:    From: Terry Gray &lt;gray@cac.washington.edu&gt; 
    S:    Subject: IMAP4rev1 WG mtg summary and minutes 
    S:    To: imap@cac.washington.edu 
    S:    cc: minutes@CNRI.Reston.VA.US, John Klensin &lt;KLENSIN@MIT.EDU&gt; 
    S:    Message-Id: &lt;B27397-0100000@cac.washington.edu&gt; 
    S:    MIME-Version: 1.0 
    S:    Content-Type: TEXT/PLAIN; CHARSET=US-ASCII 
    S: 
    S:    ) 
    S:    a004 OK FETCH completed 
    C:    a005 store 12 +flags deleted 
    S:    * 12 FETCH (FLAGS (Seen Deleted)) 
    S:    a005 OK +FLAGS completed 
    C:    a006 logout 
    S:    * BYE IMAP4rev1 server terminating connection 
    S:    a006 OK LOGOUT completed </pre>
<p class="mce-root">As you can see, there's much more detail there than in our example POP3 dialog. This should also highlight why we're using an API like JavaMail rather than opening a socket and talking directly to the server ourselves. Speaking of JavaMail, let's turn our attention to this standard API and see what it can do for us.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">JavaMail, the Standard Java API for Email</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The JavaMail API is a set of abstractions that provide a protocol and platform-independent way of working with email. While it is a required part of <strong class="calibre8">Java Enterprise Edition</strong> (<strong class="calibre8">Java EE</strong>), it is an add-on library for Java SE, meaning you'll have to download it separately, which we'll handle via our POM file.</p>
<p class="mce-root">Our primary interest with this chapter's application is message management, but we'll take a bit of time to look at sending email using the API, so you'll have something to work with should you ever find yourself needing to do so.</p>
<p class="mce-root">To start sending mails, we need to get a JavaMail <kbd class="calibre16">Session</kbd>. To do that, we'll need to set up some properties as follows:</p>
<pre class="calibre21">    Properties props = new Properties(); 
    props.put("mail.smtps.host", "smtp.gmail.com"); 
    props.put("mail.smtps.auth", "true"); 
    props.put("mail.smtps.port", "465"); 
    props.put("mail.smtps.ssl.trust", "*"); </pre>
<p class="mce-root">We'll send email through Gmail's server, and we'll use SMTP over SSL. With this <kbd class="calibre16">Properties</kbd> instance, we can create our <kbd class="calibre16">Session</kbd> instance as follows:</p>
<pre class="calibre21">    Session session = Session.getInstance(props,  
      new javax.mail.Authenticator() { 
      @Override 
      protected PasswordAuthentication getPasswordAuthentication() { 
        return new PasswordAuthentication(userName, password); 
      } 
    }); </pre>
<p class="mce-root">To log in to the server, we need to specify credentials, which we do via the anonymous <kbd class="calibre16">PasswordAuthentication</kbd> instance. Once we have our <kbd class="calibre16">Session</kbd> instance, we need to create a <kbd class="calibre16">Transport</kbd> as follows:</p>
<pre class="calibre21">    transport = session.getTransport("smtps"); 
      transport.connect(); </pre>
<p class="mce-root">Note that for the protocol parameter, we specify <kbd class="calibre16">smtps</kbd>, which tells the JavaMail implementation that we want SMTP over SSL/TLS. We're now ready to build our message using the following block of code:</p>
<pre class="calibre21">    MimeMessage message = new MimeMessage(session); 
    message.setFrom("jason@steeplesoft.com"); 
    message.setRecipients(Message.RecipientType.TO, 
      "jason@steeplesoft.com"); 
    message.setSubject("JavaMail Example"); </pre>
<p class="mce-root">An email message is modeled using the <kbd class="calibre16">MimeMessage</kbd> class, so we create an instance of that using our <kbd class="calibre16">Session</kbd> instance. We set the from and to addresses, as well as the subject. To make things more interesting, we'll attach a file using a <kbd class="calibre16">MimeBodyPart</kbd>, as we see here:</p>
<pre class="calibre21">    MimeBodyPart text = new MimeBodyPart(); 
    text.setText("This is some sample text"); 
 
    MimeBodyPart attachment = new MimeBodyPart(); 
    attachment.attachFile("src/test/resources/rules.json"); 
 
    Multipart multipart = new MimeMultipart(); 
    multipart.addBodyPart(text); 
    multipart.addBodyPart(attachment); 
    message.setContent(multipart); </pre>
<p class="mce-root">Our message will have two parts, modeled using <kbd class="calibre16">MimeBodyPart</kbd>, one is the body of the message, which is simple text, and the other is an attachment. In this case, we're simply attaching a data file from our tests, which we'll see later. Once we've defined the parts, we combine them using <kbd class="calibre16">MimeMultipart</kbd>, then set it as the content on our message, which we can now using the <kbd class="calibre16">transport.sendMessage()</kbd> method:</p>
<pre class="calibre21">    transport.sendMessage(message, new Address[] { 
      new InternetAddress("jason@steeplesoft.com")}); 
      if (transport != null) { 
        transport.close();   
      }  </pre>
<p class="mce-root">Within just a few seconds, you should see the following email show up in your inbox:</p>
<div class="mce-root1"><img class="image-border36" src="Images/0bceba72-6abc-43ad-95e6-4f5276507a75.png"/></div>
<p class="mce-root">If you want to send an HTML email with a text alternative, you can do this using the following code:</p>
<pre class="calibre21">    MimeBodyPart text = new MimeBodyPart(); 
    text.setContent("This is some sample text", "text/plain");  
    MimeBodyPart html = new MimeBodyPart(); 
    html.setContent("&lt;strong&gt;This&lt;/strong&gt; is some &lt;em&gt;sample&lt;/em&gt;<br class="calibre2"/>      &lt;span style="color: red"&gt;text&lt;/span&gt;", "text/html"); 
    Multipart multipart = new MimeMultipart("alternative"); 
    multipart.addBodyPart(text); 
    multipart.addBodyPart(html); 
    message.setContent(multipart); 
    transport.sendMessage(message, new Address[]{ 
      new InternetAddress("jason@example.com")});</pre>
<p class="mce-root">Note that we set the content on each <kbd class="calibre16">MimeBodyPart</kbd>, specifying the mime type, and when we create the <kbd class="calibre16">Multipart</kbd>, we pass alternative as the <kbd class="calibre16">subtype</kbd> parameter. Failure to do so will result in an email that shows both parts, one after the other, which is certainly not what we want. If we've written our application correctly, we should see something like the following in our email client:</p>
<div class="mce-root1"><img class="image-border36" src="Images/e9df3c0c-224d-4f46-8d80-ece8e8b45f66.png"/></div>
<p class="mce-root">You can't see the red text, of course, in black and white print, but you can see the bold and italicized text, which means the HTML version was shown, rather than the text version. Mission accomplished!</p>
<p class="mce-root">Sending emails is pretty fun, but we're here to learn about folder and message management, so let's turn our attention to that, and we'll start by setting up our project.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building the CLI</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This project, like the others, will be a multi-module Maven project. We'll have one module for all of the core code, and we'll have another for the GUI we'll write to help manage the rules.</p>
<p class="mce-root">To create the project, we'll do something a little different this time. Rather than creating the project using NetBeans, we'll create it from the command line using Maven archetypes, which can be thought of roughly as project templates, so you can see how it's done that way:</p>
<pre class="calibre21">    $ mvn archetype:generate  -DarchetypeGroupId=<br class="calibre2"/>      org.codehaus.mojo.archetypes  -DarchetypeArtifactId=pom-root -<br class="calibre2"/>      DarchetypeVersion=RELEASE 
      ... 
    Define value for property 'groupId': com.steeplesoft.mailfilter 
    Define value for property 'artifactId': mailfilter-master 
    Define value for property 'version':  1.0-SNAPSHOT 
    Define value for property 'package':  com.steeplesoft.mailfilter </pre>
<p class="mce-root">Once Maven has finished processing, change directory into the new project's directory, <kbd class="calibre16">mailfilter-master</kbd>. From here, we can create the first of our projects, the CLI:</p>
<pre class="calibre21">    $ mvn archetype:generate  -DarchetypeGroupId=<br class="calibre2"/>      org.apache.maven.archetypes  -DarchetypeArtifactId=<br class="calibre2"/>      maven-archetype-quickstart  -DarchetypeVersion=RELEASE 
    Define value for property 'groupId': com.steeplesoft.mailfilter 
    Define value for property 'artifactId': mailfilter-cli 
    Define value for property 'version':  1.0-SNAPSHOT 
    Define value for property 'package':  com.steeplesoft.mailfilter </pre>
<p class="mce-root">This will create a new project under <kbd class="calibre16">mailfilter-master</kbd> called <kbd class="calibre16">mailfilter-cli</kbd>. We can now open <kbd class="calibre16">mailfilter-cli</kbd> in NetBeans and get to work.</p>
<p class="mce-root">The first thing we need to do is spec out how we want this tool to work. At a high level, we want to be able to specify an arbitrary number of rules for an account. These rules will allow us to move or delete emails based on certain criteria, such as the sender or the email's age. To keep things simple, we'll scope all of the rules to a specific account, and limit the operations to move and delete.</p>
<p class="mce-root">Let's start by taking a look at what the account may look like:</p>
<pre class="calibre21">    public class Account { 
      @NotBlank(message="A value must be specified for serverName") 
      private String serverName; 
      @NotNull(message = "A value must be specified for serverPort") 
      @Min(value = 0L, message = "The value must be positive") 
      private Integer serverPort = 0; 
      private boolean useSsl = true; 
      @NotBlank(message = "A value must be specified for userName") 
      private String userName; 
      @NotBlank(message = "A value must be specified for password") 
      private String password; 
      private List&lt;Rule&gt; rules; </pre>
<p class="mce-root">This is basically a very simple <strong class="calibre8">POJO</strong> (<strong class="calibre8">Plain Old Java Object</strong>) with six properties: <kbd class="calibre16">serverName</kbd>, <kbd class="calibre16">serverPort</kbd>, <kbd class="calibre16">useSsl</kbd>, <kbd class="calibre16">userName</kbd>, <kbd class="calibre16">password</kbd>, and <kbd class="calibre16">rules</kbd>. What are those annotations, though? Those come from a library called Bean Validation that provides some annotations and supporting code that allows us to express, declaratively, constraints on the values , which the variable can hold. Here are the annotations we're using, and what they mean:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">@NotBlank</kbd>: This tells the system that the value can't be null, nor can it be an empty string (effectively, <kbd class="calibre16">string != null &amp;&amp; !string.trim() .equals("")</kbd>)</li>
<li class="calibre14"><kbd class="calibre16">@NotNull</kbd>: This tells the system that the value can't be null</li>
<li class="calibre14"><kbd class="calibre16">@Min</kbd>: This describes a minimum valid value</li>
</ul>
<p class="mce-root">There are, of course, many, many others, and the system defines a means for you to define your own, so it's a very simple, yet very powerful framework to validate input, which brings up an important point: these constraints are only validated when the Bean Validation framework is asked to do so. We could easily build up a large collection of these <kbd class="calibre16">Account</kbd> instances with every field holding invalid data, and the JVM would be perfectly happy with that. The only way to apply the Bean Validation constraints is to ask it to check the instances we provide it with. In a nutshell, it's the API and not the JVM that enforces these constraints. That may seem obvious, but, sometimes, it pays to be explicit.</p>
<p class="mce-root">Before we go any further, we need to add Bean Validation to our project. We'll use the reference implementation: <kbd class="calibre16">Hibernate Validator</kbd>. We'll also need the Expression Language API and an implementation in our project. We get all of those by adding the following dependencies to <kbd class="calibre16">pom.xml</kbd>:</p>
<pre class="calibre21">    &lt;dependency&gt; 
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt; 
      &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; 
      &lt;version&gt;5.3.4.Final&lt;/version&gt; 
    &lt;/dependency&gt; 
    &lt;dependency&gt; 
      &lt;groupId&gt;javax.el&lt;/groupId&gt; 
      &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; 
      &lt;version&gt;2.2.4&lt;/version&gt; 
    &lt;/dependency&gt; 
    &lt;dependency&gt; 
      &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; 
      &lt;artifactId&gt;javax.el&lt;/artifactId&gt; 
      &lt;version&gt;2.2.4&lt;/version&gt; 
    &lt;/dependency&gt; </pre>
<p class="mce-root">Getting back to our model, there are some getters and setters, of course, but those are not very interesting. What is interesting, though, is the implementation of <kbd class="calibre16">equals()</kbd> and <kbd class="calibre16">hashCode()</kbd>. Josh Bloch, in his seminal work, Effective Java, says this:</p>
<div class="packt_quote">Always override <kbd class="calibre39">hashCode</kbd> when you override <kbd class="calibre39">equals</kbd>.</div>
<p class="mce-root">The main point of his assertion is that failure to do so violates the <kbd class="calibre16">equals()</kbd> contract, which states that equals objects must have equals hashes, which can result in incorrect and/or unpredictable behavior if your class is used in any hash-based collection, such as <kbd class="calibre16">HashMap</kbd>. Bloch then lists some rules to create a good <kbd class="calibre16">hashCode</kbd> implementation, as well as a good <kbd class="calibre16">equals</kbd> implementation, but here's my advice: let the IDE do the work for you, which is what we've done in the following code block for <kbd class="calibre16">equals()</kbd>:</p>
<pre class="calibre21">    public boolean equals(Object obj) { 
      if (this == obj) { 
        return true; 
      } 
      if (obj == null) { 
        return false; 
      } 
      if (getClass() != obj.getClass()) { 
        return false; 
      } 
      final Account other = (Account) obj; 
      if (this.useSsl != other.useSsl) { 
        return false; 
      } 
      if (!Objects.equals(this.serverName, other.serverName)) { 
        return false; 
      } 
      if (!Objects.equals(this.userName, other.userName)) { 
        return false; 
      } 
      if (!Objects.equals(this.password, other.password)) { 
        return false; 
      } 
      if (!Objects.equals(this.serverPort, other.serverPort)) { 
        return false; 
      } 
      if (!Objects.equals(this.rules, other.rules)) { 
         return false; 
      } 
      return true; 
    } </pre>
<p class="mce-root">We have done the same for <kbd class="calibre16">hashCode()</kbd> here:</p>
<pre class="calibre21">    public int hashCode() { 
      int hash = 5; 
      hash = 59 * hash + Objects.hashCode(this.serverName); 
      hash = 59 * hash + Objects.hashCode(this.serverPort); 
      hash = 59 * hash + (this.useSsl ? 1 : 0); 
      hash = 59 * hash + Objects.hashCode(this.userName); 
      hash = 59 * hash + Objects.hashCode(this.password); 
      hash = 59 * hash + Objects.hashCode(this.rules); 
      return hash; 
    } </pre>
<p class="mce-root">Note that every method tested in <kbd class="calibre16">equals()</kbd> is also used in <kbd class="calibre16">hashCode()</kbd>. It's absolutely vital that your implementations follow this rule, or you'll end up with methods that don't really work as they should. It's possible that your IDE can help with this as you are generating the methods, but you must make sure that you are indeed using the same list of fields, and certainly, should you ever modify one of the methods, the other method must be updated accordingly.</p>
<p class="mce-root">We now have <kbd class="calibre16">Account</kbd>, so what does <kbd class="calibre16">Rule</kbd> look like? Let's take a look at the following piece of code:</p>
<pre class="calibre21">    @ValidRule 
    public class Rule { 
      @NotNull 
      private RuleType type = RuleType.MOVE; 
      @NotBlank(message = "Rules must specify a source folder.") 
      private String sourceFolder = "INBOX"; 
      private String destFolder; 
      private Set&lt;String&gt; fields = new HashSet&lt;&gt;(); 
      private String matchingText; 
      @Min(value = 1L, message = "The age must be greater than 0.") 
      private Integer olderThan; </pre>
<p class="mce-root">The validation on this class is two-fold. First, we can see the same field-level constraints we saw on <kbd class="calibre16">Account</kbd>: <kbd class="calibre16">type</kbd> cannot be null, <kbd class="calibre16">sourceFolder</kbd> cannot be blank, and <kbd class="calibre16">olderThan</kbd> must be at least 1. While you may not recognize it for what it is, we also have a class-level constraint in <kbd class="calibre16">@ValidRule</kbd>.</p>
<p class="mce-root">Field-level constraints can see only the field to which they have been applied. This means that if the valid values for a field are dependent on the value of some other field, these types of constraints are not appropriate. Class-level rules, though, allow us to look at the whole object when doing validation, so we can look to see what the value of one field is when validating another. This also means a bit more code for us, so we'll start with the following annotation:</p>
<pre class="calibre21">    @Target({ElementType.TYPE, ElementType.ANNOTATION_TYPE}) 
    @Retention(RetentionPolicy.RUNTIME) 
    @Constraint(validatedBy = ValidRuleValidator.class) 
    @Documented 
    public @interface ValidRule { 
      String message() default "Validation errors"; 
      Class&lt;?&gt;[] groups() default {}; 
      Class&lt;? extends Payload&gt;[] payload() default {}; 
    } </pre>
<p class="mce-root">In case you've never seen the source for an annotation before, this is a fairly typical example. Rather than declaring the type of the object to be <kbd class="calibre16">class</kbd> or <kbd class="calibre16">interface</kbd>, we used <kbd class="calibre16">@interface</kbd>, a subtle but important difference. The fields of the annotation are also a bit different, as there are no visibility modifiers, and the types cannot be primitives. Note the use of the <kbd class="calibre16">default</kbd> keyword.</p>
<p class="mce-root">The annotation itself also has annotations, which are as follows:</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">@Target</kbd>: This restricts the types of elements this annotation can be applied to; in this case, types and other annotations.</li>
<li class="calibre14"><kbd class="calibre16">@Retention</kbd>: This instructs the compiler whether or not it should write the annotation to the class file, and making it available at runtime.</li>
<li class="calibre14"><kbd class="calibre16">@Constraint</kbd>: This is a Bean Validation annotation that identifies our annotation as a new constraint type. The value of this annotation tells the system what <kbd class="calibre16">ConstraintValidator</kbd> processes the validation logic for this constraint.</li>
<li class="calibre14"><kbd class="calibre16">@Documented</kbd>: This indicates that the presence of this annotation on any type should be considered a part of that type's public API.</li>
</ul>
<p class="mce-root">Our <kbd class="calibre16">ConstraintValidator</kbd> implementation to handle this new constraint is a bit more complicated. We declared the class like this:</p>
<pre class="calibre21">    public class ValidRuleValidator implements  
      ConstraintValidator&lt;ValidRule, Object&gt; { </pre>
<p class="mce-root">Bean Validation provides a parameterized interface for constraint validation that takes the type of the constraint and the object type to which the logic in the validator applies. This allows you to write different validators of a given constraint for different object types. In our case, we could specify <kbd class="calibre16">Rule</kbd> rather than <kbd class="calibre16">Object</kbd>. If we were to do that, any time something other than <kbd class="calibre16">Rule</kbd> is annotated with <kbd class="calibre16">@ValidRule</kbd> and the instance is validated, the calling code will see an exception thrown. What we've done instead, as you will see, is validate the annotated type, specifically adding a constraint violation if needed.</p>
<p class="mce-root">The interface requires that we implement this method as well, but we have no work to be done here, so it has an empty method body, as shown here:</p>
<pre class="calibre21">    @Override 
    public void initialize(ValidRule constraintAnnotation) { 
    } </pre>
<p class="mce-root">The interesting method is called <kbd class="calibre16">isValid()</kbd>. It's a bit long, so let's step through it piece by piece:</p>
<pre class="calibre21">    public boolean isValid(Object value,  
      ConstraintValidatorContext ctx) { 
        if (value == null) { 
          return true; 
        } </pre>
<p class="mce-root">The first step is to make sure <kbd class="calibre16">value</kbd> is not null. We have two choices: return <kbd class="calibre16">true</kbd> if it's null, indicating there's no problem, or return <kbd class="calibre16">false</kbd>, indicating that there is a problem. Our choice depends on how we want the application to behave. Reasonable arguments can be made for either approach, but it seems that it would make sense for a null <kbd class="calibre16">Rule</kbd> to be considered invalid, so let's change the body of that for it to look like this:</p>
<pre class="calibre21">    ctx.disableDefaultConstraintViolation(); 
    ctx.buildConstraintViolationWithTemplate( 
      "Null values are not considered valid Rules") 
      .addConstraintViolation(); 
    return false; </pre>
<p class="mce-root">We build <kbd class="calibre16">ConstraintViolation</kbd> using the specified message, add that to <kbd class="calibre16">ConstraintValidatorContext</kbd>, <kbd class="calibre16">ctx</kbd>, and return false to indicate a failure.</p>
<p class="mce-root">Next, we want to make sure we're dealing with an instance of <kbd class="calibre16">Rule</kbd>:</p>
<pre class="calibre21">    if (!(value instanceof Rule)) { 
      ctx.disableDefaultConstraintViolation(); 
      ctx.buildConstraintViolationWithTemplate( 
        "Constraint valid only on instances of Rule.") 
      .addConstraintViolation(); 
      return false; 
    } </pre>
<p class="mce-root">Once we're sure we have a non-null instance of <kbd class="calibre16">Rule</kbd>, we can get to the heart of our validation logic:</p>
<pre class="calibre21">    boolean valid = true; 
    Rule rule = (Rule) value; 
    if (rule.getType() == RuleType.MOVE) { 
      valid &amp;= validateNotBlank(ctx, rule, rule.getDestFolder(),  
      "A destination folder must be specified."); 
    } </pre>
<p class="mce-root">We'd like to be able to gather all of the violations, so we create a <kbd class="calibre16">boolean</kbd> variable to hold the current state, then we cast the value as <kbd class="calibre16">Rule</kbd> to make dealing with the instance a bit more natural. In our first test, we make sure that, if the type of <kbd class="calibre16">Rule</kbd> is <kbd class="calibre16">RuleType. MOVE</kbd>, it has a destination folder specified. We do so using this private method:</p>
<pre class="calibre21">    private boolean validateNotBlank(ConstraintValidatorContext ctx,  
      String value, String message) { 
      if (isBlank(value)) { 
        ctx.disableDefaultConstraintViolation(); 
        ctx.buildConstraintViolationWithTemplate(message) 
        .addConstraintViolation(); 
        return false; 
      } 
      return true; 
   } </pre>
<p class="mce-root">If <kbd class="calibre16">value</kbd> is blank, we add <kbd class="calibre16">ConstraintViolation</kbd>, as we've already seen, using the specified message, and return <kbd class="calibre16">false</kbd>. If it is not blank, we return <kbd class="calibre16">true</kbd>. This value is then ANDed with <kbd class="calibre16">valid</kbd> to update the current state of the <kbd class="calibre16">Rule</kbd> validation.</p>
<p class="mce-root">The <kbd class="calibre16">isBlank()</kbd> method is very simple:</p>
<pre class="calibre21">    private boolean isBlank(String value) { 
      return (value == null || (value.trim().isEmpty())); 
    } </pre>
<p class="mce-root">This is a very common check, and is actually logically identical to the validator behind Bean Validation's <kbd class="calibre16">@NotBlank</kbd>.</p>
<p class="mce-root">Our next two tests are related. The logic is this: the rule must specify either text to match, or a maximum age in days. The test for that looks like this:</p>
<pre class="calibre21">     if (!isBlank(rule.getMatchingText())) { 
       valid &amp;= validateFields(ctx, rule); 
     } else if (rule.getOlderThan() == null) { 
       ctx.disableDefaultConstraintViolation(); 
       ctx.buildConstraintViolationWithTemplate( 
         "Either matchingText or olderThan must be specified.") 
       .addConstraintViolation(); 
       valid = false; 
     } </pre>
<p class="mce-root">If <kbd class="calibre16">Rule</kbd> specifies <kbd class="calibre16">matchingText</kbd>, then we validate that <kbd class="calibre16">fields</kbd> has been set properly. If neither <kbd class="calibre16">matchingText</kbd> nor <kbd class="calibre16">olderThan</kbd> were set, then we add <kbd class="calibre16">ConstraintViolation</kbd> with a message to that effect and set <kbd class="calibre16">valid</kbd> to false. Our <kbd class="calibre16">fields</kbd> validation looks like this:</p>
<pre class="calibre21">    private boolean validateFields(ConstraintValidatorContext ctx, Rule rule) { 
      if (rule.getFields() == null || rule.getFields().isEmpty()) { 
        ctx.disableDefaultConstraintViolation(); 
        ctx.buildConstraintViolationWithTemplate( 
          "Rules which specify a matching text must specify the field(s)<br class="calibre2"/>            to match on.") 
          .addConstraintViolation(); 
        return false; 
      } 
      return true; 
    } </pre>
<p class="mce-root">We make sure that <kbd class="calibre16">fields</kbd> is neither null nor empty. We do not do any validation here on the actual contents of the field <kbd class="calibre16">Set</kbd>, though we certainly could.</p>
<p class="mce-root">We have now written, possibly, our very first custom validation. Your reaction is likely something like, "Wow! That's a lot of code for a 'simple' validation", and you're right. Before you throw the baby out with the bath water, think about this: the value of Bean Validation is that you can take potentially complex validation logic and hide it behind a very small annotation. You can then reuse this logic wherever you want simply by placing your constraint annotation in the appropriate places. The logic is expressed in one place, maintained in one place, but used in many, all very neatly and concisely.</p>
<p class="mce-root">So, yes, that's a good deal of code, but you only have to write it once, and the consumers of the constraints never need to see it. There's not really much extra work over and above what you'd normally write, but it's up to you to decide if this extra bit of work is worth the time.</p>
<p class="mce-root">Now that we've taken a quick look at custom Bean Validation constraints, let's return to our data model. The final piece to show is the <kbd class="calibre16">RuleType</kbd> enum:</p>
<pre class="calibre21">    public enum RuleType { 
      DELETE, MOVE; 
      public static RuleType getRuleType(String type) { 
        switch(type.toLowerCase()) { 
          case "delete" : return DELETE; 
          case "move" : return MOVE; 
          default : throw new IllegalArgumentException( 
            "Invalid rule type specified: " + type); 
        } 
      } 
    } </pre>
<p class="mce-root">This is a basic Java <kbd class="calibre16">enum</kbd> with two possible values, <kbd class="calibre16">DELETE</kbd> and <kbd class="calibre16">MOVE</kbd>, but we've also added a helper method to return the appropriate <kbd class="calibre16">RuleType</kbd> instance for a given String representation. This will help us when we're unmarshaling a <kbd class="calibre16">Rule</kbd> from JSON, for example.</p>
<p class="mce-root">With our data model defined, we're ready to start writing the code for the utility itself. While the Maven module is called <kbd class="calibre16">mailfilter-cli</kbd>, we will not concern ourselves here with a robust command-line interface, like we saw in previous chapters. Instead, we'll provide a very basic interaction with the command line, leaving an OS service, which we'll look at later, as the preferred means of usage.</p>
<p class="mce-root">It is at this point that we will begin using the JavaMail API, so we need to make sure we have our project set up correctly, so we add the following lines of code to <kbd class="calibre16">pom.xml</kbd>:</p>
<pre class="calibre21">    &lt;dependency&gt; 
      &lt;groupId&gt;com.sun.mail&lt;/groupId&gt; 
      &lt;artifactId&gt;javax.mail&lt;/artifactId&gt; 
      &lt;version&gt;1.5.6&lt;/version&gt; 
    &lt;/dependency&gt; </pre>
<p class="mce-root">In our IDE, we create a new class, <kbd class="calibre16">MailFilter</kbd>, and create the familiar <kbd class="calibre16">public static void main</kbd> method as follows:</p>
<pre class="calibre21">    public static void main(String... args) { 
      try { 
        final MailFilter mailFilter =  
          new MailFilter(args.length &gt; 0 ? args[1] : null); 
        mailFilter.run(); 
        System.out.println("tDeleted count: "  
          + mailFilter.getDeleted()); 
        System.out.println("tMove count:    "  
          + mailFilter.getMoved()); 
      } catch (Exception e) { 
        System.err.println(e.getLocalizedMessage()); 
      } 
    } </pre>
<div class="packt_tip">NetBeans supports a number of code templates. The template of interest here is <kbd class="calibre39">psvm</kbd>, which will create a <kbd class="calibre39">public static void main</kbd> method. To use it, make sure you are on an empty line inside the class definition (to avoid odd formatting issues), then type <kbd class="calibre39">psvm</kbd> and press tab. NetBeans creates the method for you and places the cursor on the first line of the empty method, ready for you to start coding. You can find dozens of other helpful code templates by navigating to <span class="calibre5">Tools</span> | <span class="calibre5">Options</span> | <span class="calibre5">Editor</span> | <span class="calibre5">Code Templates</span>. You can even define your own.</div>
<p class="mce-root">In our <kbd class="calibre16">main()</kbd> method, we create an instance of <kbd class="calibre16">MainFilter</kbd>, passing in any rule definition file that may have been specified on the command line, and calling <kbd class="calibre16">run()</kbd>:</p>
<pre class="calibre21">    public void run() { 
      try { 
        AccountService service = new AccountService(fileName); 
 
        for (Account account : service.getAccounts()) { 
          AccountProcessor processor =  
            new AccountProcessor(account); 
          processor.process(); 
          deleted += processor.getDeleteCount(); 
          moved += processor.getMoveCount(); 
        } 
      } catch (MessagingException ex) { 
        Logger.getLogger(MailFilter.class.getName()) 
        .log(Level.SEVERE, null, ex); 
      } 
    } </pre>
<p class="mce-root">We start by creating an instance of <kbd class="calibre16">AccountService</kbd>, which wraps up the details of reading and writing the <kbd class="calibre16">Rules</kbd> file. For each account in the specified file, we create <kbd class="calibre16">AccountProcessor</kbd>, which encapsulates the rule processing logic.</p>
<p class="mce-root">The <kbd class="calibre16">AccountService</kbd> instance may not sound very exciting, but there are some pretty interesting technical bits hidden away behind that public interface. We see where the Bean Validation constraints are actually checked, and we also see the use of the Jackson JSON library to read and write the <kbd class="calibre16">Rules</kbd> file. Before we can start using Jackson, we need to add it to our project, which we do by adding this <kbd class="calibre16">pom.xml</kbd>:</p>
<pre class="calibre21">    &lt;dependency&gt; 
      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; 
      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; 
      &lt;version&gt;2.8.5&lt;/version&gt; 
    &lt;/dependency&gt; </pre>
<p class="mce-root">You should, as always, make sure that you are on the latest version of the library.</p>
<p class="mce-root">This is not a big class to start with, but only three methods are of any interest here. We'll start with the most basic one, which is as follows:</p>
<pre class="calibre21">    private File getRulesFile(final String fileName) { 
      final File file = new File(fileName != null ? fileName 
        : System.getProperty("user.home") + File.separatorChar 
        + ".mailfilter" + File.separatorChar + "rules.json"); 
      if (!file.exists()) { 
        throw new IllegalArgumentException( 
          "The rules file does not exist: " + rulesFile); 
      } 
      return file; 
    } </pre>
<p class="mce-root">The only reason I include this here is that reading a file from the user's home directory is something I find myself doing fairly frequently, and you might too. This example shows you how to do just that, attempting to find the rule file at <kbd class="calibre16">~/.mailfilter/rules.json</kbd> if the user does not specify a file explicitly. Generated or specified, if the rule file can't be found, we throw an exception.</p>
<p class="mce-root">Perhaps the most interesting method is the <kbd class="calibre16">getAccounts()</kbd> method. We'll step through this one slowly:</p>
<pre class="calibre21">    public List&lt;Account&gt; getAccounts() { 
      final Validator validator = Validation 
        .buildDefaultValidatorFactory().getValidator(); 
      final ObjectMapper mapper = new ObjectMapper() 
        .configure(DeserializationFeature. 
        ACCEPT_SINGLE_VALUE_AS_ARRAY, true); 
      List&lt;Account&gt; accounts = null; </pre>
<p class="mce-root">These three statements are setting up some objects required to process the accounts. The first is <kbd class="calibre16">Validator</kbd>, which is the Bean Validation class that is our entry point to apply and check the constraints we've described on our data models. The next, <kbd class="calibre16">ObjectMapper</kbd>, is a Jackson class that will map a JSON data structure onto our Java data model. We need to specify <kbd class="calibre16">ACCEPT_SINGLE_VALUE_AS_ARRAY</kbd> to make sure that Jackson properly handles any lists in our model. Finally, we create <kbd class="calibre16">List</kbd> to hold our <kbd class="calibre16">Account</kbd> instances.</p>
<p class="mce-root">Reading the rules file into memory and getting that as instances of our data model is extremely easy with Jackson:</p>
<pre class="calibre21">    accounts = mapper.readValue(rulesFile,  
      new TypeReference&lt;List&lt;Account&gt;&gt;() {}); </pre>
<p class="mce-root">Since the property names in our Java classes match the keys used in our JSON file, <kbd class="calibre16">ObjectMapper</kbd> can easily read the data from the JSON file and build our in-memory model with just this one line. Note the <kbd class="calibre16">TypeReference</kbd> instance. We want Jackson to return a <kbd class="calibre16">List&lt;Account&gt;</kbd> instance, but due to some design decisions in the JVM, direct access to parameterized types at runtime is not possible. The <kbd class="calibre16">TypeReference</kbd> class, however, helps capture this information, which Jackson then uses in creating the data model. If we passed <kbd class="calibre16">List.class</kbd>, we would get a type cast failure at runtime.</p>
<p class="mce-root">Now that we have our <kbd class="calibre16">Account</kbd> instances, we're ready to start validation:</p>
<pre class="calibre21">    accounts.forEach((account) -&gt; { 
      final Set&lt;ConstraintViolation&lt;Account&gt;&gt; violations =  
        validator.validate(account); 
      if (violations.size() &gt; 0) { 
        System.out.println( 
          "The rule file has validation errors:"); 
        violations.forEach(a -&gt; System.out.println("  "" + a)); 
        throw new RuntimeException("Rule validation errors"); 
      } 
      account.getRules().sort((o1, o2) -&gt;  
        o1.getType().compareTo(o2.getType())); 
    }); </pre>
<p class="mce-root">Using <kbd class="calibre16">List.forEach()</kbd>, we iterate over each account in <kbd class="calibre16">List</kbd> (the null check was not shown here). For each <kbd class="calibre16">Account</kbd>, we call <kbd class="calibre16">validator.validate()</kbd>, which is when the constraints are actually validated. Up to this point, they were just annotations stored in the class, with the JVM happily carrying them along, but not doing anything else with them. Bean Validation, as we discussed earlier, is the enforcer of the constraints described by the annotations, and here we see that manual API call.</p>
<p class="mce-root">When the call to the <kbd class="calibre16">validator</kbd> returns, we need to see if there were any <kbd class="calibre16">ConstraintViolations</kbd>. If there were, we fairly naively print a message to standard out detailing each of the failures. If the rule has multiple violations, thanks to how we wrote our validator, we'll see them all at once, so the user can fix them without having to attempt to process the rules multiple times. Printing these to the console is not necessarily the best approach, as we can't process them programmatically, but it is sufficient for our needs at the moment.</p>
<div class="packt_tip">Where Bean Validation really shines is in frameworks that integrate it on your behalf. For example, JAX-RS, the standard Java API to build REST resources, offers this type of integration. We see a usage of the functionality in this sample REST resource method:<br class="calibre2"/>
<kbd class="calibre39">@GET</kbd><br class="calibre2"/>
<kbd class="calibre39">public Response getSomething (</kbd><br class="calibre2"/>
<kbd class="calibre39">@QueryParam("foo") @NotNull Integer bar) {</kbd><br class="calibre2"/>
When a request is routed to this method, JAX-RS ensures that the query parameter <kbd class="calibre39">foo</kbd> is converted, if possible, to an <kbd class="calibre39">Integer</kbd>, and that it is not <kbd class="calibre39">null</kbd>, so in your code, you can assume that you have a valid <kbd class="calibre39">Integer</kbd> reference.</div>
<p class="mce-root">The final method we want to look at in this class is <kbd class="calibre16">saveAccounts()</kbd>, which, as crazy as it may sound, saves the <kbd class="calibre16">Account</kbd> instances to the rules file specified:</p>
<pre class="calibre21">    public void saveAccounts(List&lt;Account&gt; accounts) { 
      try { 
        final ObjectMapper mapper =  
          new ObjectMapper().configure(DeserializationFeature. 
          ACCEPT_SINGLE_VALUE_AS_ARRAY, true); 
        mapper.writeValue(rulesFile, accounts); 
      } catch (IOException ex) { 
        // ... 
      } 
    } </pre>
<p class="mce-root">Much like reading the file, writing to it is extremely simple, so long as your Java classes and your JSON structures match. If you do have differing names (for example, the Java class may have the <kbd class="calibre16">accountName</kbd> property, while the JSON file uses <kbd class="calibre16">account_name</kbd>), Jackson offers some annotations that can be applied to the POJO to explain how to map the fields correctly. You can find complete details for those on Jackson's website (<a href="https://github.com/FasterXML/jackson" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://github.com/FasterXML/jackson</span></a>).</p>
<p class="mce-root">With our <kbd class="calibre16">Account</kbd> instances loaded into memory and validated for correctness, we now need to process them. The entry point is the <kbd class="calibre16">process()</kbd> method:</p>
<pre class="calibre21">    public void process() throws MessagingException { 
      try { 
        getImapSession(); 
 
        for (Map.Entry&lt;String, List&lt;Rule&gt;&gt; entry :  
          getRulesByFolder(account.getRules()).entrySet()) { 
          processFolder(entry.getKey(), entry.getValue()); 
        } 
      } catch (Exception e) { 
        throw new RuntimeException(e); 
      } finally { 
        closeFolders(); 
        if (store != null) { 
          store.close(); 
        } 
      } 
    } </pre>
<p class="mce-root">The three lines to pay attention to are the calls to <kbd class="calibre16">getImapSession()</kbd>, <kbd class="calibre16">getRulesByFolder()</kbd>, and <kbd class="calibre16">processFolder()</kbd>, which we'll look at in detail now:</p>
<pre class="calibre21">    private void getImapSession()  
      throws MessagingException, NoSuchProviderException { 
      Properties props = new Properties(); 
      props.put("mail.imap.ssl.trust", "*"); 
      props.put("mail.imaps.ssl.trust", "*"); 
      props.setProperty("mail.imap.starttls.enable",  
        Boolean.toString(account.isUseSsl())); 
      Session session = Session.getInstance(props, null); 
      store = session.getStore(account.isUseSsl() ?  
        "imaps" : "imap"); 
      store.connect(account.getServerName(), account.getUserName(),  
        account.getPassword()); 
    } </pre>
<p class="mce-root">To get an IMAP <kbd class="calibre16">Session</kbd>, as we saw earlier in this chapter, we create a <kbd class="calibre16">Properties</kbd> instance and set a few important properties. We get a <kbd class="calibre16">Store</kbd> reference using the protocol specified by the user in the rule file: <kbd class="calibre16">imap</kbd> for non-SSL-based connections and <kbd class="calibre16">imaps</kbd> for SSL-based connections.</p>
<p class="mce-root">Once we have our session, we then iterate over our rules, grouping them by source folder:</p>
<pre class="calibre21">    private Map&lt;String, List&lt;Rule&gt;&gt; getRulesByFolder(List&lt;Rule&gt; rules) { 
      return rules.stream().collect( 
        Collectors.groupingBy(r -&gt; r.getSourceFolder(), 
        Collectors.toList())); 
    } </pre>
<p class="mce-root">We can now process the folder as follows:</p>
<pre class="calibre21">    private void processFolder(String folder, List&lt;Rule&gt; rules)  
      throws MessagingException { 
      Arrays.stream(getFolder(folder, Folder.READ_WRITE) 
        .getMessages()).forEach(message -&gt; 
        rules.stream().filter(rule -&gt;  
        rule.getSearchTerm().match(message)) 
        .forEach(rule -&gt; { 
          switch (rule.getType()) { 
            case MOVE: 
              moveMessage(message, getFolder( 
                rule.getDestFolder(),  
                Folder.READ_WRITE)); 
            break; 
            case DELETE: 
              deleteMessage(message); 
            break; 
          } 
      })); 
    } </pre>
<p class="mce-root">Using <kbd class="calibre16">Stream</kbd>, we iterate over each message in the source folder, filtering for only those that match <kbd class="calibre16">SearchTerm</kbd>, but what is that, and where did it come from?</p>
<p class="mce-root">There are a couple of extra items on the <kbd class="calibre16">Rule</kbd> class that we haven't looked at yet:</p>
<pre class="calibre21">    private SearchTerm term; 
    @JsonIgnore 
    public SearchTerm getSearchTerm() { 
      if (term == null) { 
        if (matchingText != null) { 
          List&lt;SearchTerm&gt; terms = fields.stream() 
          .map(f -&gt; createFieldSearchTerm(f)) 
          .collect(Collectors.toList()); 
          term = new OrTerm(terms.toArray(new SearchTerm[0])); 
        } else if (olderThan != null) { 
          LocalDateTime day = LocalDateTime.now() 
          .minusDays(olderThan); 
          term = new SentDateTerm(ComparisonTerm.LE, 
            Date.from(day.toLocalDate().atStartOfDay() 
            .atZone(ZoneId.systemDefault()).toInstant())); 
        } 
      } 
      return term; 
    } </pre>
<p class="mce-root">We add a private field to cache <kbd class="calibre16">SearchTerm</kbd> so we don't have to create it more than once. It's a minor optimization, but we want to avoid unnecessary performance hits from recreating <kbd class="calibre16">SearchTerm</kbd> for every message on a large folder. If the rule has a <kbd class="calibre16">matchingText</kbd> set, we create a <kbd class="calibre16">List&lt;SearchTerm&gt;</kbd> based on the fields specified. Once we have that list, we wrap it in <kbd class="calibre16">OrTerm</kbd>, which will instruct JavaMail to match the message if <em class="calibre20">any</em> of the specified fields match the text.</p>
<p class="mce-root">If <kbd class="calibre16">olderThan</kbd> is set, then we create <kbd class="calibre16">SentDateTerm</kbd> to match any messages that were sent at least <kbd class="calibre16">olderThan</kbd> days ago. We save the <kbd class="calibre16">SearchTerm</kbd> reference in our private instance variable then return it.</p>
<p class="mce-root">Notice that the method has the <kbd class="calibre16">@JsonIgnore</kbd> annotation. We use this to make sure that Jackson doesn't try to marshall the value returned by this getter to the JSON file.</p>
<p class="mce-root">For the curious, <kbd class="calibre16">createFieldSearchTerm()</kbd> looks like this:</p>
<pre class="calibre21">    private SearchTerm createFieldSearchTerm(String f) { 
      switch (f.toLowerCase()) { 
        case "from": 
          return new FromStringTerm(matchingText); 
        case "cc": 
          return new RecipientStringTerm( 
            Message.RecipientType.CC, matchingText); 
        case "to": 
          return new RecipientStringTerm( 
            Message.RecipientType.TO, matchingText); 
        case "body": 
          return new BodyTerm(matchingText); 
        case "subject": 
          return new SubjectTerm(matchingText); 
        default: 
            return null; 
      } 
    } </pre>
<p class="mce-root">So, how are the messages actually moved or deleted? There is, of course, a JavaMail API for that, whose usage might look something like this:</p>
<pre class="calibre21">    private static final Flags FLAGS_DELETED =  
      new Flags(Flags.Flag.DELETED); 
    private void deleteMessage(Message toDelete) { 
      if (toDelete != null) { 
        try { 
          final Folder source = toDelete.getFolder(); 
          source.setFlags(new Message[]{toDelete},  
            FLAGS_DELETED, true); 
          deleteCount++; 
        } catch (MessagingException ex) { 
          throw new RuntimeException(ex); 
        } 
      } 
    } </pre>
<p class="mce-root">We do a quick null check, then we get a reference to the messages <kbd class="calibre16">Folder</kbd>. With that, we instruct JavaMail to set a flag, <kbd class="calibre16">FLAGS_DELETED</kbd>, on the messages in the folder. The JavaMail API more often than not works on arrays of <kbd class="calibre16">Message</kbd> (<kbd class="calibre16">Message[]</kbd>), so we need to wrap <kbd class="calibre16">Message</kbd> in an array as we pass it to <kbd class="calibre16">setFlags()</kbd>. As we finish up, we increment our deleted message counter so we can print our report when we're finished.</p>
<p class="mce-root">Moving a <kbd class="calibre16">Message</kbd> is very similar:</p>
<pre class="calibre21">    private void moveMessage(Message toMove, Folder dest) { 
      if (toMove != null) { 
        try { 
          final Folder source = toMove.getFolder(); 
          final Message[] messages = new Message[]{toMove}; 
          source.setFlags(messages, FLAGS_DELETED, true); 
          source.copyMessages(messages, dest); 
          moveCount++; 
        } catch (MessagingException ex) { 
          throw new RuntimeException(ex); 
        } 
      } 
    } </pre>
<p class="mce-root">The bulk of this method looks just like <kbd class="calibre16">deleteMessage()</kbd>, but there is a subtle difference. JavaMail doesn't have a <kbd class="calibre16">moveMessages()</kbd> API. What we have to do instead is call <kbd class="calibre16">copyMessages()</kbd> to create a copy of the message in the destination folder, then delete the message from the source folder. We increment the moved counter and return.</p>
<p class="mce-root">The final two methods of interest deal with folders. First, we need to get the folder, which we do here:</p>
<pre class="calibre21">    final private Map&lt;String, Folder&gt; folders = new HashMap&lt;&gt;(); 
    private Folder getFolder(String folderName, int mode) { 
      Folder source = null; 
      try { 
        if (folders.containsKey(folderName)) { 
          source = folders.get(folderName); 
        } else { 
          source = store.getFolder(folderName); 
          if (source == null || !source.exists()) { 
            throw new IllegalArgumentException( 
             "Invalid folder: " + folderName); 
          } 
          folders.put(folderName, source); 
        } 
        if (!source.isOpen()) { 
          source.open(mode); 
        } 
      } catch (MessagingException ex) { 
        //... 
      } 
      return source; 
    } </pre>
<p class="mce-root">For performance reasons, we cache each <kbd class="calibre16">Folder</kbd> instance in <kbd class="calibre16">Map</kbd>, keyed by the folder name. If we find <kbd class="calibre16">Folder</kbd> in <kbd class="calibre16">Map</kbd>, we use that. If we do not, then we ask the IMAP <kbd class="calibre16">Store</kbd> for a reference to the desired <kbd class="calibre16">Folder</kbd>, and cache it in <kbd class="calibre16">Map</kbd>. Finally, we make sure <kbd class="calibre16">Folder</kbd> is open, or our move and delete commands will throw <kbd class="calibre16">Exception</kbd>.</p>
<p class="mce-root">We also need to make sure we close the <kbd class="calibre16">Folder</kbd> when we're finished:</p>
<pre class="calibre21">    private void closeFolders() { 
      folders.values().stream() 
      .filter(f -&gt; f.isOpen()) 
      .forEachOrdered(f -&gt; { 
        try { 
          f.close(true); 
        } catch (MessagingException e) { 
        } 
      }); 
    } </pre>
<p class="mce-root">We filter our stream of <kbd class="calibre16">Folder</kbd> for only those that are open, then call <kbd class="calibre16">folder.close()</kbd>, swallowing any failure that might occur. At this point in the processing, there's not much that can be done.</p>
<p class="mce-root">Our mail filter is now technically complete, but it's not as usable as it could be. We need some way to run this on a schedule, and being able to view and edit the rules in a GUI would be really nice, so we'll build both of those. Since it doesn't make sense to schedule something if we have nothing to run, we'll start with the GUI.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building the GUI</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Since we want to make this as easy to use as possible, we'll now build a GUI to help manage these rules. To create the project, we'll use the same Maven archetype we used in creating the CLI:</p>
<pre class="calibre21"><strong class="calibre3">$ mvn archetype:generate  -DarchetypeGroupId=org.apache.maven.archetypes  -DarchetypeArtifactId=maven-archetype-quickstart  -DarchetypeVersion=RELEASE 
Define value for property 'groupId': com.steeplesoft.mailfilter 
Define value for property 'artifactId': mailfilter-gui 
Define value for property 'version':  1.0-SNAPSHOT 
Define value for property 'package':  com.steeplesoft.mailfilter.gui</strong> </pre>
<p class="mce-root">Once the POM has been created, we need to edit it a bit. We need to set the parent by adding this element to <kbd class="calibre16">pom.xml</kbd>:</p>
<pre class="calibre21">    &lt;parent&gt; 
      &lt;groupId&gt;com.steeplesoft.j9bp.mailfilter&lt;/groupId&gt; 
      &lt;artifactId&gt;mailfilter-master&lt;/artifactId&gt; 
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; 
    &lt;/parent&gt; </pre>
<p class="mce-root">We will also add a dependency on the CLI module as follows:</p>
<pre class="calibre21">    &lt;dependencies&gt; 
      &lt;dependency&gt; 
        &lt;groupId&gt;${project.groupId}&lt;/groupId&gt; 
        &lt;artifactId&gt;mailfilter-cli&lt;/artifactId&gt; 
        &lt;version&gt;${project.version}&lt;/version&gt; 
      &lt;/dependency&gt; 
    &lt;/dependencies&gt; </pre>
<p class="mce-root">Since we're not depending on NetBeans to generate the JavaFX project for us, we'll also need to create a few basic artifacts by hand. Let's start with the application's entry point:</p>
<pre class="calibre21">    public class MailFilter extends Application { 
      @Override 
      public void start(Stage stage) throws Exception { 
        Parent root = FXMLLoader.load(getClass() 
        .getResource("/fxml/mailfilter.fxml")); 
        Scene scene = new Scene(root); 
        stage.setTitle("MailFilter"); 
        stage.setScene(scene); 
        stage.show(); 
      } 
 
      public static void main(String[] args) { 
        launch(args); 
      } 
    } </pre>
<p class="mce-root">This is a very typical JavaFX main class, so we'll skip right to the FXML file. For now, we'll just create a stub using the following piece of code:</p>
<pre class="calibre21">    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;?import java.lang.*?&gt; 
    &lt;?import java.util.*?&gt; 
    &lt;?import javafx.scene.*?&gt; 
    &lt;?import javafx.scene.control.*?&gt; 
    &lt;?import javafx.scene.layout.*?&gt; 
 
    &lt;AnchorPane id="AnchorPane" prefHeight="200" prefWidth="320"  
        
      fx:controller= 
        "com.steeplesoft.mailfilter.gui.Controller"&gt; 
      &lt;children&gt; 
        &lt;Button layoutX="126" layoutY="90" text="Click Me!"  
          fx:id="button" /&gt; 
        &lt;Label layoutX="126" layoutY="120" minHeight="16"  
          minWidth="69" fx:id="label" /&gt; 
      &lt;/children&gt; 
    &lt;/AnchorPane&gt; </pre>
<p class="mce-root">And finally, we create the controller:</p>
<pre class="calibre21">    public class Controller implements Initializable { 
      @Override 
      public void initialize(URL url, ResourceBundle rb) { 
      } 
    } </pre>
<p class="mce-root">This gives us a working JavaFX application that starts and runs, but doesn't do much else. In previous chapters, we've walked through building a JavaFX application in painstaking detail, so we won't do that again here, but there are some interesting challenges in this one that are worth taking a look at.</p>
<p class="mce-root">To give you a sense of what we're working toward, here's a screenshot of the final user interface:</p>
<div class="mce-root1"><img class="image-border37" src="Images/b66e3847-c4b6-4015-87b6-3b16d467c4a8.png"/></div>
<p class="mce-root">On the left, we have <kbd class="calibre16">ListView</kbd> to display the <kbd class="calibre16">Account</kbd> configured in our rules file. Below <kbd class="calibre16">ListView</kbd>, we have a few controls to edit the currently selected <kbd class="calibre16">Account</kbd>. On the right, we have <kbd class="calibre16">TableView</kbd> to display the <kbd class="calibre16">Rule</kbd>, and a similar area below it for editing a <kbd class="calibre16">Rule</kbd>.</p>
<p class="mce-root">When the user clicks on <kbd class="calibre16">Account</kbd> or <kbd class="calibre16">Rule</kbd>, we want the form area below to be populated with the relevant information. As the user modifies the data, <kbd class="calibre16">Account</kbd>/<kbd class="calibre16">Rule</kbd> as well as <kbd class="calibre16">ListView</kbd>/<kbd class="calibre16">TableView</kbd> should be updated.</p>
<p class="mce-root">Ordinarily, this is one of the areas in which JavaFX really shines, that of property binding. We've already seen a small part of that with <kbd class="calibre16">ObservableList</kbd>: we can add an item to <kbd class="calibre16">List</kbd>, and it is automatically added to the UI component to which it has been bound. The situation we find ourselves in now is a little different though, in that our model is a POJO, one that doesn't use any JavaFX APIs, so we don't get that functionality quite so easily. Let's look at what it will take to wire these things together.</p>
<p class="mce-root">First, let's look at the <kbd class="calibre16">Account</kbd> list. We have <kbd class="calibre16">ObservableList</kbd>:</p>
<pre class="calibre21">    private final ObservableList&lt;Account&gt; accounts =  
      FXCollections.observableArrayList(); </pre>
<p class="mce-root">We add our accounts to this <kbd class="calibre16">ObservableList</kbd> as follows:</p>
<pre class="calibre21">    private void configureAccountsListView() { 
      accountService = new AccountService(); 
      accounts.addAll(accountService.getAccounts()); </pre>
<p class="mce-root">Then, we bind <kbd class="calibre16">List</kbd> and <kbd class="calibre16">ListView</kbd>, as follows:</p>
<pre class="calibre21">    accountsListView.setItems(accounts); </pre>
<p class="mce-root">Here is where things change a little bit. To encapsulate our POJO binding setup, we'll create a new class called <kbd class="calibre16">AccountProperty</kbd>, which we'll look at shortly. Although, let's first add the following code snippet to handle the <kbd class="calibre16">ListView</kbd> clicks:</p>
<pre class="calibre21">    accountProperty = new AccountProperty(); 
    accountsListView.setOnMouseClicked(e -&gt; { 
      final Account account = accountsListView.getSelectionModel() 
      .getSelectedItem(); 
      if (account != null) { 
        accountProperty.set(account); 
      } 
    }); </pre>
<p class="mce-root">When the user clicks on <kbd class="calibre16">ListView</kbd>, we set <kbd class="calibre16">Account</kbd> on the <kbd class="calibre16">AccountProperty</kbd> instance. Before we leave this method and look at <kbd class="calibre16">AccountProperty</kbd>, we need to set up one last item:</p>
<pre class="calibre21">    final ChangeListener&lt;String&gt; accountChangeListener =  
      (observable, oldValue, newValue) -&gt;  
      accountsListView.refresh(); 
    serverName.textProperty().addListener(accountChangeListener); 
    userName.textProperty().addListener(accountChangeListener); </pre>
<p class="mce-root">We define <kbd class="calibre16">ChangeListener</kbd>, which simply calls <kbd class="calibre16">accountsListView.refresh()</kbd>, which instructs <kbd class="calibre16">ListView</kbd> to redraw itself. We'll want it to do this when the model itself is updated, a change that <kbd class="calibre16">ObservableList</kbd> doesn't bubble up to <kbd class="calibre16">ListView</kbd>. The next two lines add <kbd class="calibre16">Listener</kbd> to <kbd class="calibre16">serverName</kbd> and <kbd class="calibre16">userName</kbd><kbd class="calibre16">TextField</kbd>. These two controls edit the properties by the same name on <kbd class="calibre16">Account</kbd>, and are the only two used to generate the display String for <kbd class="calibre16">ListView</kbd>, which we don't show here.</p>
<p class="mce-root"><kbd class="calibre16">AccountProperty</kbd> is a custom JavaFX property, so we extend <kbd class="calibre16">ObjectPropertyBase</kbd> as follows:</p>
<pre class="calibre21">    private class AccountProperty extends ObjectPropertyBase&lt;Account&gt; { </pre>
<p class="mce-root">This offers part of the binding solution, but the heavy lifting is handled by a class from the excellent JFXtras project, <kbd class="calibre16">BeanPathAdapter</kbd>:</p>
<pre class="calibre21">    private final BeanPathAdapter&lt;Account&gt; pathAdapter; </pre>
<div class="packt_infobox">The JFXtras library is not, as of the writing of this book, Java 9 compatible. All we need from the library is this one class, so I have copied the source of class from the JFXtras repository into this project for the time being. Once JFXtras runs under Java 9, we can remove this copy.</div>
<p class="mce-root">The documentation describes this class as an "adapter that takes a POJO bean and internally and recursively binds/unbinds its fields to other <kbd class="calibre16">Property</kbd> components". This is an extremely powerful class that we can't cover in its entirety here, so we'll just jump to our particular usage, which is as follows:</p>
<pre class="calibre21">    public AccountProperty() { 
        pathAdapter = new BeanPathAdapter&lt;&gt;(new Account()); 
        pathAdapter.bindBidirectional("serverName",  
            serverName.textProperty()); 
        pathAdapter.bindBidirectional("serverPort",  
            serverPort.textProperty()); 
        pathAdapter.bindBidirectional("useSsl",  
            useSsl.selectedProperty(), Boolean.class); 
        pathAdapter.bindBidirectional("userName",  
            userName.textProperty()); 
        pathAdapter.bindBidirectional("password",  
            password.textProperty()); 
        addListener((observable, oldValue, newValue) -&gt; { 
            rules.setAll(newValue.getRules()); 
        }); 
    } </pre>
<p class="mce-root"><kbd class="calibre16">BeanPathAdapter</kbd> allows us to bind a JavaFX <kbd class="calibre16">Property</kbd> to a property on a POJO, which could be nested to an arbitrary depth and referenced using a dot-separated path notation. In our case, the properties are top-level properties on the <kbd class="calibre16">Account</kbd> object, so the path is short and simple. After we've bound our controls to the properties, we add a <kbd class="calibre16">Listener</kbd> to update the <kbd class="calibre16">ObservableList</kbd> rules with <kbd class="calibre16">Rule</kbd> for the current account.</p>
<p class="mce-root">The <kbd class="calibre16">set()</kbd> method that is called in the preceding code when the <kbd class="calibre16">Account</kbd> selection changes in <kbd class="calibre16">ListView</kbd> is very straightforward:</p>
<pre class="calibre21">    @Override 
    public void set(Account newValue) { 
      pathAdapter.setBean(newValue); 
      super.set(newValue); 
    } </pre>
<p class="mce-root">With these pieces in place, the <kbd class="calibre16">Account</kbd> object is updated as we type in the various controls, and the <kbd class="calibre16">ListView</kbd> label is updated as the <kbd class="calibre16">serverName</kbd> and/or <kbd class="calibre16">userName</kbd> fields are edited.</p>
<p class="mce-root">Now we need to do the same for the <kbd class="calibre16">TableView</kbd> that will display each <kbd class="calibre16">Rule</kbd> the user has configured. The setup is almost identical:</p>
<pre class="calibre21">    private void configureRuleFields() { 
        ruleProperty = new RuleProperty(); 
        fields.getCheckModel().getCheckedItems().addListener( 
          new RuleFieldChangeListener()); 
        final ChangeListener&lt;Object&gt; ruleChangeListener =  
            (observable, oldValue, newValue) -&gt;  
                rulesTableView.refresh(); 
        sourceFolder.textProperty() 
           .addListener(ruleChangeListener); 
        destFolder.textProperty().addListener(ruleChangeListener); 
        matchingText.textProperty() 
            .addListener(ruleChangeListener); 
        age.textProperty().addListener(ruleChangeListener); 
        type.getSelectionModel().selectedIndexProperty() 
            .addListener(ruleChangeListener); 
    } </pre>
<p class="mce-root">Here, we see the same basic structure: instantiate <kbd class="calibre16">RuleProperty</kbd>, create <kbd class="calibre16">ChangeListener</kbd> to request that <kbd class="calibre16">TableView</kbd> refresh itself, and add that listener to the relevant form fields.</p>
<p class="mce-root"><kbd class="calibre16">RuleProperty</kbd> is also similar to <kbd class="calibre16">AccountProperty</kbd>:</p>
<pre class="calibre21">    private class RuleProperty extends ObjectPropertyBase&lt;Rule&gt; { 
      private final BeanPathAdapter&lt;Rule&gt; pathAdapter; 
 
      public RuleProperty() { 
        pathAdapter = new BeanPathAdapter&lt;&gt;(new Rule()); 
        pathAdapter.bindBidirectional("sourceFolder",  
          sourceFolder.textProperty()); 
        pathAdapter.bindBidirectional("destFolder",  
          destFolder.textProperty()); 
        pathAdapter.bindBidirectional("olderThan",  
          age.textProperty()); 
        pathAdapter.bindBidirectional("matchingText",  
          matchingText.textProperty()); 
        pathAdapter.bindBidirectional("type",  
          type.valueProperty(), String.class); 
        addListener((observable, oldValue, newValue) -&gt; { 
          isSelectingNewRule = true; 
          type.getSelectionModel().select(type.getItems() 
          .indexOf(newValue.getType().name())); 
 
          IndexedCheckModel checkModel = fields.getCheckModel(); 
          checkModel.clearChecks(); 
          newValue.getFields().forEach((field) -&gt; { 
            checkModel.check(checkModel.getItemIndex(field)); 
          }); 
          isSelectingNewRule = false; 
      }); 
    } </pre>
<p class="mce-root">The biggest difference here is <kbd class="calibre16">Listener</kbd> that is created. Given the use of <kbd class="calibre16">CheckListView</kbd>, a custom control from the great ControlsFX project, it's worth noting the logic: we get <kbd class="calibre16">IndexedCheckModel</kbd>, which we clear, then we iterate over each field, finding its index in <kbd class="calibre16">CheckModel</kbd> and checking it.</p>
<p class="mce-root">We control updating the value of the fields set on <kbd class="calibre16">Rule</kbd> via <kbd class="calibre16">RuleFieldChangeListener</kbd>:</p>
<pre class="calibre21">    private class RuleFieldChangeListener implements ListChangeListener { 
      @Override 
      public void onChanged(ListChangeListener.Change c) { 
        if (!isSelectingNewRule &amp;&amp; c.next()) { 
          final Rule bean = ruleProperty.getBean(); 
          bean.getFields().removeAll(c.getRemoved()); 
          bean.getFields().addAll(c.getAddedSubList()); 
        } 
      } 
    } </pre>
<p class="mce-root"><kbd class="calibre16">ListChangeListener</kbd> tells us what was removed and what was added, so we processed those accordingly.</p>
<p class="mce-root">There are several other moving parts to the GUI, but we've seen them in one for another in previous chapters, so we'll not cover them here. If you're curious about these details, you can find them in this book's source code repository. Let's turn our attention to the final part of our project: the OS-specific service.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building the service</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">One of the stated goals of this project is to be able to define rules to manage and filter email, and to have it run more or less all the time, not just when the email client is running. (There is, of course, not much we can do about the machine running this being turned off, so we can't promise constant coverage). To fulfill this part of the promise, we'll need a few extra parts. We already have the part of the system that does the actual work, but we also need a way to run that part on a schedule, and we also need a part that will start the scheduled job.</p>
<p class="mce-root">For the scheduling aspect, we have many options, but we'll use a library called Quartz. The Quartz Job Scheduling Library is an open source library that can be used in Java SE as well as Java EE applications. It provides a clean and simple API that is perfect for use here. To add Quartz to our project, we need to do this to <kbd class="calibre16">pom.xml</kbd>:</p>
<pre class="calibre21">    &lt;dependency&gt; 
      &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; 
      &lt;artifactId&gt;quartz&lt;/artifactId&gt; 
      &lt;version&gt;2.2.3&lt;/version&gt; 
    &lt;/dependency&gt; </pre>
<p class="mce-root">How simple is the API? Here's our <kbd class="calibre16">Job</kbd> definition:</p>
<pre class="calibre21">    public class MailFilterJob implements Job { 
      @Override 
      public void execute(JobExecutionContext jec)  
        throws JobExecutionException { 
        MailFilter filter = new MailFilter(); 
        filter.run(); 
      } 
    } </pre>
<p class="mce-root">We extend <kbd class="calibre16">org.quartz.Job</kbd> overriding <kbd class="calibre16">execute()</kbd>, in which we simply instantiate <kbd class="calibre16">MailFilter</kbd> and call <kbd class="calibre16">run()</kbd>. That's really all there is to it. With our job defined, we just need to schedule it, which we'll do in <kbd class="calibre16">MailFilterService</kbd>:</p>
<pre class="calibre21">    public class MailFilterService { 
      public static void main(String[] args) { 
        try { 
          final Scheduler scheduler =  
            StdSchedulerFactory.getDefaultScheduler(); 
          scheduler.start(); 
 
          final JobDetail job =  
            JobBuilder.newJob(MailFilterJob.class).build(); 
          final Trigger trigger = TriggerBuilder.newTrigger() 
          .startNow() 
          .withSchedule( 
             SimpleScheduleBuilder.simpleSchedule() 
             .withIntervalInMinutes(15) 
             .repeatForever()) 
          .build(); 
          scheduler.scheduleJob(job, trigger); 
        } catch (SchedulerException ex) { 
          Logger.getLogger(MailFilterService.class.getName()) 
          .log(Level.SEVERE, null, ex); 
        } 
      } 
    } </pre>
<p class="mce-root">We begin by getting a reference to the default <kbd class="calibre16">Scheduler</kbd> and starting it. Next, we create a new job using <kbd class="calibre16">JobBuilder</kbd>, then build <kbd class="calibre16">Trigger</kbd> using <kbd class="calibre16">TriggerBuilder</kbd>. We tell <kbd class="calibre16">Trigger</kbd> to start executing now, but note that it won't start until it is actually built and assigned to <kbd class="calibre16">Scheduler</kbd>. Once that happens, <kbd class="calibre16">Job</kbd> will execute immediately. Finally, we define <kbd class="calibre16">Schedule</kbd> for <kbd class="calibre16">Trigger</kbd> using the <kbd class="calibre16">SimpleScheduleBuilder</kbd> helper class, specifying a fifteen minute interval, which will run forever. We want this to run until the computer is shut down or the service is stopped.</p>
<p class="mce-root">If we run/debug <kbd class="calibre16">MailFilterService</kbd> now, we can watch <kbd class="calibre16">MailFilter</kbd> run. If you do this, and you're not extremely patient, I would suggest that you lower the interval to something more reasonable.</p>
<p class="mce-root">This leaves us with one final piece: the OS integration. In a nutshell, what we want to be able to do is run <kbd class="calibre16">MailFilterService</kbd> when the operating system boots up. Ideally, we'd prefer not to have ad hoc scripts cobble together to make this happen. Fortunately, we are again presented with a number of options.</p>
<p class="mce-root">We will be using the excellent Java Service Wrapper library from Tanuki Software (details of which can be found at <a href="https://wrapper.tanukisoftware.com/" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://wrapper.tanukisoftware.com</span></a>). While we can manually build the service artifacts, we'd much rather let our build do the work for us, and, of course, there's a Maven plugin, called <kbd class="calibre16">appassembler-maven-plugin</kbd>, to do just that. To integrate them both into our project, we need to modify the <kbd class="calibre16">build</kbd> section of our POM by adding the following code snippet:</p>
<pre class="calibre21">    &lt;build&gt; 
      &lt;plugins&gt; 
        &lt;plugin&gt; 
          &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; 
          &lt;artifactId&gt;appassembler-maven-plugin&lt;/artifactId&gt; 
          &lt;version&gt;2.0.0&lt;/version&gt; </pre>
<p class="mce-root">The transitive dependencies of this plugin will pull in everything we need for the Java Service Wrapper, so all we need to do is configure our usage .We start by adding an execution, telling Maven to run the <kbd class="calibre16">generate-daemons</kbd> goal when packaging the project:</p>
<pre class="calibre21">    &lt;executions&gt; 
      &lt;execution&gt; 
        &lt;id&gt;generate-jsw-scripts&lt;/id&gt; 
        &lt;phase&gt;package&lt;/phase&gt; 
        &lt;goals&gt; 
          &lt;goal&gt;generate-daemons&lt;/goal&gt; 
        &lt;/goals&gt; </pre>
<p class="mce-root">Next we need to configure the plugin, which we do with the <kbd class="calibre16">configuration</kbd> element:</p>
<pre class="calibre21">    &lt;configuration&gt; 
      &lt;repositoryLayout&gt;flat&lt;/repositoryLayout&gt; </pre>
<p class="mce-root">The <kbd class="calibre16">repositoryLayout</kbd> option tells the plugin to build a <strong class="calibre8">lib</strong> style repository, as opposed to the Maven 2 style layout, which is a number of nested directories. This is largely a style concern, at least for our purposes here, but I find it helpful to be able to scan the generated directory and see what is included at a glance.</p>
<p class="mce-root">Next, we need to define the <strong class="calibre8">daemons</strong> (another term for OS service that comes from the Unix world and which stands for <strong class="calibre8">Disk And Execution Monitor</strong>) as follows:</p>
<pre class="calibre21">    &lt;daemons&gt; 
      &lt;daemon&gt; 
        &lt;id&gt;mailfilter-service&lt;/id&gt; 
        &lt;wrapperMainClass&gt; 
          org.tanukisoftware.wrapper.WrapperSimpleApp 
        &lt;/wrapperMainClass&gt; 
        &lt;mainClass&gt; 
         com.steeplesoft.mailfilter.service.MailFilterService 
        &lt;/mainClass&gt; 
        &lt;commandLineArguments&gt; 
          &lt;commandLineArgument&gt;start&lt;/commandLineArgument&gt; 
        &lt;/commandLineArguments&gt; </pre>
<p class="mce-root">The Java Service Wrapper is a very flexible system, providing a number of ways to wrap your Java project. Our needs are simple, so we instruct it to use <kbd class="calibre16">WrapperSimpleApp</kbd> and point it to the main class, <kbd class="calibre16">MailFilterService</kbd>.</p>
<p class="mce-root">The plugin supports a couple of other service wrapper methods, but we're interested in the Java Service Wrapper, so we specify that here, with the <kbd class="calibre16">platform</kbd> element:</p>
<pre class="calibre21">        &lt;platforms&gt; 
          &lt;platform&gt;jsw&lt;/platform&gt; 
        &lt;/platforms&gt; </pre>
<p class="mce-root">Finally, we need to configure the generator, telling it which OS to support:</p>
<pre class="calibre21">        &lt;generatorConfigurations&gt; 
          &lt;generatorConfiguration&gt; 
            &lt;generator&gt;jsw&lt;/generator&gt; 
            &lt;includes&gt; 
              &lt;include&gt;linux-x86-64&lt;/include&gt; 
              &lt;include&gt;macosx-universal-64&lt;/include&gt; 
              &lt;include&gt;windows-x86-64&lt;/include&gt; 
            &lt;/includes&gt; 
          &lt;/generatorConfiguration&gt; 
        &lt;/generatorConfigurations&gt; 
      &lt;/daemon&gt; 
    &lt;/daemons&gt; </pre>
<p class="mce-root">Each of those OS definitions offers a 32-bit option that you can add if needed, but, for the sake of brevity, I've omitted them here.</p>
<p class="mce-root">When we build the app now, either via <kbd class="calibre16">mvn package</kbd> or <kbd class="calibre16">mvn install</kbd>, this plugin will generate a wrapper for our service, complete with binaries appropriate for the configured operating systems. The nice thing is that it will build wrappers for each OS, regardless of what OS the build is actually run under. For example, here's the output of building this on a Windows machine (note the Linux and Mac binaries):</p>
<div class="mce-root1"><img class="image-border38" src="Images/c1821797-8711-4f38-b469-a88c1a115075.png"/></div>
<p class="mce-root">The wrapper is capable of much, much more, so if you're interested, you can read all the details on Tanuki Software's website.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Just like that, once again, our application is <strong class="calibre8">finished</strong>. We've covered quite a bit in this chapter. We started by learning a little bit about the history and technical details of several email protocols (SMTP, POP3, and IMAP4), then learned how to interact with services based on those using the JavaMail API. In the process of doing so, we discovered the Jackson JSON Parser and used it to marshal and unmarshal POJOs to and from the disk. We used the ControlsFX class, <kbd class="calibre16">BeanPathAdapter</kbd>, to bind non-JavaFX-aware POJOs to JavaFX controls, and the Quartz Job Scheduling Library to execute code on a schedule. Finally, we wrapped up our application using the Java Service Wrapper to create installation artifacts.</p>
<p class="mce-root">We're left with what I hope is an application that is both interesting and helpful. There are several ways to improve on it, of course, if you feel so motivated. The account/rule data structure could be extended to allow defining global rules that are shared across accounts. The GUI could support viewing email in the folders on the account and generating rules based on live data. The build could be extended to create an installer for the application. You can probably think of many more. Always feel free to check out the code and hack away. If you come up with something interesting, be sure to share it, as I'd love to see what you've done.</p>
<p class="mce-root">With another project wrapped up (no pun intended), we're ready to turn our attention to another. In the next chapter, we'll spend our entire time in a GUI and build a photo management system. This will give us the opportunity to look at some of JDK's imaging handling capabilities, including the newly added TIFF support, a feature that should make image aficionados quite happy. Turn the page and let's get started!</p>


            </article>

            
        </section>
    </div>



  </body></html>