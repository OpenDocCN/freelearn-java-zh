- en: Fine-Grained Stack Tracing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精细粒度堆栈跟踪
- en: Java 9 comes with a new stack walker API that lets the program walk the calling
    stack. This is a very special functionality that is rarely needed by ordinary
    programs. The API can be useful for some very special cases--for functionality
    that is delivered by framework. So, if you want an efficient means of stack walking
    that gives you filterable access to stack trace information, you will enjoy this
    new stack walker API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9附带了一个新的堆栈遍历API，允许程序遍历调用栈。这是一个非常特殊的功能，普通程序很少需要。对于一些非常特殊的情况，API可能很有用——对于由框架提供的功能。因此，如果您想要一种高效的堆栈遍历方法，该方法可以提供可筛选的堆栈跟踪信息，您将喜欢这个新的堆栈遍历API。
- en: The API gives fast and optimized access to the call stack, implementing lazy
    access to the individual frames.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: API提供了快速和优化的对调用栈的访问，实现了对单个帧的懒访问。
- en: 'In this chapter, we cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Overview of the Java Stack
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java堆栈概述
- en: The importance of stack information
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈信息的重要性
- en: Using `StackWalker`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`StackWalker`
- en: The `StackFrame`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackFrame`'
- en: Performance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能
- en: Overview of the Java Stack
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java堆栈概述
- en: Before we dive into the stack walker, let's start by covering the Java Stack.
    This is basic stack information, not specific to the stack walker.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究堆栈遍历之前，让我们先从介绍Java堆栈开始。这是基本的堆栈信息，并不特定于堆栈遍历。
- en: The Java runtime has a class named Stack, which can be used to store objects
    using the **last-in-first-out** (**LIFO**) policy.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Java运行时有一个名为Stack的类，可以使用它来存储对象，使用的是**后进先出**（**LIFO**）策略。
- en: When arithmetic expressions are calculated they are done using a stack. If we
    add *A* and *B* in our code first *A* is pushed on the **Operand Stack**, then
    *B* is pushed on the Operand Stack and finally the addition operation is executed,
    which fetches the two topmost elements of the Operand Stack and pushes the result,
    *A* + *B* there.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算算术表达式时，它们是使用堆栈来完成的。如果我们首先在我们的代码中添加*A*和*B*，则*A*会被推送到**操作数栈**，然后*B*被推送到操作数栈，最后执行加法操作，该操作从操作数栈的顶部两个元素中获取结果，并将其推送到那里，即*A*
    + *B*。
- en: The JVM is written in C and executes calling C functions and returning from
    there. This call-return sequence is maintained using the Native Method Stack just
    like any other C program.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JVM是用C语言编写的，并执行调用C函数和从那里返回的操作。这个调用-返回序列是通过使用本地方法栈来维护的，就像任何其他C程序一样。
- en: Finally, when the JVM creates a new thread it also allocates a call stack containing
    frames that in turn contain the local variables, reference to the previous frame,
    and reference to the class that contains the executing method. When a method is
    invoked a new frame is created. The frame is destroyed when a method finishes
    its execution, in other words, returns or throws an exception. This stack, the
    Java Virtual Machine Stack, is the one that the stack walker API manages.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当JVM创建一个新的线程时，它也会分配一个包含帧的调用栈，这些帧反过来又包含局部变量、对前一个帧的引用以及对包含执行方法的类的引用。当一个方法被调用时，会创建一个新的帧。当方法完成其执行时，即返回或抛出异常时，帧会被销毁。这个栈，即Java虚拟机栈，是堆栈遍历API管理的栈。
- en: The importance of stack information
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈信息的重要性
- en: Generally speaking we need the stack information when we want to develop caller
    dependent code. Having information about the caller allows our code to make decisions
    based on that information. In general practice, it is not a good idea to make
    functionality dependent on the caller. Information that affects the behavior of
    a method should be available via parameters. Caller dependent code development
    should be fairly limited.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，当我们想要开发依赖于调用者的代码时，我们需要堆栈信息。有关调用者的信息允许我们的代码根据该信息做出决策。在一般实践中，使功能依赖于调用者不是一个好主意。影响方法行为的信息应通过参数提供。依赖于调用者的代码开发应该相当有限。
- en: The JDK accesses stack information with native methods that are not available
    to Java applications. The `SecurityManager` is a class that defines an application's
    security policy. This class checks that the caller of a reflection API is allowed
    to access the non-public members of another class. To do that it has to have access
    to the caller class and it does that through a protected native method.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: JDK使用原生方法访问堆栈信息，这些原生方法对Java应用程序不可用。`SecurityManager`是一个定义应用程序安全策略的类。这个类检查反射API的调用者是否有权访问另一个类的非公共成员。为了做到这一点，它必须能够访问调用者类，它通过一个受保护的本地方法来实现这一点。
- en: 'This is an example of implementing some security measures without having to
    walk through a stack. We open our code for external developers to use it as a
    library. We also call methods of classes provided by the library user and they
    may call back to our code. There is some code that we want to allow library users
    to call but only if they were not called from our code. If we did not want to
    allow some of the code to be accessed directly by the library using code we could
    use Java 9''s modular structure not exporting the package containing the classes
    not to be invoked. This is the reason we set the extra condition that the code
    is available for the callers from outside, except if they were called by our code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在不遍历堆栈的情况下实施某些安全措施的示例。我们向外部开发者开放我们的代码，让他们将其用作库。我们还调用库用户提供的类的方法，他们可能反过来调用我们的代码。有一些代码我们希望允许库用户调用，但前提是他们不是从我们的代码中调用的。如果我们不希望允许某些代码直接通过库代码访问，我们可以使用
    Java 9 的模块结构，不导出包含不调用类包，以此来实现。这就是我们设置额外条件的原因，即代码对来自外部的调用者可用，除非它们是由我们的代码调用的：
- en: '![](img/27cc0ba9-edab-4795-b504-d73914b599a0.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![示例](img/27cc0ba9-edab-4795-b504-d73914b599a0.png)'
- en: 'Another example is when we want to get access to a logger. Java applications
    use many different loggers and the logging system is usually very flexible so
    that the output of the different loggers can be switched on and off based on the
    actual need to introspect into the code. The most common practice is to use a
    different logger for each class and the name of the logger is usually the name
    of the class. The practice is so common that the logging framework even provides
    logger access methods that accept the reference to the class itself instead of
    the name. It essentially means that the call to get the handle of a logger looks
    something like the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是我们想要获取对日志记录器的访问权限。Java 应用程序使用许多不同的日志记录器，日志系统通常非常灵活，可以根据实际需要切换不同日志记录器的输出。最常见的方法是为每个类使用不同的日志记录器，日志记录器的名称通常是类的名称。这种做法非常普遍，以至于日志框架甚至提供了接受类引用而不是名称的日志记录器访问方法。这本质上意味着获取日志记录器句柄的调用看起来如下：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A problem can arise when we create new classes from existing classes if we forget
    to alter the name of the class name in the call for getting a new logger. This
    is not a serious problem, but it is common. In that case our code will use the
    logger of the other class and it will actually work, but may create confusion
    when we analyze the log files. It would be much nicer if we had a method that
    returns the logger that is named as the class of the caller.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们忘记更改获取新日志记录器调用中的类名时，从现有类创建新类可能会出现问题。这不是一个严重的问题，但很常见。在这种情况下，我们的代码将使用其他类的日志记录器，并且实际上可以工作，但在分析日志文件时可能会造成混淆。如果有一个方法可以返回名为调用者类的日志记录器，那就更好了。
- en: Let's continue our exploration of stack information in the next two sections
    with code snippet examples.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在下一两个部分中通过代码片段示例来探索堆栈信息。
- en: Example - Restricting callers
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 限制调用者
- en: 'In this section we develop a sample library with two methods. The `hello()`
    method prints `hello` to the standard output. The `callMe()` method accepts a
    `Runnable` as an argument and runs it. The first method however is restricted.
    It executes only if the caller is purely outside of the library. It throws an
    `IllegalCallerException` if the caller obtained the control in a way that the
    library was calling out, presumably via the second method invoking the passed
    `Runnable`. The implementation of the API is simple:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们开发了一个包含两个方法的示例库。`hello()` 方法将 `hello` 打印到标准输出。`callMe()` 方法接受一个 `Runnable`
    参数并运行它。然而，第一个方法是受限的。它仅在调用者完全在库外部时执行。如果调用者以库调用 `Runnable` 的方式获得控制权，则会抛出 `IllegalCallerException`。API
    的实现很简单：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The code that performs the eligibility checking is implemented in a separate
    class to keep things simple. We will examine that code shortly, but before that
    we look at the main code we use to start the demonstration. The main program code
    we use to demonstrate the functionality is the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 执行资格检查的代码在一个单独的类中实现，以保持简单。我们很快就会检查那段代码，但在那之前，我们来看看我们用来启动演示的主要代码。我们用来演示功能的程序代码如下：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code creates an instance of our API class and then directly invokes the
    `hello()` method. It should work and should print the characters `hello` on screen.
    The next code line asks the `callMe()` method to call back the `Runnable` provided
    in form of a lambda expression. In this case the call will fail, because the caller
    is outside but was called from inside the library.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了我们 API 类的一个实例，然后直接调用 `hello()` 方法。它应该能正常工作并在屏幕上打印出字符 `hello`。下一行代码要求 `callMe()`
    方法回调以 lambda 表达式形式提供的 `Runnable`。在这种情况下，调用将失败，因为调用者在外部，但却是从库内部被调用的。
- en: 'Let''s now look at how the eligibility check is implemented:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看如何实现资格检查：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `itIsNotCallBack()` method is the one called from the `hello()` method.
    This method creates a stack walker and invokes the `walk()` method. The argument
    of the `walk()` method is a `Function` that converts a `Stream` of `StackFrame`
    objects to some other value that the `walk()` method will return.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`itIsNotCallBack()` 方法是从 `hello()` 方法中调用的一个方法。此方法创建了一个栈跟踪器并调用了 `walk()` 方法。`walk()`
    方法的参数是一个 `Function`，它将 `StackFrame` 对象的 `Stream` 转换为 `walk()` 方法将返回的其他值。'
- en: At first this argument setting might seem complex and difficult to understand.
    It would be more logical to return a `Stream` that provides the `StackFrame` objects
    instead of forcing the caller to define a `Function` that will get this as an
    argument.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个参数设置可能看起来很复杂且难以理解。返回一个提供 `StackFrame` 对象的 `Stream` 可能会更合理，而不是强迫调用者定义一个将作为参数获取此值的
    `Function`。
- en: 'The sample code uses a lambda expression to define the `Function` as an argument
    to the `walk()` method. The argument to the lambda expression `s` is the stream.
    Since the first element of this stream is the actual call we drop it. Because
    these calls should also be refused if the caller is not eligible even though the
    call to method `hello()` was through some other class and method that is already
    inside the library, we drop all elements from the frame that belong to classes
    inside the package of the class `CheckEligibility`. This package is `packt.java9.deep.stackwalker.myrestrictivelibrary`
    and in the code this string is stored in the field `packageName`. The resulting
    stream contains only the `StackFrame` objects that are from outside of the library.
    We drop these also until the stream exhausts or until we find a `StackFrame` that
    again belongs to the library. If all elements were dropped we are good. In this
    case the result of `count()` is zero. If we find some class in the `StackFrame`
    that belongs to the library it means that the outside code was called from the
    library and in this case we have to refuse working. In this case the variable
    eligible will be `false` and we throw an exception, as can be seen in the following
    screenshot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码使用 lambda 表达式来定义 `Function` 作为 `walk()` 方法的参数。lambda 表达式的参数 `s` 是流。由于此流的第一个元素是实际调用，所以我们丢弃它。因为这些调用也应该在调用者不符合条件时被拒绝，即使调用
    `hello()` 方法是通过库内部的其他类和方法进行的，我们也丢弃属于 `CheckEligibility` 类包内的所有帧元素。此包是 `packt.java9.deep.stackwalker.myrestrictivelibrary`，在代码中这个字符串存储在字段
    `packageName` 中。结果流只包含来自库外部的 `StackFrame` 对象。我们也丢弃这些，直到流耗尽或直到我们找到一个再次属于库的 `StackFrame`。如果所有元素都被丢弃，我们就成功了。在这种情况下，`count()`
    的结果为零。如果我们找到 `StackFrame` 中的某个类属于库，这意味着外部代码是从库中调用的，在这种情况下我们必须拒绝工作。在这种情况下，变量 `eligible`
    将为 `false`，并且我们抛出一个异常，如以下截图所示：
- en: '![](img/33ee8105-e133-4af2-a10e-ea2ae43cf043.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/33ee8105-e133-4af2-a10e-ea2ae43cf043.png)'
- en: Example - Getting logger for caller
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 获取调用者的日志记录器
- en: To get a logger, Java 9 has a new API. Using this API a module can provide an
    implementation for the service `LoggerFinder`, which in turn can return a `Logger`
    implementing the `getLogger()` method. This eliminates the dependency of libraries
    on specific loggers or logger facades, which is a huge advantage. The smaller
    but still annoying issue requiring us to write the name of the class again as
    the parameter to the method `getLogger()` is still there.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取一个日志记录器，Java 9 有一个新的 API。使用此 API，一个模块可以为服务 `LoggerFinder` 提供一个实现，该服务反过来可以返回实现
    `getLogger()` 方法的 `Logger`。这消除了库对特定日志记录器或日志记录器外观的依赖，这是一个巨大的优势。但仍然存在一个较小但仍然令人烦恼的问题，需要我们再次将类的名称作为
    `getLogger()` 方法的参数写入。这个问题仍然存在。
- en: 'To avoid this cumbersome task, we create a helper class that looks up the caller
    class and retrieves the logger that is suitable for the caller class and module.
    Because in this case there is no need for all the classes referenced in the stack
    trace we will call the `getCallerClass()` method of the `StackWalker` class. We
    create a class named `Labrador` in the package `packt.java9.deep.stackwalker.logretriever`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这项繁琐的任务，我们创建了一个辅助类，该类查找调用者类并检索适合调用者类和模块的记录器。因为在这种情况下，我们不需要在堆栈跟踪中引用的所有类，我们将调用
    `StackWalker` 类的 `getCallerClass()` 方法。我们在包 `packt.java9.deep.stackwalker.logretriever`
    中创建了一个名为 `Labrador` 的类：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Before Java 9 the solution for this issue was getting the `StackTrace` array
    from the `Thread` class and looking up the name of the caller class from there.
    Another approach was extending the `SecurityManager` that has a protected method
    `getClassContext()` that returns an array of all the classes on the stack. Both
    solutions walk through the stack and compose an array although we only need one
    element from the array. In case of logger retrieval it may not be a significant
    performance penalty since loggers are usually stored in `private static final`
    fields and thus are initialized once per class during class initialization. In
    other use cases the performance penalty may be significant.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 之前，解决此问题的方法是获取 `Thread` 类的 `StackTrace` 数组，并从那里查找调用者类的名称。另一种方法是扩展具有受保护方法
    `getClassContext()` 的 `SecurityManager`，该方法返回堆栈上所有类的数组。这两种解决方案都会遍历堆栈并组成一个数组，尽管我们只需要数组中的一个元素。在日志检索的情况下，由于记录器通常存储在
    `private static final` 字段中，因此每个类在类初始化期间只初始化一次，因此性能惩罚可能并不显著。在其他用例中，性能惩罚可能非常显著。
- en: After we have seen two examples we will look at the details of `StackWalker`
    inner working.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看过两个示例之后，我们将查看 `StackWalker` 内部工作的细节。
- en: Working with StackWalker
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 StackWalker
- en: 'In this section you will become more familiar with how to work with `StackWalker`.
    We will explore the following topics in this section:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将更熟悉如何与 `StackWalker` 一起工作。在本节中，我们将探讨以下主题：
- en: Getting an instance of `StackWalker`
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 `StackWalker` 实例
- en: Stack walking options
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈遍历选项
- en: Getting an instance of StackWalker
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取 `StackWalker` 实例
- en: 'To perform the walking over the stack elements we need an instance of the stack
    walker. To do that, we invoke the `getInstance()` method. As shown here, there
    are four overloaded versions of this method:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要在栈元素上执行遍历，我们需要一个栈遍历器的实例。为此，我们调用 `getInstance()` 方法。如图所示，此方法有四个重载版本：
- en: '`static StackWalker getInstance()`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static StackWalker getInstance()`'
- en: '`static StackWalker getInstance(StackWalker.Option option)`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static StackWalker getInstance(StackWalker.Option option)`'
- en: '`static StackWalker getInstance(Set<StackWalker.Option> options)`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static StackWalker getInstance(Set<StackWalker.Option> options)`'
- en: '`static StackWalker getInstance(Set<StackWalker.Option> options, int estimateDepth)`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static StackWalker getInstance(Set<StackWalker.Option> options, int estimateDepth)`'
- en: 'The first version does not take any arguments and returns a `StackWalker` instance
    that will let us walk through normal stack frames. This is usually what we would
    be interested in. The other versions of the method accept a `StackWalker.Option`
    value or values. The enum `StackWalker.Option,` as the name suggests, is inside
    the class `StackWalker` and has three values:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个版本不接受任何参数，并返回一个 `StackWalker` 实例，该实例将允许我们遍历正常的栈帧。这通常是我们感兴趣的。该方法的其他版本接受 `StackWalker.Option`
    值或值。枚举 `StackWalker.Option`，如名称所示，位于 `StackWalker` 类中，有三个值：
- en: '`RETAIN_CLASS_REFERENCE`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RETAIN_CLASS_REFERENCE`'
- en: '`SHOW_REFLECT_FRAMES`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHOW_REFLECT_FRAMES`'
- en: '`SHOW_HIDDEN_FRAMES`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHOW_HIDDEN_FRAMES`'
- en: These `enum` options have self-descriptive names and are explained in the next
    sections.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `enum` 选项具有自描述的名称，并在下一节中解释。
- en: RETAIN_CLASS_REFERENCE
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RETAIN_CLASS_REFERENCE
- en: If we specify the first option `enum` constant, `RETAIN_CLASS_REFERENCE,` as
    an argument to the `getInstance()` method then the returned instance grants us
    access to the classes that the individual stack frames reference during the walking.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将第一个选项 `enum` 常量 `RETAIN_CLASS_REFERENCE,` 作为 `getInstance()` 方法的参数，那么返回的实例将使我们能够访问在遍历过程中各个栈帧所引用的类。
- en: SHOW_REFLECT_FRAMES
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SHOW_REFLECT_FRAMES
- en: The `SHOW_REFLECT_FRAMES enum` constant will generate a walker that includes
    the frames that source from some reflective calling.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHOW_REFLECT_FRAMES enum` 常量将生成一个包括来自某些反射调用的帧的遍历器。'
- en: SHOW_HIDDEN_FRAMES
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SHOW_HIDDEN_FRAMES
- en: Finally the `enum` constant option, `SHOW_HIDDEN_FRAMES` will include all the
    hidden frames, which contain reflective calls as well as call frames that are
    generated for lambda function calls.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，枚举常量选项 `SHOW_HIDDEN_FRAMES` 将包括所有隐藏帧，这些帧包含反射调用以及为 lambda 函数调用生成的调用帧。
- en: 'Here is a simple demonstration of reflective and hidden frames:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个关于反射和隐藏帧的简单演示：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The main method allowing us to execute this code directly calls the method
    `simpleCall()`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 允许我们直接执行此代码的 `main()` 方法调用 `simpleCall()` 方法：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The method `simpleCall()` simply calls on as the name suggests:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `simpleCall()` 如其名所示，只是简单地调用：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The next method in the chain is a bit more complex. Although this also only
    calls the next one, it does so using reflection:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 链中的下一个方法稍微复杂一些。尽管这也只是调用下一个方法，但它使用反射来做到这一点：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this next example, we have a method that calls using a lambda:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们有一个使用 lambda 调用的方法：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The last method before the actual walking is called `walk()`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '实际行走前的最后一种方法被称为 `walk()`:'
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding `walk()` method calls three methods, one after the other. These
    methods are very similar to each other and provided here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `walk()` 方法依次调用三个方法。这些方法非常相似，这里提供它们：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding three methods print out the frames to the standard output. They
    use the `forEach()` method of the stack walker. Here is the output of the stack
    walking program:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的三个方法将帧打印到标准输出。它们使用堆栈跟踪器的 `forEach()` 方法。以下是堆栈跟踪程序输出：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This output only contains the frames that belong to calls that are in our code.
    The `main()` method calls `simpleCall()`, which calls `reflectCall()`, that in
    turn calls `lambdaCall()`, which calls a lambda expression, that calls `walk()`
    and so on. The fact that we did not specify any option does not delete the lambda
    call from the stack. We performed that call, thus it must be there. What it deletes
    are the extra stack frames that are needed by the JVM to implement the lambda.
    We can see on the next output, when the option was `SHOW_REFLECT_FRAMES,` that
    the reflective frames are already there:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出仅包含属于我们代码中调用的帧。`main()` 方法调用 `simpleCall()`，它又调用 `reflectCall()`，然后 `reflectCall()`
    调用 `lambdaCall()`，`lambdaCall()` 调用一个 lambda 表达式，该表达式调用 `walk()`，依此类推。我们没有指定任何选项并不意味着
    lambda 调用会从堆栈中删除。我们执行了那个调用，因此它必须在那里。它删除的是 JVM 实现 lambda 所需要的额外堆栈帧。我们可以在下一个输出中看到，当选项是
    `SHOW_REFLECT_FRAMES` 时，反射帧已经存在：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case the difference is that we can see that the call from the `reflectCall()`
    method to `lambdaCall()` method is not direct. The `reflectCall()` method calls
    the `invoke()` method that calls another method of the same name defined in a
    different class that in turn calls the `invoke0()` method, which is a native method
    provided by the JVM. After that we finally get to the `lambdaCall()` method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，区别在于我们可以看到 `reflectCall()` 方法调用 `lambdaCall()` 方法不是直接的。`reflectCall()`
    方法调用 `invoke()` 方法，它又调用另一个在另一个类中定义的同名方法，然后该方法调用 JVM 提供的本地方法 `invoke0()`。之后我们最终到达
    `lambdaCall()` 方法。
- en: In the output we can also see that these reflective calls belong to the module
    `java.base` and not our `stackwalker` module.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中我们还可以看到，这些反射调用属于 `java.base` 模块，而不是我们的 `stackwalker` 模块。
- en: 'If we include the hidden frames in addition to the reflective frames, specifying
    the option `SHOW_HIDDEN_FRAMES`, then we will see the following output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们除了反射帧外还包含隐藏帧，指定选项 `SHOW_HIDDEN_FRAMES`，那么我们将看到以下输出：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This includes an extra hidden frame that the JVM is using to execute the lambda
    call. In addition, the reflective frames are also included.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括 JVM 用于执行 lambda 调用的额外隐藏帧。此外，还包括反射帧。
- en: Final thoughts on enum constants
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于枚举常量的最后思考
- en: We can also specify more than one option giving a set of the options. The simplest
    way of doing that is to use the static `of()` method of the `java.util.Set` interface.
    This way the `RETAIN_CLASS_REFERENCE` option can be combined with either the `SHOW_REFLECT_FRAMES`
    option or the `SHOW_HIDDEN_FRAMES` option.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定多个选项，给出一个选项集。最简单的方法是使用 `java.util.Set` 接口的静态 `of()` 方法。这样，`RETAIN_CLASS_REFERENCE`
    选项可以与 `SHOW_REFLECT_FRAMES` 选项或 `SHOW_HIDDEN_FRAMES` 选项组合。
- en: Although it is technically possible to combine `SHOW_REFLECT_FRAMES` and `SHOW_HIDDEN_FRAMES`
    as an option set, there is really no advantage in doing that. The latter includes
    the first, so the combination of the two is exactly same as the second.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然技术上可以将 `SHOW_REFLECT_FRAMES` 和 `SHOW_HIDDEN_FRAMES` 作为选项集组合，但这样做实际上并没有任何优势。后者包括前者，所以两者的组合与后者完全相同。
- en: Accessing classes
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问类
- en: When we want to access the class objects during a stack walk, we have to specify
    the `RETAIN_CLASS_REFERENCE` option. Although the `StackFrame` interface defines
    the `getClassName()` method, that could be used to access a class of the name
    using the `Class.forName()` method, doing so would not guarantee that the class
    the `StackFrame` object refers to was loaded by the same class loader as the code
    calling `Class.forName()`. In some special cases, we could end up with two different
    classes of the same name loaded by two different class loaders.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在堆栈遍历期间访问类对象时，我们必须指定`RETAIN_CLASS_REFERENCE`选项。尽管`StackFrame`接口定义了`getClassName()`方法，可以使用它通过`Class.forName()`方法访问具有该名称的类，但这样做并不能保证`StackFrame`对象引用的类是由与调用`Class.forName()`的代码相同的类加载器加载的。在某些特殊情况下，我们可能会遇到两个不同类加载器加载的两个具有相同名称的不同类。
- en: When the option is not used during the creation of the `StackWalker` instance
    then the methods that otherwise return a class object will throw an `UnsupportedOperationException`
    exception. That way `getDeclaringClass()` cannot be used on the `StackFrame` and
    `getCallerClass()` on the `StackWalker`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在创建`StackWalker`实例时没有使用选项，则其他返回类对象的方法将抛出`UnsupportedOperationException`异常。这样，就不能在`StackFrame`上使用`getDeclaringClass()`，在`StackWalker`上使用`getCallerClass()`。
- en: Walking methods
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤方法
- en: The `StackWalker` defines the `forEach()` method that expects a `Consumer` (preferably
    in the form of a lambda expression) that is invoked for each element of the stack
    trace walking up the stack. The argument to the `Consumer` method is a `StackFrame`
    object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackWalker`定义了`forEach()`方法，该方法期望一个`Consumer`（最好是lambda表达式形式），它会对堆栈跟踪中的每个元素进行调用。`Consumer`方法的参数是一个`StackFrame`对象。'
- en: Although a method named `forEach` is also defined by the `Stream` interface
    and the method `walk()` passes a `Stream` object to the `Function` it gets as
    argument, we should not confuse the two. The `forEach()` method of `StackWalker`
    is a simpler, and most of the time less effective way to get through all the elements
    of the stack trace.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Stream`接口也定义了一个名为`forEach`的方法，并且`walk()`方法将一个`Stream`对象传递给作为参数的`Function`，但我们不应混淆这两个方法。`StackWalker`的`forEach()`方法是一个更简单、大多数情况下效果较差的方法，用于遍历堆栈跟踪的所有元素。
- en: It is less effective, in most cases, because it forces the `StackWalker` instance
    to get all the elements of the stack trace so that the `forEach()` method can
    traverse through each element to the end. If we know that we will not traverse
    through the stack trace to the end we should use the `walk()` method that is accessing
    the stack the lazy way and thus leave more room for performance optimization.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这种方法效果较差，因为它迫使`StackWalker`实例获取堆栈跟踪的所有元素，以便`forEach()`方法可以遍历每个元素到末尾。如果我们知道我们不会遍历堆栈跟踪到末尾，我们应该使用`walk()`方法，它以懒惰的方式访问堆栈，从而为性能优化留出更多空间。
- en: The `StackWalker` class has the `walk()` method, which is the defining method
    that makes it a walker. The method accepts a `Function` that is called by the
    `StackWalker`. The return value of the `walk()` method will be the object returned
    by the `Function`. The argument to the `Function` is a `Stream<StackFrame>` that
    delivers the stack frames. The first frame is the one that contains the `walk()`
    method call, the next is the one that was calling method that contains the call
    to `walk()`, and so on.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackWalker`类有一个`walk()`方法，这是定义其作为遍历者的方法。该方法接受一个由`StackWalker`调用的`Function`。`walk()`方法的返回值将是`Function`返回的对象。`Function`的参数是一个`Stream<StackFrame>`，它传递堆栈帧。第一个帧是包含`walk()`方法调用的帧，下一个是调用`walk()`方法的调用方法的帧，依此类推。'
- en: The `Function` can be used to calculate some value based on the `StackFrame`
    objects that come from the stream and decide if a caller is eligible calling our
    code or not.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`Function`根据从流中来的`StackFrame`对象计算一些值，并决定调用者是否有资格调用我们的代码。
- en: 'You might ponder, after reviewing the `walk()` method that needs a `Function`
    that in turn gets a `Stream<StackFrame>` as argument, why it is so complicated.
    We might wish we could get a `Stream<StackFrame>` from the `StackWalter` instance
    directly. The simplest approach would be to pass the stream back from the `Function`.
    Consider the following example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾了需要`Function`作为参数的`walk()`方法后，你可能会想，为什么它如此复杂。我们可能希望我们能直接从`StackWalter`实例中获取`Stream<StackFrame>`。最简单的方法是将流从`Function`返回。考虑以下示例：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What we were doing is simply returning the stream directly from the walker call
    and walking through it afterwards doing the same calculation. Our results are
    an `IllegalStateException` exception instead of the eligibility check.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是简单地从walker调用中直接返回流，并在之后遍历它执行相同的计算。我们的结果是返回一个`IllegalStateException`异常，而不是执行资格检查。
- en: The reason for that is that the implementation of the `StackWalker` is highly
    optimized. It does not copy the whole stack to provide source information for
    the stream. It works from the actual, living stack. To do that it has to be sure
    that the stack is not modified while the stream is in use. This is something very
    similar to the `ConcurrentModificationException` that we might get if we alter
    a collection while we iterate over it. If we passed the stream up in the call
    stack and then wanted to get the `StackFrame` out of it, the stream would try
    to get the information from the stack frame that is long gone, since we returned
    from the method that it belonged to. That way the `StackWalker` does not make
    a snapshot of the whole stack but rather it works from the actual one and it must
    ensure that the part of the stack it needs does not change. We may call methods
    from the `Function` and that way we can dig deeper in the call chain but we cannot
    get higher while the stream is in use.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于`StackWalker`的实现高度优化。它不会复制整个堆栈以提供流源信息。它从实际的、活动的堆栈工作。为了做到这一点，它必须确保在流使用期间堆栈不会被修改。这与我们在迭代集合时更改集合可能会得到的`ConcurrentModificationException`非常相似。如果我们把流传递到调用栈中，然后想要从中获取`StackFrame`，由于我们从属于它的方法返回了，流将尝试从已经消失的堆栈帧中获取信息。这样，`StackWalker`不会对整个堆栈进行快照，而是从实际的堆栈工作，并且必须确保它需要的堆栈部分不会改变。我们可能从`Function`中调用方法，这样我们可以在调用链中深入挖掘，但在流使用期间我们不能向上移动。
- en: Also do not try to play other tricks, like extending the `StackWalker` class.
    You cannot. It is a `final` class.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 也不要尝试玩其他技巧，比如扩展`StackWalker`类。你不能。它是一个`final`类。
- en: StackFrame
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StackFrame
- en: In previous sections, we iterated through the `StackFrame` elements, and provided
    sample code snippets, but did not take the time to examine it more closely. `StackFrame`
    is an interface defined inside the `StackWalker` class. It defines accessors,
    and a converter that can be used to convert the information to `StackTraceElement`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们遍历了`StackFrame`元素，并提供了示例代码片段，但没有花时间更仔细地检查它。`StackFrame`是定义在`StackWalker`类内部的一个接口。它定义了访问器，以及一个可以将信息转换为`StackTraceElement`的转换器。
- en: 'The accessors the interface defines are the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义的访问器如下：
- en: '`getClassName()` will return the binary name of the class of the method represented
    by the `StackFrame`.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getClassName()`将返回由`StackFrame`表示的方法的类的二进制名称。'
- en: '`getMethodName()` will return the name of the method represented by the `StackFrame`.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getMethodName()`将返回由`StackFrame`表示的方法名。'
- en: '`getDeclaringClass()` will return the class of the method represented by the
    `StackFrame`. If the `Option.RETAIN_CLASS_REFERENCE` was not used during the creation
    of the `StackWalker` instance then the method will throw `UnsupportedOperationException`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDeclaringClass()`将返回由`StackFrame`表示的方法的类。如果在创建`StackWalker`实例时没有使用`Option.RETAIN_CLASS_REFERENCE`，则该方法将抛出`UnsupportedOperationException`。'
- en: '`getByteCodeIndex()` gets the index to the code array containing the execution
    point of the method represented by the `StackFrame`. The use of this value can
    be helpful during bug hunting when looking at the disassembled Java code that
    the command line tool `javap` can give us. The programmatic use of this value
    can only be valuable for applications that have direct access to the byte code
    of the code, java agents or libraries that generate byte code during run-time.
    The method will return a negative number in case the method is native.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getByteCodeIndex()`获取包含由`StackFrame`表示的方法执行点的代码数组的索引。在查找由命令行工具`javap`提供的反汇编Java代码时，使用此值可能有助于调试。此值的程序化使用仅对具有直接访问代码字节码的应用程序有价值，例如java代理或运行时生成字节码的库。如果方法是本地的，该方法将返回一个负数。'
- en: '`getFileName()` returns the name of the source file the method represented
    by the `StackFrame` was defined.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFileName()`返回由`StackFrame`表示的方法定义的源文件名。'
- en: '`getLineNumber()` returns the line number of the source code.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getLineNumber()`返回源代码的行号。'
- en: '`isNativeMethod()` returns `true` if the method represented by the `StackFrame`
    is native and `false` otherwise.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isNativeMethod()`如果`StackFrame`表示的方法是本地的，则返回`true`，否则返回`false`。'
- en: The `StackFrame` does not provide any means to access the object that the method
    belongs to. You cannot access the arguments and the local variables of the method
    represented by the `StackFrame` and there is no other way you can accomplish that.
    This is important. Such access would be too invasive and is not possible.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackFrame`不提供任何访问方法所属对象的方法。你不能访问由`StackFrame`表示的方法的参数和局部变量，也没有其他方法可以完成这个任务。这是很重要的。这样的访问会过于侵入性，并且是不可能的。'
- en: Performance
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能
- en: Our coverage of `StackWalker` would not be complete without a look at performance
    considerations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不查看性能考虑因素，我们对`StackWalker`的覆盖就不会完整。
- en: '`StackWalker` is highly optimized and does not create huge memory structures
    that go unused. That is the reason why we have to use that `Function` passed to
    the method `walker()` as an argument. This is also the reason why a `StackTrace`
    is not automatically converted to a `StackTraceElement` when created. This only
    happens if we query the method name, the line number of the specific `StackTraceElement`.
    It is important to understand that this conversion takes a significant amount
    of time and if it was used for some debug purpose in the code it should not be
    left there.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackWalker`高度优化，不会创建大量未使用的内存结构。这就是为什么我们必须使用传递给`walker()`方法作为参数的`Function`的原因。这也是为什么`StackTrace`在创建时不会自动转换为`StackTraceElement`的原因。这只有在查询特定`StackTraceElement`的方法名和行号时才会发生。理解这一点很重要，因为这个转换需要相当多的时间，如果它被用于代码中的某些调试目的，那么它不应该被留下。'
- en: To make the `StackWalker` even faster we can provide an estimate about the number
    of `StackFrame` elements that we will work with in the stream. If we do not provide
    such an estimate, the current implementation in the JDK will use eight `StackFrame`
    objects pre-allocated and when that is exhausted, the JDK will allocate more.
    The JDK will allocate the number of elements based on our estimate unless we estimate
    a value larger than 256\. In that case, the JDK will use 256.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`StackWalker`更快，我们可以提供一个关于我们将要处理的`StackFrame`元素数量的估计。如果我们不提供这样的估计，JDK当前实现将使用预先分配的八个`StackFrame`对象，当这些用完时，JDK将分配更多的。JDK将根据我们的估计分配元素的数量，除非我们估计的值大于256。在这种情况下，JDK将使用256。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use the `StackWalker` and provided example
    code. Our detailed review of the API included different usage scenarios, options,
    and information. We explained the API's complexity and shared how and how not
    to use the class. We closed with some related performance issues that the user
    has to be aware of.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用`StackWalker`并提供了示例代码。我们对API的详细审查包括了不同的使用场景、选项和信息。我们解释了API的复杂性，并分享了如何以及如何不使用该类。我们以一些用户必须注意的相关性能问题结束。
- en: In our next chapter, we will cover over a dozen Java Enhancement Proposals that
    were incorporated in the Java 9 platform. The featured changes will cover a wide
    range of tools and updates to APIs that are aimed at making developing with Java
    easier and the ability to create optimized Java applications. We will look at
    the new HTTP client, changes to the Javadoc and Doclet API, the new JavaScript
    parser, JAR and JRE changes, the new Java-level JVM compiler interface, support
    for TIFF images, platform logging, XML catalog support, collections, new platform-specific
    desktop features, and enhancements to method handling and the depreciation annotation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们接下来的章节中，我们将涵盖十几个被纳入Java 9平台的Java增强提案。这些重点变更将覆盖广泛的工具和API更新，旨在使使用Java开发更加容易，并能够创建优化的Java应用程序。我们将探讨新的HTTP客户端、Javadoc和Doclet
    API的变更、新的JavaScript解析器、JAR和JRE的变更、新的Java级别JVM编译器接口、对TIFF图像的支持、平台日志记录、XML目录支持、集合、新的平台特定桌面功能，以及方法处理和弃用注解的增强。
