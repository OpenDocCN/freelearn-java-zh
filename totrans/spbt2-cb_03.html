<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Web Framework Behavior Tuning</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will learn about the following topics:</p>
<ul>
<li>Configuring route matching patterns</li>
<li>Configuring custom static path mappings</li>
<li>Tuning Tomcat via ServletWebServerFactory</li>
<li>Choosing embedded servlet containers</li>
<li>Adding custom connectors</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>In <a href="bd85f38d-1b98-47d6-a98a-b22f4478f68e.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Configuring Web Applications</em>, we explored how to configure web applications in Spring Boot with our custom filters, interceptors, and so on. We will continue to look further into enhancing our web application by doing behavior tuning, configuring the custom routing rules and patterns, adding additional static asset paths, adding and modifying servlet container connectors, and other properties such as enabling SSL.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring route matching patterns</h1>
                </header>
            
            <article>
                
<p>When we build web applications, it is not always the case that a default out-of-the-box mapping configuration is applicable. At times, we want to create RESTful URLs that contain characters such as <span>dot</span> (<kbd><span>.</span></kbd>), which Spring treats as a delimiter-defining format, like <kbd>path.xml</kbd>; or we might not want to recognize a trailing slash, and so on. Conveniently, Spring provides us with a way to accomplish this with ease.</p>
<p>In <a href="bd85f38d-1b98-47d6-a98a-b22f4478f68e.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Configuring Web Applications</em>, we introduced a <kbd>WebConfiguration</kbd> class, which extends from <kbd>WebMvcConfigurerAdapter</kbd>. This extension allows us to override methods that are geared toward adding filters, formatters, and many more. It also has methods that can be overridden in order to configure the path match, among other things.</p>
<p>Let's imagine that the ISBN format does allow the use of dots to separate the book number from the revision with a pattern looking like <kbd>[isbn-number].[revision]</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We will configure our application to not use the suffix pattern match of <kbd>.*</kbd> and to not strip the values after the dot when parsing the parameters. Let's perform the following steps:</p>
<ol>
<li>Let's add the necessary configuration to our <kbd>WebConfiguration</kbd> class with the following content:</li>
</ol>
<pre style="padding-left: 60px">@Override 
public void 
  configurePathMatch(PathMatchConfigurer configurer) { 
    configurer.setUseSuffixPatternMatch(false). 
      setUseTrailingSlashMatch(true); 
} </pre>
<ol start="2">
<li>Start the application by running <kbd>./gradlew clean bootRun</kbd>.</li>
</ol>
<ol start="3">
<li>Let's open <kbd>http://localhost:8080/books/978-1-78528-415-1.1</kbd> in the browser to see the following results:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="221" src="assets/c52ee837-9990-4b10-b1f9-51044d7eb0e8.png" width="454"/></div>
<ol start="4">
<li>If we enter the correct ISBN, we will see a different result, as follows:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="222" src="assets/e98c6bbe-749f-4f4a-a5eb-08980ad983a1.png" width="454"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's look at what we did in detail. The <kbd>configurePathMatch(PathMatchConfigurer configurer)</kbd> method gives us the ability to set our own behavior in how we want Spring to match the request URL path to the controller parameters:</p>
<ul>
<li><kbd>configurer.setUseSuffixPatternMatch(false)</kbd>: This method indicates that we don't want to use the <kbd>.*</kbd> suffix, so as to strip the trailing characters after the last dot. This means that Spring parses out the entire <kbd>978-1-78528-415-1.1</kbd> ISBN as an <kbd>{isbn}</kbd> parameter for <kbd>BookController</kbd>. So, <kbd>http://localhost:8080/books/978-1-78528-415-1.1</kbd> and <kbd>http://localhost:8080/books/978-1-78528-415-1</kbd> will become different URLs.</li>
<li><kbd>configurer.setUseTrailingSlashMatch(true)</kbd>: This method indicates that we want to use the trailing <kbd>/</kbd> symbol in the URL as a match as if it were not there. This effectively makes <kbd>http://localhost:8080/books/978-1-78528-415-1</kbd> the same as <kbd>http://localhost:8080/books/978-1-78528-415-1/</kbd>.</li>
</ul>
<p>If you want to do further configuration of how the path matching takes place, you can provide your own implementation of <kbd>PathMatcher</kbd> and <kbd>UrlPathHelper</kbd>, but these would be required in the most extreme and custom-tailored situations and are not generally recommended.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring custom static path mappings</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, we looked at how to tune the URL path mapping for requests and translate them into controller methods. It is also possible to control how our web application deals with static assets and the files that exist on the filesystem or are bundled in the deployable archive.</p>
<p>Let's say that we want to expose our internal <kbd>application.properties</kbd> file via the static web URL of <kbd>http://localhost:8080/internal/application.properties</kbd> from our application. To get started with this, proceed with the steps in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Let's add a new method, <kbd>addResourceHandlers</kbd>, to the <kbd>WebConfiguration</kbd> class with the following content:</li>
</ol>
<pre style="padding-left: 60px">@Override 
public void addResourceHandlers(ResourceHandlerRegistry registry) { 
    registry.addResourceHandler("/internal/**")<br/>            .addResourceLocations("classpath:/"); 
}</pre>
<ol start="2">
<li>Start the application by running <kbd>./gradlew clean bootRun</kbd></li>
<li>Let's open <kbd>http://localhost:8080/internal/application.properties</kbd> in the browser to see the following results:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="223" src="assets/79dd9179-12be-47de-8845-f1e1e9e9717b.png" width="452"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The method that we overrode, <kbd>addResourceHandlers(ResourceHandlerRegistry registry)</kbd>, is another configuration method from <kbd>WebMvcConfigurer</kbd>, which gives us the ability to define custom mappings for static resource URLs and connect them with the resources on the filesystem or application classpath. In our case, we defined a mapping of anything that is being accessed via the <kbd>/ internal</kbd> URL to be looked for in the <kbd>classpath:/</kbd> path of our application (for the production environment, you probably don't want to expose the entire classpath as a static resource!).</p>
<p>So let's look at what we did in detail, as follows:</p>
<ul>
<li>The <kbd>registry.addResourceHandler("/internal/**")</kbd> method adds a resource handler to the registry to handle our static resources, and returns  <kbd>ResourceHandlerRegistration</kbd> to us, which can be used to further configure the mapping in a chained fashion. The <kbd>/internal/**</kbd> is a path pattern that will be used to match against the request URL using <kbd>PathMatcher</kbd>. We have seen how <kbd>PathMatcher</kbd> can be configured in the previous example, but by default an <kbd>AntPathMatcher</kbd> implementation is used. We can configure more than one URL pattern to be matched to a particular resource location.</li>
<li>The <kbd>addResourceLocations("classpath:/")</kbd> method is called on the newly created instance of <kbd>ResourceHandlerRegistration</kbd>, and it defines the directories where the resources should be loaded from. These should be valid filesystems or classpath directories, and more than one can be entered. If multiple locations are provided, they will be checked in the order in which they were entered.</li>
</ul>
<p>We can also configure a caching interval for the given resource using the <kbd>setCachePeriod(Integer cachePeriod)</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tuning Tomcat via ServletWebServerFactory</h1>
                </header>
            
            <article>
                
<p>Spring Boot exposes many of the server properties that can be used to configure things such as PORT, SSL, and others by simply setting the values in <kbd>application.properties</kbd>. However, if we need to do any more complex tuning, Spring Boot provides us with a <kbd>ServletWebServerFactory</kbd> interface to programmatically define our configuration.</p>
<p>Even though the session timeout can be easily configured by setting the <kbd>server.session.timeout</kbd> property in <kbd>application.properties</kbd> to our desired value in seconds, we will do it using <kbd>ServletWebServerFactory</kbd> to demonstrate how it is done.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Let's say that we want our session to be for one minute. To make this happen, we will ad a <kbd>ServletWebServerFactory</kbd> bean to our <kbd>WebConfiguration</kbd> class with the following content:</li>
</ol>
<pre style="padding-left: 60px">@Bean<br/>public ServletWebServerFactory servletContainer() {    <br/>  TomcatServletWebServerFactory tomcat = <br/>         new TomcatServletWebServerFactory();<br/>  tomcat.getSession().setTimeout(Duration.ofMinutes(1));<br/>  return tomcat;<br/>}</pre>
<ol start="2">
<li>Just for the purpose of demonstration, we will get the session from the request to force its creation. To do this, we will add a new request mapping to our <kbd>BookController</kbd> class with the following content:</li>
</ol>
<pre style="padding-left: 60px">@RequestMapping(value = "/session", method = <br/>   RequestMethod.GET) 
public String getSessionId(HttpServletRequest request) { 
  return request.getSession().getId(); 
} </pre>
<ol start="3">
<li>Start the application by running <kbd>./gradlew clean bootRun</kbd>.</li>
<li>Let's open <kbd>http://localhost:8080/books/session</kbd> in the browser to see the following results:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="125" src="assets/1aa9c9a0-7a91-42e4-98a9-254bda718229.png" width="477"/></div>
<p>If we wait for more than a minute and then reload this page, the session ID will change to a different one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>ServletWebServerFactory</kbd> interface defines the <kbd>WebServer getWebServer(ServletContextInitializer... initializers)</kbd> method. Out of the box, Spring Boot provides concrete factory implementations for the <kbd>TomcatServletWebServerFactory</kbd>, <kbd>JettyServletWebServerFactory</kbd>, and <kbd>UndertowServletWebServerFactory</kbd> application servers. Since we are using Tomcat in our example, we will be using the provided <kbd>TomcatServletWebServerFactory</kbd> class to configure the behavior of the session.</p>
<p>During application startup, Spring Boot autoconfiguration detects the presence of the factory and invokes the <kbd>getWebServer(...)</kbd> method, passing the reference to a collection of <kbd>ServletContextInitializer</kbd> beans. Typically, those initializers are created and managed by Spring Boot internally, but we can always create some custom <kbd>ServletContextInitializer</kbd> beans to add custom behavior that should be executed during the startup life cycle of the application server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Choosing embedded servlet containers</h1>
                </header>
            
            <article>
                
<p>If we decide that we want to use Jetty as our servlet container, we will need to add a Jetty starter to our <kbd>build</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>As Tomcat already comes as a transitive dependency of Spring Boot, we will need to exclude it from our <kbd>build</kbd> dependency tree by adding the following to <kbd>build.gradle</kbd>:</li>
</ol>
<pre style="padding-left: 60px">configurations { 
  compile.exclude module: "spring-boot-starter-tomcat" 
}</pre>
<ol start="2">
<li>We will also need to add a <kbd>compile</kbd> dependency to our <kbd>build</kbd> dependencies on Jetty:</li>
</ol>
<pre style="padding-left: 60px">compile("org.springframework.boot:spring-boot-starter-jetty")</pre>
<ol start="3">
<li>To fix the compiler errors, we will need to remove the bean declaration of Tomcat's <kbd>RemoteIpFilter</kbd> from our <kbd>WebConfiguration</kbd> class, as the Tomcat dependency has been removed.</li>
<li>Start the application by running <kbd>./gradlew clean bootRun</kbd></li>
<li>If we now look at the console logs, we will see that our application is running in Jetty:</li>
</ol>
<pre style="padding-left: 60px"><strong>2017-12-16 --- o.eclipse.jetty.server.AbstractConnector <br/> : Started ServerConnector...</strong>
<strong>2017-12-16 ---.o.s.b.web.embedded.jetty.JettyWebServer<br/> : Jetty started on port(s) 8080 (http/1.1)...</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The reason that this works is because of Spring Boot's autoconfiguration magic. We had to remove the Tomcat dependency from the <kbd>build</kbd> file in order to prevent a dependency collision between Tomcat and Jetty. Spring Boot does a conditional scan of the classes in the classpath and depending on what it detects, it determines which servlet container will be used.</p>
<p>If we look in the <kbd>ServletWebServerFactoryAutoConfiguration</kbd> class, we will see the following conditional code that checks this:</p>
<pre style="padding-left: 60px">/** 
 * Nested configuration if Jetty is being used. 
 */ 
@Configuration 
@ConditionalOnClass({ Servlet.class, Server.class, Loader.class}) 
@ConditionalOnMissingBean(value = ServletWebServerFactory.class,  <br/>                           search = SearchStrategy.CURRENT) 
public static class EmbeddedJetty { 
 
  @Bean 
  public JettyServletWebServerFactory <br/>       JettyServletWebServerFactory() {<br/>           return new JettyServletWebServerFactory();<br/>  } 
 
}</pre>
<p>The <kbd>@ConditionalOnClass</kbd> annotation tells Spring Boot to use only the <kbd>EmbeddedJetty</kbd> configuration if the classes of Jetty, namely <kbd>org.eclipse.jetty.server.Server</kbd> and <kbd>org.eclipse.jetty.util.Loader</kbd>, are present in the classpath.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding custom connectors</h1>
                </header>
            
            <article>
                
<p>Another very common scenario in the enterprise application development and deployment is to run the application with two separate HTTP port connectors: one for HTTP and the other for HTTPS</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will start by going back to using Tomcat; so for this recipe, we will undo the changes that we implemented in the previous example.</p>
<p>In order to create an HTTPS connector, we will need a few things; but most importantly, we will need to generate the certificate keystore that is used to encrypt and decrypt the SSL communication with the browser.</p>
<p>If you are using Unix or macOS, you can do it by running the following command:</p>
<pre>    <strong>$JAVA_HOME/bin/keytool -genkey -alias tomcat -keyalg RSA</strong></pre>
<p>On Windows, this can be achieved via the following command:</p>
<pre>    <strong>"%JAVA_HOME%binkeytool" -genkey -alias tomcat -keyalg RSA</strong>  </pre>
<p>During the creation of the keystore, you should enter the information that is appropriate to you, including passwords, name, and so on. For the purpose of this book, we will use the default password: <kbd>changeit</kbd>. Once the execution is complete, a newly generated keystore file will appear in your home directory under the name: <kbd>keystore</kbd>.</p>
<div class="packt_infobox">You can find more information about preparing the certificate keystore at <a href="https://tomcat.apache.org/tomcat-8.0-doc/ssl-howto.html#Prepare_the_Certificate_Keystore"><span class="URLPACKT">https://tomcat.apache.org/tomcat-8.0-doc/ssl-howto.html#Prepare_the_Certificate_Keystore</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>With the keystore creation complete, we will need to create a separate <kbd>properties</kbd> file in order to store our configuration for the HTTPS connectors, such as port. After that, we will create a configuration property binding object and use it to configure our new connector. Perform the following steps:</p>
<ol>
<li>First, we will create a new properties file named <kbd>tomcat.https.properties</kbd> in the <kbd>src/main/resources</kbd> directory from the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">custom.tomcat.https.port=8443 
custom.tomcat.https.secure=true 
custom.tomcat.https.scheme=https 
custom.tomcat.https.ssl=true 
custom.tomcat.https.keystore=${user.home}/.keystore 
custom.tomcat.https.keystore-password=changeit </pre>
<ol start="2">
<li>Next, we will create a nested static class named <kbd>TomcatSslConnectorProperties</kbd> in our <kbd>WebConfiguration</kbd> class with the following content:</li>
</ol>
<pre style="padding-left: 60px">@ConfigurationProperties(prefix = "custom.tomcat.https") 
public static class TomcatSslConnectorProperties { 
  private Integer port; 
  private Boolean ssl = true; 
  private Boolean secure = true; 
  private String scheme = "https"; 
  private File keystore; 
  private String keystorePassword; 
  //Skipping getters and setters to save space, but we do need them 
 
  public void configureConnector(Connector connector) { 
    if (port != null) 
      connector.setPort(port); 
    if (secure != null) 
      connector.setSecure(secure); 
    if (scheme != null) 
      connector.setScheme(scheme); 
    if (ssl!= null) 
      connector.setProperty("SSLEnabled", ssl.toString()); 
    if (keystore!= null &amp;&amp;keystore.exists()) { 
      connector.setProperty("keystoreFile", <br/>         keystore.getAbsolutePath());      <br/>      connector.setProperty("keystorePassword", <br/>         keystorePassword); 
    } 
  } 
}</pre>
<ol start="3">
<li>Now, we will need to add our newly created <kbd>tomcat.http.properties</kbd> file as a Spring Boot property source and enable <kbd>TomcatSslConnectorProperties</kbd> to be bound. This can be done by adding the following code right prior to the class declaration of the <kbd>WebConfiguration</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">@Configuration 
@PropertySource("classpath:/tomcat.https.properties") 
@EnableConfigurationProperties(WebConfiguration.TomcatSslConnectorProperties.class) 
public class WebConfiguration extends WebMvcConfigurerAdapter {...}</pre>
<ol start="4">
<li>Finally, we will need to modify a <kbd>ServletWebServerFactory</kbd> Spring bean, where we will add our HTTPS connector. We will do that by changing the following code in the <kbd>WebConfiguration</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">@Bean<br/>public ServletWebServerFactory servletContainer<br/>            (TomcatSslConnectorProperties properties) {<br/>    TomcatServletWebServerFactory tomcat = <br/>        new TomcatServletWebServerFactory();<br/>    tomcat.addAdditionalTomcatConnectors<br/>        (createSslConnector(properties));<br/>    tomcat.getSession().setTimeout(Duration.ofMinutes(1));<br/>    return tomcat;<br/>}<br/>private Connector createSslConnector<br/>            (TomcatSslConnectorProperties properties) { 
    Connector connector = new Connector(); 
    properties.configureConnector(connector); 
    return connector; 
} </pre>
<ol start="5">
<li>Start the application by running <kbd>./gradlew clean bootRun</kbd>.</li>
</ol>
<ol start="6">
<li>Let's open <kbd>https://localhost:8443/internal/tomcat.https.properties</kbd> in the browser to see the following results:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="163" src="assets/df9a6406-13c4-482a-a005-259cec02915c.png" width="549"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we did a number of things; so let's break them down one change at a time.</p>
<p>The first change, ignoring the need to create the keystore, was the creation of the <kbd>tomcat.https.properties</kbd> and <kbd>TomcatSslConnectorProperties</kbd> objects to bind them to. Previously, we already dealt with making changes to the various settings in <kbd>application.properties</kbd> when configuring our datasource. At that time, though, we did not have to create any binding objects because Spring Boot already had them defined.</p>
<p>As we learned earlier, Spring Boot already exposes many properties to configure the application settings, including a whole set of settings for the <kbd>server</kbd> section. These values get bound to an internal Spring Boot class: <kbd>ServerProperties</kbd></p>
<div class="packt_infobox">A complete list of the common application properties can be found in the Spring Boot reference documentation at <a href="http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html"><span class="URLPACKT">http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html</span></a>.</div>
<p>What we did with our addition was simply mimic Spring Boot and create our own configuration group with a binding object behind it. The reason that we didn't use the already existing <kbd>server.tomcat.</kbd> prefix, and instead opt for <kbd>custom.tomcat</kbd>, was mostly governed by the need to separate our config values from the default ones. Since we are adding a second connector, we want to have a clean separation between the default configuration properties and our custom ones.</p>
<p>The <kbd>@ConfigurationProperties(prefix = "custom.tomcat.https")</kbd> method is an important annotation for our <kbd>TomcatSslConnectorProperties</kbd> object. It tells Spring Boot to automatically bind the properties with the <kbd>custom.tomcat.https</kbd> prefix to fields that are declared in <kbd>TomcatSslConnectorProperties</kbd>. In order for the binding to take place—in addition to defining the fields in the class—it is very important to define the getters and setters as well. It is also worth mentioning that during the binding process, Spring will automatically try to convert the property values to their appropriate data types. For example, the value of <kbd>custom.tomcat.https.keystore</kbd> gets automatically bound to a private file keystore field object.</p>
<div class="packt_infobox">The converters, which we learned about earlier, will also be used during the process of converting to custom-defined data types.</div>
<p>The next step is to tell Spring Boot to include the properties that are defined in <kbd>tomcat.https.properties</kbd> in the list of properties. This is achieved by adding <kbd>@PropertySource("classpath:/tomcat.https.properties")</kbd> next to <kbd>@Configuration</kbd> in the <kbd>WebConfiguration</kbd> class.</p>
<p>After the values are imported, we will need to tell Spring Boot to automatically create an instance of <kbd>TomcatSslConnectorProperties</kbd> for us to use. This is done by adding the following annotation next to <kbd>@Configuration</kbd>:</p>
<pre>@EnableConfigurationProperties(WebConfiguration.TomcatSslConnectorProperties.class)</pre>
<p>This will instruct Spring Boot to automatically create a bean of type <kbd>TomcatSslConnectorProperties</kbd> and bind it with the values from the specified <kbd>classpath:/tomcat.https.properties</kbd> file. This bean can later be used for autowiring into different places, such as when we create a <kbd>ServletWebServerFactory</kbd> bean.</p>
<p>After all the property support is set and done, we will proceed with the actual code to create a second connector. The creation of the <kbd>ServletWebServerFactory</kbd> bean provides Spring Boot with a factory to use in order to create  <kbd>WebServer</kbd>. The convenient <kbd>configureConnector(Connector connector)</kbd> method, which we added to <kbd>TomcatSslConnectorProperties</kbd>, gives us a good place to encapsulate and consolidate all the settings that are needed to configure the newly created <kbd>Connector</kbd> instance.</p>


            </article>

            
        </section>
    </body></html>