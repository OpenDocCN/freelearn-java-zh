- en: Fork/Join Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fork/Join 框架
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating a fork/join pool
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 fork/join 池
- en: Joining the results of the tasks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联合任务的结果
- en: Running tasks asynchronously
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步运行任务
- en: Throwing exceptions in the tasks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任务中抛出异常
- en: Canceling a task
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消任务
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Normally, when you implement a simple, concurrent Java application, you implement
    some `Runnable` objects and then the corresponding `Thread` objects. You control
    the creation, execution, and status of those threads in your program. Java 5 introduced
    an improvement with the `Executor` and `ExecutorService` interfaces and the classes
    that implement them (for example, the `ThreadPoolExecutor` class).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你实现一个简单的并发 Java 应用程序时，你会实现一些 `Runnable` 对象，然后是相应的 `Thread` 对象。你在程序中控制这些线程的创建、执行和状态。Java
    5 通过引入 `Executor` 和 `ExecutorService` 接口及其实现类（例如，`ThreadPoolExecutor` 类）进行了改进。
- en: The **Executor** framework separates the task creation and its execution. With
    it, you only have to implement the `Runnable` objects and use an `Executor` object.
    You send the `Runnable` tasks to the executor and it creates, manages, and finalizes
    the necessary threads to execute those tasks.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**Executor** 框架将任务创建和执行分离。使用它，你只需实现 `Runnable` 对象并使用一个 `Executor` 对象。你将 `Runnable`
    任务发送给执行器，然后它创建、管理和最终化执行这些任务所需的线程。'
- en: Java 7 goes a step further and includes an additional implementation of the
    `ExecutorService` interface oriented to a specific kind of problem. It's the **fork/join
    framework**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7 进一步发展，并包括了一个面向特定问题的 `ExecutorService` 接口的额外实现。它是 **fork/join 框架**。
- en: 'This framework is designed to solve problems that can be broken into smaller
    tasks using the divide and conquer technique. Inside a task, you check the size
    of the problem you want to resolve, and if it''s bigger than an established size,
    you divide it into smaller tasks that are executed using the framework. If the
    size of the problem is smaller than the established size, you solve the problem
    directly in the task, and then, optionally, it returns a result. The following
    diagram summarizes this concept:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架旨在解决可以使用分治技术分解为更小任务的问题。在一个任务内部，你检查你想要解决的问题的大小，如果它大于一个设定的阈值，你将其分解为更小的任务，这些任务使用框架执行。如果问题的大小小于设定的阈值，你直接在任务中解决问题，然后，可选地，返回一个结果。以下图表总结了这一概念：
- en: '![](img/00033.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00033.jpeg)'
- en: There is no formula to determine the reference size of a problem that determines
    if a task is to be subdivided or not, depending on its characteristics. You can
    use the number of elements to process in the task and an estimation of the execution
    time to determine the reference size. Test different reference sizes to choose
    the best one for your problem. You can consider `ForkJoinPool` as a special kind
    of `Executor`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 没有公式可以确定问题的参考大小，这决定了任务是否要细分，取决于其特征。你可以使用任务中要处理的元素数量和执行时间的估计来确定参考大小。测试不同的参考大小，以选择最适合你问题的最佳选项。你可以将
    `ForkJoinPool` 视为一种特殊的 `Executor`。
- en: 'The framework is based on the following two operations:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架基于以下两个操作：
- en: '**Fork operation**: When you divide a task into smaller tasks and execute them
    using the framework.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fork 操作**：当你将任务分解为更小的任务并使用框架执行它们时。'
- en: '**Join operation**: When a task waits for the finalization of the tasks it
    has created. It''s used to combine the results of those tasks.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Join 操作**：当一个任务等待其创建的任务的最终化。它用于合并这些任务的结果。'
- en: The main difference between the fork/join and the Executor frameworks is the
    **work-stealing** algorithm. Unlike the Executor framework, when a task is waiting
    for the finalization of the subtasks it has created using the join operation,
    the thread that is executing that task (called **worker thread**) looks for other
    tasks that have not been executed yet and begins their execution. In this way,
    the threads take full advantage of their running time, thereby improving the performance
    of the application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: fork/join 框架和 Executor 框架之间的主要区别是 **工作窃取** 算法。与 Executor 框架不同，当任务正在等待使用 join
    操作创建的子任务的最终化时，执行该任务的线程（称为 **工作线程**）会寻找尚未执行的其他任务，并开始它们的执行。通过这种方式，线程充分利用它们的运行时间，从而提高应用程序的性能。
- en: 'To achieve this goal, the tasks executed by the fork/join framework have the
    following limitations:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一目标，由 fork/join 框架执行的任务有以下限制：
- en: Tasks can only use the `fork()` and `join()` operations as synchronization mechanisms.
    If they use other synchronization mechanisms, the worker threads can't execute
    other tasks when they are in the synchronization operation. For example, if you
    put a task to sleep in the fork/join framework, the worker thread that is executing
    that task won't execute another one during the sleeping time.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务只能使用`fork()`和`join()`操作作为同步机制。如果它们使用其他同步机制，当它们处于同步操作时，工作线程无法执行其他任务。例如，如果在fork/join框架中将任务挂起，执行该任务的线程在挂起期间不会执行另一个任务。
- en: Tasks should not perform I/O operations such as read or write data in a file.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务不应执行I/O操作，例如在文件中读取或写入数据。
- en: Tasks can't throw checked exceptions. They have to include the code necessary
    to process them.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务不能抛出受检异常。它们必须包含处理它们的必要代码。
- en: 'The core of the fork/join framework is formed by the following two classes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: fork/join框架的核心由以下两个类组成：
- en: '`ForkJoinPool`: This class implements the `ExecutorService` interface and the
    work-stealing algorithm. It manages the worker threads and offers information
    about the status of the tasks and their execution.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForkJoinPool`：这个类实现了`ExecutorService`接口和工作窃取算法。它管理工作线程并提供有关任务状态及其执行的信息。'
- en: '`ForkJoinTask`: This is the base class of the tasks that will execute in the `ForkJoinPool`.
    It provides the mechanisms to execute the `fork()` and `join()` operations inside
    a task and the methods to control the status of the tasks. Usually, to implement
    your fork/join tasks, you will implement a subclass of three subclasses of this
    class: `RecursiveAction` for tasks with no return result, `RecursiveTask` for
    tasks that return one result, and `CountedCompleter` for tasks that launch a completion
    action when all the subtasks have finished.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForkJoinTask`：这是将在`ForkJoinPool`中执行的任务的基类。它提供了在任务内部执行`fork()`和`join()`操作的机制以及控制任务状态的方法。通常，为了实现你的fork/join任务，你将实现这个类的三个子类之一：`RecursiveAction`用于没有返回结果的任务，`RecursiveTask`用于返回一个结果的任务，以及`CountedCompleter`用于在所有子任务完成后启动完成动作的任务。'
- en: Most of the features provided by this framework were included in Java 7, but
    Java 8 included minor features in it. It included a default `ForkJoinPool` object.
    You can obtain it using the static method, `commonPool()`, of the `ForkJoinPool`
    class. This default fork/join executor will by default use the number of threads
    determined by the available processors of your computer. You can change this default
    behavior by changing the value of the system property, `java.util.concurrent.ForkJoinPool.common.parallelism`.
    This default pool is used internally by other classes of the Concurrency API.
    For example, **Parallel Streams** use it. Java 8 also included the `CountedCompleter`
    class mentioned earlier.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架提供的多数特性都包含在Java 7中，但Java 8在其中添加了一些小特性。它包括了一个默认的`ForkJoinPool`对象。你可以使用`ForkJoinPool`类的静态方法`commonPool()`来获取它。默认的fork/join执行器将默认使用由你的计算机可用的处理器数量确定的线程数。你可以通过更改系统属性`java.util.concurrent.ForkJoinPool.common.parallelism`的值来改变这种默认行为。这个默认池被并发API的其他类内部使用。例如，**并行流**使用它。Java
    8还包含了之前提到的`CountedCompleter`类。
- en: This chapter presents five recipes that show you how to work efficiently with
    the fork/join framework.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了五个配方，展示了如何高效地使用fork/join框架。
- en: Creating a fork/join pool
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个fork/join池
- en: 'In this recipe, you will learn how to use the basic elements of the fork/join
    framework. This includes the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，你将学习如何使用fork/join框架的基本元素。这包括以下内容：
- en: Creating a `ForkJoinPool` object to execute the tasks
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个用于执行任务的`ForkJoinPool`对象
- en: Creating a subclass of `ForkJoinTask` to be executed in the pool
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在池中执行创建`ForkJoinTask`的子类
- en: 'The main characteristics of the fork/join framework you''re going to use in
    this example are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要使用的fork/join框架的主要特性如下：
- en: You will create `ForkJoinPool` using the default constructor.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将使用默认构造函数创建`ForkJoinPool`。
- en: 'Inside the task, you will use the structure recommended by the Java API documentation:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任务内部，你将使用Java API文档推荐的结构：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will execute the tasks in a synchronized way. When a task executes two or
    more subtasks, it waits for their finalizations. In this way, the thread that
    was executing that task (called worker thread) will look for other tasks to execute,
    taking full advantage of their execution time.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将以同步方式执行任务。当一个任务执行两个或多个子任务时，它将等待它们的完成。这样，执行该任务的线程（称为工作线程）将寻找其他任务来执行，充分利用它们的执行时间。
- en: The tasks you're going to implement won't return any result, so you'll take
    the `RecursiveAction` class as the base class for their implementation.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将要实现的任务不会返回任何结果，因此你将`RecursiveAction`类作为它们实现的基础类。
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example in this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDEs, such as NetBeans, open it and create a new Java project.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱中的示例已使用Eclipse IDE实现。如果你使用Eclipse或其他IDE，如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: In this recipe, you are going to implement a task to update the price of a list
    of products. The initial task will be responsible for updating all the elements
    in a list. You will use a size 10 as the reference size, so if a task has to update
    more than 10 elements, it divides the part of the list assigned to it in two parts
    and creates two tasks to update the prices of the products in the respective parts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将实现一个更新一系列产品价格的任务。初始任务将负责更新列表中的所有元素。你将使用大小为10作为参考大小，因此如果一个任务需要更新超过10个元素，它将把分配给它的列表部分分成两部分，并创建两个任务来更新相应部分的产品价格。
- en: 'Follow these steps to implement the example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Product` that will store the name and price of a product:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Product`的类来存储产品的名称和价格：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Declare a private `String` attribute named `name` and a `private` double attribute
    named `price`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`name`的私有`String`属性和一个名为`price`的私有`double`属性：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Implement getter and setter methods for those fields. They are very simple to
    implement, so its source code is not included.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现这些字段的getter和setter方法。它们非常简单实现，所以不包括其源代码。
- en: 'Create a class named `ProductListGenerator` to generate a list of random products:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ProductListGenerator`的类来生成一系列随机产品：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Implement the `generate()` method. It receives an `int` parameter with the
    size of the list and returns a `List<Product>` object with the list of generated
    products:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现接收一个带有列表大小的`int`参数的`generate()`方法。它返回一个包含生成产品列表的`List<Product>`对象：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create the object to return the list of products:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个对象以返回产品列表：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Generate the list of products. Assign the same price to all of the products,
    for example, `10`, to check that the program works well:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成产品列表。将相同的单价分配给所有产品，例如`10`，以检查程序是否运行良好：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a class named `Task`. Specify that it extends the `RecursiveAction`
    class:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类。指定它扩展`RecursiveAction`类：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Declare a `private List<Product>` attribute named products:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`products`的私有`List<Product>`属性：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Declare two private `int` attributes named `first` and `last`. These attributes
    will determine the block of products this task has to process:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个名为`first`和`last`的私有`int`属性。这些属性将确定任务需要处理的产品的块：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Declare a private `double` attribute named `increment` to store the increment
    of the price of the products:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`increment`的私有`double`属性来存储产品价格的增量：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Implement the constructor of the class that will initialize all the attributes
    of the class:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，用于初始化类的所有属性：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Implement the `compute()` method, which will implement the logic of the task:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为`compute()`的方法，该方法将实现任务的逻辑：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the difference of the `last` and `first` attributes is less than `10` (the
    task has to update the price of less than `10` products), increment the price
    of that set of products using the `updatePrices()` method:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`last`和`first`属性之间的差异小于`10`（任务需要更新少于`10`个产品），使用`updatePrices()`方法增加该组产品的价格：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the difference between the `last` and `first` attributes is greater than
    or equal to `10`, create two new `Task` objects, one to process the first half
    of the products and the other to process the second half, and execute them in
    `ForkJoinPool` using the `invokeAll()` method:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`last`和`first`属性之间的差异大于或等于`10`，创建两个新的`Task`对象，一个用于处理产品的前半部分，另一个用于处理后半部分，并使用`invokeAll()`方法在`ForkJoinPool`中执行它们：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Implement the `updatePrices()` method. This method updates the products that
    occupy the positions between the values of the `first` and `last` attributes in
    the list of products:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`updatePrices()`方法。此方法更新列表中`first`和`last`属性之间的位置所占据的产品：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并添加`main()`方法来实现示例的主类：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a list of `10000` products using the `ProductListGenerator` class:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ProductListGenerator`类创建一个包含`10000`个产品的列表：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a new `Task` object to update the `prices` of all the products in the
    list. The parameter `first` takes the value `0` and the `last` parameter takes
    the value `10000` (the size of the product list):'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Task`对象来更新列表中所有产品的`prices`。参数`first`取值为`0`，`last`参数取值为`10000`（产品列表的大小）：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a `ForkJoinPool` object using the constructor without parameters:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不带参数的构造函数创建一个`ForkJoinPool`对象：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Execute the task in the pool using the `execute()` method:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`execute()`方法在池中执行任务：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Implement a block of code that shows information about the evolution of the
    pool every five milliseconds, writing to the console the value of some parameters
    of the pool until the task finishes its execution:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个每五毫秒显示池进化的代码块，将池的一些参数的值写入控制台，直到任务完成其执行：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Shut down the pool using the `shutdown()` method:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法关闭池：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Check if the task has finished without errors with the `isCompletedNormally()`
    method and in that case, write a message to the console:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`isCompletedNormally()`方法检查任务是否无错误地完成，并在这种情况下向控制台写入一条消息：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The expected price of all the products, after the increment, is `12`. Write
    the name and price of all the products that have a price difference of `12` to
    check that all of them have increased their price correctly:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有产品在增加后的预期价格是`12`。将所有价格差异为`12`的产品名称和价格写入，以检查它们的价格是否都正确增加：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Write a message to indicate the finalization of the program:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入一条消息以指示程序的最终化：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, you created a `ForkJoinPool` object and a subclass of the `ForkJoinTask`
    class that you executed in the pool. To create the `ForkJoinPool` object, you
    used the constructor without arguments, so it will be executed with its default
    configuration. It creates a pool with a number of threads equal to the number
    of processors of the computer. When the `ForkJoinPool` object is created, those
    threads are created and they wait in the pool until some tasks arrive for their
    execution.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你创建了一个`ForkJoinPool`对象和一个在池中执行的`ForkJoinTask`类的子类。为了创建`ForkJoinPool`对象，你使用了不带参数的构造函数，因此它将以默认配置执行。它创建了一个具有与计算机处理器数量相等的线程数量的池。当创建`ForkJoinPool`对象时，那些线程会被创建并在池中等待，直到有任务到达以供执行。
- en: Since the `Task` class doesn't return a result, it extends the `RecursiveAction`
    class. In the recipe, you used the recommended structure for the implementation
    of the task. If the task has to update more than `10` products, it divides that
    set of elements into two blocks, creates two tasks, and assigns a block to each
    task. You used the `first` and `last` attributes in the `Task` class to know the
    range of positions that this task has to update in the list of products. You used
    the `first` and `last` attributes to use only one copy of the product list and
    not create different lists for each task.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Task`类不返回结果，它扩展了`RecursiveAction`类。在配方中，你使用了推荐的实现任务的架构。如果任务需要更新超过`10`个产品，它将那个元素集分成两个块，创建两个任务，并将一个块分配给每个任务。你使用了`Task`类中的`first`和`last`属性来知道这个任务在产品列表中需要更新的位置范围。你使用`first`和`last`属性来仅使用一个产品列表的副本，而不是为每个任务创建不同的列表。
- en: To execute the subtasks that a task creates, it calls the `invokeAll()` method.
    This is a synchronous call, and the task waits for the finalization of the subtasks
    before continuing (potentially finishing) its execution. While the task is waiting
    for its subtasks, the worker thread that was executing it takes another task waiting
    for execution and executes it. With this behavior, the fork/join framework offers
    more efficient task management than the `Runnable` and `Callable` objects themselves.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行任务创建的子任务，它调用`invokeAll()`方法。这是一个同步调用，任务在继续（可能完成）其执行之前等待子任务的最终化。当任务等待其子任务时，执行它的工作线程会获取另一个等待执行的任务并执行它。通过这种行为，fork/join框架提供了比`Runnable`和`Callable`对象本身更有效的任务管理。
- en: The `invokeAll()` method of the `ForkJoinTask` class is one of the main differences
    between the Executor and the fork/join framework. In the Executor framework, all
    the tasks have to be sent to the executor while in this case, the tasks include
    methods to execute and control the tasks inside the pool. You used the `invokeAll()`
    method in the `Task` class, which extends the `RecursiveAction` class, which in
    turn extends the `ForkJoinTask` class.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForkJoinTask` 类的 `invokeAll()` 方法是 Executor 和 fork/join 框架之间主要区别之一。在 Executor
    框架中，所有任务都必须发送到执行器，而在这个例子中，任务包括在池内执行和控制任务的方法。你在扩展了 `RecursiveAction` 类的 `Task`
    类中使用了 `invokeAll()` 方法，而 `RecursiveAction` 类又扩展了 `ForkJoinTask` 类。'
- en: You sent a unique task to the pool to update all the lists of products using
    the `execute()` method. In this case, it's an asynchronous call, and the main
    thread continues its execution.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 `execute()` 方法向池中发送了一个独特的任务来更新所有产品列表。在这种情况下，这是一个异步调用，主线程继续执行。
- en: You used some methods of the `ForkJoinPool` class to check the status and the
    evolution of the tasks that are running. The class includes more methods that
    can be useful for this purpose. See the *Monitoring a fork/join pool* recipe in
    [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736), *Testing Concurrent
    Applications* for a complete list of those methods.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用了 `ForkJoinPool` 类的一些方法来检查正在运行的任务的状态和演变。该类包括更多可用于此目的的方法。请参阅第 9 章 *监控 fork/join
    池* 菜单，*测试并发应用程序*，以获取这些方法的完整列表。
- en: Finally, like with the Executor framework, you should finish `ForkJoinPool`
    using the `shutdown()` method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，就像使用 Executor 框架一样，你应该使用 `shutdown()` 方法来结束 `ForkJoinPool`。
- en: 'The following screenshot shows part of an execution of this example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此示例的部分执行过程：
- en: '![](img/00034.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00034.jpeg)'
- en: You can see the tasks finishing their work and the price of the products updated.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到任务完成工作，产品价格更新。
- en: There's more...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `ForkJoinPool` class provides other methods to execute a task. These methods
    are as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForkJoinPool` 类提供了其他方法来执行任务。这些方法如下：'
- en: '`execute (Runnable task)`: This is another version of the `execute()` method
    used in the example. In this case, you send a `Runnable` task to the `ForkJoinPool`
    class. Note that the `ForkJoinPool` class doesn''t use the work-stealing algorithm
    with `Runnable` objects. It''s only used with `ForkJoinTask` objects.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute (Runnable task)`: 这是示例中使用的 `execute()` 方法的另一个版本。在这种情况下，你向 `ForkJoinPool`
    类发送一个 `Runnable` 任务。请注意，`ForkJoinPool` 类不使用 `Runnable` 对象的工作窃取算法。它仅与 `ForkJoinTask`
    对象一起使用。'
- en: '`invoke(ForkJoinTask<T> task)`: While the `execute()` method makes an asynchronous
    call to the `ForkJoinPool` class, as you learned in the example, the `invoke()`
    method makes a synchronous call to the `ForkJoinPool` class. This call doesn''t
    return until the task passed as a parameter finishes its execution.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invoke(ForkJoinTask<T> task)`: 虽然 `execute()` 方法会对 `ForkJoinPool` 类进行异步调用，正如你在示例中所学，但
    `invoke()` 方法会对 `ForkJoinPool` 类进行同步调用。这个调用会一直持续到作为参数传递的任务完成执行才会返回。'
- en: You can also use the `invokeAll()` and `invokeAny()` methods declared in the
    `ExecutorService` interface. These methods receive `Callable` objects as parameters.
    The `ForkJoinPool` class doesn't use the work-stealing algorithm with the `Callable`
    objects, so you'd be better off executing them using a `ThreadPoolExecutor`.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以使用在 `ExecutorService` 接口中声明的 `invokeAll()` 和 `invokeAny()` 方法。这些方法接收 `Callable`
    对象作为参数。`ForkJoinPool` 类不使用 `Callable` 对象的工作窃取算法，因此你最好使用 `ThreadPoolExecutor` 来执行它们。
- en: 'The `ForkJoinTask` class also includes other versions of the `invokeAll()`
    method used in the example. These versions are as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForkJoinTask` 类还包括示例中使用的 `invokeAll()` 方法的其他版本。这些版本如下：'
- en: '`invokeAll(ForkJoinTask<?>... tasks)`: This version of the method uses a variable
    list of arguments. You can pass to it as parameters as many `ForkJoinTask` objects
    as you want.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokeAll(ForkJoinTask<?>... tasks)`: 这个方法版本使用可变数量的参数列表。你可以传递任意数量的 `ForkJoinTask`
    对象作为参数。'
- en: '`invokeAll(Collection<T> tasks)`: This version of the method accepts a collection
    (for example, an `ArrayList` object, a `LinkedList` object, or a `TreeSet` object)
    of objects of a generic type `T`. This generic type `T` must be the `ForkJoinTask`
    class or a subclass of it.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokeAll(Collection<T> tasks)`: 这个方法版本接受一个泛型类型 `T` 的对象集合（例如，`ArrayList` 对象、`LinkedList`
    对象或 `TreeSet` 对象）。这个泛型类型 `T` 必须是 `ForkJoinTask` 类或其子类。'
- en: Although the `ForkJoinPool` class is designed to execute an object of `ForkJoinTask`,
    you can also execute the `Runnable` and `Callable` objects directly. You may also
    use the `adapt()` method of the `ForkJoinTask` class that accepts a `Callable`
    object or a `Runnable` object and returns a `ForkJoinTask` object to execute that
    task.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`ForkJoinPool`类是为执行`ForkJoinTask`对象而设计的，但你也可以直接执行`Runnable`和`Callable`对象。你还可以使用`ForkJoinTask`类的`adapt()`方法，该方法接受一个`Callable`对象或`Runnable`对象，并返回一个`ForkJoinTask`对象以执行该任务。
- en: See also
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Monitoring a fork/join pool* recipe in [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736),
    *Testing Concurrent Applications*
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736)的*监控fork/join池*菜谱中，*测试并发应用程序*
- en: Joining the results of the tasks
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并任务的结果
- en: The fork/join framework provides the ability to execute tasks that return a
    result. This kind of tasks is implemented by the `RecursiveTask` class. This class
    extends the `ForkJoinTask` class and implements the `Future` interface provided
    by the Executor framework.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Fork/join框架提供了执行返回结果的任务的能力。这种任务通过`RecursiveTask`类实现。这个类扩展了`ForkJoinTask`类，并实现了Executor框架提供的`Future`接口。
- en: 'Inside the task, you have to use the structure recommended by the Java API
    documentation:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在任务内部，你必须使用Java API文档中推荐的架构：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If the task has to resolve a problem bigger than a predefined size, you divide
    the problem into more subtasks and execute those subtasks using the fork/join
    framework. When they finish their execution, the initiating task obtains the results
    generated by all the subtasks, groups them, and returns the final result. Ultimately,
    when the initiating task executed in the pool finishes its execution, you obtain
    its result, which is effectively the final result of the entire problem.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务需要解决比预定义大小更大的问题，你将问题分解成更多的子任务，并使用fork/join框架执行这些子任务。当它们完成执行后，启动任务将获得所有子任务生成的结果，将它们分组，并返回最终结果。最终，当在池中启动的任务完成执行时，你将获得其结果，这实际上是整个问题的最终结果。
- en: 'In this recipe, you will learn how to use this kind of problem solving with
    fork/join framework by developing an application that looks for a word in a document.
    You will implement the following two kinds of tasks:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将通过开发一个在文档中查找单词的应用程序来学习如何使用这种问题解决方法，该应用程序将实现以下两种类型的任务：
- en: A document task, which is going to search for a word in a set of lines of a
    document
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文档任务，将在文档的一组行中搜索一个单词
- en: A line task, which is going to search a word in a part of the document
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行任务，将在文档的一部分中搜索一个单词
- en: All the tasks will return the number of appearances of the word in the part
    of the document or line they process. In this recipe we will use the default fork/join
    pool provided by the Java Concurrency API.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所有任务都将返回单词在它们处理的文档部分或行中的出现次数。在这个菜谱中，我们将使用Java并发API提供的默认fork/join池。
- en: How to do it...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `DocumentMock`. It will generate a string matrix that
    will simulate a document:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`DocumentMock`的类。它将生成一个字符串矩阵，以模拟文档：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create an array of strings with some words. This array will be used in the
    generation of the strings matrix:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含一些单词的字符串数组。这个数组将用于生成字符串矩阵：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Implement the `generateDocument()` method. It receives as parameters the number
    of lines, the number of words per line, and the word the example is going to look
    for. It returns a matrix of strings:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`generateDocument()`方法。该方法接收行数、每行的单词数以及示例将要查找的单词作为参数。它返回一个字符串矩阵：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'First, create the necessary objects to generate the document-the `String` matrix
    and a `Random` object to generate random numbers:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建生成文档所需的必要对象——字符串矩阵和一个用于生成随机数的`Random`对象：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Fill the array with strings. Store in each position the string that is at a
    random position in the array of words and count the number of appearances of the
    word the program will look for in the generated array. You can use this value
    to check whether the program does its job properly:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用字符串填充数组。在每个位置存储在单词数组中随机位置的字符串，并计算程序将在生成的数组中查找的单词出现的次数。你可以使用这个值来检查程序是否正确地完成了其工作：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Write a message with the number of appearances of the word and return the matrix
    generated:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一条包含单词出现次数的消息，并返回生成的矩阵：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a class named `DocumentTask` and specify that it extends the `RecursiveTask`
    class parameterized with the `Integer` class. This class will implement the task
    that will calculate the number of appearances of the word in a set of lines:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `DocumentTask` 的类，并指定它扩展由 `Integer` 类参数化的 `RecursiveTask` 类。这个类将实现一个任务，用于计算一组行中单词出现的次数：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Declare a private `String` matrix named document and two private `int` attributes
    named `start` and `end`. Also, declare a private `String` attribute named `word`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `document` 的私有 `String` 矩阵和两个名为 `start` 和 `end` 的私有 `int` 属性。此外，声明一个名为
    `word` 的私有 `String` 属性：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Implement the constructor of the class to initialize all its attributes:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化所有属性：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Implement the `compute()` method. If the difference between the `end` and `start`
    attributes is smaller than `10`, the task calculates the number of appearances
    of a word in the lines between those positions by calling the `processLines()`
    method:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `compute()` 方法。如果 `end` 和 `start` 属性之间的差小于 `10`，任务通过调用 `processLines()` 方法计算这些位置之间的行中单词出现的次数：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Otherwise, divide the group of lines into two objects, create two new `DocumentTask`
    objects to process those two groups, and execute them in the pool using the `invokeAll()`
    method:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，将行组分成两个对象，创建两个新的 `DocumentTask` 对象来处理这两组，并使用 `invokeAll()` 方法在池中执行它们：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, add the values returned by both the tasks using the `groupResults()`
    method. Finally, return the result calculated by the task:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 `groupResults()` 方法将两个任务返回的值相加。最后，返回任务计算出的结果：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Implement the `processLines()` method. It receives the string matrix, the `start`
    attribute, the `end` attribute, and the `word` attribute the task is searching
    for as parameters:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `processLines()` 方法。它接收字符串矩阵、`start` 属性、`end` 属性以及任务正在搜索的 `word` 属性作为参数：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For every line the task has to process, create a `LineTask` object to process
    the complete line and store them in a list of tasks:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于任务必须处理的每一行，创建一个 `LineTask` 对象来处理完整行，并将它们存储在任务列表中：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Execute all the tasks in that list using the `invokeAll()` method:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `invokeAll()` 方法执行该列表中的所有任务：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Sum the value returned by all these tasks and return the result:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有这些任务返回的值相加并返回结果：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Implement the `groupResults()` method. It adds two numbers and returns the
    result:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `groupResults()` 方法。它将两个数字相加并返回结果：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a class named `LineTask` and specify that it extends the `RecursiveTask`
    class parameterized with the `Integer` class. This class will implement the task
    that will calculate the number of appearances of the word in a line:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `LineTask` 的类，并指定它扩展由 `Integer` 类参数化的 `RecursiveTask` 类。这个类将实现一个任务，用于计算一行中单词出现的次数：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Declare a private `String` array attribute named `line` and two private `int`
    attributes named `start` and `end`. Finally, declare a private `String` attribute
    named `word`:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `line` 的私有 `String` 数组属性和两个名为 `start` 和 `end` 的私有 `int` 属性。最后，声明一个名为
    `word` 的私有 `String` 属性：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Implement the constructor of the class to initialize all its attributes:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化所有属性：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Implement the `compute()` method of the class. If the difference between the
    `end` and `start` attributes is smaller than `100`, the task searches for the
    word in the fragment of the line determined by the `start` and `end` attributes
    using the `count()` method:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的 `compute()` 方法。如果 `end` 和 `start` 属性之间的差小于 `100`，任务使用 `count()` 方法在由 `start`
    和 `end` 属性确定的行片段中搜索单词：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Otherwise, divide the group of words in the line in two, create two new `LineTask`
    objects to process those two groups, and execute them in the pool using the `invokeAll()`
    method:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，将行中的单词组分成两部分，创建两个新的 `LineTask` 对象来处理这两组单词，并使用 `invokeAll()` 方法在池中执行它们：
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, add the values returned by both the tasks using the `groupResults()`
    method. Finally, return the result calculated by the task:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 `groupResults()` 方法将两个任务返回的值相加。最后，返回任务计算出的结果：
- en: '[PRE49]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Implement the `count()` method. It receives the string array with the complete
    line, the `start` attribute, the `end` attribute, and the `word` attribute the
    task is searching for as parameters:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `count()` 方法。它接收包含完整行的字符串数组、`start` 属性、`end` 属性以及任务正在搜索的 `word` 属性作为参数：
- en: '[PRE50]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Compare the words stored in the positions between the `start` and `end` attributes
    with the `word` attribute the task is searching for, and if they are equal, increment
    the `counter` variable:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较存储在`start`和`end`属性之间的位置上的单词与任务正在搜索的`word`属性，如果它们相等，则增加`counter`变量：
- en: '[PRE51]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To slow the execution of the example, put the task to sleep for `10` milliseconds:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了减慢示例的执行速度，将任务休眠`10`毫秒：
- en: '[PRE52]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Return the value of the `counter` variable:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`counter`变量的值：
- en: '[PRE53]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Implement the `groupResults()` method. It sums two numbers and returns the
    `result`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`groupResults()`方法。它将两个数字相加并返回`result`：
- en: '[PRE54]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并包含一个`main()`方法来实现示例的主类：
- en: '[PRE55]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create `Document` with `100` lines and `1000` words per line using the `DocumentMock`
    class:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`DocumentMock`类创建具有`100`行和每行`1000`个单词的`Document`：
- en: '[PRE56]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a new `DocumentTask` object to update the products of the entire document.
    The `start` parameter takes the value `0` and the `end` parameter takes the value
    `100`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`DocumentTask`对象来更新整个文档的产品。`start`参数取值为`0`，`end`参数取值为`100`：
- en: '[PRE57]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Get the default `ForkJoinPool` executor using the `commmonPool()` method and
    execute the task on it using the `execute()` method:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`commmonPool()`方法获取默认的`ForkJoinPool`执行器，并使用`execute()`方法在上面执行任务：
- en: '[PRE58]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Implement a block of code that shows information about the progress of the
    pool, writing every second to the console the value of some parameters of the
    pool until the task finishes its execution:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个代码块，显示池的进度信息，每秒将池的一些参数的值写入控制台，直到任务完成执行：
- en: '[PRE59]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Shut down the pool using the `shutdown()` method:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法关闭池：
- en: '[PRE60]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Wait for the finalization of the tasks using the `awaitTermination()` method:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`awaitTermination()`方法等待任务的最终化：
- en: '[PRE61]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Write the number of the appearances of the word in the document. Check that
    this number is the same as the number written by the `DocumentMock` class:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写出文档中单词出现的次数。检查这个数字是否与`DocumentMock`类写出的数字相同：
- en: '[PRE62]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this example, you implemented two different tasks:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你实现了两个不同的任务：
- en: '`DocumentTask`: A task of this class has to process a set of lines of the document
    determined by the `start` and `end` attributes. If this set of lines has a size
    smaller than `10`, it creates `LineTask` per line, and when they finish their
    execution, it sums the results of those tasks and returns the `result` of the
    sum. If the set of lines the task has to process has a size of `10` or bigger,
    it divides the set in two and creates two `DocumentTask` objects to process those
    new sets. When those tasks finish their execution, the tasks sum their results
    and return that sum as a `result`.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DocumentTask`：此类任务必须处理由`start`和`end`属性确定的文档的一组行。如果这组行的数量小于`10`，它将为每一行创建一个`LineTask`，当它们完成执行后，它将那些任务的结果相加并返回总和的`result`。如果任务必须处理的行组的数量为`10`或更大，它将这组行分成两部分，并创建两个`DocumentTask`对象来处理这些新组。当这些任务完成执行后，任务将它们的结果相加并返回这个总和作为`result`。'
- en: '`LineTask`: A task of this class has to process a set of words of a line of
    the document. If this set of words is smaller than `100`, the task searches the
    word directly in that set of words and returns the number of appearances of the
    word. Otherwise, it divides the set of words into two and creates two `LineTask`
    objects to process those sets. When those tasks finish their execution, the task
    sums the results of both the tasks and returns that sum as a `result`.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LineTask`：此类任务必须处理文档某一行的一组单词。如果这组单词的数量小于`100`，任务将直接在该组单词中搜索单词并返回单词出现的次数。否则，它将单词组分成两部分，并创建两个`LineTask`对象来处理这些组。当这些任务完成执行后，任务将两个任务的结果相加并返回这个总和作为`result`。'
- en: In the `Main` class, you used the default `ForkJoinPool` (obtained from the
    static method, `commonPool()`) and executed in it a `DocumentTask` class that
    has to process a document of `100` lines and `1000` words per line. This task
    will divide the problem using other `DocumentTask` objects and `LineTask` objects,
    and when all the tasks finish their execution, you can use the original task to
    get the total number of appearances of the word in the whole document. Since the
    tasks return a result, they extend the `RecursiveTask` class.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Main` 类中，你使用了默认的 `ForkJoinPool`（通过静态方法 `commonPool()` 获取）并在其中执行了一个 `DocumentTask`
    类，该类需要处理每行 `100` 行和每行 `1000` 个单词的文档。此任务将使用其他 `DocumentTask` 对象和 `LineTask` 对象来分解问题，当所有任务完成执行后，你可以使用原始任务来获取整个文档中单词出现的总数。由于任务返回结果，它们扩展了
    `RecursiveTask` 类。
- en: To obtain the result returned by `Task`, you used the `get()` method. This method
    is declared in the `Future` interface implemented by the `RecursiveTask` class.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 `Task` 返回的结果，你使用了 `get()` 方法。此方法声明在 `RecursiveTask` 类实现的 `Future` 接口中。
- en: When you execute the program, you can compare the first and the last lines written
    in the console. The first line is the number of appearances of the word calculated
    when the document is generated and the last is the same number calculated by the
    fork/join tasks.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行程序时，你可以比较在控制台写入的第一行和最后一行。第一行是文档生成时计算的单词出现次数，最后一行是 fork/join 任务计算出的相同数字。
- en: There's more...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: The `ForkJoinTask` class provides another method to finish the execution of
    a task and return a result, that is, the `complete()` method. This method accepts
    an object of the type used in the parameterization of the `RecursiveTask` class
    and returns that object as a result of the task when the `join()` method is called.
    It's use is recommended to provide results for asynchronous tasks.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForkJoinTask` 类提供了另一种完成任务执行并返回结果的方法，即 `complete()` 方法。此方法接受 `RecursiveTask`
    类参数化中使用的对象类型，并在调用 `join()` 方法时将此对象作为任务的结果返回。建议使用此方法为异步任务提供结果。'
- en: 'Since the `RecursiveTask` class implements the `Future` interface, there''s
    another version of the `get()` method:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `RecursiveTask` 类实现了 `Future` 接口，因此 `get()` 方法还有一个版本：
- en: '`get(long timeout, TimeUnit unit)`: This version of the `get()` method, if
    the result of the task isn''t available, waits the specified time for it. If the
    specified period of time passes and the result isn''t yet available, the method
    returns a `null` value. The `TimeUnit` class is an enumeration with these constants:
    `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and
    `SECONDS`.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(long timeout, TimeUnit unit)`：此版本的 `get()` 方法，如果任务的结果不可用，将等待指定的时间。如果指定的时间过去后结果仍然不可用，则方法返回一个
    `null` 值。`TimeUnit` 类是一个枚举，具有以下常量：`DAYS`、`HOURS`、`MICROSECONDS`、`MILLISECONDS`、`MINUTES`、`NANOSECONDS`
    和 `SECONDS`。'
- en: See also
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a fork/join pool* recipe in this chapter
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中 *创建 fork/join 池* 的配方
- en: The *Monitoring a fork/join pool* recipe in [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736),
    *Testing Concurrent Applications*
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 9 章](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736)中的 *监控 fork/join
    池* 配方，*测试并发应用程序*'
- en: Running tasks asynchronously
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步运行任务
- en: When you execute `ForkJoinTask` in `ForkJoinPool`, you can do it in a synchronous
    or an asynchronous way. When you do it in a synchronous way, the method that sends
    the task to the pool doesn't return until the task sent finishes its execution.
    When you do it in an asynchronous way, the method that sends the task to the executor
    returns immediately, so the task can continue with its execution.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 `ForkJoinPool` 中执行 `ForkJoinTask` 时，你可以以同步或异步的方式进行。当你以同步方式执行时，将任务发送到池中的方法不会返回，直到发送的任务完成执行。当你以异步方式执行时，将任务发送到执行器的那个方法会立即返回，因此任务可以继续执行。
- en: You should be aware of a big difference between the two methods. When you use
    the synchronous methods, the task that calls one of these methods (for example,
    the `invokeAll()` method) is suspended until the tasks it sent to the pool finish
    their execution. This allows the `ForkJoinPool` class to use the work-stealing
    algorithm to assign a new task to the worker thread that executed the sleeping
    task. On the contrary, when you use the asynchronous methods (for example, the
    `fork()` method), the task continues with its execution, so the `ForkJoinPool`
    class can't use the work-stealing algorithm to increase the performance of the
    application. In this case, only when you call the `join()` or `get()` methods
    to wait for the finalization of a task, the `ForkJoinPool` class can use that
    algorithm.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该意识到这两种方法之间有一个很大的区别。当你使用同步方法时（例如，使用 `invokeAll()` 方法），调用这些方法之一的任务（例如，`invokeAll()`
    方法）将暂停，直到它发送到池中的任务完成其执行。这允许 `ForkJoinPool` 类使用工作窃取算法将新任务分配给执行睡眠任务的工人线程。相反，当你使用异步方法（例如，使用
    `fork()` 方法）时，任务将继续执行，因此 `ForkJoinPool` 类不能使用工作窃取算法来提高应用程序的性能。在这种情况下，只有当你调用 `join()`
    或 `get()` 方法等待任务的最终化时，`ForkJoinPool` 类才能使用该算法。
- en: In addition to the `RecursiveAction` and `RecursiveTask` classes, Java 8 introduced
    a new `ForkJoinTask` class with the `CountedCompleter` class. With this kind of
    tasks, you can include a completion action that will be executed when it is launched
    and there is no pending child task. This mechanism is based on a method included
    in the class (the `onCompletion()` method) and a counter of pending tasks.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `RecursiveAction` 和 `RecursiveTask` 类之外，Java 8 引入了一个新的 `ForkJoinTask` 类，它与
    `CountedCompleter` 类一起使用。使用这类任务，你可以在启动任务且没有挂起的子任务时包含一个完成动作。这种机制基于类中包含的一个方法（即 `onCompletion()`
    方法）和挂起任务的计数器。
- en: This counter is initialized to zero by default and you can increment it when
    you need in an atomic way. Normally, you will increment this counter one by one
    as and when you launch a child task. Finally, when a task has finished its execution,
    you can try to complete the execution of the task and consequently execute the
    `onCompletion()` method. If the pending count is greater than zero, it is decremented
    by one. If it's zero, the `onCompletion()` method is executed and then the parent
    task is tried to be completed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此计数器默认初始化为零，你可以在需要时以原子方式递增它。通常，你将逐个递增此计数器，正如你启动子任务时那样。最后，当任务完成其执行时，你可以尝试完成任务的执行，并相应地执行
    `onCompletion()` 方法。如果挂起的计数大于零，则递减一个。如果为零，则执行 `onCompletion()` 方法，然后尝试完成父任务。
- en: In this recipe, you will learn how to use the asynchronous methods provided
    by the `ForkJoinPool` and `CountedCompleter` classes for the management of tasks.
    You are going to implement a program that will search for files with a determined
    extension inside a folder and its subfolders. The `CountedCompleter` class you're
    going to implement will process the contents of a folder. For each subfolder inside
    that folder, it will send a new task to the `ForkJoinPool` class in an asynchronous
    way. For each file inside that folder, the task will check the extension of the
    file and add it to the result list if it proceeds. When a task is completed, it
    will insert the result lists of all its child tasks in its result task.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，你将学习如何使用 `ForkJoinPool` 和 `CountedCompleter` 类提供的异步方法来管理任务。你将实现一个程序，该程序将在文件夹及其子文件夹中搜索具有特定扩展名的文件。你将要实现的
    `CountedCompleter` 类将处理文件夹的内容。对于该文件夹内的每个子文件夹，它将以异步方式向 `ForkJoinPool` 类发送一个新的任务。对于该文件夹内的每个文件，任务将检查文件的扩展名，并在继续的情况下将其添加到结果列表中。当一个任务完成时，它将将其子任务的全部结果列表插入其结果任务中。
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to implement the example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `FolderProcessor` and specify that it extends the `CountedCompleter`
    class parameterized with the `List<String>` type:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `FolderProcessor` 的类，并指定它扩展了参数化为 `List<String>` 类型的 `CountedCompleter`
    类：
- en: '[PRE63]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Declare a private `String` attribute named `path`. This attribute will store
    the full path of the folder the task is going to process:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `path` 的私有 `String` 属性。该属性将存储任务将要处理的文件夹的完整路径：
- en: '[PRE64]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Declare a private `String` attribute named `extension`. This attribute will
    store the name of the extension of the files the task is going to look for:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `extension` 的私有 `String` 属性。该属性将存储任务将要查找的文件的扩展名：
- en: '[PRE65]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Declare two `List` private attributes named `tasks` and `resultList`. We will
    use the first one to store all the child tasks launched from this task and the
    other one to store the list of results of this task:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个名为`tasks`和`resultList`的私有`List`属性。我们将使用第一个来存储从该任务启动的所有子任务，并使用另一个来存储该任务的结果列表：
- en: '[PRE66]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Implement one constructor for the class to initialize its attributes and its
    parent class. We declare this constructor as `protected` as it will only be used
    internally:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为该类实现一个构造函数以初始化其属性及其父类。我们将其声明为`protected`，因为它只会在内部使用：
- en: '[PRE67]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We implement the other public constructor to be used externally. As the task
    created by this constructor won''t have a parent task, we don''t include this
    object as a parameter:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现其他公共构造函数以供外部使用。由于此构造函数创建的任务不会有父任务，因此我们不将此对象作为参数包含：
- en: '[PRE68]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Implement the `compute()` method. As the base class of our task is the `CountedCompleter`
    class, the return type of this method is `void`:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`compute()`方法。由于我们的任务的基础类是`CountedCompleter`类，因此此方法的返回类型为`void`：
- en: '[PRE69]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'First, initialize the two list attributes:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，初始化两个列表属性：
- en: '[PRE70]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Get the contents of the folder:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取文件夹的内容：
- en: '[PRE71]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'For each element in the folder, if there is a subfolder, create a new `FolderProcessor`
    object and execute it asynchronously using the `fork()` method. We use the first
    constructor of the class and pass the current task as the completer task of the
    new one. We also increment the counter of pending tasks using the `addToPendingCount()`
    method:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于文件夹中的每个元素，如果存在子文件夹，则创建一个新的`FolderProcessor`对象，并使用`fork()`方法异步执行它。我们使用类的第一个构造函数，并将当前任务作为新任务的完成者任务传递。我们还使用`addToPendingCount()`方法增加挂起任务的计数器：
- en: '[PRE72]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Otherwise, compare the extension of the file with the extension you are looking
    for, using the `checkFile()` method, and if they are equal, store the full path
    of the file in the list of strings declared earlier:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，使用`checkFile()`方法比较文件的扩展名与您正在寻找的扩展名，如果它们相等，则将文件的完整路径存储在之前声明的字符串列表中：
- en: '[PRE73]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If the list of the `FolderProcessor` subtasks has more than `50` elements,
    write a message to the console to indicate this circumstance:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`FolderProcessor`子任务列表中的元素超过`50`个，向控制台写入一条消息以指示这种情况：
- en: '[PRE74]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Finally, try to complete the current task using the `tryComplete()` method:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，尝试使用`tryComplete()`方法完成当前任务：
- en: '[PRE75]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Implement the `onCompletion()` method. This method will be executed when all
    the child tasks (all the tasks that have been forked from the current task) have
    finished their execution. We add the result list of all the child tasks to the
    result list of the current task:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`onCompletion()`方法。当所有子任务（从当前任务分叉的所有任务）完成执行时，将执行此方法。我们将所有子任务的结果列表添加到当前任务的结果列表中：
- en: '[PRE76]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Implement the `checkFile()` method. This method compares if the name of a file
    passed as a parameter ends with the `extension` you are looking for. If so, the
    method returns the `true` value, otherwise it returns the `false` value:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`checkFile()`方法。此方法比较作为参数传递的文件名是否以您正在寻找的`extension`结尾。如果是，则方法返回`true`值，否则返回`false`值：
- en: '[PRE77]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Finally, implement the `getResultList()` method to return the result list of
    a task. The code of this method is very simple so it won't be included.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现`getResultList()`方法以返回任务的結果列表。此方法的代码非常简单，因此不会包含在内。
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并包含一个`main()`方法来实现示例的主类：
- en: '[PRE78]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Create `ForkJoinPool` using the default constructor:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用默认构造函数创建`ForkJoinPool`：
- en: '[PRE79]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Create three `FolderProcessor` tasks. Initialize each with a different folder
    path:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个`FolderProcessor`任务。初始化每个任务时使用不同的文件夹路径：
- en: '[PRE80]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Execute the three tasks in the pool using the `execute()` method:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`execute()`方法在池中执行三个任务：
- en: '[PRE81]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Write to the console information about the status of the pool every second
    until the three tasks have finished their execution:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在三个任务完成执行之前，每秒向控制台写入有关池状态的信息：
- en: '[PRE82]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Shut down `ForkJoinPool` using the `shutdown()` method:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法关闭`ForkJoinPool`：
- en: '[PRE83]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Write the number of results generated by each task to the console:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个任务生成的结果数量写入控制台：
- en: '[PRE84]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: How it works...
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following screenshot shows part of an execution of the preceding example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了先前示例的部分执行情况：
- en: '![](img/00035.jpeg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00035.jpeg)'
- en: 'The key to this example is in the `FolderProcessor` class. Each task processes
    the contents of a folder. As you know, this content has the following two kinds
    of elements:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的关键在于`FolderProcessor`类。每个任务处理一个文件夹的内容。正如你所知，这个内容有以下两种元素：
- en: Files
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件
- en: Other folders
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他文件夹
- en: If the task finds a folder, it creates another `FolderProcessor` object to process
    that folder and sends it to the pool using the `fork()` method. This method sends
    the task to the pool that will execute it if it has a free worker thread, or it
    can create a new one. The method returns immediately, so the task can continue
    processing the contents of the folder. For every file, a task compares its extension
    with the one it's looking for and, if they are equal, adds the name of the file
    to the list of `results`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务找到一个文件夹，它将创建另一个`FolderProcessor`对象来处理该文件夹，并使用`fork()`方法将其发送到池中。此方法将任务发送到将执行它的池，如果它有一个空闲的工作线程，或者它可以创建一个新的线程。该方法立即返回，因此任务可以继续处理文件夹的内容。对于每个文件，任务将其扩展名与其正在寻找的扩展名进行比较，如果它们相等，则将文件的名称添加到`results`列表中。
- en: Once the task has processed all the contents of the assigned folder, we try
    to complete the current task. As we explained in the introduction of this recipe,
    when we try to complete a task, the code of the `CountedCompleter` looks for the
    value of the pending task counter. If this value is greater than `0`, it decreases
    the value of that counter. On the contrary, if the value is `0`, the task executes
    the `onCompletion()` method and then tries to complete its parent task. In our
    case, when a task is processing a folder and it finds a subfolder, it creates
    a new child task, launches that task using the `fork()` method, and increments
    the counter of the pending tasks. So, when a task has processed its entire content,
    the counter of pending tasks of the task will be equal to the number of child
    tasks we have launched. When we call the `tryComplete()` method, if the folder
    of the current task has subfolders, this call will decrease the number of pending
    tasks. Only when all its child tasks have been completed, its `onCompletion()`
    method is executed. If the folder of the current task hasn't got any subfolders,
    the counter of pending tasks will be zero; the `onComplete()` method will be called
    immediately, and then it will try to complete its parent task. In this way, we
    create a tree of tasks from top to bottom that are completed from bottom to top.
    In the `onComplete()` method, we process all the result lists of the child tasks
    and add their elements in the result list of the current task.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦任务处理完分配文件夹的所有内容，我们就尝试完成当前任务。正如我们在本食谱的介绍中所解释的，当我们尝试完成一个任务时，`CountedCompleter`的代码会查找待处理任务计数器的值。如果这个值大于`0`，它会减少该计数器的值。相反，如果值是`0`，任务将执行`onCompletion()`方法，然后尝试完成其父任务。在我们的情况下，当一个任务正在处理一个文件夹并找到一个子文件夹时，它会创建一个新的子任务，使用`fork()`方法启动该任务，并增加待处理任务的计数器。因此，当一个任务处理完其全部内容时，该任务的待处理任务计数器将等于我们启动的子任务数量。当我们调用`tryComplete()`方法时，如果当前任务的文件夹有子文件夹，这个调用将减少待处理任务的数量。只有当所有子任务都已完成，它的`onCompletion()`方法才会被执行。如果当前任务的文件夹没有任何子文件夹，待处理任务的计数器将为零；`onComplete()`方法将立即被调用，然后它将尝试完成其父任务。这样，我们从上到下创建了一个任务树，这些任务从下到上完成。在`onCompletion()`方法中，我们处理所有子任务的输出列表，并将它们的元素添加到当前任务的输出列表中。
- en: The `ForkJoinPool` class also allows the execution of tasks in an asynchronous
    way. You used the `execute()` method to send the three initial tasks to the pool.
    In the `Main` class, you also finished the pool using the `shutdown()` method
    and wrote information about the status and the evolution of the tasks that are
    running in it. The `ForkJoinPool` class includes more methods that can be useful
    for this purpose. See the *Monitoring a fork/join pool* recipe in [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736),
    *Testing Concurrent Applications* to see a complete list of those methods.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForkJoinPool`类还允许以异步方式执行任务。你使用了`execute()`方法将三个初始任务发送到池中。在`Main`类中，你还使用`shutdown()`方法关闭了池，并写下了关于其中正在运行的任务的状态和进化的信息。`ForkJoinPool`类包括更多可用于此目的的方法。请参阅第9章中关于*监控fork/join池*的食谱，*测试并发应用程序*，以查看这些方法的完整列表。'
- en: There's more...
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In this example we used the `addToPendingCount()` method to increment the counter
    of pending tasks, but we have other methods we can use to change the value of
    this counter:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`addToPendingCount()`方法来增加待处理任务的计数器，但我们还有其他方法可以用来改变这个计数器的值：
- en: '`setPendingCount()`: This method establishes the value of the counter of pending
    tasks.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setPendingCount()`: 此方法设置待处理任务计数器的值。'
- en: '`compareAndSetPendingCount()`: This method receives two parameters. The first
    one is the expected value and the second one is the new value. If the value of
    the counter of pending tasks is equal to the expected value, establish its value
    to the new one.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compareAndSetPendingCount()`: 此方法接收两个参数。第一个是预期值，第二个是新值。如果待处理任务计数器的值等于预期值，则将其值设置为新的值。'
- en: '`decrementPendingCountUnlessZero()`: This method decrements the value of the
    counter of pending tasks unless it''s equal to zero.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decrementPendingCountUnlessZero()`: 此方法会减少待处理任务计数器的值，除非它等于零。'
- en: 'The `CountedCompleter` class also includes other methods to manage the completion
    of the tasks. The following are the most significant ones:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`CountedCompleter`类还包括其他方法来管理任务的完成。以下是最重要的几个：'
- en: '`complete()`: This method executes the `onCompletion()` method independently
    of the value of the counter of pending tasks and tries to complete its completer
    (parent) task.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`complete()`: 此方法独立于待处理任务计数器的值执行`onCompletion()`方法，并尝试完成其完成者（父）任务。'
- en: '`onExceptionalCompletion()`: This method is executed when the `completeExceptionally()`
    method has been called or the `compute()` method has thrown an `Exception`. Override
    this method to include your code to process such exceptions.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onExceptionalCompletion()`: 当调用`completeExceptionally()`方法或`compute()`方法抛出`Exception`时，此方法会被执行。重写此方法以包含处理此类异常的代码。'
- en: 'In this example, you used the `join()` method to wait for the finalization
    of tasks and get their results. You can also use one of the following two versions
    of the `get()` method with this purpose:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你使用了`join()`方法等待任务的最终化并获取其结果。你也可以使用以下两种`get()`方法版本之一来完成这个目的：
- en: '`get(long timeout, TimeUnit unit)`: This version of the `get()` method, if
    the result of the task isn''t available, waits the specified time for it. If the
    specified period of time passes and the result isn''t yet available, the method
    returns a `null` value. The `TimeUnit` class is an enumeration with the following
    constants: `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`,
    and `SECONDS`'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(long timeout, TimeUnit unit)`: 此版本的`get()`方法，如果任务的结果不可用，将等待指定的时间。如果指定的时间过去后结果仍然不可用，则方法返回一个`null`值。`TimeUnit`类是一个枚举，具有以下常量：`DAYS`、`HOURS`、`MICROSECONDS`、`MILLISECONDS`、`MINUTES`、`NANOSECONDS`和`SECONDS`'
- en: The `join()` method can't be interrupted. If you interrupt the thread that called
    the `join()` method, the method throws an `InterruptedException` exception.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join()`方法不能被中断。如果你中断了调用`join()`方法的线程，该方法会抛出`InterruptedException`异常。'
- en: See also
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a fork/join pool* recipe in this chapter
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*创建fork/join池*配方
- en: The *Monitoring a fork/join pool* recipe in [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736),
    *Testing Concurrent Applications*
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736)的*监控fork/join池*配方中，*测试并发应用程序*
- en: Throwing exceptions in the tasks
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在任务中抛出异常
- en: 'There are two kinds of exceptions in Java:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Java中有两种类型的异常：
- en: '**Checked exceptions**: These exceptions must be specified in the `throws`
    clause of a method or caught inside them. For example, `IOException` or `ClassNotFoundException`.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查型异常**: 这些异常必须在方法的`throws`子句中指定或在它们内部捕获。例如，`IOException`或`ClassNotFoundException`。'
- en: '**Unchecked exceptions**: These exceptions don''t have to be specified or caught.
    For example, `NumberFormatException`.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非检查型异常**: 这些异常不需要指定或捕获。例如，`NumberFormatException`。'
- en: You can't throw any checked exception in the `compute()` method of the `ForkJoinTask`
    class because this method doesn't include any `throws` declaration in its implementation.
    You have to include the necessary code to handle the checked exceptions. On the
    other hand, you can throw (or it can be thrown by any method or object used inside
    the method) an unchecked exception. The behavior of the `ForkJoinTask` and `ForkJoinPool`
    classes is different from what you may expect. The program doesn't finish execution
    and you won't see any information about the exception in the console. It's simply
    swallowed as if it weren't thrown. Only when you call the `get()` method of the
    initial task, the exception will be thrown. You can, however, use some methods
    of the `ForkJoinTask` class to know if a task has thrown an exception and if so,
    what kind of exception it was. In this recipe, you will learn how to get that
    information.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ForkJoinTask` 类的 `compute()` 方法中不能抛出任何已检查的异常，因为这个方法在其实现中不包含任何 `throws` 声明。您必须包含必要的代码来处理已检查的异常。另一方面，您可以抛出（或方法内部使用的任何方法或对象可以抛出）未检查的异常。`ForkJoinTask`
    和 `ForkJoinPool` 类的行为可能与你预期的不同。程序不会完成执行，你也不会在控制台看到任何关于异常的信息。它只是被默默吞没，就像它没有被抛出一样。只有当你调用初始任务的
    `get()` 方法时，异常才会被抛出。然而，您可以使用 `ForkJoinTask` 类的一些方法来了解任务是否抛出了异常，以及抛出了什么类型的异常。在本食谱中，您将学习如何获取这些信息。
- en: Getting ready
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的食谱实现使用了 Eclipse IDE。如果您使用 Eclipse 或其他如 NetBeans 之类的 IDE，请打开它并创建一个新的 Java
    项目。
- en: How to do it...
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Task`. Specify that it implements the `RecursiveTask`
    class, parameterized with the `Integer` class:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Task` 的类。指定它实现 `RecursiveTask` 类，并使用 `Integer` 类进行参数化：
- en: '[PRE85]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Declare a private `int` array named `array`. It will simulate the array of
    data you are going to process in this example:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `array` 的私有 `int` 数组。它将模拟您在本例中将要处理的数据数组：
- en: '[PRE86]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Declare two private `int` attributes named `start` and `end`. These attributes
    will determine the elements of the array this task has to process:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个名为 `start` 和 `end` 的私有 `int` 属性。这些属性将确定任务需要处理的数组元素：
- en: '[PRE87]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Implement the constructor of the class that initializes its attributes:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数，初始化其属性：
- en: '[PRE88]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Implement the `compute()` method of the task. As you have parameterized the
    `RecursiveTask` class with the `Integer` class, this method has to return an `Integer`
    object. First, write a message to the console with the value of the `start` and
    `end` attributes:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现任务的 `compute()` 方法。由于您已将 `RecursiveTask` 类参数化为 `Integer` 类，因此此方法必须返回一个 `Integer`
    对象。首先，向控制台发送一条消息，包含 `start` 和 `end` 属性的值：
- en: '[PRE89]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'If the block of elements that this task has to process, determined by the `start`
    and `end` attributes, has a size smaller than `10`, check if the element in the
    fourth position in the array (index number three) is in that block. If that is
    the case, throw `RuntimeException`. Then, put the task to sleep for a second:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果此任务需要处理的元素块（由 `start` 和 `end` 属性确定）的大小小于 `10`，则检查数组中第四个位置的元素（索引号为三）是否在该块中。如果是这样，则抛出
    `RuntimeException`。然后，让任务休眠一秒钟：
- en: '[PRE90]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Otherwise (the block of elements that this task has to process has a size of
    10 or bigger), divide the block of elements in two, create two `Task` objects
    to process those blocks, and execute them in the pool using the `invokeAll()`
    method. Then, we write the results of these tasks to the console:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则（此任务需要处理的元素块的大小为 10 或更大），将元素块分成两半，创建两个 `Task` 对象来处理这些块，并使用 `invokeAll()` 方法在池中执行它们。然后，我们将这些任务的结果写入控制台：
- en: '[PRE91]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Write a message to the console indicating the end of the task, writing the
    value of the `start` and `end` attributes:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控制台发送一条消息，指示任务的结束，并写入 `start` 和 `end` 属性的值：
- en: '[PRE92]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Return the number `0` as the result of the task:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `0` 作为任务的结果返回：
- en: '[PRE93]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `Main` 的类并包含一个 `main()` 方法来实现示例的主类：
- en: '[PRE94]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Create an array of `100` integer numbers:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含 `100` 个整数数字的数组：
- en: '[PRE95]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Create a `Task` object to process that `array`:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Task` 对象来处理那个 `array`：
- en: '[PRE96]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Create a `ForkJoinPool` object using the default constructor:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用默认构造函数创建一个 `ForkJoinPool` 对象：
- en: '[PRE97]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Execute the task in the pool using the `execute()` method:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `execute()` 方法在池中执行任务：
- en: '[PRE98]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Shut down the `ForkJoinPool` class using the `shutdown()` method:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `shutdown()` 方法关闭 `ForkJoinPool` 类：
- en: '[PRE99]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Wait for the finalization of the task using the `awaitTermination()` method.
    As you want to wait for the finalization of the task however long it takes to
    complete, pass the values `1` and `TimeUnit.DAYS` as parameters to this method:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `awaitTermination()` 方法等待任务的最终化。由于你希望无论任务完成所需时间多长都等待其最终化，因此将值 `1` 和 `TimeUnit.DAYS`
    作为参数传递给此方法：
- en: '[PRE100]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Check if the task, or one of its subtasks, has thrown an exception using the
    `isCompletedAbnormally()` method. In such a case, write a message to the console
    with the exception that was thrown. Get that exception with the `getException()`
    method of the `ForkJoinTask` class:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `isCompletedAbnormally()` 方法检查任务或其子任务是否抛出了异常。在这种情况下，将异常消息写入控制台。使用 `ForkJoinTask`
    类的 `getException()` 方法获取该异常：
- en: '[PRE101]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: How it works...
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Task` class you implemented in this recipe processes an array of numbers.
    It checks if the block of numbers it has to process has `10` or more elements.
    In that case, it splits the block in two and creates two new `Task` objects to
    process those blocks. Otherwise, it looks for the element in the fourth position
    of the array (index number three). If that element is in the block the task has
    to process, it throws `RuntimeException`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中实现的 `Task` 类处理一个数字数组。它检查它必须处理的数字块是否有 `10` 个或更多元素。在这种情况下，它将块分成两部分并创建两个新的
    `Task` 对象来处理这些块。否则，它会在数组的第四个位置（索引号为三）查找元素。如果该元素在任务必须处理的块中，它将抛出 `RuntimeException`。
- en: When you execute the program, the exception is thrown, but the program doesn't
    stop. In the `Main` class you have included a call to the `isCompletedAbnormally()`
    method of the `ForkJoinTask` class using the original task. This method returns
    `true` if that task, or one of its subtasks, has thrown an exception. You also
    used the `getException()` method of the same object to get the `Exception` object
    that it has thrown.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行程序时，会抛出异常，但程序不会停止。在 `Main` 类中，你使用原始任务调用了 `ForkJoinTask` 类的 `isCompletedAbnormally()`
    方法。如果该任务或其子任务抛出了异常，此方法返回 `true`。你还使用了同一对象的 `getException()` 方法来获取它抛出的 `Exception`
    对象。
- en: 'When you throw an unchecked exception in a task, it also affects its parent
    task (the task that sent it to the `ForkJoinPool` class) and the parent task of
    its parent task, and so on. If you revise the entire output of the program, you''ll
    see that there aren''t output messages for the finalization of some tasks. The
    starting messages of those tasks are as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在任务中抛出未检查的异常时，它也会影响其父任务（将其发送到 `ForkJoinPool` 类的任务）及其父任务的父任务，依此类推。如果你审查整个程序的输出，你会看到某些任务的最终化没有输出消息。这些任务的起始消息如下：
- en: '[PRE102]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: These tasks are the ones that threw the exception and its parent tasks. All
    of them have finished abnormally. Take this into account when you develop a program
    with the `ForkJoinPool` and `ForkJoinTask` objects that can throw exceptions if
    you don't want this behavior.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务是抛出异常及其父任务的那些任务。所有这些任务都异常完成。当你使用可能抛出异常的 `ForkJoinPool` 和 `ForkJoinTask`
    对象开发程序时，请考虑这一点，如果你不希望出现这种行为。
- en: 'The following screenshot shows part of an execution of this example:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此示例的部分执行：
- en: '![](img/00036.jpeg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00036.jpeg)'
- en: There's more...
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'In this example, you used the `join()` method to wait for the finalization
    of tasks and get their results. You can also use one of the following two versions
    of the `get()` method with this purpose:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，你使用了 `join()` 方法等待任务的最终化并获取其结果。你也可以使用以下两种 `get()` 方法的其中一种来达到此目的：
- en: '`get()`: This version of the `get()` method returns the value returned by the
    `compute()` method if `ForkJoinTask` has finished its execution, or it waits until
    its finalization.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()`: 此版本的 `get()` 方法在 `ForkJoinTask` 完成其执行后返回 `compute()` 方法返回的值，或者它等待直到其最终化。'
- en: '`get(long timeout, TimeUnit unit)`: This version of the `get()` method, if
    the result of the task isn''t available, waits the specified time for it. If the
    specified period of time passes and the result isn''t yet available, the method
    returns a `null` value. The `TimeUnit` class is an enumeration with the following
    constants: `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`,
    and `SECONDS`.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(long timeout, TimeUnit unit)`: 此版本的 `get()` 方法，如果任务的输出不可用，将等待指定的时间。如果指定的时间过去而结果仍然不可用，则方法返回一个
    `null` 值。`TimeUnit` 类是一个枚举，具有以下常量：`DAYS`、`HOURS`、`MICROSECONDS`、`MILLISECONDS`、`MINUTES`、`NANOSECONDS`
    和 `SECONDS`。'
- en: 'There are two main differences between the `get()` and `join()` methods:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`方法和`join()`方法之间有两个主要区别：'
- en: The `join()` method can't be interrupted. If you interrupt the thread that called
    the `join()` method, the method throws `InterruptedException`.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join()`方法不能被中断。如果你中断调用`join()`方法的线程，该方法会抛出`InterruptedException`。'
- en: While the `get()` method will return `ExecutionException` if the tasks throw
    any unchecked exception, the `join()` method will return `RuntimeException`.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`get()`方法会返回`ExecutionException`如果任务抛出任何未检查的异常时，`join()`方法将返回`RuntimeException`。
- en: 'You can obtain the same result obtained in the example if, instead of throwing
    an exception, you use the `completeExceptionally()` method of the `ForkJoinTask`
    class. The code would be as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是抛出异常，而是使用`ForkJoinTask`类的`completeExceptionally()`方法，你可以获得与示例中相同的结果。代码如下：
- en: '[PRE103]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: See also
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a fork/join pool* recipe in this chapter
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中创建一个**创建fork/join池**的配方
- en: Canceling a task
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消任务
- en: 'When you execute the `ForkJoinTask` objects in a `ForkJoinPool` class, you
    can cancel them before they start their execution. The `ForkJoinTask` class provides
    the `cancel()` method for this purpose. There are some points you have to take
    into account when you want to cancel a task, which are as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在`ForkJoinPool`类中执行`ForkJoinTask`对象时，你可以在它们开始执行之前取消它们。`ForkJoinTask`类提供了`cancel()`方法用于此目的。当你想要取消一个任务时，你必须注意一些要点，如下所示：
- en: The `ForkJoinPool` class doesn't provide any method to cancel all the tasks
    it has running or waiting in the pool
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForkJoinPool`类不提供任何方法来取消它在池中运行或等待的所有任务'
- en: When you cancel a task, you don't cancel the tasks this task has executed
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你取消一个任务时，你不会取消该任务已执行的任务
- en: In this recipe, you will implement an example of the cancellation of `ForkJoinTask`
    objects. You will look for the position of a number in an array. The first task
    that finds the number will cancel the remaining tasks. As that functionality is
    not provided by the fork/join framework, you will implement an auxiliary class
    to do this cancellation.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，你将实现一个取消`ForkJoinTask`对象的示例。你将查找数组中数字的位置。第一个找到数字的任务将取消其余任务。由于fork/join框架不提供此功能，你将实现一个辅助类来完成此取消。
- en: Getting ready...
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中...
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的示例已使用Eclipse IDE实现。如果您使用Eclipse或其他IDE如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `ArrayGenerator`. This class will generate an array of
    random integer numbers with the specified size. Implement a method named `generateArray()`.
    It will generate the array of numbers. It receives the size of the array as a
    parameter:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ArrayGenerator`的类。这个类将生成一个指定大小的随机整数数组。实现一个名为`generateArray()`的方法。它将生成数字数组。它接收数组的大小作为参数：
- en: '[PRE104]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Create a class named `TaskManager`. We will use this class to store all the
    tasks executed in `ForkJoinPool` used in the example. Due to the limitations of
    the `ForkJoinPool` and `ForkJoinTask` classes, you will use this class to cancel
    all the tasks of the `ForkJoinPool` class:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`TaskManager`的类。我们将使用这个类来存储示例中使用的`ForkJoinPool`中执行的所有任务。由于`ForkJoinPool`和`ForkJoinTask`类的限制，你将使用这个类来取消`ForkJoinPool`类的所有任务：
- en: '[PRE105]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Declare a list of objects parameterized with the `ForkJoinTask` class, parameterized
    with the `Integer` class named `List`:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个使用`ForkJoinTask`类参数化的对象列表，使用名为`List`的`Integer`类参数化：
- en: '[PRE106]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Implement the constructor of the class. It initializes the list of tasks:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数。它初始化任务列表：
- en: '[PRE107]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Implement the `addTask()` method. It adds a `ForkJoinTask` object to the lists
    of tasks:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`addTask()`方法。它将一个`ForkJoinTask`对象添加到任务列表中：
- en: '[PRE108]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Implement the `cancelTasks()` method. It will cancel all the `ForkJoinTask`
    objects stored in the list using the `cancel()` method. It receives as a parameter
    the `ForkJoinTask` object that wants to cancel the rest of the tasks. The method
    cancels all the tasks:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`cancelTasks()`方法。它将使用`cancel()`方法取消存储在列表中的所有`ForkJoinTask`对象。它接收一个参数，即想要取消其余任务的`ForkJoinTask`对象。该方法取消所有任务：
- en: '[PRE109]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Implement the `SearchNumberTask` class. Specify that it extends the `RecursiveTask`
    class parameterized with the `Integer` class. This class will look for a number
    in a block of elements of an integer array:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `SearchNumberTask` 的类。指定它扩展了参数化为 `Integer` 类的 `RecursiveTask` 类。这个类将在整数数组的元素块中查找一个数字：
- en: '[PRE110]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Declare a private array of `int` numbers named `numbers`:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `numbers` 的私有 `int` 数组：
- en: '[PRE111]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Declare two private `int` attributes named `start` and `end`. These attributes
    will determine the elements of the array this task has to process:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个名为 `start` 和 `end` 的私有 `int` 属性。这些属性将确定这个任务需要处理的数组元素：
- en: '[PRE112]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Declare a private `int` attribute named `number` to store the number you are
    going to look for:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `number` 的私有 `int` 属性来存储你要查找的数字：
- en: '[PRE113]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Declare a private `TaskManager` attribute named `manager`. You will use this
    object to cancel all the tasks:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `manager` 的私有 `TaskManager` 属性。你将使用这个对象来取消所有任务：
- en: '[PRE114]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Declare a private `int` constant and initialize it to `-1`. It will be the
    returned value by the task when it doesn''t find the number:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的 `int` 常量并将其初始化为 `-1`。当任务找不到数字时，它将返回这个值：
- en: '[PRE115]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE116]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Implement the `compute()` method. Start the method by writing a message to
    the console indicating the values of the `start` and `end` attributes:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `compute()` 的方法。首先，向控制台写入一条消息，指示 `start` 和 `end` 属性的值：
- en: '[PRE117]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'If the difference between the `start` and `end` attributes is greater than
    `10` (the task has to process more than `10` elements of the array), call the
    `launchTasks()` method to divide the work of this task into two subtasks:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `start` 和 `end` 属性之间的差异大于 `10`（任务需要处理数组中的超过 `10` 个元素），调用 `launchTasks()`
    方法将这个任务的工作分成两个子任务：
- en: '[PRE118]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Otherwise, look for the number in the block of the array that the task calling
    the `lookForNumber()` method has to process:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，在调用 `lookForNumber()` 方法的任务需要处理的数组块中查找数字：
- en: '[PRE119]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Return the result of the task:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回任务的结果：
- en: '[PRE120]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Implement the `lookForNumber()` method:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `lookForNumber()` 的方法：
- en: '[PRE121]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'For all the elements in the block of elements this task has to process, compare
    the value stored in that element with the number you are looking for. If they
    are equal, write a message to the console indicating, in such a circumstance,
    to use the `cancelTasks()` method of the `TaskManager` object to cancel all the
    tasks, and return the position of the element where you found the number:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个任务需要处理的元素块中的所有元素，比较该元素中存储的值与你要查找的数字。如果它们相等，向控制台写入一条消息，在这种情况下，使用 `TaskManager`
    对象的 `cancelTasks()` 方法取消所有任务，并返回找到数字的元素位置：
- en: '[PRE122]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Inside the loop, put the task to sleep for one second:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环内部，让任务休眠一秒钟：
- en: '[PRE123]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Finally, return the `-1` value:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，返回 `-1` 值：
- en: '[PRE124]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Implement the `launchTasks()` method. First, divide the block of numbers this
    task has to process into two, and then create two `Task` objects to process them:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `launchTasks()` 的方法。首先，将这个任务需要处理的数字块分成两块，然后创建两个 `Task` 对象来处理它们：
- en: '[PRE125]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Add the tasks to the `TaskManager` object:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将任务添加到 `TaskManager` 对象中：
- en: '[PRE126]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Execute the two tasks asynchronously using the `fork()` method:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `fork()` 方法异步执行两个任务：
- en: '[PRE127]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Wait for the finalization of the tasks, and return the result of the first
    task if it is not equal to `-1` or the result of the second task, otherwise:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待任务的最终化，如果第一个任务的结果不等于 `-1`，则返回第一个任务的结果，否则返回第二个任务的结果：
- en: '[PRE128]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Implement the `writeCancelMessage()` method to write a message when the task
    is canceled:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `writeCancelMessage()` 的方法，在任务被取消时写入一条消息：
- en: '[PRE129]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `Main` 的类并包含一个 `main()` 方法来实现示例的主类：
- en: '[PRE130]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Create an array of `1000` numbers using the `ArrayGenerator` class:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ArrayGenerator` 类创建一个包含 `1000` 个数字的数组：
- en: '[PRE131]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Create a `TaskManager` object:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `TaskManager` 对象：
- en: '[PRE132]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Create a `ForkJoinPool` object using the default constructor:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用默认构造函数创建一个 `ForkJoinPool` 对象：
- en: '[PRE133]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Create a `Task` object to process the array generated before:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于处理之前生成的数组的 `Task` 对象：
- en: '[PRE134]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Execute the task in the pool asynchronously using the `execute()` method:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `execute()` 方法在池中异步执行任务：
- en: '[PRE135]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Shut down the pool using the `shutdown()` method:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `shutdown()` 方法关闭池：
- en: '[PRE136]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Wait for the finalization of the tasks using the `awaitTermination()` method
    of the `ForkJoinPool` class:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ForkJoinPool` 类的 `awaitTermination()` 方法等待任务的最终化：
- en: '[PRE137]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Write a message to the console indicating the end of the program:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控制台写入一条消息，指示程序的结束：
- en: '[PRE138]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: How it works...
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `ForkJoinTask` class provides the `cancel()` method that allows you to cancel
    a task if it hasn't been executed yet. This is a very important point. If the
    task has begun its execution, a call to the `cancel()` method has no effect. The
    method receives a parameter as a `Boolean` value called `mayInterruptIfRunning`.
    This name may make you think that, if you pass the true value to the method, the
    task will be canceled even if it is running. The Java API documentation specifies
    that, in the default implementation of the `ForkJoinTask` class, this attribute
    has no effect. The tasks are only canceled if they haven't started their execution.
    The cancellation of a task has no effect over the tasks that the cancelled task
    sent to the pool. They continue with their execution.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForkJoinTask` 类提供了一个 `cancel()` 方法，允许你在任务尚未执行之前取消它。这是一个非常重要的点。如果任务已经开始执行，调用
    `cancel()` 方法将没有任何效果。该方法接收一个名为 `mayInterruptIfRunning` 的 `Boolean` 类型的参数。这个名称可能让你认为，如果你向该方法传递
    `true` 值，即使任务正在运行，任务也会被取消。Java API 文档指定，在 `ForkJoinTask` 类的默认实现中，此属性没有任何效果。只有当任务尚未开始执行时，才会取消任务。取消任务对已取消任务发送到池中的任务没有影响。它们将继续执行。'
- en: A limitation of the fork/join framework is that it doesn't allow the cancellation
    of all the tasks that are in `ForkJoinPool`. To overcome that limitation, you
    implemented the `TaskManager` class. It stores all the tasks that have been sent
    to the pool. It has a method that cancels all the tasks it has stored. If a task
    can't be canceled because it's running or has finished, the `cancel()` method
    returns the `false` value, so you can try to cancel all the tasks without being
    afraid of the possible collateral effects.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: Fork/join 框架的一个限制是它不允许取消 `ForkJoinPool` 中所有的任务。为了克服这个限制，你实现了 `TaskManager` 类。它存储了所有已发送到池中的任务。它有一个取消它存储的所有任务的方法。如果一个任务因为正在运行或已完成而无法取消，`cancel()`
    方法将返回 `false` 值，这样你就可以尝试取消所有任务，而不必担心可能的副作用。
- en: In the example, you have implemented a task that looks for a number in an array
    of numbers. You divided the problem into smaller subproblems as the fork/join
    framework recommends. You are only interested in one occurrence of the number,
    so when you find it, you cancel the other tasks.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，你实现了一个在数字数组中查找数字的任务。你按照 fork/join 框架的建议将问题分解成更小的子问题。你只对数字的一个出现感兴趣，所以当你找到它时，你取消其他任务。
- en: 'The following screenshot shows part of an execution of this example:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此示例执行的一部分：
- en: '![](img/00037.jpeg)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00037.jpeg)'
- en: See also
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a fork/join pool* recipe in this chapter
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中 *创建 fork/join 池* 的配方
