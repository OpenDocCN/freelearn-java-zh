- en: Fork/Join Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a fork/join pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joining the results of the tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tasks asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throwing exceptions in the tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canceling a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, when you implement a simple, concurrent Java application, you implement
    some `Runnable` objects and then the corresponding `Thread` objects. You control
    the creation, execution, and status of those threads in your program. Java 5 introduced
    an improvement with the `Executor` and `ExecutorService` interfaces and the classes
    that implement them (for example, the `ThreadPoolExecutor` class).
  prefs: []
  type: TYPE_NORMAL
- en: The **Executor** framework separates the task creation and its execution. With
    it, you only have to implement the `Runnable` objects and use an `Executor` object.
    You send the `Runnable` tasks to the executor and it creates, manages, and finalizes
    the necessary threads to execute those tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Java 7 goes a step further and includes an additional implementation of the
    `ExecutorService` interface oriented to a specific kind of problem. It's the **fork/join
    framework**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This framework is designed to solve problems that can be broken into smaller
    tasks using the divide and conquer technique. Inside a task, you check the size
    of the problem you want to resolve, and if it''s bigger than an established size,
    you divide it into smaller tasks that are executed using the framework. If the
    size of the problem is smaller than the established size, you solve the problem
    directly in the task, and then, optionally, it returns a result. The following
    diagram summarizes this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There is no formula to determine the reference size of a problem that determines
    if a task is to be subdivided or not, depending on its characteristics. You can
    use the number of elements to process in the task and an estimation of the execution
    time to determine the reference size. Test different reference sizes to choose
    the best one for your problem. You can consider `ForkJoinPool` as a special kind
    of `Executor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The framework is based on the following two operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fork operation**: When you divide a task into smaller tasks and execute them
    using the framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Join operation**: When a task waits for the finalization of the tasks it
    has created. It''s used to combine the results of those tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main difference between the fork/join and the Executor frameworks is the
    **work-stealing** algorithm. Unlike the Executor framework, when a task is waiting
    for the finalization of the subtasks it has created using the join operation,
    the thread that is executing that task (called **worker thread**) looks for other
    tasks that have not been executed yet and begins their execution. In this way,
    the threads take full advantage of their running time, thereby improving the performance
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this goal, the tasks executed by the fork/join framework have the
    following limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: Tasks can only use the `fork()` and `join()` operations as synchronization mechanisms.
    If they use other synchronization mechanisms, the worker threads can't execute
    other tasks when they are in the synchronization operation. For example, if you
    put a task to sleep in the fork/join framework, the worker thread that is executing
    that task won't execute another one during the sleeping time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks should not perform I/O operations such as read or write data in a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks can't throw checked exceptions. They have to include the code necessary
    to process them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The core of the fork/join framework is formed by the following two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ForkJoinPool`: This class implements the `ExecutorService` interface and the
    work-stealing algorithm. It manages the worker threads and offers information
    about the status of the tasks and their execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ForkJoinTask`: This is the base class of the tasks that will execute in theÂ `ForkJoinPool`.
    It provides the mechanisms to execute the `fork()` and `join()` operations inside
    a task and the methods to control the status of the tasks. Usually, to implement
    your fork/join tasks, you will implement a subclass of three subclasses of this
    class: `RecursiveAction` for tasks with no return result, `RecursiveTask` for
    tasks that return one result, and `CountedCompleter` for tasks that launch a completion
    action when all the subtasks have finished.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the features provided by this framework were included in Java 7, but
    Java 8 included minor features in it. It included a default `ForkJoinPool` object.
    You can obtain it using the static method, `commonPool()`, of the `ForkJoinPool`
    class. This default fork/join executor will by default use the number of threads
    determined by the available processors of your computer. You can change this default
    behavior by changing the value of the system property, `java.util.concurrent.ForkJoinPool.common.parallelism`.
    This default pool is used internally by other classes of the Concurrency API.
    For example, **Parallel Streams** use it. Java 8 also included the `CountedCompleter`
    class mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter presents five recipes that show you how to work efficiently with
    the fork/join framework.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a fork/join pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn how to use the basic elements of the fork/join
    framework. This includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a `ForkJoinPool` object to execute the tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a subclass of `ForkJoinTask` to be executed in the pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main characteristics of the fork/join framework you''re going to use in
    this example are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You will create `ForkJoinPool` using the default constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the task, you will use the structure recommended by the Java API documentation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You will execute the tasks in a synchronized way. When a task executes two or
    more subtasks, it waits for their finalizations. In this way, the thread that
    was executing that task (called worker thread) will look for other tasks to execute,
    taking full advantage of their execution time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tasks you're going to implement won't return any result, so you'll take
    the `RecursiveAction` class as the base class for their implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example in this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDEs, such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you are going to implement a task to update the price of a list
    of products. The initial task will be responsible for updating all the elements
    in a list. You will use a size 10 as the reference size, so if a task has to update
    more than 10 elements, it divides the part of the list assigned to it in two parts
    and creates two tasks to update the prices of the products in the respective parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Product` that will store the name and price of a product:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` attribute named `name` and a `private` double attribute
    named `price`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Implement getter and setter methods for those fields. They are very simple to
    implement, so its source code is not included.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a class named `ProductListGenerator` to generate a list of random products:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `generate()` method. It receives an `int` parameter with the
    size of the list and returns a `List<Product>` object with the list of generated
    products:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the object to return the list of products:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate the list of products. Assign the same price to all of the products,
    for example, `10`, to check that the program works well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Task`. Specify that it extends the `RecursiveAction`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a `private List<Product>` attribute named products:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare two private `int` attributes named `first` and `last`. These attributes
    will determine the block of products this task has to process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `double` attribute named `increment` to store the increment
    of the price of the products:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that will initialize all the attributes
    of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `compute()` method, which will implement the logic of the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the difference of the `last` and `first` attributes is less than `10` (the
    task has to update the price of less than `10` products), increment the price
    of that set of products using the `updatePrices()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If the difference between the `last` and `first` attributes is greater than
    or equal to `10`, create two new `Task` objects, one to process the first half
    of the products and the other to process the second half, and execute them in
    `ForkJoinPool` using the `invokeAll()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `updatePrices()` method. This method updates the products that
    occupy the positions between the values of the `first` and `last` attributes in
    the list of products:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a list of `10000` products using the `ProductListGenerator` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Task` object to update the `prices` of all the products in the
    list. The parameter `first` takes the value `0` and the `last` parameter takes
    the value `10000` (the size of the product list):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `ForkJoinPool` object using the constructor without parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the task in the pool using the `execute()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a block of code that shows information about the evolution of the
    pool every five milliseconds, writing to the console the value of some parameters
    of the pool until the task finishes its execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Shut down the pool using the `shutdown()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Check if the task has finished without errors with the `isCompletedNormally()`
    method and in that case, write a message to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected price of all the products, after the increment, is `12`. Write
    the name and price of all the products that have a price difference of `12` to
    check that all of them have increased their price correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message to indicate the finalization of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, you created a `ForkJoinPool` object and a subclass of the `ForkJoinTask`
    class that you executed in the pool. To create the `ForkJoinPool` object, you
    used the constructor without arguments, so it will be executed with its default
    configuration. It creates a pool with a number of threads equal to the number
    of processors of the computer. When the `ForkJoinPool` object is created, those
    threads are created and they wait in the pool until some tasks arrive for their
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `Task` class doesn't return a result, it extends the `RecursiveAction`
    class. In the recipe, you used the recommended structure for the implementation
    of the task. If the task has to update more than `10` products, it divides that
    set of elements into two blocks, creates two tasks, and assigns a block to each
    task. You used the `first` and `last` attributes in the `Task` class to know the
    range of positions that this task has to update in the list of products. You used
    the `first` and `last` attributes to use only one copy of the product list and
    not create different lists for each task.
  prefs: []
  type: TYPE_NORMAL
- en: To execute the subtasks that a task creates, it calls the `invokeAll()` method.
    This is a synchronous call, and the task waits for the finalization of the subtasks
    before continuing (potentially finishing) its execution. While the task is waiting
    for its subtasks, the worker thread that was executing it takes another task waiting
    for execution and executes it. With this behavior, the fork/join framework offers
    more efficient task management than the `Runnable` and `Callable` objects themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The `invokeAll()` method of the `ForkJoinTask` class is one of the main differences
    between the Executor and the fork/join framework. In the Executor framework, all
    the tasks have to be sent to the executor while in this case, the tasks include
    methods to execute and control the tasks inside the pool. You used the `invokeAll()`
    method in the `Task` class, which extends the `RecursiveAction` class, which in
    turn extends the `ForkJoinTask` class.
  prefs: []
  type: TYPE_NORMAL
- en: You sent a unique task to the pool to update all the lists of products using
    the `execute()` method. In this case, it's an asynchronous call, and the main
    thread continues its execution.
  prefs: []
  type: TYPE_NORMAL
- en: You used some methods of the `ForkJoinPool` class to check the status and the
    evolution of the tasks that are running. The class includes more methods that
    can be useful for this purpose. See the *Monitoring a fork/join pool* recipe in
    [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736), *Testing Concurrent
    Applications* for a complete list of those methods.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, like with the Executor framework, you should finish `ForkJoinPool`
    using the `shutdown()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see the tasks finishing their work and the price of the products updated.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ForkJoinPool` class provides other methods to execute a task. These methods
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`execute (Runnable task)`: This is another version of the `execute()` method
    used in the example. In this case, you send a `Runnable` task to the `ForkJoinPool`
    class. Note that the `ForkJoinPool` class doesn''t use the work-stealing algorithm
    with `Runnable` objects. It''s only used with `ForkJoinTask` objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invoke(ForkJoinTask<T> task)`: While the `execute()` method makes an asynchronous
    call to the `ForkJoinPool` class, as you learned in the example, the `invoke()`
    method makes a synchronous call to the `ForkJoinPool` class. This call doesn''t
    return until the task passed as a parameter finishes its execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also use the `invokeAll()` and `invokeAny()` methods declared in the
    `ExecutorService` interface. These methods receive `Callable` objects as parameters.
    The `ForkJoinPool` class doesn't use the work-stealing algorithm with the `Callable`
    objects, so you'd be better off executing them using a `ThreadPoolExecutor`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ForkJoinTask` class also includes other versions of the `invokeAll()`
    method used in the example. These versions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`invokeAll(ForkJoinTask<?>... tasks)`: This version of the method uses a variable
    list of arguments. You can pass to it as parameters as many `ForkJoinTask` objects
    as you want.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invokeAll(Collection<T> tasks)`: This version of the method accepts a collection
    (for example, an `ArrayList` object, a `LinkedList` object, or a `TreeSet` object)
    of objects of a generic type `T`. This generic type `T` must be the `ForkJoinTask`
    class or a subclass of it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the `ForkJoinPool` class is designed to execute an object of `ForkJoinTask`,
    you can also execute the `Runnable` and `Callable` objects directly. You may also
    use the `adapt()` method of the `ForkJoinTask` class that accepts a `Callable`
    object or a `Runnable` object and returns a `ForkJoinTask` object to execute that
    task.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Monitoring a fork/join pool* recipe in [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736),
    *Testing Concurrent Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joining the results of the tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fork/join framework provides the ability to execute tasks that return a
    result. This kind of tasks is implemented by the `RecursiveTask` class. This class
    extends the `ForkJoinTask` class and implements the `Future` interface provided
    by the Executor framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the task, you have to use the structure recommended by the Java API
    documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If the task has to resolve a problem bigger than a predefined size, you divide
    the problem into more subtasks and execute those subtasks using the fork/join
    framework. When they finish their execution, the initiating task obtains the results
    generated by all the subtasks, groups them, and returns the final result. Ultimately,
    when the initiating task executed in the pool finishes its execution, you obtain
    its result, whichÂ is effectively the final result of the entire problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn how to use this kind of problem solving with
    fork/join framework by developing an application that looks for a word in a document.
    You will implement the following two kinds of tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: A document task, which is going to search for a word in a set of lines of a
    document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line task, which is going to search a word in a part of the document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the tasks will return the number of appearances of the word in the part
    of the document or line they process. In this recipe we will use the default fork/join
    pool provided by the Java Concurrency API.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `DocumentMock`. It will generate a string matrix that
    will simulate a document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an array of strings with some words. This array will be used in the
    generation of the strings matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `generateDocument()` method. It receives as parameters the number
    of lines, the number of words per line, and the word the example is going to look
    for. It returns a matrix of strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'First, create the necessary objects to generate the document-the `String` matrix
    and a `Random` object to generate random numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Fill the array with strings. Store in each position the string that is at a
    random position in the array of words and count the number of appearances of the
    word the program will look for in the generated array. You can use this value
    to check whether the program does its job properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message with the number of appearances of the word and return the matrix
    generated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `DocumentTask` and specify that it extends the `RecursiveTask`
    class parameterized with the `Integer` class. This class will implement the task
    that will calculate the number of appearances of the word in a set of lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` matrix named document and two private `int` attributes
    named `start` and `end`. Also, declare a private `String` attribute named `word`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize all its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `compute()` method. If the difference between the `end` and `start`
    attributes is smaller than `10`, the task calculates the number of appearances
    of a word in the lines between those positions by calling the `processLines()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, divide the group of lines into two objects, create two new `DocumentTask`
    objects to process those two groups, and execute them in the pool using the `invokeAll()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the values returned by both the tasks using the `groupResults()`
    method. Finally, return the result calculated by the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `processLines()` method. It receives the string matrix, the `start`
    attribute, the `end` attribute, and the `word` attribute the task is searching
    for as parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'For every line the task has to process, create a `LineTask` object to process
    the complete line and store them in a list of tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute all the tasks in that list using the `invokeAll()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Sum the value returned by all these tasks and return the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `groupResults()` method. It adds two numbers and returns the
    result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `LineTask` and specify that it extends the `RecursiveTask`
    class parameterized with the `Integer` class. This class will implement the task
    that will calculate the number of appearances of the word in a line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` array attribute named `line` and two private `int`
    attributes named `start` and `end`. Finally, declare a private `String` attribute
    named `word`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize all its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `compute()` method of the class. If the difference between the
    `end` and `start` attributes is smaller than `100`, the task searches for the
    word in the fragment of the line determined by the `start` and `end` attributes
    using the `count()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, divide the group of words in the line in two, create two new `LineTask`
    objects to process those two groups, and execute them in the pool using the `invokeAll()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the values returned by both the tasks using the `groupResults()`
    method. Finally, return the result calculated by the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `count()` method. It receives the string array with the complete
    line, the `start` attribute, the `end` attribute, and the `word` attribute the
    task is searching for as parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the words stored in the positions between the `start` and `end` attributes
    with the `word` attribute the task is searching for, and if they are equal, increment
    the `counter` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To slow the execution of the example, put the task to sleep for `10` milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Return the value of the `counter` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `groupResults()` method. It sums two numbers and returns the
    `result`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `Document` with `100` lines and `1000` words per line using the `DocumentMock`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `DocumentTask` object to update the products of the entire document.
    The `start` parameter takes the value `0` and the `end` parameter takes the value
    `100`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the default `ForkJoinPool` executor using the `commmonPool()` method and
    execute the task on it using the `execute()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a block of code that shows information about the progress of the
    pool, writing every second to the console the value of some parameters of the
    pool until the task finishes its execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Shut down the pool using the `shutdown()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the tasks using the `awaitTermination()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the number of the appearances of the word in the document. Check that
    this number is the same as the number written by the `DocumentMock` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, you implemented two different tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DocumentTask`: A task of this class has to process a set of lines of the document
    determined by the `start` and `end` attributes. If this set of lines has a size
    smaller than `10`, it creates `LineTask` per line, and when they finish their
    execution, it sums the results of those tasks and returns the `result` of the
    sum. If the set of lines the task has to process has a size of `10` or bigger,
    it divides the set in two and creates two `DocumentTask` objects to process those
    new sets. When those tasks finish their execution, the tasks sum their results
    and return that sum as a `result`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LineTask`: A task of this class has to process a set of words of a line of
    the document. If this set of words is smaller than `100`, the task searches the
    word directly in that set of words and returns the number of appearances of the
    word. Otherwise, it divides the set of words into two and creates two `LineTask`
    objects to process those sets. When those tasks finish their execution, the task
    sums the results of both the tasks and returns that sum as a `result`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Main` class, you used the default `ForkJoinPool` (obtained from the
    static method, `commonPool()`) and executed in it a `DocumentTask` class that
    has to process a document of `100` lines and `1000` words per line. This task
    will divide the problem using other `DocumentTask` objects and `LineTask` objects,
    and when all the tasks finish their execution, you can use the original task to
    get the total number of appearances of the word in the whole document. Since the
    tasks return a result, they extend the `RecursiveTask` class.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain the result returned by `Task`, you used the `get()` method. This method
    is declared in the `Future` interface implemented by the `RecursiveTask` class.
  prefs: []
  type: TYPE_NORMAL
- en: When you execute the program, you can compare the first and the last lines written
    in the console. The first line is the number of appearances of the word calculated
    when the document is generated and the last is the same number calculated by the
    fork/join tasks.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ForkJoinTask` class provides another method to finish the execution of
    a task and return a result, that is, the `complete()` method. This method accepts
    an object of the type used in the parameterization of the `RecursiveTask` class
    and returns that object as a result of the task when the `join()` method is called.
    It's use is recommended to provide results for asynchronous tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `RecursiveTask` class implements the `Future` interface, there''s
    another version of the `get()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get(long timeout, TimeUnit unit)`: This version of the `get()` method, if
    the result of the task isn''t available, waits the specified time for it. If the
    specified period of time passes and the result isn''t yet available, the method
    returns a `null` value. The `TimeUnit` class is an enumeration with these constants:
    `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and
    `SECONDS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a fork/join pool* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Monitoring a fork/join pool* recipe in [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736),
    *Testing Concurrent Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tasks asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you execute `ForkJoinTask` in `ForkJoinPool`, you can do it in a synchronous
    or an asynchronous way. When you do it in a synchronous way, the method that sends
    the task to the pool doesn't return until the task sent finishes its execution.
    When you do it in an asynchronous way, the method that sends the task to the executor
    returns immediately, so the task can continue with its execution.
  prefs: []
  type: TYPE_NORMAL
- en: You should be aware of a big difference between the two methods. When you use
    the synchronous methods, the task that calls one of these methods (for example,
    the `invokeAll()` method) is suspended until the tasks it sent to the pool finish
    their execution. This allows the `ForkJoinPool` class to use the work-stealing
    algorithm to assign a new task to the worker thread that executed the sleeping
    task. On the contrary, when you use the asynchronous methods (for example, the
    `fork()` method), the task continues with its execution, so the `ForkJoinPool`
    class can't use the work-stealing algorithm to increase the performance of the
    application. In this case, only when you call the `join()` or `get()` methods
    to wait for the finalization of a task, the `ForkJoinPool` class can use that
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `RecursiveAction` and `RecursiveTask` classes, Java 8 introduced
    a new `ForkJoinTask` class with the `CountedCompleter` class. With this kind of
    tasks, you can include a completion action that will be executed when it is launched
    and there is no pending child task. This mechanism is based on a method included
    in the class (the `onCompletion()` method) and a counter of pending tasks.
  prefs: []
  type: TYPE_NORMAL
- en: This counter is initialized to zero by default and you can increment it when
    you need in an atomic way. Normally, you will increment this counter one by one
    as and when you launch a child task. Finally, when a task has finished its execution,
    you can try to complete the execution of the task and consequently execute the
    `onCompletion()` method. If the pending count is greater than zero, it is decremented
    by one. If it's zero, the `onCompletion()` method is executed and then the parent
    task is tried to be completed.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the asynchronous methods provided
    by the `ForkJoinPool` and `CountedCompleter` classes for the management of tasks.
    You are going to implement a program that will search for files with a determined
    extension inside a folder and its subfolders. The `CountedCompleter` class you're
    going to implement will process the contents of a folder. For each subfolder inside
    that folder, it will send a new task to the `ForkJoinPool` class in an asynchronous
    way. For each file inside that folder, the task will check the extension of the
    file and add it to the result list if it proceeds. When a task is completed, it
    will insert the result lists of all its child tasks in its result task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `FolderProcessor` and specify that it extends the `CountedCompleter`
    class parameterized with the `List<String>` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` attribute named `path`. This attribute will store
    the full path of the folder the task is going to process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` attribute named `extension`. This attribute will
    store the name of the extension of the files the task is going to look for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare two `List` private attributes named `tasks` and `resultList`. We will
    use the first one to store all the child tasks launched from this task and the
    other one to store the list of results of this task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement one constructor for the class to initialize its attributes and its
    parent class. We declare this constructor as `protected` as it will only be used
    internally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We implement the other public constructor to be used externally. As the task
    created by this constructor won''t have a parent task, we don''t include this
    object as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `compute()` method. As the base class of our task is the `CountedCompleter`
    class, the return type of this method is `void`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'First, initialize the two list attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the contents of the folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'For each element in the folder, if there is a subfolder, create a new `FolderProcessor`
    object and execute it asynchronously using the `fork()` method. We use the first
    constructor of the class and pass the current task as the completer task of the
    new one. We also increment the counter of pending tasks using the `addToPendingCount()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, compare the extension of the file with the extension you are looking
    for, using the `checkFile()` method, and if they are equal, store the full path
    of the file in the list of strings declared earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'If the list of the `FolderProcessor` subtasks has more than `50` elements,
    write a message to the console to indicate this circumstance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, try to complete the current task using the `tryComplete()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `onCompletion()` method. This method will be executed when all
    the child tasks (all the tasks that have been forked from the current task) have
    finished their execution. We add the result list of all the child tasks to the
    result list of the current task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `checkFile()` method. This method compares if the name of a file
    passed as a parameter ends with the `extension` you are looking for. If so, the
    method returns the `true` value, otherwise it returns the `false` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Finally, implement the `getResultList()` method to return the result list of
    a task. The code of this method is very simple so it won't be included.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `ForkJoinPool` using the default constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Create three `FolderProcessor` tasks. Initialize each with a different folder
    path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the three tasks in the pool using the `execute()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Write to the console information about the status of the pool every second
    until the three tasks have finished their execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Shut down `ForkJoinPool` using the `shutdown()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the number of results generated by each task to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of an execution of the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The key to this example is in the `FolderProcessor` class. Each task processes
    the contents of a folder. As you know, this content has the following two kinds
    of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: Files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other folders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the task finds a folder, it creates another `FolderProcessor` object to process
    that folder and sends it to the pool using the `fork()` method. This method sends
    the task to the pool that will execute it if it has a free worker thread, or it
    can create a new one. The method returns immediately, so the task can continue
    processing the contents of the folder. For every file, a task compares its extension
    with the one it's looking for and, if they are equal, adds the name of the file
    to the list of `results`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the task has processed all the contents of the assigned folder, we try
    to complete the current task. As we explained in the introduction of this recipe,
    when we try to complete a task, the code of the `CountedCompleter` looks for the
    value of the pending task counter. If this value is greater than `0`, it decreases
    the value of that counter. On the contrary, if the value is `0`, the task executes
    the `onCompletion()` method and then tries to complete its parent task. In our
    case, when a task is processing a folder and it finds a subfolder, it creates
    a new child task, launches that task using the `fork()` method, and increments
    the counter of the pending tasks. So, when a task has processed its entire content,
    the counter of pending tasks of the task will be equal to the number of child
    tasks we have launched. When we call the `tryComplete()` method, if the folder
    of the current task has subfolders, this call will decrease the number of pending
    tasks. Only when all its child tasks have been completed, its `onCompletion()`
    method is executed. If the folder of the current task hasn't got any subfolders,
    the counter of pending tasks will be zero; the `onComplete()` method will be called
    immediately, and then it will try to complete its parent task. In this way, we
    create a tree of tasks from top to bottom that are completed from bottom to top.
    In the `onComplete()` method, we process all the result lists of the child tasks
    and add their elements in the result list of the current task.
  prefs: []
  type: TYPE_NORMAL
- en: The `ForkJoinPool` class also allows the execution of tasks in an asynchronous
    way. You used the `execute()` method to send the three initial tasks to the pool.
    In the `Main` class, you also finished the pool using the `shutdown()` method
    and wrote information about the status and the evolution of the tasks that are
    running in it. The `ForkJoinPool` class includes more methods that can be useful
    for this purpose. See the *Monitoring a fork/join pool* recipe in [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736),
    *Testing Concurrent Applications* to see a complete list of those methods.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example we used the `addToPendingCount()` method to increment the counter
    of pending tasks, but we have other methods we can use to change the value of
    this counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setPendingCount()`: This method establishes the value of the counter of pending
    tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compareAndSetPendingCount()`: This method receives two parameters. The first
    one is the expected value and the second one is the new value. If the value of
    the counter of pending tasks is equal to the expected value, establish its value
    to the new one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decrementPendingCountUnlessZero()`: This method decrements the value of the
    counter of pending tasks unless it''s equal to zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `CountedCompleter` class also includes other methods to manage the completion
    of the tasks. The following are the most significant ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`complete()`: This method executes the `onCompletion()` method independently
    of the value of the counter of pending tasks and tries to complete its completer
    (parent) task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onExceptionalCompletion()`: This method is executed when the `completeExceptionally()`
    method has been called or the `compute()` method has thrown an `Exception`. Override
    this method to include your code to process such exceptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, you used the `join()` method to wait for the finalization
    of tasks and get their results. You can also use one of the following two versions
    of the `get()` method with this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get(long timeout, TimeUnit unit)`: This version of the `get()` method, if
    the result of the task isn''t available, waits the specified time for it. If the
    specified period of time passes and the result isn''t yet available, the method
    returns a `null` value. The `TimeUnit` class is an enumeration with the following
    constants: `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`,
    and `SECONDS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `join()` method can't be interrupted. If you interrupt the thread that called
    the `join()` method, the method throws an `InterruptedException` exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a fork/join pool* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Monitoring a fork/join pool* recipe in [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736),
    *Testing Concurrent Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throwing exceptions in the tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two kinds of exceptions in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Checked exceptions**: These exceptions must be specified in the `throws`
    clause of a method or caught inside them. For example, `IOException` or `ClassNotFoundException`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unchecked exceptions**: These exceptions don''t have to be specified or caught.
    For example, `NumberFormatException`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't throw any checked exception in the `compute()` method of the `ForkJoinTask`
    class because this method doesn't include any `throws` declaration in its implementation.
    You have to include the necessary code to handle the checked exceptions. On the
    other hand, you can throw (or it can be thrown by any method or object used inside
    the method) an unchecked exception. The behavior of the `ForkJoinTask` and `ForkJoinPool`
    classes is different from what you may expect. The program doesn't finish execution
    and you won't see any information about the exception in the console. It's simply
    swallowed as if it weren't thrown. Only when you call the `get()` method of the
    initial task, the exception will be thrown. You can, however, use some methods
    of the `ForkJoinTask` class to know if a task has thrown an exception and if so,
    what kind of exception it was. In this recipe, you will learn how to get that
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Task`. Specify that it implements the `RecursiveTask`
    class, parameterized with the `Integer` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `int` array named `array`. It will simulate the array of
    data you are going to process in this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare two private `int` attributes named `start` and `end`. These attributes
    will determine the elements of the array this task has to process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that initializes its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `compute()` method of the task. As you have parameterized the
    `RecursiveTask` class with the `Integer` class, this method has to return an `Integer`
    object. First, write a message to the console with the value of the `start` and
    `end` attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'If the block of elements that this task has to process, determined by the `start`
    and `end` attributes, has a size smaller than `10`, check if the element in the
    fourth position in the array (index number three) is in that block. If that is
    the case, throw `RuntimeException`. Then, put the task to sleep for a second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise (the block of elements that this task has to process has a size of
    10 or bigger), divide the block of elements in two, create two `Task` objects
    to process those blocks, and execute them in the pool using the `invokeAll()`
    method. Then, we write the results of these tasks to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message to the console indicating the end of the task, writing the
    value of the `start` and `end` attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Return the number `0` as the result of the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an array of `100` integer numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Task` object to process that `array`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `ForkJoinPool` object using the default constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the task in the pool using the `execute()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Shut down the `ForkJoinPool` class using the `shutdown()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the task using the `awaitTermination()` method.
    As you want to wait for the finalization of the task however long it takes to
    complete, pass the values `1` and `TimeUnit.DAYS` as parameters to this method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Check if the task, or one of its subtasks, has thrown an exception using the
    `isCompletedAbnormally()` method. In such a case, write a message to the console
    with the exception that was thrown. Get that exception with the `getException()`
    method of the `ForkJoinTask` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Task` class you implemented in this recipe processes an array of numbers.
    It checks if the block of numbers it has to process has `10` or more elements.
    In that case, it splits the block in two and creates two new `Task` objects to
    process those blocks. Otherwise, it looks for the element in the fourth position
    of the array (index number three). If that element is in the block the task has
    to process, it throws `RuntimeException`.
  prefs: []
  type: TYPE_NORMAL
- en: When you execute the program, the exception is thrown, but the program doesn't
    stop. In the `Main` class you have included a call to the `isCompletedAbnormally()`
    method of the `ForkJoinTask` class using the original task. This method returns
    `true` if that task, or one of its subtasks, has thrown an exception. You also
    used the `getException()` method of the same object to get the `Exception` object
    that it has thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you throw an unchecked exception in a task, it also affects its parent
    task (the task that sent it to the `ForkJoinPool` class) and the parent task of
    its parent task, and so on. If you revise the entire output of the program, you''ll
    see that there aren''t output messages for the finalization of some tasks. The
    starting messages of those tasks are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: These tasks are the ones that threw the exception and its parent tasks. All
    of them have finished abnormally. Take this into account when you develop a program
    with the `ForkJoinPool` and `ForkJoinTask` objects that can throw exceptions if
    you don't want this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, you used the `join()` method to wait for the finalization
    of tasks and get their results. You can also use one of the following two versions
    of the `get()` method with this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get()`: This version of the `get()` method returns the value returned by the
    `compute()` method if `ForkJoinTask` has finished its execution, or it waits until
    its finalization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get(long timeout, TimeUnit unit)`: This version of the `get()` method, if
    the result of the task isn''t available, waits the specified time for it. If the
    specified period of time passes and the result isn''t yet available, the method
    returns a `null` value. The `TimeUnit` class is an enumeration with the following
    constants: `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`,
    and `SECONDS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two main differences between the `get()` and `join()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The `join()` method can't be interrupted. If you interrupt the thread that called
    the `join()` method, the method throws `InterruptedException`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the `get()` method will return `ExecutionException` if the tasks throw
    any unchecked exception, the `join()` method will return `RuntimeException`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can obtain the same result obtained in the example if, instead of throwing
    an exception, you use the `completeExceptionally()` method of the `ForkJoinTask`
    class. The code would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a fork/join pool* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canceling a task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you execute the `ForkJoinTask` objects in a `ForkJoinPool` class, you
    can cancel them before they start their execution. The `ForkJoinTask` class provides
    the `cancel()` method for this purpose. There are some points you have to take
    into account when you want to cancel a task, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ForkJoinPool` class doesn't provide any method to cancel all the tasks
    it has running or waiting in the pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you cancel a task, you don't cancel the tasks this task has executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, you will implement an example of the cancellation of `ForkJoinTask`
    objects. You will look for the position of a number in an array. The first task
    that finds the number will cancel the remaining tasks. As that functionality is
    not provided by the fork/join framework, you will implement an auxiliary class
    to do this cancellation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `ArrayGenerator`. This class will generate an array of
    random integer numbers with the specified size. Implement a method named `generateArray()`.
    It will generate the array of numbers. It receives the size of the array as a
    parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `TaskManager`. We will use this class to store all the
    tasks executed in `ForkJoinPool` used in the example. Due to the limitations of
    the `ForkJoinPool` and `ForkJoinTask` classes, you will use this class to cancel
    all the tasks of the `ForkJoinPool` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a list of objects parameterized with the `ForkJoinTask` class, parameterized
    with the `Integer` class named `List`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class. It initializes the list of tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `addTask()` method. It adds a `ForkJoinTask` object to the lists
    of tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `cancelTasks()` method. It will cancel all the `ForkJoinTask`
    objects stored in the list using the `cancel()` method. It receives as a parameter
    the `ForkJoinTask` object that wants to cancel the rest of the tasks. The method
    cancels all the tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `SearchNumberTask` class. Specify that it extends the `RecursiveTask`
    class parameterized with the `Integer` class. This class will look for a number
    in a block of elements of an integer array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private array of `int` numbers named `numbers`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare two private `int` attributes named `start` and `end`. These attributes
    will determine the elements of the array this task has to process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `int` attribute named `number` to store the number you are
    going to look for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `TaskManager` attribute named `manager`. You will use this
    object to cancel all the tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `int` constant and initialize it to `-1`. It will be the
    returned value by the task when it doesn''t find the number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class to initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `compute()` method. Start the method by writing a message to
    the console indicating the values of the `start` and `end` attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'If the difference between the `start` and `end` attributes is greater than
    `10` (the task has to process more than `10` elements of the array), call the
    `launchTasks()` method to divide the work of this task into two subtasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, look for the number in the block of the array that the task calling
    the `lookForNumber()` method has to process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Return the result of the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `lookForNumber()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'For all the elements in the block of elements this task has to process, compare
    the value stored in that element with the number you are looking for. If they
    are equal, write a message to the console indicating, in such a circumstance,
    to use the `cancelTasks()` method of the `TaskManager` object to cancel all the
    tasks, and return the position of the element where you found the number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the loop, put the task to sleep for one second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, return the `-1` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `launchTasks()` method. First, divide the block of numbers this
    task has to process into two, and then create two `Task` objects to process them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the tasks to the `TaskManager` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the two tasks asynchronously using the `fork()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the tasks, and return the result of the first
    task if it is not equal to `-1` or the result of the second task, otherwise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `writeCancelMessage()` method to write a message when the task
    is canceled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` with
    a `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an array of `1000` numbers using the `ArrayGenerator` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `TaskManager` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `ForkJoinPool` object using the default constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Task` object to process the array generated before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the task in the pool asynchronously using the `execute()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Shut down the pool using the `shutdown()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the tasks using the `awaitTermination()` method
    of the `ForkJoinPool` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message to the console indicating the end of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ForkJoinTask` class provides the `cancel()` method that allows you to cancel
    a task if it hasn't been executed yet. This is a very important point. If the
    task has begun its execution, a call to the `cancel()` method has no effect. The
    method receives a parameter as a `Boolean` value called `mayInterruptIfRunning`.
    This name may make you think that, if you pass the true value to the method, the
    task will be canceled even if it is running. The Java API documentation specifies
    that, in the default implementation of the `ForkJoinTask` class, this attribute
    has no effect. The tasks are only canceled if they haven't started their execution.
    The cancellation of a task has no effect over the tasks that the cancelled task
    sent to the pool. They continue with their execution.
  prefs: []
  type: TYPE_NORMAL
- en: A limitation of the fork/join framework is that it doesn't allow the cancellation
    of all the tasks that are in `ForkJoinPool`. To overcome that limitation, you
    implemented the `TaskManager` class. It stores all the tasks that have been sent
    to the pool. It has a method that cancels all the tasks it has stored. If a task
    can't be canceled because it's running or has finished, the `cancel()` method
    returns the `false` value, so you can try to cancel all the tasks without being
    afraid of the possible collateral effects.
  prefs: []
  type: TYPE_NORMAL
- en: In the example, you have implemented a task that looks for a number in an array
    of numbers. You divided the problem into smaller subproblems as the fork/join
    framework recommends. You are only interested in one occurrence of the number,
    so when you find it, you cancel the other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a fork/join pool* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
