- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Data Persistence and Relational Database Integration with Spring Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Data 与关系型数据库进行数据持久化和集成
- en: Most applications handle their data in some way, necessitating the use of a
    database engine. This chapter discusses Relational Databases, the most widely
    used database technology. Relational databases remain a flexible and dependable
    option for a variety of application scenarios. Their organized, tabular data storage
    format with a defined schema suits many purposes. Additionally, relational databases
    offer essential benefits like enforcing data integrity, supporting complex queries,
    and adhering to **ACID** principles (**Atomicity, Consistency, Isolation, Durability**).
    They prove to be a suitable choice for applications ranging from simple to mission-critical
    ones.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序以某种方式处理他们的数据，这需要使用数据库引擎。本章讨论了关系型数据库，这是最广泛使用的数据库技术。关系型数据库仍然是各种应用程序场景中灵活和可靠的选项。它们的组织化、表格化数据存储格式和定义良好的模式适合许多用途。此外，关系型数据库提供了诸如强制数据完整性、支持复杂查询和遵循
    **ACID** 原则（**原子性、一致性、隔离性、持久性**）等基本好处。它们被证明是适用于从简单到关键任务应用的各种应用程序的合适选择。
- en: Spring Data is a component of the Spring Framework, designed to streamline data
    access in Java applications. It offers a consistent programming model and an abstraction
    layer for interacting with various data stores, including relational databases
    and other types of databases.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 是 Spring 框架的一个组件，旨在简化 Java 应用程序中的数据访问。它提供了一个一致的编程模型和与各种数据存储（包括关系型数据库和其他类型的数据库）交互的抽象层。
- en: 'There are two modules in Spring Data for relational databases: Spring Data
    JPA and Spring Data JDBC.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 为关系型数据库提供了两个模块：Spring Data JPA 和 Spring Data JDBC。
- en: Spring Data JPA. This module provides integration with **Java Persistence API**
    (**JPA**), allowing developers to work with relational databases using **Object-Relational
    Mapping** principles (**ORM**). One of the benefits is that most of the code is
    database independent, not for the purpose of creating an application totally independent
    of the database, but to reuse the learnings regardless the underlaying database.
    In complex applications, taking advantage of vendor-specific features can be determinant
    for a successful project, so I recommend using all features available from a database
    engine. Trying to make an application that can be deployed in any database causes
    that your application will use only the minimum common set available in all databases.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data JPA。此模块提供了与 **Java 持久化 API**（**JPA**）的集成，允许开发人员使用 **对象关系映射**（**ORM**）原则与关系型数据库一起工作。其中一个好处是大多数代码是数据库无关的，不是为了创建一个完全独立于数据库的应用程序，而是为了无论底层数据库如何都能重用所学知识。在复杂的应用程序中，利用特定供应商的功能对于项目的成功可能是决定性的，因此我建议使用数据库引擎提供的所有功能。试图创建一个可以在任何数据库中部署的应用程序会导致你的应用程序只使用所有数据库中可用的最小公共集合。
- en: Spring Data JDBC. This module offers more direct approach to database access,
    focusing on the use of plain SQL queries and direct mapping of data between Java
    objects and database tables.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data JDBC。此模块提供了更直接的数据访问方法，侧重于使用纯 SQL 查询以及 Java 对象和数据库表之间的直接数据映射。
- en: We will use Spring Data JPA for the most common data access scenarios. From
    basic data operations such as Create, Read, Update, Delete (CRUD) to more advanced
    tasks such as complex queries, transactions, and database schema initialization
    and schema upgrade.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Spring Data JPA 处理最常见的数据访问场景。从基本数据操作，如创建、读取、更新、删除（CRUD）到更高级的任务，如复杂查询、事务以及数据库模式初始化和模式升级。
- en: We will use PostgreSQL as a database engine, as it is Open Source, widely adopted,
    multiplatform and has a vibrant community around it. But as mentioned above, we
    could use the same principles to create an application using another relational
    database engine, such as MySQL, SQL Server or Oracle.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 PostgreSQL 作为数据库引擎，因为它开源、广泛采用、多平台，并且围绕它有一个充满活力的社区。但如上所述，我们可以使用相同的原理来创建一个使用其他关系型数据库引擎的应用程序，例如
    MySQL、SQL Server 或 Oracle。
- en: 'In this chapter we are going to cover the following main topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Connecting your application to Postgresql
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的应用程序连接到 Postgresql
- en: Creating and updating the database schema
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和更新数据库模式
- en: Creating a CRUD repository.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 CRUD 存储库。
- en: Using JPQL.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JPQL。
- en: Using Native queries.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原生查询。
- en: Updating operations
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新操作
- en: Dynamic Queries
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态查询
- en: Using Transactions
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事务
- en: Using Spring Data JDBC.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Data JDBC。
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need a PostgreSQL server. The easiest way to deploy
    it in your local environment is by using Docker. You can get Docker from the product
    page: [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要一个PostgreSQL服务器。在本地环境中部署它的最简单方法是使用Docker。您可以从产品页面获取Docker：[https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)
- en: 'If you prefer to install PostgreSQL in your computer, you can download it from
    the project page: [https://www.postgresql.org/download/](https://www.postgresql.org/download/)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在您的计算机上安装PostgreSQL，您可以从项目页面下载它：[https://www.postgresql.org/download/](https://www.postgresql.org/download/)
- en: 'I also recommend installing PgAdmin to access the database. You can use it
    to observe the changes performed by your application in the database. You can
    download it from the project page: [https://www.pgadmin.org/download/](https://www.pgadmin.org/download/)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我还推荐安装PgAdmin来访问数据库。您可以使用它来观察应用程序在数据库中执行的变化。您可以从项目页面下载它：[https://www.pgadmin.org/download/](https://www.pgadmin.org/download/)
- en: You can use other tools, such as plugins for Visual Studio Code or IntelliJ.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用其他工具，例如Visual Studio Code或IntelliJ的插件。
- en: You will need a code editor and OpenJDK as explained in the previous chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，您需要一个代码编辑器和OpenJDK。
- en: 'All the recipes that will be demonstrated in this chapter can be found at:
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter5](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter5).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中将要展示的所有菜谱都可以在以下位置找到：[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter5](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter5).
- en: Connecting your application to PostgreSQL
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的应用程序连接到PostgreSQL
- en: You want to create a RESTful API to server Football data to your end users.
    To manage this data, we decided to use a relatational database, as we are interested
    in prodiving data consistency and advanced query capabilities.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要创建一个RESTful API来为您的最终用户提供足球数据。为了管理这些数据，我们决定使用关系型数据库，因为我们感兴趣的是提供数据一致性和高级查询功能。
- en: In this recipe, we will connect an application, a RESTful API, to a PostgreSQL
    database. To do that, the first thing we’ll do is deploy a PostgreSQL database
    in Docker.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将连接一个应用程序，一个RESTful API，到一个PostgreSQL数据库。为此，我们首先要做的是在Docker中部署一个PostgreSQL数据库。
- en: In this recipe you will learn how to create a basic application that connects
    to a PostgreSQL database and perform basic SQL queries with JdbcTemplate.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将学习如何创建一个基本的应用程序，该应用程序连接到PostgreSQL数据库，并使用JdbcTemplate执行基本的SQL查询。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, you will need a PostgreSQL database. If you have already one
    server available, you can use it. Otherwise, you can use Docker to deploy a PostgreSQL
    in your computer. For that, you can execute the following command in your terminal
    to download and execute a PostgreSQL instance:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，您需要一个PostgreSQL数据库。如果您已经有一个可用的服务器，您可以使用它。否则，您可以使用Docker在您的计算机上部署一个PostgreSQL。为此，您可以在终端中执行以下命令来下载和执行一个PostgreSQL实例：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will have a PostgreSQL server available listening on port 5432, with username
    and password *packt*. If you want to change these parameters, you can modify the
    command above.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您将有一个PostgreSQL服务器可供使用，监听端口5432，用户名和密码为*packt*。如果您想更改这些参数，您可以修改上面的命令。
- en: 'You will need a tool to perform some actions on PostgreSQL. I will use the
    command line tool psql. In Ubuntu you can install it using *apt,* the default
    package manager:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一款工具来对PostgreSQL执行一些操作。我将使用命令行工具psql。在Ubuntu上，您可以使用默认的包管理器*apt*来安装它：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Alternativelly to psql, you can use PgAdmin to connect to the database with
    a nice UI. I’ll explain the samples just with the command line using psql, but
    you can use PgAdmin to execute the database scripts if you want. Follow the instruction
    from the official page at [https://www.pgadmin.org/download/](https://www.pgadmin.org/download/)
    to install it in your computer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 作为psql的替代方案，您可以使用PgAdmin通过一个友好的UI连接到数据库。我将仅使用psql的命令行示例进行说明，但如果您想的话，您也可以使用PgAdmin来执行数据库脚本。请按照官方页面[https://www.pgadmin.org/download/](https://www.pgadmin.org/download/)上的说明在您的计算机上安装它。
- en: You will find the sql scripts in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub仓库中找到sql脚本，网址为[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
- en: As usual, we will use Spring Initializr tool to create our projects, or the
    integrated tool in your favorite IDE or editor if you prefer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们将使用Spring Initializr工具创建我们的项目，或者如果你更喜欢，可以使用你最喜欢的IDE或编辑器中的集成工具。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Once we have our PostgreSQL server ready as explained in *Getting Ready*, we
    will create a database. After this, we will create a Spring Boot application that
    will connect to the database to perform a simple query.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好了如*准备就绪*中所述的PostgreSQL服务器，我们将创建一个数据库。之后，我们将创建一个Spring Boot应用程序，该应用程序将连接到数据库以执行一个简单的查询。
- en: 'First, download the postgresql scripts available in the GitHub repository.
    They are located in `chapter5/recipe5-1/start/sql`. There are two script files:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，下载GitHub仓库中可用的postgresql脚本。它们位于`chapter5/recipe5-1/start/sql`目录下。有两个脚本文件：
- en: '`db-creation.sql`. This script creates a database named `football`, with two
    tables: `teams` and `players`.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db-creation.sql`。此脚本创建一个名为`football`的数据库，包含两个表：`teams`和`players`。'
- en: '`insert-data.sql`. This script inserts sample data in the `teams` and `players`
    tables.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert-data.sql`。此脚本在`teams`和`players`表中插入示例数据。'
- en: Next, we’ll execute the scripts in the database to execute the scripts. For
    that, open a terminal and execute the following commands to execute the scripts
    in PostgreSQL using the *psql* tool.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将执行数据库中的脚本。为此，打开一个终端并执行以下命令以使用*psql*工具在PostgreSQL中执行脚本。
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It will request the password. Introduce *packt* as configured in the *Getting
    Ready* section. If you used different parameters in the *Getting Ready* section,
    use it accordingly.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它将请求密码。输入*packt*，如*准备就绪*部分中配置的那样。如果你在*准备就绪*部分使用了不同的参数，请相应地使用。
- en: Alternatively, you can use *PgAdmin* tool instead of *psql* tool.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，你也可以使用*PgAdmin*工具代替*psql*工具。
- en: 'The database schema we just created looks like this:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚刚创建的数据库模式看起来如下：
- en: '![Figure 5.1: Database schema. Exported with PgAdmin tool.](img/B21646_05_1.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1：数据库模式。使用PgAdmin工具导出。](img/B21646_05_1.jpg)'
- en: 'Figure 5.1: Database schema. Exported with PgAdmin tool.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：数据库模式。使用PgAdmin工具导出。
- en: 'Let’s create a new Spring Boot application connecting to the database using
    *Spring Initializr* tool. We’ll use the same parameters as in *Creating a RESTful
    API* recipe in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020), except changing
    the following options:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用*Spring Initializr*工具创建一个新的Spring Boot应用程序，该应用程序连接到数据库。我们将使用与[*第1章*](B21646_01.xhtml#_idTextAnchor020)中*创建RESTful
    API*配方相同的参数，除了更改以下选项：
- en: '`footballpg`'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`footballpg`'
- en: '**Dependencies**: **Spring Web**, **Spring Data JPA**, **PostgreSQL Driver**'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项**：**Spring Web**，**Spring Data JPA**，**PostgreSQL Driver**'
- en: 'Next, we’ll configure the application to connect to the PostgreSQL database.
    For that, create an `application.yml` file in the `resources` folder and set the
    following content:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将配置应用程序以连接到PostgreSQL数据库。为此，在`resources`文件夹中创建一个`application.yml`文件，并设置以下内容：
- en: '[PRE3]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, create a new service class named `TeamsService`. This class will use JdbcTemplate
    to perform the queries against the database. For that, it’s necessary to inject
    a JdbcTemplate.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`TeamsService`的新服务类。此类将使用JdbcTemplate对数据库执行查询。为此，需要注入一个JdbcTemplate。
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We’ll create a method in the *TeamsService* that gets the total number of teams.
    You can name the method `getTeamCount`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在*TeamsService*中创建一个方法来获取团队总数。你可以将此方法命名为`getTeamCount`：
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We used the jdbcTemplate method queryForObject to perform an SQL query to get
    a single value.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用了jdbcTemplate的queryForObject方法来执行一个SQL查询以获取单个值。
- en: You can now create a RestController using this service. I made a sample controller
    that uses the `TeamsService`. You can find it in the book’s repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以使用此服务创建一个RestController。我创建了一个使用`TeamsService`的示例控制器。你可以在本书的仓库中找到它，网址为[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)。
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In our configuration file `application.yml`, we have defined a data source.
    Within the data source, we have used a URL, a username, and a password. However,
    it is also possible to define additional properties. Alternatively, we can use
    only the URL. The URL contains important information such as the type of the database
    (in our case, PostgreSQL), the host, the port, and the database name. Although
    it’s possible to pass the username and password in the URL, we used specific fields
    to enhance clarity.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配置文件 `application.yml` 中，我们定义了一个数据源。在数据源内部，我们使用了 URL、用户名和密码。然而，也可以定义其他属性。或者，我们也可以只使用
    URL。URL 包含重要信息，例如数据库的类型（在我们的情况下，是 PostgreSQL）、主机、端口和数据库名。尽管可以在 URL 中传递用户名和密码，但我们使用了特定的字段来提高清晰度。
- en: Since we specified PostgreSQL as the database, it is essential to have a driver
    registered in the class path. We achieved that by adding the dependency to the
    PostgreSQL driver.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们指定了 PostgreSQL 作为数据库，因此确保类路径中注册了驱动程序至关重要。我们通过添加 PostgreSQL 驱动程序的依赖项来实现这一点。
- en: A data source object is registered in the dependency container by defining a
    data source in the configuration file. Spring Data JPA uses that data source to
    create JdbcTemplates when needed, for instance, it creates a JdbcTemplate instance
    and injects it into the `TeamsService` class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在配置文件中定义数据源，数据源对象被注册到依赖容器中。Spring Data JPA 使用该数据源在需要时创建 JdbcTemplate，例如，它创建一个
    JdbcTemplate 实例并将其注入到 `TeamsService` 类中。
- en: JdbcTemplate handles the creation and release of resources and converts `SQLExceptions`
    into Spring’s `DataAccessExceptions`. In this example, we used a very simple query
    that does not require any parameter and returns an Integer. Still, JdbcTemplate
    allows passing parameters to your query and mapping the results to complex classes.
    We won’t extend much on these capabilities in this book; rather, we’ll go deeper
    into JPA and Hibernate capabilities to map complex entities and relations to classes.
    We’ll see that in from *Using Hibernate* recipe onwards.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JdbcTemplate 处理资源的创建和释放，并将 `SQLExceptions` 转换为 Spring 的 `DataAccessExceptions`。在此示例中，我们使用了一个非常简单的查询，它不需要任何参数并返回一个
    Integer。尽管如此，JdbcTemplate 允许向你的查询传递参数并将结果映射到复杂类。我们不会在本书中过多扩展这些功能；相反，我们将深入研究 JPA
    和 Hibernate 功能，以将复杂实体和关系映射到类。从 *使用 Hibernate* 食谱开始，我们将看到这一点。
- en: There’s more...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'JdbcTemplate can be used to retrieve results that are not limited to scalar
    values. For instance, assuming that we have a `Team` class, we can define the
    following method that uses the `query` method to retrieve all teams:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: JdbcTemplate 可以用来检索不仅限于标量值的查询结果。例如，假设我们有一个 `Team` 类，我们可以定义以下方法，使用 `query` 方法检索所有团队：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we use an anonymous `RowMapper` that transforms each row into
    a `Team`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用一个匿名 `RowMapper`，它将每一行转换为一个 `Team` 对象。
- en: 'You can also pass arguments to your query. For instance, let’s retrieve a specific
    team:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以向你的查询传递参数。例如，让我们检索一个特定的团队：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This time, we used a `BeanPropertyRowMapper` to map the resulting row to Team.
    This class infers the target properties to map the columns of the resulting rows.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用 `BeanPropertyRowMapper` 将结果行映射到 Team。这个类推断目标属性以映射结果行的列。
- en: Using JdbcClient to access the database
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JdbcClient 访问数据库
- en: In the previous recipe, we used JdbcTemplate to access the database. The JdbcClient
    is an enhanced JDBC client that provides a Fluent interaction mode. JdbcClient
    has been introduced in Spring Framework 6.1, and it’s available since Spring Boot
    3.2.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个食谱中，我们使用 JdbcTemplate 访问数据库。JdbcClient 是一个增强的 JDBC 客户端，它提供了一种流畅的交互模式。JdbcClient
    自 Spring Framework 6.1 以来被引入，并且自 Spring Boot 3.2 起可用。
- en: In this recipe, we’ll learn how to use JdbcClient by performing some simple
    queries to the database.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将通过执行一些简单的数据库查询来学习如何使用 JdbcClient。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll need a PostgreSQL database. You can reuse the same database
    created in the previous recipe, *Connecting your application to PostgreSQL*. You
    can reuse the project from the same recipe as well, as the dependencies are the
    same. I prepared a working version that you can use as a starting point for this
    recipe. You can find it in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in `chapter5/recipe5-2/start` folder.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们需要一个PostgreSQL数据库。你可以重用之前在*连接你的应用程序到PostgreSQL*菜谱中创建的相同数据库。你也可以重用同一个菜谱中的项目，因为依赖项是相同的。我已经准备了一个你可以用作此菜谱起点的工作版本。你可以在本书的GitHub仓库中找到它，在`chapter5/recipe5-2/start`文件夹中。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let’s prepare some queries using JdbcClient instead of JdbcTemplate.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用JdbcClient而不是JdbcTemplate来准备一些查询。
- en: 'Let’s start by creating a new service class named `PlayersService` and inject
    a JdbcClient in the constructor:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为`PlayersService`的新服务类并在这个构造函数中注入一个JdbcClient开始：
- en: '[PRE8]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Create a class named `Player`. This class should have the same fields as the
    table `players` created in the *Connecting your application to PostgreSQL* recipe.
    You can find an implementation of this class in the book’s repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Player`的类。这个类应该有与在*连接你的应用程序到PostgreSQL*菜谱中创建的`players`表相同的字段。你可以在本书的仓库中找到这个类的实现，网址为[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)。
- en: 'Now, we can create methods in the `PlayersService` to interact with the database:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在`PlayersService`中创建方法来与数据库交互：
- en: 'Let’s create a method named `getPlayers` to retrieve all players:'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`getPlayers`的方法来检索所有球员：
- en: '[PRE9]'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can create a method named `getPlayer` to retrieve a single `Player`. We can
    use a parameter in the SQL query.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个名为`getPlayer`的方法来检索单个`Player`。我们可以在SQL查询中使用一个参数。
- en: '[PRE10]'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s do a method to create a new `Player`. Name it `createPlayer`:'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`createPlayer`的方法来创建一个新的`Player`：
- en: '[PRE11]'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can create a controller that uses the `PlayerService`. I prepared a working
    version that you can find in the book’s GitHub repository at: [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以创建一个使用`PlayerService`的控制器。我已经准备了一个可以在本书的GitHub仓库中找到的工作版本：[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)。
- en: How it works...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The mechanism used by the JdbcClient to create a connection to the database
    is like the JdbcTemplate. Spring Data JPA uses the data source configured in the
    application and injects it in the JdbcClient.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: JdbcClient用来创建数据库连接的机制类似于JdbcTemplate。Spring Data JPA使用在应用程序中配置的数据源，并将其注入到JdbcClient中。
- en: The JdbcClient provides a Fluent way to interact with the database, making the
    development more intuitive and reducing the boilerplate code. It allows using
    named parameters very easily, as we saw in the methods `getPlayer` and `createPlayer`.
    It also provides automatic mapping, with no need to define a `RowMapper` to process
    each row.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: JdbcClient提供了一个流畅的方式来与数据库交互，使开发更加直观，并减少了样板代码。它允许非常容易地使用命名参数，就像我们在`getPlayer`和`createPlayer`方法中看到的那样。它还提供了自动映射，无需定义`RowMapper`来处理每一行。
- en: Using an ORM to access the database
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ORM访问数据库
- en: Accessing a database performing SQL requests can be performant and can work
    for simple applications. However, when the application becomes more complex and
    the database schema grows, it can be interesting using an **Object-Relational
    Mapping** (**ORM**) framework to access the database using an **Object-Oriented
    Programming** (**OOP**) layer. Probably, the most popular ORM framework in Java
    is **Hibernate**, and Spring Data JPA uses Hibernate as its default **Java Persistence
    API** (**JPA**) implementation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行SQL请求访问数据库可以是高效的，并且适用于简单的应用程序。然而，当应用程序变得更加复杂且数据库模式增长时，使用一个**对象关系映射**（**ORM**）框架通过**面向对象编程**（**OOP**）层访问数据库可能是有趣的。在Java中，最流行的ORM框架可能是**Hibernate**，而Spring
    Data JPA使用Hibernate作为其默认的**Java持久化API**（**JPA**）实现。
- en: In this recipe, we will create entity classes that can be mapped to the database
    schema, and we’ll interact with the database without writing a single line of
    SQL.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建可以映射到数据库模式的实体类，并且我们将与数据库交互而不需要写一行SQL。
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need a PostgreSQL database for this recipe. You can reuse the database
    created in the *Connecting your application to PostgreSQL* recipe. If you haven’t
    completed that recipe yet, you can complete the first two steps of that recipe
    to create the database.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要为这个菜谱创建一个 PostgreSQL 数据库。您可以使用 *连接您的应用程序到 PostgreSQL* 菜谱中创建的数据库。如果您还没有完成那个菜谱，您可以完成那个菜谱的前两步来创建数据库。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Once we have our PostgreSQL server ready, as explained in *Getting Ready*, we
    will create a database, and we will fill it with some data. After this, we will
    create a RESTfull project to connect to the database to retrieve the data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好了 PostgreSQL 服务器，如 *准备就绪* 中所述，我们将创建一个数据库，并填充一些数据。之后，我们将创建一个 RESTful 项目以连接到数据库并检索数据。
- en: Let’s create a project connected to this database. We will use Spring Initialzr
    tool by opening https://start.spring.io in your browser.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个连接到这个数据库的项目。我们将在浏览器中打开 https://start.spring.io 来使用 Spring Initializr
    工具。
- en: 'We will use the usual parameters as in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020),
    with the following specific parameters:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用与 [*第 1 章*](B21646_01.xhtml#_idTextAnchor020) 中的相同参数，以下是一些特定参数：
- en: '`footballpg`'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`footballpg`'
- en: '**Dependencies**: **Spring Web**, **Spring Data JPA**, **PostgreSQL Driver**'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项**：**Spring Web**，**Spring Data JPA**，**PostgreSQL 驱动程序**'
- en: In this project, create the entity classes to map with the database tables.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个项目中，创建实体类以映射数据库表。
- en: 'Create a file named `TeamEntity.java` containing a class to map with table
    `teams`:'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `TeamEntity.java` 的文件，包含一个与表 `teams` 映射的类：
- en: '[PRE12]'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Create a file named `PlayerEntity.java` containing the class to map with table
    `players`.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PlayerEntity.java` 的文件，包含与表 `players` 映射的类。
- en: '[PRE13]'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Create two repository interfaces to access the database using the entities we
    created in the previous step.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个仓库接口以使用我们在上一步创建的实体访问数据库。
- en: 'Create a file named `TeamRepository.java` with the following interface:'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `TeamRepository.java` 的文件，包含以下接口：
- en: '[PRE14]'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a file named `PlayerRepository.java` containing the following interface:'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PlayerRepository.java` 的文件，包含以下接口：
- en: '[PRE15]'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a service class named `FootballService` using both repositories:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个仓库创建一个名为 `FootballService` 的服务类：
- en: '[PRE16]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create two classes representing the data exposed:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个表示公开数据的类：
- en: '`Team`:'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Team`：'
- en: '[PRE17]'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`Player`:'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player`：'
- en: '[PRE18]'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add a couple of methods to find players using different criteria:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些方法来根据不同的标准查找球员：
- en: 'Search players that contain a given string in the name:'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索包含给定字符串在名称中的球员：
- en: '[PRE19]'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Search players by birth date:'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过出生日期搜索球员：
- en: '[PRE20]'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add a method to return a `Team`, including its players:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个方法来返回一个包含其球员的 `Team`：
- en: '[PRE21]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a new team:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的团队：
- en: '[PRE22]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Update the position of a player:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新玩家的位置：
- en: '[PRE23]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, you can create a controller using the service to expose the application’s
    logic. You can find a complete example in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以使用服务创建一个控制器来公开应用程序的逻辑。您可以在书籍的 GitHub 存储库中找到一个完整的示例，网址为 [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)。
- en: 'Now configure the application to connect to PostgreSQL database. Under `resources`
    folder, create a file named `application.yml`. Set the following configuration:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在配置应用程序以连接到 PostgreSQL 数据库。在 `resources` 文件夹下，创建一个名为 `application.yml` 的文件。设置以下配置：
- en: '[PRE24]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now you can execute and test the application. You can use the instructions from
    [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020) to test the application using
    curl. I also provided a script that you can find in the repository with curl requests
    for this application. It is located at `chapter2/recipe2-1/end/scripts/requests.sh`
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您可以执行并测试应用程序。您可以使用 [*第 1 章*](B21646_01.xhtml#_idTextAnchor020) 中的说明使用 curl
    测试应用程序。我还提供了一个脚本，您可以在存储库中找到该脚本，其中包含此应用程序的 curl 请求。它位于 `chapter2/recipe2-1/end/scripts/requests.sh`。
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Hibernate is an **Object-Relational Mapping** (**ORM**) framework. Its primary
    goal is to bridge the gap between the Java programming language and relational
    databases. Using annotations such as @Entity, @Table, @Id, @OneToMany, @ManyToOne,
    and others not used in this recipe, Hibernate maps the classes to database tables.
    These mapped classes are known as *Entities*. Hibernate also provides other features,
    such as transaction management, query capabilities, caching, and lazy loading.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate是一个**对象关系映射（ORM**）框架。它的主要目标是弥合Java编程语言和关系数据库之间的差距。使用如@Entity、@Table、@Id、@OneToMany、@ManyToOne等注解，Hibernate将类映射到数据库表。这些映射的类被称为*实体*。Hibernate还提供其他功能，如事务管理、查询能力、缓存和延迟加载。
- en: Hibernate is the default JPA provider for Spring Data JPA. Spring Data JPA allows
    you to define Repository interfaces to interact with your data model. Just by
    extending the `CrudRepository` interface, it automatically generates the necessary
    JPA operations to provide Create, Read, Update, and Delete operations for your
    Entities. When using `JpaRepository`, Spring Data JPA generates the necessary
    JPA queries based on method names.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate是Spring Data JPA的默认JPA提供者。Spring Data JPA允许你定义仓库接口来与你的数据模型交互。只需通过扩展`CrudRepository`接口，它就会自动生成必要的JPA操作，为你的实体提供创建、读取、更新和删除操作。当使用`JpaRepository`时，Spring
    Data JPA会根据方法名称生成必要的JPA查询。
- en: For instance, we used `findByDateOfBirth` to create a method that returns all
    players by their date of birth and `findByNameContaining` to return all players
    whose names contain a given string. All this without writing a single line of
    SQL!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们使用了`findByDateOfBirth`来创建一个方法，该方法通过出生日期返回所有球员，以及`findByNameContaining`来返回所有名字包含给定字符串的球员。所有这些都不需要写一行SQL代码！
- en: If you are unfamiliar with the naming convention, I strongly recommend checking
    the project documentation. See [https://docs.spring.io/spring-data/jpa/reference/#repository-query-keywords](https://docs.spring.io/spring-data/jpa/reference/#repository-query-keywords).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对命名约定不熟悉，我强烈建议检查项目文档。请参阅[https://docs.spring.io/spring-data/jpa/reference/#repository-query-keywords](https://docs.spring.io/spring-data/jpa/reference/#repository-query-keywords)。
- en: In addition to the operations to read data, `CrudRepository` and `JpaRepository`
    have a method named `save`. This method allows you to update existing entities
    or create new ones if they don’t already exist. They also have some methods to
    delete entities, such as `delete`, `deleteById` and other methods.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了读取数据的操作外，`CrudRepository`和`JpaRepository`还有一个名为`save`的方法。这个方法允许你更新现有实体或创建新的实体（如果它们还不存在的话）。它们还有一些删除实体的方法，例如`delete`、`deleteById`和其他方法。
- en: Even with the abstraction offered by Spring Data JPA, it’s crucial to understand
    some of the inner workings of Spring Data. In this recipe, I used a middle tier
    component named `FootballService` between the controller and the repositories.
    You could also call a repository directly from your controller, however there
    are some caveats with this approach. To better understand it, lets deep dive on
    the operation to return a team and its players.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有了Spring Data JPA提供的抽象，理解Spring Data的一些内部工作原理也是至关重要的。在这个菜谱中，我在控制器和仓库之间使用了一个名为`FootballService`的中层组件。你也可以直接从控制器调用仓库，然而这种方法有一些注意事项。为了更好地理解它，让我们深入探讨返回一个团队及其球员的操作。
- en: 'Hibernate has two ways of loading the entities with related entities: `TeamEntity`
    has a member annotated with @OneToMany to manage its Player Entities. When your
    application uses the method `getPlayers` of the class `TeamEntity`, Hibernate
    tries to load the players by performing a request to the database. By default,
    @OneToMany relations are loaded in Lazy mode, while @ManyToOne are loaded in Eager
    mode. In summary, Lazy means, that if you don’t use the relation, the request
    to the database won’t happen. If you use the repository to retrieve the team in
    the controller and you try to return the `TeamEntity`, it will serialize the entity
    into a Json object, traversing all properties, including the players. At that
    stage of the request execution, there is no session open to access the database
    and you will receive an exception. There are several ways to fix this issue:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate有两种方式加载与实体相关的实体：`TeamEntity`有一个用@OneToMany注解的成员来管理其球员实体。当你的应用程序使用`TeamEntity`类的`getPlayers`方法时，Hibernate会尝试通过向数据库发送请求来加载球员。默认情况下，@OneToMany关系以懒加载模式加载，而@ManyToOne以急加载模式加载。总的来说，懒加载意味着，如果你不使用这个关系，就不会向数据库发送请求。如果你在控制器中通过仓库检索团队并尝试返回`TeamEntity`，它将序列化实体到一个Json对象中，遍历所有属性，包括球员。在请求执行的这一阶段，没有打开会话来访问数据库，你将收到一个异常。有几种方法可以解决这个问题：
- en: By retrieving the players at the same time as the team by using the Eager mode.
    It can be valid in certain scenarios, but it could cause unnecessary requests
    to the database.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用急加载模式同时检索团队和球员。在某些场景中可能是有效的，但它可能导致不必要的数据库请求。
- en: By allowing opening connections in view. This can be done using `spring.jpa.open-in-view=true`.
    This is an antipattern and I strongly recommend not using it.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过允许在视图中打开连接。这可以通过使用`spring.jpa.open-in-view=true`来实现。这是一个反模式，我强烈建议不要使用它。
- en: I had a bad experience related to this antipattern working on a project. I had
    an issue related to bad performance and availability of the application, but the
    system had resources and any component seemed under stress. Finally, I realized
    there were connection leaks in the application due to this `open-in-view` option.
    Finding the root cause and resolving this bug was one of the most challenging
    tasks I’ve encountered, as figuring out the root cause was not obvius.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我在处理一个项目时遇到了与这个反模式相关的一个糟糕的经历。我遇到了一个与性能和可用性相关的问题，但系统有资源，任何组件似乎都处于压力之下。最后，我意识到由于这个`open-in-view`选项，应用程序中存在连接泄漏。找到根本原因并解决这个bug是我遇到的最具挑战性的任务之一，因为找出根本原因并不明显。
- en: By the way, `spring.jpa.open-in-view=true` is the default value in Spring Boot,
    so keep this in mind and configure as false unless you have a good reason that
    I cannot imagine.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 顺便说一句，`spring.jpa.open-in-view=true`是Spring Boot的默认值，所以请记住这一点，除非你有我无法想象的好理由，否则请将其配置为false。
- en: By creating a session or a transaction while you are retrieving the data, including
    the lazy relations. This is the approach followed in this recipe. When mapping
    from `TeamEntity` to `Team`, we used the method `getPlayers`, and hence retrieved
    the data from the database. As the method `getTeam` in the `FootballService` is
    marked as `@Transactional`, all requests happen in the same transaction/session.
    As this is a read operation, you can set `@Transactional(readOnly = true)`, for
    having a less costly isolation mode for your transaction.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在检索数据时创建一个会话或事务，包括懒关系。这是本菜谱中采用的方法。当我们从`TeamEntity`映射到`Team`时，我们使用了`getPlayers`方法，因此从数据库中检索了数据。由于`FootballService`中的`getTeam`方法被标记为`@Transactional`，所有请求都在同一个事务/会话中发生。由于这是一个读操作，你可以设置`@Transactional(readOnly
    = true)`，为你的事务提供一个成本更低的隔离模式。
- en: By performing a `Join` query to retrieve both the team and its players in a
    single database request. This is the most efficient way to implement this scenario.
    We will see how to do it in another recipe of this chapter.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过执行一个`Join`查询来在一次数据库请求中检索团队及其球员。这是实现此场景的最有效方式。我们将在本章的另一道菜谱中看到如何实现它。
- en: That is the reason to create a `Service` class and not return Entities directly
    in the RESTful API.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是创建`Service`类而不是直接在RESTful API中返回实体的原因。
- en: There’s more...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this exercise, we used an existing database, and we manually created the
    entities and repositories to interact with the database. There is another approach
    that we will tackle in further recipes of this chapter, that defines the entities
    first and then generates the database automatically. For both scenarios there
    are tools that assist you in this task that can be very mechanical. For instance,
    you can use JPA Buddy plugin for IntelliJ, [https://plugins.jetbrains.com/plugin/15075-jpa-buddy](https://plugins.jetbrains.com/plugin/15075-jpa-buddy).
    It has a basic free version that is enough for simple scenarios, and a paid one
    with advanced features.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了一个现有的数据库，并手动创建了实体和仓库来与数据库交互。还有另一种方法，我们将在本章的后续菜谱中解决，它首先定义实体然后自动生成数据库。对于这两种场景，都有工具可以帮助你完成这项任务，可以非常机械。例如，你可以使用
    IntelliJ 的 JPA Buddy 插件，[https://plugins.jetbrains.com/plugin/15075-jpa-buddy](https://plugins.jetbrains.com/plugin/15075-jpa-buddy)。它有一个基本的免费版本，对于简单场景已经足够，还有一个付费版本，具有高级功能。
- en: In this recipe, we created some code to transform Entities into other objects,
    also known as **Data Transfer Objects** (**DTOs**). It could add a lot of boilerplate
    code in your project. There are libraries that automate mapping between Java Beans
    that can fit well in this scenario. For example Mapstruct (https://mapstruct.org/).
    Spring Data JPA supports using Mapstruct to convert Entities to DTO and viceversa.
    For learning purposes, I don’t use it in the recipes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一些代码来将实体转换为其他对象，也称为**数据传输对象**（**DTO**）。这可能会在你的项目中添加很多样板代码。有一些库可以自动化
    Java Bean 之间的映射，非常适合这种场景。例如 Mapstruct（https://mapstruct.org/）。Spring Data JPA
    支持使用 Mapstruct 将实体转换为 DTO 以及相反。出于学习目的，我在菜谱中没有使用它。
- en: See also
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: If you want to learn more about **Open Session In View** (**OSIV**) antipattern,
    I recommend you to read this article [https://vladmihalcea.com/the-open-session-in-view-anti-pattern/](https://vladmihalcea.com/the-open-session-in-view-anti-pattern/)
    to understand the details.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于**视图中的打开会话**（**OSIV**）反模式的细节，我建议你阅读这篇文章 [https://vladmihalcea.com/the-open-session-in-view-anti-pattern/](https://vladmihalcea.com/the-open-session-in-view-anti-pattern/)。
- en: Creating the database schema from our code
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从我们的代码创建数据库模式
- en: Creating a database schema and its corresponding Entities in our application,
    as seen in the previous recipe, requires a lot of repetitive work. Instead, we
    can create our Entities and we can generate the database schema automatically.
    In this recipe, we will use Spring Data JPA to generate the database schema based
    on the entity model of the application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中创建数据库模式及其相应的实体，如前一个菜谱所示，需要大量的重复工作。相反，我们可以创建我们的实体，并可以自动生成数据库模式。在这个菜谱中，我们将使用
    Spring Data JPA 根据应用程序的实体模型生成数据库模式。
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need the same tools as in the previous recipe, namely
    a PostgreSQL server that you can run in a Docker container or on your computer.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，你需要与上一个菜谱相同的工具，即一个可以在 Docker 容器或你的电脑上运行的 PostgreSQL 服务器。
- en: We will use the same code generated in the previous recipe. If you didn’t complete
    it, you can find a completed recipe in the book’s GitHub repository https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用前一个菜谱中生成的相同代码。如果你没有完成它，你可以在书的 GitHub 仓库 https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/
    中找到一个完成的菜谱。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will use the previous example about football teams and players. Still, in
    this recipe, instead of using an existing database and creating the mapping entities,
    we will go in the opposite direction. We will use and tune the Entities already
    created to generate the Database schema. Let’s begin:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前关于足球队和球员的例子。然而，在这个菜谱中，我们不会使用现有的数据库和创建映射实体，而是相反的方向。我们将使用和调整已经创建的实体来生成数据库模式。让我们开始：
- en: Create a new database named `football2`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `football2` 的新数据库。
- en: Open psql in your terminal.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的终端中打开 psql。
- en: '[PRE25]'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Execute the following SQL command to create the database:'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行以下 SQL 命令以创建数据库：
- en: '[PRE26]'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Instead of manually generating the identifiers of our entities we will rely
    on the automatic identifier generators of the database. For that purpose, we will
    modify the annotation `@Id` of our entities.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不会手动生成实体的标识符，而是依赖数据库的自动标识符生成器。为此，我们将修改我们实体的 `@Id` 注解。
- en: 'Open `TeamEntity` and modify the member id as follows:'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 `TeamEntity` 中的成员 ID，如下所示：
- en: '[PRE27]'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Do the same with `PlayerEntity`.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用 `PlayerEntity` 做同样的事情。
- en: 'Open `application.yml` file and add the `spring.jpa.generate-ddl=true` and
    `spring.sql.init.mode=always` properties. The file should look like this:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `application.yml` 文件，并添加 `spring.jpa.generate-ddl=true` 和 `spring.sql.init.mode=always`
    属性。文件应该看起来像这样：
- en: '[PRE28]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you run the application, the database schema will be created automatically.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你运行应用程序，数据库模式将自动创建。
- en: 'Modify the `createTeam` method in class `FootballService`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `FootballService` 类中的 `createTeam` 方法：
- en: '[PRE29]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we removed the generation of the team identifier, instead it will be automatically
    generated.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们移除了团队标识符的生成，而是让它自动生成。
- en: Copy the file located in the GitHub repository, in `chapter5/recipe5-4/start/data.sql`,
    to the resources folder. This folder is located in `src/main/resources`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将位于 GitHub 存储库中的文件 `chapter5/recipe5-4/start/data.sql` 复制到资源文件夹。这个文件夹位于 `src/main/resources`。
- en: Execute the application.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。
- en: Test the application by performing requests to the application as explained
    in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020). I also provided a script that
    you can find in the repository with curl requests for this application. It is
    located at `chapter5/recipe5-4/end/scripts/requests.sh`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照第 [*1章*](B21646_01.xhtml#_idTextAnchor020) 中所述，通过向应用程序执行请求来测试应用程序。我还提供了一个脚本，你可以在存储库中找到这个脚本，其中包含对该应用程序的
    curl 请求。它位于 `chapter5/recipe5-4/end/scripts/requests.sh`。
- en: You will see that the database schema is initialized, and it already has data.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到数据库模式已初始化，并且已经有数据。
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'By configuring the application with *spring.jpa.generate-ddl=true*, Spring
    Data will automatically generate the data schema from the entities defined in
    the project. It will use the annotations to generate the schema according to the
    target database. For instance, we used `@GeneratedValue` for id field in both
    `PlayerEntity` and `TableEntity`. It is translated into a PostgreSQL sequences.
    Taking the `TeamEntity` as an example, this is the result in PostgreSQL:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置应用程序为 `*spring.jpa.generate-ddl=true`，Spring Data 将自动从项目中定义的实体生成数据模式。它将使用注解根据目标数据库生成模式。例如，我们在
    `PlayerEntity` 和 `TableEntity` 中的 id 字段都使用了 `@GeneratedValue`。它被转换成 PostgreSQL
    序列。以 `TeamEntity` 为例，这是在 PostgreSQL 中的结果：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Spring Boot is able to create the schema and initialize data. It loads schema
    scripts from `optional:classpath*:schema.sql` and data scripts from `optional:classpath*:data.sql`.
    We only provided data scripts explicitly, and we did let Spring Boot generate
    the schema with `generate-ddl` setting. In addition to the data scripts, you can
    also provide the schema scripts instead of letting Spring Boot generate them for
    you. For complex applications, probably you will require specific database settings..
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 能够创建模式和初始化数据。它从 `optional:classpath*:schema.sql` 加载模式脚本，从 `optional:classpath*:data.sql`
    加载数据脚本。我们只明确提供了数据脚本，并且我们确实让 Spring Boot 通过 `generate-ddl` 设置来生成模式。除了数据脚本之外，你也可以提供模式脚本，而不是让
    Spring Boot 为你生成它们。对于复杂的应用程序，你可能需要特定的数据库设置。
- en: As mentioned, in this recipe we let Spring Boot performing the database initialization.
    By default, Spring Boot only performs the initialization if it considers that
    the database is an In-Memory embedded database, such as H2\. To force the initialization
    for PostgreSQL, we used the parameter `spring.sql.init.mode=always`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在这个菜谱中，我们让 Spring Boot 执行数据库初始化。默认情况下，Spring Boot 只有在它认为数据库是一个内存嵌入数据库（如
    H2）时才会执行初始化。为了强制对 PostgreSQL 进行初始化，我们使用了参数 `spring.sql.init.mode=always`。
- en: The approach followed in this recipe is intended for development environments.
    In a production environment, we could have multiple instances of the same application
    and it can cause issues having more than one instance trying to initialize the
    database. Even with mechanisms in place to ensure that only one instance of the
    application is updating the database, this process can take time and will slow
    down the application initialization. It is important to note, that some of those
    scripts should be executed only once. For instance, in this recipe we used a `data.sql`
    that insert records in both tables using explicit id values. If you try to execute
    it twice will produce a unique constraint validation error. For initialization
    you most probably want to execute the process before all the application instances
    start. For instance, in Kubernetes you can achieve this by using Init Containers,
    see https://kubernetes.io/docs/concepts/workloads/pods/init-containers/.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱中遵循的方法旨在用于开发环境。在生产环境中，我们可能有相同应用的多实例，并且多个实例尝试初始化数据库可能会引起问题。即使有机制确保只有一个应用实例更新数据库，这个过程也可能需要时间并减慢应用初始化速度。重要的是要注意，其中一些脚本应该只执行一次。例如，在这个菜谱中，我们使用了`data.sql`，它使用显式的id值在两个表中插入记录。如果您尝试执行两次，将产生唯一约束验证错误。对于初始化，您最可能希望在所有应用实例启动之前执行此过程。例如，在Kubernetes中，您可以通过使用Init
    Containers来实现这一点，请参阅https://kubernetes.io/docs/concepts/workloads/pods/init-containers/。
- en: For production environments, other tools such as Flyway and Liquibase exist,
    and they are supported by Spring Boot. Those tools provide more control on the
    database creation, providing versioning and migrations. In the next recipe, we’ll
    use Flyway to create and migrate the schema of the database.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产环境，存在其他工具，如Flyway和Liquibase，它们由Spring Boot支持。这些工具提供了对数据库创建的更多控制，提供了版本控制和迁移。在下一个菜谱中，我们将使用Flyway来创建和迁移数据库的模式。
- en: There’s more...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In this recipe, we used few options among all possibilities to customize our
    entities, but almost any aspect of database schema definition can be controlled.
    Just to give some examples:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们只使用了所有可能性中的一些选项来定制我们的实体，但几乎可以控制数据库模式定义的任何方面。仅举几个例子：
- en: '`@Entity`: Annotating a class with `@Entity` indicates that it is a JPA entity
    and should be mapped to a database table. Each entity class corresponds to a table
    in the database, and each field in the class corresponds to a column in the table.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Entity`: 使用`@Entity`注解一个类表示它是一个JPA实体，应该映射到数据库表。每个实体类对应数据库中的一个表，类中的每个字段对应表中的一个列。'
- en: '`@Table`: It is used to specify the details of the database table to which
    an entity should be mapped. You can use it to set the table name, schema, and
    other attributes.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Table`: 它用于指定实体应映射到的数据库表的详细信息。您可以使用它来设置表名、模式和其他属性。'
- en: '`@Column`: It allows you to configure the mapping of an entity field to a database
    column. You can specify attributes like column name, length, nullable, and unique
    constraints.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Column`: 它允许您配置实体字段到数据库列的映射。您可以指定诸如列名、长度、可空性和唯一约束等属性。'
- en: '`@JoinColumn`: It is used to specify the column that represents a foreign key
    in a relationship. It is often used in conjunction with `@ManyToOne` or `@OneToOne`
    to specify the join column’s name and other attributes.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@JoinColumn`: 它用于指定表示关系外键的列。它通常与`@ManyToOne`或`@OneToOne`一起使用，以指定连接列的名称和其他属性。'
- en: '`@Transient`: Fields marked with `@Transient` are not mapped to database columns.
    This annotation is used for fields that should be excluded from database persistence.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Transient`: 被标记为`@Transient`的字段不会映射到数据库列。这个注解用于那些应该从数据库持久化中排除的字段。'
- en: '`@Embedded` and `@Embeddable`: These annotations are used for creating embedded
    objects within entities. `@Embeddable` is applied to a class, and `@Embedded`
    is used in an entity to indicate that an instance of the embedded class should
    be persisted as part of the entity.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Embedded`和`@Embeddable`: 这些注解用于在实体中创建嵌入对象。`@Embeddable`应用于一个类，而`@Embedded`用于实体，表示嵌入类的实例应作为实体的一部分进行持久化。'
- en: '`@Version`: It is used to specify a version property for optimistic locking.
    It is typically applied to a numeric or timestamp field and is used to prevent
    concurrent updates to the same record.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Version`: 它用于指定乐观锁的版本属性。它通常应用于数字或时间戳字段，用于防止对同一记录的并发更新。'
- en: See also
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.data-initialization](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.data-initialization)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.data-initialization](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.data-initialization)'
- en: PostgreSQL integration tests with Testcontainers
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Testcontainers 的 PostgreSQL 集成测试
- en: When developing tests for a component, one of the biggest challenges is managing
    dependent services like databases. While creating mocks or using an in-memory
    database like H2 can be a solution, these approaches may hide potential issues
    in our application. **Testcontainers** is an open-source framework that offers
    temporary instances of popular databases and other services that can be run on
    Docker containers. This provides a more reliable way to test applications.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发组件的测试时，最大的挑战之一是管理数据库等依赖服务。虽然创建模拟或使用像 H2 这样的内存数据库可能是一种解决方案，但这些方法可能会隐藏我们应用程序中潜在的问题。**Testcontainers**
    是一个开源框架，它提供了在 Docker 容器上运行的流行数据库和其他服务的临时实例。这为测试应用程序提供了一种更可靠的方法。
- en: In this recipe, you will learn how to create an integration test that depends
    on PostgreSQL using Testcontainers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将学习如何使用 Testcontainers 创建依赖于 PostgreSQL 的集成测试。
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll create some tests for the application created in the previous
    recipe, *Creating the database schema from our code*. I prepared a working version
    as a starting point for this recipe in case you haven’t completed the previous
    recipe yet. You can find it in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将为上一个菜谱中创建的应用程序创建一些测试，即 *从我们的代码创建数据库模式*。如果您还没有完成上一个菜谱，我准备了一个工作版本作为这个菜谱的起点。您可以在本书的
    GitHub 仓库中找到它：[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)。
- en: Testcontainers requires Docker installed in your computer.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Testcontainers 需要在您的计算机上安装 Docker。
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let’s enhance the reliability of our application by creating tests that utilize
    a real PostgreSQL database.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建利用真实 PostgreSQL 数据库的测试来提高我们应用程序的可靠性。
- en: 'First, we’ll need to include the Testcontainers starter and the PostgreSQL
    Testcontainer dependency. You can do it by adding the following dependencies in
    the project `pom.xml` file:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要包含 Testcontainers 启动器和 PostgreSQL Testcontainer 依赖项。您可以通过在项目的 `pom.xml`
    文件中添加以下依赖项来实现：
- en: '[PRE31]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, create a test class, you can name it `FootballServiceTest`. Let’s setup
    the class for TestContainers. For that we’ll need:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个测试类，您可以将其命名为 `FootballServiceTest`。让我们为 TestContainers 设置这个类。为此，我们需要：
- en: Annotate the class with `@SpringBootTest`.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@SpringBootTest` 注解该类。
- en: Annotate the class with `@TestContainers`.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@TestContainers` 注解该类。
- en: Configure a context initializer that configures the application context using
    the PostgreSQL container that we’ll create during the test. To set the initializer
    we can annotate the class with `@ContextConfiguration`.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置一个上下文初始化器，使用我们在测试期间创建的 PostgreSQL 容器配置应用程序上下文。为了设置初始化器，我们可以使用 `@ContextConfiguration`
    注解该类。
- en: 'The class definition will look like this:'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类定义看起来是这样的：
- en: '[PRE32]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, there is a reference to `FootballServiceTest.Initializer` class
    that we haven’t described yet. It’s explained in the following steps.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如您所看到的，有一个对 `FootballServiceTest.Initializer` 类的引用，我们还没有描述。它将在以下步骤中解释。
- en: 'Now, we’ll define a static field with the PostgreSQL container:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将定义一个静态字段，使用 PostgreSQL 容器：
- en: '[PRE33]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let’s use the container we just created to configure the application. It’s
    now when we’ll create the `FootballServiceTest.Initializer` class. Inside the
    FootballServiceTest create a class named Initializer:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用刚刚创建的容器来配置应用程序。现在是我们创建 `FootballServiceTest.Initializer` 类的时候了。在 FootballServiceTest
    中创建一个名为 Initializer 的类：
- en: '[PRE34]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The initializer overrides the data source configuration using the PostgreSQLContainer
    settings.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始化器使用 PostgreSQLContainer 设置覆盖数据源配置。
- en: 'The final step in configuring Testcontainers is to start the container, which
    can be done before all tests begin using `@BeforeAll` annotation. Let’s create
    a method that starts the container:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 Testcontainers 的最后一步是启动容器，这可以通过使用 `@BeforeAll` 注解在所有测试开始之前完成。让我们创建一个启动容器的函数：
- en: '[PRE35]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we can create the tests normally. For example, let’s make a test that
    creates a team:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以正常创建测试。例如，让我们创建一个创建团队的测试：
- en: '[PRE36]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `@Testcontainers` annotation searches for all fields tagged with @Container
    and triggers their container lifecycle methods. Containers declared as static
    fields, like in this recipe, are shared between test methods. This means that
    the container is started only once, before any test method is executed, and stopped
    after the last test method has executed. If the container were declared as an
    instance field, it would be started and stopped for each test method.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Testcontainers`注解会搜索所有带有@Container标记的字段，并触发它们的容器生命周期方法。声明为静态字段的容器，如本菜谱中所示，在测试方法之间是共享的。这意味着容器仅在执行任何测试方法之前启动一次，并在最后一个测试方法执行后停止。如果容器被声明为实例字段，它将为每个测试方法启动和停止。'
- en: The PostgreSQLContainer is a specialized Testcontainer module that exposes the
    attributes of the database to facilitate the connection in our tests. We used
    the JdbcUrl, the username and the password to override the configuration.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQLContainer是一个专门的Testcontainer模块，它将数据库的属性暴露出来，以方便我们在测试中进行连接。我们使用了JdbcUrl、用户名和密码来覆盖配置。
- en: As you can see, we didn’t require mocking any repository to create tests for
    the FootballService class. Another great advantage is that the database is recreated
    for every test execution cycle, so the tests are repeatable and predictable.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们不需要模拟任何存储库来为FootballService类创建测试。另一个巨大的优点是，数据库在每次测试执行周期中都会被重新创建，因此测试是可重复和可预测的。
- en: Versioning and upgrading database schema
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库模式版本控制和升级
- en: As our applications evolve, we’ll need to keep the database in sync with our
    Java entities. That could be a complex and error prone task. To address this scenario,
    there are tools to manage database schemas and database migrations. A couple of
    examples of such tools are Flyway and Liquibase, both supported by Spring Boot.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序的发展，我们需要保持数据库与我们的Java实体同步。这可能是一个复杂且容易出错的任务。为了应对这种情况，有一些工具可以管理数据库模式和数据库迁移。此类工具的几个示例是Flyway和Liquibase，它们都受Spring
    Boot支持。
- en: 'In addition to the database migration feature itself, Flyway provides the following
    features:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据库迁移功能本身之外，Flyway还提供了以下功能：
- en: Version control to keep track of the migrations applied to a database and the
    ones which are pending.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制以跟踪应用到数据库的迁移和待处理的迁移。
- en: It can be integrated into development environments and build automation tools,
    such as Maven or Gradle.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以集成到开发环境和构建自动化工具中，例如Maven或Gradle。
- en: Repeatable migrations. Every time Flyway runs, repeatable migrations are executed
    ensuring that the database remains in the desired state.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重复迁移。每次Flyway运行时，都会执行可重复迁移，确保数据库保持所需状态。
- en: Rollback and undo operations. Flyway can automatically generate SQL scripts
    to undo a specific migration, allowing rollbacks in case of issues.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回滚和撤销操作。Flyway可以自动生成SQL脚本以撤销特定的迁移，以便在出现问题时进行回滚。
- en: It can execute the migration during the initialization of your project.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在您的项目初始化期间执行迁移。
- en: It provides standalone tools that can be used out of your Java project.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一些独立工具，可以在Java项目之外使用。
- en: When used in your project, it requires different configurations to perform the
    migration, for instance registering specific beans. Spring Boot facilitates that
    integration, minimizing the necessary configuration to just some application settings
    unless you need more advanced actions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当在您的项目中使用时，它需要不同的配置来执行迁移，例如注册特定的bean。Spring Boot简化了这种集成，将必要的配置最小化到仅一些应用程序设置，除非您需要更高级的操作。
- en: Getting ready
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can use the exercise completed in the previous recipe as starting point
    for this recipe. If you haven’t completed yet, you can find a complete version
    in the book’s GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/.
    You will need the same tools, PostgreSQL and Docker.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将上一道菜谱中完成的练习作为这道菜谱的起点。如果您还没有完成，您可以在书的GitHub仓库中找到一个完整版本，网址为https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/。您将需要相同的工具，PostgreSQL和Docker。
- en: Flyway is a solution maintained by Redgate, with free edition for individual
    and non-commercial projects and paid supported editions. For this recipe, we can
    use the libraries but keep in mind that using Flyway in a production environment
    may require a Redgate license. See https://documentation.red-gate.com/fd/licensing-164167730.html
    for details.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Flyway是由Redgate维护的解决方案，为个人和非商业项目提供免费版，并为付费支持版。对于这道菜谱，我们可以使用库，但请记住，在生产环境中使用Flyway可能需要Redgate许可证。有关详细信息，请参阅https://documentation.red-gate.com/fd/licensing-164167730.html。
- en: How to do it...
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this recipe, we’ll use Flyway to create an initial version of the database,
    and then we’ll apply changes. We’ll learn how it can be easily used with Spring
    Boot.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用Flyway创建数据库的初始版本，然后应用更改。我们将学习如何轻松地与Spring Boot一起使用它。
- en: Create a new database named `football3`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`football3`的新数据库。
- en: Open psql in your terminal.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的终端中打开psql。
- en: '[PRE37]'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Execute the following SQL command to create the database:'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行以下SQL命令以创建数据库：
- en: '[PRE38]'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Add Flyway dependency. In your `pom.xml` file add the dependency `org.flywaydb:flywaycore`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Flyway依赖项。在您的`pom.xml`文件中添加依赖项`org.flywaydb:flywaycore`。
- en: '[PRE39]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create the database creation script. The default location for flyway scripts
    is under `src/main/resources/db`. Name the file `V1_InitialDatabase.sql` and add
    the following content to create the `teams` and `players` tables:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数据库创建脚本。Flyway脚本的默认位置在`src/main/resources/db`下。将文件命名为`V1_InitialDatabase.sql`并添加以下内容以创建`teams`和`players`表：
- en: '[PRE40]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can also use this script to fill the database with data, for instance adding
    `teams` and `players`.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您也可以使用此脚本向数据库中填充数据，例如添加`teams`和`players`。
- en: '[PRE41]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the book’s GitHub repository, you can find more data for this script, you
    can copy and paste in your project if you wish.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本书的GitHub仓库中，您可以找到更多与此脚本相关的数据，如果您愿意，可以将其复制并粘贴到您的项目中。
- en: Migration files naming convention
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移文件命名约定
- en: 'Migration files should follow the naming convention: `V<version>__<name>.sql`,
    version can be `<major version>_<minor version>`, but it is optional. Pay attention
    that between `<version>` and `<name>` there are two underscore signs.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移文件应遵循命名约定：`V<版本>__<名称>.sql`，版本可以是`<主版本>_<次版本>`，但这是可选的。请注意，在`<版本>`和`<名称>`之间有两个下划线符号。
- en: Launch the application.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序。
- en: 'If you look at the output logs, you will see a message similar to this:'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您查看输出日志，您将看到类似以下的消息：
- en: "![Figure 5.2\uFEFF: Application logs showing migration execution.](img/B21646_05_2.jpg)"
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2：显示迁移执行的应用程序日志](img/B21646_05_2.jpg)'
- en: 'Figure 5.2: Application logs showing migration execution.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：显示迁移执行的应用程序日志。
- en: Flyway created a new table to manage the schema history named `flyway_schema_history`
    and executed the script we create above. You can get the list of tables in PostgreSQL
    using command *\dt*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Flyway创建了一个名为`flyway_schema_history`的新表来管理架构历史，并执行了我们上面创建的脚本。您可以使用命令`*\dt*`在PostgreSQL中获取表列表。
- en: "![Figure 5.3\uFEFF: List of tables in recently in the database created by Flyway.](img/B21646_05_3.jpg)"
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3：显示Flyway最近创建的数据库中表列表](img/B21646_05_3.jpg)'
- en: 'Figure 5.3: List of tables in recently in the database created by Flyway.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：显示Flyway最近创建的数据库中表列表。
- en: The database now has the tables necessary to manage our application.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据库已经有了管理我们应用程序所需的表。
- en: Let’s create a migration for our application now. We need to manage football
    matches in our application, and we need to know the height and weight of the players.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为我们的应用程序创建一个迁移。我们需要在我们的应用程序中管理足球比赛，并且我们需要知道球员的身高和体重。
- en: 'The matches will be managed in a new Entity named `MatchEntity`. It will have
    two fields referencing the teams playing the match, the match date, and the goals
    scored by each team. It should look like this:'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比赛将由一个名为`MatchEntity`的新实体来管理。它将有两个字段引用比赛的球队、比赛日期以及每队进球数。它应该看起来像这样：
- en: '[PRE42]'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The existing entity `PlayerEntity` should have two new properties to manage
    the height and weight of the player.
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的实体`PlayerEntity`应该有两个新属性来管理球员的身高和体重。
- en: '[PRE43]'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We need to create the SQL scripts for the database now. In `src/main/resources/db`
    create a new sql file named `V2__AddMatches.sql`. Add the required changes on
    the database to support the application.
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们需要为数据库创建SQL脚本。在`src/main/resources/db`中创建一个名为`V2__AddMatches.sql`的新sql文件。在数据库中添加必要的更改以支持应用程序。
- en: Create the table `matches`
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`matches`表
- en: '[PRE44]'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Modify the table players to add the two columns for the height and weight.
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`players`表以添加身高和体重两列。
- en: '[PRE45]'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can also set values for the existing players, for simplicity, we can set
    the same values for all players:'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以为现有球员设置值，为了简单起见，我们可以为所有球员设置相同的值：
- en: '[PRE46]'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Execute the application.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。
- en: If you check the logs, you will see the schema migration applied by Flyway.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您检查日志，您将看到Flyway应用的结构迁移。
- en: "![Figure 5.4\uFEFF: Application logs showing the new schema migration.](img/B21646_05_4.jpg)"
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4：显示新架构迁移的应用程序日志](img/B21646_05_4.jpg)'
- en: 'Figure 5.4: Application logs showing the new schema migration.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：显示新架构迁移的应用程序日志。
- en: During the startup of the application, the database is initialized. In order
    to ensure that the migration is working as expected, you can use Testcontainers
    to validate it. You can check if certain data exists in the database using this
    approach. There are some tests available in the book’s GitHub repository that
    assume the existence of certain values in the database.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序启动期间，数据库被初始化。为了确保迁移按预期工作，你可以使用Testcontainers来验证它。你可以使用这种方法检查数据库中是否存在某些数据。书中GitHub存储库中提供了一些测试，假设数据库中存在某些值。
- en: How it works...
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: On adding the Flyway dependency to your project, it will check for migration
    scripts during the application startup. If there are migration scripts, it will
    connect to the database and check for migrations that have been already applied
    by looking at the table `flyway_schema_history`. If that table doesn’t exist yet,
    it will create it. Then it will start executing all migrations that have not been
    applied yet in order. For instance, in our sample, if you start the application
    pointing to an empty database, it will apply `V1__InitialDatabase.sql` first and
    then `V2__AddMatches.sql`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在将Flyway依赖项添加到你的项目中时，它将在应用程序启动时检查迁移脚本。如果有迁移脚本，它将连接到数据库，并查看通过查看`flyway_schema_history`表已应用的迁移。如果该表尚不存在，它将创建它。然后，它将按顺序执行所有尚未应用的迁移。例如，在我们的示例中，如果你指向一个空数据库启动应用程序，它将首先应用`V1__InitialDatabase.sql`，然后是`V2__AddMatches.sql`。
- en: 'Flyway also uses `flyway_schema_history` table to control the concurrency while
    applying migrations. If you have more than one instance of your application, all
    of them will try to perform the same procedure:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Flyway还使用`flyway_schema_history`表来在应用迁移时控制并发。如果你有多个应用程序实例，它们都将尝试执行相同的程序：
- en: The first application instance checks if the expected version is the same than
    the version deployed by looking at the `flyway_schema_history` table.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个应用程序实例将检查预期的版本是否与通过查看`flyway_schema_history`表部署的版本相同。
- en: If the version deployed is the expected, they will continue the application
    normally.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果部署的版本是预期的，它们将正常继续应用程序。
- en: If the version is different, it will lock the `flyway_schema_history` table,
    and will apply the migration.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果版本不同，它将锁定`flyway_schema_history`表，并应用迁移。
- en: The rest of application instances wait until the `flyway_schema_history` table
    is released.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其余的应用程序实例将等待直到`flyway_schema_history`表被释放。
- en: When the migration finishes, the first application instance will update the
    version in `flyway_schema_history` table and will release it.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移完成后，第一个应用程序实例将更新`flyway_schema_history`表中的版本，并将其释放。
- en: Then, the rest of application instances will check the version as in step 1\.
    As it is already deployed, they will continue normally without applying the migration
    again.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，其余的应用程序实例将按照步骤1检查版本。由于它们已经部署，它们将正常继续，而无需再次应用迁移。
- en: Another validation performed by flyway is checking if a migration file has been
    modified. The way it does it is by generating a checksum of the content and saving
    in the `flyway_schema_history`. A checksum is a kind of signature generated from
    the content that can be used to verify that content has not been modified. The
    purpose of this validation is to ensure the consistency and repeatability of the
    process.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Flyway还执行另一种验证，即检查迁移文件是否已被修改。它是通过生成内容的校验和并将其保存到`flyway_schema_history`中来实现这一点的。校验和是从内容中生成的一种签名，可用于验证内容是否未被修改。这种验证的目的是确保过程的一致性和可重复性。
- en: Important
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: Once applied a migration, don’t modify the script file. If you need to fix a
    migration, create a new one performing the fix.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用了迁移，不要修改脚本文件。如果你需要修复迁移，请创建一个新的迁移来执行修复。
- en: Keep in mind that large migrations, for instance those requiring data transformation,
    may produce locks on the database and potential downtimes in your application,
    as the application won’t complete the initialization until the migration completes.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，大型迁移，例如需要数据转换的迁移，可能会在数据库上产生锁，并可能导致你的应用程序出现潜在的停机时间，因为应用程序将不会在迁移完成之前完成初始化。
- en: There’s more...
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Flyway provides a powerful mechanism to perform consistent migrations and keep
    your code in sync with the database schema. It provides robust mechanisms for
    versioning and rollback/undo operations as well as repeatable migrations.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Flyway提供了一个强大的机制来执行一致的迁移，并保持你的代码与数据库模式同步。它提供了强大的版本控制和回滚/撤销操作以及可重复迁移的机制。
- en: 'If your application has complex requirements related to other components and
    not only your application, Flyway provides a mechanism named *Callback* to invoke
    additional actions related to the migrations, such as recompiling stored procedures,
    recalculating materialized view or flushing a cache, etc. If you have that kind
    of requirements, I recommend you to take a look at this documentation: [https://documentation.red-gate.com/flyway/flyway-cli-and-api/concepts/callback-concept](https://documentation.red-gate.com/flyway/flyway-cli-and-api/concepts/callback-concept).'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用与其他组件有关且不仅仅是您的应用有复杂需求，Flyway提供了一个名为*回调*的机制来调用与迁移相关的额外操作，例如重新编译存储过程、重新计算物化视图或刷新缓存等。如果您有这种需求，我建议您查看以下文档：[https://documentation.red-gate.com/flyway/flyway-cli-and-api/concepts/callback-concept](https://documentation.red-gate.com/flyway/flyway-cli-and-api/concepts/callback-concept)。
- en: One drawback of using Flyway is that it may slow down the application boot process,
    even if there is no migration to apply. For that reason, Flyway also provides
    standalone tools to manage migrations, such as a Desktop UI and a command line
    tool. These tools aid in the process of allowing the migrations and related actions
    without adding any dependency to your project and performing the migration process
    independently.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Flyway的一个缺点是，即使没有迁移要应用，它也可能减慢应用启动过程。因此，Flyway还提供了独立工具来管理迁移，例如桌面UI和命令行工具。这些工具有助于在不添加任何依赖项到您的项目的情况下，独立执行迁移过程和相关操作。
- en: See also
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: In this exercise, I focused on Flyway as a tool to manage database versioning,
    but Spring Boot also offers support for Liquibase. Just as Flyway, Liquibase can
    perform migrations during application startup and using independent tools such
    as the CLI. It has free and paid versions. I recommend you evaluate both tools
    and use the one that better meets your requirements.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我专注于将Flyway作为一个管理数据库版本的工具，但Spring Boot也提供了对Liquibase的支持。正如Flyway一样，Liquibase可以在应用启动时执行迁移，并使用独立的工具，如CLI。它有免费和付费版本。我建议您评估这两个工具，并使用更适合您需求的那个。
- en: Using JPQL
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JPQL
- en: '**JPQL** stands for **Java Persistence Query Language**. It is a platform-independent
    query language that is used to query and manipulate data stored in relational
    databases using the **Java Persistence** **API** (**JPA**).'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**JPQL**代表**Java持久化查询语言**。它是一个平台无关的查询语言，用于使用**Java持久化** **API**（**JPA**）查询和操作存储在关系数据库中的数据。'
- en: JPQL is similar in syntax to SQL, but it operates at the object level, allowing
    developers to write queries in terms of Java objects and their relationships rather
    than database tables and columns. This makes JPQL a more natural choice for developers
    working with Java-based applications and object-relational mapping frameworks
    like Hibernate.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: JPQL的语法与SQL相似，但它操作在对象级别，允许开发者以Java对象及其关系为术语编写查询，而不是以数据库表和列为术语。这使得JPQL成为与基于Java的应用和对象关系映射框架（如Hibernate）一起工作的开发者的更自然选择。
- en: 'Some key features and concepts of JPQL include:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: JPQL的一些关键特性和概念包括：
- en: '**Entity Classes**: JPQL queries are written against Java entity classes, which
    are Java objects that represent database tables.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体类**：JPQL查询是针对Java实体类编写的，这些实体类是代表数据库表的Java对象。'
- en: '**Object-Oriented Queries**: JPQL allows you to query and manipulate data in
    an object-oriented way, using the names of Java classes and their attributes.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向对象的查询**：JPQL允许您以面向对象的方式查询和操作数据，使用Java类及其属性的名称。'
- en: '**Relationships**: JPQL supports querying data based on the relationships between
    entities, such as one-to-one, one-to-many, and many-to-many associations.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关系**：JPQL支持基于实体之间关系的数据查询，例如一对一、一对多和多对多关联。'
- en: '**Portability**: JPQL queries are written in a way that is independent of the
    underlying database system, making it possible to switch databases without changing
    the queries.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：JPQL查询是以一种与底层数据库系统无关的方式编写的，这使得在不更改查询的情况下切换数据库成为可能。'
- en: '**Type Safety**: JPQL queries are type-checked at compile-time, reducing the
    risk of runtime errors.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型安全**：JPQL查询在编译时进行类型检查，减少了运行时错误的风险。'
- en: JPQL is a powerful tool for working with data in Java-based applications. It
    allows developers to express database queries in a way that is more aligned with
    the object-oriented nature of Java programming.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: JPQL是处理基于Java的应用数据的有力工具。它允许开发者以与Java编程的面向对象特性更一致的方式表达数据库查询。
- en: Getting ready
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we don’t need additional tools compared to previous recipes.
    As a starting point of this exercise, we will use the completed version of previous
    recipe. If you didn’t complete it, you can find it in the book’s repository at
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们不需要与之前菜谱相比额外的工具。作为这个练习的起点，我们将使用之前菜谱的完成版本。如果你没有完成它，你可以在书籍仓库[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)中找到它。
- en: How to do it...
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we will enhance the Repositories created in the previous recipe
    with some advanced queries using JPQL. We will add two more entities, `AlbumEntity`
    and `CardEntity` to emulate a card trading game. The data model will look like
    this:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用JPQL添加一些高级查询来增强之前菜谱中创建的仓库。我们将添加两个额外的实体，`AlbumEntity`和`CardEntity`来模拟卡片交易游戏。数据模型将如下所示：
- en: "![Figure 5.5\uFEFF: PostgreSQL Data model](img/B21646_05_5.jpg)"
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5：PostgreSQL数据模型](img/B21646_05_5.jpg)'
- en: 'Figure 5.5: PostgreSQL Data model'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：PostgreSQL数据模型
- en: 'Let’s begin:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: Add the new Entities and a new repository. We will need to create a new migration.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新的实体和新的仓库。我们需要创建一个新的迁移。
- en: 'AlbumEntity:'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'AlbumEntity:'
- en: '[PRE47]'
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'CardsEntity:'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'CardsEntity:'
- en: '[PRE48]'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'AlbumRepository:'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'AlbumRepository:'
- en: '[PRE49]'
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now create a new Flyway migration to create the tables. To do that, create a
    file named `V3__AddAlbums.sql` and create the tables.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在创建一个新的Flyway迁移来创建表。为此，创建一个名为`V3__AddAlbums.sql`的文件并创建表。
- en: '[PRE50]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This script is available in the book repository, including some sample data.
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此脚本可在书籍仓库中找到，包括一些示例数据。
- en: 'In our trading card game, the `CardEntitity` entity represents the cards that
    the user has. We will create a method to get the players we have of a certain
    team. To do that, in the `AlbumRepository` add the following method:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的交易卡片游戏中，`CardEntitity`实体代表用户拥有的卡片。我们将创建一个方法来获取我们拥有的一定队伍的球员。要做到这一点，在`AlbumRepository`中添加以下方法：
- en: '[PRE51]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We want to know what players we don’t have yet. To find out, add the following
    method in the AlbumsRepository:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想知道我们还没有哪些球员。为了找出答案，在AlbumsRepository中添加以下方法：
- en: '[PRE52]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let’s find which are the players of a certain match, from both teams. In the
    `MatchRepository` add the following method:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们找出特定比赛的双方球员。在`MatchRepository`中添加以下方法：
- en: '[PRE53]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Get a team and its players. To do that, in the `TeamRepository` add the following
    method:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个队伍及其球员。要做到这一点，在`TeamRepository`中添加以下方法：
- en: '[PRE54]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This method can be used now in `FootballService` to get the teams. If you remember
    from the recipe *Connect your application to Postgresql*, we implemented a mechanism
    to avoid the Open Session In View antipattern by adding a `@Transactional` annotation
    in the method `getTeam`. With this new `TeamRepository` method, it retrieves both
    the team and its players in the same session, then it is not necessary `@Transactional`.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在可以在`FootballService`中使用此方法来获取队伍。如果你还记得从菜谱“将你的应用程序连接到Postgresql”，我们通过在`getTeam`方法中添加`@Transactional`注解来实现了一个避免Open
    Session In View反模式的机制。有了这个新的`TeamRepository`方法，它将在同一个会话中检索队伍及其球员，因此不再需要`@Transactional`。
- en: '[PRE55]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Find a list of players. Modify `PlayerRepository` by adding the following method:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找球员列表。通过在`PlayerRepository`中添加以下方法来修改：
- en: '[PRE56]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This method could be also implemented just by using naming convention with no
    need for `@``Query` annotation.
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法也可以仅通过使用命名约定来实现，无需`@Query`注解。
- en: '[PRE57]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Find a list of players whose names contain a certain string. Modify the `PlayerRepository`
    and add the following method:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找包含特定字符串的球员列表。通过在`PlayerRepository`中添加以下方法来修改：
- en: '[PRE58]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Find a list of players whose name starts with a string. Modify the `PlayerRepository`
    and add the following method:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找以特定字符串开头的球员列表。通过在`PlayerRepository`中添加以下方法来修改：
- en: '[PRE59]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Sort the players of a team in ascending order. Modify the `PlayerRepository`
    and add the following repository.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按升序排序一个队伍的球员。修改`PlayerRepository`并添加以下仓库。
- en: '[PRE60]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You can decide how to sort the results.
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以决定如何排序结果。
- en: We have the option to paginate the results. This means that if the result set
    is extensive, we can divide it into pages and retrieve. The `JpaRepository` already
    provides method overloads to page the results. For instance, the method `findAll`
    can receive a pageable parameter to control how the results should be paged.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有分页结果的选择。这意味着如果结果集很大，我们可以将其分成页面并检索。`JpaRepository`已经提供了方法重载来分页结果。例如，`findAll`方法可以接收一个可分页的参数来控制结果应该如何分页。
- en: '[PRE61]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can add this as parameter in any of the methods using a custom query. For
    instance, we can create the following method in `AlbumsRepository`:'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以将此参数添加到任何使用自定义查询的方法中。例如，我们可以在`AlbumsRepository`中创建以下方法：
- en: '[PRE62]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We can also use JPQL to return aggregated results. For instance, let’s create
    a query to get the number of players in a given position, per team.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用JPQL来返回聚合结果。例如，让我们创建一个查询来获取给定位置上每个团队的球员数量。
- en: '[PRE63]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As you can see, the result is not an entity, but just the name of the team and
    the number of players in the position. To return this result we used a custom
    result, implemented as an Interface.
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，结果不是一个实体，而是该位置上的团队名称和球员数量的名称。为了返回这个结果，我们使用了一个自定义的结果，它被实现为一个接口。
- en: '[PRE64]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The interface should have getter methods matching the projected query result.
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接口应该有匹配投影查询结果的getter方法。
- en: Create a RESTful controller and a service to use the methods generated. In the
    book’s GitHub repository there is a RESTful API using the repositories created
    in this recipe.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个RESTful控制器和一个服务来使用生成的这些方法。在本书的GitHub仓库中有一个使用在此菜谱中创建的仓库的RESTful API。
- en: In the repository you can also find a script to call the RESTful API methods
    created in this recipe.
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在仓库中，您还可以找到调用在此菜谱中创建的RESTful API方法的脚本。
- en: How it works...
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When an application using Spring Data JPA starts, it performs several important
    actions to make it work.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Spring Data JPA的应用程序启动时，它执行几个重要的操作来使其工作。
- en: Spring Application Context initialization. It sets up the environment for managing
    Spring components, including the repositories.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring应用程序上下文初始化。它设置管理Spring组件的环境，包括仓库。
- en: Spring Boot scans component and detect repositories. It checks classes annotated
    with `@Repository` and interfaces extending `JpaRepository`.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot扫描组件并检测仓库。它检查带有`@Repository`注解的类和扩展`JpaRepository`的接口。
- en: For each repository interface, Spring Data JPA generates a concrete implementation
    during runtime. In our scenario, it means that it takes each method defined in
    the repositories and generates the specific queries. At this step it validates
    if it can generate the implementation by using the naming convention, or by using
    the `@Query` annotation. At this step it also validates the queries, so if we
    write an invalid query or it is not capable of generating the implementation from
    the naming convention, it will fail.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个仓库接口，Spring Data JPA在运行时生成一个具体的实现。在我们的场景中，这意味着它将每个在仓库中定义的方法取出来，并生成特定的查询。在这一步，它通过使用命名约定或使用`@Query`注解来验证是否可以生成实现。在这一步，它还验证查询，所以如果我们编写了一个无效的查询或者它不能从命名约定中生成实现，它将失败。
- en: After generating the implementation, it registers them as beans in the application
    context and are now available for the rest of components of our application.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生成实现后，它将它们注册为应用程序上下文中的bean，现在它们对应用程序的其余部分都是可用的。
- en: One important advantage of JPA and JPQL is that the queries reference the Entities
    we defined in our code, so it can detect a query/entity mapping mismatch early.
    This cannot be achieved when using native queries.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: JPA和JPQL的一个重要优点是查询引用了我们代码中定义的实体，因此它可以早期检测查询/实体映射不匹配。当使用原生查询时，这是无法实现的。
- en: Another advantage is that it abstracts the underlaying database. As a developer,
    this is an interesting feature, as it makes the onboarding to a new database faster.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是它抽象了底层数据库。作为一个开发者，这是一个有趣的功能，因为它使得迁移到新的数据库更快。
- en: There’s more...
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can activate the SQL logging by using `spring.jpa.show-sql` configuration
    variable. It is interesting to check and debug the native queries being generated.
    Keep in mind that it can slow down your application and generate large logs. I
    recommend using this setting only in development.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`spring.jpa.show-sql`配置变量来激活SQL日志记录。检查和调试生成的原生查询很有趣。请记住，这可能会减慢您的应用程序并生成大量的日志。我建议只在开发中使用此设置。
- en: Using Native Queries
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原生查询
- en: 'JPQL is a very powerful mechanism to access relational databases with an abstraction
    of the underlying database. Native Queries refers to executing SQL statements
    directly against the database. Depending on your requirements you might consider
    using Native queries, for instances like:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: JPQL是一个非常强大的机制，可以以底层数据库的抽象方式访问关系数据库。原生查询指的是直接对数据库执行SQL语句。根据您的需求，您可能需要考虑使用原生查询，例如：
- en: Executing complex SQL operations that are not easily expressible in JPQL, for
    instance, queries that involve subqueries or database-specific functions.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行复杂SQL操作，这些操作在JPQL中不易表达，例如涉及子查询或特定数据库函数的查询。
- en: When you need to fine-tune the performance of a query, leveraging database-specific
    optimizations, indexes, and hints to improve the query execution time.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要微调查询的性能时，利用特定数据库的优化、索引和提示来提高查询执行时间。
- en: Database-specific features, for instance, the databases that can manage JSON
    structures, may have different ways of doing it.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定数据库的功能，例如可以管理JSON结构的数据库，可能有不同的实现方式。
- en: 'Bulk Operations: Native queries are often more efficient for executing bulk
    insert, update, or delete operations on a large number of records, as they bypass
    the overhead of entity management and caching that comes with JPQL.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量操作：原生查询在执行大量记录的批量插入、更新或删除操作时通常更有效，因为它们绕过了JPQL带来的实体管理和缓存开销。
- en: Keep in mind that using Native Queries comes with some trade-offs compared to
    JPQL.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，与JPQL相比，使用原生查询有一些权衡。
- en: '**Type Safety**: As we saw in the previous recipe, JPQL provides type safety,
    which means that query results are returned as strongly typed objects and queries
    are validated during application startup. With native queries, you typically work
    with untyped result sets, which can introduce runtime errors if not handled properly
    and that will come up just when the native query is used.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型安全**：正如我们在上一个菜谱中看到的，JPQL提供了类型安全，这意味着查询结果以强类型对象返回，并且在应用程序启动时验证查询。使用原生查询时，你通常与无类型的结果集一起工作，如果不正确处理，可能会引入运行时错误，而且这种情况通常会在使用原生查询时出现。'
- en: Native queries can be harder to maintain and refactor because they involve SQL
    strings embedded in your Java code. JPQL queries are more self-contained and easier
    to manage
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原生查询可能更难维护和重构，因为它们涉及嵌入在Java代码中的SQL字符串。JPQL查询更自包含且易于管理。
- en: '**Portability**: Native queries are not portable across different database
    systems. If your application needs to support multiple databases, you may need
    to write database-specific queries for each one, and you will need to learn the
    specific differences of each database SQL dialect.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：原生查询在不同数据库系统之间不可移植。如果你的应用程序需要支持多个数据库，你可能需要为每个数据库编写特定的查询，并且你需要学习每个数据库SQL方言的具体差异。'
- en: In this recipe, we’ll introduce a new feature, match timelines, to our Football
    application. The timeline are all the events that happen during a football match;
    as we don’t want to constrain the content that can be managed as an event, we
    will save part of the information as JSON. PostgreSQL has excellent support for
    JSON, but for most of the scenarios, it is necessary to write native queries.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将向我们的足球应用程序引入一个新功能，即比赛时间线。时间线是足球比赛中发生的所有事件；由于我们不希望将可以管理为事件的内容进行约束，我们将部分信息保存为JSON。PostgreSQL对JSON有出色的支持，但在大多数场景中，编写原生查询是必要的。
- en: Getting ready
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we don’t need additional tools compared to previous recipes.
    As starting point of this exercise, we will use the completed version of previous
    recipe. If you didn’t complete it, you can find it in the book’s repository at
    https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/. I also prepared
    some scripts to create some sample data for the database. It will be explained
    as part of the recipe steps.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们不需要与之前菜谱相比额外的工具。作为这个练习的起点，我们将使用之前菜谱的完成版本。如果你没有完成它，你可以在本书的仓库中找到它，网址为https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/。我还准备了一些脚本，用于为数据库创建一些示例数据。它将在菜谱步骤中解释。
- en: How to do it...
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this recipe, we will create a new table managing the match events. That table
    will have a column containing JSON documents.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个新的表格来管理比赛事件。这个表格将包含一个包含JSON文档的列。
- en: To create the new table, we will create a new Flyway migration. In folder `src/main/resources/db/migration`
    create a file named `V4__AddMatchEvents.sql` with the following content.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建新表格，我们将创建一个新的Flyway迁移。在`src/main/resources/db/migration`文件夹中创建一个名为`V4__AddMatchEvents.sql`的文件，内容如下。
- en: '[PRE65]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Additionally, I prepared another migration that you can find in https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/
    named `V4_1__CreateSampleEvents.sql`. This migration inserts events in the `match_events`
    table, so you will be able to play around it. Here you can see an example of match
    event detail:'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，我还准备了一个名为`V4_1__CreateSampleEvents.sql`的迁移，您可以在https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/找到它。这个迁移在`match_events`表中插入事件，这样您就可以尝试操作它。这里您可以看到一个比赛事件详情的示例：
- en: '[PRE66]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create a new entity to manage this table. Create a class named `MatchEventEntity`:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的实体来管理这个表。创建一个名为`MatchEventEntity`的类：
- en: '[PRE67]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We will map the JSON content in another class named `MatchEventDetails`. You
    can use other more flexible data structures, such as a Map.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在另一个名为`MatchEventDetails`的类中映射JSON内容。您可以使用其他更灵活的数据结构，如Map。
- en: '[PRE68]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Create a new `JpaRepository` and name it `MatchEventRepository`:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`JpaRepository`并命名为`MatchEventRepository`：
- en: '[PRE69]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We will create a new method in the repository to retrieve all events in a match
    of a given type. The type of event is just an attribute of the JSON content. To
    perform this query, we need to use PostgreSQL specific syntax to query using the
    JSON content. To use Native Queries, we just need to specify in `@Query` annotation
    the attribute `nativeQuery =` `true`.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在仓库中创建一个新的方法来检索给定类型比赛中所有的事件。事件类型只是JSON内容的属性。为了执行此查询，我们需要使用PostgreSQL特定的语法来查询JSON内容。要使用原生查询，我们只需在`@Query`注解中指定属性`nativeQuery
    =` `true`。
- en: '[PRE70]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We will implement a repository method to retrieve the events associated with
    a particular football match in which a specified player participated.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将实现一个仓库方法来检索与特定足球比赛相关的、指定球员参与的事件。
- en: '[PRE71]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In `PlayerRepository` we will create a method a new method to map the stored
    procedure.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerRepository`中，我们将创建一个新的方法来映射存储过程。
- en: '[PRE72]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now you can create a service and a controller using these repositories. In the
    GitHub repository, I extended the existing controller to call the new repository
    methods. You can also find a script calling the new controller methods.
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在您可以使用这些仓库创建一个服务和控制器。在GitHub仓库中，我扩展了现有的控制器以调用新的仓库方法。您还可以找到一个调用新控制器方法的脚本。
- en: How it works...
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we used JSON because it is very useful to store data that can
    be flexible, extensible and it is not required to be as structured as a table,
    with known columns and types. PostgreSQL has a good support for JSON, however
    JPQL support for this kind of scenario is more limited. That is why, you need
    to use Native Queries.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了JSON，因为它非常适合存储灵活、可扩展的数据，而且不需要像表格那样有已知列和类型。PostgreSQL对JSON有很好的支持，然而JPQL对这种场景的支持更为有限。这就是为什么您需要使用原生查询。
- en: Note
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Even if PostgreSQL has very good support for JSON, it is not as optimized as
    it is for regular columns. If there is information in the document that is frequently
    used, it is better to move it to regular columns. PostgreSQL supports indexes
    over JSON properties, you will need to evaluate which is the best approach for
    your specific scenario.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 即使PostgreSQL对JSON的支持非常好，但它并不像对常规列那样优化。如果文档中有经常使用的信息，最好将其移动到常规列。PostgreSQL支持对JSON属性的索引，您需要评估在您的特定场景中哪种方法最好。
- en: We used `MatchEventDetail` is just a class, not an Entity. In any case, this
    also requires knowing the schema of the JSON data in advance to avoid serialization
    errors. If you need a more flexible approach, you can use just a Map or a String
    to map that column.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的`MatchEventDetail`只是一个类，不是一个实体。无论如何，这也需要提前了解JSON数据的模式以避免序列化错误。如果您需要一个更灵活的方法，可以使用一个简单的Map或String来映射该列。
- en: JSON support is just an example of a native feature in this case of PostgreSQL,
    but there are other scenarios that you might require using native queries. For
    instance, complex queries that are difficult or not possible to express using
    JPQL, such as subqueries and bulk operations.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: JSON支持只是在这个PostgreSQL案例中一个原生功能的示例，但还有其他场景可能需要使用原生查询。例如，复杂查询难以或无法使用JPQL表达，如子查询和批量操作。
- en: 'When a Native Query is executed, the SQL command itself is not checked by Spring
    Data JPA nor Hibernate, however the resulting execution should be mapped to the
    resulting Entities. Keep that in mind when you write the SQL statements. For instance,
    if in this recipe, we wrote:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行原生查询时，Spring Data JPA和Hibernate不会检查SQL命令本身，然而执行结果应该映射到结果实体。在编写SQL语句时请记住这一点。例如，如果在这个菜谱中我们这样写：
- en: '[PRE73]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'That should match a `List<MatchEventEntity>`. According to our definition of
    `MatchEventEntity`, it expects that the result of the query contains the columns
    *id*, *event_time*, *details* and *match_id*. So be aware of this fact when using
    alias in your queries. As an example, look at the following query, it will result
    in an error in runtime:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该匹配一个 `List<MatchEventEntity>`。根据我们对 `MatchEventEntity` 的定义，它期望查询结果包含列 *id*、*event_time*、*details*
    和 *match_id*。所以在使用查询别名时请注意这一点。例如，看以下查询，它将在运行时产生错误：
- en: '[PRE74]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: CREATE TABLE users (
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CREATE TABLE users (
- en: id SERIAL PRIMARY KEY,
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: id SERIAL PRIMARY KEY,
- en: username VARCHAR(255)
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: username VARCHAR(255)
- en: );
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: );
- en: ALTER TABLE albums ADD COLUMN owner_id INTEGER REFERENCES users(id);
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ALTER TABLE albums ADD COLUMN owner_id INTEGER REFERENCES users(id);
- en: ALTER TABLE cards ADD COLUMN owner_id INTEGER REFERENCES users(id);
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ALTER TABLE cards ADD COLUMN owner_id INTEGER REFERENCES users(id);
- en: ALTER TABLE cards ADD CONSTRAINT cards_album_player_key UNIQUE (album_id, player_id);
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ALTER TABLE cards ADD CONSTRAINT cards_album_player_key UNIQUE (album_id, player_id);
- en: '[PRE75]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '@Table(name = "users")'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Table(name = "users")'
- en: '@Entity'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Entity'
- en: public class UserEntity {
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public class 用户实体 {
- en: '@Id'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Id'
- en: '@GeneratedValue(strategy = GenerationType.IDENTITY)'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@GeneratedValue(strategy = GenerationType.IDENTITY)'
- en: private Integer id;
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private Integer id;
- en: private String username;
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private String username;
- en: '@OneToMany(mappedBy = "owner")'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@OneToMany(mappedBy = "所有者")'
- en: private List<CardEntity> ownedCards;
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private List<卡片实体> 拥有卡片;
- en: '@OneToMany(mappedBy = "owner")'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@OneToMany(mappedBy = "所有者")'
- en: private Set<AlbumEntity> ownedAlbums;
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private Set<专辑实体> 拥有专辑;
- en: '}'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE76]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '@ManyToOne'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@ManyToOne'
- en: '@JoinColumn(name = "owner_id")'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@JoinColumn(name = "所有者_id")'
- en: private UserEntity owner;
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private 用户实体 所有者;
- en: '[PRE77]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '@Table(name = "cards", uniqueConstraints = { @UniqueConstraint(columnNames
    = { "album_id", "player_id" }) })'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Table(name = "cards", uniqueConstraints = { @UniqueConstraint(columnNames
    = { "album_id", "player_id" }) })'
- en: '@Entity'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Entity'
- en: public class CardEntity {
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public class 卡片实体 {
- en: '}'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE78]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: public interface UserRepository extends JpaRepository<UserEntity, Integer> {
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public interface 用户存储库 extends JpaRepository<用户实体, Integer> {
- en: '}'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE79]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: private UserRepository usersRepository;
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private 用户存储库 用户存储库;
- en: public User createUser(String name) {
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public 用户 创建用户(String name) {
- en: UserEntity user = new UserEntity();
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用户实体 用户 = new 用户实体();
- en: user.setUsername(name);
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用户.setUsername(name);
- en: user = usersRepository.save(user);
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用户 = 用户存储库.findById(userId).orElseThrow();
- en: return new User(user.getId(), user.getUsername());
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return new 用户(user.getId(), user.getUsername());
- en: '}'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE80]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: public Album buyAlbum(Integer userId, String title) {
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public 专辑 购买专辑(Integer userId, String title) {
- en: AlbumEntity album = new AlbumEntity();
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 专辑实体 专辑 = new 专辑实体();
- en: album.setTitle(title);
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 专辑.setTitle(title);
- en: album.setExpireDate(LocalDate.now().plusYears(1));
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 专辑.setExpireDate(LocalDate.now().plusYears(1));
- en: album.setOwner(usersRepository.findById(userId).orElseThrow());
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 专辑.setOwner(用户存储库.findById(userId).orElseThrow());
- en: album = albumsRepository.save(album);
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 专辑 = 专辑存储库.save(专辑);
- en: return new Album(album.getId(), album.getTitle(), album.getOwner().getId());
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return new 专辑(专辑.getId(), 专辑.getTitle(), 专辑的所有者().getId());
- en: '}'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE81]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: public List<Card> buyCards(Integer userId, Integer count) {
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public List<Card> 购买卡片(Integer userId, Integer count) {
- en: Random rnd = new Random();
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Random rnd = new Random();
- en: List<PlayerEntity> players = getAvailablePlayers();
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: List<球员实体> 球员 = 获取可用球员();
- en: UserEntity owner = usersRepository.findById(userId).orElseThrow();
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用户实体 所有者 = 用户存储库.findById(userId).orElseThrow();
- en: List<CardEntity> cards = Stream.generate(() -> {
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: List<CardEntity> 卡片 = Stream.generate(() -> {
- en: CardEntity card = new CardEntity();
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CardEntity card = new CardEntity();
- en: card.setOwner(owner);
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: card.setOwner(owner);
- en: card.setPlayer(players.get(rnd.nextInt(players.size())));
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: card.setPlayer(players.get(rnd.nextInt(players.size())));
- en: return card;
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return 卡片;
- en: '}).limit(count).toList();'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}).limit(count).toList();'
- en: return cardsRepository.saveAll(cards)
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return 卡片存储库.saveAll(卡片)
- en: .stream()
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .stream()
- en: .map(card -> new Card(card.getId(), card.getOwner().getId(), Optional.empty(),
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .map(card -> new Card(card.getId(), card.getOwner().getId(), Optional.empty(),
- en: new Player(card.getPlayer().getName(), card.getPlayer().getJerseyNumber(),
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: new 球员(card.getPlayer().getName(), card.getPlayer().getJerseyNumber(),
- en: card.getPlayer().getPosition(), card.getPlayer().getDateOfBirth())))
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: card.getPlayer().getPosition(), card.getPlayer().getDateOfBirth())))
- en: .collect(Collectors.toList());
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .collect(Collectors.toList());
- en: '}'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE82]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: UPDATE cards
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: UPDATE 卡片
- en: SET album_id = r.album_id
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SET 专辑_id = r.album_id
- en: FROM
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FROM
- en: (SELECT available.album_id, (SELECT c2.id from cards c2 where c2.owner_id=?1
    AND c2.player_id = available.player_id AND c2.album_id IS NULL LIMIT 1) as card_id
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (SELECT available.album_id, (SELECT c2.id from cards c2 where c2.owner_id=?1
    AND c2.player_id = available.player_id AND c2.album_id IS NULL LIMIT 1) as card_id
- en: FROM
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FROM
- en: (SELECT DISTINCT a.id as album_id, c.player_id FROM albums a CROSS JOIN cards
    c WHERE a.owner_id=?1 AND c.owner_id=?1 AND c.album_id IS NULL AND c.player_id
    NOT IN (SELECT uc.player_id from cards uc WHERE uc.album_id = a.id)) available)
    as r
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (SELECT DISTINCT a.id as album_id, c.player_id FROM albums a CROSS JOIN cards
    c WHERE a.owner_id=?1 AND c.owner_id=?1 AND c.album_id IS NULL AND c.player_id
    NOT IN (SELECT uc.player_id from cards uc WHERE uc.album_id = a.id)) as r
- en: WHERE cards.id = r.card_id
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: WHERE 卡片.id = r.card_id
- en: '[PRE83]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '@Modifying'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Modifying'
- en: '@Query(nativeQuery = true, value = "UPDATE cards " +'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Query(nativeQuery = true, value = "UPDATE cards " +'
- en: '"SET album_id = r.album_id  " + //'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"SET album_id = r.album_id  " + //'
- en: '"FROM " + //'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"FROM " + //'
- en: '"(SELECT available.album_id, (SELECT c2.id from cards c2 where c2.owner_id=?1
    AND c2.player_id = available.player_id AND c2.album_id IS NULL LIMIT 1) as card_id
    " + //'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"(SELECT available.album_id, (SELECT c2.id from cards c2 where c2.owner_id=?1
    AND c2.player_id = available.player_id AND c2.album_id IS NULL LIMIT 1) as card_id
    " + //'
- en: '"FROM " + //'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"FROM " + //'
- en: '"(SELECT DISTINCT a.id as album_id, c.player_id FROM albums a CROSS JOIN cards
    c WHERE a.owner_id=?1 AND c.owner_id=?1 AND c.album_id IS NULL AND c.player_id
    NOT IN (SELECT uc.player_id from cards uc WHERE uc.album_id = a.id)) available)
    as r " +'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"(SELECT DISTINCT a.id as album_id, c.player_id FROM albums a CROSS JOIN cards
    c WHERE a.owner_id=?1 AND c.owner_id=?1 AND c.album_id IS NULL AND c.player_id
    NOT IN (SELECT uc.player_id from cards uc WHERE uc.album_id = a.id)) available)
    as r " +'
- en: '"WHERE cards.id = r.card_id " +'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"WHERE cards.id = r.card_id " +'
- en: '"RETURNING cards.*")'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"RETURNING cards.*")'
- en: List<CardEntity> assignCardsToUserAlbums(Integer userId);
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: List<CardEntity> assignCardsToUserAlbums(Integer userId);
- en: '[PRE84]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '@Modifying'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Modifying'
- en: '@Query(value = "UPDATE CardEntity " +'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Query(value = "UPDATE CardEntity " +'
- en: '" SET album = null, " +'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '" SET album = null, " +'
- en: '" owner= (SELECT u FROM UserEntity u WHERE u.id=?2) " +'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '" owner= (SELECT u FROM UserEntity u WHERE u.id=?2) " +'
- en: '"WHERE id = ?1 ")'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"WHERE id = ?1 ")'
- en: Integer transferCard(Integer cardId, Integer userId);
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Integer transferCard(Integer cardId, Integer userId);
- en: '[PRE85]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '@Transactional'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Transactional'
- en: public Optional<Card> transferCard(Integer cardId, Integer userId) {
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public Optional<Card> transferCard(Integer cardId, Integer userId) {
- en: Integer count = cardsRepository.transferCard(cardId, userId);
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Integer count = cardsRepository.transferCard(cardId, userId);
- en: if (count == 0) {
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (count == 0) {
- en: return Optional.empty();
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return Optional.empty();
- en: '} else {'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '} else {'
- en: …
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …
- en: '}'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE86]'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '@Modifying'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Modifying'
- en: '@Query(nativeQuery = true, value = "UPDATE cards " +'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Query(nativeQuery = true, value = "UPDATE cards " +'
- en: '"SET owner_id=?2 " +'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"SET owner_id=?2 " +'
- en: '" FROM (select c1.id from cards c1 where c1.owner_id=?1 and c1.album_id IS
    NULL AND c1.player_id IN (select p2.id from players p2 where p2.id NOT IN (SELECT
    c2.player_id FROM cards c2 WHERE c2.owner_id=?2)) LIMIT ?3) cards_from_user1_for_user2
    " +'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '" FROM (select c1.id from cards c1 where c1.owner_id=?1 and c1.album_id IS
    NULL AND c1.player_id IN (select p2.id from players p2 where p2.id NOT IN (SELECT
    c2.player_id FROM cards c2 WHERE c2.owner_id=?2)) LIMIT ?3) cards_from_user1_for_user2
    " +'
- en: '"WHERE cards.id = cards_from_user1_for_user2.id " +'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"WHERE cards.id = cards_from_user1_for_user2.id " +'
- en: '"RETURNING cards.*")'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"RETURNING cards.*")'
- en: List<CardEntity> tradeCardsBetweenUsers(Integer userId1, Integer userId2, Integer
    count);
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: List<CardEntity> tradeCardsBetweenUsers(Integer userId1, Integer userId2, Integer
    count);
- en: '[PRE87]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '@Service'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Service'
- en: public class DynamicQueriesService {
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public class DynamicQueriesService {
- en: '}'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE88]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Public List<PlayerEntity> searchTeamPlayers(Integer teamId, Optional<String>
    name, Optional<Integer> minHeight,
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Public List<PlayerEntity> searchTeamPlayers(Integer teamId, Optional<String>
    name, Optional<Integer> minHeight,
- en: Optional<Integer> maxHeight,
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Optional<Integer> maxHeight,
- en: Optional<Integer> minWeight, Optional<Integer> maxWeight) {
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Optional<Integer> minWeight, Optional<Integer> maxWeight) {
- en: CriteriaBuilder cb = em.getCriteriaBuilder();
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CriteriaBuilder cb = em.getCriteriaBuilder();
- en: CriteriaQuery<PlayerEntity> cq = cb.createQuery(PlayerEntity.class);
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CriteriaQuery<PlayerEntity> cq = cb.createQuery(PlayerEntity.class);
- en: Root<PlayerEntity> player = cq.from(PlayerEntity.class);
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Root<PlayerEntity> player = cq.from(PlayerEntity.class);
- en: List<Predicate> predicates = new ArrayList<>();
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: List<Predicate> predicates = new ArrayList<>();
- en: predicates.add(cb.equal(player.get("team").get("id"), teamId));
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: predicates.add(cb.equal(player.get("team").get("id"), teamId));
- en: if (name.isPresent()) {
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (name.isPresent()) {
- en: predicates.add(cb.like(player.get("name"), name.get()));
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: predicates.add(cb.like(player.get("name"), name.get()));
- en: '}'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: if (minHeight.isPresent()) {
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (minHeight.isPresent()) {
- en: predicates.add(cb.ge(player.get("height"), minHeight.get()));
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: predicates.add(cb.ge(player.get("height"), minHeight.get()));
- en: '}'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: if (maxHeight.isPresent()) {
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (maxHeight.isPresent()) {
- en: predicates.add(cb.le(player.get("height"), maxHeight.get()));
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: predicates.add(cb.le(player.get("height"), maxHeight.get()));
- en: '}'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: if (minWeight.isPresent()) {
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (minWeight.isPresent()) {
- en: predicates.add(cb.ge(player.get("weight"), minWeight.get()));
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: predicates.add(cb.ge(player.get("weight"), minWeight.get()));
- en: '}'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: if (maxWeight.isPresent()) {
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (maxWeight.isPresent()) {
- en: predicates.add(cb.le(player.get("weight"), maxWeight.get()));
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: predicates.add(cb.le(player.get("weight"), maxWeight.get()));
- en: '}'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: cq.where(predicates.toArray(new Predicate[0]));
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cq.where(predicates.toArray(new Predicate[0]));
- en: TypedQuery<PlayerEntity> query = em.createQuery(cq);
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TypedQuery<PlayerEntity> query = em.createQuery(cq);
- en: return query.getResultList();
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return query.getResultList();
- en: '}'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE89]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: public List<MatchEventEntity> searchMatchEventsRange(Integer matchId, Optional<LocalDateTime>
    minTime, Optional<LocalDateTime> maxTime) {
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public List<MatchEventEntity> searchMatchEventsRange(Integer matchId, Optional<LocalDateTime>
    minTime, Optional<LocalDateTime> maxTime) {
- en: String command = "SELECT e FROM MatchEventEntity e WHERE e.match.id=:matchId
    ";
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: String command = "SELECT e FROM MatchEventEntity e WHERE e.match.id=:matchId
    ";
- en: if (minTime.isPresent() && maxTime.isPresent()) {
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (minTime.isPresent() && maxTime.isPresent()) {
- en: command += " AND e.time BETWEEN :minTime AND :maxTime";
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: command += " AND e.time BETWEEN :minTime AND :maxTime";
- en: '} else if (minTime.isPresent()) {'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '} else if (minTime.isPresent()) {'
- en: command += " AND e.time >= :minTime";
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: command += " AND e.time >= :minTime";
- en: '} else if (maxTime.isPresent()) {'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '} else if (maxTime.isPresent()) {'
- en: command += " AND e.time <= :maxTime";
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: command += " AND e.time <= :maxTime";
- en: '}'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: TypedQuery<MatchEventEntity> query = em.createQuery(command, MatchEventEntity.class);
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TypedQuery<MatchEventEntity> query = em.createQuery(command, MatchEventEntity.class);
- en: query.setParameter("matchId", matchId);
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: query.setParameter("matchId", matchId);
- en: if (minTime.isPresent()) {
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (minTime.isPresent()) {
- en: query.setParameter("minTime", minTime.get());
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: query.setParameter("minTime", minTime.get());
- en: '}'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: if (maxTime.isPresent()) {
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (maxTime.isPresent()) {
- en: query.setParameter("maxTime", maxTime.get());
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: query.setParameter("maxTime", maxTime.get());
- en: '}'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: return query.getResultList();
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return query.getResultList();
- en: '}'
  id: totrans-578
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE90]'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: public List<PlayerEntity> searchUserMissingPlayers(Integer userId) {
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public List<PlayerEntity> searchUserMissingPlayers(Integer userId) {
- en: Query query = em.createNativeQuery(
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Query query = em.createNativeQuery(
- en: '"SELECT p1.* FROM players p1 WHERE p1.id NOT IN (SELECT c1.player_id FROM cards
    c1 WHERE c1.owner_id=?1)",'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"SELECT p1.* FROM players p1 WHERE p1.id NOT IN (SELECT c1.player_id FROM cards
    c1 WHERE c1.owner_id=?1)",'
- en: PlayerEntity.class);
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: PlayerEntity.class);
- en: query.setParameter(1, userId);
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: query.setParameter(1, userId);
- en: return query.getResultList();
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return query.getResultList();
- en: '}'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE91]'
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: public void deleteEventRange(Integer matchId, LocalDateTime start, LocalDateTime
    end) {
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public void deleteEventRange(Integer matchId, LocalDateTime start, LocalDateTime
    end) {
- en: em.getTransaction().begin();
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: em.getTransaction().begin();
- en: Query query = em.createQuery("DELETE FROM MatchEventEntity e WHERE e.match.id=:matchId
    AND e.time BETWEEN :start AND :end");
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Query query = em.createQuery("DELETE FROM MatchEventEntity e WHERE e.match.id=:matchId
    AND e.time BETWEEN :start AND :end");
- en: query.setParameter("matchId", matchId);
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: query.setParameter("matchId", matchId);
- en: query.setParameter("start", start);
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: query.setParameter("start", start);
- en: query.setParameter("end", end);
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: query.setParameter("end", end);
- en: query.executeUpdate();
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: query.executeUpdate();
- en: em.getTransaction().commit();
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: em.getTransaction().commit();
- en: '}'
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE92]'
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Integer potentialUser1ToUser2 = cardsRepository.countMatchBetweenUsers(userId1,
    userId2);
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Integer potentialUser1ToUser2 = cardsRepository.countMatchBetweenUsers(userId1,
    userId2);
- en: Integer potentialUser2ToUser1 = cardsRepository.countMatchBetweenUsers(userId2,
    userId1);
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Integer potentialUser2ToUser1 = cardsRepository.countMatchBetweenUsers(userId2,
    userId1);
- en: Integer count = Math.min(potentialUser1ToUser2, potentialUser2ToUser1);
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Integer count = Math.min(potentialUser1ToUser2, potentialUser2ToUser1);
- en: '[PRE93]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: ArrayList<CardEntity> result = new ArrayList<>(
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ArrayList<CardEntity> result = new ArrayList<>(
- en: cardsRepository.tradeCardsBetweenUsers(userId1, userId2, count));
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cardsRepository.tradeCardsBetweenUsers(userId1, userId2, count));
- en: useAllCardAvailable(userId2);
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: useAllCardAvailable(userId2);
- en: result.addAll(cardsRepository.tradeCardsBetweenUsers(userId2, userId1, count));
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: result.addAll(cardsRepository.tradeCardsBetweenUsers(userId2, userId1, count));
- en: useAllCardAvailable(userId1);
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: useAllCardAvailable(userId1);
- en: '[PRE94]'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '@Transactional'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Transactional'
- en: public List<Card> tradeAllCards(Integer userId1, Integer userId2) {
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public List<Card> tradeAllCards(Integer userId1, Integer userId2) {
- en: Integer potentialUser1ToUser2 = cardsRepository.countMatchBetweenUsers(userId1,
    userId2);
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Integer potentialUser1ToUser2 = cardsRepository.countMatchBetweenUsers(userId1,
    userId2);
- en: Integer potentialUser2ToUser1 = cardsRepository.countMatchBetweenUsers(userId2,
    userId1);
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Integer potentialUser2ToUser1 = cardsRepository.countMatchBetweenUsers(userId2,
    userId1);
- en: Integer count = Math.min(potentialUser1ToUser2, potentialUser2ToUser1);
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Integer count = Math.min(potentialUser1ToUser2, potentialUser2ToUser1);
- en: if (count > 0) {
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (count > 0) {
- en: ArrayList<CardEntity> result = new ArrayList<>(
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ArrayList<CardEntity> result = new ArrayList<>(
- en: cardsRepository.tradeCardsBetweenUsers(userId1, userId2, count));
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cardsRepository.tradeCardsBetweenUsers(userId1, userId2, count));
- en: useAllCardAvailable(userId2);
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: useAllCardAvailable(userId2);
- en: result.addAll(cardsRepository.tradeCardsBetweenUsers(userId2, userId1, count));
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: result.addAll(cardsRepository.tradeCardsBetweenUsers(userId2, userId1, count));
- en: useAllCardAvailable(userId1);
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: useAllCardAvailable(userId1);
- en: '}'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE95]'
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: ArrayList<CardEntity> result1 = new ArrayList<>(
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ArrayList<CardEntity> result1 = new ArrayList<>(
- en: cardsRepository.tradeCardsBetweenUsers(userId1, userId2, count));
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cardsRepository.tradeCardsBetweenUsers(userId1, userId2, count));
- en: useAllCardAvailable(userId2);
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: useAllCardAvailable(userId2);
- en: ArrayList<CardEntity> result2 = new ArrayList<>(
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ArrayList<CardEntity> result2 = new ArrayList<>(
- en: cardsRepository.tradeCardsBetweenUsers(userId2, userId1, count));
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cardsRepository.tradeCardsBetweenUsers(userId2, userId1, count));
- en: useAllCardAvailable(userId1);
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: useAllCardAvailable(userId1);
- en: if (result1.size() != result2.size()) {
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (result1.size() != result2.size()) {
- en: throw new RuntimeException("Users have different number of cards");
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: throw new RuntimeException("Users have different number of cards");
- en: '}'
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE96]'
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '@Transactional(isolation = Isolation.SERIALIZABLE)'
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Transactional(isolation = Isolation.SERIALIZABLE)'
- en: public List<Card> tradeAllCards(Integer userId1, Integer userId2) {
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public List<Card> tradeAllCards(Integer userId1, Integer userId2) {
- en: Integer potentialUser1ToUser2 = cardsRepository.countMatchBetweenUsers(userId1,
    userId2);
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Integer potentialUser1ToUser2 = cardsRepository.countMatchBetweenUsers(userId1,
    userId2);
- en: Integer potentialUser2ToUser1 = cardsRepository.countMatchBetweenUsers(userId2,
    userId1);
  id: totrans-634
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Integer potentialUser2ToUser1 = cardsRepository.countMatchBetweenUsers(userId2,
    userId1);
- en: Integer count = Math.min(potentialUser1ToUser2, potentialUser2ToUser1);
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Integer count = Math.min(potentialUser1ToUser2, potentialUser2ToUser1);
- en: if (count > 0) {
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (count > 0) {
- en: ArrayList<CardEntity> result1 = new ArrayList<>(
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ArrayList<CardEntity> result1 = new ArrayList<>(
- en: cardsRepository.tradeCardsBetweenUsers(userId1, userId2, count));
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cardsRepository.tradeCardsBetweenUsers(userId1, userId2, count));
- en: useAllCardAvailable(userId2);
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: useAllCardAvailable(userId2);
- en: ArrayList<CardEntity> result2 = new ArrayList<>(
  id: totrans-640
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ArrayList<CardEntity> result2 = new ArrayList<>(
- en: cardsRepository.tradeCardsBetweenUsers(userId2, userId1, count));
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cardsRepository.tradeCardsBetweenUsers(userId2, userId1, count));
- en: useAllCardAvailable(userId1);
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: useAllCardAvailable(userId1);
- en: …
  id: totrans-643
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …
- en: '}'
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE97]'
  id: totrans-646
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '@Transactional(propagation = Propagation.REQUIRES_NEW)'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '@Transactional(propagation = Propagation.REQUIRES_NEW)'
- en: '[PRE98]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: em.getTransaction().begin();
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: em.getTransaction().begin();
- en: // do your changes
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: // do your changes
- en: em.getTransaction().commit();
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: em.getTransaction().commit();
- en: '[PRE99]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: try {
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: try {
- en: em.getTransaction().begin();
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: em.getTransaction().begin();
- en: …
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: em.getTransaction().commit();
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: em.getTransaction().commit();
- en: '} catch (Exception e) {'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (Exception e) {'
- en: em.getTransaction().rollback();
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: em.getTransaction().rollback();
- en: '}'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE100]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
