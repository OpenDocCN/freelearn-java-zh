- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Data Persistence and Relational Database Integration with Spring Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Data 与关系型数据库进行数据持久化和集成
- en: Most applications handle their data in some way, necessitating the use of a
    database engine. This chapter discusses Relational Databases, the most widely
    used database technology. Relational databases remain a flexible and dependable
    option for a variety of application scenarios. Their organized, tabular data storage
    format with a defined schema suits many purposes. Additionally, relational databases
    offer essential benefits like enforcing data integrity, supporting complex queries,
    and adhering to **ACID** principles (**Atomicity, Consistency, Isolation, Durability**).
    They prove to be a suitable choice for applications ranging from simple to mission-critical
    ones.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序以某种方式处理他们的数据，这需要使用数据库引擎。本章讨论了关系型数据库，这是最广泛使用的数据库技术。关系型数据库仍然是各种应用程序场景中灵活和可靠的选项。它们的组织化、表格化数据存储格式和定义良好的模式适合许多用途。此外，关系型数据库提供了诸如强制数据完整性、支持复杂查询和遵循
    **ACID** 原则（**原子性、一致性、隔离性、持久性**）等基本好处。它们被证明是适用于从简单到关键任务应用的各种应用程序的合适选择。
- en: Spring Data is a component of the Spring Framework, designed to streamline data
    access in Java applications. It offers a consistent programming model and an abstraction
    layer for interacting with various data stores, including relational databases
    and other types of databases.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 是 Spring 框架的一个组件，旨在简化 Java 应用程序中的数据访问。它提供了一个一致的编程模型和与各种数据存储（包括关系型数据库和其他类型的数据库）交互的抽象层。
- en: 'There are two modules in Spring Data for relational databases: Spring Data
    JPA and Spring Data JDBC.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 为关系型数据库提供了两个模块：Spring Data JPA 和 Spring Data JDBC。
- en: Spring Data JPA. This module provides integration with **Java Persistence API**
    (**JPA**), allowing developers to work with relational databases using **Object-Relational
    Mapping** principles (**ORM**). One of the benefits is that most of the code is
    database independent, not for the purpose of creating an application totally independent
    of the database, but to reuse the learnings regardless the underlaying database.
    In complex applications, taking advantage of vendor-specific features can be determinant
    for a successful project, so I recommend using all features available from a database
    engine. Trying to make an application that can be deployed in any database causes
    that your application will use only the minimum common set available in all databases.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data JPA。此模块提供了与 **Java 持久化 API**（**JPA**）的集成，允许开发人员使用 **对象关系映射**（**ORM**）原则与关系型数据库一起工作。其中一个好处是大多数代码是数据库无关的，不是为了创建一个完全独立于数据库的应用程序，而是为了无论底层数据库如何都能重用所学知识。在复杂的应用程序中，利用特定供应商的功能对于项目的成功可能是决定性的，因此我建议使用数据库引擎提供的所有功能。试图创建一个可以在任何数据库中部署的应用程序会导致你的应用程序只使用所有数据库中可用的最小公共集合。
- en: Spring Data JDBC. This module offers more direct approach to database access,
    focusing on the use of plain SQL queries and direct mapping of data between Java
    objects and database tables.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data JDBC。此模块提供了更直接的数据访问方法，侧重于使用纯 SQL 查询以及 Java 对象和数据库表之间的直接数据映射。
- en: We will use Spring Data JPA for the most common data access scenarios. From
    basic data operations such as Create, Read, Update, Delete (CRUD) to more advanced
    tasks such as complex queries, transactions, and database schema initialization
    and schema upgrade.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Spring Data JPA 处理最常见的数据访问场景。从基本数据操作，如创建、读取、更新、删除（CRUD）到更高级的任务，如复杂查询、事务以及数据库模式初始化和模式升级。
- en: We will use PostgreSQL as a database engine, as it is Open Source, widely adopted,
    multiplatform and has a vibrant community around it. But as mentioned above, we
    could use the same principles to create an application using another relational
    database engine, such as MySQL, SQL Server or Oracle.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 PostgreSQL 作为数据库引擎，因为它开源、广泛采用、多平台，并且围绕它有一个充满活力的社区。但如上所述，我们可以使用相同的原理来创建一个使用其他关系型数据库引擎的应用程序，例如
    MySQL、SQL Server 或 Oracle。
- en: 'In this chapter we are going to cover the following main topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Connecting your application to Postgresql
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的应用程序连接到 Postgresql
- en: Creating and updating the database schema
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和更新数据库模式
- en: Creating a CRUD repository.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 CRUD 存储库。
- en: Using JPQL.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JPQL。
- en: Using Native queries.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原生查询。
- en: Updating operations
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新操作
- en: Dynamic Queries
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态查询
- en: Using Transactions
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事务
- en: Using Spring Data JDBC.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Data JDBC。
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need a PostgreSQL server. The easiest way to deploy
    it in your local environment is by using Docker. You can get Docker from the product
    page: [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer to install PostgreSQL in your computer, you can download it from
    the project page: [https://www.postgresql.org/download/](https://www.postgresql.org/download/)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'I also recommend installing PgAdmin to access the database. You can use it
    to observe the changes performed by your application in the database. You can
    download it from the project page: [https://www.pgadmin.org/download/](https://www.pgadmin.org/download/)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: You can use other tools, such as plugins for Visual Studio Code or IntelliJ.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: You will need a code editor and OpenJDK as explained in the previous chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'All the recipes that will be demonstrated in this chapter can be found at:
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter5](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter5).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Connecting your application to PostgreSQL
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You want to create a RESTful API to server Football data to your end users.
    To manage this data, we decided to use a relatational database, as we are interested
    in prodiving data consistency and advanced query capabilities.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will connect an application, a RESTful API, to a PostgreSQL
    database. To do that, the first thing we’ll do is deploy a PostgreSQL database
    in Docker.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe you will learn how to create a basic application that connects
    to a PostgreSQL database and perform basic SQL queries with JdbcTemplate.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you will need a PostgreSQL database. If you have already one
    server available, you can use it. Otherwise, you can use Docker to deploy a PostgreSQL
    in your computer. For that, you can execute the following command in your terminal
    to download and execute a PostgreSQL instance:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will have a PostgreSQL server available listening on port 5432, with username
    and password *packt*. If you want to change these parameters, you can modify the
    command above.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need a tool to perform some actions on PostgreSQL. I will use the
    command line tool psql. In Ubuntu you can install it using *apt,* the default
    package manager:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Alternativelly to psql, you can use PgAdmin to connect to the database with
    a nice UI. I’ll explain the samples just with the command line using psql, but
    you can use PgAdmin to execute the database scripts if you want. Follow the instruction
    from the official page at [https://www.pgadmin.org/download/](https://www.pgadmin.org/download/)
    to install it in your computer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: You will find the sql scripts in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we will use Spring Initializr tool to create our projects, or the
    integrated tool in your favorite IDE or editor if you prefer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们将使用Spring Initializr工具创建我们的项目，或者如果你更喜欢，可以使用你最喜欢的IDE或编辑器中的集成工具。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Once we have our PostgreSQL server ready as explained in *Getting Ready*, we
    will create a database. After this, we will create a Spring Boot application that
    will connect to the database to perform a simple query.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好了如*准备就绪*中所述的PostgreSQL服务器，我们将创建一个数据库。之后，我们将创建一个Spring Boot应用程序，该应用程序将连接到数据库以执行一个简单的查询。
- en: 'First, download the postgresql scripts available in the GitHub repository.
    They are located in `chapter5/recipe5-1/start/sql`. There are two script files:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，下载GitHub仓库中可用的postgresql脚本。它们位于`chapter5/recipe5-1/start/sql`目录下。有两个脚本文件：
- en: '`db-creation.sql`. This script creates a database named `football`, with two
    tables: `teams` and `players`.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db-creation.sql`。此脚本创建一个名为`football`的数据库，包含两个表：`teams`和`players`。'
- en: '`insert-data.sql`. This script inserts sample data in the `teams` and `players`
    tables.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert-data.sql`。此脚本在`teams`和`players`表中插入示例数据。'
- en: Next, we’ll execute the scripts in the database to execute the scripts. For
    that, open a terminal and execute the following commands to execute the scripts
    in PostgreSQL using the *psql* tool.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将执行数据库中的脚本。为此，打开一个终端并执行以下命令以使用*psql*工具在PostgreSQL中执行脚本。
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It will request the password. Introduce *packt* as configured in the *Getting
    Ready* section. If you used different parameters in the *Getting Ready* section,
    use it accordingly.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它将请求密码。输入*packt*，如*准备就绪*部分中配置的那样。如果你在*准备就绪*部分使用了不同的参数，请相应地使用。
- en: Alternatively, you can use *PgAdmin* tool instead of *psql* tool.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，你也可以使用*PgAdmin*工具代替*psql*工具。
- en: 'The database schema we just created looks like this:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚刚创建的数据库模式看起来如下：
- en: '![Figure 5.1: Database schema. Exported with PgAdmin tool.](img/B21646_05_1.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1：数据库模式。使用PgAdmin工具导出。](img/B21646_05_1.jpg)'
- en: 'Figure 5.1: Database schema. Exported with PgAdmin tool.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：数据库模式。使用PgAdmin工具导出。
- en: 'Let’s create a new Spring Boot application connecting to the database using
    *Spring Initializr* tool. We’ll use the same parameters as in *Creating a RESTful
    API* recipe in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020), except changing
    the following options:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用*Spring Initializr*工具创建一个新的Spring Boot应用程序，该应用程序连接到数据库。我们将使用与[*第1章*](B21646_01.xhtml#_idTextAnchor020)中*创建RESTful
    API*配方相同的参数，除了更改以下选项：
- en: '`footballpg`'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`footballpg`'
- en: '**Dependencies**: **Spring Web**, **Spring Data JPA**, **PostgreSQL Driver**'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项**：**Spring Web**，**Spring Data JPA**，**PostgreSQL Driver**'
- en: 'Next, we’ll configure the application to connect to the PostgreSQL database.
    For that, create an `application.yml` file in the `resources` folder and set the
    following content:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将配置应用程序以连接到PostgreSQL数据库。为此，在`resources`文件夹中创建一个`application.yml`文件，并设置以下内容：
- en: '[PRE3]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, create a new service class named `TeamsService`. This class will use JdbcTemplate
    to perform the queries against the database. For that, it’s necessary to inject
    a JdbcTemplate.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`TeamsService`的新服务类。此类将使用JdbcTemplate对数据库执行查询。为此，需要注入一个JdbcTemplate。
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We’ll create a method in the *TeamsService* that gets the total number of teams.
    You can name the method `getTeamCount`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在*TeamsService*中创建一个方法来获取团队总数。你可以将此方法命名为`getTeamCount`：
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We used the jdbcTemplate method queryForObject to perform an SQL query to get
    a single value.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用了jdbcTemplate的queryForObject方法来执行一个SQL查询以获取单个值。
- en: You can now create a RestController using this service. I made a sample controller
    that uses the `TeamsService`. You can find it in the book’s repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以使用此服务创建一个RestController。我创建了一个使用`TeamsService`的示例控制器。你可以在本书的仓库中找到它，网址为[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)。
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In our configuration file `application.yml`, we have defined a data source.
    Within the data source, we have used a URL, a username, and a password. However,
    it is also possible to define additional properties. Alternatively, we can use
    only the URL. The URL contains important information such as the type of the database
    (in our case, PostgreSQL), the host, the port, and the database name. Although
    it’s possible to pass the username and password in the URL, we used specific fields
    to enhance clarity.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配置文件 `application.yml` 中，我们定义了一个数据源。在数据源内部，我们使用了 URL、用户名和密码。然而，也可以定义其他属性。或者，我们也可以只使用
    URL。URL 包含重要信息，例如数据库的类型（在我们的情况下，是 PostgreSQL）、主机、端口和数据库名。尽管可以在 URL 中传递用户名和密码，但我们使用了特定的字段来提高清晰度。
- en: Since we specified PostgreSQL as the database, it is essential to have a driver
    registered in the class path. We achieved that by adding the dependency to the
    PostgreSQL driver.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们指定了 PostgreSQL 作为数据库，因此确保类路径中注册了驱动程序至关重要。我们通过添加 PostgreSQL 驱动程序的依赖项来实现这一点。
- en: A data source object is registered in the dependency container by defining a
    data source in the configuration file. Spring Data JPA uses that data source to
    create JdbcTemplates when needed, for instance, it creates a JdbcTemplate instance
    and injects it into the `TeamsService` class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在配置文件中定义数据源，数据源对象被注册到依赖容器中。Spring Data JPA 使用该数据源在需要时创建 JdbcTemplate，例如，它创建一个
    JdbcTemplate 实例并将其注入到 `TeamsService` 类中。
- en: JdbcTemplate handles the creation and release of resources and converts `SQLExceptions`
    into Spring’s `DataAccessExceptions`. In this example, we used a very simple query
    that does not require any parameter and returns an Integer. Still, JdbcTemplate
    allows passing parameters to your query and mapping the results to complex classes.
    We won’t extend much on these capabilities in this book; rather, we’ll go deeper
    into JPA and Hibernate capabilities to map complex entities and relations to classes.
    We’ll see that in from *Using Hibernate* recipe onwards.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JdbcTemplate 处理资源的创建和释放，并将 `SQLExceptions` 转换为 Spring 的 `DataAccessExceptions`。在此示例中，我们使用了一个非常简单的查询，它不需要任何参数并返回一个
    Integer。尽管如此，JdbcTemplate 允许向你的查询传递参数并将结果映射到复杂类。我们不会在本书中过多扩展这些功能；相反，我们将深入研究 JPA
    和 Hibernate 功能，以将复杂实体和关系映射到类。从 *使用 Hibernate* 食谱开始，我们将看到这一点。
- en: There’s more...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'JdbcTemplate can be used to retrieve results that are not limited to scalar
    values. For instance, assuming that we have a `Team` class, we can define the
    following method that uses the `query` method to retrieve all teams:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: JdbcTemplate 可以用来检索不仅限于标量值的查询结果。例如，假设我们有一个 `Team` 类，我们可以定义以下方法，使用 `query` 方法检索所有团队：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we use an anonymous `RowMapper` that transforms each row into
    a `Team`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用一个匿名 `RowMapper`，它将每一行转换为一个 `Team` 对象。
- en: 'You can also pass arguments to your query. For instance, let’s retrieve a specific
    team:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以向你的查询传递参数。例如，让我们检索一个特定的团队：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This time, we used a `BeanPropertyRowMapper` to map the resulting row to Team.
    This class infers the target properties to map the columns of the resulting rows.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用 `BeanPropertyRowMapper` 将结果行映射到 Team。这个类推断目标属性以映射结果行的列。
- en: Using JdbcClient to access the database
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JdbcClient 访问数据库
- en: In the previous recipe, we used JdbcTemplate to access the database. The JdbcClient
    is an enhanced JDBC client that provides a Fluent interaction mode. JdbcClient
    has been introduced in Spring Framework 6.1, and it’s available since Spring Boot
    3.2.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个食谱中，我们使用 JdbcTemplate 访问数据库。JdbcClient 是一个增强的 JDBC 客户端，它提供了一种流畅的交互模式。JdbcClient
    自 Spring Framework 6.1 以来被引入，并且自 Spring Boot 3.2 起可用。
- en: In this recipe, we’ll learn how to use JdbcClient by performing some simple
    queries to the database.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将通过执行一些简单的数据库查询来学习如何使用 JdbcClient。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll need a PostgreSQL database. You can reuse the same database
    created in the previous recipe, *Connecting your application to PostgreSQL*. You
    can reuse the project from the same recipe as well, as the dependencies are the
    same. I prepared a working version that you can use as a starting point for this
    recipe. You can find it in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in `chapter5/recipe5-2/start` folder.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s prepare some queries using JdbcClient instead of JdbcTemplate.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a new service class named `PlayersService` and inject
    a JdbcClient in the constructor:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Create a class named `Player`. This class should have the same fields as the
    table `players` created in the *Connecting your application to PostgreSQL* recipe.
    You can find an implementation of this class in the book’s repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can create methods in the `PlayersService` to interact with the database:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s create a method named `getPlayers` to retrieve all players:'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can create a method named `getPlayer` to retrieve a single `Player`. We can
    use a parameter in the SQL query.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s do a method to create a new `Player`. Name it `createPlayer`:'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can create a controller that uses the `PlayerService`. I prepared a working
    version that you can find in the book’s GitHub repository at: [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mechanism used by the JdbcClient to create a connection to the database
    is like the JdbcTemplate. Spring Data JPA uses the data source configured in the
    application and injects it in the JdbcClient.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The JdbcClient provides a Fluent way to interact with the database, making the
    development more intuitive and reducing the boilerplate code. It allows using
    named parameters very easily, as we saw in the methods `getPlayer` and `createPlayer`.
    It also provides automatic mapping, with no need to define a `RowMapper` to process
    each row.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Using an ORM to access the database
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessing a database performing SQL requests can be performant and can work
    for simple applications. However, when the application becomes more complex and
    the database schema grows, it can be interesting using an **Object-Relational
    Mapping** (**ORM**) framework to access the database using an **Object-Oriented
    Programming** (**OOP**) layer. Probably, the most popular ORM framework in Java
    is **Hibernate**, and Spring Data JPA uses Hibernate as its default **Java Persistence
    API** (**JPA**) implementation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create entity classes that can be mapped to the database
    schema, and we’ll interact with the database without writing a single line of
    SQL.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need a PostgreSQL database for this recipe. You can reuse the database
    created in the *Connecting your application to PostgreSQL* recipe. If you haven’t
    completed that recipe yet, you can complete the first two steps of that recipe
    to create the database.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要为这个菜谱创建一个 PostgreSQL 数据库。您可以使用 *连接您的应用程序到 PostgreSQL* 菜谱中创建的数据库。如果您还没有完成那个菜谱，您可以完成那个菜谱的前两步来创建数据库。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Once we have our PostgreSQL server ready, as explained in *Getting Ready*, we
    will create a database, and we will fill it with some data. After this, we will
    create a RESTfull project to connect to the database to retrieve the data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好了 PostgreSQL 服务器，如 *准备就绪* 中所述，我们将创建一个数据库，并填充一些数据。之后，我们将创建一个 RESTful 项目以连接到数据库并检索数据。
- en: Let’s create a project connected to this database. We will use Spring Initialzr
    tool by opening https://start.spring.io in your browser.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个连接到这个数据库的项目。我们将在浏览器中打开 https://start.spring.io 来使用 Spring Initializr
    工具。
- en: 'We will use the usual parameters as in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020),
    with the following specific parameters:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用与 [*第 1 章*](B21646_01.xhtml#_idTextAnchor020) 中的相同参数，以下是一些特定参数：
- en: '`footballpg`'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`footballpg`'
- en: '**Dependencies**: **Spring Web**, **Spring Data JPA**, **PostgreSQL Driver**'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项**：**Spring Web**，**Spring Data JPA**，**PostgreSQL 驱动程序**'
- en: In this project, create the entity classes to map with the database tables.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个项目中，创建实体类以映射数据库表。
- en: 'Create a file named `TeamEntity.java` containing a class to map with table
    `teams`:'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `TeamEntity.java` 的文件，包含一个与表 `teams` 映射的类：
- en: '[PRE12]'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Create a file named `PlayerEntity.java` containing the class to map with table
    `players`.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PlayerEntity.java` 的文件，包含与表 `players` 映射的类。
- en: '[PRE13]'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Create two repository interfaces to access the database using the entities we
    created in the previous step.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个仓库接口以使用我们在上一步创建的实体访问数据库。
- en: 'Create a file named `TeamRepository.java` with the following interface:'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `TeamRepository.java` 的文件，包含以下接口：
- en: '[PRE14]'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a file named `PlayerRepository.java` containing the following interface:'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PlayerRepository.java` 的文件，包含以下接口：
- en: '[PRE15]'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a service class named `FootballService` using both repositories:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个仓库创建一个名为 `FootballService` 的服务类：
- en: '[PRE16]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create two classes representing the data exposed:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个表示公开数据的类：
- en: '`Team`:'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Team`：'
- en: '[PRE17]'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`Player`:'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player`：'
- en: '[PRE18]'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add a couple of methods to find players using different criteria:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些方法来根据不同的标准查找球员：
- en: 'Search players that contain a given string in the name:'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索包含给定字符串在名称中的球员：
- en: '[PRE19]'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Search players by birth date:'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过出生日期搜索球员：
- en: '[PRE20]'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add a method to return a `Team`, including its players:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个方法来返回一个包含其球员的 `Team`：
- en: '[PRE21]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a new team:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的团队：
- en: '[PRE22]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Update the position of a player:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新玩家的位置：
- en: '[PRE23]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, you can create a controller using the service to expose the application’s
    logic. You can find a complete example in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以使用服务创建一个控制器来公开应用程序的逻辑。您可以在书籍的 GitHub 存储库中找到一个完整的示例，网址为 [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)。
- en: 'Now configure the application to connect to PostgreSQL database. Under `resources`
    folder, create a file named `application.yml`. Set the following configuration:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在配置应用程序以连接到 PostgreSQL 数据库。在 `resources` 文件夹下，创建一个名为 `application.yml` 的文件。设置以下配置：
- en: '[PRE24]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now you can execute and test the application. You can use the instructions from
    [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020) to test the application using
    curl. I also provided a script that you can find in the repository with curl requests
    for this application. It is located at `chapter2/recipe2-1/end/scripts/requests.sh`
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您可以执行并测试应用程序。您可以使用 [*第 1 章*](B21646_01.xhtml#_idTextAnchor020) 中的说明使用 curl
    测试应用程序。我还提供了一个脚本，您可以在存储库中找到该脚本，其中包含此应用程序的 curl 请求。它位于 `chapter2/recipe2-1/end/scripts/requests.sh`。
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Hibernate is an **Object-Relational Mapping** (**ORM**) framework. Its primary
    goal is to bridge the gap between the Java programming language and relational
    databases. Using annotations such as @Entity, @Table, @Id, @OneToMany, @ManyToOne,
    and others not used in this recipe, Hibernate maps the classes to database tables.
    These mapped classes are known as *Entities*. Hibernate also provides other features,
    such as transaction management, query capabilities, caching, and lazy loading.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate是一个**对象关系映射（ORM**）框架。它的主要目标是弥合Java编程语言和关系数据库之间的差距。使用如@Entity、@Table、@Id、@OneToMany、@ManyToOne等注解，Hibernate将类映射到数据库表。这些映射的类被称为*实体*。Hibernate还提供其他功能，如事务管理、查询能力、缓存和延迟加载。
- en: Hibernate is the default JPA provider for Spring Data JPA. Spring Data JPA allows
    you to define Repository interfaces to interact with your data model. Just by
    extending the `CrudRepository` interface, it automatically generates the necessary
    JPA operations to provide Create, Read, Update, and Delete operations for your
    Entities. When using `JpaRepository`, Spring Data JPA generates the necessary
    JPA queries based on method names.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate是Spring Data JPA的默认JPA提供者。Spring Data JPA允许你定义仓库接口来与你的数据模型交互。只需通过扩展`CrudRepository`接口，它就会自动生成必要的JPA操作，为你的实体提供创建、读取、更新和删除操作。当使用`JpaRepository`时，Spring
    Data JPA会根据方法名称生成必要的JPA查询。
- en: For instance, we used `findByDateOfBirth` to create a method that returns all
    players by their date of birth and `findByNameContaining` to return all players
    whose names contain a given string. All this without writing a single line of
    SQL!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们使用了`findByDateOfBirth`来创建一个方法，该方法通过出生日期返回所有球员，以及`findByNameContaining`来返回所有名字包含给定字符串的球员。所有这些都不需要写一行SQL代码！
- en: If you are unfamiliar with the naming convention, I strongly recommend checking
    the project documentation. See [https://docs.spring.io/spring-data/jpa/reference/#repository-query-keywords](https://docs.spring.io/spring-data/jpa/reference/#repository-query-keywords).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对命名约定不熟悉，我强烈建议检查项目文档。请参阅[https://docs.spring.io/spring-data/jpa/reference/#repository-query-keywords](https://docs.spring.io/spring-data/jpa/reference/#repository-query-keywords)。
- en: In addition to the operations to read data, `CrudRepository` and `JpaRepository`
    have a method named `save`. This method allows you to update existing entities
    or create new ones if they don’t already exist. They also have some methods to
    delete entities, such as `delete`, `deleteById` and other methods.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了读取数据的操作外，`CrudRepository`和`JpaRepository`还有一个名为`save`的方法。这个方法允许你更新现有实体或创建新的实体（如果它们还不存在的话）。它们还有一些删除实体的方法，例如`delete`、`deleteById`和其他方法。
- en: Even with the abstraction offered by Spring Data JPA, it’s crucial to understand
    some of the inner workings of Spring Data. In this recipe, I used a middle tier
    component named `FootballService` between the controller and the repositories.
    You could also call a repository directly from your controller, however there
    are some caveats with this approach. To better understand it, lets deep dive on
    the operation to return a team and its players.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有了Spring Data JPA提供的抽象，理解Spring Data的一些内部工作原理也是至关重要的。在这个菜谱中，我在控制器和仓库之间使用了一个名为`FootballService`的中层组件。你也可以直接从控制器调用仓库，然而这种方法有一些注意事项。为了更好地理解它，让我们深入探讨返回一个团队及其球员的操作。
- en: 'Hibernate has two ways of loading the entities with related entities: `TeamEntity`
    has a member annotated with @OneToMany to manage its Player Entities. When your
    application uses the method `getPlayers` of the class `TeamEntity`, Hibernate
    tries to load the players by performing a request to the database. By default,
    @OneToMany relations are loaded in Lazy mode, while @ManyToOne are loaded in Eager
    mode. In summary, Lazy means, that if you don’t use the relation, the request
    to the database won’t happen. If you use the repository to retrieve the team in
    the controller and you try to return the `TeamEntity`, it will serialize the entity
    into a Json object, traversing all properties, including the players. At that
    stage of the request execution, there is no session open to access the database
    and you will receive an exception. There are several ways to fix this issue:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate有两种方式加载与实体相关的实体：`TeamEntity`有一个用@OneToMany注解的成员来管理其球员实体。当你的应用程序使用`TeamEntity`类的`getPlayers`方法时，Hibernate会尝试通过向数据库发送请求来加载球员。默认情况下，@OneToMany关系以懒加载模式加载，而@ManyToOne以急加载模式加载。总的来说，懒加载意味着，如果你不使用这个关系，就不会向数据库发送请求。如果你在控制器中通过仓库检索团队并尝试返回`TeamEntity`，它将序列化实体到一个Json对象中，遍历所有属性，包括球员。在请求执行的这一阶段，没有打开会话来访问数据库，你将收到一个异常。有几种方法可以解决这个问题：
- en: By retrieving the players at the same time as the team by using the Eager mode.
    It can be valid in certain scenarios, but it could cause unnecessary requests
    to the database.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用急加载模式同时检索团队和球员。在某些场景中可能是有效的，但它可能导致不必要的数据库请求。
- en: By allowing opening connections in view. This can be done using `spring.jpa.open-in-view=true`.
    This is an antipattern and I strongly recommend not using it.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过允许在视图中打开连接。这可以通过使用`spring.jpa.open-in-view=true`来实现。这是一个反模式，我强烈建议不要使用它。
- en: I had a bad experience related to this antipattern working on a project. I had
    an issue related to bad performance and availability of the application, but the
    system had resources and any component seemed under stress. Finally, I realized
    there were connection leaks in the application due to this `open-in-view` option.
    Finding the root cause and resolving this bug was one of the most challenging
    tasks I’ve encountered, as figuring out the root cause was not obvius.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我在处理一个项目时遇到了与这个反模式相关的一个糟糕的经历。我遇到了一个与性能和可用性相关的问题，但系统有资源，任何组件似乎都处于压力之下。最后，我意识到由于这个`open-in-view`选项，应用程序中存在连接泄漏。找到根本原因并解决这个bug是我遇到的最具挑战性的任务之一，因为找出根本原因并不明显。
- en: By the way, `spring.jpa.open-in-view=true` is the default value in Spring Boot,
    so keep this in mind and configure as false unless you have a good reason that
    I cannot imagine.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 顺便说一句，`spring.jpa.open-in-view=true`是Spring Boot的默认值，所以请记住这一点，除非你有我无法想象的好理由，否则请将其配置为false。
- en: By creating a session or a transaction while you are retrieving the data, including
    the lazy relations. This is the approach followed in this recipe. When mapping
    from `TeamEntity` to `Team`, we used the method `getPlayers`, and hence retrieved
    the data from the database. As the method `getTeam` in the `FootballService` is
    marked as `@Transactional`, all requests happen in the same transaction/session.
    As this is a read operation, you can set `@Transactional(readOnly = true)`, for
    having a less costly isolation mode for your transaction.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在检索数据时创建一个会话或事务，包括懒关系。这是本菜谱中采用的方法。当我们从`TeamEntity`映射到`Team`时，我们使用了`getPlayers`方法，因此从数据库中检索了数据。由于`FootballService`中的`getTeam`方法被标记为`@Transactional`，所有请求都在同一个事务/会话中发生。由于这是一个读操作，你可以设置`@Transactional(readOnly
    = true)`，为你的事务提供一个成本更低的隔离模式。
- en: By performing a `Join` query to retrieve both the team and its players in a
    single database request. This is the most efficient way to implement this scenario.
    We will see how to do it in another recipe of this chapter.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过执行一个`Join`查询来在一次数据库请求中检索团队及其球员。这是实现此场景的最有效方式。我们将在本章的另一道菜谱中看到如何实现它。
- en: That is the reason to create a `Service` class and not return Entities directly
    in the RESTful API.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是创建`Service`类而不是直接在RESTful API中返回实体的原因。
- en: There’s more...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this exercise, we used an existing database, and we manually created the
    entities and repositories to interact with the database. There is another approach
    that we will tackle in further recipes of this chapter, that defines the entities
    first and then generates the database automatically. For both scenarios there
    are tools that assist you in this task that can be very mechanical. For instance,
    you can use JPA Buddy plugin for IntelliJ, [https://plugins.jetbrains.com/plugin/15075-jpa-buddy](https://plugins.jetbrains.com/plugin/15075-jpa-buddy).
    It has a basic free version that is enough for simple scenarios, and a paid one
    with advanced features.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we created some code to transform Entities into other objects,
    also known as **Data Transfer Objects** (**DTOs**). It could add a lot of boilerplate
    code in your project. There are libraries that automate mapping between Java Beans
    that can fit well in this scenario. For example Mapstruct (https://mapstruct.org/).
    Spring Data JPA supports using Mapstruct to convert Entities to DTO and viceversa.
    For learning purposes, I don’t use it in the recipes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to learn more about **Open Session In View** (**OSIV**) antipattern,
    I recommend you to read this article [https://vladmihalcea.com/the-open-session-in-view-anti-pattern/](https://vladmihalcea.com/the-open-session-in-view-anti-pattern/)
    to understand the details.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Creating the database schema from our code
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a database schema and its corresponding Entities in our application,
    as seen in the previous recipe, requires a lot of repetitive work. Instead, we
    can create our Entities and we can generate the database schema automatically.
    In this recipe, we will use Spring Data JPA to generate the database schema based
    on the entity model of the application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need the same tools as in the previous recipe, namely
    a PostgreSQL server that you can run in a Docker container or on your computer.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: We will use the same code generated in the previous recipe. If you didn’t complete
    it, you can find a completed recipe in the book’s GitHub repository https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the previous example about football teams and players. Still, in
    this recipe, instead of using an existing database and creating the mapping entities,
    we will go in the opposite direction. We will use and tune the Entities already
    created to generate the Database schema. Let’s begin:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Create a new database named `football2`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open psql in your terminal.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Execute the following SQL command to create the database:'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Instead of manually generating the identifiers of our entities we will rely
    on the automatic identifier generators of the database. For that purpose, we will
    modify the annotation `@Id` of our entities.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `TeamEntity` and modify the member id as follows:'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Do the same with `PlayerEntity`.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open `application.yml` file and add the `spring.jpa.generate-ddl=true` and
    `spring.sql.init.mode=always` properties. The file should look like this:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you run the application, the database schema will be created automatically.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the `createTeam` method in class `FootballService`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we removed the generation of the team identifier, instead it will be automatically
    generated.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy the file located in the GitHub repository, in `chapter5/recipe5-4/start/data.sql`,
    to the resources folder. This folder is located in `src/main/resources`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the application.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the application by performing requests to the application as explained
    in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020). I also provided a script that
    you can find in the repository with curl requests for this application. It is
    located at `chapter5/recipe5-4/end/scripts/requests.sh`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see that the database schema is initialized, and it already has data.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By configuring the application with *spring.jpa.generate-ddl=true*, Spring
    Data will automatically generate the data schema from the entities defined in
    the project. It will use the annotations to generate the schema according to the
    target database. For instance, we used `@GeneratedValue` for id field in both
    `PlayerEntity` and `TableEntity`. It is translated into a PostgreSQL sequences.
    Taking the `TeamEntity` as an example, this is the result in PostgreSQL:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Spring Boot is able to create the schema and initialize data. It loads schema
    scripts from `optional:classpath*:schema.sql` and data scripts from `optional:classpath*:data.sql`.
    We only provided data scripts explicitly, and we did let Spring Boot generate
    the schema with `generate-ddl` setting. In addition to the data scripts, you can
    also provide the schema scripts instead of letting Spring Boot generate them for
    you. For complex applications, probably you will require specific database settings..
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, in this recipe we let Spring Boot performing the database initialization.
    By default, Spring Boot only performs the initialization if it considers that
    the database is an In-Memory embedded database, such as H2\. To force the initialization
    for PostgreSQL, we used the parameter `spring.sql.init.mode=always`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The approach followed in this recipe is intended for development environments.
    In a production environment, we could have multiple instances of the same application
    and it can cause issues having more than one instance trying to initialize the
    database. Even with mechanisms in place to ensure that only one instance of the
    application is updating the database, this process can take time and will slow
    down the application initialization. It is important to note, that some of those
    scripts should be executed only once. For instance, in this recipe we used a `data.sql`
    that insert records in both tables using explicit id values. If you try to execute
    it twice will produce a unique constraint validation error. For initialization
    you most probably want to execute the process before all the application instances
    start. For instance, in Kubernetes you can achieve this by using Init Containers,
    see https://kubernetes.io/docs/concepts/workloads/pods/init-containers/.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: For production environments, other tools such as Flyway and Liquibase exist,
    and they are supported by Spring Boot. Those tools provide more control on the
    database creation, providing versioning and migrations. In the next recipe, we’ll
    use Flyway to create and migrate the schema of the database.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we used few options among all possibilities to customize our
    entities, but almost any aspect of database schema definition can be controlled.
    Just to give some examples:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '`@Entity`: Annotating a class with `@Entity` indicates that it is a JPA entity
    and should be mapped to a database table. Each entity class corresponds to a table
    in the database, and each field in the class corresponds to a column in the table.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Table`: It is used to specify the details of the database table to which
    an entity should be mapped. You can use it to set the table name, schema, and
    other attributes.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Column`: It allows you to configure the mapping of an entity field to a database
    column. You can specify attributes like column name, length, nullable, and unique
    constraints.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@JoinColumn`: It is used to specify the column that represents a foreign key
    in a relationship. It is often used in conjunction with `@ManyToOne` or `@OneToOne`
    to specify the join column’s name and other attributes.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Transient`: Fields marked with `@Transient` are not mapped to database columns.
    This annotation is used for fields that should be excluded from database persistence.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Embedded` and `@Embeddable`: These annotations are used for creating embedded
    objects within entities. `@Embeddable` is applied to a class, and `@Embedded`
    is used in an entity to indicate that an instance of the embedded class should
    be persisted as part of the entity.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Version`: It is used to specify a version property for optimistic locking.
    It is typically applied to a numeric or timestamp field and is used to prevent
    concurrent updates to the same record.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.data-initialization](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.data-initialization)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL integration tests with Testcontainers
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing tests for a component, one of the biggest challenges is managing
    dependent services like databases. While creating mocks or using an in-memory
    database like H2 can be a solution, these approaches may hide potential issues
    in our application. **Testcontainers** is an open-source framework that offers
    temporary instances of popular databases and other services that can be run on
    Docker containers. This provides a more reliable way to test applications.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create an integration test that depends
    on PostgreSQL using Testcontainers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll create some tests for the application created in the previous
    recipe, *Creating the database schema from our code*. I prepared a working version
    as a starting point for this recipe in case you haven’t completed the previous
    recipe yet. You can find it in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Testcontainers requires Docker installed in your computer.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s enhance the reliability of our application by creating tests that utilize
    a real PostgreSQL database.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll need to include the Testcontainers starter and the PostgreSQL
    Testcontainer dependency. You can do it by adding the following dependencies in
    the project `pom.xml` file:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, create a test class, you can name it `FootballServiceTest`. Let’s setup
    the class for TestContainers. For that we’ll need:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Annotate the class with `@SpringBootTest`.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotate the class with `@TestContainers`.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure a context initializer that configures the application context using
    the PostgreSQL container that we’ll create during the test. To set the initializer
    we can annotate the class with `@ContextConfiguration`.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The class definition will look like this:'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, there is a reference to `FootballServiceTest.Initializer` class
    that we haven’t described yet. It’s explained in the following steps.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we’ll define a static field with the PostgreSQL container:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let’s use the container we just created to configure the application. It’s
    now when we’ll create the `FootballServiceTest.Initializer` class. Inside the
    FootballServiceTest create a class named Initializer:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The initializer overrides the data source configuration using the PostgreSQLContainer
    settings.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final step in configuring Testcontainers is to start the container, which
    can be done before all tests begin using `@BeforeAll` annotation. Let’s create
    a method that starts the container:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we can create the tests normally. For example, let’s make a test that
    creates a team:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `@Testcontainers` annotation searches for all fields tagged with @Container
    and triggers their container lifecycle methods. Containers declared as static
    fields, like in this recipe, are shared between test methods. This means that
    the container is started only once, before any test method is executed, and stopped
    after the last test method has executed. If the container were declared as an
    instance field, it would be started and stopped for each test method.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The PostgreSQLContainer is a specialized Testcontainer module that exposes the
    attributes of the database to facilitate the connection in our tests. We used
    the JdbcUrl, the username and the password to override the configuration.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we didn’t require mocking any repository to create tests for
    the FootballService class. Another great advantage is that the database is recreated
    for every test execution cycle, so the tests are repeatable and predictable.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Versioning and upgrading database schema
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our applications evolve, we’ll need to keep the database in sync with our
    Java entities. That could be a complex and error prone task. To address this scenario,
    there are tools to manage database schemas and database migrations. A couple of
    examples of such tools are Flyway and Liquibase, both supported by Spring Boot.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the database migration feature itself, Flyway provides the following
    features:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Version control to keep track of the migrations applied to a database and the
    ones which are pending.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be integrated into development environments and build automation tools,
    such as Maven or Gradle.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeatable migrations. Every time Flyway runs, repeatable migrations are executed
    ensuring that the database remains in the desired state.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rollback and undo operations. Flyway can automatically generate SQL scripts
    to undo a specific migration, allowing rollbacks in case of issues.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can execute the migration during the initialization of your project.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides standalone tools that can be used out of your Java project.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When used in your project, it requires different configurations to perform the
    migration, for instance registering specific beans. Spring Boot facilitates that
    integration, minimizing the necessary configuration to just some application settings
    unless you need more advanced actions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the exercise completed in the previous recipe as starting point
    for this recipe. If you haven’t completed yet, you can find a complete version
    in the book’s GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/.
    You will need the same tools, PostgreSQL and Docker.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Flyway is a solution maintained by Redgate, with free edition for individual
    and non-commercial projects and paid supported editions. For this recipe, we can
    use the libraries but keep in mind that using Flyway in a production environment
    may require a Redgate license. See https://documentation.red-gate.com/fd/licensing-164167730.html
    for details.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll use Flyway to create an initial version of the database,
    and then we’ll apply changes. We’ll learn how it can be easily used with Spring
    Boot.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Create a new database named `football3`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open psql in your terminal.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Execute the following SQL command to create the database:'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Add Flyway dependency. In your `pom.xml` file add the dependency `org.flywaydb:flywaycore`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create the database creation script. The default location for flyway scripts
    is under `src/main/resources/db`. Name the file `V1_InitialDatabase.sql` and add
    the following content to create the `teams` and `players` tables:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can also use this script to fill the database with data, for instance adding
    `teams` and `players`.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the book’s GitHub repository, you can find more data for this script, you
    can copy and paste in your project if you wish.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Migration files naming convention
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Migration files should follow the naming convention: `V<version>__<name>.sql`,
    version can be `<major version>_<minor version>`, but it is optional. Pay attention
    that between `<version>` and `<name>` there are two underscore signs.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Launch the application.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you look at the output logs, you will see a message similar to this:'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: "![Figure 5.2\uFEFF: Application logs showing migration execution.](img/B21646_05_2.jpg)"
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Application logs showing migration execution.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Flyway created a new table to manage the schema history named `flyway_schema_history`
    and executed the script we create above. You can get the list of tables in PostgreSQL
    using command *\dt*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.3\uFEFF: List of tables in recently in the database created by Flyway.](img/B21646_05_3.jpg)"
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: List of tables in recently in the database created by Flyway.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The database now has the tables necessary to manage our application.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a migration for our application now. We need to manage football
    matches in our application, and we need to know the height and weight of the players.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The matches will be managed in a new Entity named `MatchEntity`. It will have
    two fields referencing the teams playing the match, the match date, and the goals
    scored by each team. It should look like this:'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The existing entity `PlayerEntity` should have two new properties to manage
    the height and weight of the player.
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We need to create the SQL scripts for the database now. In `src/main/resources/db`
    create a new sql file named `V2__AddMatches.sql`. Add the required changes on
    the database to support the application.
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the table `matches`
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Modify the table players to add the two columns for the height and weight.
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can also set values for the existing players, for simplicity, we can set
    the same values for all players:'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Execute the application.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you check the logs, you will see the schema migration applied by Flyway.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: "![Figure 5.4\uFEFF: Application logs showing the new schema migration.](img/B21646_05_4.jpg)"
  id: totrans-283
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Application logs showing the new schema migration.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: During the startup of the application, the database is initialized. In order
    to ensure that the migration is working as expected, you can use Testcontainers
    to validate it. You can check if certain data exists in the database using this
    approach. There are some tests available in the book’s GitHub repository that
    assume the existence of certain values in the database.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On adding the Flyway dependency to your project, it will check for migration
    scripts during the application startup. If there are migration scripts, it will
    connect to the database and check for migrations that have been already applied
    by looking at the table `flyway_schema_history`. If that table doesn’t exist yet,
    it will create it. Then it will start executing all migrations that have not been
    applied yet in order. For instance, in our sample, if you start the application
    pointing to an empty database, it will apply `V1__InitialDatabase.sql` first and
    then `V2__AddMatches.sql`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Flyway also uses `flyway_schema_history` table to control the concurrency while
    applying migrations. If you have more than one instance of your application, all
    of them will try to perform the same procedure:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: The first application instance checks if the expected version is the same than
    the version deployed by looking at the `flyway_schema_history` table.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the version deployed is the expected, they will continue the application
    normally.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the version is different, it will lock the `flyway_schema_history` table,
    and will apply the migration.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rest of application instances wait until the `flyway_schema_history` table
    is released.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the migration finishes, the first application instance will update the
    version in `flyway_schema_history` table and will release it.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the rest of application instances will check the version as in step 1\.
    As it is already deployed, they will continue normally without applying the migration
    again.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another validation performed by flyway is checking if a migration file has been
    modified. The way it does it is by generating a checksum of the content and saving
    in the `flyway_schema_history`. A checksum is a kind of signature generated from
    the content that can be used to verify that content has not been modified. The
    purpose of this validation is to ensure the consistency and repeatability of the
    process.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Important
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Once applied a migration, don’t modify the script file. If you need to fix a
    migration, create a new one performing the fix.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that large migrations, for instance those requiring data transformation,
    may produce locks on the database and potential downtimes in your application,
    as the application won’t complete the initialization until the migration completes.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flyway provides a powerful mechanism to perform consistent migrations and keep
    your code in sync with the database schema. It provides robust mechanisms for
    versioning and rollback/undo operations as well as repeatable migrations.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'If your application has complex requirements related to other components and
    not only your application, Flyway provides a mechanism named *Callback* to invoke
    additional actions related to the migrations, such as recompiling stored procedures,
    recalculating materialized view or flushing a cache, etc. If you have that kind
    of requirements, I recommend you to take a look at this documentation: [https://documentation.red-gate.com/flyway/flyway-cli-and-api/concepts/callback-concept](https://documentation.red-gate.com/flyway/flyway-cli-and-api/concepts/callback-concept).'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: One drawback of using Flyway is that it may slow down the application boot process,
    even if there is no migration to apply. For that reason, Flyway also provides
    standalone tools to manage migrations, such as a Desktop UI and a command line
    tool. These tools aid in the process of allowing the migrations and related actions
    without adding any dependency to your project and performing the migration process
    independently.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, I focused on Flyway as a tool to manage database versioning,
    but Spring Boot also offers support for Liquibase. Just as Flyway, Liquibase can
    perform migrations during application startup and using independent tools such
    as the CLI. It has free and paid versions. I recommend you evaluate both tools
    and use the one that better meets your requirements.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Using JPQL
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JPQL** stands for **Java Persistence Query Language**. It is a platform-independent
    query language that is used to query and manipulate data stored in relational
    databases using the **Java Persistence** **API** (**JPA**).'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: JPQL is similar in syntax to SQL, but it operates at the object level, allowing
    developers to write queries in terms of Java objects and their relationships rather
    than database tables and columns. This makes JPQL a more natural choice for developers
    working with Java-based applications and object-relational mapping frameworks
    like Hibernate.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Some key features and concepts of JPQL include:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '**Entity Classes**: JPQL queries are written against Java entity classes, which
    are Java objects that represent database tables.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object-Oriented Queries**: JPQL allows you to query and manipulate data in
    an object-oriented way, using the names of Java classes and their attributes.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relationships**: JPQL supports querying data based on the relationships between
    entities, such as one-to-one, one-to-many, and many-to-many associations.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portability**: JPQL queries are written in a way that is independent of the
    underlying database system, making it possible to switch databases without changing
    the queries.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type Safety**: JPQL queries are type-checked at compile-time, reducing the
    risk of runtime errors.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JPQL is a powerful tool for working with data in Java-based applications. It
    allows developers to express database queries in a way that is more aligned with
    the object-oriented nature of Java programming.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we don’t need additional tools compared to previous recipes.
    As a starting point of this exercise, we will use the completed version of previous
    recipe. If you didn’t complete it, you can find it in the book’s repository at
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will enhance the Repositories created in the previous recipe
    with some advanced queries using JPQL. We will add two more entities, `AlbumEntity`
    and `CardEntity` to emulate a card trading game. The data model will look like
    this:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.5\uFEFF: PostgreSQL Data model](img/B21646_05_5.jpg)"
  id: totrans-319
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: PostgreSQL Data model'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Add the new Entities and a new repository. We will need to create a new migration.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'AlbumEntity:'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'CardsEntity:'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'AlbumRepository:'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now create a new Flyway migration to create the tables. To do that, create a
    file named `V3__AddAlbums.sql` and create the tables.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This script is available in the book repository, including some sample data.
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In our trading card game, the `CardEntitity` entity represents the cards that
    the user has. We will create a method to get the players we have of a certain
    team. To do that, in the `AlbumRepository` add the following method:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We want to know what players we don’t have yet. To find out, add the following
    method in the AlbumsRepository:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let’s find which are the players of a certain match, from both teams. In the
    `MatchRepository` add the following method:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Get a team and its players. To do that, in the `TeamRepository` add the following
    method:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This method can be used now in `FootballService` to get the teams. If you remember
    from the recipe *Connect your application to Postgresql*, we implemented a mechanism
    to avoid the Open Session In View antipattern by adding a `@Transactional` annotation
    in the method `getTeam`. With this new `TeamRepository` method, it retrieves both
    the team and its players in the same session, then it is not necessary `@Transactional`.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Find a list of players. Modify `PlayerRepository` by adding the following method:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This method could be also implemented just by using naming convention with no
    need for `@``Query` annotation.
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Find a list of players whose names contain a certain string. Modify the `PlayerRepository`
    and add the following method:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Find a list of players whose name starts with a string. Modify the `PlayerRepository`
    and add the following method:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Sort the players of a team in ascending order. Modify the `PlayerRepository`
    and add the following repository.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You can decide how to sort the results.
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have the option to paginate the results. This means that if the result set
    is extensive, we can divide it into pages and retrieve. The `JpaRepository` already
    provides method overloads to page the results. For instance, the method `findAll`
    can receive a pageable parameter to control how the results should be paged.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can add this as parameter in any of the methods using a custom query. For
    instance, we can create the following method in `AlbumsRepository`:'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We can also use JPQL to return aggregated results. For instance, let’s create
    a query to get the number of players in a given position, per team.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As you can see, the result is not an entity, but just the name of the team and
    the number of players in the position. To return this result we used a custom
    result, implemented as an Interface.
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The interface should have getter methods matching the projected query result.
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a RESTful controller and a service to use the methods generated. In the
    book’s GitHub repository there is a RESTful API using the repositories created
    in this recipe.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the repository you can also find a script to call the RESTful API methods
    created in this recipe.
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an application using Spring Data JPA starts, it performs several important
    actions to make it work.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Spring Application Context initialization. It sets up the environment for managing
    Spring components, including the repositories.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot scans component and detect repositories. It checks classes annotated
    with `@Repository` and interfaces extending `JpaRepository`.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each repository interface, Spring Data JPA generates a concrete implementation
    during runtime. In our scenario, it means that it takes each method defined in
    the repositories and generates the specific queries. At this step it validates
    if it can generate the implementation by using the naming convention, or by using
    the `@Query` annotation. At this step it also validates the queries, so if we
    write an invalid query or it is not capable of generating the implementation from
    the naming convention, it will fail.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After generating the implementation, it registers them as beans in the application
    context and are now available for the rest of components of our application.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One important advantage of JPA and JPQL is that the queries reference the Entities
    we defined in our code, so it can detect a query/entity mapping mismatch early.
    This cannot be achieved when using native queries.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage is that it abstracts the underlaying database. As a developer,
    this is an interesting feature, as it makes the onboarding to a new database faster.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can activate the SQL logging by using `spring.jpa.show-sql` configuration
    variable. It is interesting to check and debug the native queries being generated.
    Keep in mind that it can slow down your application and generate large logs. I
    recommend using this setting only in development.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Using Native Queries
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JPQL is a very powerful mechanism to access relational databases with an abstraction
    of the underlying database. Native Queries refers to executing SQL statements
    directly against the database. Depending on your requirements you might consider
    using Native queries, for instances like:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Executing complex SQL operations that are not easily expressible in JPQL, for
    instance, queries that involve subqueries or database-specific functions.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you need to fine-tune the performance of a query, leveraging database-specific
    optimizations, indexes, and hints to improve the query execution time.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database-specific features, for instance, the databases that can manage JSON
    structures, may have different ways of doing it.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bulk Operations: Native queries are often more efficient for executing bulk
    insert, update, or delete operations on a large number of records, as they bypass
    the overhead of entity management and caching that comes with JPQL.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that using Native Queries comes with some trade-offs compared to
    JPQL.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '**Type Safety**: As we saw in the previous recipe, JPQL provides type safety,
    which means that query results are returned as strongly typed objects and queries
    are validated during application startup. With native queries, you typically work
    with untyped result sets, which can introduce runtime errors if not handled properly
    and that will come up just when the native query is used.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native queries can be harder to maintain and refactor because they involve SQL
    strings embedded in your Java code. JPQL queries are more self-contained and easier
    to manage
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Portability**: Native queries are not portable across different database
    systems. If your application needs to support multiple databases, you may need
    to write database-specific queries for each one, and you will need to learn the
    specific differences of each database SQL dialect.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we’ll introduce a new feature, match timelines, to our Football
    application. The timeline are all the events that happen during a football match;
    as we don’t want to constrain the content that can be managed as an event, we
    will save part of the information as JSON. PostgreSQL has excellent support for
    JSON, but for most of the scenarios, it is necessary to write native queries.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we don’t need additional tools compared to previous recipes.
    As starting point of this exercise, we will use the completed version of previous
    recipe. If you didn’t complete it, you can find it in the book’s repository at
    https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/. I also prepared
    some scripts to create some sample data for the database. It will be explained
    as part of the recipe steps.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will create a new table managing the match events. That table
    will have a column containing JSON documents.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: To create the new table, we will create a new Flyway migration. In folder `src/main/resources/db/migration`
    create a file named `V4__AddMatchEvents.sql` with the following content.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Additionally, I prepared another migration that you can find in https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/
    named `V4_1__CreateSampleEvents.sql`. This migration inserts events in the `match_events`
    table, so you will be able to play around it. Here you can see an example of match
    event detail:'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create a new entity to manage this table. Create a class named `MatchEventEntity`:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We will map the JSON content in another class named `MatchEventDetails`. You
    can use other more flexible data structures, such as a Map.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Create a new `JpaRepository` and name it `MatchEventRepository`:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We will create a new method in the repository to retrieve all events in a match
    of a given type. The type of event is just an attribute of the JSON content. To
    perform this query, we need to use PostgreSQL specific syntax to query using the
    JSON content. To use Native Queries, we just need to specify in `@Query` annotation
    the attribute `nativeQuery =` `true`.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We will implement a repository method to retrieve the events associated with
    a particular football match in which a specified player participated.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In `PlayerRepository` we will create a method a new method to map the stored
    procedure.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now you can create a service and a controller using these repositories. In the
    GitHub repository, I extended the existing controller to call the new repository
    methods. You can also find a script calling the new controller methods.
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we used JSON because it is very useful to store data that can
    be flexible, extensible and it is not required to be as structured as a table,
    with known columns and types. PostgreSQL has a good support for JSON, however
    JPQL support for this kind of scenario is more limited. That is why, you need
    to use Native Queries.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Even if PostgreSQL has very good support for JSON, it is not as optimized as
    it is for regular columns. If there is information in the document that is frequently
    used, it is better to move it to regular columns. PostgreSQL supports indexes
    over JSON properties, you will need to evaluate which is the best approach for
    your specific scenario.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: We used `MatchEventDetail` is just a class, not an Entity. In any case, this
    also requires knowing the schema of the JSON data in advance to avoid serialization
    errors. If you need a more flexible approach, you can use just a Map or a String
    to map that column.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: JSON support is just an example of a native feature in this case of PostgreSQL,
    but there are other scenarios that you might require using native queries. For
    instance, complex queries that are difficult or not possible to express using
    JPQL, such as subqueries and bulk operations.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'When a Native Query is executed, the SQL command itself is not checked by Spring
    Data JPA nor Hibernate, however the resulting execution should be mapped to the
    resulting Entities. Keep that in mind when you write the SQL statements. For instance,
    if in this recipe, we wrote:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'That should match a `List<MatchEventEntity>`. According to our definition of
    `MatchEventEntity`, it expects that the result of the query contains the columns
    *id*, *event_time*, *details* and *match_id*. So be aware of this fact when using
    alias in your queries. As an example, look at the following query, it will result
    in an error in runtime:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: CREATE TABLE users (
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: id SERIAL PRIMARY KEY,
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: username VARCHAR(255)
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: );
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ALTER TABLE albums ADD COLUMN owner_id INTEGER REFERENCES users(id);
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ALTER TABLE cards ADD COLUMN owner_id INTEGER REFERENCES users(id);
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ALTER TABLE cards ADD CONSTRAINT cards_album_player_key UNIQUE (album_id, player_id);
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '@Table(name = "users")'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Entity'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public class UserEntity {
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Id'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@GeneratedValue(strategy = GenerationType.IDENTITY)'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: private Integer id;
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: private String username;
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@OneToMany(mappedBy = "owner")'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: private List<CardEntity> ownedCards;
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@OneToMany(mappedBy = "owner")'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: private Set<AlbumEntity> ownedAlbums;
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '@ManyToOne'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@JoinColumn(name = "owner_id")'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: private UserEntity owner;
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '@Table(name = "cards", uniqueConstraints = { @UniqueConstraint(columnNames
    = { "album_id", "player_id" }) })'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Entity'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public class CardEntity {
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: public interface UserRepository extends JpaRepository<UserEntity, Integer> {
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: private UserRepository usersRepository;
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public User createUser(String name) {
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: UserEntity user = new UserEntity();
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: user.setUsername(name);
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: user = usersRepository.save(user);
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return new User(user.getId(), user.getUsername());
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: public Album buyAlbum(Integer userId, String title) {
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: AlbumEntity album = new AlbumEntity();
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: album.setTitle(title);
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: album.setExpireDate(LocalDate.now().plusYears(1));
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: album.setOwner(usersRepository.findById(userId).orElseThrow());
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: album = albumsRepository.save(album);
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return new Album(album.getId(), album.getTitle(), album.getOwner().getId());
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: public List<Card> buyCards(Integer userId, Integer count) {
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Random rnd = new Random();
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: List<PlayerEntity> players = getAvailablePlayers();
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: UserEntity owner = usersRepository.findById(userId).orElseThrow();
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: List<CardEntity> cards = Stream.generate(() -> {
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CardEntity card = new CardEntity();
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: card.setOwner(owner);
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: card.setPlayer(players.get(rnd.nextInt(players.size())));
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return card;
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}).limit(count).toList();'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return cardsRepository.saveAll(cards)
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .stream()
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .map(card -> new Card(card.getId(), card.getOwner().getId(), Optional.empty(),
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: new Player(card.getPlayer().getName(), card.getPlayer().getJerseyNumber(),
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: card.getPlayer().getPosition(), card.getPlayer().getDateOfBirth())))
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect(Collectors.toList());
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: UPDATE cards
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: SET album_id = r.album_id
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: FROM
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (SELECT available.album_id, (SELECT c2.id from cards c2 where c2.owner_id=?1
    AND c2.player_id = available.player_id AND c2.album_id IS NULL LIMIT 1) as card_id
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: FROM
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (SELECT DISTINCT a.id as album_id, c.player_id FROM albums a CROSS JOIN cards
    c WHERE a.owner_id=?1 AND c.owner_id=?1 AND c.album_id IS NULL AND c.player_id
    NOT IN (SELECT uc.player_id from cards uc WHERE uc.album_id = a.id)) available)
    as r
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: WHERE cards.id = r.card_id
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '@Modifying'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Query(nativeQuery = true, value = "UPDATE cards " +'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"SET album_id = r.album_id  " + //'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"FROM " + //'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"(SELECT available.album_id, (SELECT c2.id from cards c2 where c2.owner_id=?1
    AND c2.player_id = available.player_id AND c2.album_id IS NULL LIMIT 1) as card_id
    " + //'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"FROM " + //'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"(SELECT DISTINCT a.id as album_id, c.player_id FROM albums a CROSS JOIN cards
    c WHERE a.owner_id=?1 AND c.owner_id=?1 AND c.album_id IS NULL AND c.player_id
    NOT IN (SELECT uc.player_id from cards uc WHERE uc.album_id = a.id)) available)
    as r " +'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"WHERE cards.id = r.card_id " +'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"RETURNING cards.*")'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: List<CardEntity> assignCardsToUserAlbums(Integer userId);
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '@Modifying'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Query(value = "UPDATE CardEntity " +'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '" SET album = null, " +'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '" owner= (SELECT u FROM UserEntity u WHERE u.id=?2) " +'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"WHERE id = ?1 ")'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integer transferCard(Integer cardId, Integer userId);
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '@Transactional'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public Optional<Card> transferCard(Integer cardId, Integer userId) {
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integer count = cardsRepository.transferCard(cardId, userId);
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (count == 0) {
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return Optional.empty();
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: …
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '@Modifying'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Query(nativeQuery = true, value = "UPDATE cards " +'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"SET owner_id=?2 " +'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '" FROM (select c1.id from cards c1 where c1.owner_id=?1 and c1.album_id IS
    NULL AND c1.player_id IN (select p2.id from players p2 where p2.id NOT IN (SELECT
    c2.player_id FROM cards c2 WHERE c2.owner_id=?2)) LIMIT ?3) cards_from_user1_for_user2
    " +'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"WHERE cards.id = cards_from_user1_for_user2.id " +'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"RETURNING cards.*")'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: List<CardEntity> tradeCardsBetweenUsers(Integer userId1, Integer userId2, Integer
    count);
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '@Service'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public class DynamicQueriesService {
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Public List<PlayerEntity> searchTeamPlayers(Integer teamId, Optional<String>
    name, Optional<Integer> minHeight,
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Optional<Integer> maxHeight,
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Optional<Integer> minWeight, Optional<Integer> maxWeight) {
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CriteriaBuilder cb = em.getCriteriaBuilder();
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CriteriaQuery<PlayerEntity> cq = cb.createQuery(PlayerEntity.class);
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Root<PlayerEntity> player = cq.from(PlayerEntity.class);
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: List<Predicate> predicates = new ArrayList<>();
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: predicates.add(cb.equal(player.get("team").get("id"), teamId));
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (name.isPresent()) {
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: predicates.add(cb.like(player.get("name"), name.get()));
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (minHeight.isPresent()) {
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: predicates.add(cb.ge(player.get("height"), minHeight.get()));
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (maxHeight.isPresent()) {
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: predicates.add(cb.le(player.get("height"), maxHeight.get()));
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (minWeight.isPresent()) {
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: predicates.add(cb.ge(player.get("weight"), minWeight.get()));
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (maxWeight.isPresent()) {
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: predicates.add(cb.le(player.get("weight"), maxWeight.get()));
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cq.where(predicates.toArray(new Predicate[0]));
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: TypedQuery<PlayerEntity> query = em.createQuery(cq);
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return query.getResultList();
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: public List<MatchEventEntity> searchMatchEventsRange(Integer matchId, Optional<LocalDateTime>
    minTime, Optional<LocalDateTime> maxTime) {
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: String command = "SELECT e FROM MatchEventEntity e WHERE e.match.id=:matchId
    ";
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (minTime.isPresent() && maxTime.isPresent()) {
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: command += " AND e.time BETWEEN :minTime AND :maxTime";
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else if (minTime.isPresent()) {'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: command += " AND e.time >= :minTime";
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else if (maxTime.isPresent()) {'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: command += " AND e.time <= :maxTime";
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: TypedQuery<MatchEventEntity> query = em.createQuery(command, MatchEventEntity.class);
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: query.setParameter("matchId", matchId);
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (minTime.isPresent()) {
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: query.setParameter("minTime", minTime.get());
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (maxTime.isPresent()) {
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: query.setParameter("maxTime", maxTime.get());
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return query.getResultList();
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-578
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: public List<PlayerEntity> searchUserMissingPlayers(Integer userId) {
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Query query = em.createNativeQuery(
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"SELECT p1.* FROM players p1 WHERE p1.id NOT IN (SELECT c1.player_id FROM cards
    c1 WHERE c1.owner_id=?1)",'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: PlayerEntity.class);
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: query.setParameter(1, userId);
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return query.getResultList();
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: public void deleteEventRange(Integer matchId, LocalDateTime start, LocalDateTime
    end) {
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: em.getTransaction().begin();
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Query query = em.createQuery("DELETE FROM MatchEventEntity e WHERE e.match.id=:matchId
    AND e.time BETWEEN :start AND :end");
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: query.setParameter("matchId", matchId);
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: query.setParameter("start", start);
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: query.setParameter("end", end);
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: query.executeUpdate();
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: em.getTransaction().commit();
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Integer potentialUser1ToUser2 = cardsRepository.countMatchBetweenUsers(userId1,
    userId2);
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integer potentialUser2ToUser1 = cardsRepository.countMatchBetweenUsers(userId2,
    userId1);
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integer count = Math.min(potentialUser1ToUser2, potentialUser2ToUser1);
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: ArrayList<CardEntity> result = new ArrayList<>(
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cardsRepository.tradeCardsBetweenUsers(userId1, userId2, count));
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useAllCardAvailable(userId2);
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: result.addAll(cardsRepository.tradeCardsBetweenUsers(userId2, userId1, count));
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useAllCardAvailable(userId1);
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '@Transactional'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public List<Card> tradeAllCards(Integer userId1, Integer userId2) {
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integer potentialUser1ToUser2 = cardsRepository.countMatchBetweenUsers(userId1,
    userId2);
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integer potentialUser2ToUser1 = cardsRepository.countMatchBetweenUsers(userId2,
    userId1);
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integer count = Math.min(potentialUser1ToUser2, potentialUser2ToUser1);
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (count > 0) {
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ArrayList<CardEntity> result = new ArrayList<>(
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cardsRepository.tradeCardsBetweenUsers(userId1, userId2, count));
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useAllCardAvailable(userId2);
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: result.addAll(cardsRepository.tradeCardsBetweenUsers(userId2, userId1, count));
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useAllCardAvailable(userId1);
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: ArrayList<CardEntity> result1 = new ArrayList<>(
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cardsRepository.tradeCardsBetweenUsers(userId1, userId2, count));
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useAllCardAvailable(userId2);
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ArrayList<CardEntity> result2 = new ArrayList<>(
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cardsRepository.tradeCardsBetweenUsers(userId2, userId1, count));
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useAllCardAvailable(userId1);
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (result1.size() != result2.size()) {
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: throw new RuntimeException("Users have different number of cards");
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '@Transactional(isolation = Isolation.SERIALIZABLE)'
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public List<Card> tradeAllCards(Integer userId1, Integer userId2) {
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integer potentialUser1ToUser2 = cardsRepository.countMatchBetweenUsers(userId1,
    userId2);
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integer potentialUser2ToUser1 = cardsRepository.countMatchBetweenUsers(userId2,
    userId1);
  id: totrans-634
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integer count = Math.min(potentialUser1ToUser2, potentialUser2ToUser1);
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (count > 0) {
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ArrayList<CardEntity> result1 = new ArrayList<>(
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cardsRepository.tradeCardsBetweenUsers(userId1, userId2, count));
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useAllCardAvailable(userId2);
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ArrayList<CardEntity> result2 = new ArrayList<>(
  id: totrans-640
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cardsRepository.tradeCardsBetweenUsers(userId2, userId1, count));
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useAllCardAvailable(userId1);
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: …
  id: totrans-643
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-646
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '@Transactional(propagation = Propagation.REQUIRES_NEW)'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: em.getTransaction().begin();
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: // do your changes
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: em.getTransaction().commit();
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: try {
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: em.getTransaction().begin();
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: …
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: em.getTransaction().commit();
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (Exception e) {'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: em.getTransaction().rollback();
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
