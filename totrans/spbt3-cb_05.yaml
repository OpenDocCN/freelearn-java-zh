- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Persistence and Relational Database Integration with Spring Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most applications handle their data in some way, necessitating the use of a
    database engine. This chapter discusses Relational Databases, the most widely
    used database technology. Relational databases remain a flexible and dependable
    option for a variety of application scenarios. Their organized, tabular data storage
    format with a defined schema suits many purposes. Additionally, relational databases
    offer essential benefits like enforcing data integrity, supporting complex queries,
    and adhering to **ACID** principles (**Atomicity, Consistency, Isolation, Durability**).
    They prove to be a suitable choice for applications ranging from simple to mission-critical
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data is a component of the Spring Framework, designed to streamline data
    access in Java applications. It offers a consistent programming model and an abstraction
    layer for interacting with various data stores, including relational databases
    and other types of databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two modules in Spring Data for relational databases: Spring Data
    JPA and Spring Data JDBC.'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data JPA. This module provides integration with **Java Persistence API**
    (**JPA**), allowing developers to work with relational databases using **Object-Relational
    Mapping** principles (**ORM**). One of the benefits is that most of the code is
    database independent, not for the purpose of creating an application totally independent
    of the database, but to reuse the learnings regardless the underlaying database.
    In complex applications, taking advantage of vendor-specific features can be determinant
    for a successful project, so I recommend using all features available from a database
    engine. Trying to make an application that can be deployed in any database causes
    that your application will use only the minimum common set available in all databases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data JDBC. This module offers more direct approach to database access,
    focusing on the use of plain SQL queries and direct mapping of data between Java
    objects and database tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use Spring Data JPA for the most common data access scenarios. From
    basic data operations such as Create, Read, Update, Delete (CRUD) to more advanced
    tasks such as complex queries, transactions, and database schema initialization
    and schema upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: We will use PostgreSQL as a database engine, as it is Open Source, widely adopted,
    multiplatform and has a vibrant community around it. But as mentioned above, we
    could use the same principles to create an application using another relational
    database engine, such as MySQL, SQL Server or Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting your application to Postgresql
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and updating the database schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a CRUD repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JPQL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Native queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic Queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Spring Data JDBC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need a PostgreSQL server. The easiest way to deploy
    it in your local environment is by using Docker. You can get Docker from the product
    page: [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer to install PostgreSQL in your computer, you can download it from
    the project page: [https://www.postgresql.org/download/](https://www.postgresql.org/download/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'I also recommend installing PgAdmin to access the database. You can use it
    to observe the changes performed by your application in the database. You can
    download it from the project page: [https://www.pgadmin.org/download/](https://www.pgadmin.org/download/)'
  prefs: []
  type: TYPE_NORMAL
- en: You can use other tools, such as plugins for Visual Studio Code or IntelliJ.
  prefs: []
  type: TYPE_NORMAL
- en: You will need a code editor and OpenJDK as explained in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the recipes that will be demonstrated in this chapter can be found at:
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter5](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter5).'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting your application to PostgreSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You want to create a RESTful API to server Football data to your end users.
    To manage this data, we decided to use a relatational database, as we are interested
    in prodiving data consistency and advanced query capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will connect an application, a RESTful API, to a PostgreSQL
    database. To do that, the first thing we’ll do is deploy a PostgreSQL database
    in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe you will learn how to create a basic application that connects
    to a PostgreSQL database and perform basic SQL queries with JdbcTemplate.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you will need a PostgreSQL database. If you have already one
    server available, you can use it. Otherwise, you can use Docker to deploy a PostgreSQL
    in your computer. For that, you can execute the following command in your terminal
    to download and execute a PostgreSQL instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You will have a PostgreSQL server available listening on port 5432, with username
    and password *packt*. If you want to change these parameters, you can modify the
    command above.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need a tool to perform some actions on PostgreSQL. I will use the
    command line tool psql. In Ubuntu you can install it using *apt,* the default
    package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Alternativelly to psql, you can use PgAdmin to connect to the database with
    a nice UI. I’ll explain the samples just with the command line using psql, but
    you can use PgAdmin to execute the database scripts if you want. Follow the instruction
    from the official page at [https://www.pgadmin.org/download/](https://www.pgadmin.org/download/)
    to install it in your computer.
  prefs: []
  type: TYPE_NORMAL
- en: You will find the sql scripts in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we will use Spring Initializr tool to create our projects, or the
    integrated tool in your favorite IDE or editor if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have our PostgreSQL server ready as explained in *Getting Ready*, we
    will create a database. After this, we will create a Spring Boot application that
    will connect to the database to perform a simple query.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, download the postgresql scripts available in the GitHub repository.
    They are located in `chapter5/recipe5-1/start/sql`. There are two script files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`db-creation.sql`. This script creates a database named `football`, with two
    tables: `teams` and `players`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insert-data.sql`. This script inserts sample data in the `teams` and `players`
    tables.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we’ll execute the scripts in the database to execute the scripts. For
    that, open a terminal and execute the following commands to execute the scripts
    in PostgreSQL using the *psql* tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It will request the password. Introduce *packt* as configured in the *Getting
    Ready* section. If you used different parameters in the *Getting Ready* section,
    use it accordingly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Alternatively, you can use *PgAdmin* tool instead of *psql* tool.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The database schema we just created looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.1: Database schema. Exported with PgAdmin tool.](img/B21646_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Database schema. Exported with PgAdmin tool.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new Spring Boot application connecting to the database using
    *Spring Initializr* tool. We’ll use the same parameters as in *Creating a RESTful
    API* recipe in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020), except changing
    the following options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`footballpg`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependencies**: **Spring Web**, **Spring Data JPA**, **PostgreSQL Driver**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we’ll configure the application to connect to the PostgreSQL database.
    For that, create an `application.yml` file in the `resources` folder and set the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, create a new service class named `TeamsService`. This class will use JdbcTemplate
    to perform the queries against the database. For that, it’s necessary to inject
    a JdbcTemplate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll create a method in the *TeamsService* that gets the total number of teams.
    You can name the method `getTeamCount`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We used the jdbcTemplate method queryForObject to perform an SQL query to get
    a single value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can now create a RestController using this service. I made a sample controller
    that uses the `TeamsService`. You can find it in the book’s repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our configuration file `application.yml`, we have defined a data source.
    Within the data source, we have used a URL, a username, and a password. However,
    it is also possible to define additional properties. Alternatively, we can use
    only the URL. The URL contains important information such as the type of the database
    (in our case, PostgreSQL), the host, the port, and the database name. Although
    it’s possible to pass the username and password in the URL, we used specific fields
    to enhance clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Since we specified PostgreSQL as the database, it is essential to have a driver
    registered in the class path. We achieved that by adding the dependency to the
    PostgreSQL driver.
  prefs: []
  type: TYPE_NORMAL
- en: A data source object is registered in the dependency container by defining a
    data source in the configuration file. Spring Data JPA uses that data source to
    create JdbcTemplates when needed, for instance, it creates a JdbcTemplate instance
    and injects it into the `TeamsService` class.
  prefs: []
  type: TYPE_NORMAL
- en: JdbcTemplate handles the creation and release of resources and converts `SQLExceptions`
    into Spring’s `DataAccessExceptions`. In this example, we used a very simple query
    that does not require any parameter and returns an Integer. Still, JdbcTemplate
    allows passing parameters to your query and mapping the results to complex classes.
    We won’t extend much on these capabilities in this book; rather, we’ll go deeper
    into JPA and Hibernate capabilities to map complex entities and relations to classes.
    We’ll see that in from *Using Hibernate* recipe onwards.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JdbcTemplate can be used to retrieve results that are not limited to scalar
    values. For instance, assuming that we have a `Team` class, we can define the
    following method that uses the `query` method to retrieve all teams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use an anonymous `RowMapper` that transforms each row into
    a `Team`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also pass arguments to your query. For instance, let’s retrieve a specific
    team:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This time, we used a `BeanPropertyRowMapper` to map the resulting row to Team.
    This class infers the target properties to map the columns of the resulting rows.
  prefs: []
  type: TYPE_NORMAL
- en: Using JdbcClient to access the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we used JdbcTemplate to access the database. The JdbcClient
    is an enhanced JDBC client that provides a Fluent interaction mode. JdbcClient
    has been introduced in Spring Framework 6.1, and it’s available since Spring Boot
    3.2.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to use JdbcClient by performing some simple
    queries to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll need a PostgreSQL database. You can reuse the same database
    created in the previous recipe, *Connecting your application to PostgreSQL*. You
    can reuse the project from the same recipe as well, as the dependencies are the
    same. I prepared a working version that you can use as a starting point for this
    recipe. You can find it in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in `chapter5/recipe5-2/start` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s prepare some queries using JdbcClient instead of JdbcTemplate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a new service class named `PlayersService` and inject
    a JdbcClient in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a class named `Player`. This class should have the same fields as the
    table `players` created in the *Connecting your application to PostgreSQL* recipe.
    You can find an implementation of this class in the book’s repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can create methods in the `PlayersService` to interact with the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s create a method named `getPlayers` to retrieve all players:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: We can create a method named `getPlayer` to retrieve a single `Player`. We can
    use a parameter in the SQL query.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s do a method to create a new `Player`. Name it `createPlayer`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'You can create a controller that uses the `PlayerService`. I prepared a working
    version that you can find in the book’s GitHub repository at: [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mechanism used by the JdbcClient to create a connection to the database
    is like the JdbcTemplate. Spring Data JPA uses the data source configured in the
    application and injects it in the JdbcClient.
  prefs: []
  type: TYPE_NORMAL
- en: The JdbcClient provides a Fluent way to interact with the database, making the
    development more intuitive and reducing the boilerplate code. It allows using
    named parameters very easily, as we saw in the methods `getPlayer` and `createPlayer`.
    It also provides automatic mapping, with no need to define a `RowMapper` to process
    each row.
  prefs: []
  type: TYPE_NORMAL
- en: Using an ORM to access the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessing a database performing SQL requests can be performant and can work
    for simple applications. However, when the application becomes more complex and
    the database schema grows, it can be interesting using an **Object-Relational
    Mapping** (**ORM**) framework to access the database using an **Object-Oriented
    Programming** (**OOP**) layer. Probably, the most popular ORM framework in Java
    is **Hibernate**, and Spring Data JPA uses Hibernate as its default **Java Persistence
    API** (**JPA**) implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create entity classes that can be mapped to the database
    schema, and we’ll interact with the database without writing a single line of
    SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need a PostgreSQL database for this recipe. You can reuse the database
    created in the *Connecting your application to PostgreSQL* recipe. If you haven’t
    completed that recipe yet, you can complete the first two steps of that recipe
    to create the database.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have our PostgreSQL server ready, as explained in *Getting Ready*, we
    will create a database, and we will fill it with some data. After this, we will
    create a RESTfull project to connect to the database to retrieve the data.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a project connected to this database. We will use Spring Initialzr
    tool by opening https://start.spring.io in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will use the usual parameters as in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020),
    with the following specific parameters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`footballpg`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependencies**: **Spring Web**, **Spring Data JPA**, **PostgreSQL Driver**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In this project, create the entity classes to map with the database tables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `TeamEntity.java` containing a class to map with table
    `teams`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Create a file named `PlayerEntity.java` containing the class to map with table
    `players`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Create two repository interfaces to access the database using the entities we
    created in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `TeamRepository.java` with the following interface:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file named `PlayerRepository.java` containing the following interface:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a service class named `FootballService` using both repositories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create two classes representing the data exposed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Team`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`Player`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a couple of methods to find players using different criteria:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Search players that contain a given string in the name:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Search players by birth date:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a method to return a `Team`, including its players:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new team:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the position of a player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you can create a controller using the service to expose the application’s
    logic. You can find a complete example in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now configure the application to connect to PostgreSQL database. Under `resources`
    folder, create a file named `application.yml`. Set the following configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now you can execute and test the application. You can use the instructions from
    [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020) to test the application using
    curl. I also provided a script that you can find in the repository with curl requests
    for this application. It is located at `chapter2/recipe2-1/end/scripts/requests.sh`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hibernate is an **Object-Relational Mapping** (**ORM**) framework. Its primary
    goal is to bridge the gap between the Java programming language and relational
    databases. Using annotations such as @Entity, @Table, @Id, @OneToMany, @ManyToOne,
    and others not used in this recipe, Hibernate maps the classes to database tables.
    These mapped classes are known as *Entities*. Hibernate also provides other features,
    such as transaction management, query capabilities, caching, and lazy loading.
  prefs: []
  type: TYPE_NORMAL
- en: Hibernate is the default JPA provider for Spring Data JPA. Spring Data JPA allows
    you to define Repository interfaces to interact with your data model. Just by
    extending the `CrudRepository` interface, it automatically generates the necessary
    JPA operations to provide Create, Read, Update, and Delete operations for your
    Entities. When using `JpaRepository`, Spring Data JPA generates the necessary
    JPA queries based on method names.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, we used `findByDateOfBirth` to create a method that returns all
    players by their date of birth and `findByNameContaining` to return all players
    whose names contain a given string. All this without writing a single line of
    SQL!
  prefs: []
  type: TYPE_NORMAL
- en: If you are unfamiliar with the naming convention, I strongly recommend checking
    the project documentation. See [https://docs.spring.io/spring-data/jpa/reference/#repository-query-keywords](https://docs.spring.io/spring-data/jpa/reference/#repository-query-keywords).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the operations to read data, `CrudRepository` and `JpaRepository`
    have a method named `save`. This method allows you to update existing entities
    or create new ones if they don’t already exist. They also have some methods to
    delete entities, such as `delete`, `deleteById` and other methods.
  prefs: []
  type: TYPE_NORMAL
- en: Even with the abstraction offered by Spring Data JPA, it’s crucial to understand
    some of the inner workings of Spring Data. In this recipe, I used a middle tier
    component named `FootballService` between the controller and the repositories.
    You could also call a repository directly from your controller, however there
    are some caveats with this approach. To better understand it, lets deep dive on
    the operation to return a team and its players.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hibernate has two ways of loading the entities with related entities: `TeamEntity`
    has a member annotated with @OneToMany to manage its Player Entities. When your
    application uses the method `getPlayers` of the class `TeamEntity`, Hibernate
    tries to load the players by performing a request to the database. By default,
    @OneToMany relations are loaded in Lazy mode, while @ManyToOne are loaded in Eager
    mode. In summary, Lazy means, that if you don’t use the relation, the request
    to the database won’t happen. If you use the repository to retrieve the team in
    the controller and you try to return the `TeamEntity`, it will serialize the entity
    into a Json object, traversing all properties, including the players. At that
    stage of the request execution, there is no session open to access the database
    and you will receive an exception. There are several ways to fix this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: By retrieving the players at the same time as the team by using the Eager mode.
    It can be valid in certain scenarios, but it could cause unnecessary requests
    to the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By allowing opening connections in view. This can be done using `spring.jpa.open-in-view=true`.
    This is an antipattern and I strongly recommend not using it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I had a bad experience related to this antipattern working on a project. I had
    an issue related to bad performance and availability of the application, but the
    system had resources and any component seemed under stress. Finally, I realized
    there were connection leaks in the application due to this `open-in-view` option.
    Finding the root cause and resolving this bug was one of the most challenging
    tasks I’ve encountered, as figuring out the root cause was not obvius.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By the way, `spring.jpa.open-in-view=true` is the default value in Spring Boot,
    so keep this in mind and configure as false unless you have a good reason that
    I cannot imagine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By creating a session or a transaction while you are retrieving the data, including
    the lazy relations. This is the approach followed in this recipe. When mapping
    from `TeamEntity` to `Team`, we used the method `getPlayers`, and hence retrieved
    the data from the database. As the method `getTeam` in the `FootballService` is
    marked as `@Transactional`, all requests happen in the same transaction/session.
    As this is a read operation, you can set `@Transactional(readOnly = true)`, for
    having a less costly isolation mode for your transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By performing a `Join` query to retrieve both the team and its players in a
    single database request. This is the most efficient way to implement this scenario.
    We will see how to do it in another recipe of this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is the reason to create a `Service` class and not return Entities directly
    in the RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we used an existing database, and we manually created the
    entities and repositories to interact with the database. There is another approach
    that we will tackle in further recipes of this chapter, that defines the entities
    first and then generates the database automatically. For both scenarios there
    are tools that assist you in this task that can be very mechanical. For instance,
    you can use JPA Buddy plugin for IntelliJ, [https://plugins.jetbrains.com/plugin/15075-jpa-buddy](https://plugins.jetbrains.com/plugin/15075-jpa-buddy).
    It has a basic free version that is enough for simple scenarios, and a paid one
    with advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we created some code to transform Entities into other objects,
    also known as **Data Transfer Objects** (**DTOs**). It could add a lot of boilerplate
    code in your project. There are libraries that automate mapping between Java Beans
    that can fit well in this scenario. For example Mapstruct (https://mapstruct.org/).
    Spring Data JPA supports using Mapstruct to convert Entities to DTO and viceversa.
    For learning purposes, I don’t use it in the recipes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to learn more about **Open Session In View** (**OSIV**) antipattern,
    I recommend you to read this article [https://vladmihalcea.com/the-open-session-in-view-anti-pattern/](https://vladmihalcea.com/the-open-session-in-view-anti-pattern/)
    to understand the details.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the database schema from our code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a database schema and its corresponding Entities in our application,
    as seen in the previous recipe, requires a lot of repetitive work. Instead, we
    can create our Entities and we can generate the database schema automatically.
    In this recipe, we will use Spring Data JPA to generate the database schema based
    on the entity model of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need the same tools as in the previous recipe, namely
    a PostgreSQL server that you can run in a Docker container or on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the same code generated in the previous recipe. If you didn’t complete
    it, you can find a completed recipe in the book’s GitHub repository https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the previous example about football teams and players. Still, in
    this recipe, instead of using an existing database and creating the mapping entities,
    we will go in the opposite direction. We will use and tune the Entities already
    created to generate the Database schema. Let’s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new database named `football2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open psql in your terminal.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the following SQL command to create the database:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Instead of manually generating the identifiers of our entities we will rely
    on the automatic identifier generators of the database. For that purpose, we will
    modify the annotation `@Id` of our entities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `TeamEntity` and modify the member id as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Do the same with `PlayerEntity`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open `application.yml` file and add the `spring.jpa.generate-ddl=true` and
    `spring.sql.init.mode=always` properties. The file should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you run the application, the database schema will be created automatically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the `createTeam` method in class `FootballService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we removed the generation of the team identifier, instead it will be automatically
    generated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy the file located in the GitHub repository, in `chapter5/recipe5-4/start/data.sql`,
    to the resources folder. This folder is located in `src/main/resources`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the application by performing requests to the application as explained
    in [*Chapter 1*](B21646_01.xhtml#_idTextAnchor020). I also provided a script that
    you can find in the repository with curl requests for this application. It is
    located at `chapter5/recipe5-4/end/scripts/requests.sh`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see that the database schema is initialized, and it already has data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By configuring the application with *spring.jpa.generate-ddl=true*, Spring
    Data will automatically generate the data schema from the entities defined in
    the project. It will use the annotations to generate the schema according to the
    target database. For instance, we used `@GeneratedValue` for id field in both
    `PlayerEntity` and `TableEntity`. It is translated into a PostgreSQL sequences.
    Taking the `TeamEntity` as an example, this is the result in PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Spring Boot is able to create the schema and initialize data. It loads schema
    scripts from `optional:classpath*:schema.sql` and data scripts from `optional:classpath*:data.sql`.
    We only provided data scripts explicitly, and we did let Spring Boot generate
    the schema with `generate-ddl` setting. In addition to the data scripts, you can
    also provide the schema scripts instead of letting Spring Boot generate them for
    you. For complex applications, probably you will require specific database settings..
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, in this recipe we let Spring Boot performing the database initialization.
    By default, Spring Boot only performs the initialization if it considers that
    the database is an In-Memory embedded database, such as H2\. To force the initialization
    for PostgreSQL, we used the parameter `spring.sql.init.mode=always`.
  prefs: []
  type: TYPE_NORMAL
- en: The approach followed in this recipe is intended for development environments.
    In a production environment, we could have multiple instances of the same application
    and it can cause issues having more than one instance trying to initialize the
    database. Even with mechanisms in place to ensure that only one instance of the
    application is updating the database, this process can take time and will slow
    down the application initialization. It is important to note, that some of those
    scripts should be executed only once. For instance, in this recipe we used a `data.sql`
    that insert records in both tables using explicit id values. If you try to execute
    it twice will produce a unique constraint validation error. For initialization
    you most probably want to execute the process before all the application instances
    start. For instance, in Kubernetes you can achieve this by using Init Containers,
    see https://kubernetes.io/docs/concepts/workloads/pods/init-containers/.
  prefs: []
  type: TYPE_NORMAL
- en: For production environments, other tools such as Flyway and Liquibase exist,
    and they are supported by Spring Boot. Those tools provide more control on the
    database creation, providing versioning and migrations. In the next recipe, we’ll
    use Flyway to create and migrate the schema of the database.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we used few options among all possibilities to customize our
    entities, but almost any aspect of database schema definition can be controlled.
    Just to give some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Entity`: Annotating a class with `@Entity` indicates that it is a JPA entity
    and should be mapped to a database table. Each entity class corresponds to a table
    in the database, and each field in the class corresponds to a column in the table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Table`: It is used to specify the details of the database table to which
    an entity should be mapped. You can use it to set the table name, schema, and
    other attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Column`: It allows you to configure the mapping of an entity field to a database
    column. You can specify attributes like column name, length, nullable, and unique
    constraints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@JoinColumn`: It is used to specify the column that represents a foreign key
    in a relationship. It is often used in conjunction with `@ManyToOne` or `@OneToOne`
    to specify the join column’s name and other attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Transient`: Fields marked with `@Transient` are not mapped to database columns.
    This annotation is used for fields that should be excluded from database persistence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Embedded` and `@Embeddable`: These annotations are used for creating embedded
    objects within entities. `@Embeddable` is applied to a class, and `@Embedded`
    is used in an entity to indicate that an instance of the embedded class should
    be persisted as part of the entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Version`: It is used to specify a version property for optimistic locking.
    It is typically applied to a numeric or timestamp field and is used to prevent
    concurrent updates to the same record.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.data-initialization](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.data-initialization)'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL integration tests with Testcontainers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing tests for a component, one of the biggest challenges is managing
    dependent services like databases. While creating mocks or using an in-memory
    database like H2 can be a solution, these approaches may hide potential issues
    in our application. **Testcontainers** is an open-source framework that offers
    temporary instances of popular databases and other services that can be run on
    Docker containers. This provides a more reliable way to test applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create an integration test that depends
    on PostgreSQL using Testcontainers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll create some tests for the application created in the previous
    recipe, *Creating the database schema from our code*. I prepared a working version
    as a starting point for this recipe in case you haven’t completed the previous
    recipe yet. You can find it in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook).
  prefs: []
  type: TYPE_NORMAL
- en: Testcontainers requires Docker installed in your computer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s enhance the reliability of our application by creating tests that utilize
    a real PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll need to include the Testcontainers starter and the PostgreSQL
    Testcontainer dependency. You can do it by adding the following dependencies in
    the project `pom.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a test class, you can name it `FootballServiceTest`. Let’s setup
    the class for TestContainers. For that we’ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Annotate the class with `@SpringBootTest`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotate the class with `@TestContainers`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure a context initializer that configures the application context using
    the PostgreSQL container that we’ll create during the test. To set the initializer
    we can annotate the class with `@ContextConfiguration`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The class definition will look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, there is a reference to `FootballServiceTest.Initializer` class
    that we haven’t described yet. It’s explained in the following steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we’ll define a static field with the PostgreSQL container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s use the container we just created to configure the application. It’s
    now when we’ll create the `FootballServiceTest.Initializer` class. Inside the
    FootballServiceTest create a class named Initializer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The initializer overrides the data source configuration using the PostgreSQLContainer
    settings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final step in configuring Testcontainers is to start the container, which
    can be done before all tests begin using `@BeforeAll` annotation. Let’s create
    a method that starts the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can create the tests normally. For example, let’s make a test that
    creates a team:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `@Testcontainers` annotation searches for all fields tagged with @Container
    and triggers their container lifecycle methods. Containers declared as static
    fields, like in this recipe, are shared between test methods. This means that
    the container is started only once, before any test method is executed, and stopped
    after the last test method has executed. If the container were declared as an
    instance field, it would be started and stopped for each test method.
  prefs: []
  type: TYPE_NORMAL
- en: The PostgreSQLContainer is a specialized Testcontainer module that exposes the
    attributes of the database to facilitate the connection in our tests. We used
    the JdbcUrl, the username and the password to override the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we didn’t require mocking any repository to create tests for
    the FootballService class. Another great advantage is that the database is recreated
    for every test execution cycle, so the tests are repeatable and predictable.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning and upgrading database schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our applications evolve, we’ll need to keep the database in sync with our
    Java entities. That could be a complex and error prone task. To address this scenario,
    there are tools to manage database schemas and database migrations. A couple of
    examples of such tools are Flyway and Liquibase, both supported by Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the database migration feature itself, Flyway provides the following
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: Version control to keep track of the migrations applied to a database and the
    ones which are pending.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be integrated into development environments and build automation tools,
    such as Maven or Gradle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeatable migrations. Every time Flyway runs, repeatable migrations are executed
    ensuring that the database remains in the desired state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rollback and undo operations. Flyway can automatically generate SQL scripts
    to undo a specific migration, allowing rollbacks in case of issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can execute the migration during the initialization of your project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides standalone tools that can be used out of your Java project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When used in your project, it requires different configurations to perform the
    migration, for instance registering specific beans. Spring Boot facilitates that
    integration, minimizing the necessary configuration to just some application settings
    unless you need more advanced actions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the exercise completed in the previous recipe as starting point
    for this recipe. If you haven’t completed yet, you can find a complete version
    in the book’s GitHub repository at https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/.
    You will need the same tools, PostgreSQL and Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Flyway is a solution maintained by Redgate, with free edition for individual
    and non-commercial projects and paid supported editions. For this recipe, we can
    use the libraries but keep in mind that using Flyway in a production environment
    may require a Redgate license. See https://documentation.red-gate.com/fd/licensing-164167730.html
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll use Flyway to create an initial version of the database,
    and then we’ll apply changes. We’ll learn how it can be easily used with Spring
    Boot.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new database named `football3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open psql in your terminal.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the following SQL command to create the database:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Add Flyway dependency. In your `pom.xml` file add the dependency `org.flywaydb:flywaycore`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the database creation script. The default location for flyway scripts
    is under `src/main/resources/db`. Name the file `V1_InitialDatabase.sql` and add
    the following content to create the `teams` and `players` tables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can also use this script to fill the database with data, for instance adding
    `teams` and `players`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the book’s GitHub repository, you can find more data for this script, you
    can copy and paste in your project if you wish.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Migration files naming convention
  prefs: []
  type: TYPE_NORMAL
- en: 'Migration files should follow the naming convention: `V<version>__<name>.sql`,
    version can be `<major version>_<minor version>`, but it is optional. Pay attention
    that between `<version>` and `<name>` there are two underscore signs.'
  prefs: []
  type: TYPE_NORMAL
- en: Launch the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you look at the output logs, you will see a message similar to this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: "![Figure 5.2\uFEFF: Application logs showing migration execution.](img/B21646_05_2.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Application logs showing migration execution.'
  prefs: []
  type: TYPE_NORMAL
- en: Flyway created a new table to manage the schema history named `flyway_schema_history`
    and executed the script we create above. You can get the list of tables in PostgreSQL
    using command *\dt*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.3\uFEFF: List of tables in recently in the database created by Flyway.](img/B21646_05_3.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: List of tables in recently in the database created by Flyway.'
  prefs: []
  type: TYPE_NORMAL
- en: The database now has the tables necessary to manage our application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a migration for our application now. We need to manage football
    matches in our application, and we need to know the height and weight of the players.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The matches will be managed in a new Entity named `MatchEntity`. It will have
    two fields referencing the teams playing the match, the match date, and the goals
    scored by each team. It should look like this:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The existing entity `PlayerEntity` should have two new properties to manage
    the height and weight of the player.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: We need to create the SQL scripts for the database now. In `src/main/resources/db`
    create a new sql file named `V2__AddMatches.sql`. Add the required changes on
    the database to support the application.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the table `matches`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Modify the table players to add the two columns for the height and weight.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also set values for the existing players, for simplicity, we can set
    the same values for all players:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Execute the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you check the logs, you will see the schema migration applied by Flyway.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: "![Figure 5.4\uFEFF: Application logs showing the new schema migration.](img/B21646_05_4.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Application logs showing the new schema migration.'
  prefs: []
  type: TYPE_NORMAL
- en: During the startup of the application, the database is initialized. In order
    to ensure that the migration is working as expected, you can use Testcontainers
    to validate it. You can check if certain data exists in the database using this
    approach. There are some tests available in the book’s GitHub repository that
    assume the existence of certain values in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On adding the Flyway dependency to your project, it will check for migration
    scripts during the application startup. If there are migration scripts, it will
    connect to the database and check for migrations that have been already applied
    by looking at the table `flyway_schema_history`. If that table doesn’t exist yet,
    it will create it. Then it will start executing all migrations that have not been
    applied yet in order. For instance, in our sample, if you start the application
    pointing to an empty database, it will apply `V1__InitialDatabase.sql` first and
    then `V2__AddMatches.sql`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flyway also uses `flyway_schema_history` table to control the concurrency while
    applying migrations. If you have more than one instance of your application, all
    of them will try to perform the same procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: The first application instance checks if the expected version is the same than
    the version deployed by looking at the `flyway_schema_history` table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the version deployed is the expected, they will continue the application
    normally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the version is different, it will lock the `flyway_schema_history` table,
    and will apply the migration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rest of application instances wait until the `flyway_schema_history` table
    is released.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the migration finishes, the first application instance will update the
    version in `flyway_schema_history` table and will release it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the rest of application instances will check the version as in step 1\.
    As it is already deployed, they will continue normally without applying the migration
    again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another validation performed by flyway is checking if a migration file has been
    modified. The way it does it is by generating a checksum of the content and saving
    in the `flyway_schema_history`. A checksum is a kind of signature generated from
    the content that can be used to verify that content has not been modified. The
    purpose of this validation is to ensure the consistency and repeatability of the
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: Once applied a migration, don’t modify the script file. If you need to fix a
    migration, create a new one performing the fix.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that large migrations, for instance those requiring data transformation,
    may produce locks on the database and potential downtimes in your application,
    as the application won’t complete the initialization until the migration completes.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flyway provides a powerful mechanism to perform consistent migrations and keep
    your code in sync with the database schema. It provides robust mechanisms for
    versioning and rollback/undo operations as well as repeatable migrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your application has complex requirements related to other components and
    not only your application, Flyway provides a mechanism named *Callback* to invoke
    additional actions related to the migrations, such as recompiling stored procedures,
    recalculating materialized view or flushing a cache, etc. If you have that kind
    of requirements, I recommend you to take a look at this documentation: [https://documentation.red-gate.com/flyway/flyway-cli-and-api/concepts/callback-concept](https://documentation.red-gate.com/flyway/flyway-cli-and-api/concepts/callback-concept).'
  prefs: []
  type: TYPE_NORMAL
- en: One drawback of using Flyway is that it may slow down the application boot process,
    even if there is no migration to apply. For that reason, Flyway also provides
    standalone tools to manage migrations, such as a Desktop UI and a command line
    tool. These tools aid in the process of allowing the migrations and related actions
    without adding any dependency to your project and performing the migration process
    independently.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, I focused on Flyway as a tool to manage database versioning,
    but Spring Boot also offers support for Liquibase. Just as Flyway, Liquibase can
    perform migrations during application startup and using independent tools such
    as the CLI. It has free and paid versions. I recommend you evaluate both tools
    and use the one that better meets your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Using JPQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JPQL** stands for **Java Persistence Query Language**. It is a platform-independent
    query language that is used to query and manipulate data stored in relational
    databases using the **Java Persistence** **API** (**JPA**).'
  prefs: []
  type: TYPE_NORMAL
- en: JPQL is similar in syntax to SQL, but it operates at the object level, allowing
    developers to write queries in terms of Java objects and their relationships rather
    than database tables and columns. This makes JPQL a more natural choice for developers
    working with Java-based applications and object-relational mapping frameworks
    like Hibernate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some key features and concepts of JPQL include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Entity Classes**: JPQL queries are written against Java entity classes, which
    are Java objects that represent database tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object-Oriented Queries**: JPQL allows you to query and manipulate data in
    an object-oriented way, using the names of Java classes and their attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relationships**: JPQL supports querying data based on the relationships between
    entities, such as one-to-one, one-to-many, and many-to-many associations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portability**: JPQL queries are written in a way that is independent of the
    underlying database system, making it possible to switch databases without changing
    the queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type Safety**: JPQL queries are type-checked at compile-time, reducing the
    risk of runtime errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JPQL is a powerful tool for working with data in Java-based applications. It
    allows developers to express database queries in a way that is more aligned with
    the object-oriented nature of Java programming.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we don’t need additional tools compared to previous recipes.
    As a starting point of this exercise, we will use the completed version of previous
    recipe. If you didn’t complete it, you can find it in the book’s repository at
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will enhance the Repositories created in the previous recipe
    with some advanced queries using JPQL. We will add two more entities, `AlbumEntity`
    and `CardEntity` to emulate a card trading game. The data model will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.5\uFEFF: PostgreSQL Data model](img/B21646_05_5.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: PostgreSQL Data model'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the new Entities and a new repository. We will need to create a new migration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'AlbumEntity:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'CardsEntity:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'AlbumRepository:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Now create a new Flyway migration to create the tables. To do that, create a
    file named `V3__AddAlbums.sql` and create the tables.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This script is available in the book repository, including some sample data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In our trading card game, the `CardEntitity` entity represents the cards that
    the user has. We will create a method to get the players we have of a certain
    team. To do that, in the `AlbumRepository` add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want to know what players we don’t have yet. To find out, add the following
    method in the AlbumsRepository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s find which are the players of a certain match, from both teams. In the
    `MatchRepository` add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get a team and its players. To do that, in the `TeamRepository` add the following
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method can be used now in `FootballService` to get the teams. If you remember
    from the recipe *Connect your application to Postgresql*, we implemented a mechanism
    to avoid the Open Session In View antipattern by adding a `@Transactional` annotation
    in the method `getTeam`. With this new `TeamRepository` method, it retrieves both
    the team and its players in the same session, then it is not necessary `@Transactional`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find a list of players. Modify `PlayerRepository` by adding the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method could be also implemented just by using naming convention with no
    need for `@``Query` annotation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find a list of players whose names contain a certain string. Modify the `PlayerRepository`
    and add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find a list of players whose name starts with a string. Modify the `PlayerRepository`
    and add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sort the players of a team in ascending order. Modify the `PlayerRepository`
    and add the following repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can decide how to sort the results.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have the option to paginate the results. This means that if the result set
    is extensive, we can divide it into pages and retrieve. The `JpaRepository` already
    provides method overloads to page the results. For instance, the method `findAll`
    can receive a pageable parameter to control how the results should be paged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can add this as parameter in any of the methods using a custom query. For
    instance, we can create the following method in `AlbumsRepository`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can also use JPQL to return aggregated results. For instance, let’s create
    a query to get the number of players in a given position, per team.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the result is not an entity, but just the name of the team and
    the number of players in the position. To return this result we used a custom
    result, implemented as an Interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The interface should have getter methods matching the projected query result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a RESTful controller and a service to use the methods generated. In the
    book’s GitHub repository there is a RESTful API using the repositories created
    in this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the repository you can also find a script to call the RESTful API methods
    created in this recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an application using Spring Data JPA starts, it performs several important
    actions to make it work.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Application Context initialization. It sets up the environment for managing
    Spring components, including the repositories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot scans component and detect repositories. It checks classes annotated
    with `@Repository` and interfaces extending `JpaRepository`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each repository interface, Spring Data JPA generates a concrete implementation
    during runtime. In our scenario, it means that it takes each method defined in
    the repositories and generates the specific queries. At this step it validates
    if it can generate the implementation by using the naming convention, or by using
    the `@Query` annotation. At this step it also validates the queries, so if we
    write an invalid query or it is not capable of generating the implementation from
    the naming convention, it will fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After generating the implementation, it registers them as beans in the application
    context and are now available for the rest of components of our application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One important advantage of JPA and JPQL is that the queries reference the Entities
    we defined in our code, so it can detect a query/entity mapping mismatch early.
    This cannot be achieved when using native queries.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage is that it abstracts the underlaying database. As a developer,
    this is an interesting feature, as it makes the onboarding to a new database faster.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can activate the SQL logging by using `spring.jpa.show-sql` configuration
    variable. It is interesting to check and debug the native queries being generated.
    Keep in mind that it can slow down your application and generate large logs. I
    recommend using this setting only in development.
  prefs: []
  type: TYPE_NORMAL
- en: Using Native Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JPQL is a very powerful mechanism to access relational databases with an abstraction
    of the underlying database. Native Queries refers to executing SQL statements
    directly against the database. Depending on your requirements you might consider
    using Native queries, for instances like:'
  prefs: []
  type: TYPE_NORMAL
- en: Executing complex SQL operations that are not easily expressible in JPQL, for
    instance, queries that involve subqueries or database-specific functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you need to fine-tune the performance of a query, leveraging database-specific
    optimizations, indexes, and hints to improve the query execution time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database-specific features, for instance, the databases that can manage JSON
    structures, may have different ways of doing it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bulk Operations: Native queries are often more efficient for executing bulk
    insert, update, or delete operations on a large number of records, as they bypass
    the overhead of entity management and caching that comes with JPQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that using Native Queries comes with some trade-offs compared to
    JPQL.
  prefs: []
  type: TYPE_NORMAL
- en: '**Type Safety**: As we saw in the previous recipe, JPQL provides type safety,
    which means that query results are returned as strongly typed objects and queries
    are validated during application startup. With native queries, you typically work
    with untyped result sets, which can introduce runtime errors if not handled properly
    and that will come up just when the native query is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native queries can be harder to maintain and refactor because they involve SQL
    strings embedded in your Java code. JPQL queries are more self-contained and easier
    to manage
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Portability**: Native queries are not portable across different database
    systems. If your application needs to support multiple databases, you may need
    to write database-specific queries for each one, and you will need to learn the
    specific differences of each database SQL dialect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we’ll introduce a new feature, match timelines, to our Football
    application. The timeline are all the events that happen during a football match;
    as we don’t want to constrain the content that can be managed as an event, we
    will save part of the information as JSON. PostgreSQL has excellent support for
    JSON, but for most of the scenarios, it is necessary to write native queries.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we don’t need additional tools compared to previous recipes.
    As starting point of this exercise, we will use the completed version of previous
    recipe. If you didn’t complete it, you can find it in the book’s repository at
    https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/. I also prepared
    some scripts to create some sample data for the database. It will be explained
    as part of the recipe steps.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will create a new table managing the match events. That table
    will have a column containing JSON documents.
  prefs: []
  type: TYPE_NORMAL
- en: To create the new table, we will create a new Flyway migration. In folder `src/main/resources/db/migration`
    create a file named `V4__AddMatchEvents.sql` with the following content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additionally, I prepared another migration that you can find in https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/
    named `V4_1__CreateSampleEvents.sql`. This migration inserts events in the `match_events`
    table, so you will be able to play around it. Here you can see an example of match
    event detail:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new entity to manage this table. Create a class named `MatchEventEntity`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will map the JSON content in another class named `MatchEventDetails`. You
    can use other more flexible data structures, such as a Map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `JpaRepository` and name it `MatchEventRepository`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will create a new method in the repository to retrieve all events in a match
    of a given type. The type of event is just an attribute of the JSON content. To
    perform this query, we need to use PostgreSQL specific syntax to query using the
    JSON content. To use Native Queries, we just need to specify in `@Query` annotation
    the attribute `nativeQuery =` `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will implement a repository method to retrieve the events associated with
    a particular football match in which a specified player participated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `PlayerRepository` we will create a method a new method to map the stored
    procedure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now you can create a service and a controller using these repositories. In the
    GitHub repository, I extended the existing controller to call the new repository
    methods. You can also find a script calling the new controller methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we used JSON because it is very useful to store data that can
    be flexible, extensible and it is not required to be as structured as a table,
    with known columns and types. PostgreSQL has a good support for JSON, however
    JPQL support for this kind of scenario is more limited. That is why, you need
    to use Native Queries.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Even if PostgreSQL has very good support for JSON, it is not as optimized as
    it is for regular columns. If there is information in the document that is frequently
    used, it is better to move it to regular columns. PostgreSQL supports indexes
    over JSON properties, you will need to evaluate which is the best approach for
    your specific scenario.
  prefs: []
  type: TYPE_NORMAL
- en: We used `MatchEventDetail` is just a class, not an Entity. In any case, this
    also requires knowing the schema of the JSON data in advance to avoid serialization
    errors. If you need a more flexible approach, you can use just a Map or a String
    to map that column.
  prefs: []
  type: TYPE_NORMAL
- en: JSON support is just an example of a native feature in this case of PostgreSQL,
    but there are other scenarios that you might require using native queries. For
    instance, complex queries that are difficult or not possible to express using
    JPQL, such as subqueries and bulk operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a Native Query is executed, the SQL command itself is not checked by Spring
    Data JPA nor Hibernate, however the resulting execution should be mapped to the
    resulting Entities. Keep that in mind when you write the SQL statements. For instance,
    if in this recipe, we wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'That should match a `List<MatchEventEntity>`. According to our definition of
    `MatchEventEntity`, it expects that the result of the query contains the columns
    *id*, *event_time*, *details* and *match_id*. So be aware of this fact when using
    alias in your queries. As an example, look at the following query, it will result
    in an error in runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: CREATE TABLE users (
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: id SERIAL PRIMARY KEY,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: username VARCHAR(255)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: );
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ALTER TABLE albums ADD COLUMN owner_id INTEGER REFERENCES users(id);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ALTER TABLE cards ADD COLUMN owner_id INTEGER REFERENCES users(id);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ALTER TABLE cards ADD CONSTRAINT cards_album_player_key UNIQUE (album_id, player_id);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@Table(name = "users")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Entity'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public class UserEntity {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Id'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@GeneratedValue(strategy = GenerationType.IDENTITY)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: private Integer id;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: private String username;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@OneToMany(mappedBy = "owner")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: private List<CardEntity> ownedCards;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@OneToMany(mappedBy = "owner")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: private Set<AlbumEntity> ownedAlbums;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@ManyToOne'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@JoinColumn(name = "owner_id")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: private UserEntity owner;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@Table(name = "cards", uniqueConstraints = { @UniqueConstraint(columnNames
    = { "album_id", "player_id" }) })'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Entity'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public class CardEntity {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public interface UserRepository extends JpaRepository<UserEntity, Integer> {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: private UserRepository usersRepository;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public User createUser(String name) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: UserEntity user = new UserEntity();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: user.setUsername(name);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: user = usersRepository.save(user);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return new User(user.getId(), user.getUsername());
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public Album buyAlbum(Integer userId, String title) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: AlbumEntity album = new AlbumEntity();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: album.setTitle(title);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: album.setExpireDate(LocalDate.now().plusYears(1));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: album.setOwner(usersRepository.findById(userId).orElseThrow());
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: album = albumsRepository.save(album);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return new Album(album.getId(), album.getTitle(), album.getOwner().getId());
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public List<Card> buyCards(Integer userId, Integer count) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Random rnd = new Random();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: List<PlayerEntity> players = getAvailablePlayers();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: UserEntity owner = usersRepository.findById(userId).orElseThrow();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: List<CardEntity> cards = Stream.generate(() -> {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CardEntity card = new CardEntity();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: card.setOwner(owner);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: card.setPlayer(players.get(rnd.nextInt(players.size())));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return card;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}).limit(count).toList();'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return cardsRepository.saveAll(cards)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .stream()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .map(card -> new Card(card.getId(), card.getOwner().getId(), Optional.empty(),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: new Player(card.getPlayer().getName(), card.getPlayer().getJerseyNumber(),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: card.getPlayer().getPosition(), card.getPlayer().getDateOfBirth())))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .collect(Collectors.toList());
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: UPDATE cards
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: SET album_id = r.album_id
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: FROM
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (SELECT available.album_id, (SELECT c2.id from cards c2 where c2.owner_id=?1
    AND c2.player_id = available.player_id AND c2.album_id IS NULL LIMIT 1) as card_id
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: FROM
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (SELECT DISTINCT a.id as album_id, c.player_id FROM albums a CROSS JOIN cards
    c WHERE a.owner_id=?1 AND c.owner_id=?1 AND c.album_id IS NULL AND c.player_id
    NOT IN (SELECT uc.player_id from cards uc WHERE uc.album_id = a.id)) available)
    as r
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: WHERE cards.id = r.card_id
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@Modifying'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Query(nativeQuery = true, value = "UPDATE cards " +'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"SET album_id = r.album_id  " + //'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"FROM " + //'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"(SELECT available.album_id, (SELECT c2.id from cards c2 where c2.owner_id=?1
    AND c2.player_id = available.player_id AND c2.album_id IS NULL LIMIT 1) as card_id
    " + //'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"FROM " + //'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"(SELECT DISTINCT a.id as album_id, c.player_id FROM albums a CROSS JOIN cards
    c WHERE a.owner_id=?1 AND c.owner_id=?1 AND c.album_id IS NULL AND c.player_id
    NOT IN (SELECT uc.player_id from cards uc WHERE uc.album_id = a.id)) available)
    as r " +'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"WHERE cards.id = r.card_id " +'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"RETURNING cards.*")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: List<CardEntity> assignCardsToUserAlbums(Integer userId);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@Modifying'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Query(value = "UPDATE CardEntity " +'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '" SET album = null, " +'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '" owner= (SELECT u FROM UserEntity u WHERE u.id=?2) " +'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"WHERE id = ?1 ")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integer transferCard(Integer cardId, Integer userId);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@Transactional'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public Optional<Card> transferCard(Integer cardId, Integer userId) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integer count = cardsRepository.transferCard(cardId, userId);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (count == 0) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return Optional.empty();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@Modifying'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Query(nativeQuery = true, value = "UPDATE cards " +'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"SET owner_id=?2 " +'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '" FROM (select c1.id from cards c1 where c1.owner_id=?1 and c1.album_id IS
    NULL AND c1.player_id IN (select p2.id from players p2 where p2.id NOT IN (SELECT
    c2.player_id FROM cards c2 WHERE c2.owner_id=?2)) LIMIT ?3) cards_from_user1_for_user2
    " +'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"WHERE cards.id = cards_from_user1_for_user2.id " +'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"RETURNING cards.*")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: List<CardEntity> tradeCardsBetweenUsers(Integer userId1, Integer userId2, Integer
    count);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@Service'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public class DynamicQueriesService {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Public List<PlayerEntity> searchTeamPlayers(Integer teamId, Optional<String>
    name, Optional<Integer> minHeight,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Optional<Integer> maxHeight,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Optional<Integer> minWeight, Optional<Integer> maxWeight) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CriteriaBuilder cb = em.getCriteriaBuilder();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CriteriaQuery<PlayerEntity> cq = cb.createQuery(PlayerEntity.class);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Root<PlayerEntity> player = cq.from(PlayerEntity.class);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: List<Predicate> predicates = new ArrayList<>();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: predicates.add(cb.equal(player.get("team").get("id"), teamId));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (name.isPresent()) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: predicates.add(cb.like(player.get("name"), name.get()));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (minHeight.isPresent()) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: predicates.add(cb.ge(player.get("height"), minHeight.get()));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (maxHeight.isPresent()) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: predicates.add(cb.le(player.get("height"), maxHeight.get()));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (minWeight.isPresent()) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: predicates.add(cb.ge(player.get("weight"), minWeight.get()));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (maxWeight.isPresent()) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: predicates.add(cb.le(player.get("weight"), maxWeight.get()));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cq.where(predicates.toArray(new Predicate[0]));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: TypedQuery<PlayerEntity> query = em.createQuery(cq);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return query.getResultList();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public List<MatchEventEntity> searchMatchEventsRange(Integer matchId, Optional<LocalDateTime>
    minTime, Optional<LocalDateTime> maxTime) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: String command = "SELECT e FROM MatchEventEntity e WHERE e.match.id=:matchId
    ";
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (minTime.isPresent() && maxTime.isPresent()) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: command += " AND e.time BETWEEN :minTime AND :maxTime";
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else if (minTime.isPresent()) {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: command += " AND e.time >= :minTime";
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '} else if (maxTime.isPresent()) {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: command += " AND e.time <= :maxTime";
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: TypedQuery<MatchEventEntity> query = em.createQuery(command, MatchEventEntity.class);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: query.setParameter("matchId", matchId);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (minTime.isPresent()) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: query.setParameter("minTime", minTime.get());
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (maxTime.isPresent()) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: query.setParameter("maxTime", maxTime.get());
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return query.getResultList();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public List<PlayerEntity> searchUserMissingPlayers(Integer userId) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Query query = em.createNativeQuery(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"SELECT p1.* FROM players p1 WHERE p1.id NOT IN (SELECT c1.player_id FROM cards
    c1 WHERE c1.owner_id=?1)",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: PlayerEntity.class);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: query.setParameter(1, userId);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return query.getResultList();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public void deleteEventRange(Integer matchId, LocalDateTime start, LocalDateTime
    end) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: em.getTransaction().begin();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Query query = em.createQuery("DELETE FROM MatchEventEntity e WHERE e.match.id=:matchId
    AND e.time BETWEEN :start AND :end");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: query.setParameter("matchId", matchId);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: query.setParameter("start", start);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: query.setParameter("end", end);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: query.executeUpdate();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: em.getTransaction().commit();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Integer potentialUser1ToUser2 = cardsRepository.countMatchBetweenUsers(userId1,
    userId2);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integer potentialUser2ToUser1 = cardsRepository.countMatchBetweenUsers(userId2,
    userId1);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integer count = Math.min(potentialUser1ToUser2, potentialUser2ToUser1);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: ArrayList<CardEntity> result = new ArrayList<>(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cardsRepository.tradeCardsBetweenUsers(userId1, userId2, count));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useAllCardAvailable(userId2);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: result.addAll(cardsRepository.tradeCardsBetweenUsers(userId2, userId1, count));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useAllCardAvailable(userId1);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@Transactional'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public List<Card> tradeAllCards(Integer userId1, Integer userId2) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integer potentialUser1ToUser2 = cardsRepository.countMatchBetweenUsers(userId1,
    userId2);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integer potentialUser2ToUser1 = cardsRepository.countMatchBetweenUsers(userId2,
    userId1);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integer count = Math.min(potentialUser1ToUser2, potentialUser2ToUser1);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (count > 0) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ArrayList<CardEntity> result = new ArrayList<>(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cardsRepository.tradeCardsBetweenUsers(userId1, userId2, count));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useAllCardAvailable(userId2);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: result.addAll(cardsRepository.tradeCardsBetweenUsers(userId2, userId1, count));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useAllCardAvailable(userId1);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: ArrayList<CardEntity> result1 = new ArrayList<>(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cardsRepository.tradeCardsBetweenUsers(userId1, userId2, count));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useAllCardAvailable(userId2);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ArrayList<CardEntity> result2 = new ArrayList<>(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cardsRepository.tradeCardsBetweenUsers(userId2, userId1, count));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useAllCardAvailable(userId1);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (result1.size() != result2.size()) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: throw new RuntimeException("Users have different number of cards");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@Transactional(isolation = Isolation.SERIALIZABLE)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public List<Card> tradeAllCards(Integer userId1, Integer userId2) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integer potentialUser1ToUser2 = cardsRepository.countMatchBetweenUsers(userId1,
    userId2);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integer potentialUser2ToUser1 = cardsRepository.countMatchBetweenUsers(userId2,
    userId1);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integer count = Math.min(potentialUser1ToUser2, potentialUser2ToUser1);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (count > 0) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ArrayList<CardEntity> result1 = new ArrayList<>(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cardsRepository.tradeCardsBetweenUsers(userId1, userId2, count));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useAllCardAvailable(userId2);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ArrayList<CardEntity> result2 = new ArrayList<>(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cardsRepository.tradeCardsBetweenUsers(userId2, userId1, count));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useAllCardAvailable(userId1);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@Transactional(propagation = Propagation.REQUIRES_NEW)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: em.getTransaction().begin();
  prefs: []
  type: TYPE_NORMAL
- en: // do your changes
  prefs: []
  type: TYPE_NORMAL
- en: em.getTransaction().commit();
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: em.getTransaction().begin();
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: em.getTransaction().commit();
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (Exception e) {'
  prefs: []
  type: TYPE_NORMAL
- en: em.getTransaction().rollback();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
