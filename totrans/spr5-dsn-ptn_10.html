<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Implementing the MVC Pattern in a Web Application using Spring</h1>
                </header>
            
            <article>
                
<p>In the last couple of chapters in the book, we have seen that all examples were based on a standalone application using the Spring Framework. We have seen how Spring works to provide important features, such as the dependency injection pattern, bean life cycle management, AOP, cache management, and Spring, in the backend using the JDBC and ORM modules. In this chapter, we will see how Spring works in the web environment to address some common problems of any web application, such as workflow, validations, and state management.</p>
<p>Like other modules in the Spring Framework, Spring has introduced its own web framework, known as Spring Web MVC. It is based on the <strong>Model-View-Controller</strong> (<strong>MVC</strong>) pattern. Spring Web MVC supports the presentation tier, and helps you to build a flexible and loosely coupled web-based application. The Spring MVC module addresses the problem of testing the web components in the enterprise application. It allows you to write the test case without using request and response objects in the application. Here, we will discuss more about it.</p>
<p>In this chapter, we will not only discuss the internals of Spring MVC, but also about the different layers of a web application. We will see here the implementation of the MVC pattern including what it is, and why we should use it. We will explore the following topics in this chapter about Spring's MVC web framework:</p>
<ul>
<li>Implementing MVC patterns on a web application</li>
<li>Implementing controllers patterns</li>
<li>Configuring <kbd>DispatcherServlet</kbd> as the Front Controller pattern</li>
<li>Enabling Spring MVC and proxying</li>
<li>Accepting request parameters</li>
<li>Processing the forms of a web page</li>
<li>Implementing a view in the MVC pattern</li>
<li>Creating JSP views in a web application</li>
<li>The View Helper pattern</li>
<li>The Composite View pattern with Apache Tiled ViewResolver</li>
</ul>
<p>Let's look at all the aforementioned topics in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the MVC pattern in a web application</h1>
                </header>
            
            <article>
                
<p>The <strong>Model View Controller pattern</strong> (<strong>MVC pattern</strong>) is a J2EE design pattern. It was first introduced by Trygve Reenskaug in his own project to separate the different components of the application. That time, he used this pattern on a desktop-based application. The main approach of this pattern is to promote the separation of concerns principle of the software industry. The MVC pattern divides the system into three kinds of components. Each component in the system has specific responsibilities. Let's see these three components of this pattern:</p>
<ul>
<li><strong>Model</strong>: The model in the MVC pattern is responsible for maintaining data for the view so that it can be rendered in any view template. In short, we can say that the model is a data object, such as a <kbd>SavingAccount</kbd> in the banking system, and list of accounts of a branch of any bank.</li>
<li><strong>View</strong>: The view in the MVC pattern is responsible for rendering the model to itself in a web application for representation of a page. It presents the data of the model in a readable format to the user. There are several technologies that provide the view, such as JSP, JSF page, PDF, XML, and so on.</li>
<li><strong>Controller</strong>: This is an actual actionable component in the MVC pattern. In Software, the controller code controls the interaction between the view and model. Interactions such as form submission or clicking a link are part of the controller in an enterprise application. The controller is also responsible for creating and updating the model, and forwarding this model to the view for rendering.</li>
</ul>
<p>Take a look at the following diagram to understand more about the MVC pattern:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="213" width="362" class=" image-border" src="assets/6ba5f771-d7c8-414e-9d30-a4a4234e7074.png"/></div>
<p>As you can see in the preceding diagram, there are three components in an application, and each component has its own responsibility. As we've already said, the MVC pattern is all about separation of concerns. In a software system, separation of concerns is very important to make the components flexible and easy to test with a clean code structure. In the MVC pattern, the <strong>User</strong> interacts with the <strong>Controller</strong> component through the <strong>View</strong> component, and the <strong>Controller</strong> component triggers the actual action to prepare the <strong>Model</strong> component. That <strong>Model</strong> component propagates the changes to the <strong>View</strong>, and finally, the <strong>View</strong> component renders the model in front of the <strong>User</strong>. This is the whole idea behind the implementation of the MVC pattern. This approach of MVC pattern properly fits most of the applications, especially, desktop applications. This MVC pattern is also known as Model 1 architecture.</p>
<p>But in case you are working with an enterprise web application, things will be slightly different from a desktop application, because keeping a model across the request life cycle can be quite difficult due to the stateless nature of an HTTP protocol. Let's see another modified version of the MVC pattern in the following section, and how the Spring framework adopts it to create the enterprise web application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Model 2 architecture MVC pattern with Spring</h1>
                </header>
            
            <article>
                
<p>The Model 1 architecture is not very straightforward for a web application. Model 1 also has decentralized navigation control, because in this architecture, each user contains a separate controller and also different logic to determine the next page. That time for web application, Model 1 architecture has Servlet and JSP as the main technologies to develop the web applications.</p>
<p>For a web application, the MVC pattern is implemented as a Model 2 architecture. This pattern provides centralized navigation control logics to easily test and maintain the web application, and it also provides better separation of concerns than Model 1 architecture for web applications. The difference between the MVC pattern based on Model 1 Architecture and the modified MVC pattern based on Model 2 architecture is that the latter incorporates a front controller that dispatches all incoming requests to other controllers. These controllers handle the incoming request, return the model, and select the view. take a look at the following diagram to better understand the Model 2 architecture MVC pattern:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="219" width="388" class=" image-border" src="assets/e6d0343e-df2f-4f7e-91fd-8c64d9f3a48e.png"/></div>
<p>As you can see in the preceding diagram, a new component is introduced for the MVC pattern, that is, the front controller. It is implemented as a <kbd>javax.servlet.Servlet</kbd> servlet such as <kbd>ActionServlet</kbd> in struts, <kbd>FacesServlet</kbd> in JSF, and <kbd>DispatcherServlet</kbd> in Spring MVC. It handles the incoming requests, and delegates the requests to the specific application controller. That application controller creates and updates the model, and delegates it to the front controller for rendering. Finally, the <strong>Front Controller</strong> determines the specific view, and renders that model data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Front Controller design pattern</h1>
                </header>
            
            <article>
                
<p>The Front Controller design pattern is a J2EE pattern; it provides solutions for the following application design problems:</p>
<ul>
<li>In a web application based on the Model 1 architecture, too many controllers are required to handle too many requests. It is difficult to maintain and reuse them.</li>
<li>Each request has its own point of entry in the web application; it should be a single point of entry for each request.</li>
<li>JSP and Servlet are the main components of the Model 1 MVC pattern, so, these components handle both action and view, violating the <em>Single Responsibility</em> principle.</li>
</ul>
<p>The Front Controller provides the solution to the aforementioned design problems of the web application. In a web application, it works as the main component which routes all requests into framework control. This means that too many requests land on a single controller (Front Controller), and then, these requests are delegated to the specific controllers. Front Controller provides centralized control, and improves the reusability and manageability, because, typically, only the resource is registered with the web container. This controller not only handles too many requests, but also has following responsibilities:</p>
<ul>
<li>It initializes the framework to cater to the requests</li>
<li>It loads the map of all URLs and the components responsible for handling the request</li>
<li>It prepares the map for the views</li>
</ul>
<p>Let's see the following diagram for <strong>Front Controller</strong>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="178" width="389" src="assets/699d8a8c-7cdb-402f-8a07-9b072be15c68.jpg"/></div>
<p>As you can see in the preceding diagram, all application requests land at the <strong>Front Controller</strong>, and it delegates these requests to the configured application controllers.</p>
<p>The Spring Framework provides a module based on the MVC pattern, that is, Model 2 architecture implementation. The Spring MVC module provides out-of-the-box front controller pattern implementation by introducing the <kbd>org.springframework.web.servlet.DispatcherServlet</kbd> class. This is a simple <kbd>servlet</kbd> class, and the backbone of the Spring MVC framework. And this Servlet is integrated with the Spring IoC container to benefit the Spring's dependency pattern. Spring's web framework uses Spring for its own configuration, and all controllers are Spring beans; these controllers are testable artifacts.</p>
<p>Let's dive into the internals of Spring MVC in this Chapter, and have a closer look at <kbd>org.springframework.web.servlet.DispatcherServlet</kbd> in the Spring MVC framework, and how it handles all incoming requests to the web application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Processing the life of a request</h1>
                </header>
            
            <article>
                
<p>Have you ever played a <em>wooden labyrinth board game, a maze puzzle with a steel ball bearing</em>? You might have played it in your childhood. It was a very crazy game. The goal of this game is to send all the steel ball bearings to the center of the wooden labyrinth board through interlinked curvy paths, and these curvy paths have cuts leading to a second curve near the center. All the balls need to navigate to the center of the wooden labyrinth board through these cuts between the curvy paths. If one steel ball reaches the center, then we have to be careful about this ball so that it does not move away from the center when trying to move another ball to the center. You can see this in the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="201" width="291" class=" image-border" src="assets/5c9421b7-9fbb-4547-909c-fd02a540e216.png"/></div>
<p>The Spring MVC framework is similar to this Wooden Labyrinth board game at first glance. Instead of the moving the steel ball bearings through various curvy paths and cuts, the Spring MVC framework moves web application requests through various components such as the Front Controller, that is, the dispatcher Servlet, handler mappings, controllers, and view resolvers.</p>
<p>Let's see the request processing flow in the Spring MVC Framework for a web application. The request processing workflow of the Spring Web MVC <kbd>DispatcherServlet</kbd> is illustrated in the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/5a0220b4-5457-4167-b2ac-809ee99cb479.png"/></div>
<p>As you already know, the front controller plays a very important role in the Model 2 MVC pattern, because it has the responsibility to handle all incoming requests to the web application, and prepare the response to the browser. In the Spring MVC framework, <kbd>org.springframework.web.servlet.DispatcherServlet</kbd> plays the role of the Front Controller of the Model 2 MVC pattern. As you can see in the last diagram, this <kbd>DispatcherServlet</kbd> uses many other components to fulfill its own role. Let's see the step-by-step request processing in the Spring MVC framework:</p>
<ol>
<li>A user clicks on the browser or submits a web form of the application. The request leaves the browser, either with some additional information or with common information. This request lands at Spring's <kbd>DispatcherServlet</kbd>, which is a simple <kbd>servlet</kbd> class as other java-based web applications. It is a Front Controller of the Spring MVC framework, and funnels all the incoming requests through the single point. The Spring MVC framework centralizes the request flow control by using this Front Controller.</li>
<li>After landing a request at Spring's <kbd>DispatcherServlet</kbd>, it delegates that request to the Spring MVC controller, that is, application controller. Although, , there may be several controllers in a Spring web application, but each request must be delegated to the specific controller. For that, Spring's <kbd>DispatcherServlet</kbd> takes help of the handler mappings configured in the web application. Handler mapping decides the particular controller by using the URL and request parameters.</li>
<li>Once a particular application controller is decided by Spring's <kbd>DispatcherServlet</kbd> with the help of the handler mapping configuration, <kbd>DispatcherServlet</kbd> dispatches that request to the selected controller. This is the actual controller responsible for processing information according to the user's request and its parameters.</li>
<li>Spring MVC's controller executes the business logic by using business services of the application, and it creates the model which wraps the information to be carried back to the user, and is displayed in the browser. This model carries information according to the user's request. But this model is not formatted, and we can use any view template technology to render the model information in the browser. That is why Spring MVC's controller also returns a logic view name along with the model. Why does it return a logic view name? This is because Spring MVC's controller is not tied to any specific view technology such as JSP, JSF, Thymeleaf, and so on.</li>
</ol>
<ol start="5">
<li>Once again, Spring MVC's <kbd>DispatcherServlet</kbd> takes the help of the view resolver; it is configured in the web application to resolve the view. According to the configured <kbd>ViewResolver</kbd>, it resolves the actual view name instead of the logic view name. Now <kbd>DispatcherServlet</kbd> has the view as well to render the model information.</li>
<li>Spring MVC's <kbd>DispatcherServlet</kbd> renders the model to the view, and generates a user-readable format of the model's information.</li>
<li>Finally, that information creates a response, and returns it to the user's browser by <kbd>DispatcherServlet</kbd>.</li>
</ol>
<p>As you can see, there are several steps and components involved in serving a request of the application. Most of these components are related to the Spring MVC framework, and these components have their own specific responsibility to serve a request.</p>
<p>Till now, you have learned that <kbd>DispatcherServlet</kbd> is a key component in processing requests with Spring MVC. It is the heart of the Spring Web MVC. It is a front controller that coordinates all request handling activities analogous to Struts <kbd>ActionServlet</kbd> / JSF <kbd>FacesServlet</kbd>. It delegates to the web infrastructure beans, and invokes user web components. It is also highly flexible, configurable, and fully customizable. It is very flexible, because all the components used by this servlet are interfaces for all the infrastructure beans. The following table lists some of the involved interfaces provided by the Spring MVC Framework:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Spring MVC Component</strong></p>
</td>
<td>
<p><strong>Role in request processing</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>org.springframework.web.multipart.MultipartResolver</kbd></p>
</td>
<td>
<p>It handles multipart requests such as file uploads</p>
</td>
</tr>
<tr>
<td>
<p><kbd>org.springframework.web.servlet.LocaleResolver</kbd></p>
</td>
<td>
<p>It handles locale resolution and modification</p>
</td>
</tr>
<tr>
<td>
<p><kbd>org.springframework.web.servlet.ThemeResolver</kbd></p>
</td>
<td>
<p>It handles theming resolution and modification</p>
</td>
</tr>
<tr>
<td>
<p><kbd>org.springframework.web.servlet.HandlerMapping</kbd></p>
</td>
<td>
<p>It maps all incoming requests to the handler objects.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>org.springframework.web.servlet.HandlerAdapter</kbd></p>
</td>
<td>
<p>It is based on the Adapter pattern, and is used for the handler object type to execute the handler</p>
</td>
</tr>
<tr>
<td>
<p><kbd>org.springframework.web.servlet.HandlerExceptionResolver</kbd></p>
</td>
<td>
<p>It handles the exceptions thrown during handler execution</p>
</td>
</tr>
<tr>
<td>
<p><kbd>org.springframework.web.servlet.ViewResolver</kbd></p>
</td>
<td>
<p>It translates the logical view name to an actual view implementation</p>
</td>
</tr>
</tbody>
</table>
<p>Â </p>
<p>The components listed in the preceding table work on the Spring MVC Framework for the request processing life cycle in a web application. In the upcoming section, we'll see how to configure the Spring MVC's main component, that is, <kbd>DispatcherServlet</kbd>. We'll also take a closer look at the different ways of implementation and configuration based on either Java or XML.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring DispatcherServlet as the Front Controller</h1>
                </header>
            
            <article>
                
<p>In a Java-based web application, all servlets are defined in the <kbd>web.xml</kbd> file. It is loaded in a web container at the bootstrap, and maps each servlet to a particular URL pattern. Similarly, the <kbd>org.springframework.web.servlet.DispatcherServlet</kbd> is the centerpiece of the Spring MVC; it needs to be configured in the same file--<kbd>web.xml</kbd>, and it is loaded at the bootstrap of the web application. At the time of bootstrapping, <kbd>DispatcherServlet</kbd> is invoked to create Spring's <kbd>org.springframework.web.context.WebApplicationContext</kbd> by loading the beans' configuration through Java, XML, or annotation-based. The servlet tries to fetch all the required components from this web application context. It has the responsibility to route the request through all the other components.</p>
<div class="packt_infobox"><kbd>WebApplicationContext</kbd> is a web version of the <kbd>ApplicationContext</kbd>, as discussed in previous chapters of this book. It has some additional capabilities necessary for web applications other than the <kbd>ApplicationContext</kbd>, such as servlet-specific scope request, session, and so on. The <kbd>WebApplicationContext</kbd> is bound in the <kbd>ServletContext</kbd>; you can also access it by using the static method of the <kbd>RequestContextUtils</kbd> class. Let's see the following code snippet for this:<br/>
<kbd>ApplicationContext webApplicationContext = RequestContextUtils.findWebApplicationContext(request);</kbd></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defined by XML configuration</h1>
                </header>
            
            <article>
                
<p>As you know, <kbd>web.xml</kbd> is the root file of any web application, placed in the <kbd>WEB-INF</kbd> directory. It has a servlet specification, and contains all the servlet configuration to be bootstrapped. Let's see the required code of the <kbd>DispatcherServlet</kbd> configuration in the web application, which is as follows:</p>
<pre>    &lt;web-app version="3.0" 
     
     
    xsi:schemaLocation=http://java.sun.com/xml/ns/javaee 
    http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd      
    metadata-complete="true"&gt; 
      &lt;servlet&gt; 
         &lt;servlet-name&gt;bankapp&lt;/servlet-name&gt; 
         &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; 
         &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 
      &lt;/servlet&gt; 
      &lt;servlet-mapping&gt; 
         &lt;servlet-name&gt;bankapp&lt;/servlet-name&gt; 
         &lt;url-pattern&gt;/*&lt;/url-pattern&gt; 
      &lt;/servlet-mapping&gt; 
   &lt;/web-app&gt; </pre>
<p>The preceding code is the minimum required code to configure the <kbd>DispatcherServlet</kbd> in a Spring web application using XML-based configuration.</p>
<div class="packt_infobox">There is nothing is special in the <kbd>web.xml</kbd> file; typically, it defines only one servlet configuration very similar to the traditional Java web application. But DispatcherServlet loads a file which contains the spring beans configuration for the application. By default, it loads a file named <kbd>[servletname]-servlet.xml</kbd> from the WEB-INF directory. In our case, the file name should be <kbd>bankapp-servlet.xml</kbd> in the WEB-INF directory.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defined by Java configuration</h1>
                </header>
            
            <article>
                
<p>In this chapter, instead of the XML configuration, we will use Java to configure <kbd>DispatcherServlet</kbd> in the servlet container for our web application. Servlet 3.0 and later supports java-based bootstrapping, so, we can avoid using the web.xml file. Instead of this, we can create a java class that implements the <kbd>javax.servlet.ServletContainerInitializer</kbd> interface. Spring MVC provides the <kbd>WebApplicationInitializer</kbd> interface to ensure that your spring configuration is loaded and initialized in any Servlet 3 container. But the Spring MVC framework makes it even easier by providing an abstract class implementation of the <kbd>WebApplicationInitializer</kbd> interface. By using this abstract class, you just map your servlet mapping, and provide the root and MVC configuration classes. I, personally, prefer this way of configuration in my web application. The following is the code for this configuration class:</p>
<pre>    package com.packt.patterninspring.chapter10.bankapp.web; 
 
    import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer; 
 
    import com.packt.patterninspring.chapter10.bankapp.config.AppConfig; 
    import com.packt.patterninspring.chapter10.bankapp.web.mvc.SpringMvcConfig; 
 
    public class SpringApplicationInitilizer extends AbstractAnnotationConfigDispatcherServletInitializer<br/>    { 
     // Tell Spring what to use for the Root context: as ApplicationContext - "Root" configuration 
      @Override 
      protected Class&lt;?&gt;[] getRootConfigClasses() { 
         return new Class &lt;?&gt;[]{AppConfig.class}; 
      } 
     // Tell Spring what to use for the DispatcherServlet context: WebApplicationContext- MVC <br/>     configuration 
     @Override 
     protected Class&lt;?&gt;[] getServletConfigClasses() { 
         return new Class &lt;?&gt;[]{SpringMvcConfig.class}; 
     } 
    
     // DispatcherServlet mapping, this method responsible for URL pattern as like in web.xml file <br/>     &lt;url-pattern&gt;/&lt;/url-pattern&gt; 
     @Override 
     protected String[] getServletMappings() { 
         return new String[]{"/"}; 
     } 
    } </pre>
<p>As seen in the preceding code, the <kbd>SpringApplicationInitializer</kbd> class extends the <kbd>AbstractAnnotationConfigDispatcherServletInitializer</kbd> class. It asks only the required information from the developer, and all configurations related to the <kbd>DispatcherServlet</kbd> are configured by this class using the servlet container interfaces. Take a look at the following diagram to understand more about the <kbd>AbstractAnnotationConfigDispatcherServletInitializer</kbd> class and its implementation to configure the <kbd>DispatcherServlet</kbd> in the application:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="225" width="425" class=" image-border" src="assets/523eec9d-ebde-4091-84cc-2153ce838e82.png"/></div>
<p>You have seen that the <kbd>SpringApplicationInitilizer</kbd> class overrides three methods of the <kbd>AbstractAnnotationConfigDispatcherServletInitializer</kbd> class, that is, <kbd>getServletMappings()</kbd>, <kbd>getServletConfigClasses()</kbd>, and <kbd>getRootConfigClasses()</kbd>. The method <kbd>getServletMappings()</kbd> defines the servlet mapping-in our application, it's mapped to "<kbd>/</kbd>"<strong>.</strong> The method <kbd>getServletConfigClasses()</kbd> asks <kbd>DispatcherServlet</kbd> to load its application context with the beans defined in the <kbd>SpringMvcConfig</kbd> configuration class. This configuration file has bean definitions related to the web components such as controllers, view resolvers, and handler mappings. A Spring web application has another application context, and it is created by <kbd>ContextLoaderListener</kbd>. So, another method, <kbd>getRootConfigClasses()</kbd>, loads the other beans such as services, repositories, data-source, and other application beans typically required in the middle-tier and data-tier of the application defined in the <kbd>AppConfig</kbd> configuration class.</p>
<div class="packt_infobox">The Spring Framework provides a listener class--<kbd>ContextLoaderListener</kbd>. It is responsible for bootstrapping the backend application context.</div>
<p>Let's see the following diagram to understand more about the Spring web application design after starting up the servlet container:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="253" width="440" class=" image-border" src="assets/6f968668-e514-4a7e-bcdd-ca0f6ae6629c.png"/></div>
<p>As you can see in the last diagram, the web component beans definitions configuration classes returned by the <kbd>getServletConfigClasses()</kbd> method are loaded by the <kbd>DispatcherServlet</kbd>, and the other application beans definition configuration classes returned by the <kbd>getRootConfigClasses()</kbd> method are loaded by the <kbd>ContextLoaderListener</kbd>.</p>
<div class="packt_infobox">A Java-based web configuration will only work when deploying to a server that supports <strong>Servlet 3.0</strong>, such as <strong>Apache Tomcat 7 or higher.</strong></div>
<p>Let's see how to enable more features of the Spring MVC Framework in the coming section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling the Spring MVC</h1>
                </header>
            
            <article>
                
<p>There are many ways to configure the <kbd>DispatcherServlet</kbd> and other web components. There are many features of the Spring MVC framework which are not enabled by default, such as <kbd>HttpMessageConverter</kbd>, Support for validating <kbd>@Controller</kbd> inputs with <kbd>@Valid</kbd>, and so on. So, we can enable these features by using either a Java-based configuration or XML configuration.</p>
<p>To enable the MVC Java config, add the annotation <kbd>@EnableWebMvc</kbd> to one of your <kbd>@Configuration</kbd> classes, as follows:</p>
<pre> import org.springframework.context.annotation.Configuration; 
    import org.springframework.web.servlet.config.annotation.EnableWebMvc; 
    @Configuration 
    @EnableWebMvc 
    public class SpringMvcConfig { 
    } </pre>
<p>In XML configuration, we can use MVC namespace, there is an <kbd>&lt;mvc:annotation-driven&gt;</kbd> element that you can use to enable the annotation-driven Spring MVC.</p>
<pre>    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;beans  
     
     
    xsi:schemaLocation=" 
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd 
        http://www.springframework.org/schema/mvc 
        http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; 
 
    &lt;mvc:annotation-driven/&gt; 
 
    &lt;/beans&gt; </pre>
<p>The Spring MVC advanced feature can be enabled in a Spring web application either by using the <kbd>@EnableWebMvc</kbd> annotation, or by using the XML namespace <kbd>&lt;mvc:annotation-driven/&gt;</kbd>. The Spring MVC Framework also allows you to customize the default configuration in Java by extending the <kbd>WebMvcConfigurerAdapter</kbd> class, or by implementing the <kbd>WebMvcConfigurer</kbd> interface. Let's see the modified configuration file after adding a bit more configuration:</p>
<pre>    package com.packt.patterninspring.chapter10.bankapp.web.mvc; 
 
    import org.springframework.context.annotation.Bean; 
    import org.springframework.context.annotation.ComponentScan; 
    import org.springframework.context.annotation.Configuration; 
    import org.springframework.web.servlet.ViewResolver; 
    import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer; 
    import org.springframework.web.servlet.config.annotation.EnableWebMvc; 
    import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter; 
    import org.springframework.web.servlet.view.InternalResourceViewResolver; 
 
    @Configuration 
    @ComponentScan(basePackages = {" com.packt.patterninspring.chapter10.bankapp.web.controller"})   
    @EnableWebMvc 
    public class SpringMvcConfig extends WebMvcConfigurerAdapter{ 
    
    @Bean 
    public ViewResolver viewResolver(){ 
         InternalResourceViewResolver viewResolver = new InternalResourceViewResolver(); 
         viewResolver.setPrefix("/WEB-INF/view/"); 
         viewResolver.setSuffix(".jsp"); 
         return viewResolver; 
    } 
    
    @Override 
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { 
         configurer.enable(); 
    } 
    
   }</pre>
<p>As seen in the preceding code, the configuration class <kbd>SpringMvcConfig</kbd> is annotated with <kbd>@Configuration</kbd>, <kbd>@ComponentScan</kbd>, and <kbd>@EnableWebMvc</kbd>. Here, the <kbd>com.packt.patterninspring.chapter10.bankapp.web.controller</kbd> package will be scanned for components. This class extends the <kbd>WebMvcConfigurerAdapter</kbd> class, and overrides the <kbd>configureDefaultServletHandling()</kbd> method. We have also configured a <kbd>ViewResolver</kbd> bean.</p>
<p>Till now, you have learned what is the MVC pattern and architecture, and how to set up <kbd>DispatcherServlet</kbd> and enable the essential Spring MVC components for a Spring web application. In the upcoming section, we'll discuss how to implement controllers in a Spring application, and how these controllers handle web requests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing controllers</h1>
                </header>
            
            <article>
                
<p>As we have seen in the MVC pattern, controllers are also one of the crucial components of the MVC pattern. They are responsible for executing the actual request, preparing the model, and sending this model along with logical view name to the front controller. In a web application, the controllers work between the web layer and the core application layer. In the Spring MVC framework, controllers are also more like POJO classes with methods; these methods are known as handlers, because these are annotated with the <kbd>@RequestMapping</kbd> annotation. Let's see how to define controller classes in a Spring web application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining a controller with @Controller</h1>
                </header>
            
            <article>
                
<p>Let's create a controller class for our bank application. <kbd>HomeController</kbd> is a controller class that handles requests for <kbd>/</kbd> and renders the homepage of the bank application:</p>
<pre>    package com.packt.patterninspring.chapter10.bankapp.web.controller; 
 
    import org.springframework.stereotype.Controller; 
    import org.springframework.web.bind.annotation.RequestMapping; 
    import org.springframework.web.bind.annotation.RequestMethod; 
 
    @Controller 
    public class HomeController { 
    
      @RequestMapping(value = "/", method = RequestMethod.GET) 
      public String home (){ 
         return "home"; 
     } 
   } </pre>
<p>As you can see in the preceding code, the <kbd>HomeController</kbd> class contains the <kbd>home()</kbd> method. It is a handler method, because it is annotated with the <kbd>@RequestMapping</kbd> annotation. It specifies that this method handles all the requests that are mapped to the <kbd>/</kbd> URL. Another thing to notice is that our controller class, <kbd>HomeController</kbd>, is also annotated with the <kbd>@Controller</kbd> annotation. As we know, <kbd>@Controller</kbd> is a stereotype annotation, and it is also used to create the bean in the Spring IoC container similar to the other Meta annotations of the <kbd>@Component</kbd> annotation such as <kbd>@Service</kbd> and <kbd>@Repository.</kbd> Yes, this annotation specifies any class as the controller, and adds some more capability of Spring MVC to that class. You could also use the <kbd>@Component</kbd> annotation instead of <kbd>@Controller</kbd> to create Spring beans in a web application, but in this case, that bean does not have the capability of the Spring MVC framework such as exception handling at web layer, handler mapping, and so on.</p>
<p>Let's take a closer look at the <kbd>@RequestMapping</kbd> annotation, and also the composed variants of the <kbd>@RequestMapping</kbd> annotation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mapping requests with @RequestMapping</h1>
                </header>
            
            <article>
                
<p>The previously defined <kbd>HomeController</kbd> class has only one handler method, and this method is annotated with the <kbd>@RequestMapping</kbd> annotation. Here, I have used two attributes of this annotation--one is value to map the HTTP request to the <kbd>/</kbd> pattern, and the other attribute is a method for supporting the HTTP <kbd>GET</kbd> method. We can define multiple URL mappings with one handler method. Let's see this in the following code snippet:</p>
<pre>    @Controller 
    public class HomeController { 
    
     @RequestMapping(value = {"/", "/index"}, method = RequestMethod.GET) 
     public String home (){ 
         return "home"; 
    } 
   } </pre>
<p>In the preceding code, the <kbd>@RequestMapping</kbd> annotation has an array of string values for the value attribute of this annotation. Now, this handler method is mapped with two URL patterns, such as <kbd>/</kbd> and <kbd>/index</kbd>. The Spring MVC's <kbd>@RequestMapping</kbd> annotation supports several HTTP methods such as <kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd>, <kbd>DELETE</kbd>, and so on. As of version 4.3, Spring composed <kbd>@RequestMapping</kbd> variants, and now provides simple methods for the mapping of common HTTP methods, as shown in the following expressions:</p>
<pre>    @RequestMapping + HTTP GET = @GetMapping 
    @RequestMapping + HTTP POST = @PostMapping 
    @RequestMapping + HTTP PUT = @PutMapping 
    @RequestMapping + HTTP DELETE = @DeleteMapping </pre>
<p>This is the modified version of <kbd>HomeController</kbd> with composed annotation mappings:</p>
<pre>    @Controller 
    public class HomeController { 
    
      @GetMapping(value = {"/", "/index"}) 
      public String home (){ 
         return "home"; 
      } 
   } </pre>
<p>We can use the <kbd>@RequestMapping</kbd> annotation at both locations: at the class level, and at the method level. Let's see examples for this:</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">@RequestMapping at method level</h1>
                </header>
            
            <article>
                
<p>Spring MVC allows you to use the <kbd>@RequestMapping</kbd> annotation at the method level to make this method as handler method in the Spring web application. Let's see how to use it in the following class:</p>
<pre><span>     package com.packt.patterninspring.<br/>       chapter10.bankapp.web.controller;</span> 
     import org.springframework.stereotype.Controller; 
     import org.springframework.ui.ModelMap; 
     import org.springframework.web.bind.annotation.RequestMapping; 
     import org.springframework.web.bind.annotation.RequestMethod; 
 
     import com.packt.patterninspring.chapter10.bankapp.model.User; 
 
     @Controller 
     public class HomeController { 
    
      @RequestMapping(value = "/", method = RequestMethod.GET) 
      public String home (){ 
         return "home"; 
      } 
    
      @RequestMapping(value = "/create", method = RequestMethod.GET) 
      public String create (){ 
         return "addUser"; 
      } 
    
      @RequestMapping(value = "/create", method = RequestMethod.POST) 
      public String saveUser (User user, ModelMap model){ 
         model.put("user", user); 
         return "addUser"; 
      } 
    } </pre>
<p>As you can see in the preceding code, I have used the <kbd>@RequestMapping</kbd> annotation with three methods <kbd>home()</kbd>, <kbd>create()</kbd>, and <kbd>saveUser()</kbd>. Here I have also used the attributes "value" and "method" of this annotation. The "value" attribute has the request mapping with request URL and "method" attribute is used to define the HTTP request methods such GET or POST. Mapping rules are, typically, URL-based, and, optionally, use wild cards, as shown here:</p>
<pre>    - /create 
    - /create/account 
    - /edit/account 
    - /listAccounts.htm - Suffix ignored by default. 
    - /accounts/* </pre>
<p>In the preceding example, the handler methods have some arguments as well, so we can pass any number of arguments of any type. The Spring MVC will handle these arguments as request parameters. Let's see first how to define <kbd>@RequestMapping</kbd> at the class level, then we will discuss the request parameters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">@RequestMapping at the class level</h1>
                </header>
            
            <article>
                
<p>The Spring MVC allows you to use the <kbd>@RequestMapping</kbd> annotation at the class level. This means we can annotate the controller class with <kbd>@RequestMapping</kbd>, as shown in the following code snippet:</p>
<pre>    package com.packt.patterninspring.chapter10.bankapp.web.controller; 
 
    import org.springframework.stereotype.Controller; 
    import org.springframework.ui.ModelMap; 
    import org.springframework.web.bind.annotation.RequestMapping; 
    import org.springframework.web.bind.annotation.RequestMethod; 
 
    @Controller 
    @RequestMapping("/") 
    public class HomeController { 
    
     @RequestMapping(method=GET) 
     public String home() { 
         return "home"; 
     } 
   } </pre>
<p>As you have seen in the preceding code, the <kbd>HomeController</kbd> class is annotated with the <kbd>@RequestMapping</kbd> and <kbd>@Controller</kbd> annotations. But the HTTP method is still defined above the handler methods. Class-level mapping is applied with all the handler methods defined under this controller.</p>
<p>After the Spring MVC configuration, we created a controller class with the handler methods. Let's test this controller before moving ahead with more details. In this book, I haven't use any JUnit test cases, so here, I will just run this web application on the Tomcat container. You can see the output on the browser as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="171" width="278" class=" image-border" src="assets/f4c6014d-f22c-4a85-91a5-0799fb2c7d8b.png"/></div>
<p>The last image is the homepage of our <strong>Bank Management System</strong> web application.</p>
<div class="packt_infobox">Before Spring 3.1, the Spring MVC mapped the requests to handler methods using two steps. First, the controller was selected by <kbd>DefaultAnnotationHandlerMapping</kbd>, and then, the actual method was mapped with the incoming requests by the <kbd>AnnotationMethodHandlerAdapter</kbd>. But as of Spring 3.1, Spring MVC maps the requests, in one step, directly to the handler methods by using <kbd>RequestMappingHandlerMapping</kbd>.</div>
<p>In the next section, we'll see how to define the handler methods, and the return type and parameters allowed for the handler methods in Spring MVC.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining @RequestMapping handler methods</h1>
                </header>
            
            <article>
                
<p>In the Spring MVC Framework, the <kbd>@RequestMapping</kbd> handler methods are very flexible in defining signatures. You can pass any number of arguments in any order. These methods support most type of arguments, and are also very flexible in the return type as well. It can have several return types, some of which are listed next:</p>
<ul>
<li>Supported method argument types
<ul>
<li>Request or response objects (Servlet API)</li>
<li>Session object (Servlet API)</li>
<li><kbd>java.util.Locale</kbd></li>
<li><kbd>java.util.TimeZone</kbd></li>
<li><kbd>java.io.InputStream</kbd> / <kbd>java.io.Reader</kbd></li>
<li><kbd>java.io.OutputStream</kbd> / <kbd>java.io.Writer</kbd></li>
<li><kbd>java.security.Principal</kbd></li>
<li><kbd>@PathVariable</kbd></li>
<li><kbd>@RequestParam</kbd></li>
<li><kbd>@RequestBody</kbd></li>
<li><kbd>@RequestPart</kbd></li>
<li><kbd>java.util.Map</kbd> / <kbd>org.springframework.ui.Model</kbd> / <kbd>org.springframework.ui.ModelMap</kbd></li>
<li><kbd>org.springframework.validation.Errors</kbd> / <kbd>org.springframework.validation.BindingResult</kbd></li>
</ul>
</li>
<li>Supported method return types:
<ul>
<li><kbd>ModelAndView</kbd></li>
<li><kbd>Model</kbd></li>
<li><kbd>Map</kbd></li>
<li><kbd>View</kbd></li>
<li><kbd>String</kbd></li>
<li><kbd>void</kbd></li>
<li><kbd>HttpEntity&lt;?&gt;</kbd> or <kbd>ResponseEntity&lt;?&gt;</kbd></li>
<li><kbd>HttpHeaders</kbd></li>
<li><kbd>Callable&lt;?&gt;</kbd></li>
<li><kbd>DeferredResult&lt;?&gt;</kbd></li>
</ul>
</li>
</ul>
<p>I have listed some of the supported return types and method argument types. It seems that Spring MVC is very flexible and customizable in the nature of defining the request handler methods unlike other MVC frameworks.</p>
<div class="packt_infobox">In the Spring MVC framework, even the handler method can have any ordering of the arguments, but in case of Errors or <kbd>BindingResult</kbd> parameters, we have to put these parameters first, followed by the model object for being bound immediately, because the handler method might have any number of model objects, and Spring MVC creates separate instances of the Errors or <kbd>BindingResult</kbd> for each of them. For example:<br/>
<br/>
<strong>Invalid location<br/>
<br/></strong> <kbd>@PostMapping</kbd><br/>
<kbd>public String saveUser(@ModelAttribute ("user") User user, ModelMap model, BindingResult result){...}</kbd><br/>
<br/>
<strong>Valid location<br/>
<br/></strong> <kbd>@PostMapping</kbd><br/>
<kbd>public String saveUser(@ModelAttribute ("user") User user, BindingResult result, ModelMap model){...}</kbd></div>
<p>Let's see how to pass model data to the view layer in the upcoming section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing model data to the view</h1>
                </header>
            
            <article>
                
<p>As of now, we have implemented a very simple <kbd>HomeCotroller</kbd>, and tested it. But in the web application, we have also passed model data to the view layer. That model data we passed in the model (in a simple word, it is <kbd>Map</kbd>), and that model is returned by the controller along with logical view name. As you already know, Spring MVC supports several return types of the handler method. Let's see the following example:</p>
<pre>    package com.packt.patterninspring.chapter10.bankapp.web.controller; 
 
    import java.util.List; 
 
    import org.springframework.beans.factory.annotation.Autowired; 
    import org.springframework.stereotype.Controller; 
    import org.springframework.ui.ModelMap; 
    import org.springframework.web.bind.annotation.GetMapping; 
    import org.springframework.web.bind.annotation.PostMapping; 
 
    import com.packt.patterninspring.chapter10.bankapp.model.Account; 
    import com.packt.patterninspring.chapter10.bankapp.service.AccountService; 
 
    @Controller 
    public class AccountController { 
    
     @Autowired 
     AccountService accountService; 
    
     @GetMapping(value = "/open-account") 
     public String openAccountForm (){ 
         return "account"; 
     } 
    
     @PostMapping(value = "/open-account") 
     public String save (Account account, ModelMap model){ 
         account = accountService.open(account); 
         model.put("account", account); 
         return "accountDetails"; 
     } 
    
     @GetMapping(value = "/all-accounts") 
     public String all (ModelMap model){ 
         List&lt;Account&gt; accounts = accountService.findAllAccounts(); 
         model.put("accounts", accounts); 
         return "accounts"; 
     } 
   } </pre>
<p>As you can see in the preceding example, the <kbd>AccountController</kbd> class has three handler methods. Two handler methods return the model data along with the logical view name. But in this example, I am using Spring MVC's <kbd>ModelMap</kbd>, so, we don't need to forcefully return as logical view, it binds automatically with the response.</p>
<p>Next you'll learn how to accept request parameters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accepting request parameters</h1>
                </header>
            
            <article>
                
<p>In a Spring web application, sometimes, we just read the data from the server side like in our example. Reading data for all the accounts was a simple read call, and no request parameter was required. But in case you want to fetch data for a particular account, then you have to pass the account ID with the request parameters. Similarly, for creating a new Account in the bank, you have to pass an account object as a parameter. In Spring MVC, we can accept the request parameters in the following ways:</p>
<ul>
<li>Taking query parameters</li>
<li>Taking request parameters via path variables</li>
<li>Taking form parameters</li>
</ul>
<p>Let's look at each of these ways one by one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Taking query parameters</h1>
                </header>
            
            <article>
                
<p>In a web application, we can fetch the request parameters from the request-the account ID in our example if you want to access the details of a particular account. Let's fetch the account ID from the request parameter using the following code:</p>
<pre>    @Controller 
    public class AccountController { 
      @GetMapping(value = "/account") 
      public String getAccountDetails (ModelMap model, HttpServletRequest request){ 
         String accountId = request.getParameter("accountId"); 
         Account account = accountService.findOne(Long.valueOf(accountId)); 
         model.put("account", account); 
         return "accountDetails"; 
     } 
    }  </pre>
<p>In the preceding code snippet, I have used the traditional way to access the request parameters. The Spring MVC framework provides an annotation, <kbd>@RequestParam</kbd>, to access the request parameters. Let's use the <kbd>@RequestParam</kbd> annotation to bind the request parameters to a method parameter in your controller. The following code snippet shows the usage of the <kbd>@RequestParam</kbd> annotation. It extracts the parameter from the request, and performs type conversion as well:</p>
<pre>    @Controller 
    public class AccountController { 
     @GetMapping(value = "/account") 
     public String getAccountDetails (ModelMap model, @RequestParam("accountId") long accountId){ 
         Account account = accountService.findOne(accountId); 
         model.put("account", account); 
         return "accountDetails "; 
    } 
   }  </pre>
<p>In the preceding code, we access the request parameter by using the <kbd>@RequestParam</kbd> annotation, and you can also notice that I didn't use the type conversion from <kbd>String</kbd> to <kbd>Long</kbd>, it will be done automatically by this annotation. One more thing to note here is that parameters using this annotation are required by default, but Spring allows you to override this behavior by using the <kbd>required</kbd> attribute of the <kbd>@RequestParam</kbd> annotation.</p>
<pre>    @Controller 
    public class AccountController { 
      @GetMapping(value = "/account") 
      public String getAccountDetails (ModelMap model,  
         @RequestParam(name = "accountId") long accountId 
         @RequestParam(name = "name", required=false) String name){ 
         Account account = accountService.findOne(accountId); 
         model.put("account", account); 
         return " accountDetails "; 
     } 
   } </pre>
<p>Now let's see how to use path variables to take input as part of the request path.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Taking request parameters via path variables</h1>
                </header>
            
            <article>
                
<p>Spring MVC allows you to pass parameters in the URI instead of passing them through request parameters. The passed values can be extracted from the request URLs. It is based on URI templates. It is not a Spring-specific concept, and is used in many frameworks by using <kbd>{...}</kbd> placeholders and the <kbd>@PathVariable</kbd> annotation. It allows clean URLs without request parameters. The following is an example:</p>
<pre>    @Controller 
    public class AccountController { 
      @GetMapping("/accounts/{accountId}") 
      public String show(@PathVariable("accountId") long accountId, Model model) { 
         Account account = accountService.findOne(accountId); 
         model.put("account", account); 
         return "accountDetails"; 
     } 
     ... 
   } </pre>
<p>In the previous handler, the method can handle the request like this:</p>
<pre>http://localhost:8080/Chapter-10-Spring-MVC-pattern/account?accountId=1000 </pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="118" width="439" class=" image-border" src="assets/ea3b22a3-5441-481c-aed4-8f39359f9b3c.png"/></div>
<p>But in the preceding example, the handler method can handle the request such as:</p>
<pre>http://localhost:8080/Chapter-10-Spring-MVC-pattern/accounts/2000 </pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="111" width="432" class=" image-border" src="assets/788b5f14-6d7c-4ad5-9af7-c6d175d5155a.png"/></div>
<p>We have seen in the preceding code and images how to pass a value either by using request parameters or using path parameters. Both ways are fine if you are passing small amounts of data on a request. But in some cases, we have to pass a lot of data to the server, such as form submission. Let's see how to write controller methods that handle form submissions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Processing forms of a web page</h1>
                </header>
            
            <article>
                
<p>As you know, in any web application, we can send and receive data from the server. In a web application, we send the data by filling out forms, and submitting this form to the server. Spring MVC also provides support for form handling of the client end by displaying the form, validating the form data, and submitting this form data.</p>
<p>Basically, Spring MVC handles the form displaying and form processing first. In the Bank management application, you will need to create a new user, and open a new account in the bank, so, let's create a controller class, AccountController, with a single request-handling method for displaying the account open form, as follows:</p>
<pre>    package com.packt.patterninspring.chapter10.bankapp.web.controller; 
 
    import org.springframework.stereotype.Controller; 
    import org.springframework.web.bind.annotation.GetMapping; 
 
    @Controller 
    public class AccountController { 
    
     @GetMapping(value = "/open-account") 
     public String openAccountForm (){ 
         return "accountForm"; 
    } 
   } </pre>
<p>The <kbd>openAccountForm()</kbd> method's <kbd>@GetMapping</kbd> annotation declares that it will handle the HTTP GET requests for /open-account. It's a simple method, taking no input and only returning a logical view named <kbd>accountForm</kbd>. We have configured <kbd>InternalResourceViewResolver</kbd>, which means that the JSP at <kbd>/WEB-INF/views/accountForm.jsp</kbd> will be called on to render the open account form.</p>
<p>Here's the JSP you'll use for now:</p>
<pre>    &lt;%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %&gt; 
    &lt;html&gt; 
     &lt;head&gt; 
         &lt;title&gt;Bank Management System&lt;/title&gt; 
         &lt;link rel="stylesheet" type="text/css" href="&lt;c:url value="/resources/style.css" /&gt;" &gt; 
     &lt;/head&gt; 
     &lt;body&gt; 
         &lt;h1&gt;Open Account Form&lt;/h1&gt; 
          &lt;form method="post"&gt; 
           Account Number:&lt;br&gt; 
           &lt;input type="text" name="id"&gt;&lt;br&gt; 
           Account Name:&lt;br&gt; 
           &lt;input type="text" name="name"&gt;&lt;br&gt; 
           Initial Balance:&lt;br&gt; 
           &lt;input type="text" name="balance"&gt;&lt;br&gt; 
           &lt;br&gt; 
           &lt;input type="submit" value="Open Account"&gt; 
           &lt;/form&gt;  
    &lt;/body&gt; 
  &lt;/html&gt;    </pre>
<p>As you can see in the preceding code, we have an open account form. It has some fields such as <kbd>AccountId</kbd>, <kbd>Account Name</kbd>, and <kbd>Initial Balance</kbd>. This JSP page has the <kbd>&lt;form&gt;</kbd> tag for the form, and this <kbd>&lt;form&gt;</kbd> tag doesn't have any action parameter. This means that when we submit this form, it will post the form data to the same URI <kbd>/open-account</kbd> with the <kbd>POST</kbd> HTTP method call. The following screenshot displays the account form:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="229" width="397" class=" image-border" src="assets/22c32b1b-53cf-4171-8577-146ea46a1bf5.png"/></div>
<p>Let's add another method to handle the call for the HTTP <kbd>POST</kbd> method with the same URI, <kbd>/open-account</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a form handling controller</h1>
                </header>
            
            <article>
                
<p>Let's see the same <kbd>AccountController</kbd> class by adding another handler method to handle the HTTP <kbd>POST</kbd> request for the URI <kbd>/open-account</kbd> in the web application:</p>
<pre>    package com.packt.patterninspring.chapter10.bankapp.web.controller; 
 
    import java.util.List; 
 
    import org.springframework.beans.factory.annotation.Autowired; 
    import org.springframework.stereotype.Controller; 
    import org.springframework.ui.ModelMap; 
    import org.springframework.web.bind.annotation.GetMapping; 
    import org.springframework.web.bind.annotation.PathVariable; 
    import org.springframework.web.bind.annotation.PostMapping; 
 
    import com.packt.patterninspring.chapter10.bankapp.model.Account; 
    import com.packt.patterninspring.chapter10.bankapp.service.AccountService; 
 
    @Controller 
     public class AccountController { 
    
       @Autowired 
       AccountService accountService; 
    
       @GetMapping(value = "/open-account") 
       public String openAccountForm (){ 
         return "accountForm"; 
       } 
    
       @PostMapping(value = "/open-account") 
       public String save (Account account){ 
         accountService.open(account); 
         return "redirect:/accounts/"+account.getId(); 
       } 
    
       @GetMapping(value = "/accounts/{accountId}") 
       public String getAccountDetails (ModelMap model, @PathVariable Long accountId){ 
         Account account = accountService.findOne(accountId); 
         model.put("account", account); 
         return "accountDetails"; 
       } 
    } </pre>
<p>As you can see in the preceding code, we have added two more handler methods in the <kbd>AccountController</kbd> method, and also injected the service <kbd>AccountService</kbd> with this controller to save the account details in the database. Whenever we process the <kbd>POST</kbd> request from the open account form, the controller accepts the account form data, and saves it to the database by using the injected account service. It will accept the account form data as an Account object. You may also notice here that after processing the form data using the HTTP <kbd>POST</kbd> method, the handler method redirects to the account details page. It is also a better practice to redirect after <kbd>POST</kbd> submission to prevent accidentally submitting the form twice. The following screen is displayed after submission of the request:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="169" width="444" class=" image-border" src="assets/ba094c31-5de1-41f8-a501-baf17624c557.png"/></div>
<p>As you can see in the preceding output on the browser, this page is rendered after submitting the account form. Because we have added one request handler method, this handler method handles the request, and renders another web page including the account details. The following JSP page is rendered as the view of the preceding output:</p>
<pre>    &lt;%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %&gt; 
    &lt;html&gt; 
     &lt;head&gt; 
         &lt;title&gt;Bank Management System&lt;/title&gt; 
         &lt;link rel="stylesheet" type="text/css" href="&lt;c:url value="/resources/style.css" /&gt;" &gt; 
     &lt;/head&gt; 
     &lt;body&gt; 
         &lt;h1&gt;${message} Account Details&lt;/h1&gt; 
           &lt;c:if test="${not empty account }"&gt; 
               &lt;table border="1"&gt; 
                     &lt;tr&gt; 
                           &lt;td&gt;Account Number&lt;/td&gt; 
                           &lt;td&gt;Account Name&lt;/td&gt; 
                           &lt;td&gt;Account Balance&lt;/td&gt; 
                     &lt;/tr&gt; 
                     &lt;tr&gt; 
                           &lt;td&gt;${account.id }&lt;/td&gt; 
                           &lt;td&gt;${account.name }&lt;/td&gt; 
                           &lt;td&gt;${account.balance }&lt;/td&gt; 
                     &lt;/tr&gt; 
               &lt;/table&gt; 
           &lt;/c:if&gt; 
      &lt;/body&gt; 
    &lt;/html&gt; </pre>
<p>In this last code, the handler method sends the <kbd>Account</kbd> object to the model, and also returns the logical view name. This JSP page renders the <kbd>Account</kbd> object taken from the response.</p>
<div class="packt_infobox">One thing to be noticed here is that the Account object has ID, name, and balance properties, which will be populated from the request parameters of the same name as the field name in the account form. If any object property name matches the field name of the HTML form, then this property will be initialized with a NULL value.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data binding with Command Design pattern</h1>
                </header>
            
            <article>
                
<div class="packt_quote">Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.<br/>
- GOF Design Pattern</div>
<p>You learned about the Command Design pattern in <a href="bd05acbb-a42a-4070-9e01-54a8ce049e41.xhtml" target="_blank">Chapter 3</a>, <em>Consideration of Structural and Behavioral Patterns</em>. It is a part of the Behavioral pattern family of the GOF pattern. It is a very simple data-driven pattern. It allows you to encapsulate your request data into an object, and pass that object as a command to the invoker method, and that method returns the command as another object to the caller.</p>
<p>Spring MVC implements the Command Design pattern to bind the request data from the web form as an Object, and passes that object to the request handler method in the controller class. Here, we will explore how to use this pattern to bind the request data to the Object, and also explore the benefits and possibilities of using data binding. In the following class, the <kbd>Account</kbd> java bean is a simple object with three properties--<kbd>id</kbd>, <kbd>name</kbd>, and <kbd>balance</kbd>:</p>
<pre>    package com.packt.patterninspring.chapter10.bankapp.model; 
 
    public class Account{ 
    
     Long id; 
     Long balance; 
     String name; 
    
     public Long getId() { 
         return id; 
     } 
     public void setId(Long id) { 
         this.id = id; 
     } 
     public Long getBalance() { 
         return balance; 
     } 
     public void setBalance(Long balance) { 
           this.balance = balance; 
     } 
     public String getName() { 
         return name; 
     } 
     public void setName(String name) { 
         this.name = name; 
     } 
     @Override 
     public String toString() { 
         return "Account [id=" + id + ", balance=" + balance + ", name=" + name + "]"; 
     } 
          
    } </pre>
<p>Either we submit the web form with the input text fields' names the same as the Object properties' name, or we receive the request as <kbd>http://localhost:8080/Chapter-10-Spring-MVC-pattern/account?id=10000</kbd>. In both cases, behind the scenes, Spring calls the setter methods of the Account class to bind the request data or web form data to the object. Spring also allows you to bind indexed collections such as List, Map, and others.</p>
<p>We can also customize data binding. Spring provides these two ways to customize data binding:</p>
<ul>
<li><strong>Global Customization</strong>: It customizes the data-binding behavior across the web application for a particular Command Object</li>
<li><strong>Per Controller Customization</strong>: It customizes the data-binding behavior per controller class for a particular Command Object</li>
</ul>
<p>Here, I will discuss only the per controller customization. Let's see the following code snippet for customizing data binding for the <kbd>Account</kbd> object:</p>
<pre>    package com.packt.patterninspring.chapter10.bankapp.web.controller; 
 
    .... 
    .... 
    @Controller 
    public class AccountController { 
    
     @Autowired 
     AccountService accountService; 
     .... 
     .... 
     @InitBinder 
     public void initBinder(WebDataBinder binder) { 
         binder.initDirectFieldAccess(); 
         binder.setDisallowedFields("id"); 
         binder.setRequiredFields("name", "balance"); 
     } 
     .... 
     .... 
    } </pre>
<p>As you can see in the preceding code, <kbd>AccountController</kbd> has a <kbd>initBinder(WebDataBinder binder)</kbd> annotated with the <kbd>@InitBinder</kbd> annotation. This method must have a void return type, and have an <kbd>org.springframework.web.bind.WebDataBinder</kbd> as a method argument. The <kbd>WebDataBinder</kbd> object has several methods; we have used some them in the preceding code. <kbd>WebDataBinder</kbd> is used to customize the data binding.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using @ModelAttributes for customizing data binding</h1>
                </header>
            
            <article>
                
<p>Spring MVC provides one more annotation, <kbd>@ModelAttributes</kbd>, for binding data to the <kbd>Command</kbd> object. It is another way to bind the data and to customize the data binding. This annotation allows you to control the creation of the <kbd>Command</kbd> object. In a Spring MVC application, this annotation can be used on a method and on method arguments. Let's see the following examples:</p>
<ul>
<li>Using <kbd>@ModelAttribute</kbd> on methods</li>
</ul>
<p style="padding-left: 60px">We can use the <kbd>ModelAttribute</kbd> annotation on methods to create an object to be used in our form, as follows:</p>
<pre>    package com.packt.patterninspring.chapter10.bankapp.web.controller; 
    .... 
    .... 
    @Controller 
    public class AccountController { 
      .... 
      @ModelAttribute 
      public Account account () { 
         return new Account(); 
     } 
      .... 
   } </pre>
<ul>
<li>Using <kbd>@ModelAttribute</kbd> on method arguments</li>
</ul>
<p>We can also use this annotation on a method argument. In this case, the handler method's arguments are looked up from the model object. If these are not available in the model, then they are created by using the default constructor:</p>
<pre>    package com.packt.patterninspring.chapter10.bankapp.web.controller; 
    .... 
    .... 
    @Controller 
    public class AccountController { 
      ... 
      @PostMapping(value = "/open-account") 
      public String save (@ModelAttribute("account") Account account){ 
         accountService.open(account); 
         return "redirect:/accounts/"+account.getId(); 
    } 
    .... 
  } </pre>
<p>As you can see in the last code snippet, the <kbd>@ModelAttribute</kbd> annotation is used on the method argument. This means that the <kbd>Account</kbd> object fetches from the model object. If it is not there, it will be created by using the default constructor.</p>
<div class="packt_infobox">When the <kbd>@ModelAttribute</kbd> annotation is put on a method, this method will be called before the request handling method is called.</div>
<p>Till now, we have seen how Spring MVC handles requests and request parameters either in the traditional way or by using the <kbd>@RequestParam</kbd>, <kbd>@PathVariable</kbd> annotations. We have also seen how to process the form web page and handle the <kbd>POST</kbd> request with the form data binding to an object in the controller layers. Now let's move to see how to validate if the submitted form data is valid or invalid for the business.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validating forms input parameters</h1>
                </header>
            
            <article>
                
<p>In a web application, validation of the web form data is very important, because end users can submit any thing. Suppose in an application, a user submits the account form by filling in the account name, then it could create the new account in the bank with account holder name. So, we have to ensure the validity of the form data before creating the new record in the database. You do not need to handle the validation logic in the handler method. Spring provides support for the JSR-303 API. As of Spring 3.0, Spring MVC supports this Java Validation API. There isn't much configuration required to configure the Java Validation API in your Spring web application-you just add the implementation of this API in your application class path such as Hibernate Validator.</p>
<p>The Java Validation API has several annotations to validate the properties of the <kbd>Command</kbd> object. We can place constraints on the value of the properties of the <kbd>Command</kbd> object. In this chapter, I have not explored all these annotations, but let's see the following examples with some of these annotations:</p>
<pre>    package com.packt.patterninspring.chapter10.bankapp.model; 
 
    import javax.validation.constraints.NotNull; 
    import javax.validation.constraints.Size; 
 
    public class Account{ 
    
     // Not null 
     @NotNull 
     Long id; 
     // Not null 
     @NotNull 
     Long balance; 
     // Not null, from 5 to 30 characters 
     @NotNull 
     @Size(min=2, max=30) 
     String name; 
    
     public Long getId() { 
         return id; 
     } 
     public void setId(Long id) { 
         this.id = id; 
     } 
     public Long getBalance() { 
         return balance; 
     } 
     public void setBalance(Long balance) { 
         this.balance = balance; 
     } 
     public String getName() { 
         return name; 
     } 
     public void setName(String name) { 
         this.name = name; 
     } 
     @Override 
     public String toString() { 
         return "Account [id=" + id + ", balance=" + balance + ", name=" + name + "]"; 
     } 
    
    } </pre>
<p>As you can see in the preceding code, the properties of the Account class are now annotated with <kbd>@NotNull</kbd> to ensure that the value must not be null, and some properties are also annotated with the <kbd>@Size</kbd> annotation to ensure the count of characters between the minimum and maximum lengths.</p>
<p>Only annotating the properties of the <kbd>Account</kbd> object is not enough. We have to annotate the save() method argument of the <kbd>AccountController</kbd> class as follows:</p>
<pre>    package com.packt.patterninspring.chapter10.bankapp.web.controller; 
    .... 
    .... 
    @Controller 
    public class AccountController { 
    
     .... 
     @PostMapping(value = "/open-account") 
     public String save (@Valid @ModelAttribute("account") Account account, Errors errors){ 
         if (errors.hasErrors()) { 
               return "accountForm"; 
         } 
         accountService.open(account); 
         return "redirect:/accounts/"+account.getId(); 
     } 
     .... 
    } </pre>
<p>As you can see in the preceding code, the <kbd>Account</kbd> parameter is now annotated with <kbd>@Valid</kbd> to indicate to Spring that the command object has validation constraints that should be enforced. Let's see the output when we submit the web open account form while filling invalid data:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="212" width="329" class=" image-border" src="assets/de979414-1011-4428-bd1d-f2e349800dc7.png"/></div>
<p>As I had submitted this form without data, it has been redirected to the same page with validation errors. Spring also allows you to customize these validation messages by configuring these messages into the properties file.</p>
<p>As of now, in this chapter, you have learned about the controller component of the MVC pattern. You also learned how to create and configure in a web application. Let's explore another component of the MVC pattern, view, in the upcoming section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing View in the MVC pattern</h1>
                </header>
            
            <article>
                
<p>View is the most important component of the MVC pattern. The controller returns the model to the front controller along with the logical view name. The front controller resolves to the actual view by using the configured view resolver. Spring MVC provides several view resolvers to support multiple view technologies, such as JSP, Velocity, FreeMarker, JSF, Tiles, Thymeleaf, and so on. You have to configure the view resolver according to the view technology that you use in your web application. Take a look at the following figure to understand more about the view pattern in Spring MVC:</p>
<div class="CDPAlignCenter CDPAlign"><img height="217" width="345" src="assets/a948ab9b-14a7-4fc2-9647-eea78f448711.jpg"/></div>
<p>As you can see in the diagram, Spring MVC's Front Controller has several view resolvers according to the different view technologies. But in this chapter, we will use only JSP as the view technology, and so, we will explore only the JSP-related view resolver, <kbd>InternalResourveViewResolver</kbd>.</p>
<p>A View renders the web output. There are many built-in views available for JSPs, XSLT, templating approaches (Velocity, FreeMarker), and others. Spring MVC also has view support classes for creating PDFs, Excel spreadsheets, and so on.</p>
<p>Controllers, typically, return a <em>logical view name</em> in String MVC, but Spring's <kbd>ViewResolvers</kbd> select a View based on the view name. Let's see how to configure the <kbd>ViewResolver</kbd> in a Spring MVC application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining ViewResolver in the Spring MVC</h1>
                </header>
            
            <article>
                
<p>In Spring MVC, the <kbd>DispatcherServlet</kbd> delegates to a <kbd>ViewResolver</kbd> to obtain the View implementation based on the view name. The default <kbd>ViewResolver</kbd> treats the view name as a web application-relative file path, that is, a JSP--<kbd>/WEB-INF/views/account.jsp</kbd>. We can override this default by registering a <kbd>ViewResolver</kbd> bean with the <kbd>DispatcherServlet</kbd>. In our web application, we have used <kbd>InternalResourceViewResolver</kbd>, because it is related to the JSP view, but there are several other options available in Spring MVC, as mentioned in the previous section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implement the View</h1>
                </header>
            
            <article>
                
<p>The following code renders the view in the MVC pattern:</p>
<p><kbd>accountDetails.jsp</kbd>:</p>
<pre>    &lt;%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %&gt; 
    &lt;html&gt; 
     &lt;head&gt; 
         &lt;title&gt;Bank Management System&lt;/title&gt; 
         &lt;link rel="stylesheet" type="text/css" href="&lt;c:url value="/resources/style.css" /&gt;" &gt; 
     &lt;/head&gt; 
    &lt;body&gt; 
         &lt;h1&gt;${message} Account Details&lt;/h1&gt; 
           &lt;c:if test="${not empty account }"&gt; 
               &lt;table border="1"&gt; 
                     &lt;tr&gt; 
                           &lt;td&gt;Account Number&lt;/td&gt; 
                           &lt;td&gt;Account Name&lt;/td&gt; 
                           &lt;td&gt;Account Balance&lt;/td&gt; 
                     &lt;/tr&gt; 
                     &lt;tr&gt; 
                           &lt;td&gt;${account.id }&lt;/td&gt; 
                           &lt;td&gt;${account.name }&lt;/td&gt; 
                           &lt;td&gt;${account.balance }&lt;/td&gt; 
                     &lt;/tr&gt; 
               &lt;/table&gt; 
           &lt;/c:if&gt; 
      &lt;/body&gt; 
    &lt;/html&gt; </pre>
<p>As you can see in the preceding code, Spring MVC renders this view when the controller will be returned <kbd>accountDetails</kbd> as the logical view name. But how is it resolved by Spring MVC? Let's see the configuration of the <kbd>ViewResolver</kbd> in the Spring configuration file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Register ViewResolver with Spring MVC</h1>
                </header>
            
            <article>
                
<p>Let's register the JSP-related <kbd>ViewResolver</kbd>, that is, configure <kbd>InternalResourceViewResolver</kbd> in the Spring web application, as follows:</p>
<pre>     package com.packt.patterninspring.chapter10.bankapp.web.mvc; 
 
     import org.springframework.context.annotation.Bean; 
     import org.springframework.context.annotation.ComponentScan; 
     import org.springframework.context.annotation.Configuration; 
     import org.springframework.web.servlet.ViewResolver; 
     import org.springframework.web.servlet.config.annotation.EnableWebMvc; 
     import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter; 
     import org.springframework.web.servlet.view.InternalResourceViewResolver; 
 
     @Configuration 
     @ComponentScan(basePackages = {"com.packt.patterninspring.chapter10.bankapp.web.controller"})       
     @EnableWebMvc 
     public class SpringMvcConfig extends WebMvcConfigurerAdapter{ 
       .... 
        @Bean 
         public ViewResolver viewResolver(){ 
         InternalResourceViewResolver viewResolver = new InternalResourceViewResolver(); 
         viewResolver.setPrefix("/WEB-INF/views/"); 
         viewResolver.setSuffix(".jsp"); 
         return viewResolver; 
     } 
      .... 
   } </pre>
<p>As in the preceding code, suppose the controller returns with the logical view name, <kbd>accountDetails</kbd>. All the JSP files for views are placed in the <kbd>/WEB-INF/views/</kbd> directory of the web application. The <kbd>accountDetails.jsp</kbd> view file for account details. As per the preceding configuration file, the actual view name is derived by adding the prefix <kbd>/WEB-INF/views/</kbd> and the postfix <kbd>.jsp</kbd> to the logical view name returned by the application controller. If the application controller returns <kbd>accountDetails</kbd> as the logical view name, then <kbd>ViewResolver</kbd> changes it to the physical by adding a prefix and postfix to the logical view name; finally, it is changed to <kbd>/WEB-INF/views/accountDetails.jsp</kbd> in the our application. The following diagram illustrates how Spring MVC's Front Controller resolves the view in a Spring web application:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/51101b57-a465-4d07-b31e-943299cc7c69.png"/></div>
<p>This last diagram illustrates the whole picture of the Spring MVC request flow with all the components (<strong>Model</strong>, <strong>View</strong>, and <strong>Controllers</strong>) of the MVC pattern, and the Front controller pattern. Any request, either HTTP <kbd>GET</kbd> or <kbd>POST</kbd>, lands at the Front Controller first, which is, actually, the <kbd>DispatcherServlet</kbd> in Spring MVC. The controllers in a Spring web application are responsible for generating and updating the <strong>Model</strong>, and the <strong>Model</strong> is another component of the MVC pattern. Finally, the controller returns that model along with the logical view name to the <kbd>DispatcherServlet</kbd>. It consults with the configured view resolver, and resolves the physical path of the view. The <strong>View</strong> is another component of the MVC pattern.</p>
<p>In the next section, we'll elaborate on the View Helper pattern, and how Spring support the pattern in a Spring web application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The View Helper pattern</h1>
                </header>
            
            <article>
                
<p>The View Helper pattern separates the static view, such as JSP, from the processing of the business model data. The View Helper pattern is used in the presentation layer by adapting the model data and the View components. The View Helper can format the model data according to the business requirement, but it cannot generate model data for the business. The following diagram illustrates the View Helper pattern:</p>
<div class="CDPAlignCenter CDPAlign"><img height="215" width="462" class=" image-border" src="assets/386581b5-f6f4-479c-b017-501fd2e43358.png"/></div>
<p>We know that View is the a static and formatted component of the MVC pattern, but sometimes, we need some business processing the presentation layer. If you are using JSPs, then you could use a scriptlet for the business processing at the the view layer, but using a scriptlet is not a best practice, because it promotes tight coupling between the view and business logic. But some View Helper classes based on the View Helper pattern take over that responsibility of business processing at the presentation layer. Some of the technologies based on the View Helper pattern areas follows:</p>
<ul>
<li>The JavaBeans <kbd>View</kbd> helper</li>
<li>The tag <kbd>LibraryView</kbd> helper
<ul>
<li>Using JSTL tags</li>
<li>Using spring tags</li>
<li>Using third-party tag Library</li>
</ul>
</li>
</ul>
<p>The following tag libraries are used in our web application in this chapter:</p>
<pre>    &lt;%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %&gt; 
    &lt;c:if test="${not empty account }"&gt; 
     .... 
     ....         
    &lt;/c:if&gt; 
 
    &lt;%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %&gt; 
    &lt;form:form method="post" commandName="account"&gt; 
    .... 
    ... 
   &lt;/form:form&gt; </pre>
<p>As you can see in the preceding code, I have used the JSTL tag library for the check not empty account in the model, and the Spring tag library to create the open account form in the web application.</p>
<p>In the next section, you'll learn about the Composite View pattern, and how Spring MVC supports it to implement it in the web application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composite View pattern using Apache tile view resolver</h1>
                </header>
            
            <article>
                
<p>In a web application, the View is one of the most important components. Developing this component is not as easy as seems. It is very complicated to maintain, and a daunting task. Whenever we create the view for a web application, we always focus on the reusability of the view components. We can define some static templates that can be reused in other view pages in the same web application. According to the Composite Design pattern of the GOF pattern, we compose sub-view components for a particular view component. The Composite View pattern promotes reusability of views, and is easy to maintain due to the multiple sub-views instead of creating a large and complicated view. The following diagram illustrates the Composite View pattern:</p>
<div class="packt_figure CDPAlignCenter CDPAlign">&gt;<img height="228" width="433" class=" image-border" src="assets/003641b6-a597-4d9d-91f0-269c14dc2824.png"/></div>
<p>As you can see in the previous diagram, we can create multiple sub-views to create the view in a web application, and these sub-views will be reused across the web application.</p>
<p>Spring MVC provides support for implementation of the Composite View pattern through frameworks such as SiteMesh and Apache tiles. Here we will explore Apache Tiles with a Spring MVC application. Let's see how to configure the Apache Tiles <kbd>ViewResolver</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring a Tiles ViewResolver</h1>
                </header>
            
            <article>
                
<p>Let's configure Apache Tiles in the Spring MVC application. In order to configure it, we have to configure two beans in the Spring configuration file as follows:</p>
<pre>    package com.packt.patterninspring.chapter10.bankapp.web.mvc; 
    ..... 
    @Configuration 
    @ComponentScan(basePackages = {"com.packt.patterninspring.chapter10.bankapp.web.controller"})       
    @EnableWebMvc 
    public class SpringMvcConfig extends WebMvcConfigurerAdapter{ 
    ..... 
    @Bean 
    public TilesConfigurer tilesConfigurer() { 
         TilesConfigurer tiles = new TilesConfigurer(); 
         tiles.setDefinitions(new String[] { 
               "/WEB-INF/layout/tiles.xml" 
         }); 
         tiles.setCheckRefresh(true); 
         return tiles; 
    } 
    
    @Bean 
    public ViewResolver viewResolver() { 
         return new TilesViewResolver(); 
    } 
     ... 
   } </pre>
<p>In the preceding configuration file, we configured two beans, <kbd>TilesConfigurer</kbd> and the <kbd>TilesViewResolver</kbd> bean. The first bean, <kbd>TilesConfigurer</kbd>, has the responsibility to locate and load tile definitions, and, generally, coordinate Tiles. The second bean, <kbd>TilesViewResolver</kbd>, is responsible for resolving logical view names to tile definitions. The XML file <kbd>tiles.xml</kbd> has the tile definitions in the application. Let's see the following code for the tiles configuration file:</p>
<pre>    &lt;tiles-definitions&gt; 
      &lt;definition name="base.definition" template="/WEB-INF/views/mainTemplate.jsp"&gt; 
        &lt;put-attribute name="title" value=""/&gt; 
        &lt;put-attribute name="header" value="/WEB-INF/views/header.jsp"/&gt; 
        &lt;put-attribute name="menu" value="/WEB-INF/views/menu.jsp"/&gt; 
        &lt;put-attribute name="body" value=""/&gt; 
        &lt;put-attribute name="footer" value="/WEB-INF/views/footer.jsp"/&gt; 
      &lt;/definition&gt; 
  
      &lt;definition extends="base.definition" name="openAccountForm"&gt; 
        &lt;put-attribute name="title" value="Account Open Form"/&gt; 
        &lt;put-attribute name="body" value="/WEB-INF/views/accountForm.jsp"/&gt; 
      &lt;/definition&gt; 
     
      &lt;definition extends="base.definition" name="accountsList"&gt; 
        &lt;put-attribute name="title" value="Employees List"/&gt; 
        &lt;put-attribute name="body" value="/WEB-INF/views/accounts.jsp"/&gt; 
      &lt;/definition&gt; 
      ... 
      ... 
    &lt;/tiles-definitions&gt; </pre>
<p>In the preceding code, the <kbd>&lt;tiles-definitions&gt;</kbd> element has multiple <kbd>&lt;definition&gt;</kbd> elements. Each <kbd>&lt;definition&gt;</kbd> element defines a tile, and each tile references a JSP template. Some <kbd>&lt;definition&gt;</kbd> elements extend the base tile definition, because the base tile definition has the common layout for all the views in the web application.</p>
<p>Let's see the base definition template, that is, <kbd>mainTemplate.jsp</kbd>:</p>
<pre>    &lt;%@ taglib uri="http://www.springframework.org/tags" prefix="s" %&gt; 
    &lt;%@ taglib uri="http://tiles.apache.org/tags-tiles" prefix="t" %&gt; 
    &lt;%@ page session="false" %&gt; 
    &lt;html&gt;   
      &lt;head&gt;   
        &lt;title&gt; 
          &lt;tiles:insertAttribute name="title" ignore="true"/&gt; 
        &lt;/title&gt; 
      &lt;/head&gt; 
      &lt;body&gt; 
         &lt;table border="1â³ cellpadding="2â³ cellspacing="2â³ align="left"&gt; 
               &lt;tr&gt; 
                     &lt;td colspan="2â³ align="center"&gt; 
                           &lt;tiles:insertAttribute name="header"/&gt; 
                     &lt;/td&gt; 
               &lt;/tr&gt; 
               &lt;tr&gt; 
                     &lt;td&gt; 
                           &lt;tiles:insertAttribute name="menu"/&gt; 
                     &lt;/td&gt; 
                     &lt;td&gt; 
                           &lt;tiles:insertAttribute name="body"/&gt; 
                     &lt;/td&gt; 
               &lt;/tr&gt; 
               &lt;tr&gt; 
                     &lt;td colspan="2â³  align="center"&gt; 
                           &lt;tiles:insertAttribute name="footer"/&gt; 
                     &lt;/td&gt; 
               &lt;/tr&gt; 
         &lt;/table&gt; 
       &lt;/body&gt;   
    &lt;/html&gt; </pre>
<p>In this preceding JSP file, I have used the <kbd>&lt;tiles:insertAttribute&gt;</kbd> JSP tag from the <kbd>tiles</kbd> tag library to insert other templates.</p>
<p>Let's now see some best practices used to design and develop a web application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Best practices for web application design</h1>
                </header>
            
            <article>
                
<p>The following are some of the best practices that must be considered while designing and developing a web application:</p>
<ul>
<li>Spring MVC is the best choice to design and develop a web application because of the Spring DI pattern and the very flexible MVC pattern with Spring. Spring's <kbd>DispatcherServlet</kbd>, too, is very flexible and customizable.</li>
<li>In any web application using the MVC pattern, the front controller should be generic and as lightweight as possible.</li>
<li>It is important to maintain a clear separation of concerns across the layers of the web application. Separating layers improves the clean design of the application.</li>
<li>If an application layer has too many dependencies with the other layers, as a best approach, introduce another layer to reduce the dependency of that layer.</li>
<li>Never inject a DAO object to the controllers in the web application; always inject a services object to the controller. The DAO objects must be injected with the service layers so that the service layer talks to the data access layer, and the presentation layer talks to the service layer.</li>
<li>Application layers such service, DAO, and presentation layers must be pluggable, and must not be bound with the implementation, that is, using interfaces reduces the actual coupling to concrete implementations, as we know that loosely coupled layered applications are easier to test and maintain.</li>
<li>It is strongly recommended to place JSP files in the WEB-INF directory, because this location is not accessed by any client.</li>
<li>Always specify the name of the command object in the JSP file.</li>
<li>JSP files must not have any business logic and business processing. For such a requirement, we strongly recommend the use of View helper classes such as tags, libraries, JSTL, and so on.</li>
<li>Remove the programming logic from template-based views like JSP.</li>
<li>Create reusable components that can be used to combine model data across views.</li>
<li>Each component of the MVC pattern must have a consistent behavior for which the MVC introduced it. This means that the controller should follow the Single Responsibility Principle. Controllers are responsible only for delegating business logic invocation and view selection.</li>
<li>Finally, be consistent with naming of the configuration files. For example, web beans such as controllers, interceptors, and view resolvers must be defined in separate configuration files. Other application beans such as services, repositories, and so on must be defined into another, separate file. Similarly for security concerns.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you've seen how the Spring Framework allows you to develop a flexible and loosely coupled web-based application. Spring employs annotations for near-POJO development model in your web application. You learned that with Spring MVC, you can create a web-based application by developing controllers that handle requests, and these controllers are very easy to test. In this chapter, we covered the MVC pattern, including its origins and what problems it solves. The Spring Framework has implemented MVC patterns, which means that for any web application, there are three components--Model, View, and Controller.</p>
<p>Spring MVC implements the Application Controller and Front Controller patterns. Spring's dispatcher servlet (<kbd>org.springframework.web.servlet.DispatcherServlet</kbd>) works as a Front Controller in a web-based application. This dispatcher or front controller routes all requests to the application controller by using handler mapping. In Spring MVC, the controller classes have extremely flexible request handler methods. And these handler methods handle all the requests of a web application. There several ways, as we explained in this chapter, to handle request parameters. The <kbd>@RequestParam</kbd> annotation is one of the ways to handle request parameters, and it is also very easy to test without using the http request object in test cases.</p>
<p>In this chapter, we explored the request processing workflow, and discussed all the components which play a role in this workflow. The <kbd>DispatcherServlet</kbd> can be considered the main component in Spring MVC; it plays the role of a front controller in Spring MVC. Another main component is the view resolver, which has the responsibility to render the model data to any view template such JSP, Thymeleaf, FreeMarker, velocity, pdf, xml and so on depending om the configured view resolver in the web application. Spring MVC provides support for several view technologies, but, in this chapter, we briefly looked at how to write views for your controllers using JSPs. We can also add consistent layouts to your views using Apache tiles.</p>
<p>And finally, we covered the web application architecture, and discussed the different layers in a web application such as domain, user interface, web, service, and data access. We created a small bank management web application, and deployed it to the tomcat server.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>