- en: Chapter 6. Database Access and the Future of ORM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 数据库访问和ORM的未来
- en: An essential component found in almost any web application involves the storage
    and retrieval of data in a persistent store. Whether relational or NoSQL based,
    a database often occupies the most important place since it holds the application
    data. When a technology stack becomes a legacy and needs to be refactored or ported
    to a new one, the database is usually the starting point since it holds the domain
    knowledge.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何Web应用程序都包含的一个基本组件是在持久化存储中存储和检索数据。无论是基于关系型还是NoSQL，数据库通常占据最重要的位置，因为它持有应用程序数据。当一个技术栈成为遗留技术并需要重构或移植到新的技术栈时，数据库通常是起点，因为它持有领域知识。
- en: In this chapter, we are first going to study how to integrate and reuse persistence
    frameworks inherited from Java that deal with **Object Relational Mapping** (**ORM**)
    such as those supporting **Java Persistence API** (**JPA**), for example, Hibernate
    and EclipseLink. We will then experiment with the default persistence framework
    available in the Play Framework, Anorm. Finally, we will introduce and discover
    a Scala alternative to ORM and a rather novel approach that adds type safety and
    composition to the more traditional SQL-based queries, the Slick framework. We
    will experiment with Slick in the context of Play web development. We will also
    cover the generation of CRUD-like applications out of existing relational databases
    that can be a boost in productivity when starting out from a legacy database.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先将研究如何集成和重用从Java继承的持久化框架，例如支持**Java持久化API**（**JPA**）的Hibernate和EclipseLink等，这些框架处理**对象关系映射**（**ORM**）。然后，我们将实验Play框架中默认的持久化框架Anorm。最后，我们将介绍Scala的ORM替代方案和一种相当新颖的方法，它为更传统的基于SQL的查询添加了类型安全和组合，即Slick框架。我们将在Play网络开发环境中实验Slick。我们还将涵盖从现有关系数据库生成类似CRUD的应用程序，这对于从遗留数据库开始时提高生产力非常有帮助。
- en: Integrating an existing ORM – Hibernate and JPA
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成现有的ORM – Hibernate和JPA
- en: 'As defined by Wikipedia:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如维基百科所定义：
- en: '"Object-relational mapping (ORM, O/RM, and O/R mapping) in computer software
    is a programming technique for converting data between incompatible type systems
    in object-oriented programming languages".'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “在计算机软件中，对象关系映射（ORM，O/RM和O/R映射）是一种编程技术，用于在面向对象编程语言中转换不兼容的类型系统中的数据”。
- en: The popular adoption of ORM frameworks in Java such as Hibernate is largely
    due to the simplicity and diminution of code you need to write to persist and
    query data.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ORM框架在Java中的广泛应用，如Hibernate，主要归功于持久化和查询数据所需编写的代码的简单性和减少。
- en: Making JPA available in Scala
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Scala中提供JPA
- en: Although Scala has its own modern standard for data persistence (that is, Slick,
    which we will introduce later on), in this section, we will cover a possible integration
    of JPA (Java Persistence API, documented at [http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html](http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html))
    within the Scala world by building an SBT project that uses JPA-annotated Scala
    classes to persist data in a relational database. It is derived from an online
    sample available at [http://www.brainoverload.nl/scala/105/jpa-with-scala](http://www.brainoverload.nl/scala/105/jpa-with-scala),
    which should be particularly interesting to Java developers since it illustrates
    how to use the Spring framework both for dependency injection and configuration
    of beans in the context of a Scala project at the same time. As a reminder, the
    Spring framework, created by Rod Johnson, came out in 2002 as a way to provide
    inversion of control, that is, dependency injection increased in popularity to
    become a full-featured framework now containing many aspects of Java EE 7\. More
    information about Spring is available at [http://projects.spring.io/spring-framework/](http://projects.spring.io/spring-framework/).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Scala有其自己的现代数据持久化标准（即我们稍后将要介绍的Slick），但在本节中，我们将通过构建一个使用JPA注解Scala类在关系数据库中持久化数据的SBT项目，来介绍Scala世界中JPA（Java
    Persistence API，可在[http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html](http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html)中找到）的可能的集成。它源自[http://www.brainoverload.nl/scala/105/jpa-with-scala](http://www.brainoverload.nl/scala/105/jpa-with-scala)上的在线示例，这对于Java开发者来说应该特别有趣，因为它说明了如何在Scala项目中同时使用Spring框架进行依赖注入和bean配置。提醒一下，由Rod
    Johnson创建的Spring框架于2002年推出，作为一种提供控制反转（即依赖注入）的方式，依赖注入的流行度增加，现在成为一个包含Java EE 7许多方面的功能齐全的框架。有关Spring的更多信息可在[http://projects.spring.io/spring-framework/](http://projects.spring.io/spring-framework/)找到。
- en: We are going to connect to the already existing CustomerDB sample database that
    we have introduced in [Chapter 2](ch02.html "Chapter 2. Code Integration"), *Code
    Integration*, to show both how to read existing data and create new entities/tables
    to persist data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将连接到我们在[第2章](ch02.html "第2章。代码集成")中介绍的现有CustomerDB示例数据库，以展示如何读取现有数据以及创建新的实体/表以持久化数据。
- en: 'As we have seen in [Chapter 3](ch03.html "Chapter 3. Understanding the Scala
    Ecosystem"), *Understanding the Scala Ecosystem*, creating a blank Scala SBT project
    is a matter of opening a command terminal, creating a directory to put the project
    in, and running SBT as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第3章](ch03.html "第3章。理解Scala生态系统")中看到的，*理解Scala生态系统*，创建一个空的Scala SBT项目只需打开命令终端，创建一个用于放置项目的目录，然后按照以下方式运行SBT：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can navigate to the `project/` folder that SBT created, and add a `plugins.sbt`
    file containing the following one-liner to import the `sbteclipse` plugin so that
    we can work with the project under the Eclipse IDE:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以导航到SBT创建的 `project/` 文件夹，并添加一个包含以下单行语句的 `plugins.sbt` 文件，以导入 `sbteclipse`
    插件，这样我们就可以在Eclipse IDE下工作：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since we are going to use Hibernate- and Spring-related classes, we need to
    include such dependencies into our `build.sbt` build file (as well as the derby-client
    driver to connect to the `CustomerDB sample` database) so that it looks like the
    following code snippet:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用Hibernate和Spring相关的类，我们需要将这些依赖项包含到我们的 `build.sbt` 构建文件中（以及连接到 `CustomerDB
    sample` 数据库的derby-client驱动程序），使其看起来像以下代码片段：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As a reminder to make these dependencies available in Eclipse, we have to run
    the `> sbt eclipse` command again and refresh our project in the IDE.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提醒使这些依赖项在Eclipse中可用，我们必须再次运行 `> sbt eclipse` 命令并刷新IDE中的项目。
- en: Now, from the root directory of the project, enter `> sbt eclipse` and import
    the project into the IDE.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从项目的根目录进入 `> sbt eclipse` 并将项目导入IDE。
- en: 'Now let''s add a couple of domain entities (under a new package `se.sfjd`)
    that we want to annotate with Java-based JPA annotations. The `Customer` entity
    defined in a `Customer.scala` file in the `se.sfjd` package will map (at least
    partially) to the existing `CUSTOMER` database table:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加几个领域实体（在新的包 `se.sfjd` 下），我们希望用基于Java的JPA注解来注解。在 `se.sfjd` 包中定义的 `Customer`
    实体将（至少部分地）映射到现有的 `CUSTOMER` 数据库表：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice the underscore (_) representing a default value when declaring `var
    id: Int = _`. The default value will be set according to the type `T` of a variable,
    as defined by the Scala specification:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '注意下划线 (_) 在声明 `var id: Int = _` 时代表默认值。默认值将根据变量的类型 `T` 设置，如Scala规范所定义：'
- en: '`0` if `T` is `Int` or one of its subrange types'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `T` 是 `Int` 或其子范围类型之一，则为 `0`。
- en: '`0L` if `T` is `Long`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `T` 是 `Long`，则为 `0L`。
- en: '`0.0f` if `T` is `Float`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `T` 是 `Float`，则为 `0.0f`。
- en: '`0.0d` if `T` is `Double`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `T` 是 `Double`，则为 `0.0d`。
- en: '`false` if `T` is `Boolean`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `T` 是 `Boolean`，则为 `false`。
- en: '`()` if `T` is `Unit`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `T` 是 `Unit`，则为 `()`。
- en: '`null` for all other types of `T`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有其他类型的 `T`，都是 `null`。
- en: 'The `Language` entity corresponds to the addition of a new concept we want
    to persist and therefore requires a new database table, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Language` 实体对应于我们想要持久化的新概念的添加，因此需要一个新的数据库表，如下所示：'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we saw in [Chapter 2](ch02.html "Chapter 2. Code Integration"), *Code Integration*,
    the `@BeanProperty` annotation is a way to generate getters and setters conforming
    to Java, and the `this()` method is a no argument constructor needed by Hibernate.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第2章](ch02.html "第2章。代码集成")中看到的，*代码集成*，`@BeanProperty` 注解是一种生成符合Java的getter和setter的方法，而
    `this()` 方法是Hibernate需要的无参数构造函数。
- en: 'Moving on, the controller class or **DAO** (**Data Access Object**) class captures
    the behavior we want to provide for the `Customer` entity such as CRUD functionality
    in the form of `save` and `find` methods following an interface, or in this case,
    a Scala trait:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，控制器类或 **DAO** （**数据访问对象**）类捕获我们想要为 `Customer` 实体提供的操作，例如通过接口的形式提供 `save`
    和 `find` 方法的CRUD功能，或者在这种情况下，一个Scala特质：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The implementation of the `CustomerDao` class relies on the methods of the
    JPA entity manager that we as Java developers are probably familiar with:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerDao` 类的实现依赖于我们作为Java开发者可能熟悉的JPA实体管理器的各种方法：'
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In a similar manner, we can define a `Language` trait and its implementation
    as follows, with the addition of a `getByName` method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以定义一个 `Language` 特质及其实现，如下所示，并添加了一个 `getByName` 方法：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Before we can execute the project, we still have a couple of steps to follow:
    first we need a test class, we can therefore create a `CustomerTest` class following
    the `ScalaTest` syntax, as we have seen earlier in [Chapter 4](ch04.html "Chapter 4. Testing
    Tools"), *Testing Tools*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以执行项目之前，我们还需要遵循几个步骤：首先我们需要一个测试类，因此我们可以创建一个遵循 `ScalaTest` 语法（如我们之前在 [第 4
    章](ch04.html "第 4 章。测试工具") 中看到的）的 `CustomerTest` 类：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Last but not least, we have to define some configuration, both a `META-INF/persistence.xml`
    file required by JPA that we can put under `src/main/resources/` and a Spring
    `application-context.xml` where all beans are wired and the database connection
    is defined. The `persistence.xml` file will look as simple as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们必须定义一些配置，包括一个 JPA 所需的 `META-INF/persistence.xml` 文件，我们可以将其放在 `src/main/resources/`
    目录下，以及一个 Spring 的 `application-context.xml` 文件，其中所有豆类都已连接，并定义了数据库连接。`persistence.xml`
    文件将看起来像以下这样：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `application-context.xml` file, directly available under `src/main/resources/`,
    is a bit more elaborate and is given as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`application-context.xml` 文件，位于 `src/main/resources/` 目录下，内容较为详细，具体如下：'
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Before running the test, we need to make sure the database server is up and
    running; this was explained in [Chapter 2](ch02.html "Chapter 2. Code Integration"),
    *Code Integration,* while using the NetBeans IDE.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试之前，我们需要确保数据库服务器正在运行；这已在 [第 2 章](ch02.html "第 2 章。代码集成") 中解释，*代码集成*，当时使用
    NetBeans IDE。
- en: 'Now we can execute the example either by right-clicking on the `CustomerTest`
    class and navigating to **Debug As** | **Scala JUnit Test** or from the command
    prompt by entering the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过右键单击 `CustomerTest` 类并导航到 **Debug As** | **Scala JUnit Test** 或从命令提示符中输入以下命令来执行示例：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Dealing with persistence in the Play Framework
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Play 框架中处理持久化
- en: The Play Framework can be run with any sort of ORM, whether it is Java based
    such as JPA or Scala specific. There are related-but-separate Java and Scala flavors
    of the framework. As described in the Play documentation, the Java version uses
    Ebean as its ORM, whereas the Scala alternative does not use ORM but runs with
    Anorm, a Scala-ish abstraction layer on top of JDBC that interacts with a database
    using plain SQL.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Play 框架可以使用任何类型的 ORM 运行，无论是基于 Java 的 JPA 还是 Scala 特定的。该框架有相关的但独立的 Java 和 Scala
    版本。如 Play 文档所述，Java 版本使用 Ebean 作为其 ORM，而 Scala 替代方案不使用 ORM，而是通过 JDBC 之上的 Scala
    风格抽象层 Anorm 运行。
- en: A simple example using Anorm
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Anorm 的简单示例
- en: To illustrate the usage of Anorm, we are going to make a small Play example
    that connects to the existing `CustomerDB` database from the NetBeans distribution
    that we have used in the previous section and introduced in [Chapter 2](ch02.html
    "Chapter 2. Code Integration"), *Code Integration*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 Anorm 的用法，我们将创建一个小的 Play 示例，连接到之前章节中使用的 NetBeans 分发的现有 `CustomerDB` 数据库，并在
    [第 2 章](ch02.html "第 2 章。代码集成") 中介绍，*代码集成*。
- en: 'The most straightforward way to start is to create a default Play Scala project
    from a terminal window by entering the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最直接的方法是从终端窗口创建一个默认的 Play Scala 项目，输入以下命令：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once created and imported into Eclipse (after creating Eclipse-related files
    once again using the `> play eclipse` command; refer to [Chapter 5](ch05.html
    "Chapter 5. Getting Started with the Play Framework"), *Getting Started with the
    Play Framework*, if you need more details) we can see that the dependency to Anorm
    is already part of the `built.sbt` file. However, we need to add the dependency
    to the `derby-client` database driver to this file to be able to communicate with
    the database through jdbc. The dependency can be added as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建并导入到 Eclipse 中（再次使用 `> play eclipse` 命令创建 Eclipse 相关文件；如需更多细节，请参阅 [第 5 章](ch05.html
    "第 5 章。Play 框架入门"), *Play 框架入门*），我们可以看到 Anorm 的依赖已经包含在 `built.sbt` 文件中。然而，我们需要将
    `derby-client` 数据库驱动程序的依赖添加到该文件中，以便通过 jdbc 与数据库通信。依赖项可以按以下方式添加：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now define a `Customer` case class that will represent the `CUSTOMER`
    table from the database and implement some behaviors in the form of methods defined
    in its companion object, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义一个 `Customer` case 类，它将代表数据库中的 `CUSTOMER` 表，并在其伴生对象中实现一些方法形式的行为，如下所示：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The Anorm SQL query conforms to a string-based SQL statement where variables
    are bound to values. Here we bind the `customer_id` column to the `id` input parameter.
    Since we want to return an `Option[Customer]` to handle the case where the SQL
    query did not return any result, we first need to parse the `ResultSet` object
    to create a `Customer` instance and invoke the `singleOpt` method that will make
    sure we wrap the result into an `Option` (which can return `None` instead of a
    potential error).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Anorm SQL 查询符合基于字符串的 SQL 语句，其中变量绑定到值。在这里，我们将 `customer_id` 列绑定到 `id` 输入参数。由于我们希望返回一个
    `Option[Customer]` 来处理 SQL 查询没有返回任何结果的情况，我们首先需要解析 `ResultSet` 对象以创建一个 `Customer`
    实例并调用 `singleOpt` 方法，这将确保我们将结果包装在一个 `Option` 中（它可以返回 `None` 而不是潜在的错误）。
- en: 'The `Application` controller is given as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application` 控制器如下所示：'
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It simply surrounds the database query with a database connection and does some
    pattern matching on the `Option[Customer]` entity to display different messages
    whether the queried customer `id` is found or not.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是将数据库查询包围在数据库连接中，并对 `Option[Customer]` 实体进行一些模式匹配，以显示查询的客户 `id` 是否找到的不同消息。
- en: 'You may have noticed the keyword, `implicit`, sometimes while reading the Scala
    code in general (such as the `implicit c` parameter given in the previous code
    example). As clearly explained in the Scala documentation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能在阅读 Scala 代码时注意到了关键字 `implicit`，例如在之前的代码示例中给出的 `implicit c` 参数。正如 Scala 文档中明确解释的那样：
- en: '"a method with implicit parameters can be applied to arguments just like a
    normal method. In this case, the implicit label has no effect. However, if such
    a method misses arguments for its implicit parameters, such arguments will be
    automatically provided".'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"具有隐含参数的方法可以像普通方法一样应用于参数。在这种情况下，隐含标签没有效果。然而，如果这样的方法遗漏了其隐含参数的参数，这些参数将被自动提供"。'
- en: In our previous case, we could have omitted this implicit parameter since we
    are not using the database connection `c` variable further in the body of our
    method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们可以省略这个隐含参数，因为我们没有在方法体中进一步使用数据库连接 `c` 变量。
- en: Running the application with `inputId=2` can be replaced by `inputId=3000;`
    for example, to demonstrate the case where no customer is found. To avoid changing
    anything in the view, we have reused the welcome message location of the default
    `index.html` page; therefore, you will see the result in the browser in the green
    header at the top of the HTML page.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `inputId=2` 运行应用程序可以替换为 `inputId=3000;` 例如，以演示没有找到客户的情况。为了避免在视图中进行任何更改，我们重用了默认
    `index.html` 页面的欢迎信息位置；因此，您将在浏览器的绿色页眉中看到结果。
- en: This sample only shows a basic usage of Anorm; it is derived from the much more
    complete `computer-database` example that is part of the samples of the Play Framework
    distribution. You can refer to it if you need a deeper knowledge of the Anorm
    framework.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例仅展示了 Anorm 的基本用法；它源自 Play 框架发行版样本中的更完整的 `computer-database` 示例。如果您需要深入了解
    Anorm 框架，可以参考它。
- en: Replacing ORM
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换 ORM
- en: As Java developers, we are used to handling relational database persistence
    through the use of mature and well-established JPA frameworks such as Hibernate
    or EclipseLink. Despite the fact that these frameworks are convenient to use and
    hide a lot of the complexity for retrieving or updating data that is spread over
    several tables, Object-Relational Mapping suffers from the **Object-Relational
    Impedance Mismatch** problem; in an object-oriented model, you traverse objects
    via their relationships, whereas in a relational database, you join the data rows
    of tables, resulting sometimes in an inefficient and cumbersome retrieval of data.
    (This is further explained on the Wikipedia page, [http://en.wikipedia.org/wiki/Object-relational_impedance_mismatch](http://en.wikipedia.org/wiki/Object-relational_impedance_mismatch).)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Java 开发者，我们习惯于通过使用成熟且稳定的 JPA 框架，如 Hibernate 或 EclipseLink，来处理关系型数据库的持久化。尽管这些框架使用方便，并且隐藏了跨多个表检索或更新数据的许多复杂性，但对象关系映射仍然存在
    **对象关系阻抗不匹配** 问题；在面向对象模型中，您通过对象之间的关系遍历对象，而在关系型数据库中，您将表的数据行连接起来，有时会导致数据检索效率低下且繁琐。（这进一步在维基百科页面中解释，[http://en.wikipedia.org/wiki/Object-relational_impedance_mismatch](http://en.wikipedia.org/wiki/Object-relational_impedance_mismatch)。）
- en: 'In contrast, the `Slick` framework that is part of the Typesafe stack proposes
    to solve the persistence of data to relational databases through a Functional
    Relational Mapping, which strives for a more natural fit. Some of the additional
    benefits of Slick include the following two aspects:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Typesafe 栈中的 `Slick` 框架提出通过函数式关系映射来解决数据到关系数据库的持久化问题，力求更自然地匹配。Slick 的额外好处包括以下两个方面：
- en: '**Conciseness and Type Safety**: Instead of running SQL queries by expressing
    them through strings in Java code, Slick uses plain Scala code to express queries.
    In JPA, the Criteria API or languages such as **JPQL** (**Java Persistence** **Query
    Language**) or **HQL** (**Hibernate Query Language**) have long tried to make
    string-based queries more type checked, but are still difficult to comprehend
    and produce verbose code. With Slick, queries are written concisely using the
    power of Scala `for comprehensions`. Type safety of SQL queries was introduced
    a long time ago in the .Net world through the popular LINQ Framework.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁性和类型安全**：Slick 不是通过在 Java 代码中用字符串表达 SQL 查询来运行 SQL 查询，而是使用纯 Scala 代码来表达查询。在
    JPA 中，Criteria API 或如 **JPQL（Java Persistence Query Language**）或 **HQL（Hibernate
    Query Language**）之类的语言长期以来一直试图使基于字符串的查询具有更强的类型检查，但仍然难以理解并生成冗长的代码。使用 Slick，查询通过
    Scala 的 `for comprehensions` 功能简洁地编写。SQL 查询的类型安全在 .Net 世界中通过流行的 LINQ 框架很久以前就已经引入。'
- en: '**Composable and reusable queries**: The functional approach adopted by Slick
    makes composition a natural behavior, a feature that lacks when considering plain
    SQL as an alternative to ORM.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可组合和可重用查询**：Slick 采取的函数式方法使组合成为一种自然的行为，这是当考虑将纯 SQL 作为 ORM 的替代品时缺乏的特性。'
- en: Learning about Slick
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Slick
- en: Let's explore the behavior of the Slick framework through code examples to see
    how we can enhance and replace more traditional ORM solutions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过代码示例来探索 Slick 框架的行为，看看我们如何可以增强和替换更传统的 ORM 解决方案。
- en: 'The first example we can study is part of the `test-patterns-scala` activator
    template project that we have analyzed in [Chapter 4](ch04.html "Chapter 4. Testing
    Tools"), *Testing Tools*. The `scalatest/Test012.scala` file found inside the
    project exhibits a typical usage of Slick as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以研究的第一个例子是我们在第 4 章[测试工具](ch04.html "第 4 章。测试工具")中分析的 `test-patterns-scala`
    activator 模板项目的一部分。项目中的 `scalatest/Test012.scala` 文件展示了 Slick 的典型用法如下：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The most interesting part in the code has to do with the SQL query. The immutable
    variable `names` contains the result of a query to the database; instead of expressing
    the SQL query as a `String` or through the Java Criteria API, pure Scala code
    is used through a `for comprehension`, as shown in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中最有趣的部分与 SQL 查询有关。不可变变量 `names` 包含对数据库的查询结果；而不是将 SQL 查询表达为 `String` 或通过 Java
    Criteria API，而是通过 `for comprehension` 使用纯 Scala 代码，如下面的截图所示：
- en: '![Learning about Slick](img/3637OS_06_05.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![了解 Slick](img/3637OS_06_05.jpg)'
- en: Unlike string-based SQL queries, any typo or reference to tables or fields that
    do not exist will be immediately pointed out by the compiler. More complex queries
    will be very naturally translated into for expressions in a readable manner compared
    to the verbose and hard-to-read output code resulting from the JPA Criteria API.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于字符串的 SQL 查询不同，任何拼写错误或对不存在表或字段的引用都会立即由编译器指出。与 JPA Criteria API 生成的冗长且难以阅读的输出代码相比，更复杂的查询将以非常自然的方式转换为可读的
    for 表达式。
- en: This sample only contains one table, `Contacts`, that we define by extending
    the `scala.slick.driver.H2Driver.simple.Table` class. The `CONTACTS` database
    table includes three columns, one primary key `id` defined as a `Long` datatype,
    and two other properties of type `String`, `name`, and `gender` respectively.
    The method `*` defined in the `Contacts` object specifies a default projection,
    that is, all the columns (or computed values) we are usually interested in. The
    expression `id ~ name` (using the `~` sequence operator) returns a `Projection2[Long,String]`
    which can be thought of as a Tuple2, but for the representation of relations.
    The default projection of `(Int, String)` leads to a `List[(Int, String)]` for
    simple queries.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例仅包含一个表，即 `Contacts`，我们通过扩展 `scala.slick.driver.H2Driver.simple.Table` 类来定义它。`CONTACTS`
    数据库表包括三个列，一个作为 `Long` 数据类型定义的主键 `id`，以及两个其他类型为 `String` 的属性，分别是 `name` 和 `gender`。在
    `Contacts` 对象中定义的 `*` 方法指定了一个默认投影，即我们通常感兴趣的所有列（或计算值）。表达式 `id ~ name`（使用 `~` 连接序列运算符）返回一个
    `Projection2[Long, String]`，可以将其视为 Tuple2，但用于关系表示。默认投影 `(Int, String)` 导致简单查询的
    `List[(Int, String)]`。
- en: 'Since the datatypes of columns in relational databases are not the same as
    Scala types, they need to be mapped (similar to the mappings needed when dealing
    with ORM frameworks or pure JDBC access). As stated in Slick''s documentation,
    the primitive types supported out of the box are as follows (with a few limitations
    depending on the database driver used for each database type):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于关系数据库中列的数据类型与 Scala 类型不同，因此需要映射（类似于处理 ORM 框架或纯 JDBC 访问时所需的映射）。如 Slick 文档所述，开箱即用的原始类型支持如下（根据每个数据库类型使用的数据库驱动程序，有一些限制）：
- en: '**Numeric types**: `Byte`, `Short`, `Int`, `Long`, `BigDecimal`, `Float`, `Double`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数值类型**: `Byte`, `Short`, `Int`, `Long`, `BigDecimal`, `Float`, `Double`'
- en: '**LOB types**: `java.sql.Blob`, `java.sql.Clob`, `Array[Byte]`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LOB 类型**: `java.sql.Blob`, `java.sql.Clob`, `Array[Byte]`'
- en: '**Date types**: `java.sql.Date`, `java.sql.Time`, `java.sql.Timestamp`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日期类型**: `java.sql.Date`, `java.sql.Time`, `java.sql.Timestamp`'
- en: '`Boolean`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boolean`'
- en: '`String`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`'
- en: '`Unit`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unit`'
- en: '`java.util.UUID`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.UUID`'
- en: Once the domain entity is defined, the next steps are to create the database,
    insert some test data in it, and then run a query as we would do with any other
    persistence framework.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 定义领域实体之后，下一步是创建数据库，向其中插入一些测试数据，然后运行查询，就像我们使用任何其他持久化框架一样。
- en: 'All of the code we run in the `Test12` test is surrounded by the following
    block:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `Test12` 测试中运行的代码都被以下代码块包围：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `forURL` method specifies a JDBC database connection, which normally consists
    of a driver class corresponding to the specific database to use and a connection
    URL defined by its `host`, `port`, `database name` as well as an optional `username/password`.
    In the example, a local in-memory database (H2) named `contacts` is used so that
    the connection URL is `jdbc:h2:mem:contacts`, exactly as we would write it in
    Java. Note that a Slick `Database` instance only encapsulates a "how-to" on how
    connections are created, the physical connection being created only at the `withSession`
    call.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`forURL` 方法指定了一个 JDBC 数据库连接，这通常包括一个对应于要使用的特定数据库的驱动程序类和一个由其 `host`、`port`、`database
    name` 以及可选的 `username/password` 定义的连接 URL。在示例中，使用了一个名为 `contacts` 的本地内存数据库（H2），因此连接
    URL 是 `jdbc:h2:mem:contacts`，这与我们在 Java 中编写的方式完全相同。请注意，Slick 的 `Database` 实例仅封装了创建连接的“如何做”，实际的连接仅在
    `withSession` 调用中创建。'
- en: The `Contacts.ddl.create` statement will create the database schema and the
    `insertAll` method will populate the `Contacts` table with three rows each consisting
    of its primary key `id` and `name`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contacts.ddl.create` 语句将创建数据库模式，而 `insertAll` 方法将使用包含其主键 `id` 和 `name` 的三行数据填充
    `Contacts` 表。'
- en: 'We can execute this test alone to verify that it runs as expected, by entering
    the following command in a terminal window in the root directory of the `test-patterns-scala`
    project:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 `test-patterns-scala` 项目的根目录下的终端窗口中输入以下命令来单独执行此测试，以验证它是否按预期运行：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Currently, the `test-patterns-scala` project includes a dependency to the `slf4j-nop`
    implementation of the SLF4J logging framework that disables any logging. Since
    it can be useful to visualize the exact SQL statement produced by Scala `for comprehension`
    statements, let's replace `sl4j-nop` with a logback implementation. In your `build.sbt`
    build file, replace the line `"org.slf4j" % "slf4j-nop" % "1.6.4"` with a reference
    to logback, for example, `"ch.qos.logback" % "logback-classic" % "0.9.28" % "test"`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`test-patterns-scala` 项目包含对 SLF4J 日志框架的 `slf4j-nop` 实现的依赖，该实现禁用了所有日志。由于可视化
    Scala `for comprehension` 语句产生的确切 SQL 语句可能很有用，让我们将 `sl4j-nop` 替换为 logback 实现。在你的
    `build.sbt` 构建文件中，将 `"org.slf4j" % "slf4j-nop" % "1.6.4"` 这一行替换为对 logback 的引用，例如
    `"ch.qos.logback" % "logback-classic" % "0.9.28" % "test"`。
- en: 'Now, if you rerun the test, you will probably see much more logging info than
    you actually want. We can therefore add a `logback.xml` file to the project (in
    the `src/test/resources/` folder) as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你重新运行测试，你可能会看到比实际需要的更多日志信息。因此，我们可以在项目中添加一个 `logback.xml` 文件（在 `src/test/resources/`
    文件夹中），如下所示：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This time if we enable only the `"scala.slick.jdbc.JdbcBackend.statement"`
    logger, the output from the test will show all the SQL queries, similar to the
    following output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，如果我们只启用 `"scala.slick.jdbc.JdbcBackend.statement"` 日志记录器，测试的输出将显示所有 SQL 查询，类似于以下输出：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, to verify whether database schema validation has been enforced, let''s
    try to modify one of the keys of the inserted data so that we have duplicate keys,
    as shown in the following lines of code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了验证是否已强制执行数据库模式验证，让我们尝试修改插入数据的一个键，以便我们有重复的键，如下面的代码行所示：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we run the test again, it fails with a message similar to the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行测试，它将失败，并显示类似于以下的消息：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Scaffolding a Play application
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搭建 Play 应用程序
- en: In this section, we are going to further experiment with Slick and Play by automatically
    creating a full Play application with basic CRUD functionality out of a relational
    database, including Models, Views, Controllers, as well as test data and configuration
    files such as Play routes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过从关系型数据库自动创建一个具有基本 CRUD 功能的完整 Play 应用程序来进一步实验 Slick 和 Play，包括模型、视图、控制器，以及测试数据和配置文件，如
    Play 路由。
- en: Any web application that needs to connect to a database generally requires most
    of the CRUD functionality at least in the backend. Furthermore, being able to
    generate a default frontend can avoid you having to make one from scratch. In
    particular, a Play frontend consisting of HTML5 views is highly reusable since
    most of the display of columns, fields, buttons, and forms can be re-arranged
    with limited copy/paste in an HTML editor.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 任何需要连接到数据库的 Web 应用程序通常至少需要在后端实现大部分 CRUD 功能。此外，能够生成默认的前端可以避免你从头开始制作。特别是，由 HTML5
    视图组成的 Play 前端具有高度的复用性，因为大多数列、字段、按钮和表单的显示都可以在 HTML 编辑器中进行有限的复制粘贴重新排列。
- en: Let's apply this reverse engineering on the sample customer database from the
    NetBeans distribution that we have already covered in [Chapter 2](ch02.html "Chapter 2. Code
    Integration"), *Code Integration*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这种逆向工程应用于我们在[第 2 章](ch02.html "第 2 章。代码集成")中已经介绍过的 NetBeans 分发的示例客户数据库，*代码集成*。
- en: 'The generation of the Play app is done in two steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Play 应用的生成分为两个步骤：
- en: Creation of a regular Play project.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个常规的 Play 项目。
- en: Usage of an external tool named `playcrud` that is itself a Play app and will
    generate all the required MVC and configuration files on top of the new Play project
    structure.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用名为 `playcrud` 的外部工具，它本身是一个 Play 应用程序，并将生成所有必需的 MVC 和配置文件，这些文件位于新的 Play 项目结构之上。
- en: Having this approach in two steps has a better guarantee that the generated
    application will follow the latest changes in the Play distribution, in particular
    with regards to the evolution of the look and feel in Play that comes with every
    new release.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这种两步走的方法更有保证，生成的应用程序将遵循 Play 分发的最新变化，特别是关于 Play 每个新版本带来的外观和感觉的变化。
- en: 'To get started with the `playcrud` utility, clone the project from GitHub by
    entering in a command terminal in a directory of your choice (assuming GIT is
    installed, visit [http://git-scm.com/](http://git-scm.com/) if you don''t have
    it already):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '要开始使用 `playcrud` 工具，请在所选目录的命令行中克隆项目（假设已安装 GIT，如果没有，请访问 [http://git-scm.com/](http://git-scm.com/)）： '
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This should create a directory, `playcrud`, with the content of the project
    being a regular Play application, including the plugin to generate an Eclipse
    project. We can therefore run the following commands:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `playcrud` 的目录，项目内容是一个常规的 Play 应用程序，包括生成 Eclipse 项目的插件。因此，我们可以运行以下命令：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, import the project into Eclipse to better visualize what it consists
    of. The application is made of just one controller found in the `Application.scala`
    file located at `samplecrud\app\controllers`, and its corresponding view found
    in `index.scala.html` under `samplecrud\app\views`. Only two routes are defined
    in the `routes` file under `samplecrud\conf`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将项目导入到 Eclipse 中以更好地可视化其组成。应用程序由位于 `samplecrud\app\controllers` 的 `Application.scala`
    文件中的一个控制器组成，以及位于 `samplecrud\app\views` 下的 `index.scala.html` 中的相应视图。在 `samplecrud\conf`
    下的 `routes` 文件中只定义了两个路由：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first route will display a form in the browser where we can enter information
    about the database from which we want to create a Play app. The form is fairly
    straightforward to understand by looking at its template:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条路由将在浏览器中显示一个表单，我们可以输入有关数据库的信息，从而创建一个 Play 应用程序。通过查看其模板，这个表单相当容易理解：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The second is the `generateAll` action performed once we submit the form that
    will create all files needed to execute the newly created Play app.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是在提交表单后执行一次的 `generateAll` 动作，该动作将创建执行新创建的 Play 应用程序所需的所有文件。
- en: 'To be able to generate all files in the right place, we just need to edit one
    configuration property called `baseDirectory`, currently found in the `Config.scala`
    file in the `utilities/` folder. This property specifies the root directory of
    the Play application we want to generate. Before we edit it, we can generate a
    blank Play project that the `baseDirectory` variable will refer to:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在正确的位置生成所有文件，我们只需要编辑一个名为 `baseDirectory` 的配置属性，目前位于 `utilities/` 文件夹中的 `Config.scala`
    文件。该属性指定了我们想要生成的 Play 应用程序的根目录。在我们编辑它之前，我们可以生成一个空白 Play 项目，`baseDirectory` 变量将引用它：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, open the `http://localhost:9000` URL in a web browser.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在网页浏览器中打开 `http://localhost:9000` URL。
- en: Now that we have our `baseDirectory` (`~/projects/internal/samplecrud`), we
    can add it to the `Config.scala` file. The other properties concerning the database
    are just default values; we do not need to edit them here since we will instead
    specify them when we fill out the HTML form while running the `playcrud` app.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的 `baseDirectory` (`~/projects/internal/samplecrud`)，我们可以将其添加到 `Config.scala`
    文件中。其他关于数据库的属性只是默认值；我们在这里不需要编辑它们，因为我们将在运行 `playcrud` 应用程序时填写 HTML 表单时指定它们。
- en: 'In a new terminal window, let''s execute the `playcrud` app by entering the
    following commands:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新的终端窗口中，让我们通过输入以下命令来执行 `playcrud` 应用程序：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we need to choose a different port than `9000` as it is already taken
    by the blank application.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们需要选择一个不同于 `9000` 的端口，因为它已被空白应用程序占用。
- en: 'Now, point your web browser to the `playcrud` URL, `http://localhost:9020/`.
    You should get an HTML form where you can edit the properties of the source database
    to access for CRUD generation, as shown in the following screenshot (this database
    will only be read from):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将您的网络浏览器指向 `playcrud` URL，`http://localhost:9020/`。您应该会看到一个 HTML 表单，您可以在其中编辑源数据库的属性以进行
    CRUD 生成，如下面的截图所示（此数据库将只进行读取）：
- en: '![Scaffolding a Play application](img/3637OS_06_01.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![搭建 Play 应用程序](img/3637OS_06_01.jpg)'
- en: Submitting the form will most likely generate some logging output in the terminal
    console, and once it is done with the generation, the browser will be redirected
    to port `9000` to display the newly generated CRUD app. Since this is the first
    time we generate the app, it will fail because the `build.sbt` file of the generated
    app was updated and needs to be reloaded with some new dependencies.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 提交表单很可能会在终端控制台中生成一些日志输出，一旦生成完成，浏览器将被重定向到端口 `9000` 以显示新生成的 CRUD 应用程序。由于这是我们第一次生成应用程序，它将失败，因为生成的应用程序的
    `build.sbt` 文件已更新，需要重新加载一些新依赖项。
- en: 'To fix that, interrupt the currently running Play app by pressing *Ctrl* +
    *D*. Once it has stopped, simply re-launch it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，通过按下 *Ctrl* + *D* 来中断当前运行的 Play 应用程序。一旦它停止，只需重新启动它：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If everything goes well, you should be able to access `http://localhost:9000`
    and see a list of clickable controllers corresponding to the entities that were
    generated from the database, including `Product`, `Manufacturer`, and `Purchase
    Order`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该能够访问 `http://localhost:9000` 并看到从数据库生成的实体对应的可点击控制器列表，包括 `Product`、`Manufacturer`
    和 `Purchase Order`。
- en: 'Let''s open one of them, for instance, the Manufacturer view, as shown in the
    following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开其中一个，例如制造商视图，如下截图所示：
- en: '![Scaffolding a Play application](img/3637OS_06_02.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![构建Play应用程序的脚手架](img/3637OS_06_02.jpg)'
- en: The resulting screen shows the `READ` part of the CRUD functionality by displaying
    a list of all the manufacturer rows from the database. The paging functionality
    is set to `3` by default, that is why only three out of the 30 available manufacturers
    are seen at once, but one can navigate to the other pages by clicking on the **Previous**
    and **Next** buttons. This default page size is editable in each individual controller
    (look for a `pageSize` val declaration), or can be modified in the controller
    template before code generation to update all controllers at once. Moreover, the
    headers of the HTML table are clickable to sort elements according to each specific
    column.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 结果屏幕显示了CRUD功能的`READ`部分，通过显示数据库中所有制造商行的列表。分页功能默认设置为`3`，这就是为什么一次只能看到30个制造商中的三个，但可以通过点击**上一页**和**下一页**按钮导航到其他页面。这个默认页面大小可以在每个单独的控制器中编辑（查找`pageSize`
    val声明），或者可以在代码生成之前修改控制器模板，以一次性更新所有控制器。此外，HTML表格的标题是可点击的，可以根据每个特定的列对元素进行排序。
- en: Clicking on the **Add New Manufacturer** button will invoke a new screen containing
    a form used to create a new entry in the database.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**添加新制造商**按钮将调用一个新屏幕，其中包含一个用于在数据库中创建新条目的表单。
- en: Importing test data
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入测试数据
- en: The generated app is running with an H2 in-memory database, by default, which
    is populated at startup with some test data. During generation, we have exported
    content from the source database into an XML file using the functionality of DBUnit,
    a JUnit-based framework in Java. DBUnit is useful when there is enough database
    data involved in your tests that you want to avoid mocking everything by producing
    XML sample files containing some data extracted from a real database instead.
    The exported test data is stored in `testdata.xml` under `samplecrud\test\`. When
    running the generated application, this file will be loaded by DBUnit in the `onStart`
    method of the `Global.scala` after the DB schema has been created.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的应用默认使用H2内存数据库运行，启动时会填充一些测试数据。在生成过程中，我们使用DBUnit的功能将源数据库的内容导出到一个XML文件中，DBUnit是一个基于JUnit的Java框架。当测试中涉及足够多的数据库数据，而你又想避免通过生成包含从真实数据库中提取的一些数据的XML样本文件来模拟所有内容时，DBUnit非常有用。导出的测试数据存储在`samplecrud\test\`目录下的`testdata.xml`文件中。当运行生成的应用程序时，该文件将由DBUnit在`Global.scala`的`onStart`方法中加载，在创建数据库模式之后。
- en: 'To be able to persist the data to a real database and therefore avoid importing
    the XML file on every restart, we can replace the in-memory data by a real database
    on disk. For example, we can replace the database driver properties in the `application.conf`
    file under `samplecrud\conf` with the following lines:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够将数据持久化到真实的数据库中，从而避免每次重启时都导入XML文件，我们可以将内存中的数据替换为磁盘上的真实数据库。例如，我们可以将位于`samplecrud\conf`目录下的`application.conf`文件中的数据库驱动属性替换为以下几行：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The new database is built once we have restarted the play app:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 重启play应用后，新的数据库将被构建：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Accessing the `http://localhost:9000` URL in the browser will this time create
    the database schema on disk and populate test data as well. Since the database
    is persisted between restarts, from now on we have to comment out the `ddl.create`
    statement in `Global.scala` as well as the lines referring to the DBUnit import
    of `testdata.xml`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中访问`http://localhost:9000` URL这次将在磁盘上创建数据库模式并填充测试数据。由于数据库在重启之间是持久化的，从现在开始我们必须在`Global.scala`中注释掉`ddl.create`语句以及引用`testdata.xml`的DBUnit导入的行。
- en: Visualizing the database in the H2browser
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在H2browser中可视化数据库
- en: 'A convenient feature of Play is that you can access the `h2-browser` to visualize
    the database content in your browser directly from SBT. This is true even if you
    are using most databases other than H2\. Open a terminal window and navigate to
    the root of the generated project:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Play的一个方便功能是，你可以直接从SBT访问`h2-browser`来在你的浏览器中可视化数据库内容。即使你使用的是除了H2之外的大多数数据库，这也是正确的。打开一个终端窗口并导航到生成的项目根目录：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Connect to the database by filling out the connection properties as shown in
    the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过填写以下截图所示的连接属性来连接到数据库：
- en: '![Visualizing the database in the H2browser](img/3637OS_06_03.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![在H2browser中可视化数据库](img/3637OS_06_03.jpg)'
- en: 'Assuming that clicking on the **Test Connection** button displayed **Test successful**
    as shown in the previous screenshot, we can visualize and send SQL queries to
    the `customerdb` database as shown in the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 假设点击显示在上一张截图中的**测试连接**按钮后显示**测试成功**，我们可以可视化并发送SQL查询到`customerdb`数据库，如下一张截图所示：
- en: '![Visualizing the database in the H2browser](img/3637OS_06_04.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![在H2browser中可视化数据库](img/3637OS_06_04.jpg)'
- en: Exploring the code behind the app generation
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索应用生成的代码背后的内容
- en: 'Every table from the source database leads to the generation of a number of
    artifacts:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 源数据库中的每个表都会生成一些工件：
- en: One `model`, one `controller`, and several `view` classes
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`模型`，一个`控制器`，以及几个`视图`类
- en: 'A set of `route` entries inserted in the `conf.routes` file, as shown in the
    following code for the `PURCHASE_ORDER` table:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`conf.routes`文件中插入了一组`route`条目，如下所示为`PURCHASE_ORDER`表：
- en: '[PRE33]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Models consist of the domain entities, each being defined in Slick by a combination
    of a case class representing a row together with a driver specific `slick.driver.H2Driver.simple.Table`
    of rows. We could have avoided the usage of the case class and directly written
    tuples of the involved columns as we have seen in the earlier `Test12` example
    from the `test-patterns-scala` activator template, but encapsulating the columns
    in a case class is convenient for later use of pattern matching and usage in the
    views. The model class representing a `PurchaseOrder` entity is generated as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 模型由域实体组成，每个实体都通过Slick定义，结合一个表示行的case类和一个特定驱动程序的`slick.driver.H2Driver.simple.Table`行。我们本可以避免使用case类，直接编写涉及列的元组，就像我们在早期的`Test12`示例中看到的`test-patterns-scala`激活器模板一样，但将列封装在case类中对于后续的模式匹配和视图中的使用来说更方便。代表`PurchaseOrder`实体的模型类生成如下：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The complete code for the `PurchaseOrder` entity as well as the definition of
    the CRUD methods of the corresponding `PurchaseOrderController` class is available
    for download on the Packt Publishing website and can also be reproduced by executing
    the scaffolding playcrud GitHub project on the `CustomerDB` sample database as
    we have explained in this section.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`PurchaseOrder`实体的完整代码以及相应的`PurchaseOrderController`类的CRUD方法定义可以在Packt Publishing网站上下载，也可以通过在本节中解释的执行`scaffolding
    playcrud` GitHub项目在`CustomerDB`样本数据库上重现。'
- en: 'Finally, templates to generate views for a specific entity are gathered under
    the same directory named `views.<entity_name>/` and consist of three files, `list.scala.html`,
    `createForm.scala.html`, and `editForm.scala.html` for the `READ`, `CREATE`, and
    `UPDATE` operations, respectively. They embed a mix of plain HTML5 markup together
    with minimal Scala code to loop over and display elements from the controller
    queries. Notice in the view the addition of a specific `play.api.mvc.Flash` implicit
    object: this useful feature of Play makes it possible to display some information
    in the resulting views to inform the user on the outcome of the performed actions.
    You can see in the controller that we referred to it via the statement `Home.flashing
    {... }`, where we display various information depending on pattern matching on
    the success or failure of an action.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为特定实体生成视图的模板收集在同一个名为`views.<entity_name>/`的目录下，并包括三个文件，分别是`list.scala.html`、`createForm.scala.html`和`editForm.scala.html`，分别用于`READ`、`CREATE`和`UPDATE`操作。它们嵌入了一种混合的纯HTML5标记和最小Scala代码，用于遍历和显示来自控制器查询的元素。注意在视图中添加了一个特定的`play.api.mvc.Flash`隐式对象：Play的这个有用特性使得在生成的视图中显示一些信息成为可能，以通知用户执行操作的结果。您可以在控制器中看到，我们通过`Home.flashing
    {... }`语句引用它，其中根据操作的成功或失败显示各种信息。
- en: Limitations of the playcrud utility
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: playcrud工具的限制
- en: 'In the current release of the experimental `playcrud` utility, a few limitations
    have been found, which are explained as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前实验性的`playcrud`工具版本中，发现了一些限制，如下所述：
- en: 'The `playcrud` project does not always work out of the box with all JDBC databases,
    especially since the mappings of some databases are customized. However, with
    only few changes, it is flexible enough to adapt to new mappings. Furthermore,
    it allows the generation of only a partial database by specifying the tables that
    need to be generated in an external file. To enable this functionality, we only
    need to add a file in our `playcrud` project under `conf/`, name it `tables`,
    and write the table names of tables we want to include (one table name per row
    in the file, case insensitive). For instance, consider a `tables` file that includes
    the following code:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playcrud` 项目并不总是与所有 JDBC 数据库完美兼容，特别是由于某些数据库的映射是定制的。然而，只需进行少量更改，它就足够灵活，可以适应新的映射。此外，它允许通过指定需要生成的外部文件中的表来生成部分数据库。为了启用此功能，我们只需在我们的
    `playcrud` 项目的 `conf/` 目录下添加一个文件，命名为 `tables`，并写入我们想要包含的表的名称（文件中的每一行一个表名，不区分大小写）。例如，考虑一个包含以下代码的
    `tables` 文件：'
- en: '[PRE35]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This code will create MVC classes and HTML views for these three tables only.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码只为这三个表创建 MVC 类和 HTML 视图。
- en: In case the mapping of a specific database datatype is not handled by `playcrud`,
    you will get a compiler error in the browser window that will most likely refer
    to the missing datatype. The place in the `playcrud` code where mappings are handled
    is the `utilities/DBUtil.scala` class. A later release of `playcrud` should make
    these configurations more flexible per database type and put them in external
    files, but for now they are embedded in the code.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果特定数据库数据类型的映射没有被 `playcrud` 处理，你将在浏览器窗口中得到一个编译错误，这很可能会提到缺少的数据类型。处理映射的 `playcrud`
    代码中的位置是 `utilities/DBUtil.scala` 类。`playcrud` 的后续版本应该使这些配置对每种数据库类型更加灵活，并将它们放在外部文件中，但到目前为止，它们是嵌入在代码中的。
- en: The available code generation is inspired and built upon two already existing
    samples, one being the sample named `computer-database` part of the Play Framework
    distribution (which exhibits a CRUD app but with Anorm as persistence, a SQL-based
    persistence framework, which is the default in Play), the other being a sample
    of usage of Slick done by Typesafe's Slick Team (the `Coffee` database with its
    `Suppliers` showing one-to-many relationships). If you wish to generate the code
    differently, all the templates are found under `views/`. Some of them mostly contain
    static data, such as the generation of `build.sbt` based on the `build.scala.txt`
    template.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的代码生成是在两个已经存在的样本的基础上灵感和构建的，一个是 Play 框架分发的名为 `computer-database` 的样本（它展示了一个
    CRUD 应用，但使用 Anorm 作为持久层，这是一个基于 SQL 的持久层框架，是 Play 的默认选项），另一个是 Typesafe 的 Slick
    团队完成的 Slick 使用示例（带有 `Suppliers` 的 `Coffee` 数据库，展示了多对一关系）。如果你希望以不同的方式生成代码，所有模板都可以在
    `views/` 目录下找到。其中一些主要包含静态数据，例如基于 `build.scala.txt` 模板生成 `build.sbt`。
- en: In commercial applications, it is not unusual to encounter database tables that
    have more than 22 columns. Since we encapsulate these columns into case classes
    and Scala 2.10 has a restriction that limits the creation of a case class of more
    than 22 elements, it is not possible at the moment to generate Slick mappings
    exceeding that size. Hopefully, starting with Scala 2.11, this limitation should
    be lifted.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在商业应用中，遇到具有超过 22 列的数据库表并不罕见。由于我们将这些列封装到案例类中，而 Scala 2.10 有一个限制，限制了超过 22 个元素的案例类的创建，因此目前无法生成超过该大小的
    Slick 映射。希望从 Scala 2.11 开始，这个限制应该会被取消。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered several approaches to deal with relational
    database persistence. We first went through an example of integration between
    Scala and traditional JPA-based ORM persistence. The example also illustrated
    the integration between the Spring framework and a Scala codebase. We then introduced
    Anorm, the default persistence framework available in the Play Framework that
    relies on direct SQL queries. Because of some limitations of ORM, mainly related
    to scalability and performance, and limitations as well of plain SQL queries in
    terms of lack of type safety and lack of composability, we moved towards the adoption
    of the Slick framework, a unique approach to persistence that targets a more functional
    way to persist data in relational databases. Finally, we considered the case where
    we can generate a full Play web app with basic CRUD functionality out of an existing
    database as a way of rapidly getting started integrating Slick into Play. The
    future releases of Slick starting with 2.0 enhance support for code generation
    and strive for even more readable syntax for writing database queries through
    the usage of Scala macros.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了处理关系型数据库持久化的几种方法。我们首先通过一个Scala与基于传统JPA的ORM持久化集成的例子进行了说明。该例子还展示了Spring框架与Scala代码库之间的集成。然后，我们介绍了Anorm，这是Play框架中默认的持久化框架，它依赖于直接SQL查询。由于ORM的一些局限性，主要与可扩展性和性能相关，以及纯SQL查询在类型安全和可组合性方面的局限性，我们转向采用Slick框架，这是一种独特的持久化方法，旨在以更函数式的方式在关系型数据库中持久化数据。最后，我们考虑了通过从现有数据库生成具有基本CRUD功能的全功能Play
    Web应用程序，作为快速将Slick集成到Play中的方法。Slick的未来版本从2.0开始增强了对代码生成的支持，并力求通过使用Scala宏使编写数据库查询的语法更加可读。
- en: In the next chapter, we are going to consider how to use Scala when integrating
    external systems together, in particular through Web Services and REST APIs, supporting
    data formats such as JSON and XML.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在使用Scala集成外部系统时使用Scala，特别是通过Web服务和REST API，支持JSON和XML等数据格式。
