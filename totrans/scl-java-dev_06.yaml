- en: Chapter 6. Database Access and the Future of ORM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An essential component found in almost any web application involves the storage
    and retrieval of data in a persistent store. Whether relational or NoSQL based,
    a database often occupies the most important place since it holds the application
    data. When a technology stack becomes a legacy and needs to be refactored or ported
    to a new one, the database is usually the starting point since it holds the domain
    knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are first going to study how to integrate and reuse persistence
    frameworks inherited from Java that deal with **Object Relational Mapping** (**ORM**)
    such as those supporting **Java Persistence API** (**JPA**), for example, Hibernate
    and EclipseLink. We will then experiment with the default persistence framework
    available in the Play Framework, Anorm. Finally, we will introduce and discover
    a Scala alternative to ORM and a rather novel approach that adds type safety and
    composition to the more traditional SQL-based queries, the Slick framework. We
    will experiment with Slick in the context of Play web development. We will also
    cover the generation of CRUD-like applications out of existing relational databases
    that can be a boost in productivity when starting out from a legacy database.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating an existing ORM – Hibernate and JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As defined by Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Object-relational mapping (ORM, O/RM, and O/R mapping) in computer software
    is a programming technique for converting data between incompatible type systems
    in object-oriented programming languages".'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The popular adoption of ORM frameworks in Java such as Hibernate is largely
    due to the simplicity and diminution of code you need to write to persist and
    query data.
  prefs: []
  type: TYPE_NORMAL
- en: Making JPA available in Scala
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although Scala has its own modern standard for data persistence (that is, Slick,
    which we will introduce later on), in this section, we will cover a possible integration
    of JPA (Java Persistence API, documented at [http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html](http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html))
    within the Scala world by building an SBT project that uses JPA-annotated Scala
    classes to persist data in a relational database. It is derived from an online
    sample available at [http://www.brainoverload.nl/scala/105/jpa-with-scala](http://www.brainoverload.nl/scala/105/jpa-with-scala),
    which should be particularly interesting to Java developers since it illustrates
    how to use the Spring framework both for dependency injection and configuration
    of beans in the context of a Scala project at the same time. As a reminder, the
    Spring framework, created by Rod Johnson, came out in 2002 as a way to provide
    inversion of control, that is, dependency injection increased in popularity to
    become a full-featured framework now containing many aspects of Java EE 7\. More
    information about Spring is available at [http://projects.spring.io/spring-framework/](http://projects.spring.io/spring-framework/).
  prefs: []
  type: TYPE_NORMAL
- en: We are going to connect to the already existing CustomerDB sample database that
    we have introduced in [Chapter 2](ch02.html "Chapter 2. Code Integration"), *Code
    Integration*, to show both how to read existing data and create new entities/tables
    to persist data.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen in [Chapter 3](ch03.html "Chapter 3. Understanding the Scala
    Ecosystem"), *Understanding the Scala Ecosystem*, creating a blank Scala SBT project
    is a matter of opening a command terminal, creating a directory to put the project
    in, and running SBT as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can navigate to the `project/` folder that SBT created, and add a `plugins.sbt`
    file containing the following one-liner to import the `sbteclipse` plugin so that
    we can work with the project under the Eclipse IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are going to use Hibernate- and Spring-related classes, we need to
    include such dependencies into our `build.sbt` build file (as well as the derby-client
    driver to connect to the `CustomerDB sample` database) so that it looks like the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As a reminder to make these dependencies available in Eclipse, we have to run
    the `> sbt eclipse` command again and refresh our project in the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Now, from the root directory of the project, enter `> sbt eclipse` and import
    the project into the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add a couple of domain entities (under a new package `se.sfjd`)
    that we want to annotate with Java-based JPA annotations. The `Customer` entity
    defined in a `Customer.scala` file in the `se.sfjd` package will map (at least
    partially) to the existing `CUSTOMER` database table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the underscore (_) representing a default value when declaring `var
    id: Int = _`. The default value will be set according to the type `T` of a variable,
    as defined by the Scala specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0` if `T` is `Int` or one of its subrange types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0L` if `T` is `Long`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0.0f` if `T` is `Float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0.0d` if `T` is `Double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`false` if `T` is `Boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`()` if `T` is `Unit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null` for all other types of `T`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Language` entity corresponds to the addition of a new concept we want
    to persist and therefore requires a new database table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we saw in [Chapter 2](ch02.html "Chapter 2. Code Integration"), *Code Integration*,
    the `@BeanProperty` annotation is a way to generate getters and setters conforming
    to Java, and the `this()` method is a no argument constructor needed by Hibernate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, the controller class or **DAO** (**Data Access Object**) class captures
    the behavior we want to provide for the `Customer` entity such as CRUD functionality
    in the form of `save` and `find` methods following an interface, or in this case,
    a Scala trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the `CustomerDao` class relies on the methods of the
    JPA entity manager that we as Java developers are probably familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar manner, we can define a `Language` trait and its implementation
    as follows, with the addition of a `getByName` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can execute the project, we still have a couple of steps to follow:
    first we need a test class, we can therefore create a `CustomerTest` class following
    the `ScalaTest` syntax, as we have seen earlier in [Chapter 4](ch04.html "Chapter 4. Testing
    Tools"), *Testing Tools*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, we have to define some configuration, both a `META-INF/persistence.xml`
    file required by JPA that we can put under `src/main/resources/` and a Spring
    `application-context.xml` where all beans are wired and the database connection
    is defined. The `persistence.xml` file will look as simple as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `application-context.xml` file, directly available under `src/main/resources/`,
    is a bit more elaborate and is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Before running the test, we need to make sure the database server is up and
    running; this was explained in [Chapter 2](ch02.html "Chapter 2. Code Integration"),
    *Code Integration,* while using the NetBeans IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can execute the example either by right-clicking on the `CustomerTest`
    class and navigating to **Debug As** | **Scala JUnit Test** or from the command
    prompt by entering the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Dealing with persistence in the Play Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Play Framework can be run with any sort of ORM, whether it is Java based
    such as JPA or Scala specific. There are related-but-separate Java and Scala flavors
    of the framework. As described in the Play documentation, the Java version uses
    Ebean as its ORM, whereas the Scala alternative does not use ORM but runs with
    Anorm, a Scala-ish abstraction layer on top of JDBC that interacts with a database
    using plain SQL.
  prefs: []
  type: TYPE_NORMAL
- en: A simple example using Anorm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To illustrate the usage of Anorm, we are going to make a small Play example
    that connects to the existing `CustomerDB` database from the NetBeans distribution
    that we have used in the previous section and introduced in [Chapter 2](ch02.html
    "Chapter 2. Code Integration"), *Code Integration*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most straightforward way to start is to create a default Play Scala project
    from a terminal window by entering the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once created and imported into Eclipse (after creating Eclipse-related files
    once again using the `> play eclipse` command; refer to [Chapter 5](ch05.html
    "Chapter 5. Getting Started with the Play Framework"), *Getting Started with the
    Play Framework*, if you need more details) we can see that the dependency to Anorm
    is already part of the `built.sbt` file. However, we need to add the dependency
    to the `derby-client` database driver to this file to be able to communicate with
    the database through jdbc. The dependency can be added as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define a `Customer` case class that will represent the `CUSTOMER`
    table from the database and implement some behaviors in the form of methods defined
    in its companion object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The Anorm SQL query conforms to a string-based SQL statement where variables
    are bound to values. Here we bind the `customer_id` column to the `id` input parameter.
    Since we want to return an `Option[Customer]` to handle the case where the SQL
    query did not return any result, we first need to parse the `ResultSet` object
    to create a `Customer` instance and invoke the `singleOpt` method that will make
    sure we wrap the result into an `Option` (which can return `None` instead of a
    potential error).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Application` controller is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It simply surrounds the database query with a database connection and does some
    pattern matching on the `Option[Customer]` entity to display different messages
    whether the queried customer `id` is found or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed the keyword, `implicit`, sometimes while reading the Scala
    code in general (such as the `implicit c` parameter given in the previous code
    example). As clearly explained in the Scala documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '"a method with implicit parameters can be applied to arguments just like a
    normal method. In this case, the implicit label has no effect. However, if such
    a method misses arguments for its implicit parameters, such arguments will be
    automatically provided".'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In our previous case, we could have omitted this implicit parameter since we
    are not using the database connection `c` variable further in the body of our
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application with `inputId=2` can be replaced by `inputId=3000;`
    for example, to demonstrate the case where no customer is found. To avoid changing
    anything in the view, we have reused the welcome message location of the default
    `index.html` page; therefore, you will see the result in the browser in the green
    header at the top of the HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: This sample only shows a basic usage of Anorm; it is derived from the much more
    complete `computer-database` example that is part of the samples of the Play Framework
    distribution. You can refer to it if you need a deeper knowledge of the Anorm
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing ORM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Java developers, we are used to handling relational database persistence
    through the use of mature and well-established JPA frameworks such as Hibernate
    or EclipseLink. Despite the fact that these frameworks are convenient to use and
    hide a lot of the complexity for retrieving or updating data that is spread over
    several tables, Object-Relational Mapping suffers from the **Object-Relational
    Impedance Mismatch** problem; in an object-oriented model, you traverse objects
    via their relationships, whereas in a relational database, you join the data rows
    of tables, resulting sometimes in an inefficient and cumbersome retrieval of data.
    (This is further explained on the Wikipedia page, [http://en.wikipedia.org/wiki/Object-relational_impedance_mismatch](http://en.wikipedia.org/wiki/Object-relational_impedance_mismatch).)
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, the `Slick` framework that is part of the Typesafe stack proposes
    to solve the persistence of data to relational databases through a Functional
    Relational Mapping, which strives for a more natural fit. Some of the additional
    benefits of Slick include the following two aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Conciseness and Type Safety**: Instead of running SQL queries by expressing
    them through strings in Java code, Slick uses plain Scala code to express queries.
    In JPA, the Criteria API or languages such as **JPQL** (**Java Persistence** **Query
    Language**) or **HQL** (**Hibernate Query Language**) have long tried to make
    string-based queries more type checked, but are still difficult to comprehend
    and produce verbose code. With Slick, queries are written concisely using the
    power of Scala `for comprehensions`. Type safety of SQL queries was introduced
    a long time ago in the .Net world through the popular LINQ Framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composable and reusable queries**: The functional approach adopted by Slick
    makes composition a natural behavior, a feature that lacks when considering plain
    SQL as an alternative to ORM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about Slick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's explore the behavior of the Slick framework through code examples to see
    how we can enhance and replace more traditional ORM solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example we can study is part of the `test-patterns-scala` activator
    template project that we have analyzed in [Chapter 4](ch04.html "Chapter 4. Testing
    Tools"), *Testing Tools*. The `scalatest/Test012.scala` file found inside the
    project exhibits a typical usage of Slick as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The most interesting part in the code has to do with the SQL query. The immutable
    variable `names` contains the result of a query to the database; instead of expressing
    the SQL query as a `String` or through the Java Criteria API, pure Scala code
    is used through a `for comprehension`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Learning about Slick](img/3637OS_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unlike string-based SQL queries, any typo or reference to tables or fields that
    do not exist will be immediately pointed out by the compiler. More complex queries
    will be very naturally translated into for expressions in a readable manner compared
    to the verbose and hard-to-read output code resulting from the JPA Criteria API.
  prefs: []
  type: TYPE_NORMAL
- en: This sample only contains one table, `Contacts`, that we define by extending
    the `scala.slick.driver.H2Driver.simple.Table` class. The `CONTACTS` database
    table includes three columns, one primary key `id` defined as a `Long` datatype,
    and two other properties of type `String`, `name`, and `gender` respectively.
    The method `*` defined in the `Contacts` object specifies a default projection,
    that is, all the columns (or computed values) we are usually interested in. The
    expression `id ~ name` (using the `~` sequence operator) returns a `Projection2[Long,String]`
    which can be thought of as a Tuple2, but for the representation of relations.
    The default projection of `(Int, String)` leads to a `List[(Int, String)]` for
    simple queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the datatypes of columns in relational databases are not the same as
    Scala types, they need to be mapped (similar to the mappings needed when dealing
    with ORM frameworks or pure JDBC access). As stated in Slick''s documentation,
    the primitive types supported out of the box are as follows (with a few limitations
    depending on the database driver used for each database type):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Numeric types**: `Byte`, `Short`, `Int`, `Long`, `BigDecimal`, `Float`, `Double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LOB types**: `java.sql.Blob`, `java.sql.Clob`, `Array[Byte]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Date types**: `java.sql.Date`, `java.sql.Time`, `java.sql.Timestamp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.UUID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the domain entity is defined, the next steps are to create the database,
    insert some test data in it, and then run a query as we would do with any other
    persistence framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the code we run in the `Test12` test is surrounded by the following
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `forURL` method specifies a JDBC database connection, which normally consists
    of a driver class corresponding to the specific database to use and a connection
    URL defined by its `host`, `port`, `database name` as well as an optional `username/password`.
    In the example, a local in-memory database (H2) named `contacts` is used so that
    the connection URL is `jdbc:h2:mem:contacts`, exactly as we would write it in
    Java. Note that a Slick `Database` instance only encapsulates a "how-to" on how
    connections are created, the physical connection being created only at the `withSession`
    call.
  prefs: []
  type: TYPE_NORMAL
- en: The `Contacts.ddl.create` statement will create the database schema and the
    `insertAll` method will populate the `Contacts` table with three rows each consisting
    of its primary key `id` and `name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can execute this test alone to verify that it runs as expected, by entering
    the following command in a terminal window in the root directory of the `test-patterns-scala`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Currently, the `test-patterns-scala` project includes a dependency to the `slf4j-nop`
    implementation of the SLF4J logging framework that disables any logging. Since
    it can be useful to visualize the exact SQL statement produced by Scala `for comprehension`
    statements, let's replace `sl4j-nop` with a logback implementation. In your `build.sbt`
    build file, replace the line `"org.slf4j" % "slf4j-nop" % "1.6.4"` with a reference
    to logback, for example, `"ch.qos.logback" % "logback-classic" % "0.9.28" % "test"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you rerun the test, you will probably see much more logging info than
    you actually want. We can therefore add a `logback.xml` file to the project (in
    the `src/test/resources/` folder) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This time if we enable only the `"scala.slick.jdbc.JdbcBackend.statement"`
    logger, the output from the test will show all the SQL queries, similar to the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to verify whether database schema validation has been enforced, let''s
    try to modify one of the keys of the inserted data so that we have duplicate keys,
    as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the test again, it fails with a message similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Scaffolding a Play application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to further experiment with Slick and Play by automatically
    creating a full Play application with basic CRUD functionality out of a relational
    database, including Models, Views, Controllers, as well as test data and configuration
    files such as Play routes.
  prefs: []
  type: TYPE_NORMAL
- en: Any web application that needs to connect to a database generally requires most
    of the CRUD functionality at least in the backend. Furthermore, being able to
    generate a default frontend can avoid you having to make one from scratch. In
    particular, a Play frontend consisting of HTML5 views is highly reusable since
    most of the display of columns, fields, buttons, and forms can be re-arranged
    with limited copy/paste in an HTML editor.
  prefs: []
  type: TYPE_NORMAL
- en: Let's apply this reverse engineering on the sample customer database from the
    NetBeans distribution that we have already covered in [Chapter 2](ch02.html "Chapter 2. Code
    Integration"), *Code Integration*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generation of the Play app is done in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Creation of a regular Play project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Usage of an external tool named `playcrud` that is itself a Play app and will
    generate all the required MVC and configuration files on top of the new Play project
    structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having this approach in two steps has a better guarantee that the generated
    application will follow the latest changes in the Play distribution, in particular
    with regards to the evolution of the look and feel in Play that comes with every
    new release.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with the `playcrud` utility, clone the project from GitHub by
    entering in a command terminal in a directory of your choice (assuming GIT is
    installed, visit [http://git-scm.com/](http://git-scm.com/) if you don''t have
    it already):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This should create a directory, `playcrud`, with the content of the project
    being a regular Play application, including the plugin to generate an Eclipse
    project. We can therefore run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, import the project into Eclipse to better visualize what it consists
    of. The application is made of just one controller found in the `Application.scala`
    file located at `samplecrud\app\controllers`, and its corresponding view found
    in `index.scala.html` under `samplecrud\app\views`. Only two routes are defined
    in the `routes` file under `samplecrud\conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The first route will display a form in the browser where we can enter information
    about the database from which we want to create a Play app. The form is fairly
    straightforward to understand by looking at its template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The second is the `generateAll` action performed once we submit the form that
    will create all files needed to execute the newly created Play app.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to generate all files in the right place, we just need to edit one
    configuration property called `baseDirectory`, currently found in the `Config.scala`
    file in the `utilities/` folder. This property specifies the root directory of
    the Play application we want to generate. Before we edit it, we can generate a
    blank Play project that the `baseDirectory` variable will refer to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, open the `http://localhost:9000` URL in a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our `baseDirectory` (`~/projects/internal/samplecrud`), we
    can add it to the `Config.scala` file. The other properties concerning the database
    are just default values; we do not need to edit them here since we will instead
    specify them when we fill out the HTML form while running the `playcrud` app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new terminal window, let''s execute the `playcrud` app by entering the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we need to choose a different port than `9000` as it is already taken
    by the blank application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, point your web browser to the `playcrud` URL, `http://localhost:9020/`.
    You should get an HTML form where you can edit the properties of the source database
    to access for CRUD generation, as shown in the following screenshot (this database
    will only be read from):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scaffolding a Play application](img/3637OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Submitting the form will most likely generate some logging output in the terminal
    console, and once it is done with the generation, the browser will be redirected
    to port `9000` to display the newly generated CRUD app. Since this is the first
    time we generate the app, it will fail because the `build.sbt` file of the generated
    app was updated and needs to be reloaded with some new dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix that, interrupt the currently running Play app by pressing *Ctrl* +
    *D*. Once it has stopped, simply re-launch it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If everything goes well, you should be able to access `http://localhost:9000`
    and see a list of clickable controllers corresponding to the entities that were
    generated from the database, including `Product`, `Manufacturer`, and `Purchase
    Order`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open one of them, for instance, the Manufacturer view, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scaffolding a Play application](img/3637OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The resulting screen shows the `READ` part of the CRUD functionality by displaying
    a list of all the manufacturer rows from the database. The paging functionality
    is set to `3` by default, that is why only three out of the 30 available manufacturers
    are seen at once, but one can navigate to the other pages by clicking on the **Previous**
    and **Next** buttons. This default page size is editable in each individual controller
    (look for a `pageSize` val declaration), or can be modified in the controller
    template before code generation to update all controllers at once. Moreover, the
    headers of the HTML table are clickable to sort elements according to each specific
    column.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on the **Add New Manufacturer** button will invoke a new screen containing
    a form used to create a new entry in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Importing test data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The generated app is running with an H2 in-memory database, by default, which
    is populated at startup with some test data. During generation, we have exported
    content from the source database into an XML file using the functionality of DBUnit,
    a JUnit-based framework in Java. DBUnit is useful when there is enough database
    data involved in your tests that you want to avoid mocking everything by producing
    XML sample files containing some data extracted from a real database instead.
    The exported test data is stored in `testdata.xml` under `samplecrud\test\`. When
    running the generated application, this file will be loaded by DBUnit in the `onStart`
    method of the `Global.scala` after the DB schema has been created.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to persist the data to a real database and therefore avoid importing
    the XML file on every restart, we can replace the in-memory data by a real database
    on disk. For example, we can replace the database driver properties in the `application.conf`
    file under `samplecrud\conf` with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The new database is built once we have restarted the play app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the `http://localhost:9000` URL in the browser will this time create
    the database schema on disk and populate test data as well. Since the database
    is persisted between restarts, from now on we have to comment out the `ddl.create`
    statement in `Global.scala` as well as the lines referring to the DBUnit import
    of `testdata.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing the database in the H2browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A convenient feature of Play is that you can access the `h2-browser` to visualize
    the database content in your browser directly from SBT. This is true even if you
    are using most databases other than H2\. Open a terminal window and navigate to
    the root of the generated project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect to the database by filling out the connection properties as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing the database in the H2browser](img/3637OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Assuming that clicking on the **Test Connection** button displayed **Test successful**
    as shown in the previous screenshot, we can visualize and send SQL queries to
    the `customerdb` database as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing the database in the H2browser](img/3637OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Exploring the code behind the app generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every table from the source database leads to the generation of a number of
    artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: One `model`, one `controller`, and several `view` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A set of `route` entries inserted in the `conf.routes` file, as shown in the
    following code for the `PURCHASE_ORDER` table:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Models consist of the domain entities, each being defined in Slick by a combination
    of a case class representing a row together with a driver specific `slick.driver.H2Driver.simple.Table`
    of rows. We could have avoided the usage of the case class and directly written
    tuples of the involved columns as we have seen in the earlier `Test12` example
    from the `test-patterns-scala` activator template, but encapsulating the columns
    in a case class is convenient for later use of pattern matching and usage in the
    views. The model class representing a `PurchaseOrder` entity is generated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for the `PurchaseOrder` entity as well as the definition of
    the CRUD methods of the corresponding `PurchaseOrderController` class is available
    for download on the Packt Publishing website and can also be reproduced by executing
    the scaffolding playcrud GitHub project on the `CustomerDB` sample database as
    we have explained in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, templates to generate views for a specific entity are gathered under
    the same directory named `views.<entity_name>/` and consist of three files, `list.scala.html`,
    `createForm.scala.html`, and `editForm.scala.html` for the `READ`, `CREATE`, and
    `UPDATE` operations, respectively. They embed a mix of plain HTML5 markup together
    with minimal Scala code to loop over and display elements from the controller
    queries. Notice in the view the addition of a specific `play.api.mvc.Flash` implicit
    object: this useful feature of Play makes it possible to display some information
    in the resulting views to inform the user on the outcome of the performed actions.
    You can see in the controller that we referred to it via the statement `Home.flashing
    {... }`, where we display various information depending on pattern matching on
    the success or failure of an action.'
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of the playcrud utility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the current release of the experimental `playcrud` utility, a few limitations
    have been found, which are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `playcrud` project does not always work out of the box with all JDBC databases,
    especially since the mappings of some databases are customized. However, with
    only few changes, it is flexible enough to adapt to new mappings. Furthermore,
    it allows the generation of only a partial database by specifying the tables that
    need to be generated in an external file. To enable this functionality, we only
    need to add a file in our `playcrud` project under `conf/`, name it `tables`,
    and write the table names of tables we want to include (one table name per row
    in the file, case insensitive). For instance, consider a `tables` file that includes
    the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code will create MVC classes and HTML views for these three tables only.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In case the mapping of a specific database datatype is not handled by `playcrud`,
    you will get a compiler error in the browser window that will most likely refer
    to the missing datatype. The place in the `playcrud` code where mappings are handled
    is the `utilities/DBUtil.scala` class. A later release of `playcrud` should make
    these configurations more flexible per database type and put them in external
    files, but for now they are embedded in the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The available code generation is inspired and built upon two already existing
    samples, one being the sample named `computer-database` part of the Play Framework
    distribution (which exhibits a CRUD app but with Anorm as persistence, a SQL-based
    persistence framework, which is the default in Play), the other being a sample
    of usage of Slick done by Typesafe's Slick Team (the `Coffee` database with its
    `Suppliers` showing one-to-many relationships). If you wish to generate the code
    differently, all the templates are found under `views/`. Some of them mostly contain
    static data, such as the generation of `build.sbt` based on the `build.scala.txt`
    template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In commercial applications, it is not unusual to encounter database tables that
    have more than 22 columns. Since we encapsulate these columns into case classes
    and Scala 2.10 has a restriction that limits the creation of a case class of more
    than 22 elements, it is not possible at the moment to generate Slick mappings
    exceeding that size. Hopefully, starting with Scala 2.11, this limitation should
    be lifted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered several approaches to deal with relational
    database persistence. We first went through an example of integration between
    Scala and traditional JPA-based ORM persistence. The example also illustrated
    the integration between the Spring framework and a Scala codebase. We then introduced
    Anorm, the default persistence framework available in the Play Framework that
    relies on direct SQL queries. Because of some limitations of ORM, mainly related
    to scalability and performance, and limitations as well of plain SQL queries in
    terms of lack of type safety and lack of composability, we moved towards the adoption
    of the Slick framework, a unique approach to persistence that targets a more functional
    way to persist data in relational databases. Finally, we considered the case where
    we can generate a full Play web app with basic CRUD functionality out of an existing
    database as a way of rapidly getting started integrating Slick into Play. The
    future releases of Slick starting with 2.0 enhance support for code generation
    and strive for even more readable syntax for writing database queries through
    the usage of Scala macros.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to consider how to use Scala when integrating
    external systems together, in particular through Web Services and REST APIs, supporting
    data formats such as JSON and XML.
  prefs: []
  type: TYPE_NORMAL
