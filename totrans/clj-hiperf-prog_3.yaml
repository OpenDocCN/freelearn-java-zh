- en: Chapter 3. Leaning on Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Being hosted on the JVM, there are several aspects of Clojure that really help
    to understand about the Java language and platform. The need is not only due to
    interoperability with Java or understanding its implementation, but also for performance
    reasons. In certain cases, Clojure may not generate optimized JVM bytecode by
    default; in some other cases, you may want to go beyond the performance that Clojure
    data structures offer—you can use the Java alternatives via Clojure to get better
    performance. This chapter discusses those aspects of Clojure. In this chapter
    we will discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting Java and bytecode generated from a Clojure source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numerics and primitives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflection and type hinting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting the equivalent Java source for Clojure code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inspecting the equivalent Java source for a given Clojure code provides great
    insight into how that might impact its performance. However, Clojure generates
    only Java bytecodes at runtime unless we compile a namespace out to the disk.
    When developing with Leiningen, only selected namespaces under the `:aot` vector
    in the `project.clj` file are output as the compiled `.class` files containing
    bytecodes. Fortunately, an easy and quick way to know the equivalent Java source
    for the Clojure code is to AOT-compile namespaces and then decompile the bytecodes
    into equivalent Java sources, using a Java bytecode decompiler.
  prefs: []
  type: TYPE_NORMAL
- en: There are several commercial and open source Java bytecode decompilers available.
    One of the open source decompilers we will discuss here is **JD-GUI**, which you
    can download from its website ([http://jd.benow.ca/#jd-gui](http://jd.benow.ca/#jd-gui)).
    Use a version suitable for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how exactly to arrive at the equivalent Java source code from Clojure.
    Create a new project using Leiningen: `lein new foo`. Then edit the `src/foo/core.clj`
    file with a `mul` function to find out the product of two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Compiling the Clojure sources into Java bytecode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, to compile Clojure sources into bytecodes and output them as `.class`
    files, run the `lein compile :all` command. It creates the `.class` files in the
    `target/classes` directory of the project as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the `foo.core` namespace has been compiled into four `.class`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Decompiling the .class files into Java source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assuming that you have already installed JD-GUI, decompiling the `.class` files
    is as simple as opening them using the JD-GUI application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Decompiling the .class files into Java source](img/B04596_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On inspection, the code for the `foo.core/mul` function looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is easy to understand from the decompiled Java source that the foo.core/mul
    function is an instance of the core$mul class in the foo package extending the
    clojure.lang.AFunction class. We can also see that the argument types are of the
    Object type in method invoke(Object, Object), which implies the numbers will be
    boxed. In a similar fashion, you can decompile class files of any Clojure code
    to inspect the equivalent Java code. If you can combine this with knowledge about
    Java types and potential reflection and boxing, you can find the suboptimal spots
    in code and focus on what to improve upon.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling the Clojure source without locals clearing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note the Java code in the method invoke where it says `x = null; y = null;`
    —how is it possible that the code throws away the arguments, sets them to null,
    and effectively multiplies two null objects? This misleading decompilation happens
    due to locals clearing, a feature of the JVM bytecode implementation of Clojure,
    which has no equivalent in the Java language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with Clojure 1.4, the compiler supports the `:disable-locals-clearing`
    key in the dynamic `clojure.core/*compiler-options*` var that we cannot configure
    in the `project.clj` file. So, we cannot use the `lein compile` command, but we
    can start a **REPL** with the `lein repl` command to compile the classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This generates the class files in the same location as we saw earlier in this
    section, but without `x = null; y = null;` because locals clearing is omitted.
  prefs: []
  type: TYPE_NORMAL
- en: Numerics, boxing, and primitives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Numerics** are scalars. The discussion on numerics was deferred till this
    chapter for the sole reason that the numerics implementation in Clojure has strong
    Java underpinnings. Since version 1.3, Clojure has settled with 64-bit numerics
    as the default. Now, `long` and `double` are idiomatic and the default numeric
    types. Note that these are primitive Java types, not objects. Primitives in Java
    lead to high performance and have several optimizations associated with them at
    compiler and runtime levels. A local primitive is created on the stack (hence
    does not contribute to heap allocation and GC) and can be accessed directly without
    any kind of dereferencing. In Java, there also exist object equivalents of the
    numeric primitives, known as **boxed numerics**—these are regular objects that
    are allocated on the heap. The boxed numerics are also immutable objects, which
    mean not only does the JVM need to dereference the stored value when reading it,
    but also needs to create a new boxed object when a new value needs to be created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be obvious that boxed numerics are slower than their primitive equivalents.
    The Oracle HotSpot JVM, when started with the `-server` option, aggressively inlines
    those functions (on frequent invocation) that contain a call to primitive operations.
    Clojure automatically uses **primitive numerics** at several levels. In the `let`
    blocks, `loop` blocks, arrays, and arithmetic operations (`+`, `-`, `*`, `/`,
    `inc`, `dec`, `<`, `<=`, `>`, `>=`), primitive numerics are detected and retained.
    The following table describes the primitive numerics with their boxed equivalents:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Primitive numeric type | Boxed equivalent |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| byte (1 byte) | `java.lang.Byte` |'
  prefs: []
  type: TYPE_TB
- en: '| short (2 bytes) | `java.lang.Short` |'
  prefs: []
  type: TYPE_TB
- en: '| int (4 bytes) | `java.lang.Integer` |'
  prefs: []
  type: TYPE_TB
- en: '| float (4 bytes) | `java.lang.Float` |'
  prefs: []
  type: TYPE_TB
- en: '| long (8 bytes) | `java.lang.Long` |'
  prefs: []
  type: TYPE_TB
- en: '| double (8 bytes) | `java.lang.Double` |'
  prefs: []
  type: TYPE_TB
- en: In Clojure, sometimes you may find the numerics are passed or returned as boxed
    objects to or from functions due to the lack of type information at runtime. Even
    if you have no control over such functions, you can coerce the values to be treated
    as primitives. The `byte`, `short`, `int`, `float`, `long`, and `double` functions
    create primitive equivalents from given boxed numeric values.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the Lisp traditions is to provide correct ([http://en.wikipedia.org/wiki/Numerical_tower](http://en.wikipedia.org/wiki/Numerical_tower))
    arithmetic implementation. A lower type should not truncate values when overflow
    or underflow happens, but rather should be promoted to construct a higher type
    to maintain correctness. Clojure follows this constraint and provides **autopromotion**
    via prime ([http://en.wikipedia.org/wiki/Prime_(symbol)](http://en.wikipedia.org/wiki/Prime_(symbol)))
    functions: `+''`, `-''`, `*''`, `inc''`, and `dec''`. Autopromotion provides correctness
    at the cost of some performance.'
  prefs: []
  type: TYPE_NORMAL
- en: There are also arbitrary length or precision numeric types in Clojure that let
    us store unbounded numbers but have poorer performance compared to primitives.
    The `bigint` and `bigdec` functions let us create numbers of arbitrary length
    and precision.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to carry out any operations with primitive numerics that may result
    in a number beyond its maximum capacity, the operation maintains correctness by
    throwing an exception. On the other hand, when we use the prime functions, they
    autopromote to provide correctness. There is another set of operations called
    unchecked operations, which do not check for overflow or underflow and can potentially
    return incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, they may be faster than regular and prime functions. Such functions
    are `unchecked-add`, `unchecked-subtract`, `unchecked-multiply`, `unchecked-divide`,
    `unchecked-inc`, and `unchecked-dec`. We can also enable unchecked math behavior
    for regular arithmetic functions using the `*unchecked-math*` var; simply include
    the following in your source code file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: One of the common needs in the arithmetic is the division used to find out the
    quotient and remainder after a natural number division. Clojure's `/` function
    provides a rational number division yielding a ratio, and the `mod` function provides
    a true modular arithmetic division. These functions are slower than the `quot`
    and `rem` functions that compute the division quotient and the remainder, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides objects and primitives, Java has a special type of collection storage
    structure called **arrays**. Once created, arrays cannot be grown or shrunk without
    copying data and creating another array to hold the result. Array elements are
    always homogeneous in type. The array elements are similar to places where you
    can mutate them to hold new values. Unlike collections such as list and vector,
    arrays can contain primitive elements, which make them a very fast storage mechanism
    without GC overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays often form a basis for mutable data structures. For example, Java''s
    `java.lang.ArrayList` implementation uses arrays internally. In Clojure, arrays
    can be used for fast numeric storage and processing, efficient algorithms, and
    so on. Unlike collections, arrays can have one or more dimensions. So you could
    layout data in an array such as a matrix or cube. Let''s see Clojure''s support
    for arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Description | Example | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create array | `(make-array Integer 20)` | Array of type (boxed) integer
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | `(make-array Integer/TYPE 20)` | Array of primitive type integer |'
  prefs: []
  type: TYPE_TB
- en: '|   | `(make-array Long/TYPE 20 10)` | Two-dimensional array of primitive long
    |'
  prefs: []
  type: TYPE_TB
- en: '| Create array of primitives | `(int-array 20)` | Array of primitive integer
    of size 20 |'
  prefs: []
  type: TYPE_TB
- en: '|   | `(int-array [10 20 30 40])` | Array of primitive integer created from
    a vector |'
  prefs: []
  type: TYPE_TB
- en: '| Create array from coll | `(to-array [10 20 30 40])` | Array from sequable
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | `(to-array-2d [[10 20 30][40 50 60]])` | Two-dimensional array from collection
    |'
  prefs: []
  type: TYPE_TB
- en: '| Clone an array | `(aclone (to-array [:a :b :c]))` |   |'
  prefs: []
  type: TYPE_TB
- en: '| Get array element | `(aget array-object 0 3)` | Get element at index [0][3]
    in a 2-D array |'
  prefs: []
  type: TYPE_TB
- en: '| Mutate array element | `(aset array-object 0 3 :foo)` | Set obj :foo at index
    [0][3] in a 2-D array |'
  prefs: []
  type: TYPE_TB
- en: '| Mutate primitive array element | `(aset-int int-array-object 2 6 89)` | Set
    value 89 at index [2][6] in 2-D array |'
  prefs: []
  type: TYPE_TB
- en: '| Find length of array | `(alength array-object)` | `alength` is significantly
    faster than count |'
  prefs: []
  type: TYPE_TB
- en: '| Map over an array | `(def a (int-array [10 20 30 40 50 60]))``(seq``(amap
    a idx ret``(do (println idx (seq ret))``(inc (aget a idx)))))` | Unlike map, `amap`
    returns a non-lazy array, which is significantly faster over array elements. Note
    that `amap` is faster only when properly type hinted. See next section for type
    hinting. |'
  prefs: []
  type: TYPE_TB
- en: '| Reduce over an array | `(def a (int-array [10 20 30 40 50 60]))``(areduce
    a idx ret 0``(do (println idx ret)``(+ ret idx)))` | Unlike reduce, `areduce`
    is significantly faster over array elements. Note that reduce is faster only when
    properly type hinted. See next section for type hinting. |'
  prefs: []
  type: TYPE_TB
- en: '| Cast to primitive arrays | `(ints int-array-object)` | Used with type hinting
    (see next section) |'
  prefs: []
  type: TYPE_TB
- en: 'Like `int-array` and `ints`, there are functions for other types as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Array construction function | Primitive-array casting function | Type hinting
    (does not work for vars) | Generic array type hinting |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| boolean-array | booleans | `^booleans` | `^"[Z"` |'
  prefs: []
  type: TYPE_TB
- en: '| byte-array | bytes | `^bytes` | `^"[B"` |'
  prefs: []
  type: TYPE_TB
- en: '| short-array | shorts | `^shorts` | `^"[S"` |'
  prefs: []
  type: TYPE_TB
- en: '| char-array | chars | `^chars` | `^"[C"` |'
  prefs: []
  type: TYPE_TB
- en: '| int-array | ints | `^ints` | `^"[I"` |'
  prefs: []
  type: TYPE_TB
- en: '| long-array | longs | `^longs` | `^"[J"` |'
  prefs: []
  type: TYPE_TB
- en: '| float-array | floats | `^floats` | `^"[F"` |'
  prefs: []
  type: TYPE_TB
- en: '| double-array | doubles | `^doubles` | `^"[D"` |'
  prefs: []
  type: TYPE_TB
- en: '| object-array | –– | `^objects` | `^"[Ljava.lang.Object"` |'
  prefs: []
  type: TYPE_TB
- en: Arrays are favored over other data structures mainly due to performance, and
    sometimes due to interop. Extreme care should be taken to type hint the arrays
    and use the appropriate functions to work with them.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection and type hints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, as Clojure is dynamically typed, the Clojure compiler is unable to
    figure out the type of object to invoke a certain method. In such cases, Clojure
    uses **reflection**, which is considerably slower than the direct method dispatch.
    Clojure's solution to this is something called **type hints**. Type hints are
    a way to annotate arguments and objects with static types, so that the Clojure
    compiler can emit bytecodes for efficient dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to know where to put type hints is to turn on reflection warning
    in the code. Consider this code that determines the length of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous snippet, we can clearly see there is a very big difference
    in performance in the code that uses reflection versus the code that does not.
    When working on a project, you may want reflection warning to be turned on for
    all files. You can do it easily in Leiningen. Just put the following entry in
    your `project.clj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will automatically turn on warning reflection every time you begin any
    kind of invocation via Leiningen in the dev workflow such as REPL and test.
  prefs: []
  type: TYPE_NORMAL
- en: An array of primitives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall the examples on `amap` and `areduce` from the previous section. If we
    run them with reflection warning on, we''d be warned that it uses reflection.
    Let''s type hint them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the primitive array hint `^ints` does not work at the var level.
    So, it would not work if you defined the var `a`, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This notation is for an array of integers. Other primitive array types have
    similar type hints. Refer to the previous section for type hinting for various
    primitive array types.
  prefs: []
  type: TYPE_NORMAL
- en: Primitives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The type hinting of primitive locals is neither required nor allowed. However,
    you can type hint function arguments as primitives. Clojure allows up to four
    arguments in functions to be type hinted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Boxing may result in something not always being a primitive. In those cases,
    you can coerce those using respective primitive types.
  prefs: []
  type: TYPE_NORMAL
- en: Macros and metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In macros, type hinting does not work the way it does in the other parts of
    the code. Since macros are about transforming the **Abstract Syntax Tree** (**AST**),
    we need to have a mental map of the transformation and we should add type hints
    as metadata in the code. For example, if `str-len` is a macro to find the length
    of a string, we make use of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we alter the metadata of the symbol `s` by tagging it
    with the type `String`, which happens to be the `java.lang.String` class in this
    case. For array types, we can use `[Ljava.lang.String` for an array of string
    objects and similarly for others. If you try to use `str-len` listed previously,
    you may notice this works only when we pass the string bound to a local or a var,
    not as a string literal. To mitigate this, we can write the macro as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here we bind the argument to a type-hinted gensym local, hence calling `.length`
    on it does not use reflection and there is no reflection warning emitted as such.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type hinting via metadata also works with functions, albeit in a different
    notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Except for the first example in the preceding snippet, they are type hinted
    to return the `java.lang.String` type.
  prefs: []
  type: TYPE_NORMAL
- en: String concatenation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `str` function in Clojure is used to concatenate and convert to string
    tokens. In Java, when we write `"hello" + e`, the Java compiler translates this
    to an equivalent code that uses `StringBuilder` and is considerably faster than
    the `str` function in micro-benchmarks. To obtain close-to-Java performance, in
    Clojure we can use a similar mechanism with a macro directly using Java interop
    to avoid the indirection via the `str` function. The **Stringer** ([https://github.com/kumarshantanu/stringer](https://github.com/kumarshantanu/stringer))
    library adopts the same technique to come up with fast string concatenation in
    Clojure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, Stringer also aggressively concatenates the literals during the compile
    phase.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a type (as in `deftype`), the mutable instance variables can be optionally
    annotated as `^:volatile-mutable` or `^:unsynchronized-mutable`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike `defprotocol`, the `definterface` macro lets us provide a return type
    hint for methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `proxy-super` macro (which is used inside the `proxy` macro) is a special
    case where you cannot directly apply a type hint. The reason being that it relies
    on the implicit this object that is automatically created by the `proxy` macro.
    In this case, you must explicitly bind this to a type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Type hinting is quite important for performance in Clojure. Fortunately, we
    need to type hint only when required and it's easy to find out when. In many cases,
    a gain from type hinting overshadows the gains from code inlining.
  prefs: []
  type: TYPE_NORMAL
- en: Using array/numeric libraries for efficiency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed in the previous sections, when working with numerics, performance
    depends a lot on whether the data is based on arrays and primitives. It may take
    a lot of meticulousness on the programmer's part to correctly coerce data into
    primitives and arrays at all stages of the computation in order to achieve optimum
    efficiency. Fortunately, the high-performance enthusiasts from the Clojure community
    realized this issue early on and created some dedicated open source libraries
    to mitigate the problem.
  prefs: []
  type: TYPE_NORMAL
- en: HipHip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**HipHip** is a Clojure library used to work with arrays of primitive types.
    It provides a safety net, that is, it strictly accepts only primitive array arguments
    to work with. As a result, passing silently boxed primitive arrays as arguments
    always results in an exception. HipHip macros and functions rarely need the programmer
    to type hint anything during the operations. It supports arrays of primitive types
    such as `int`, `long`, `float`, and `double`.'
  prefs: []
  type: TYPE_NORMAL
- en: The HipHip project is available at [https://github.com/Prismatic/hiphip](https://github.com/Prismatic/hiphip).
  prefs: []
  type: TYPE_NORMAL
- en: 'As of writing, HipHip''s most recent version is 0.2.0 that supports Clojure
    1.5.x or above, and is tagged as an Alpha release. There is a standard set of
    operations provided by HipHip for arrays of all of the four primitive types: integer
    array operations are in the namespace `hiphip.int`; double precision array operations
    in `hiphip.double`; and so on. The operations are all type hinted for the respective
    types. All of the operations for `int`, `long`, `float`, and `double` in respective
    namespaces are essentially the same except for the array type:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | Function/macro | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Core functions | `aclone` | Like `clojure.core/aclone`, for primitives |'
  prefs: []
  type: TYPE_TB
- en: '|   | `alength` | Like `clojure.core/alength`, for primitives |'
  prefs: []
  type: TYPE_TB
- en: '|   | `aget` | Like `clojure.core/aget`, for primitives |'
  prefs: []
  type: TYPE_TB
- en: '|   | `aset` | Like `clojure.core/aset`, for primitives |'
  prefs: []
  type: TYPE_TB
- en: '|   | `ainc` | Increment array element by specified value |'
  prefs: []
  type: TYPE_TB
- en: '| Equiv hiphip.array operations | `amake` | Make a new array and fill values
    computed by expression |'
  prefs: []
  type: TYPE_TB
- en: '|   | `areduce` | Like `clojure.core/areduce`, with HipHip array bindings |'
  prefs: []
  type: TYPE_TB
- en: '|   | `doarr` | Like `clojure.core/doseq`, with HipHip array bindings |'
  prefs: []
  type: TYPE_TB
- en: '|   | `amap` | Like `clojure.core/for`, creates new array |'
  prefs: []
  type: TYPE_TB
- en: '|   | `afill!` | Like preceding `amap`, but overwrites array argument |'
  prefs: []
  type: TYPE_TB
- en: '| Mathy operations | `asum` | Compute sum of array elements using expression
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | `aproduct` | Compute product of array elements using expression |'
  prefs: []
  type: TYPE_TB
- en: '|   | `amean` | Compute mean over array elements |'
  prefs: []
  type: TYPE_TB
- en: '|   | `dot-product` | Compute dot product of two arrays |'
  prefs: []
  type: TYPE_TB
- en: '| Finding minimum/maximum, Sorting | `amax-index` | Find maximum value in array
    and return the index |'
  prefs: []
  type: TYPE_TB
- en: '|   | `amax` | Find maximum value in array and return it |'
  prefs: []
  type: TYPE_TB
- en: '|   | `amin-index` | Find minimum value in array and return the index |'
  prefs: []
  type: TYPE_TB
- en: '|   | `amin` | Find minimum value in array and return it |'
  prefs: []
  type: TYPE_TB
- en: '|   | `apartition!` | Three-way partition of array: less, equal, greater than
    pivot |'
  prefs: []
  type: TYPE_TB
- en: '|   | `aselect!` | Gather smallest `k` elements at the beginning of array |'
  prefs: []
  type: TYPE_TB
- en: '|   | `asort!` | Sort array in-place using Java''s built-in implementation
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | `asort-max!` | Partial in-place sort gathering top `k` elements to the
    end |'
  prefs: []
  type: TYPE_TB
- en: '|   | `asort-min!` | Partial in-place sort gathering min `k` elements to the
    top |'
  prefs: []
  type: TYPE_TB
- en: '|   | `apartition-indices!` | Like `apartition!` but mutates index-array instead
    of values |'
  prefs: []
  type: TYPE_TB
- en: '|   | `aselect-indices!` | Like `aselect!` but mutates index-array instead
    of values |'
  prefs: []
  type: TYPE_TB
- en: '|   | `asort-indices!` | Like `asort!` but mutates index-array instead of values
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | `amax-indices` | Get index-array; last `k` indices pointing to max `k`
    values |'
  prefs: []
  type: TYPE_TB
- en: '|   | `amin-indices` | Get index-array; first `k` indices pointing to min `k`
    values |'
  prefs: []
  type: TYPE_TB
- en: 'To include HipHip as a dependency in your Leiningen project, specify it in
    `project.clj`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example of how to use HipHip, let''s see how to compute the normalized
    values of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Unless we make sure that `xs` is an array of primitive doubles, HipHip will
    throw `ClassCastException` when the type is incorrect, and `IllegalArgumentException`
    in other cases. I recommend exploring the HipHip project to gain more insight
    into using it effectively.
  prefs: []
  type: TYPE_NORMAL
- en: primitive-math
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can set `*warn-on-reflection*` to true to let Clojure warn us when the reflection
    is used at invocation boundaries. However, when Clojure has to implicitly use
    reflection to perform math, the only resort is to either use a profiler or compile
    the Clojure source down to bytecode, and analyze boxing and reflection with a
    decompiler. This is where the `primitive-math` library helps, by producing extra
    warnings and throwing exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: The `primitive-math` library is available at [https://github.com/ztellman/primitive-math](https://github.com/ztellman/primitive-math).
  prefs: []
  type: TYPE_NORMAL
- en: 'As of writing, primitive-math is at version 0.1.4; you can include it as a
    dependency in your Leiningen project by editing `project.clj` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is how it can be used (recall the example from the *Decompiling
    the .class files into Java source* section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: While `primitive-math` is a useful library, the problem it solves is mostly
    taken care of by the boxing detection feature in Clojure 1.7 (see next section
    *Detecting boxed math*). However, this library is still useful if you are unable
    to use Clojure 1.7 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting boxed math
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Boxed math** is hard to detect and is a source of performance issues. Clojure
    1.7 introduces a way to warn the user when boxed math happens. This can be configured
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When working with Leiningen, you can enable boxed math warnings by putting
    the following entry in the `project.clj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The math operations in `primitive-math` (like HipHip) are implemented via macros.
    Therefore, they cannot be used as higher order functions and, as a consequence,
    may not compose well with other code. I recommend exploring the project to see
    what suits your program use case. Adopting Clojure 1.7 obviates the boxing discovery
    issues by means of a boxed-warning feature.
  prefs: []
  type: TYPE_NORMAL
- en: Resorting to Java and native code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a handful of cases, where the lack of imperative, stack-based, mutable variables
    in Clojure may make the code not perform as well as Java, we may need to evaluate
    alternatives to make it faster. I would advise you to consider writing such code
    directly in Java for better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Another consideration is to use native OS capabilities, such as memory-mapped
    buffers ([http://docs.oracle.com/javase/7/docs/api/java/nio/MappedByteBuffer.html](http://docs.oracle.com/javase/7/docs/api/java/nio/MappedByteBuffer.html))
    or files and unsafe operations ([http://highlyscalable.wordpress.com/2012/02/02/direct-memory-access-in-java/](http://highlyscalable.wordpress.com/2012/02/02/direct-memory-access-in-java/)).
    Note that unsafe operations are potentially hazardous and not recommended in general.
    Such times are also an opportunity to consider writing performance-critical pieces
    of code in C or C++ and then access them via the **Java Native Interface** (**JNI**).
  prefs: []
  type: TYPE_NORMAL
- en: Proteus – mutable locals in Clojure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Proteus is an open source Clojure library that lets you treat a local as a local
    variable, thereby allowing its unsynchronized mutation within the local scope
    only. Note that this library depends on the internal implementation structure
    of Clojure as of Clojure 1.5.1\. The **Proteus** project is available at [https://github.com/ztellman/proteus](https://github.com/ztellman/proteus).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can include Proteus as a dependency in the Leiningen project by editing
    `project.clj`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Proteus in code is straightforward, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Proteus allows mutation only in the local scope, the following throws
    an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The mutable locals are very fast and may be quite useful in tight loops. Proteus
    is unconventional by Clojure idioms, but it may give the required performance
    boost without having to write Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clojure has strong Java interoperability and underpinning, due to which programmers
    can leverage the performance benefits nearing those of Java. For performance-critical
    code, it is sometimes necessary to understand how Clojure interacts with Java
    and how to turn the right knobs. Numerics is a key area where Java interoperability
    is required to get optimum performance. Type hints are another important performance
    trick that is frequently useful. There are several open source Clojure libraries
    that make such activities easier for the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dig deeper below Java and see how the hardware
    and the JVM stack play a key role in offering the performance we get, what their
    constraints are, and how to use their understanding to get better performance.
  prefs: []
  type: TYPE_NORMAL
