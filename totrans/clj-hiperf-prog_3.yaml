- en: Chapter 3. Leaning on Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。依赖 Java
- en: 'Being hosted on the JVM, there are several aspects of Clojure that really help
    to understand about the Java language and platform. The need is not only due to
    interoperability with Java or understanding its implementation, but also for performance
    reasons. In certain cases, Clojure may not generate optimized JVM bytecode by
    default; in some other cases, you may want to go beyond the performance that Clojure
    data structures offer—you can use the Java alternatives via Clojure to get better
    performance. This chapter discusses those aspects of Clojure. In this chapter
    we will discuss:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由于托管在 JVM 上，Clojure 有几个方面真正有助于理解 Java 语言和平台。这种需求不仅是因为与 Java 的互操作性或理解其实现，还因为性能原因。在某些情况下，Clojure
    默认可能不会生成优化的 JVM 字节码；在另一些情况下，你可能希望超越 Clojure 数据结构提供的性能——你可以通过 Clojure 使用 Java 替代方案来获得更好的性能。本章将讨论这些
    Clojure 的方面。在本章中，我们将讨论：
- en: Inspecting Java and bytecode generated from a Clojure source
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查从 Clojure 源代码生成的 Java 和字节码
- en: Numerics and primitives
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值和原始类型
- en: Working with arrays
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作数组
- en: Reflection and type hinting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射和类型提示
- en: Inspecting the equivalent Java source for Clojure code
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查 Clojure 代码的等效 Java 源代码
- en: Inspecting the equivalent Java source for a given Clojure code provides great
    insight into how that might impact its performance. However, Clojure generates
    only Java bytecodes at runtime unless we compile a namespace out to the disk.
    When developing with Leiningen, only selected namespaces under the `:aot` vector
    in the `project.clj` file are output as the compiled `.class` files containing
    bytecodes. Fortunately, an easy and quick way to know the equivalent Java source
    for the Clojure code is to AOT-compile namespaces and then decompile the bytecodes
    into equivalent Java sources, using a Java bytecode decompiler.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 检查给定 Clojure 代码的等效 Java 源代码可以提供对其性能可能产生影响的深刻见解。然而，除非我们将命名空间编译到磁盘上，否则 Clojure
    仅在运行时生成 Java 字节码。当使用 Leiningen 进行开发时，只有 `project.clj` 文件中 `:aot` 向量下的选定命名空间被输出为包含字节码的编译
    `.class` 文件。幸运的是，有一个简单快捷的方法可以知道 Clojure 代码的等效 Java 源代码，那就是 AOT 编译命名空间，然后使用 Java
    字节码反编译器将字节码反编译成等效的 Java 源代码。
- en: There are several commercial and open source Java bytecode decompilers available.
    One of the open source decompilers we will discuss here is **JD-GUI**, which you
    can download from its website ([http://jd.benow.ca/#jd-gui](http://jd.benow.ca/#jd-gui)).
    Use a version suitable for your operating system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种商业和开源的 Java 字节码反编译器可用。我们将在这里讨论的一个开源反编译器是 **JD-GUI**，你可以从其网站下载（[http://jd.benow.ca/#jd-gui](http://jd.benow.ca/#jd-gui)）。使用适合你操作系统的版本。
- en: Creating a new project
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新项目
- en: 'Let''s see how exactly to arrive at the equivalent Java source code from Clojure.
    Create a new project using Leiningen: `lein new foo`. Then edit the `src/foo/core.clj`
    file with a `mul` function to find out the product of two numbers:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何从 Clojure 代码精确地得到等效的 Java 源代码。使用 Leiningen 创建一个新的项目：`lein new foo`。然后编辑
    `src/foo/core.clj` 文件，添加一个 `mul` 函数来找出两个数字的乘积：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Compiling the Clojure sources into Java bytecode
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Clojure 源代码编译成 Java 字节码
- en: 'Now, to compile Clojure sources into bytecodes and output them as `.class`
    files, run the `lein compile :all` command. It creates the `.class` files in the
    `target/classes` directory of the project as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要编译 Clojure 源代码成字节码并将它们输出为 `.class` 文件，运行 `lein compile :all` 命令。它将在项目的 `target/classes`
    目录下创建 `.class` 文件，如下所示：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see that the `foo.core` namespace has been compiled into four `.class`
    files.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 `foo.core` 命名空间已经被编译成了四个 `.class` 文件。
- en: Decompiling the .class files into Java source
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 .class 文件反编译成 Java 源代码
- en: Assuming that you have already installed JD-GUI, decompiling the `.class` files
    is as simple as opening them using the JD-GUI application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经安装了 JD-GUI，反编译 `.class` 文件就像使用 JD-GUI 应用程序打开它们一样简单。
- en: '![Decompiling the .class files into Java source](img/B04596_03_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![将 .class 文件反编译成 Java 源代码](img/B04596_03_01.jpg)'
- en: 'On inspection, the code for the `foo.core/mul` function looks as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `foo.core/mul` 函数的代码如下：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is easy to understand from the decompiled Java source that the foo.core/mul
    function is an instance of the core$mul class in the foo package extending the
    clojure.lang.AFunction class. We can also see that the argument types are of the
    Object type in method invoke(Object, Object), which implies the numbers will be
    boxed. In a similar fashion, you can decompile class files of any Clojure code
    to inspect the equivalent Java code. If you can combine this with knowledge about
    Java types and potential reflection and boxing, you can find the suboptimal spots
    in code and focus on what to improve upon.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从反编译的 Java 源代码中很容易理解，foo.core/mul 函数是 foo 包中 core$mul 类的一个实例，该类扩展了 clojure.lang.AFunction
    类。我们还可以看到，在方法调用(Object, Object)中，参数类型是 Object 类型，这意味着数字将被装箱。以类似的方式，你可以反编译任何 Clojure
    代码的类文件来检查等效的 Java 代码。如果你能结合对 Java 类型以及可能的反射和装箱的了解，你就可以找到代码中的次优位置，并专注于需要改进的地方。
- en: Compiling the Clojure source without locals clearing
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在没有本地清除的情况下编译 Clojure 源代码
- en: Note the Java code in the method invoke where it says `x = null; y = null;`
    —how is it possible that the code throws away the arguments, sets them to null,
    and effectively multiplies two null objects? This misleading decompilation happens
    due to locals clearing, a feature of the JVM bytecode implementation of Clojure,
    which has no equivalent in the Java language.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意方法调用中的 Java 代码，其中说 `x = null; y = null;` ——代码是如何丢弃参数、将它们设置为 null 并有效地将两个 null
    对象相乘的呢？这种误导性的反编译是由于本地清除引起的，这是 Clojure JVM 字节码实现的一个特性，在 Java 语言中没有等效功能。
- en: 'Starting with Clojure 1.4, the compiler supports the `:disable-locals-clearing`
    key in the dynamic `clojure.core/*compiler-options*` var that we cannot configure
    in the `project.clj` file. So, we cannot use the `lein compile` command, but we
    can start a **REPL** with the `lein repl` command to compile the classes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Clojure 1.4 版本开始，编译器支持在动态 `clojure.core/*compiler-options*` 变量中使用 `:disable-locals-clearing`
    键，我们无法在 `project.clj` 文件中进行配置。因此，我们无法使用 `lein compile` 命令，但我们可以使用 `lein repl`
    命令启动一个 **REPL** 来编译类：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This generates the class files in the same location as we saw earlier in this
    section, but without `x = null; y = null;` because locals clearing is omitted.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在本节前面看到的相同位置生成类文件，但没有 `x = null; y = null;`，因为省略了本地清除。
- en: Numerics, boxing, and primitives
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值、装箱和原始类型
- en: '**Numerics** are scalars. The discussion on numerics was deferred till this
    chapter for the sole reason that the numerics implementation in Clojure has strong
    Java underpinnings. Since version 1.3, Clojure has settled with 64-bit numerics
    as the default. Now, `long` and `double` are idiomatic and the default numeric
    types. Note that these are primitive Java types, not objects. Primitives in Java
    lead to high performance and have several optimizations associated with them at
    compiler and runtime levels. A local primitive is created on the stack (hence
    does not contribute to heap allocation and GC) and can be accessed directly without
    any kind of dereferencing. In Java, there also exist object equivalents of the
    numeric primitives, known as **boxed numerics**—these are regular objects that
    are allocated on the heap. The boxed numerics are also immutable objects, which
    mean not only does the JVM need to dereference the stored value when reading it,
    but also needs to create a new boxed object when a new value needs to be created.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**数值**是标量。关于数值的讨论被推迟到本章，唯一的原因是 Clojure 中数值的实现有强烈的 Java 基础。从版本 1.3 开始，Clojure
    采用了 64 位数值作为默认值。现在，`long` 和 `double` 是惯用的默认数值类型。请注意，这些是原始的 Java 类型，不是对象。Java 中的原始类型导致高性能，并在编译器和运行时级别具有多个优化。局部原始类型是在栈上创建的（因此不会对堆分配和
    GC 贡献），可以直接访问而无需任何类型的解引用。在 Java 中，也存在数值原始类型的对象等效物，称为 **装箱数值**——这些是分配在堆上的常规对象。装箱数值也是不可变对象，这意味着
    JVM 不仅在读取存储的值时需要解引用，而且在需要创建新值时还需要创建一个新的装箱对象。'
- en: 'It should be obvious that boxed numerics are slower than their primitive equivalents.
    The Oracle HotSpot JVM, when started with the `-server` option, aggressively inlines
    those functions (on frequent invocation) that contain a call to primitive operations.
    Clojure automatically uses **primitive numerics** at several levels. In the `let`
    blocks, `loop` blocks, arrays, and arithmetic operations (`+`, `-`, `*`, `/`,
    `inc`, `dec`, `<`, `<=`, `>`, `>=`), primitive numerics are detected and retained.
    The following table describes the primitive numerics with their boxed equivalents:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，boxed数值比它们的原始等效类型要慢。Oracle HotSpot JVM在启动时使用`-server`选项，会积极内联那些包含对原始操作调用的函数（在频繁调用时）。Clojure在多个级别自动使用**原始数值**。在`let`块、`loop`块、数组以及算术操作（`+`、`-`、`*`、`/`、`inc`、`dec`、`<`、`<=`、`>`、`>=`）中，会检测并保留原始数值。以下表格描述了原始数值及其boxed等效类型：
- en: '| Primitive numeric type | Boxed equivalent |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 原始数值类型 | Boxed等效类型 |'
- en: '| --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| byte (1 byte) | `java.lang.Byte` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 字节型 (1字节) | `java.lang.Byte` |'
- en: '| short (2 bytes) | `java.lang.Short` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 短整型 (2字节) | `java.lang.Short` |'
- en: '| int (4 bytes) | `java.lang.Integer` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 整型 (4字节) | `java.lang.Integer` |'
- en: '| float (4 bytes) | `java.lang.Float` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 浮点型 (4字节) | `java.lang.Float` |'
- en: '| long (8 bytes) | `java.lang.Long` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 长整型 (8字节) | `java.lang.Long` |'
- en: '| double (8 bytes) | `java.lang.Double` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 双精度浮点型 (8字节) | `java.lang.Double` |'
- en: In Clojure, sometimes you may find the numerics are passed or returned as boxed
    objects to or from functions due to the lack of type information at runtime. Even
    if you have no control over such functions, you can coerce the values to be treated
    as primitives. The `byte`, `short`, `int`, `float`, `long`, and `double` functions
    create primitive equivalents from given boxed numeric values.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，有时你可能会发现由于运行时缺少类型信息，数值作为boxed对象传递或从函数返回。即使你无法控制此类函数，你也可以强制转换值以将其视为原始值。`byte`、`short`、`int`、`float`、`long`和`double`函数从给定的boxed数值值创建原始等效值。
- en: 'One of the Lisp traditions is to provide correct ([http://en.wikipedia.org/wiki/Numerical_tower](http://en.wikipedia.org/wiki/Numerical_tower))
    arithmetic implementation. A lower type should not truncate values when overflow
    or underflow happens, but rather should be promoted to construct a higher type
    to maintain correctness. Clojure follows this constraint and provides **autopromotion**
    via prime ([http://en.wikipedia.org/wiki/Prime_(symbol)](http://en.wikipedia.org/wiki/Prime_(symbol)))
    functions: `+''`, `-''`, `*''`, `inc''`, and `dec''`. Autopromotion provides correctness
    at the cost of some performance.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp的传统之一是提供正确的([数值塔](http://en.wikipedia.org/wiki/Numerical_tower))算术实现。当发生溢出或下溢时，低类型不应该截断值，而应该提升到更高类型以保持正确性。Clojure遵循这一约束，并通过素数([素数](http://en.wikipedia.org/wiki/Prime_(symbol)))函数提供**自动提升**：`+'`,
    `-'`, `*'`, `inc'`, 和 `dec'`。自动提升以牺牲一些性能为代价提供了正确性。
- en: There are also arbitrary length or precision numeric types in Clojure that let
    us store unbounded numbers but have poorer performance compared to primitives.
    The `bigint` and `bigdec` functions let us create numbers of arbitrary length
    and precision.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，也存在任意长度或精度的数值类型，允许我们存储无界数字，但与原始类型相比性能较差。`bigint`和`bigdec`函数允许我们创建任意长度和精度的数字。
- en: If we try to carry out any operations with primitive numerics that may result
    in a number beyond its maximum capacity, the operation maintains correctness by
    throwing an exception. On the other hand, when we use the prime functions, they
    autopromote to provide correctness. There is another set of operations called
    unchecked operations, which do not check for overflow or underflow and can potentially
    return incorrect results.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试执行可能超出其最大容量的原始数值操作，操作会通过抛出异常来保持正确性。另一方面，当我们使用素数函数时，它们会自动提升以提供正确性。还有另一组称为不检查操作的操作，这些操作不检查溢出或下溢，可能返回不正确的结果。
- en: 'In some cases, they may be faster than regular and prime functions. Such functions
    are `unchecked-add`, `unchecked-subtract`, `unchecked-multiply`, `unchecked-divide`,
    `unchecked-inc`, and `unchecked-dec`. We can also enable unchecked math behavior
    for regular arithmetic functions using the `*unchecked-math*` var; simply include
    the following in your source code file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，它们可能比常规和素数函数更快。这些函数是`unchecked-add`、`unchecked-subtract`、`unchecked-multiply`、`unchecked-divide`、`unchecked-inc`和`unchecked-dec`。我们还可以通过`*unchecked-math*`变量启用常规算术函数的不检查数学行为；只需在源代码文件中包含以下内容：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: One of the common needs in the arithmetic is the division used to find out the
    quotient and remainder after a natural number division. Clojure's `/` function
    provides a rational number division yielding a ratio, and the `mod` function provides
    a true modular arithmetic division. These functions are slower than the `quot`
    and `rem` functions that compute the division quotient and the remainder, respectively.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在算术运算中，常见的需求之一是用于找出自然数除法后的商和余数的除法。Clojure的`/`函数提供了一个有理数除法，返回一个比例，而`mod`函数提供了一个真正的模除法。这些函数比计算除法商和余数的`quot`和`rem`函数要慢。
- en: Arrays
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: Besides objects and primitives, Java has a special type of collection storage
    structure called **arrays**. Once created, arrays cannot be grown or shrunk without
    copying data and creating another array to hold the result. Array elements are
    always homogeneous in type. The array elements are similar to places where you
    can mutate them to hold new values. Unlike collections such as list and vector,
    arrays can contain primitive elements, which make them a very fast storage mechanism
    without GC overhead.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对象和原始数据类型之外，Java还有一种特殊的集合存储结构，称为**数组**。一旦创建，数组在不需要复制数据和创建另一个数组来存储结果的情况下不能增长或缩小。数组元素在类型上总是同质的。数组元素类似于可以修改它们以保存新值的位置。与列表和向量等集合不同，数组可以包含原始元素，这使得它们在没有GC开销的情况下成为一种非常快速的存储机制。
- en: 'Arrays often form a basis for mutable data structures. For example, Java''s
    `java.lang.ArrayList` implementation uses arrays internally. In Clojure, arrays
    can be used for fast numeric storage and processing, efficient algorithms, and
    so on. Unlike collections, arrays can have one or more dimensions. So you could
    layout data in an array such as a matrix or cube. Let''s see Clojure''s support
    for arrays:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 数组通常是可变数据结构的基础。例如，Java的`java.lang.ArrayList`实现内部使用数组。在Clojure中，数组可用于快速数值存储和处理、高效算法等。与集合不同，数组可以有一个或多个维度。因此，您可以在数组中布局数据，如矩阵或立方体。让我们看看Clojure对数组的支持：
- en: '| Description | Example | Notes |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 描述 | 示例 | 备注 |'
- en: '| --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create array | `(make-array Integer 20)` | Array of type (boxed) integer
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 创建数组 | `(make-array Integer 20)` | 类型为（boxed）整数的数组 |'
- en: '|   | `(make-array Integer/TYPE 20)` | Array of primitive type integer |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|   | `(make-array Integer/TYPE 20)` | 原始类型整数的数组 |'
- en: '|   | `(make-array Long/TYPE 20 10)` | Two-dimensional array of primitive long
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|   | `(make-array Long/TYPE 20 10)` | 原始long类型二维数组 |'
- en: '| Create array of primitives | `(int-array 20)` | Array of primitive integer
    of size 20 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 创建原始数组 | `(int-array 20)` | 大小为20的原始整数数组 |'
- en: '|   | `(int-array [10 20 30 40])` | Array of primitive integer created from
    a vector |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|   | `(int-array [10 20 30 40])` | 从向量创建的原始整数数组 |'
- en: '| Create array from coll | `(to-array [10 20 30 40])` | Array from sequable
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 从集合创建数组 | `(to-array [10 20 30 40])` | 从可序列化创建的数组 |'
- en: '|   | `(to-array-2d [[10 20 30][40 50 60]])` | Two-dimensional array from collection
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|   | `(to-array-2d [[10 20 30][40 50 60]])` | 从集合创建的二维数组 |'
- en: '| Clone an array | `(aclone (to-array [:a :b :c]))` |   |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 克隆数组 | `(aclone (to-array [:a :b :c]))` |   |'
- en: '| Get array element | `(aget array-object 0 3)` | Get element at index [0][3]
    in a 2-D array |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 获取数组元素 | `(aget array-object 0 3)` | 获取2-D数组中索引[0][3]的元素 |'
- en: '| Mutate array element | `(aset array-object 0 3 :foo)` | Set obj :foo at index
    [0][3] in a 2-D array |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 修改数组元素 | `(aset array-object 0 3 :foo)` | 在2-D数组中设置索引[0][3]的值为obj :foo |'
- en: '| Mutate primitive array element | `(aset-int int-array-object 2 6 89)` | Set
    value 89 at index [2][6] in 2-D array |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 修改原始数组元素 | `(aset-int int-array-object 2 6 89)` | 在2-D数组中设置索引[2][6]的值为89
    |'
- en: '| Find length of array | `(alength array-object)` | `alength` is significantly
    faster than count |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 获取数组长度 | `(alength array-object)` | `alength`比`count`要快得多 |'
- en: '| Map over an array | `(def a (int-array [10 20 30 40 50 60]))``(seq``(amap
    a idx ret``(do (println idx (seq ret))``(inc (aget a idx)))))` | Unlike map, `amap`
    returns a non-lazy array, which is significantly faster over array elements. Note
    that `amap` is faster only when properly type hinted. See next section for type
    hinting. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 遍历数组 | `(def a (int-array [10 20 30 40 50 60]))``(seq``(amap a idx ret``(do
    (println idx (seq ret))``(inc (aget a idx)))))` | 与map不同，`amap`返回一个非懒加载的数组，在遍历数组元素时速度要快得多。注意，`amap`只有在正确类型提示的情况下才更快。下一节将介绍类型提示。'
- en: '| Reduce over an array | `(def a (int-array [10 20 30 40 50 60]))``(areduce
    a idx ret 0``(do (println idx ret)``(+ ret idx)))` | Unlike reduce, `areduce`
    is significantly faster over array elements. Note that reduce is faster only when
    properly type hinted. See next section for type hinting. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 对数组进行归约 | `(def a (int-array [10 20 30 40 50 60]))``(areduce a idx ret 0``(do
    (println idx ret)``(+ ret idx)))` | 与归约不同，`areduce`在数组元素上要快得多。请注意，只有当正确类型提示时，归约才更快。下一节将介绍类型提示。|'
- en: '| Cast to primitive arrays | `(ints int-array-object)` | Used with type hinting
    (see next section) |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 转换为原始数组 | `(ints int-array-object)` | 与类型提示一起使用（见下一节）|'
- en: 'Like `int-array` and `ints`, there are functions for other types as well:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与`int-array`和`ints`类似，还有其他类型的函数：
- en: '| Array construction function | Primitive-array casting function | Type hinting
    (does not work for vars) | Generic array type hinting |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 数组构造函数 | 原始数组转换函数 | 类型提示（不适用于变量） | 泛型数组类型提示 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| boolean-array | booleans | `^booleans` | `^"[Z"` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 布尔数组 | booleans | `^booleans` | `^"[Z"` |'
- en: '| byte-array | bytes | `^bytes` | `^"[B"` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 字节型数组 | bytes | `^bytes` | `^"[B"` |'
- en: '| short-array | shorts | `^shorts` | `^"[S"` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 短整型数组 | shorts | `^shorts` | `^"[S"` |'
- en: '| char-array | chars | `^chars` | `^"[C"` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 字符数组 | chars | `^chars` | `^"[C"` |'
- en: '| int-array | ints | `^ints` | `^"[I"` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 整型数组 | ints | `^ints` | `^"[I"` |'
- en: '| long-array | longs | `^longs` | `^"[J"` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 长整型数组 | longs | `^longs` | `^"[J"` |'
- en: '| float-array | floats | `^floats` | `^"[F"` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 浮点数组 | floats | `^floats` | `^"[F"` |'
- en: '| double-array | doubles | `^doubles` | `^"[D"` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 双精度数组 | doubles | `^doubles` | `^"[D"` |'
- en: '| object-array | –– | `^objects` | `^"[Ljava.lang.Object"` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 对象数组 | –– | `^objects` | `^"[Ljava.lang.Object"` |'
- en: Arrays are favored over other data structures mainly due to performance, and
    sometimes due to interop. Extreme care should be taken to type hint the arrays
    and use the appropriate functions to work with them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 数组之所以比其他数据结构更受欢迎，主要是因为性能，有时也因为互操作性。在类型提示数组和使用适当的函数处理它们时，应格外小心。
- en: Reflection and type hints
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射和类型提示
- en: Sometimes, as Clojure is dynamically typed, the Clojure compiler is unable to
    figure out the type of object to invoke a certain method. In such cases, Clojure
    uses **reflection**, which is considerably slower than the direct method dispatch.
    Clojure's solution to this is something called **type hints**. Type hints are
    a way to annotate arguments and objects with static types, so that the Clojure
    compiler can emit bytecodes for efficient dispatch.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，由于Clojure是动态类型的，Clojure编译器无法确定要调用的对象类型。在这种情况下，Clojure使用**反射**，这比直接方法分派要慢得多。Clojure解决这个问题的方法是所谓的**类型提示**。类型提示是一种用静态类型注解参数和对象的方法，这样Clojure编译器就可以生成用于高效分派的字节码。
- en: 'The easiest way to know where to put type hints is to turn on reflection warning
    in the code. Consider this code that determines the length of a string:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 知道在哪里放置类型提示的最简单方法是打开代码中的反射警告。考虑以下确定字符串长度的代码：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the previous snippet, we can clearly see there is a very big difference
    in performance in the code that uses reflection versus the code that does not.
    When working on a project, you may want reflection warning to be turned on for
    all files. You can do it easily in Leiningen. Just put the following entry in
    your `project.clj` file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以清楚地看到，使用反射的代码与不使用反射的代码在性能上有很大的差异。在处理项目时，你可能希望所有文件都打开反射警告。你可以在Leiningen中轻松做到这一点。只需在`project.clj`文件中添加以下条目：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will automatically turn on warning reflection every time you begin any
    kind of invocation via Leiningen in the dev workflow such as REPL and test.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在每次通过Leiningen在开发工作流程中开始任何类型的调用时自动打开警告反射，例如REPL和测试。
- en: An array of primitives
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始数组
- en: 'Recall the examples on `amap` and `areduce` from the previous section. If we
    run them with reflection warning on, we''d be warned that it uses reflection.
    Let''s type hint them:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下前一小节中关于`amap`和`areduce`的例子。如果我们打开反射警告运行它们，我们会收到警告说它们使用了反射。让我们给它们添加类型提示：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that the primitive array hint `^ints` does not work at the var level.
    So, it would not work if you defined the var `a`, as in the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，原始数组提示`^ints`在变量级别不起作用。因此，如果你定义了变量`a`，如下所示，它将不起作用：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This notation is for an array of integers. Other primitive array types have
    similar type hints. Refer to the previous section for type hinting for various
    primitive array types.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示法用于整数数组。其他原始数组类型有类似类型提示。请参考前一小节中关于各种原始数组类型的类型提示。
- en: Primitives
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始类型
- en: 'The type hinting of primitive locals is neither required nor allowed. However,
    you can type hint function arguments as primitives. Clojure allows up to four
    arguments in functions to be type hinted:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 原始局部变量的类型提示既不是必需的，也是不允许的。然而，你可以将函数参数类型提示为原始类型。Clojure允许函数最多有四个参数可以进行类型提示：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Boxing may result in something not always being a primitive. In those cases,
    you can coerce those using respective primitive types.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 封装箱可能会导致某些情况下的结果不是原始类型。在这种情况下，你可以使用相应的原始类型强制转换它们。
- en: Macros and metadata
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宏和元数据
- en: 'In macros, type hinting does not work the way it does in the other parts of
    the code. Since macros are about transforming the **Abstract Syntax Tree** (**AST**),
    we need to have a mental map of the transformation and we should add type hints
    as metadata in the code. For example, if `str-len` is a macro to find the length
    of a string, we make use of the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在宏中，类型提示的方式与其他代码部分不同。由于宏是关于转换**抽象语法树**（**AST**），我们需要有一个心理图来表示转换，并且我们应该在代码中添加类型提示作为元数据。例如，如果`str-len`是一个用于查找字符串长度的宏，我们使用以下代码：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, we alter the metadata of the symbol `s` by tagging it
    with the type `String`, which happens to be the `java.lang.String` class in this
    case. For array types, we can use `[Ljava.lang.String` for an array of string
    objects and similarly for others. If you try to use `str-len` listed previously,
    you may notice this works only when we pass the string bound to a local or a var,
    not as a string literal. To mitigate this, we can write the macro as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过标记类型为`String`来修改符号`s`的元数据，在这个例子中恰好是`java.lang.String`类。对于数组类型，我们可以使用`[Ljava.lang.String`来表示字符串对象的数组，以及其他类似类型。如果你尝试使用之前列出的`str-len`，你可能注意到这仅在将字符串绑定到局部变量或变量时才有效，而不是作为字符串字面量。为了减轻这种情况，我们可以将宏编写如下：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here we bind the argument to a type-hinted gensym local, hence calling `.length`
    on it does not use reflection and there is no reflection warning emitted as such.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将参数绑定到一个类型提示的gensym局部变量，因此调用`.length`时不会使用反射，并且不会发出此类反射警告。
- en: 'Type hinting via metadata also works with functions, albeit in a different
    notation:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过元数据进行的类型提示也适用于函数，尽管符号不同：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Except for the first example in the preceding snippet, they are type hinted
    to return the `java.lang.String` type.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面片段中的第一个示例外，它们都提示返回`java.lang.String`类型。
- en: String concatenation
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串连接
- en: 'The `str` function in Clojure is used to concatenate and convert to string
    tokens. In Java, when we write `"hello" + e`, the Java compiler translates this
    to an equivalent code that uses `StringBuilder` and is considerably faster than
    the `str` function in micro-benchmarks. To obtain close-to-Java performance, in
    Clojure we can use a similar mechanism with a macro directly using Java interop
    to avoid the indirection via the `str` function. The **Stringer** ([https://github.com/kumarshantanu/stringer](https://github.com/kumarshantanu/stringer))
    library adopts the same technique to come up with fast string concatenation in
    Clojure:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure中的`str`函数用于连接和转换成字符串标记。在Java中，当我们编写`"hello" + e`时，Java编译器将其转换为使用`StringBuilder`的等效代码，在微基准测试中比`str`函数快得多。为了获得接近Java的性能，在Clojure中我们可以使用类似的机制，通过宏直接使用Java互操作来避免通过`str`函数的间接操作。**Stringer**
    ([https://github.com/kumarshantanu/stringer](https://github.com/kumarshantanu/stringer))库采用相同的技巧，在Clojure中实现快速字符串连接：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, Stringer also aggressively concatenates the literals during the compile
    phase.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Stringer也在编译阶段积极连接字面量。
- en: Miscellaneous
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 杂项
- en: 'In a type (as in `deftype`), the mutable instance variables can be optionally
    annotated as `^:volatile-mutable` or `^:unsynchronized-mutable`. For example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型（如`deftype`中），可变实例变量可以可选地注解为`^:volatile-mutable`或`^:unsynchronized-mutable`。例如：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Unlike `defprotocol`, the `definterface` macro lets us provide a return type
    hint for methods:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与`defprotocol`不同，`definterface`宏允许我们为方法提供返回类型提示：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `proxy-super` macro (which is used inside the `proxy` macro) is a special
    case where you cannot directly apply a type hint. The reason being that it relies
    on the implicit this object that is automatically created by the `proxy` macro.
    In this case, you must explicitly bind this to a type:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`proxy-super`宏（在`proxy`宏内部使用）是一个特殊情况，你不能直接应用类型提示。原因是它依赖于由`proxy`宏自动创建的隐式`this`对象。在这种情况下，你必须显式地将`this`绑定到一个类型：'
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Type hinting is quite important for performance in Clojure. Fortunately, we
    need to type hint only when required and it's easy to find out when. In many cases,
    a gain from type hinting overshadows the gains from code inlining.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 中，类型提示对于性能非常重要。幸运的是，我们只需要在需要时进行类型提示，并且很容易找出何时需要。在许多情况下，类型提示带来的收益会超过代码内联带来的收益。
- en: Using array/numeric libraries for efficiency
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组/数值库提高效率
- en: You may have noticed in the previous sections, when working with numerics, performance
    depends a lot on whether the data is based on arrays and primitives. It may take
    a lot of meticulousness on the programmer's part to correctly coerce data into
    primitives and arrays at all stages of the computation in order to achieve optimum
    efficiency. Fortunately, the high-performance enthusiasts from the Clojure community
    realized this issue early on and created some dedicated open source libraries
    to mitigate the problem.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到在前面的章节中，当处理数值时，性能很大程度上取决于数据是否基于数组和原始类型。为了实现最佳效率，程序员可能需要在计算的各个阶段都非常细致地将数据正确地强制转换为原始类型和数组。幸运的是，Clojure
    社区的性能爱好者及早意识到这个问题，并创建了一些专门的开源库来减轻这个问题。
- en: HipHip
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HipHip
- en: '**HipHip** is a Clojure library used to work with arrays of primitive types.
    It provides a safety net, that is, it strictly accepts only primitive array arguments
    to work with. As a result, passing silently boxed primitive arrays as arguments
    always results in an exception. HipHip macros and functions rarely need the programmer
    to type hint anything during the operations. It supports arrays of primitive types
    such as `int`, `long`, `float`, and `double`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**HipHip** 是一个用于处理原始类型数组的 Clojure 库。它提供了一个安全网，即它严格只接受原始数组参数来工作。因此，静默传递装箱的原始数组作为参数总是会引发异常。HipHip
    宏和函数很少需要在操作期间程序员进行类型提示。它支持原始类型的数组，如 `int`、`long`、`float` 和 `double`。'
- en: The HipHip project is available at [https://github.com/Prismatic/hiphip](https://github.com/Prismatic/hiphip).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: HipHip 项目可在 [https://github.com/Prismatic/hiphip](https://github.com/Prismatic/hiphip)
    找到。
- en: 'As of writing, HipHip''s most recent version is 0.2.0 that supports Clojure
    1.5.x or above, and is tagged as an Alpha release. There is a standard set of
    operations provided by HipHip for arrays of all of the four primitive types: integer
    array operations are in the namespace `hiphip.int`; double precision array operations
    in `hiphip.double`; and so on. The operations are all type hinted for the respective
    types. All of the operations for `int`, `long`, `float`, and `double` in respective
    namespaces are essentially the same except for the array type:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到编写本文时，HipHip 的最新版本是 0.2.0，支持 Clojure 1.5.x 或更高版本，并标记为 Alpha 版本。HipHip 为所有四种原始类型的数组提供了一套标准操作：整数数组操作在命名空间
    `hiphip.int` 中；双精度数组操作在 `hiphip.double` 中；等等。所有操作都针对相应类型进行了类型提示。在相应命名空间中，`int`、`long`、`float`
    和 `double` 的所有操作基本上是相同的，除了数组类型：
- en: '| Category | Function/macro | Description |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 函数/宏 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Core functions | `aclone` | Like `clojure.core/aclone`, for primitives |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 核心函数 | `aclone` | 类似于 `clojure.core/aclone`，用于原始类型 |'
- en: '|   | `alength` | Like `clojure.core/alength`, for primitives |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|   | `alength` | 类似于 `clojure.core/alength`，用于原始类型 |'
- en: '|   | `aget` | Like `clojure.core/aget`, for primitives |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|   | `aget` | 类似于 `clojure.core/aget`，用于原始类型 |'
- en: '|   | `aset` | Like `clojure.core/aset`, for primitives |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|   | `aset` | 类似于 `clojure.core/aset`，用于原始类型 |'
- en: '|   | `ainc` | Increment array element by specified value |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|   | `ainc` | 将数组元素按指定值增加 |'
- en: '| Equiv hiphip.array operations | `amake` | Make a new array and fill values
    computed by expression |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 等价于 hiphip.array 操作 | `amake` | 使用表达式计算出的值创建一个新的数组并填充 |'
- en: '|   | `areduce` | Like `clojure.core/areduce`, with HipHip array bindings |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|   | `areduce` | 类似于 `clojure.core/areduce`，带有 HipHip 数组绑定 |'
- en: '|   | `doarr` | Like `clojure.core/doseq`, with HipHip array bindings |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '|   | `doarr` | 类似于 `clojure.core/doseq`，带有 HipHip 数组绑定 |'
- en: '|   | `amap` | Like `clojure.core/for`, creates new array |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|   | `amap` | 类似于 `clojure.core/for`，创建一个新的数组 |'
- en: '|   | `afill!` | Like preceding `amap`, but overwrites array argument |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '|   | `afill!` | 类似于前面的 `amap`，但覆盖数组参数 |'
- en: '| Mathy operations | `asum` | Compute sum of array elements using expression
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 数学运算 | `asum` | 使用表达式计算数组元素的总和 |'
- en: '|   | `aproduct` | Compute product of array elements using expression |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|   | `aproduct` | 使用表达式计算数组元素乘积 |'
- en: '|   | `amean` | Compute mean over array elements |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '|   | `amean` | 计算数组元素的平均值 |'
- en: '|   | `dot-product` | Compute dot product of two arrays |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|   | `dot-product` | 计算两个数组的点积 |'
- en: '| Finding minimum/maximum, Sorting | `amax-index` | Find maximum value in array
    and return the index |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 查找最小/最大值、排序 | `amax-index` | 在数组中找到最大值并返回其索引 |'
- en: '|   | `amax` | Find maximum value in array and return it |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|   | `amax` | 在数组中找到最大值并返回它 |'
- en: '|   | `amin-index` | Find minimum value in array and return the index |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|   | `amin-index` | 在数组中找到最小值并返回其索引 |'
- en: '|   | `amin` | Find minimum value in array and return it |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '|   | `amin` | 在数组中找到最小值并返回它 |'
- en: '|   | `apartition!` | Three-way partition of array: less, equal, greater than
    pivot |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|   | `apartition!` | 数组的三角划分：小于、等于、大于枢轴 |'
- en: '|   | `aselect!` | Gather smallest `k` elements at the beginning of array |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|   | `aselect!` | 将最小的`k`个元素聚集到数组的开头 |'
- en: '|   | `asort!` | Sort array in-place using Java''s built-in implementation
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|   | `asort!` | 使用Java的内置实现原地排序数组 |'
- en: '|   | `asort-max!` | Partial in-place sort gathering top `k` elements to the
    end |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|   | `asort-max!` | 部分原地排序，将前`k`个元素聚集到数组末尾 |'
- en: '|   | `asort-min!` | Partial in-place sort gathering min `k` elements to the
    top |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|   | `asort-min!` | 部分原地排序，将最小的`k`个元素聚集到数组顶部 |'
- en: '|   | `apartition-indices!` | Like `apartition!` but mutates index-array instead
    of values |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|   | `apartition-indices!` | 与`apartition!`类似，但修改的是索引数组而不是值 |'
- en: '|   | `aselect-indices!` | Like `aselect!` but mutates index-array instead
    of values |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|   | `aselect-indices!` | 与`aselect!`类似，但修改的是索引数组而不是值 |'
- en: '|   | `asort-indices!` | Like `asort!` but mutates index-array instead of values
    |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|   | `asort-indices!` | 与`asort!`类似，但修改的是索引数组而不是值 |'
- en: '|   | `amax-indices` | Get index-array; last `k` indices pointing to max `k`
    values |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|   | `amax-indices` | 获取索引数组；最后`k`个索引指向最大的`k`个值 |'
- en: '|   | `amin-indices` | Get index-array; first `k` indices pointing to min `k`
    values |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|   | `amin-indices` | 获取索引数组；前`k`个索引指向最小的`k`个值 |'
- en: 'To include HipHip as a dependency in your Leiningen project, specify it in
    `project.clj`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要将HipHip作为依赖项包含在你的Leiningen项目中，请在`project.clj`中指定它：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As an example of how to use HipHip, let''s see how to compute the normalized
    values of an array:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用HipHip的一个示例，让我们看看如何计算数组的归一化值：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Unless we make sure that `xs` is an array of primitive doubles, HipHip will
    throw `ClassCastException` when the type is incorrect, and `IllegalArgumentException`
    in other cases. I recommend exploring the HipHip project to gain more insight
    into using it effectively.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们确保`xs`是一个原始双精度浮点数数组，否则HipHip在类型不正确时会抛出`ClassCastException`，在其他情况下会抛出`IllegalArgumentException`。我建议探索HipHip项目，以获得更多关于如何有效使用它的见解。
- en: primitive-math
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: primitive-math
- en: We can set `*warn-on-reflection*` to true to let Clojure warn us when the reflection
    is used at invocation boundaries. However, when Clojure has to implicitly use
    reflection to perform math, the only resort is to either use a profiler or compile
    the Clojure source down to bytecode, and analyze boxing and reflection with a
    decompiler. This is where the `primitive-math` library helps, by producing extra
    warnings and throwing exceptions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`*warn-on-reflection*`设置为true，让Clojure在调用边界处使用反射时警告我们。然而，当Clojure必须隐式使用反射来执行数学运算时，唯一的解决办法是使用分析器或将Clojure源代码编译成字节码，并使用反编译器分析装箱和反射。这就是`primitive-math`库发挥作用的地方，它通过产生额外的警告并抛出异常来帮助。
- en: The `primitive-math` library is available at [https://github.com/ztellman/primitive-math](https://github.com/ztellman/primitive-math).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`primitive-math`库可在[https://github.com/ztellman/primitive-math](https://github.com/ztellman/primitive-math)找到。'
- en: 'As of writing, primitive-math is at version 0.1.4; you can include it as a
    dependency in your Leiningen project by editing `project.clj` as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 截至撰写本文时，primitive-math版本为0.1.4；你可以通过编辑`project.clj`将其作为依赖项包含在你的Leiningen项目中，如下所示：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following code is how it can be used (recall the example from the *Decompiling
    the .class files into Java source* section):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用它（回想一下*将.class文件反编译成Java源代码*部分的示例）：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: While `primitive-math` is a useful library, the problem it solves is mostly
    taken care of by the boxing detection feature in Clojure 1.7 (see next section
    *Detecting boxed math*). However, this library is still useful if you are unable
    to use Clojure 1.7 or higher.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`primitive-math`是一个有用的库，但它解决的问题大部分已经被Clojure 1.7中的装箱检测功能所处理（参见下一节*检测装箱数学*）。然而，如果你无法使用Clojure
    1.7或更高版本，这个库仍然很有用。
- en: Detecting boxed math
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测装箱数学
- en: '**Boxed math** is hard to detect and is a source of performance issues. Clojure
    1.7 introduces a way to warn the user when boxed math happens. This can be configured
    in the following way:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**装箱数学**难以检测，是性能问题的来源。Clojure 1.7引入了一种在发生装箱数学时警告用户的方法。这可以通过以下方式配置：'
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When working with Leiningen, you can enable boxed math warnings by putting
    the following entry in the `project.clj` file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Leiningen 时，你可以在 `project.clj` 文件中添加以下条目来启用装箱数学警告：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The math operations in `primitive-math` (like HipHip) are implemented via macros.
    Therefore, they cannot be used as higher order functions and, as a consequence,
    may not compose well with other code. I recommend exploring the project to see
    what suits your program use case. Adopting Clojure 1.7 obviates the boxing discovery
    issues by means of a boxed-warning feature.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`primitive-math`（如 HipHip）中的数学运算是通过宏实现的。因此，它们不能用作高阶函数，并且因此可能与其他代码组合不佳。我建议探索该项目，看看什么适合你的程序用例。采用
    Clojure 1.7 通过 boxed-warning 功能消除了装箱发现问题。'
- en: Resorting to Java and native code
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 退回到 Java 和原生代码
- en: In a handful of cases, where the lack of imperative, stack-based, mutable variables
    in Clojure may make the code not perform as well as Java, we may need to evaluate
    alternatives to make it faster. I would advise you to consider writing such code
    directly in Java for better performance.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些情况下，由于 Clojure 中缺乏命令式、基于栈的、可变变量，可能会导致代码的性能不如 Java，我们可能需要评估替代方案以提高性能。我建议你考虑直接用
    Java 编写此类代码以获得更好的性能。
- en: Another consideration is to use native OS capabilities, such as memory-mapped
    buffers ([http://docs.oracle.com/javase/7/docs/api/java/nio/MappedByteBuffer.html](http://docs.oracle.com/javase/7/docs/api/java/nio/MappedByteBuffer.html))
    or files and unsafe operations ([http://highlyscalable.wordpress.com/2012/02/02/direct-memory-access-in-java/](http://highlyscalable.wordpress.com/2012/02/02/direct-memory-access-in-java/)).
    Note that unsafe operations are potentially hazardous and not recommended in general.
    Such times are also an opportunity to consider writing performance-critical pieces
    of code in C or C++ and then access them via the **Java Native Interface** (**JNI**).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个考虑因素是使用原生操作系统功能，例如内存映射缓冲区 ([http://docs.oracle.com/javase/7/docs/api/java/nio/MappedByteBuffer.html](http://docs.oracle.com/javase/7/docs/api/java/nio/MappedByteBuffer.html))
    或文件和不受保护的操作 ([http://highlyscalable.wordpress.com/2012/02/02/direct-memory-access-in-java/](http://highlyscalable.wordpress.com/2012/02/02/direct-memory-access-in-java/))。请注意，不受保护的操作可能具有潜在风险，通常不建议使用。这些时刻也是考虑在
    C 或 C++ 中编写性能关键代码，然后通过 **Java Native Interface**（**JNI**）访问它们的良机。
- en: Proteus – mutable locals in Clojure
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Proteus – Clojure 中的可变局部变量
- en: Proteus is an open source Clojure library that lets you treat a local as a local
    variable, thereby allowing its unsynchronized mutation within the local scope
    only. Note that this library depends on the internal implementation structure
    of Clojure as of Clojure 1.5.1\. The **Proteus** project is available at [https://github.com/ztellman/proteus](https://github.com/ztellman/proteus).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Proteus 是一个开源的 Clojure 库，它允许你将局部变量视为局部变量，从而只允许在局部作用域内进行非同步修改。请注意，这个库依赖于 Clojure
    1.5.1 的内部实现结构。**Proteus** 项目可在 [https://github.com/ztellman/proteus](https://github.com/ztellman/proteus)
    找到。
- en: 'You can include Proteus as a dependency in the Leiningen project by editing
    `project.clj`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过编辑 `project.clj` 将 Proteus 作为依赖项包含在 Leiningen 项目中：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Using Proteus in code is straightforward, as shown in the following code snippet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中使用 Proteus 非常简单，如下代码片段所示：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Since Proteus allows mutation only in the local scope, the following throws
    an exception:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Proteus 只允许在局部作用域中进行修改，以下代码会抛出异常：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The mutable locals are very fast and may be quite useful in tight loops. Proteus
    is unconventional by Clojure idioms, but it may give the required performance
    boost without having to write Java code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 可变局部变量非常快，在紧密循环中可能非常有用。Proteus 在 Clojure 习惯用法上是非传统的，但它可能在不编写 Java 代码的情况下提供所需的性能提升。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Clojure has strong Java interoperability and underpinning, due to which programmers
    can leverage the performance benefits nearing those of Java. For performance-critical
    code, it is sometimes necessary to understand how Clojure interacts with Java
    and how to turn the right knobs. Numerics is a key area where Java interoperability
    is required to get optimum performance. Type hints are another important performance
    trick that is frequently useful. There are several open source Clojure libraries
    that make such activities easier for the programmer.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Clojure 强大的 Java 互操作性和底层支持，程序员可以利用接近 Java 的性能优势。对于性能关键代码，有时有必要了解 Clojure
    如何与 Java 交互以及如何调整正确的旋钮。数值是一个需要 Java 互操作性以获得最佳性能的关键领域。类型提示是另一个重要的性能技巧，通常非常有用。有几个开源的
    Clojure 库使程序员更容易进行此类活动。
- en: In the next chapter, we will dig deeper below Java and see how the hardware
    and the JVM stack play a key role in offering the performance we get, what their
    constraints are, and how to use their understanding to get better performance.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入挖掘Java之下，看看硬件和JVM堆栈如何在提供我们所获得性能方面发挥关键作用，它们的限制是什么，以及如何利用对这些理解的应用来获得更好的性能。
