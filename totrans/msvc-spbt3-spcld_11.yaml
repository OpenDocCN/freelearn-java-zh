- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing Access to APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will see how we can secure access to the APIs and web pages
    exposed by the edge server introduced in the previous chapter. We will learn how
    to use HTTPS to protect against eavesdropping on external access to our APIs,
    and how to use OAuth 2.0 and OpenID Connect to authenticate and authorize users
    and client applications to access our APIs. Finally, we will use HTTP Basic authentication
    to secure access to the discovery server, Netflix Eureka.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the OAuth 2.0 and OpenID Connect standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A general discussion on how to secure the system landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting external communication with HTTPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing access to the discovery server, Netflix Eureka
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a local authorization server to our system landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating and authorizing API access using OAuth 2.0 and OpenID Connect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with the local authorization server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with an external OpenID Connect provider, Auth0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For instructions on how to install the tools used in this book and how to access
    the source code for this book, see:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 21*, *Installation Instructions for macOS*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 22*, *Installation Instructions for Microsoft Windows with WSL 2 and
    Ubuntu*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter11`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to view the changes applied to the source code in this chapter,
    that is, see what it took to secure access to the APIs in the microservice landscape,
    you can compare it with the source code for *Chapter 10*, *Using Spring Cloud
    Gateway to Hide Microservices behind an Edge Server*. You can use your favorite
    `diff` tool and compare the two folders, `$BOOK_HOME/Chapter10` and `$BOOK_HOME/Chapter11`.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to OAuth 2.0 and OpenID Connect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before introducing OAuth 2.0 and OpenID Connect, let’s clarify what we mean
    by authentication and authorization. **Authentication** means identifying a user
    by validating credentials supplied by the user, such as a username and password.
    **Authorization** is about giving access to various parts of, in our case, an
    API to an authenticated user.
  prefs: []
  type: TYPE_NORMAL
- en: '**OAuth 2.0** is an open standard for **authorization delegation**, and **OpenID
    Connect** is an add-on to OAuth 2.0 that enables client applications to verify
    the identity of users based on the authentication performed by the authorization
    server. Let’s look briefly at OAuth 2.0 and OpenID Connect separately to get an
    initial understanding of their purposes!'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing OAuth 2.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OAuth 2.0 is a widely accepted open standard for authorization that enables
    a user to give consent for a third-party client application to access protected
    resources in the name of the user. Giving a third-party client application the
    right to act in the name of a user, for example, calling an API, is known as **authorization
    delegation**.
  prefs: []
  type: TYPE_NORMAL
- en: So, what does this mean?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by sorting out the concepts used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource owner**: The end user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: The third-party client application, for example, a web app or a
    native mobile app, that wants to call some protected APIs in the name of the end
    user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource server**: The server that exposes the APIs that we want to protect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization server**: The authorization server issues tokens to the client
    after the resource owner, that is, the end user, has been authenticated. The management
    of user information and the authentication of users are typically delegated, behind
    the scenes, to an **Identity Provider** (**IdP**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client is registered in the authorization server and is given a **client ID**
    and a **client secret**. The client secret must be protected by the client, like
    a password. A client also gets registered with a set of allowed **redirect URIs**
    that the authorization server will use after a user has been authenticated to
    send **authorization codes** and **tokens** that have been issued back to the
    client application.
  prefs: []
  type: TYPE_NORMAL
- en: The following is an example by way of illustration. Let’s say that a user accesses
    a third-party client application and the client application wants to call a protected
    API to serve the user. To be allowed to access these APIs, the client application
    needs a way to tell the APIs that it is acting in the name of the user. To avoid
    solutions where the user must share their credentials with the client application
    for authentication, an **access token** is issued by an authorization server that
    gives the client application limited access to a selected set of APIs in the name
    of the user.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the user never has to reveal their credentials to the client
    application. The user can also give consent to the client application to access
    specific APIs on behalf of the user. An access token represents a time-constrained
    set of access rights, expressed as **scopes** in OAuth 2.0 terms. A **refresh
    token** can also be issued to a client application by the authorization server.
    A refresh token can be used by the client application to obtain new access tokens
    without having to involve the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OAuth 2.0 specification defines four authorization grant flows for issuing
    access tokens, explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authorization code grant flow**: This is the safest, but also the most complex,
    grant flow. This grant flow requires that the user interacts with the authorization
    server using a web browser for authentication and giving consent to the client
    application, as illustrated by the following diagram:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19825_11_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: OAuth 2.0 – authorization code grant flow'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what’s going on in this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: The client application initiates the grant flow by sending the user to the authorization
    server in the web browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The authorization server will authenticate the user and ask for the user’s consent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The authorization server will redirect the user back to the client application
    with an authorization code. The authorization server will use a **redirect URI**
    specified by the client in *step 1* to know where to send the authorization code.
    Since the authorization code is passed back to the client application using the
    web browser, that is, to an unsecure environment where malicious JavaScript code
    can potentially pick up the authorization code, it is only allowed to be used
    once and only during a short time period.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To exchange the authorization code for an access token, the client application
    is expected to call the authorization server again. The client application must
    present its client ID and client secret together with the authorization code for
    the authorization server. Since the client secret is sensitive and must be protected,
    this call must be executed from server-side code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The authorization server issues an access token and sends it back to the client
    application. The authorization server can also, optionally, issue and return a
    refresh token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the access token, the client can send a request to the protected API exposed
    by the resource server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resource server validates the access token and serves the request in the
    event of a successful validation. *Steps 6* and *7* can be repeated as long as
    the access token is valid. When the lifetime of the access token has expired,
    the client can use their refresh token to acquire a new access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implicit grant flow**: This flow is also web browser-based but intended for
    client applications that are not able to keep a client secret protected, for example,
    a single-page web application. The web browser gets an access token back from
    the authorization server instead of an authorization code. Since the implicit
    grant flow is less secure than the authorization code grant flow, the client can’t
    request a refresh token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource owner password credentials grant flow**: If a client application
    can’t interact with a web browser, it can fall back on this grant flow. In this
    grant flow, the user must share their credentials with the client application
    and the client application will use these credentials to acquire an access token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client credentials grant flow**: In the case where a client application needs
    to call an API unrelated to a specific user, it can use this grant flow to acquire
    an access token using its own client ID and client secret.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The full specification can be found here: [https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749).
    There are also a number of additional specifications that detail various aspects
    of OAuth 2.0; for an overview, refer to [https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/](https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/).
    One additional specification that is worth some extra attention is *RFC 7636 –
    Proof Key for Code Exchange by OAuth Public Clients* (or **PKCE** for short),
    [https://tools.ietf.org/html/rfc7636](https://tools.ietf.org/html/rfc7636).'
  prefs: []
  type: TYPE_NORMAL
- en: This specification describes how an otherwise unsecure public client, such as
    a mobile native app or desktop application, can utilize the authorization code
    grant flow in a secure way by adding an extra layer of security.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OAuth 2.0 specification was published in 2012, and over the years, a lot
    of lessons have been learned about what works and what does not. In 2019, work
    began to establish OAuth 2.1, consolidating all the best practices and experiences
    from using OAuth 2.0\. A draft version can be found here: [https://tools.ietf.org/html/draft-ietf-oauth-v2-1-08](https://tools.ietf.org/html/draft-ietf-oauth-v2-1-08).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In my opinion, the most important improvements in OAuth 2.1 are:'
  prefs: []
  type: TYPE_NORMAL
- en: PKCE is integrated into the authorization code grant flow. The use of PKCE will
    be required by public clients to improve their security, as described above. For
    confidential clients, where the authorization server can verify their credentials,
    the use of PKCE is not required, only recommended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implicit grant flow is deprecated and omitted from the specification, due
    to its less secure nature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resource owner password credentials grant flow is also deprecated and omitted
    from the specification, for the same reasons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the direction in the upcoming OAuth 2.1 specification, we will only use
    the authorization code grant flow and the client credentials grant flow in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to automating tests against APIs that are protected by OAuth 2.0,
    the client credentials grant flow is very handy since it doesn’t require manual
    interaction using a web browser. We will use this grant flow later on in this
    chapter with our test script; see the *Changes in the test script* section.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing OpenID Connect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenID Connect (abbreviated to **OIDC**) is, as has already been mentioned,
    an add-on to OAuth 2.0 that enables client applications to verify the identity
    of users. OIDC adds an extra token, an ID token, that the client application gets
    back from the authorization server after a completed grant flow.
  prefs: []
  type: TYPE_NORMAL
- en: The ID token is encoded as a **JSON Web Token** (**JWT**) and contains a number
    of claims, such as the ID and email address of the user. The ID token is digitally
    signed using JSON web signatures. This makes it possible for a client application
    to trust the information in the ID token by validating its digital signature using
    public keys from the authorization server.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, access tokens can also be encoded and signed in the same way as
    ID tokens, but it is not mandatory, according to the specification. Also important,
    OIDC defines a **discovery endpoint**, which is a standardized way to establish
    URLs to important endpoints, such as requesting authorization codes and tokens
    or getting the public keys to verify a digitally signed JWT. Finally, it also
    defines a **user-info endpoint**, which can be used to get extra information about
    an authenticated user given an access token for that user.
  prefs: []
  type: TYPE_NORMAL
- en: For an overview of the available specifications, see [https://openid.net/developers/specs/](https://openid.net/developers/specs/).
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will only use authorization servers that comply with the OpenID
    Connect specification. This will simplify the configuration of resource servers
    by the use of their discovery endpoints. We will also use the optional support
    for digitally signed JWT access tokens to simplify how resource servers can verify
    the authenticity of the access tokens. See the *Changes in both the edge server
    and the product-composite service* section below.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our introduction to the OAuth 2.0 and OpenID Connect standards.
    Later on in this chapter, we will learn more about how to use these standards.
    In the next section, we will get a high-level view of how the system landscape
    will be secured.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the system landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To secure the system landscape as described in the introduction to this chapter,
    we will perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Encrypt external requests and responses to and from our external API using HTTPS
    to protect against eavesdropping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authenticate and authorize users and client applications that access our APIs
    using OAuth 2.0 and OpenID Connect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Secure access to the discovery server, Netflix Eureka, using HTTP basic authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will only apply HTTPS for external communication to our edge server, using
    plain HTTP for communication inside our system landscape.
  prefs: []
  type: TYPE_NORMAL
- en: In the chapter on service meshes (*Chapter 18*, *Using a Service Mesh to Improve
    Observability and Management*) that will appear later in this book, we will see
    how we can get help from a service mesh product to automatically provision HTTPS
    to secure communication inside a system landscape.
  prefs: []
  type: TYPE_NORMAL
- en: For test purposes, we will add a local OAuth 2.0 authorization server to our
    system landscape. All external communication with the authorization server will
    be routed through the edge server. The edge server and the `product-composite`
    service will act as OAuth 2.0 resource servers; that is, they will require a valid
    OAuth 2.0 access token to allow access.
  prefs: []
  type: TYPE_NORMAL
- en: To minimize the overhead of validating access tokens, we will assume that they
    are encoded as signed JWTs and that the authorization server exposes an endpoint
    that the resource servers can use to access the public keys, also known as a **JSON
    Web Key Set**, or **jwk-set** for short, required to validate the signing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system landscape will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19825_11_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Adding an authorization server to the system landscape'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding diagram, we can note that:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS is used for external communication, while plain text HTTP is used inside
    the system landscape.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The local OAuth 2.0 authorization server will be accessed externally through
    the edge server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both the edge server and the `product-composite` microservice will validate
    access tokens as signed JWTs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The edge server and the `product-composite` microservice will get the authorization
    server’s public keys from its `jwk-set` endpoint and use them to validate the
    signature of the JWT-based access tokens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we will focus on securing access to APIs over HTTP, not on covering
    general best practices for securing web applications, for example, managing web
    application security risks pointed out by the **OWASP Top Ten Project**. Refer
    to [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: With this overview of how the system landscape will be secured, let’s start
    to see how we can protect external communication from eavesdropping using HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting external communication with HTTPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to prevent eavesdropping on external communication,
    for example, from the internet, via the public APIs exposed by the edge server.
    We will use HTTPS to encrypt communication. To use HTTPS, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a certificate**: We will create our own self-signed certificate, sufficient
    for development purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configure the edge server**: It has to be configured to accept only HTTPS-based
    external traffic using the certificate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The self-signed certificate is created with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The source code comes with a sample certificate file, so you don’t need to run
    this command to run the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: The command will ask for a number of parameters. When asked for a password,
    I entered `password`. For the rest of the parameters, I simply entered an empty
    value to accept the default value. The certificate file created, `edge.p12`, is
    placed in the `gateway` projects folder, `src/main/resources/keystore`. This means
    that the certificate file will be placed in the `.jar` file when it is built and
    will be available on the classpath at runtime at `keystore/edge.p12`.
  prefs: []
  type: TYPE_NORMAL
- en: Providing certificates using the classpath is sufficient during development,
    but not applicable to other environments, for example, a production environment.
    See the *Replacing a self-signed certificate at runtime* section below for how
    we can replace this certificate with an external certificate at runtime!
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the edge server to use the certificate and HTTPS, the following
    is added to `application.yml` in the `gateway` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Some notes from the preceding source code:'
  prefs: []
  type: TYPE_NORMAL
- en: The path to the certificate is specified in the `server.ssl.key-store` parameter,
    and is set to `classpath:keystore/edge.p12`. This means that the certificate will
    be picked up on the classpath from the location `keystore/edge.p12`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The password for the certificate is specified in the `server.ssl.key-store-password`
    parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To indicate that the edge server talks HTTPS and not HTTP, we also change the
    port from `8080` to `8443` in the `server.port` parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to these changes in the edge server, changes are also required
    in the following files to reflect the changes to the port and HTTP protocol, replacing
    `HTTP` with `HTTPS` and `8080` with `8443`:'
  prefs: []
  type: TYPE_NORMAL
- en: The three Docker Compose files, `docker-compose*.yml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test script, `test-em-all.bash`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing certificates using the classpath is, as mentioned previously, only
    sufficient during development. Let’s see how we can replace this certificate with
    an external certificate at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing a self-signed certificate at runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Placing a self-signed certificate in the `.jar` file is only useful for development.
    For a working solution in runtime environments, for example, for test or production,
    it must be possible to use certificates signed by authorized **CAs** (short for
    **Certificate Authorities**).
  prefs: []
  type: TYPE_NORMAL
- en: It must also be possible to specify the certificates to be used during runtime
    without the need to rebuild the `.jar` files and, when using Docker, the Docker
    image that contains the `.jar` file. When using Docker Compose to manage the Docker
    container, we can map a volume in the Docker container to a certificate that resides
    on the Docker host. We can also set up environment variables for the Docker container
    that points to the external certificate in the Docker volume.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 15*, *Introduction to Kubernetes*, we will learn about Kubernetes,
    where we will see more powerful solutions for how to handle secrets, such as certificates,
    that are suitable for running Docker containers in a cluster; that is, where containers
    are scheduled on a group of Docker hosts and not on a single Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: The changes described in this topic have **not** been applied to the source
    code in the book’s GitHub repository; you need to make them yourself to see them
    in action!
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace the certificate packaged in the `.jar` file, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a second certificate and set the password to `testtest` when asked for
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the Docker Compose file, `docker-compose.yml`, with environment variables
    for the location, the password for the new certificate, and a volume that maps
    to the folder where the new certificate is placed. The configuration of the edge
    server will look like the following after the change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the edge server is up and running, it needs to be restarted with the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `docker-compose restart gateway` command might look like a good candidate
    for restarting the gateway service, but it actually does not take changes in `docker-compose.yml`
    into consideration. Hence, it is not a useful command in this case.
  prefs: []
  type: TYPE_NORMAL
- en: The new certificate is now in use!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This concludes the section on how to protect external communication with HTTPS.
    In the next section, we will learn how to secure access to the discovery server,
    Netflix Eureka, using HTTP Basic authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Securing access to the discovery server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we learned how to protect external communication with HTTPS. Now
    we will use HTTP Basic authentication to restrict access to the APIs and web pages
    on the discovery server, Netflix Eureka. This means that we will require a user
    to supply a username and password to get access. Changes are required both on
    the Eureka server and in the Eureka clients, described as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the Eureka server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To protect the Eureka server, the following changes have been applied to the
    source code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `build.gradle`, a dependency has been added for Spring Security:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Security configuration has been added to the `SecurityConfig` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The user is defined as follows:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The `username` and `password` are injected into the constructor from the configuration
    file:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'All APIs and web pages are protected using HTTP Basic authentication by means
    of the following definition:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Credentials for the user are set up in the configuration file, `application.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the test class, `EurekaServerApplicationTests`, uses the credentials
    from the configuration file when testing the APIs of the Eureka server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The above are the steps required for restricting access to the APIs and web
    pages of the discovery server, Netflix Eureka. It will now use HTTP Basic authentication
    and require a user to supply a username and password to get access. The last step
    is to configure Netflix Eureka clients so that they pass credentials when accessing
    the Netflix Eureka server.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Eureka clients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Eureka clients, the credentials can be specified in the connection URL
    for the Eureka server. This is specified in each client’s configuration file,
    `application.yml`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the section on how to restrict access to the Netflix Eureka server.
    In the *Testing the protected discovery server* section, we will run tests to
    verify that the access is protected. In the next section, we will learn how to
    add a local authorization server to the system landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a local authorization server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to run tests locally and fully automated with APIs that are secured
    using OAuth 2.0 and OpenID Connect, we will add an authorization server that is
    compliant with these specifications to our system landscape. Historically, Spring
    Security has not provided an authorization server out of the box. But in April
    2020, a community-driven project, **Spring Authorization Server**, led by the
    Spring Security team, was announced with the goal of delivering an authorization
    server. In August 2021, the Spring Authorization Server project was moved out
    of experimental status and became a member of the Spring project’s portfolio.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, see [https://spring.io/blog/2020/04/15/announcing-the-spring-authorization-server](https://spring.io/blog/2020/04/15/announcing-the-spring-authorization-server)
    and [https://spring.io/blog/2021/08/17/spring-authorization-server-officially-moves-to-spring-projects](https://spring.io/blog/2021/08/17/spring-authorization-server-officially-moves-to-spring-projects).
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Authorization Server supports both the use of the OpenID Connect
    discovery endpoint and the digital signing of access tokens. It also provides
    an endpoint that can be accessed using the discovery information to get keys for
    verifying the digital signature of a token. With support for these features, it
    can be used as the authorization server in local and automated tests that verify
    that the system landscape works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The authorization server in this book is based on the sample authorization server
    provided by the Spring Authorization Server project; see [https://github.com/spring-projects/spring-authorization-server/tree/main/samples/default-authorizationserver](https://github.com/spring-projects/spring-authorization-server/tree/main/samples/default-authorizationserver).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following changes have been applied to the sample project:'
  prefs: []
  type: TYPE_NORMAL
- en: The build file has been updated to follow the structure of the other projects’
    build files in this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The port is set to `9999`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Dockerfile has been added with the same structure as for the other projects
    in this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The authorization server has been integrated with Eureka for service discovery
    in the same way as the other projects in this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public access has been added to the actuator’s endpoints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WARNING**: As already warned about in *Chapter 7*, *Developing Reactive Microservices*,
    allowing public access to the actuator’s endpoints is very helpful during development,
    but it can be a security issue to reveal too much information in actuator endpoints
    in production systems. Therefore, plan for minimizing the information exposed
    by the actuator endpoints in production!'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests have been added that verify access to the most critical endpoints
    according to the OpenID Connect specification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The username and password for the single registered user are set to `u` and
    `p`, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two OAuth clients are registered, `reader` and `writer`. The `reader` client
    is granted a `product:read` scope, and the `writer` client is granted both a `product:read`
    and `product:write` scope. The clients are configured to have their client secret
    set to `secret-reader` and `secret-writer`, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowed redirect URIs for the clients are set to `https://my.redirect.uri` and
    `https://localhost:8443/webjars/swagger-ui/oauth2-redirect.html`. The first URI
    will be used in the tests described below, and the second URI will be used by
    the Swagger UI component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, for security reasons, the authorization server does not allow redirect
    URIs that start with `https://localhost`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The authorization server has been customized to accept `https://localhost`
    for development and testing purposes. The applied customization is described here:
    [https://docs.spring.io/spring-authorization-server/docs/1.0.0/reference/html/protocol-endpoints.html#oauth2-authorization-endpoint-customizing-authorization-request-validation](https://docs.spring.io/spring-authorization-server/docs/1.0.0/reference/html/protocol-endpoints.html#oauth2-authorization-endpoint-customizing-authorization-request-validation).'
  prefs: []
  type: TYPE_NORMAL
- en: The source code for the authorization server is available in `$BOOK_HOME/Chapter11/spring-cloud/authorization-server`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To incorporate the authorization server in the system landscape, changes to
    the following files have been applied:'
  prefs: []
  type: TYPE_NORMAL
- en: The server has been added to the common build file, `settings.gradle`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server has been added to the three Docker Compose files, `docker-compose*.yml`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The edge server, `spring-cloud/gateway`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A health check has been added for the authorization server in `HealthCheckConfiguration`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routes to the authorization server for the URIs starting with `/oauth`, `/login`,
    and `/error` have been added in the configuration file, `application.yml`. These
    URIs are used to issue tokens for clients, authenticate users, and show error
    messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since these three URIs need to be unprotected by the edge server, they are configured
    in the new class `SecurityConfig` to permit all requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With an understanding of how a local authorization server is added to the system
    landscape, let’s move on and see how to use OAuth 2.0 and OpenID Connect to authenticate
    and authorize access to APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting APIs using OAuth 2.0 and OpenID Connect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the authorization server in place, we can enhance the edge server and
    the `product-composite` service to become OAuth 2.0 resource servers, so that
    they will require a valid access token to allow access. The edge server will be
    configured to accept any access token it can validate using the digital signature
    provided by the authorization server. The `product-composite` service will also
    require the access token to contain valid OAuth 2.0 scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `product:read` scope will be required for accessing the read-only APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `product:write` scope will be required for accessing the create and delete
    APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `product-composite` service will also be enhanced with a configuration that
    allows its Swagger UI component to interact with the authorization server to issue
    an access token. This will allow users of the Swagger UI web page to test the
    protected API.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to enhance the test script, `test-em-all.bash`, so that it acquires
    access tokens and uses them when it performs the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in both the edge server and the product-composite service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following changes have been applied in the source code for both the edge
    server and the `product-composite` service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security dependencies have been added to `build.gradle` to support OAuth
    2.0 resource servers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Security configurations have been added to new `SecurityConfig` classes in
    both projects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Explanations for the preceding source code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@EnableWebFluxSecurity` annotation enables Spring Security support for
    APIs based on Spring WebFlux.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.pathMatchers("/actuator/**").permitAll()` is used to allow unrestricted access
    to URLs that should be unprotected, for example, the `actuator` endpoints, in
    this case. Refer to the source code for URLs that are treated as unprotected.
    Be careful about which URLs are exposed unprotected. For example, the `actuator`
    endpoints should be protected before going to production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.anyExchange().authenticated()` ensures that the user is authenticated before
    being allowed access to all other URLs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.oauth2ResourceServer().jwt()` specifies that authorization will be based
    on OAuth 2.0 access tokens encoded as JWTs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The authorization server’s OIDC discovery endpoint has been registered in the
    configuration file, `application.yml`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: L
  prefs: []
  type: TYPE_NORMAL
- en: 'Later on in this chapter, when the system landscape is started up, you can
    test the discovery endpoint. You can, for example, find the endpoint that returns
    the keys required for verifying the digital signature of a token using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We also need to make some changes that only apply to the `product-composite`
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the product-composite service only
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the common changes applied in the previous section, the following
    changes have also been applied to the `product-composite` service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The security configuration in the `SecurityConfig` class has been refined by
    requiring OAuth 2.0 scopes in the access token in order to allow access:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By convention, OAuth 2.0 scopes need to be prefixed with `SCOPE_` when checked
    for authority using Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: A method, `logAuthorizationInfo()`, has been added to log relevant parts from
    the JWT-encoded access token upon each call to the API. The access token can be
    acquired using the standard Spring Security `SecurityContext`, which, in a reactive
    environment, can be acquired using the static helper method, `ReactiveSecurityContextHolder.getContext()`.
    Refer to the `ProductCompositeServiceImpl` class for details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The use of OAuth has been disabled when running Spring-based integration tests.
    To prevent the OAuth machinery from kicking in when we are running integration
    tests, we disable it as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A security configuration, `TestSecurityConfig`, is added to be used during
    tests. It permits access to all resources:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'In each Spring integration test class, we configure `TestSecurityConfig` to
    override the existing security configuration with the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Changes to allow Swagger UI to acquire access tokens
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To allow access to the protected APIs from the Swagger UI component, the following
    changes have been applied in the `product-composite` service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The web pages exposed by the Swagger UI component have been configured to be
    publicly available. The following line has been added to the `SecurityConfig`
    class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The OpenAPI Specification of the API has been enhanced to require that the security
    schema `security_auth` is applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following line has been added to the definition of the interface `ProductCompositeService`
    in the `API` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To define the semantics of the security schema `security_auth`, the class `OpenApiConfig`
    has been added to the `product-composite` project. It looks like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From the preceding class definition, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: The security schema will be based on OAuth 2.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The authorization code grant flow will be used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The required URLs for acquiring an authorization code and access tokens will
    be supplied by the configuration using the parameters `springdoc.oAuthFlow.authorizationUrl`
    and `springdoc.oAuthFlow.tokenUrl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A list of scopes (`product:read` and `product:write`) that Swagger UI will require
    to be able to call the APIs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, some configuration is added to `application.yml`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From the preceding configuration, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: The redirect URL that Swagger UI will use to acquire the authorization code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Its client ID and client secret.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will use HTTP Basic authentication when identifying itself for the authorization
    server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The values of the `authorizationUrl` and `tokenUrl` parameters, used by the
    `OpenApiConfig` class described above. Note that these URLs are used by the web
    browser and not by the `product-composite` service itself. So they must be resolvable
    from the web browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To allow unprotected access to the Swagger UI web pages, the edge server has
    also been configured to allow unrestricted access to URLs that are routed to the
    Swagger UI component. The following is added to the edge server’s `SecurityConfig`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With these changes in place, both the edge server and the `product-composite`
    service can act as OAuth 2.0 resource servers, and the Swagger UI component can
    act as an OAuth client. The last step we need to take to introduce the usage of
    OAuth 2.0 and OpenID Connect is to update the test script so it acquires access
    tokens and uses them when running the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the test script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start with, we need to acquire an access token before we can call any of
    the APIs, except the health API. This is done, as already mentioned above, using
    the OAuth 2.0 client credentials flow. To be able to call the create and delete
    APIs, we acquire an access token as the `writer` client, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding command, we can see that it uses HTTP Basic authentication,
    passing its client ID and client secret as `writer:secret-writer@` before the
    hostname.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that the scope-based authorization works, two tests have been added
    to the test script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The test script uses the reader client’s credentials to acquire an access token:'
  prefs: []
  type: TYPE_NORMAL
- en: The first test calls an API without supplying an access token. The API is expected
    to return the `401 Unauthorized` HTTP status.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second test verifies that the reader client can call a read-only API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last test calls an updating API using the `reader` client, which is only
    granted a `read` scope. A request sent to the delete API is expected to return
    the `403 Forbidden` HTTP status.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the full source code, see `test-em-all.bash`.
  prefs: []
  type: TYPE_NORMAL
- en: With the test script updated to acquire and use OAuth 2.0 access tokens, we
    are ready to try it out in the next section!
  prefs: []
  type: TYPE_NORMAL
- en: Testing with the local authorization server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will try out the secured system landscape; that is, we
    will test all the security components together. We will use the local authorization
    server to issue access tokens. The following tests will be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we build from source and run the test script to ensure that everything
    fits together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will test the protected discovery server’s API and web page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we will learn how to acquire access tokens using OAuth 2.0 client
    credentials and authorization code grant flows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the issued access tokens, we will test the protected APIs. We will also
    verify that an access token issued for a reader client can’t be used to call an
    updating API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will also verify that Swagger UI can issue access tokens and call
    the APIs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building and running the automated tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build and run automated tests, we perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the Docker images from source with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the system landscape in Docker and run the usual tests with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the new negative tests at the end that verify that we get a `401 Unauthorized`
    code back when not authenticated, and `403 Forbidden` when not authorized.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the protected discovery server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the protected discovery server, Eureka, up and running, we have to supply
    valid credentials to be able to access its APIs and web pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, asking the Eureka server for registered instances can be done
    by means of the following `curl` command, where we supply the username and password
    directly in the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample response is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_11_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Services registered in Eureka using an API call'
  prefs: []
  type: TYPE_NORMAL
- en: 'When accessing the web page on `https://localhost:8443/eureka/web`, we first
    have to accept an unsecure connection, since our certificate is self-signed, and
    next, we have to supply valid credentials, as specified in the configuration file
    (`u` as username and `p` as password):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface  Description automatically generated](img/B19825_11_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: Eureka requires authentication'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following a successful login, we will see the familiar web page from the Eureka
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table  Description automatically generated with medium confidence](img/B19825_11_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Services registered in Eureka using the web page'
  prefs: []
  type: TYPE_NORMAL
- en: After ensuring that access to the Eureka server is protected, we will learn
    how to issue OAuth access tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring access tokens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we are ready to acquire access tokens using grant flows defined by OAuth
    2.0\. We will first try out the client credentials grant flow, followed by the
    authorization code grant flow.
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring access tokens using the client credentials grant flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get an access token for the `writer` client, that is, with both the `product:read`
    and `product:write` scopes, issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The client identifies itself using HTTP Basic authentication, passing its client
    ID, `writer`, and its client secret, `secret`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample response is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_11_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: Sample token response'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the screenshot, we can see that we got the following information in the
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: The access token itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scopes granted to the token. The `writer` client is granted both the `product:write`
    and `product:read` scope. It is also granted the `openid` scope, allowing access
    to information regarding the user’s ID, such as an email address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of token we got; `Bearer` means that the bearer of this token should
    be given access according to the scopes granted to the token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of seconds that the access token is valid, `3599` seconds in this
    case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get an access token for the `reader` client, that is, with only the `product:read`
    scope, simply replace `writer` with `reader` in the preceding command, resulting
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Acquiring access tokens using the authorization code grant flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To acquire an access token using the authorization code grant flow, we need
    to involve a web browser. This grant flow is a bit more complicated in order to
    make it secure in an environment that is partly unsecure (the web browser).
  prefs: []
  type: TYPE_NORMAL
- en: In the first unsecure step, we will use the web browser to acquire an authorization
    code that can be used only once, to be exchanged for an access token. The authorization
    code will be passed from the web browser to a secure layer, for example, server-side
    code, which can make a new request to the authorization server to exchange the
    authorization code for an access token. In this secure exchange, the server has
    to supply a client secret to verify its identity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to execute the authorization code grant flow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an authorization code for the `reader` client, use the following URL
    in a web browser that accepts the use of self-signed certificates, for example,
    Chrome: `https://localhost:8443/oauth2/authorize?response_type=code&client_id=reader&redirect_uri=https://my.redirect.uri&scope=product:read&state=35725`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When asked to log in by the web browser, use the credentials specified in the
    configuration of the authorization server, `u` and `p`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface  Description automatically generated](img/B19825_11_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: Trying out the authorization code grant flow'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be asked to give the `reader` client consent to call the APIs in our
    name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_11_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: Authorization code grant flow consent page'
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking on the **Submit Consent** button, we will get the following
    response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_11_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.9: Authorization code grant flow redirect page'
  prefs: []
  type: TYPE_NORMAL
- en: 'This might, at first glance, look a bit disappointing. The URL that the authorization
    server sent back to the web browser is based on the redirect URI specified by
    the client in the initial request. Copy the URL into a text editor and you will
    find something similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`https://my.redirect.uri/?code=7XBs...0mmyk&state=35725`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Great! We can find the authorization code in the redirect URL in the `code`
    request parameter. Extract the authorization code from the `code` parameter and
    define an environment variable, `CODE`, with its value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pretend you are the backend server that exchanges the authorization code with
    an access token using the following `curl` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A sample response is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_11_10.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.10: Authorization code grant flow access token'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'From the screenshot, we can see that we got similar information in the response
    as we got from the client credentials flow, with the following exceptions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we used a more secure grant flow, we also got a `refresh token` issued
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we asked for an access token for the `reader` client, we only got a `product:read`
    scope, no `product:write` scope
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get an authorization code for the `writer` client, use the following URL:
    `https://localhost:8443/oauth2/authorize?response_type=code&client_id=writer&redirect_uri=https://my.redirect.uri&scope=product:read+product:write&state=72489`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To exchange the code for an access token for the `writer` client, run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Verify that the response now also contains the `product:write` scope!
  prefs: []
  type: TYPE_NORMAL
- en: Calling protected APIs using access tokens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s use the access tokens we have acquired to call the protected APIs.
  prefs: []
  type: TYPE_NORMAL
- en: An OAuth 2.0 access token is expected to be sent as a standard HTTP `authorization`
    header, where the access token is prefixed with `Bearer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands to call the protected APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Call an API to retrieve a composite product without a valid access token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It should return the following response:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_11_11.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.11: Invalid token results in a 401 Unauthorized response'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The error message clearly states that the access token is invalid!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Try using the API to retrieve a composite product using one of the access tokens
    acquired for the `reader` client from the previous section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we will get the `200 OK` status code and the expected response body will
    be returned:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_11_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.12: Valid access token results in a 200 OK response'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to access an updating API, for example, the delete API, with an access
    token acquired for the `reader` client, the call will fail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It will fail with a response similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_11_13.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.13: Insufficient scope results in a 403 Forbidden result'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From the error response, it is clear that we are forbidden to call the API since
    the request requires higher privileges than what our access token is granted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we repeat the call to the delete API, but with an access token acquired for
    the `writer` client, the call will succeed with `202 Accepted` in the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `delete` operation should return `202` even if the product with the specified
    product ID does not exist in the underlying database, since the `delete` operation
    is idempotent, as described in *Chapter 6*, *Adding Persistence*. Refer to the
    *Adding new APIs* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look into the log output using the `docker-compose logs -f product-composite`
    command, you should be able to find authorization information such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_11_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.14: Authorization info in the log output'
  prefs: []
  type: TYPE_NORMAL
- en: This information was extracted in the `product-composite` service from the JWT-encoded
    access token; the `product-composite` service did not need to communicate with
    the authorization server to get this information!
  prefs: []
  type: TYPE_NORMAL
- en: With these tests, we have seen how to acquire an access token with the client
    credentials and authorization code grant flows. We have also seen how scopes can
    be used to limit what a client can do with a specific access token, for example,
    only use it for reading operations.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Swagger UI with OAuth 2.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will learn how to use the Swagger UI component to access
    the protected API. The configuration described in the *Changes in the product-composite
    service only* section above allows us to issue an access token for Swagger UI
    and use it when calling the APIs from Swagger UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To try it out, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Swagger UI start page by going to the following URL in a web browser:
    `https://localhost:8443/openapi/swagger-ui.html`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the start page, we can now see a new button, next to the **Servers** drop-down
    list, with the text **Authorize**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Authorize** button to initiate an authorization code grant flow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Swagger UI will present a list of scopes that it will ask the authorization
    server to get access to. Select all scopes by clicking on the link with the text
    **select all** and then clicking on the **Authorize** button:![Graphical user
    interface, application  Description automatically generated](img/B19825_11_15.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.15: Swagger UI asking for OAuth scopes'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You will then be redirected to the authorization server. If you are not already
    logged in from the web browser used, the authorization server will ask for your
    credentials as in the *Acquiring access tokens using the authorization code grant
    flow* section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Log in with username `u` and password `p`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The authorization server will ask for your consent. Select both scopes and click
    on the **Submit Consent** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Swagger UI will complete the authorization process by showing information about
    the completed grant flow. Click on the **Close** button to get back to the start
    page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_11_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.16: Swagger UI summarizing the OAuth grant flow'
  prefs: []
  type: TYPE_NORMAL
- en: Now you can try out the APIs in the same way as described in *Chapter 5*, *Adding
    an API Description Using OpenAPI*. Swagger UI will add the access token to the
    requests. If you look closely at the `curl` command reported below the **Responses**
    header, you can find the access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This completes the tests we will perform with the local authorization server.
    In the next section, we will replace it with an external OpenID Connect-compliant
    provider.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with an external OpenID Connect provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, the OAuth dance works fine with an authorization server we control ourselves.
    But what happens if we replace it with a certified OpenID Connect provider? In
    theory, it should work out of the box. Let’s find out, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: For a list of certified implementations of OpenID Connect, refer to [https://openid.net/developers/certified/](https://openid.net/developers/certified/).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use Auth0, `https://auth0.com/`, for our tests with an external OpenID
    provider. To be able to use Auth0 instead of our own authorization server, we
    will go through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an account with a `reader` and `writer` client and a user in Auth0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the changes required to use Auth0 as an OpenID provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the test script to verify that it is working
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Acquiring access tokens using the following grant flows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client credentials grant flow
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization code grant flow
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling protected APIs using the access tokens acquired from the grant flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the user info endpoint to get more information about a user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us go through each of them in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and configuring an account in Auth0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the configuration required in Auth0 will be taken care of by a script
    that uses Auth0’s management API. But we must perform a few manual steps up to
    the point where Auth0 has created a client ID and client secret we can use to
    access the management API. Auth0’s service is multi-tenant, allowing us to create
    our own domain of OAuth objects in terms of clients, resource owners, and resource
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following manual steps to sign up for a free account in Auth0 and
    create a client that we can use to access the management API:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the URL [https://auth0.com](https://auth0.com) in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **hamburger menu** (☰) in the top-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Sign up** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sign up with an email of your choice.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After a successful sign-up, you will be asked to create a tenant domain. Enter
    the name of the tenant of your choice, in my case: `dev-ml-3rd.eu.auth0.com`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in the information about your account as requested.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, look in your mailbox for an email with the subject **Please Verify Your
    Auth0 Account** and use the instructions in the email to verify your account.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Following sign-up, you will be directed to an **onboarding** page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the menu to the left, click on **Applications** to get it expanded, then
    click on **APIs** to find the management API, **Auth0 Management API**. This API
    was created for you during the creation of your tenant. We will use this API to
    create the required definitions in the tenant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Auth0 Management API** and select the **Test** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A big button with the text **Create & Authorize Test**will appear. Click on
    it to get a client created that can be used to access the management API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once created, a page is displayed with the header **Asking Auth0 for tokens
    from my application**. As a final step, we need to give the created client permission
    to use the management APIs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the tab **Machine to Machine Applications**, next to the **Test** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here we will find the test client, **Auth0 Management API (Test Application)**,
    and we can see that it is authorized to use the management API. If we click on
    the down arrow next to the **Authorized** toggle button, a large number of available
    privileges are revealed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **All** choice and then on the **Update** button. The screen should
    look similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_11_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.17: Auth0 management API client permissions'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Continue** button after understanding that you now have a very
    powerful client with access to all management APIs within your tenant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we just need to collect the client ID and client secret of the created
    client. The easiest way to do that is to select **Applications** in the menu to
    the left (under the main menu choice **Applications**) and then select the application
    named **Auth0 Management API (Test Application)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A screen similar to the following should be displayed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, Teams  Description automatically generated](img/B19825_11_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.18: Auth0 Management API client application information'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file `$BOOK_HOME/Chapter11/auth0/env.bash` and copy the following
    values from the screen above:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Domain** into the value of the variable `TENANT`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Client ID** into the value of the variable `MGM_CLIENT_ID`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Client Secret** into the value of the variable `MGM_CLIENT_SECRET`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete the values required in the `env.bash` file by specifying an email address
    and password, in the variables `USER_EMAIL` and `USER_PASSWORD`, of a test user
    that the script will create for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specifying a password for a user like this is not considered best practice from
    a security perspective. Auth0 supports enrolling users who will be able to set
    the password themselves, but it is more involved to set up. For more information,
    see [https://auth0.com/docs/connections/database/password-change](https://auth0.com/docs/connections/database/password-change).
    Since this is only used for test purposes, specifying a password like this is
    OK.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run the script that will create the following definitions for us:'
  prefs: []
  type: TYPE_NORMAL
- en: Two applications, `reader` and `writer`, or clients in OAuth terminology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `product-composite` API, a resource server in OAuth terminology, with the
    OAuth scopes `product:read` and `product:write`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user, a resource owner in OAuth terminology, that we will use to test the
    authorization code grant flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we will grant the `reader` application the scope `product:read`, and
    the `writer` application the scopes `product:read` and `product:write`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect the following output (details removed from the output below):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_11_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.19: Output from setup-tenant.bash the first time it is executed'
  prefs: []
  type: TYPE_NORMAL
- en: Save a copy of the `export` commands printed at the end of the output; we will
    use them multiple times later on in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look in your mailbox for the email specified for the test user. You will receive
    a mail with the subject **Verify your email***.* Use the instructions in the email
    to verify the test user’s email address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that the script is idempotent, meaning it can be run multiple times without
    corrupting the configuration. If running the script again, it should respond with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19825_11_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.20: Output from setup-tenant.bash the next time it is executed'
  prefs: []
  type: TYPE_NORMAL
- en: It can be very handy to be able to run the script again, for example, to get
    access to the client ID and client secret of the `reader` and `writer`.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to remove the objects created by `setup-tenant.bash`, you can run
    the script `reset-tenant.bash`.
  prefs: []
  type: TYPE_NORMAL
- en: With an Auth0 account created and configured, we can move on and apply the necessary
    configuration changes in the system landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the required changes to use Auth0 as an OpenID provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will learn what configuration changes are required to be
    able to replace the local authorization server with Auth0\. We only need to change
    the configuration for the two services that act as OAuth resource servers, the
    `product-composite` and `gateway` services. We also need to change our test script
    a bit, so that it acquires the access tokens from Auth0 instead of acquiring them
    from our local authorization server. Let’s start with the OAuth resource servers,
    the `product-composite` and `gateway` services.
  prefs: []
  type: TYPE_NORMAL
- en: The changes described in this topic have **not** been applied to the source
    code in the book’s Git repository; you need to make them yourself to see them
    in action!
  prefs: []
  type: TYPE_NORMAL
- en: Changing the configuration in the OAuth resource servers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As already described, when using an OpenID Connect provider, we only have to
    configure the base URI to the standardized discovery endpoint in the OAuth resource
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `product-composite` and `gateway` projects, update the OIDC discovery
    endpoint to point to Auth0 instead of to our local authorization server. Make
    the following change to the `application.yml` file in both projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the property `spring.security.oauth2.resourceserver.jwt.issuer-uri`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace its value with `https://${TENANT}/`, where `${TENANT}` should be replaced
    with your tenant domain name; in my case, it is `dev-ml.eu.auth0.com`. Do *not*
    forget the trailing `/!`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In my case, the configuration of the OIDC discovery endpoint will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are curious, you can see what’s in the discovery document by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Rebuild the `product-composite` and `gateway` services as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: With the `product-composite` and `gateway` services updated, we can move on
    and also update the test script.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the test script so it acquires access tokens from Auth0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We also need to update the test script so it acquires access tokens from the
    Auth0 OIDC provider. This is done by performing the following changes in `test-em-all.bash`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace it with these commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note from the preceding command that Auth0 requires us to specify the intended
    **audience** of the requested access token, as an extra layer of security. The
    audience is the API we plan to call using the access token. Given that an API
    implementation verifies the `audience` field, this would prevent the situation
    where someone tries to use an access token issued for another purpose to get access
    to an API.
  prefs: []
  type: TYPE_NORMAL
- en: Set the values for the environment variables `TENANT`, `WRITER_CLIENT_ID`, and
    `WRITER_CLIENT_SECRET` in the preceding commands with the values returned by the
    `setup-tenant.bash` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As mentioned above, you can run the script again to acquire these values without
    risking any negative side effects!
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace it with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we only request the `product:read` scope and not the `product:write`
    scope here.
  prefs: []
  type: TYPE_NORMAL
- en: Set the values for the environment variables `READER_CLIENT_ID` and `READER_CLIENT_SECRET`
    in the preceding commands with the values returned by the `setup-tenant.bash`
    script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the access tokens are issued by Auth0 instead of our local authorization
    server, and our API implementations can verify the access tokens using information
    from Auth0’s discovery service configured in the `application.yml` files. The
    API implementations can, as before, use the scopes in the access tokens to authorize
    the client to perform the call to the API, or not.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have all the required changes in place. Let’s run some tests to
    verify that we can acquire access tokens from Auth0.
  prefs: []
  type: TYPE_NORMAL
- en: Running the test script with Auth0 as the OpenID Connect provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we are ready to give Auth0 a try!
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the usual tests, but this time, using Auth0 as the OpenID Connect provider,
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the logs, you will be able to find authorization information from the access
    tokens issued by Auth0\. Run the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect the following outputs from the command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From calls using an access token with both the `product:read` and `product:write`
    scopes, we will see both scopes listed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_11_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.21: Authorization information for the writer client from Auth0 in
    the log output'
  prefs: []
  type: TYPE_NORMAL
- en: 'From calls using an access token with only the `product:read` scope, we will
    see that only that scope is listed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_11_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.22: Authorization information for the reader client from Auth0 in
    the log output'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the log output, we now also get information regarding the
    **intended audience** for this access token. To strengthen security, we could
    add a test to our service that verifies that its URL, `https://localhost:8443/product-composite`
    in this case, is part of the audience list. This would, as mentioned earlier,
    prevent the situation where someone tries to use an access token issued for another
    purpose than to get access to our API.
  prefs: []
  type: TYPE_NORMAL
- en: With the automated tests working together with Auth0, we can move on and learn
    how to acquire access tokens using the different types of grant flow. Let’s start
    with the client credentials grant flow.
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring access tokens using the client credentials grant flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to acquire an access token from Auth0 yourself, you can do so by
    running the following command, using the client credentials grant flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Set the values for the environment variables `TENANT`, `WRITER_CLIENT_ID`, and
    `WRITER_CLIENT_SECRET` in the preceding commands with the values returned by the
    `setup-tenant.bash` script.
  prefs: []
  type: TYPE_NORMAL
- en: Following the instructions in the *Calling protected APIs using access tokens*
    section, you should be able to call the APIs using the acquired access token.
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring access tokens using the authorization code grant flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will learn how to acquire an access token from Auth0 using
    the authorization code grant flow. As already described above, we first need to
    acquire an authorization code using a web browser. Next, we can use server-side
    code to exchange the authorization code for an access token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to execute the authorization code grant flow with
    Auth0:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an authorization code for the default app client, use the following
    URL in the web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`https://${TENANT}/authorize?audience=https://localhost:8443/product-composite&scope=openid
    email product:read product:write&response_type=code&client_id=${WRITER_CLIENT_ID}&redirect_uri=https://my.redirect.uri&state=845361`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Replace `${TENANT}` and `${WRITER_CLIENT_ID}` in the preceding URL with the
    tenant domain name and writer client ID returned by the `setup-tenant.bash` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Auth0 should present the following login screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_11_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.23: Authorization code grant flow with Auth0, the login screen'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following a successful login, Auth0 will ask you to give the client application
    your consent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_11_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.24: Authorization code grant flow with Auth0, the consent screen'
  prefs: []
  type: TYPE_NORMAL
- en: 'The authorization code is now in the URL in the browser, just like when we
    tried out the authorization code grant flow with our local authorization server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_11_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.25: Authorization code grant flow with Auth0, access token'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract the code and run the following command to get the access token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set the values for the environment variables `TENANT`, `WRITER_CLIENT_ID`, and
    `WRITER_CLIENT_SECRET` in the preceding commands to the values returned by the
    `setup-tenant.bash` script.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to acquire access tokens using both grant flows,
    we are ready to try calling the external API using an access token acquired from
    Auth0 in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Calling protected APIs using the Auth0 access tokens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use access tokens issued by Auth0 to call our APIs, just like when we
    used access tokens issued by our local authorization server.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a read-only API, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'For an updating API, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Since we have requested both scopes, `product:read` and `product:write`, both
    the preceding API calls are expected to return `200 OK`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting extra information about the user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the log output in *Figures 11.21* and *11.22* in the *Running the test
    script with Auth0 as the OpenID Connect provider section*, we could not see any
    information about the user that initiated the API request. If you want your API
    implementation to know a bit more about the user, it can call Auth0’s `userinfo_endpoint`.
    The URL of the `userinfo` endpoint can be found in the response of a request to
    the OIDC discovery endpoint, as described in the *Changing the configuration in
    the OAuth resource servers* section. To get user info related to an access token,
    make the following request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Set the values for the `TENANT` environment variable in the preceding commands
    to the values returned by the `setup-tenant.bash` script.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this command only applies to access tokens issued using the authorization
    code grant flow. Access tokens issued using the client credentials grant flow
    don’t contain any user information and will result in an error response if tried.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample response is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_11_26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.26: Requesting extra user information from Auth0'
  prefs: []
  type: TYPE_NORMAL
- en: This endpoint can also be used to verify that the user hasn’t revoked the access
    token in Auth0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap up the tests by shutting down the system landscape with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the section, where we have learned how to replace the local OAuth
    2.0 authorization server with an external alternative. We have also seen how to
    reconfigure the microservice landscape to validate access tokens using an external
    OIDC provider.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to use Spring Security to protect our APIs.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how easy it is to enable HTTPS to prevent eavesdropping by third
    parties using Spring Security. With Spring Security, we have also learned that
    it is straightforward to restrict access to the discovery server, Netflix Eureka,
    using HTTP Basic authentication. Finally, we have seen how we can use Spring Security
    to simplify the use of OAuth 2.0 and OpenID Connect to allow third-party client
    applications to access our APIs in the name of a user, but without requiring that
    the user share credentials with the client applications. We have learned both
    how to set up a local OAuth 2.0 authorization server based on Spring Security
    and also how to change the configuration so that an external OpenID Connect provider,
    Auth0, can be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: One concern, however, is how to manage the configuration required. Each microservice
    instance must be provided with its own configuration, making it hard to get a
    good overview of the current configuration. Updating configuration that concerns
    multiple microservices will also be challenging. Added to the scattered configuration
    is the fact that some of the configurations we have seen so far contain sensitive
    information, such as credentials or certificates. It seems like we need a better
    way to handle the configuration for a number of cooperating microservices and
    also a solution for how to handle sensitive parts of the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the Spring Cloud Config Server and see
    how it can be used to handle these types of problems.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the benefits and shortcomings of using self-signed certificates?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of OAuth 2.0 authorization codes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of OAuth 2.0 scopes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does it mean when a token is a JWT?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we trust the information that is stored in a JWT?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it suitable to use the OAuth 2.0 authorization code grant flow with a native
    mobile app?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does OpenID Connect add to OAuth 2.0?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
