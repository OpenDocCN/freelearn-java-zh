- en: Deep Dive into Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scala combines both object-oriented and functional programming paradigms. In
    particular, functions are a first-class language concept. They can be defined
    in a variety of ways, assigned to variables, passed as parameters, and stored
    in data structures. Scala gives a lot of flexibility with regard to how these
    actions can be performed.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start this chapter by looking in detail at different flavors of defining
    a function. We'll then go on and apply the knowledge about types from the previous
    chapter to make our functions polymorphic and higher order. We'll study recursion,
    tail recursion, and trampolining as important aspects of functional programming
    for the JVM. Finally, we'll evaluate peculiarities related to the fact that functions
    in Scala are implemented in an object-oriented way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Ways to define a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphic functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trampolining
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-oriented aspects of functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JDK 1.8+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SBT 1.2+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for this chapter is available under [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter03](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Ways to define a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To provide some common ground for the readers with different levels of Scala
    knowledge, let's recap how a function can be defined. We'll start with the basic
    approaches such as defining a method and placing it in different scopes to create
    a local function. Then we'll look at more interesting aspects, for example closing
    over scope, partial application, different ways to specify function literals,
    and, finally, currying.
  prefs: []
  type: TYPE_NORMAL
- en: Function as a method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most Scala developers came to it from Java. Because of this, probably the most
    common way is to define a method inside of a class, trait, or an object, like
    in the following familiar example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By convention, we've explicitly defined a return type for the public method
    in the same way that we would do for the return type in Java. For the non recursive
    function, the result type can be omitted. We've done this for the private method.
  prefs: []
  type: TYPE_NORMAL
- en: The type declaration for the value parameters is mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each value parameter can have one default value assigned to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet also demonstrates that it is possible to define multiple
    groups of value parameters. The parameters from the last group can be implicit
    and also can be provided with default values. The default values from consecutive
    groups can refer to the parameters defined in previous groups as `e` refers to
    the default value of `c`, which is `a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type of the value parameter prefixed with `=>` means that this parameter
    should not be evaluated at the moment the method is called, but instead each time
    the parameter is referenced in the body of the method. Such arguments are called
    *by-name parameters* and basically, they represent a zero-argument method with
    the argument''s return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we can see how the passed block of code is executed twice,
    matching the number of usages inside the method's body.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `*` (star) can be added as a suffix to the name of the type of the last
    value parameter to denote that this is a *repeated* *parameter* and it takes a
    number of arguments of the defined type. The given arguments are then available
    in the method body as a `collection.Seq` of the specified type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is illegal to pass the `Seq` direct in place of repeated parameters. The
    last line in the previous snippet shows the `:_*` syntax to mark the last parameter
    as a *sequence argument.* The repeated parameter can't take default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arguments in the method definition have names. These names can be used to call
    the method by providing arguments in any order (as opposed to the order specified
    in the definition of the method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The named and normal arguments can be mixed, as shown in the last line of the
    previous code. In this case, the positional arguments must be specified first.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we defined our examples in the scope of the enclosing class or object.
    But Scala gives more flexibility in this regard. A method can be defined in any
    valid scope. This makes it local to the enclosing block and thus limits its visibility.
  prefs: []
  type: TYPE_NORMAL
- en: Local functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is an example of two functions that are local to the enclosing method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have both `sum` and `count` defined inside of the `average`
    definition, which makes them inaccessible from the outside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As already mentioned, the function does not need to be nested in another method.
    The enclosing block can be of any kind, for example, a variable definition. For
    instance, consider if the `average` function from the previous example was only
    defined in order to calculate a single average:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We could rewrite both code blocks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The scope visibility rules apply for methods the same way as for other language
    constructs. Because of this, the parameters of the `outer` method are visible
    to the inner functions and don''t need to be passed explicitly. We can rewrite
    our first example again using this rule, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There is a special name for the functions that refer to the definitions from
    the enclosing block, *closures*. Let's discuss them a little more deeply.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our function definitions, we''ve referred to two different types of variables:
    the ones that are provided as parameters (*bound variables*) and others, which
    were defined in the enclosing block (*free variables*). The free variable is named
    so, because the function itself does not give any meaning to it.'
  prefs: []
  type: TYPE_NORMAL
- en: A function that does not refer to any free variable is self-sufficient and the
    compiler can translate it to the bytecode in any context. Another way to state
    this is to say that this definition is closed in itself. It is named, accordingly,
    a *closed term*. A function referring to the free variables, on the other hand,
    can only be compiled in a context where all of these variables are defined. Therefore
    it is called *open term* and it closes over the free variables at the moment it
    is compiled, hence the name *closure *(over the free variables).
  prefs: []
  type: TYPE_NORMAL
- en: 'The usual scope resolution rules apply for closures in the same way that they
    apply for variables and other definitions as demonstrated by the next snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `res3` is calculated as `outerA.free (5) + innerA.free (20) + closure.in(10)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The free variable must be defined before the closure, otherwise, the compiler
    will complain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first try fails because we forgot to define a free variable. The second
    is still unsuccessful because the free variable is defined after the closure.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now, the methods and variables were handled the same way by the compiler.
    Can we exploit the similarities further and return a method as a result of another
    method and store it into the variable? Let''s give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, it didn't work. We tried to create and return a function from
    within a method and assign this function to a variable, but the compiler does
    not allow this. However, it gives us a useful hint about what we are doing wrong!
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that functions and methods are different for the compiler and
    methods can only be passed in the form of an instance of the enclosing class.
    This distinction is related to the fact that everything in the JVM is represented
    as an instance of some class. Because of this, the methods we define become methods
    of the class, and methods are not first-class citizens in the JVM. Scala works
    around this approach by having a hierarchy of classes representing functions of
    different arities. Thus, in order for us to be able to return a method from another
    method, the former must become a function. And the compiler gave us a hint as
    to how to achieve this: by using `_` (underscore) in the place where the parameters
    are expected.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The partial application can have two forms: a single underscore replacing the
    whole parameter list, or a single underscore replacing each parameter. Thus, for
    the partial application of the function we''ve just defined, both `function _`
    or `function(_,_)` would be appropriate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The partial application syntax can be used to create *shortcuts* for functions
    defined elsewhere, by importing and partially applying them at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In general, for the function of N parameters, the partial application means
    specifying 0 =< M < N parameters and leaving the rest undefined, basically applying
    the function to some part of the parameter list. This partial application gives
    a function of (N-M) parameters and the same type of result as the original function
    back. In our previous example, we defined M to be zero and thus the signature
    of the resulting function remained unchanged. But the very fact of there being
    a partial application has converted our method into the function, which allowed
    us to further work with it as with a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case, if 0< M <N,  the underscores go into the place of the parameters
    that are not applied at the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We applied the first and third arguments and left the second and fourth unapplied.
    The compiler requires us to provide a type ascription for missing parameters in
    order to use it while inferring the type of the resulting function.
  prefs: []
  type: TYPE_NORMAL
- en: The parameter names defined for methods are lost during the partial application
    and so are default values. The repeated parameters are converted to the `Seq`.
  prefs: []
  type: TYPE_NORMAL
- en: Function literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can inspect the type of the `applyTwo` function using REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the type of a first-class function looks like! In general, the
    type of function has right and left parts separated by the `=>`. The left part
    defines the types of the arguments, the right part—the type of the result. The
    implementation follows the same pattern and is called *function literal*. Here
    is an example of the full definition for a function of four arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: On the implementation side, we have a code block which consists of three expressions
    and therefore is wrapped in curly braces. Please note that we define our function
    as a `val`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, the function literal can be defined using simplified syntax. For instance,
    the type inference allows leaving the definition of the result type. The type
    definition, in this case, disappears altogether, because the type definitions
    for the parameters will move close to the parameter names exactly as in the definition
    of a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'On the application side, the compiler can help us to simplify the definition
    even more. Let''s consider an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We could have the following equal definitions for the `hasher` function. The
    full definition looks like the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet illustrates four different ways to represent a function literal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defined inline: `printHash((s: String) => s.hashCode)("inline")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Defined inline with type inference for the function parameter: `printHash((s:
    String) => s.hashCode)("inline")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defined inline with type inference for the function parameter (this is known
    as *target typing*): `printHash((s) => s.hashCode)("inline")`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parentheses around single argument can be omitted: `printHash(s => s.hashCode)("single
    argument parentheses")`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case, if an argument is used in the implementation of the function, at
    most once we can go further and use placeholder syntax: `printHash(_.hashCode)("placeholder
    syntax")`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In fact, the placeholder syntax is quite powerful and can also be used to define
    functions of multiple parameters as well as functions that are not in the target
    typing position. Here is an example of a function that calculates a hash code
    for four instances of  `Int` using the placeholder syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This syntax looks close to the partial application syntax, but represents a
    completely different language feature.
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Speaking about partial application, we have not referred to one special case
    of this, *currying*. Currying is in a sense a partial application where we take
    a function of N arguments and apply partial application for each argument in a
    row each time, to produce a function that takes one argument less. We repeat this
    process until we''re left with N functions, each taking one argument. If it sounds
    complicated, consider the next example of a function of two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Using two parameter lists, we can rewrite it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of this method is `(a: Int)(b: Int): Int` or expressed as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a function that takes an `Int` and returns a function from `Int` to
    `Int`! The number of arguments is not limited to just two of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The placeholder syntax will give us the same functionality, but in *uncurried*
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Currying is not very important in Scala compared to some other functional programming
    languages, but it is good to know as a useful functional programming concept.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism and higher order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we've played with functions that operate on only one type of data
    (*monomorphic functions*). Now, we will finally apply our type system knowledge
    to build functions that work for multiple types. Functions that take type parameters
    are called *polymorphic functions* similar to polymorphic methods implemented
    in an object-oriented hierarchy of classes (*subtype polymorphism*). For functions
    in Scala, it is called *parametric polymorphism*.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphic functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already used polymorphic functions when we played with `Glass` examples
    in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `drink` method is monomorphic and thus can only be applied to the argument
    of the type `Glass[Water]`, not even for an `EmptyGlass`. Of course, we don''t
    want to implement a separate method for every possible type of content out there.
    Instead, we implement our functions in a polymorphic way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The type parameter is available in the body of the method. In this case, we
    specify that the result should have the same type of content as the argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, it is possible to further constrain type parameter as we did before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, our method accepts any glass as long as it is a glass of water and allows
    anything more specific than water to be filled in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both examples also demonstrate that we can specify a type parameter during
    the partial application in order to have a monomorphic function of some specific
    type. Otherwise, the compiler applies the bottom type parameter the same way as
    it does when we define a polymorphic function using a function literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The inferred result type is correct at the moment of function application.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have discussed function literals and we''ve created a `printHash`
    function, which we used to demonstrate different forms of passing functions into
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `printHash` takes two parameters: the `hasher` function and a string to
    hash. Or, in functional form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Our function is `curried` as it takes one argument (a `String => Int` function)
    and returns another function, `String => Unit`. The fact that `printHash` takes
    a function as an argument is reflected by saying that `printHash` is a **higher
    order function** (**HOF**). There is nothing else special about HOFs except the
    fact that one or multiple parameters are functions. They work just as normal functions,
    can be assigned and passed over, partially applied and be polymorphic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In fact, HOFs usually apply function(s) given as parameter(s) to another parameter
    in some creative ways and therefore are almost always polymorphic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take another look at our `printHash` example. There is nothing in particular
    that requires a `hasher` function to calculate a hash; the function carried out
    by the `hasher` is independent of the logic of the `printHash`. Interestingly,
    this is the case more often than one would expect and it leads to the definition
    of HOF, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Our printing logic does not require the given function to have any specific
    type of an argument or result. The only limitation we need to enforce is that
    it is possible to call the function with the given argument, which we formulate
    with the type constraint `C <: A`. The nature of the function and an argument
    can also be anything, and it is common to use short neutral names when defining
    a HOF because of this. This is how our new definition can be used in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler needs to know the type of the function, and therefore we need
    to define it as a part of the placeholder syntax. We can help the compiler by
    changing the order of the parameters of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With this definition, it will be possible to infer the `C` first and then use
    the inferred type to enforce the type of `f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `identity` function is defined as `def identity[A](x: A): A = x` in the
    standard library.'
  prefs: []
  type: TYPE_NORMAL
- en: Recursion and trampolining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a special case of a function calling another function—the function
    calling itself. Such functions are called *recursive*. Recursive functions can
    be head-recursive or tail-recursive. There is also an approach to model recursive
    calls in an object-oriented way called *trampolining*. Recursion is very convenient
    and often uses the technique in functional programming, so let's take a close
    look at these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recursion is used to implement recurring logic without relying on loops and
    the internal states associated with them. The recursive behavior is defined by
    two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base case**: The simplest terminating case, in which no recursive calls are
    needed anymore'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recursive case**: The set of rules describing how to reduce any other state
    to the base case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One of the possible examples for recursive implementation can be reversing
    a string. The two recursive properties would be:'
  prefs: []
  type: TYPE_NORMAL
- en: The base case is an empty or single-char string. In this case, the reversed
    string is just the same string as given.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recursive case for the string of length N can be reduced to the case of
    a string of length N-1 by taking the first char of the string and appending it
    to the reversed tail of the given string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how we implement this logic in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: So, this is easier implemented than explained, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'One important aspect of our implementation in a recursive case is that it first
    makes the recursive call and then adds the rest of the string to the result. Such
    functions are head-recursive (but usually just called recursive) in the sense
    that the recursive call stays in the head of the computation. This works in a
    similar way to the depth-first algorithm, with the implementation first going
    down to the terminal case and then building up the result from the bottom up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The nested function calls are naturally kept in the stack during runtime. Because
    of this, functions that work fine for inputs of smaller size might blow up the
    stack for bigger inputs, crashing the whole application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to increase the size of memory reserved for a stack in JVM, but
    often there is a better solution—tail recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Tail recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the tail-recursive function, the recursive call is done as the very last
    activity. Because of this, it is possible to "finish" all the "preparations" for
    the call and then just "jump" back to the beginning of the function with new arguments.
    The Scala compiler rewrites tail-recursive calls as loops and hence such recursive
    invocations do not consume the stack at all. Usually, to make a recursive function
    tail-recursive, either some kind of state or some sort of and/or local helper
    function is introduced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite our reverse function in the tail-recursive way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this implementation, we've defined a local tail-recursive function, `reverse`,
    which shadows the argument `s` so that we do not unintentionally reference it,
    and also introduces an `acc` argument, which is needed to carry over the remaining
    part of the string. Now the reverse is called after the head of the string and
    `acc` are glued together. To return the result, we call the helper function with
    the original argument and an empty accumulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'This implementation does not consume the stack, which we can check by throwing
    an exception in the base case and inspecting the stack trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: At the moment we're finishing the reversing of the string, we still have just
    a single recursive call in the stack. Sometimes it confuses the developer as it
    appears as if the recursive call would not be made. In this case, it is possible
    to disable tail-call optimization by using the **notailcalls** compiler option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes the opposite is happening and a (presumably) tail-recursive call
    overflows the stack at runtime because the developer overlooked a recursive call
    in the head position. To eliminate the possibility for such kinds of error there
    is a special annotation for tail-recursive calls, `@scala.annotation.tailrec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will fail to compile head-recursive functions with this annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It seems as if we're on the safe side with properly annotated tail-recursive
    functions? Well, not 100%, because there is also a possibility that some functions
    cannot be made tail-recursive at all.
  prefs: []
  type: TYPE_NORMAL
- en: One of the examples, when tail recursion cannot be implemented, is mutual recursion. Two
    functions are mutually recursive if the first calls the second, and the second
    calls the first.
  prefs: []
  type: TYPE_NORMAL
- en: In mathematics, a Hofstadter sequence is a member of a family of related integer
    sequences defined by nonlinear recurrence relations. You can learn more about
    them in Wikipedia at [https://en.wikipedia.org/wiki/Hofstadter_sequence#Hofstadter_Female_and_Male_sequences](https://en.wikipedia.org/wiki/Hofstadter_sequence#Hofstadter_Female_and_Male_sequences).
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the examples of such functions is `Hofstadter` Female and Male sequences, defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example of a non-tail-recursive function is an Ackerman function (more
    about it can be found at [https://en.wikipedia.org/wiki/Ackermann_function](https://en.wikipedia.org/wiki/Ackermann_function))
    with the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'It is very simple, but not primitive recursive, it is stack-hungry, and it
    overflows the stack even with moderate values of m and n:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: There is a special technique called trampolining to implement non-tail-recursive
    functions on JVM.
  prefs: []
  type: TYPE_NORMAL
- en: Trampolining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In essence, *trampolining* is replacing recursive function calls with objects
    representing these calls. This way the recursive computation is built up in the
    heap instead of the stack, and it is possible to represent much deeper recursive
    calls just because of the bigger size of the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Scala `util.``control.``TailCalls` implementation provides a ready-to-use
    abstraction for trampolined recursive calls. Remember that we have two general
    cases in recursion that break down to three concrete cases? These are:'
  prefs: []
  type: TYPE_NORMAL
- en: The base case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The recursive case, which can be:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Head recursion
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tail recursion
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The representation reflects them by following three protected case classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As these are protected, we can''t use them directly, but are expected to use
    special helper methods instead. Let''s take a look at them by re implementing
    our Ackerman function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We wrap our recursive calls into the `tailcall` method, which creates an instance
    of a `Call`. The recursive call is a bit more complex than the base case because
    we first need to recursively wrap the internal call and then use the `flatMap`
    method provided by the `TailRec` to pass the result into the outer recursive call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `A` is just a helper method to unlift the result of the calculation from
    the `TailRec`. We''re using `BigInt` to represent the result because now, as the
    implementation is stack safe, it can return quite huge numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now, as we've seen how to represent recursive functions as objects, it is time
    to reveal another truth about Scala functions.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented aspects of functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We mentioned that Scala is a fusion of object-oriented and functional paradigms.
    Because of this, Scala has functions as a first-class element of the language.
    Also because of this, everything is an object in Scala. This is partly related
    to the fact that everything is an object or a primitive type in the JVM, but Scala
    goes further and also hides primitives behind objects.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that functions are also objects! Depending on the number of arguments,
    they extend one of the special traits. Also because of their object-oriented nature,
    it is possible to implement additional features by defining additional methods
    on the implementing class. This is how partial function is implemented. It is
    also natural to utilize companion objects to define common logic for functions
    so that it can be easily reused. It's even possible to write some custom implementation
    of a function, though it is seldom a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these aspects is worth a deep dive, but to really understand them, we
    need to start with some implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: Functions are traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each function in Scala implements a `FunctionN` trait, where N is an arity of
    the function. The zero-argument function is translated by the compiler to the
    implementation of `Function0`, of one argument—to `Function1` and so on, up to
    `Function22`. This complexity is needed because of the static nature of the language.
    Does it mean it is not possible to define functions of more than 22 arguments?
    Well, it is always possible to define a function using currying or multiple parameter
    lists, so this is not really a limitation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Function literals are just a syntactic sugar accepted by the compiler for developers''
    convenience. This is how the desugared signature of our previously defined Ackerman
    function looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'And the (simplified) definition of `Function2` in the standard library is like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Remember our co- and contravariance discussion in the previous chapter? Here
    we have it in action; the arguments are contravariant and the result type is covariant.
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that the compiler rewrites our definition as an instance of an
    anonymous class implementing this trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'And the instance of this class can then be passed over, assigned to a variable,
    stored into data structures, and so on. The `FunctionN` trait also defines a few
    helper methods that implement function-related functionality at the library level,
    as opposed to the language syntax. One example is a conversion of a normal function
    into the `curried` form, which for `Function2[T1,T2,R]` is defined as `def curried:
    T1 => T2 => R = (x1: T1) => (x2: T2) => apply(x1, x2) `'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This method is available for any function.
  prefs: []
  type: TYPE_NORMAL
- en: Partial functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The possibility of having additional methods gives a way do define concepts
    that would be hard to state otherwise, at least without extending the language
    itself. One such example is *partial functions*. A partial function is a function
    that is undefined for some values of its arguments. The classical example is a
    division that is not defined, for the divider equals zero. But actually, it is
    possible to have arbitrary domain rules that make some function partial. For instance,
    we could decide that our string reverse function should be undefined for empty
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of possibilities for implementing such constraints in a
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: Throw an exception for arguments for which the function is not defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constrain the type of an argument so that it is only possible to pass a valid
    argument to the function, for example using refined types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflect the partiality in the return type, for example using `Option` or `Either`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are obvious tradeoffs related to each of these approaches and in Scala,
    the first one is preferred as most natural. But, to better model the partial nature
    of the function, there is a special trait available in the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The key difference to normal function is that there is an additional method
    available that allows us to check whether the function is defined for some argument
    or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This allows the user of the function to do something different for "invalid"
    input values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s imagine we''ve invented a very efficient method to check
    if a string is a palindrome. Then we could define our reverse function as two
    partial functions, one that is only defined for palindromes and does nothing and
    another that is defined only for non-palindromes and does the actual reverse action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here we're using syntactic sugar again to define our partial functions as a
    pattern match and compiler creates `isDefinedAt` method for us. Our two partial
    functions are combined into the total function using the `orElse` method.
  prefs: []
  type: TYPE_NORMAL
- en: Function object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `orElse` method for partial function and `curried` method for a normal function
    earlier are just two examples of function-related methods predefined in the standard
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the `curried` method defined for every function instance (except
    `Function0` and `Function1`) there is another one, `tupled`, which converts a
    function of N arguments into the function of one argument which is a `TupleN`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides that, there is a companion object, `scala.Function`, that incorporates
    a few methods that are useful for higher order functional programming, most notably
    a `const` function, which always returns its argument, and a `chain` function,
    which combines a list of functions into a single function as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '`allAtOnce` is a function that is similar to the one that could be constructed
    by combining our three original functions with `andThen` (which is defined in
    the `FunctionN` trait):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: But `allAtOnce` is built in a dynamic manner.
  prefs: []
  type: TYPE_NORMAL
- en: Extending functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nothing prevents a developer from extending a `FunctionN` trait the same way
    it is done with `PartialFunction`, though it seldom makes sense because of the
    limitations imposed by the referential transparency constraint. This means that
    such an implementation of the function should not have a shared state, nor should
    it mutate state.
  prefs: []
  type: TYPE_NORMAL
- en: It might be tempting, for example, to implement a loaner pattern as a function,
    so that a used resource would be automatically closed after function application,
    but it won't be referentially transparent and thus won't satisfy the requirements
    for a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the implementation could look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is what happens if we call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, it is not even possible to test whether the second call would
    produce the same result (obviously it will not) because we broke the REPL by closing
    the `Console.in`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions represent another side of the blend of object-oriented and functional
    features in Scala. They can be defined in a number of ways, including the partial
    application of methods, function literals, and partial functions. Functions can
    be defined in any scope. If a function closes over variables available in scope,
    it is called **closure**.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphic functions implement an idea similar to polymorphism in object orientation,
    but apply that idea for types of parameters and of the result. This is called
    parametric polymorphism. It is especially useful when defining functions accepting
    other functions as arguments, so-called higher order functions.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to implement recursion and only tail-recursive functions
    are stack safe in the JVM. For the functions which cannot be made tail-recursive,
    there is a way to represent the call chain in the heap by encoding it as objects.
    This approach is called trampolining and it is supported in the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Functions are first-class values in Scala because they are implemented as anonymous
    classes extending `FunctionN` traits. This not only makes it possible to work
    with functions as with normal variables, but it also allows for the provision
    of extended function implementations with additional properties, for example,
    a `PartialFunction`.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What will be a type of following function in `curried` form: `(Int, String)
    => (Long, Boolean, Int) => String` ?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe the difference between a partially applied function and a partial function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a signature and implement a function `uncurry` for a `curried` function
    of three arguments `A => B => C => R`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a head-recursive function for factorial calculation n! = n * (n-1)
    * (n-2) * ... * 1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a tail-recursive function for factorial calculation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a recursive function for factorial calculation using trampolining
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mads Hartmann and Ruslan Shevchenko, *Professional Scala*: Write the type-safe
    code concise and expressive in an environment that lets you build for the JVM,
    browser, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Vikash Sharma, *Learning Scala Programming*: Learn how to write scalable and
    concurrent programs in Scala, a language that grows with you.
  prefs: []
  type: TYPE_NORMAL
