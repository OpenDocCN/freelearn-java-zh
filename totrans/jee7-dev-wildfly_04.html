<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;4.&#xA0;Learning Context and Dependency Injection"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Learning Context and Dependency Injection</h1></div></div></div><p class="calibre8">We saw that <a class="calibre1" title="Chapter 3. Introducing Java EE 7 – EJBs" href="part0023_split_000.html#page">Chapter 3</a>, <span class="strong"><em class="calibre10">Introducing Java EE 7 – EJBs</em></span>, was challenging since we had to cover lots of ground, including Java Enterprise enhancements and a Maven-specific configuration. In this chapter, we'll discuss <span class="strong"><strong class="calibre9">Contexts and Dependency Injection</strong></span> (<span class="strong"><strong class="calibre9">CDI</strong></span>), which was added to the Java EE specification in Java EE 6 (starting from JSR 299). It provides several benefits to Java EE developers that were missing, such as allowing any JavaBean to be used as a JSF managed bean, including stateless and stateful session beans. You can find more information on<a id="id381" class="calibre1"/> CDI and the newest version of the specification itself (JSR 346) at <a class="calibre1" href="http://www.cdi-spec.org/">http://www.cdi-spec.org/</a>.</p><p class="calibre8">Some of the topics that will be covered in this chapter are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">What Contexts and Dependency Injection is and how it relates to EJB</li><li class="listitem">How to rewrite our ticket-booking example to use the CDI and JavaServer Faces technology</li><li class="listitem">How to run the project using Maven</li></ul></div><p class="calibre8">This chapter<a id="id382" class="calibre1"/> assumes familiarity with <span class="strong"><strong class="calibre9">JavaServer Faces</strong></span> (<span class="strong"><strong class="calibre9">JSF</strong></span>), which will be used to provide a graphical interface for our applications. If you are looking for a start up guide for JSF, there are several excellent resources available online, including<a id="id383" class="calibre1"/> the relevant sections in the official Java EE 7 tutorial at <a class="calibre1" href="http://docs.oracle.com/javaee/7/tutorial/doc/jsf-develop.htm#BNATX">http://docs.oracle.com/javaee/7/tutorial/doc/jsf-develop.htm#BNATX</a>.</p></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Learning Context and Dependency Injection">
<div class="book" title="Introducing Contexts and Dependency Injection"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec23" class="calibre1"/>Introducing Contexts and Dependency Injection</h1></div></div></div><p class="calibre8">CDI for<a id="id384" class="calibre1"/> the Java EE platform introduces a standard set of component management services to the Java EE platform. As a component of Java EE 7, CDI is in many ways a standardization of concepts that have been brewing in Spring for a long time, such as dependency injection and interceptors. In fact, CDI and Spring 3 share many similar features. There are also other dependency injection frameworks available for developers<a id="id385" class="calibre1"/> that are more lightweight and easier to use in a Java SE environment. <span class="strong"><strong class="calibre9">Google Guice</strong></span> (<a class="calibre1" href="https://github.com/google/guice">https://github.com/google/guice</a>) is a notable example. Providing full-blown support for the CDI container in a standalone Java SE application and separation from<a id="id386" class="calibre1"/> the application server are one of the goals of the upcoming CDI 2.0 specification. This will allow developers to use a common programming model on both client and server sides.</p><p class="calibre8">CDI lets you decouple concerns by what it refers to as loose coupling and strong typing. In doing so, it provides an almost liberating escape from the banalities of everyday Java programming, allowing injections of its objects and controlling their lifetimes.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre8"><span class="strong"><strong class="calibre9">Why is CDI required for Java EE?</strong></span></p><p class="calibre8">If you have been programming with Java EE 5, you might argue that it already features resources injection of resources. However, this kind of injection can be used only for resources known to the container (for example, <code class="email">@EJB</code>, <code class="email">@PersistenceContext</code>, <code class="email">@PersistenceUnit</code>, and <code class="email">@Resource</code>). CDI, on the other hand, provides a general-purpose dependency injection scheme, which can be used for any component.</p></div><p class="calibre8">The CDI elementary unit is still the bean. Compared to EJBs, CDI features a different, more flexible kind of bean, which would often be a good place to put your business logic in. One of the most important differences between the two approaches is that CDI Beans are <span class="strong"><strong class="calibre9">contextual</strong></span>; that<a id="id387" class="calibre1"/> is, they live in a well-defined scope.</p><p class="calibre8">Consider the following code snippet:</p><div class="informalexample"><pre class="programlisting">public class HelloServlet extends HttpServlet {

    @EJB
    private EJBSample ejb;

    public void doGet (HttpServletRequestreq,
                       HttpServletResponse res)
                throws ServletException, IOException {
        try(PrintWriter out = res.getWriter()) {
            out.println(ejb.greet());
        }
    }
}</pre></div><p class="calibre8">Here, the injected EJB proxy (let's just assume that it is a POJO class annotated with a <code class="email">@Stateless</code> annotation) just points to a pool of stateless instances (or a single bean instance for stateful beans). There is no automatic association between the HTTP request or HTTP session and a given EJB instance.</p><p class="calibre8">The <a id="id388" class="calibre1"/>opposite is true for CDI Beans, which live in well-defined scopes. For example, the following CDI Bean lives in <code class="email">RequestScoped</code>; that is, it will be destroyed at the end of the request:</p><div class="informalexample"><pre class="programlisting">@RequestScoped
public class Customer {

    private String name;
    private String surname;

    public String getName(){
        return name;
    }

    public String getSurname(){
        return surname;
    }
}</pre></div><p class="calibre8">The preceding CDI Bean can be safely injected into our former servlet; at the end of an HTTP session or HTTP request, all the instances associated with this scope are automatically destroyed, and thus, garbage collected:</p><div class="informalexample"><pre class="programlisting">public class HelloServlet extends HttpServlet {

    @Inject
    private Customer customer;

    public void doGet (HttpServletRequest req,
                       HttpServletResponse res)
                throws ServletException, IOException {
        // some code
    }
}</pre></div></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Learning Context and Dependency Injection">
<div class="book" title="Introducing Contexts and Dependency Injection">
<div class="book" title="Named beans"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec30" class="calibre1"/>Named beans</h2></div></div></div><p class="calibre8">In the <a id="id389" class="calibre1"/>earlier section, we came across the <code class="email">@Named</code> annotation. Named beans <a id="id390" class="calibre1"/>allow us to easily inject our beans into other classes that depend <a id="id391" class="calibre1"/>on them and refer to them from JSF pages via the <span class="strong"><strong class="calibre9">Unified Expression Language</strong></span> (<span class="strong"><strong class="calibre9">UEL</strong></span>). Recall the earlier example:</p><div class="informalexample"><pre class="programlisting">@RequestScoped
@Named 
public class Customer {

    private String name;
    private String surname;

    public String getName(){
        return name;
    }

    public String getSurname(){
        return surname;
    }
}</pre></div><p class="calibre8">This class, decorated with the <code class="email">@Named</code> annotation, can then be referenced from a JSF page:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html  
      &gt;
   &lt;h:body&gt;
      &lt;h:form&gt;
         &lt;h:panelGrid columns="2"&gt;
            &lt;h:outputLabel for="name" value="Name" /&gt;
            &lt;h:inputText id="name" value="#{customer.name}" /&gt;
            &lt;h:outputLabel for="lastName" value="Surname" /&gt;
            &lt;h:inputText id="surname" value="#{customer.surname}" /&gt;
            &lt;h:panelGroup /&gt;
         &lt;/h:panelGrid&gt;
      &lt;/h:form&gt;
   &lt;/h:body&gt;
&lt;/html&gt;</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note22" class="calibre1"/>Note</h3><p class="calibre8">By default, the name of the bean will be the class name with its first letter switched to lowercase; thus, the <code class="email">Customer</code> bean can be referred to as <code class="email">customer</code>.</p></div><p class="calibre8">If you<a id="id392" class="calibre1"/> want to use a different naming policy for your bean, you <a id="id393" class="calibre1"/>could use the <code class="email">@Named</code> annotation as follows:</p><div class="informalexample"><pre class="programlisting">@Named(value="customNamed")</pre></div><p class="calibre8">This way, we will be able to reference our CDI Beans using the identified <code class="email">customNamed</code> value.</p><p class="calibre8">Instead of two <code class="email">@RequestScoped</code> and <code class="email">@Named</code> annotations, we can just use the <code class="email">@Model</code> annotation that aggregates them.</p></div></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Learning Context and Dependency Injection">
<div class="book" title="Introducing Contexts and Dependency Injection">
<div class="book" title="CDI scopes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec31" class="calibre1"/>CDI scopes</h2></div></div></div><p class="calibre8">CDI Beans <a id="id394" class="calibre1"/>come with a set of predefined scopes and annotations, and each CDI Bean has a distinct life cycle determined by the scope it belongs to. The following table describes the built-in CDI scopes and annotations required to set these scopes:</p><div class="informalexample"><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><thead class="calibre20"><tr class="calibre21"><th valign="bottom" class="calibre22">
<p class="calibre23">Scope</p>
</th><th valign="bottom" class="calibre22">
<p class="calibre23">Description</p>
</th></tr></thead><tbody class="calibre24"><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23"><code class="literal">@RequestScoped</code></p>
</td><td valign="top" class="calibre25">
<p class="calibre23">The <code class="literal">@RequestScoped</code> beans <a id="id395" class="indexterm"/>are <a id="id396" class="indexterm"/>shared during the length of a single request. This could be an HTTP request, a remote EJB invocation, a web services invocation, or message delivered to a Message Driven Bean (MDB). These beans are destroyed at the end of the request.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23"><code class="literal">@ConversationScoped</code></p>
</td><td valign="top" class="calibre25">
<p class="calibre23">The <code class="literal">@ConversationScoped</code> beans<a id="id397" class="indexterm"/> are shared across multiple <a id="id398" class="indexterm"/>requests in the same HTTP session but only if there is an active conversation maintained. Conversations are supported for JSF requests through the <code class="literal">javax.enterprise.context.Conversation</code> bean.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23"><code class="literal">@SessionScoped</code></p>
</td><td valign="top" class="calibre25">
<p class="calibre23">The <code class="literal">@SessionScoped</code> beans<a id="id399" class="indexterm"/> are shared between all the requests<a id="id400" class="indexterm"/> that occur in the same HTTP session and destroyed when the session is destroyed.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23"><code class="literal">@ApplicationScoped</code></p>
</td><td valign="top" class="calibre25">
<p class="calibre23">An <code class="literal">@ApplicationScoped</code> bean <a id="id401" class="indexterm"/>will live for as long as the application<a id="id402" class="indexterm"/> is running and be destroyed when the application is shut down.</p>
</td></tr><tr class="calibre21"><td valign="top" class="calibre25">
<p class="calibre23"><code class="literal">@Dependent</code></p>
</td><td valign="top" class="calibre25">
<p class="calibre23">The <code class="literal">@Dependent</code> beans<a id="id403" class="indexterm"/> are never shared between injection points. Any<a id="id404" class="indexterm"/> injection of a dependent bean is a new instance whose life cycle is bound to the life cycle of the object it is being injected into.</p>
</td></tr></tbody></table></div><p class="calibre8">Other parts <a id="id405" class="calibre1"/>of Java EE can extend the list of available scopes. In Java EE 7 (in the Java Transaction API specification), a new scope has been introduced: <code class="email">@TransactionScoped</code>. It bounds the life cycle of a bean with the current transaction. It is of course possible to introduce your own custom scopes.</p><p class="calibre8">In this chapter example, we will use the <code class="email">RequestScoped</code> and <code class="email">SessionScoped</code> beans to drive our simple ticket-booking system. In the next chapter, we will further enhance our example using <code class="email">ConversationScoped</code> beans, which are a peculiar scope of CDI Beans. Providing a detailed explanation of all the named beans scopes is beyond the scope of this book. However, you can quench your thirst for knowledge by having a look at CDI Reference<a id="id406" class="calibre1"/> Implementation (JBoss Weld) docs at <a class="calibre1" href="http://docs.jboss.org/weld/reference/latest/en-US/html/scopescontexts.html">http://docs.jboss.org/weld/reference/latest/en-US/html/scopescontexts.html</a>.</p></div></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Learning Context and Dependency Injection">
<div class="book" title="Introducing Contexts and Dependency Injection">
<div class="book" title="WildFly CDI implementation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec32" class="calibre1"/>WildFly CDI implementation</h2></div></div></div><p class="calibre8">Weld is <a id="id407" class="calibre1"/>the CDI Reference Implementation that <a id="id408" class="calibre1"/>originated as part of the Seam 3 project (<a class="calibre1" href="http://www.seamframework.org/">http://www.seamframework.org/</a>). Weld <a id="id409" class="calibre1"/>provides a complete CDI implementation, which can be a part of a Java EE 7 container such as WildFly.</p><p class="calibre8">Therefore, in order to run CDI-based applications on WildFly, you don't need to download any extra libraries as Weld is part of the server modules, and it is included in all server configurations as stated by the following extension:</p><div class="informalexample"><pre class="programlisting">&lt;extension module="org.jboss.as.weld"/&gt;</pre></div><p class="calibre8">Having your module installed, however, does not mean that you can blindly use it in your applications. The general rule is that on WildFly, every application module is isolated from other modules; this means, by default, it does not have visibility on the AS modules, nor do the AS modules have visibility on the application.</p><p class="calibre8">To be <a id="id410" class="calibre1"/>accurate, we could state that all WildFly modules <a id="id411" class="calibre1"/>fall into the<a id="id412" class="calibre1"/> following three categories:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Modules that are implicitly added to your applications</strong></span>: This category includes the most common APIs such as <code class="email">javax.activation</code>, <code class="email">javax.annotation</code>, <code class="email">javax.security</code>, <code class="email">javax.transaction</code>, <code class="email">javax.jms</code>, and <code class="email">javax.xml</code>. Using these modules does not require any extra effort as WildFly will add them for you if you are referencing them in your application.</li><li class="listitem"><span class="strong"><strong class="calibre9">Modules that are added on conditions</strong></span>: This category includes <code class="email">javax.ejb</code>, <code class="email">org.jboss.resteasy</code> and <code class="email">org.hibernate</code>, <code class="email">org.jboss.as.web</code>, and finally <code class="email">org.jboss.as.weld</code>. All these modules will be added on the condition that you supply its core annotations (such as <code class="email">@Stateless</code> for EJB) or its core configuration files, for example, <code class="email">web.xml</code> for a web application.</li><li class="listitem"><span class="strong"><strong class="calibre9">Modules that need to be explicitly enabled by the application deployer</strong></span>: This includes all other modules, such as your custom modules, that you can add to the application server. The simplest way to allow you to have visibility to these modules is adding an explicit dependency to your <code class="email">META-INF/MANIFEST.MF</code> file. For example, if you want to trigger the <span class="strong"><strong class="calibre9">log4j</strong></span> dependency, you have to code your manifest file as follows:<div class="informalexample"><pre class="programlisting">Dependencies: org.apache.log4j</pre></div></li></ul></div><p class="calibre8">There is also a custom descriptor file available, which is used by WildFly to resolve dependencies – <code class="email">jboss-deployment-structure.xml</code>. It allows the developer to configure the required dependencies in a fine-grained matter. The file is placed in the top-level deployment file, in the <code class="email">META-INF</code> directory (or <code class="email">WEB-INF</code> for a web archive). A sample content<a id="id413" class="calibre1"/> of the XML file (along with the XSD schema) is available at <a class="calibre1" href="https://docs.jboss.org/author/display/WFLY8/Class+Loading+in+WildFly">https://docs.jboss.org/author/display/WFLY8/Class+Loading+in+WildFly</a>.</p><p class="calibre8">So, if you have followed our checklist carefully, you will be aware that in order to let Weld libraries kick in and automatically discover your CDI beans, you should add its core configuration file, which is <code class="email">beans.xml</code>. This file can be placed in your application at the following locations:</p><div class="book"><ul class="itemizedlist"><li class="listitem">In your <code class="email">WEB-INF</code> folder if you are developing a web application</li><li class="listitem">In your <code class="email">META-INF</code> folder if you are deploying a JAR archive</li></ul></div><p class="calibre8">The <code class="email">beans.xml</code> file is based on the following schema reference:</p><div class="informalexample"><pre class="programlisting"> &lt;beans 
       
       xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee 
       http://xmlns.jcp.org/xml/ns/javaee/beans_1_1.xsd"
       version="1.1" bean-discovery-mode="all"&gt;
 &lt;/beans&gt;</pre></div><p class="calibre8">However, it is<a id="id414" class="calibre1"/> perfectly legal to place an empty <code class="email">beans.xml</code> file<a id="id415" class="calibre1"/> in the correct location; if you do so, CDI will be enabled in your application. If you, however, do not place a <code class="email">beans.xml</code> file, then only an annotated subset of classes will be considered as beans. In such a case, the container will create beans only for classes that are annotated with CDI-related annotations and ignore the rest. Most of the times, this is not the behavior we expect, and it differs from the default mode in Java EE 6 (when the <code class="email">beans.xml</code> file was required).</p><p class="calibre8">You might <a id="id416" class="calibre1"/>have noticed that the <code class="email">bean-discovery-mode</code> attribute is set to <code class="email">all</code> in our <code class="email">beans.xml</code> file. This allows us to configure the CDI discovery mode we discussed in the previous paragraph. It states that every legible class in our archive will be treated as a managed bean. You can place a <code class="email">@Vetoed</code> annotation on a class to filter it out from the bean discovery process. It is also possible to set the discovery mode to <code class="email">annotated</code> so that you can place a scope annotation for every class that you would like to use as a bean. This is the default value of the newest CDI version (also when there is no <code class="email">beans.xml</code>), so be sure to set it on for all our samples.</p></div></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Learning Context and Dependency Injection">
<div class="book" title="Introducing Contexts and Dependency Injection">
<div class="book" title="Rethinking your ticketing system"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch04lvl2sec33" class="calibre1"/>Rethinking your ticketing system</h2></div></div></div><p class="calibre8">Once <a id="id417" class="calibre1"/>you have learned the basics of CDI, we will start<a id="id418" class="calibre1"/> re-engineering the ticket-booking system using CDI Beans wherever necessary. We will turn it into a leaner application by dropping a few items such as remote interfaces or asynchronous methods, which are not needed in this example. By doing this, you will be able to focus just on the components that are actually used in the web application.</p><p class="calibre8">Let's create a<a id="id419" class="calibre1"/> new Maven project, just as we did in the previous chapter:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">From the <span class="strong"><strong class="calibre9">File</strong></span> menu, go to <span class="strong"><strong class="calibre9">New</strong></span> | <span class="strong"><strong class="calibre9">Maven Project</strong></span>; follow the wizard as we did previously (remember to check the <span class="strong"><strong class="calibre9">Create a simple project</strong></span> option).</li><li class="listitem" value="2">On the next screen, enter <code class="email">com.packtpub.wflydevelopment.chapter4</code> as <span class="strong"><strong class="calibre9">Group Id</strong></span>, <code class="email">ticket-agency-cdi</code> as <span class="strong"><strong class="calibre9">Artifact Id</strong></span>, and set packaging to <span class="strong"><strong class="calibre9">war</strong></span>:<div class="mediaobject"><img src="../images/00040.jpeg" alt="Rethinking your ticketing system" class="calibre11"/></div><p class="calibre14"> </p></li><li class="listitem" value="3">Click <a id="id420" class="calibre1"/>on <span class="strong"><strong class="calibre9">Finish</strong></span>. The Maven plugin for <a id="id421" class="calibre1"/>Eclipse will generate a project structure <a id="id422" class="calibre1"/>for you that you know from the previous chapter.</li><li class="listitem" value="4">The only difference is that besides the standard <code class="email">java</code> (for Java classes) and <code class="email">resources</code> (for configuration files) folders, a new directory named <code class="email">webapp</code> that will <a id="id423" class="calibre1"/>host<a id="id424" class="calibre1"/> the <a id="id425" class="calibre1"/>web application views.</li></ol><div class="calibre16"/></div><div class="book" title="Adding the required dependencies"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec31" class="calibre1"/>Adding the required dependencies</h3></div></div></div><p class="calibre8">In <a id="id426" class="calibre1"/>order to compile and run the project, our<a id="id427" class="calibre1"/> Maven's <code class="email">pom.xml</code> file will require the following set of dependencies known from the previous chapter:</p><div class="informalexample"><pre class="programlisting">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax&lt;/groupId&gt;
            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;
            &lt;version&gt;7.0&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.jboss.logging&lt;/groupId&gt;
            &lt;artifactId&gt;jboss-logging&lt;/artifactId&gt;
            &lt;version&gt;3.1.4.GA&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt; 
        &lt;/dependency&gt;
     &lt;/dependencies&gt;</pre></div><p class="calibre8">We will also require two plugins from the previous chapter (note that we changed the extension of the filename from <code class="email">jar</code> to <code class="email">war</code>):</p><div class="informalexample"><pre class="programlisting">    &lt;build&gt;
        &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt;
        &lt;plugins&gt;
            &lt;!-- WildFly plugin to deploy the application --&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.wildfly.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;wildfly-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.0.2.Final&lt;/version&gt;
                &lt;configuration&gt;
<span class="strong"><strong class="calibre9">                &lt;filename&gt;${project.build.finalName}.war&lt;/filename&gt;</strong></span>
                &lt;/configuration&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.1&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;!-- enforce Java 8 --&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;</pre></div><p class="calibre8">In case <a id="id428" class="calibre1"/>you have any problems with<a id="id429" class="calibre1"/> the <code class="email">POM</code> configuration file, be sure that you check the source code attached to this book and the material from the previous chapter.</p></div></div></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Learning Context and Dependency Injection">
<div class="book" title="Introducing Contexts and Dependency Injection">
<div class="book" title="Creating the beans"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch04lvl2sec34" class="calibre1"/>Creating the beans</h2></div></div></div><p class="calibre8">Once <a id="id430" class="calibre1"/>your project is properly configured, we can start modeling<a id="id431" class="calibre1"/> our beans. The first bean we will upgrade is <code class="email">TheatreBooker</code>, which will drive the user session, accessing the ticket list from our <code class="email">TheatreBox</code> bean:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter4.controller;

import com.packtpub.wflydevelopment.chapter4.boundary.TheatreBox;
import org.jboss.logging.Logger;

import javax.annotation.PostConstruct;
import javax.enterprise.context.SessionScoped;
import javax.faces.application.FacesMessage;
import javax.faces.context.FacesContext;
import javax.inject.Inject;
import javax.inject.Named;
import java.io.Serializable;

<span class="strong"><strong class="calibre9">@Named [1]</strong></span>
<span class="strong"><strong class="calibre9">@SessionScoped [2]</strong></span>
public class TheatreBooker implements Serializable {

    @Inject
<span class="strong"><strong class="calibre9">    private Logger logger; [3]</strong></span>
     
    @Inject
<span class="strong"><strong class="calibre9">    private TheatreBox theatreBox; [4]</strong></span>

    @Inject
<span class="strong"><strong class="calibre9">    private FacesContext facesContext; [5]</strong></span>

    private int money;

    @PostConstruct
    public void createCustomer() {
        this.money = 100;
    }

    public void bookSeat(int seatId) {
        logger.info("Booking seat " + seatId);
        int seatPrice = theatreBox.getSeatPrice(seatId);

        if (seatPrice &gt; money) {
<span class="strong"><strong class="calibre9">            FacesMessage m = new FacesMessage(FacesMessage.SEVERITY_ERROR, "Not enough Money!", "Registration unsuccessful"); [6]</strong></span>
            facesContext.addMessage(null, m);
            return;
        }

        theatreBox.buyTicket(seatId);

        FacesMessage m = new FacesMessage(FacesMessage.SEVERITY_INFO, "Booked!", "Booking successful");
        facesContext.addMessage(null, m);
        logger.info("Seat booked.");

        money = money - seatPrice;
    }

    public int getMoney() {
        return money;
    }
}</pre></div><p class="calibre8">As you can see, the bean has been tagged as <code class="email">Named [1]</code>, which means that it can be directly referenced in our JSF pages. The bean is <code class="email">SessionScoped [2]</code> since it stores the amount of money available to the customer during its session.</p><p class="calibre8">We would also like to inject <code class="email">logger [3]</code> and <code class="email">FacesContextFacexContexts [5]</code> instead of manually defining it. To do this, we will need to register a bean that produces loggers, which are parameterized with the name of the class. We will cover this process of producing beans in a moment.</p><p class="calibre8">Finally, notice <a id="id432" class="calibre1"/>that we can safely inject EJBs into our CDI Beans<a id="id433" class="calibre1"/> using the <code class="email">Inject [4]</code> annotation. Also, the reverse is perfectly legal, that is, injecting CDI Beans into EJBs.</p><p class="calibre8">Compared to our earlier project, here we don't raise Java exceptions when the customer is not able to afford a ticket. Since the application is web based, we simply display a warning message to the client using <code class="email">JSF Faces Messages [6]</code>.</p><p class="calibre8">The other bean that we still use in our application is <code class="email">TheatreInfo</code>, which has been moved to the <code class="email">controller</code> package as it will actually provide the application with the list of available seats:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter4.controller;

import com.google.common.collect.Lists;
import com.packtpub.wflydevelopment.chapter4.boundary.TheatreBox;
import com.packtpub.wflydevelopment.chapter4.entity.Seat;

import javax.annotation.PostConstruct;
import javax.enterprise.event.Observes;
import javax.enterprise.event.Reception;
import javax.enterprise.inject.Model;
import javax.enterprise.inject.Produces;
import javax.inject.Inject;
import javax.inject.Named;
import java.util.Collection;

<span class="strong"><strong class="calibre9">@Model [1]</strong></span>
public class TheatreInfo {

    @Inject
    private TheatreBox box;

    private Collection&lt;Seat&gt; seats;

    @PostConstruct
    public void retrieveAllSeatsOrderedByName() {
        seats = box.getSeats();
    }

<span class="strong"><strong class="calibre9">    @Produces [2]</strong></span>
    @Named
    public Collection&lt;Seat&gt; getSeats() {
        return Lists.newArrayList(seats);
    }
    public void onMemberListChanged(@Observes(notifyObserver = Reception.IF_EXISTS) final Seat member) {
        <span class="strong"><strong class="calibre9">retrieveAllSeatsOrderedByName(); [3]</strong></span>
    }
}</pre></div><p class="calibre8">At first, have <a id="id434" class="calibre1"/>a look at the <code class="email">@Model</code> annotation <code class="email">[1]</code>, which is an<a id="id435" class="calibre1"/> alias (we call this kind of annotations <span class="strong"><strong class="calibre9">stereotypes</strong></span>) for two commonly<a id="id436" class="calibre1"/> used annotations: <code class="email">@Named</code> and <code class="email">@RequestScoped</code>. Therefore, this bean will be named into our JSF page and will carry a request scope.</p><p class="calibre8">Next, pay attention to the <code class="email">getSeats</code> method. This method returns a list of seats, exposing it as a <code class="email">producer</code> method <code class="email">[2]</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note23" class="calibre1"/>Note</h3><p class="calibre8">The <code class="email">producer</code> method allows you to have control over the production of the dependency objects. As a Java factory pattern, they can be used as a source of objects whose implementation may vary at runtime or if the object requires some custom initialization that is not to be performed in the constructor.</p><p class="calibre8">It can be used to provide any kind of concrete class implementation; however, it is especially useful to inject Java EE resources into your application.</p></div><p class="calibre8">One advantage <a id="id437" class="calibre1"/>of using a <code class="email">@Producer</code> annotation<a id="id438" class="calibre1"/> for the <code class="email">getSeats</code> method is that its objects can be exposed directly via JSF's <span class="strong"><strong class="calibre9">Expression Language</strong></span> (<span class="strong"><strong class="calibre9">EL</strong></span>), as we will see in a minute.</p><p class="calibre8">Finally, another <a id="id439" class="calibre1"/>feature of CDI that was unleashed in this example is the <span class="strong"><strong class="calibre9">observer</strong></span>. An observer, as the name suggests, can be used to observe events. An observer method is notified whenever an object is created, removed, or updated. In our example, it allows the list of seats to be refreshed whenever they are needed.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note24" class="calibre1"/>Note</h3><p class="calibre8">To be precise, in our example, we are using a conditional observer that is denoted by the expression <code class="email">notifyObserver = Reception.IF_EXISTS</code>. This means that in practice, the <code class="email">observer</code> method is only called if an instance of the component already exists. If not specified, the default option (<code class="email">ALWAYS</code>) will be that the observer method is always called. (If an instance doesn't exist, it will be created.)</p></div><p class="calibre8">In the <a id="id440" class="calibre1"/>newest CDI version, it is possible to get additional information <a id="id441" class="calibre1"/>about the fired event in the observer by adding an <code class="email">EventMetadata</code> parameter to the observer's method.</p><p class="calibre8">Whenever a change in our list of seats occurs, we will use the <code class="email">javax.enterprise.event.Event</code> object to notify the observer about the changes. This will be done in our singleton bean, which gets injected with the seat's event <code class="email">[1]</code>, and notifies the observer by firing the event when a seat is booked <code class="email">[2]</code>:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter4.boundary;
import javax.enterprise.event.Event;

@Singleton
@Startup
@AccessTimeout(value = 5, unit = TimeUnit.MINUTES)
public class TheatreBox {

<span class="strong"><strong class="calibre9">    @Inject [1]</strong></span>
<span class="strong"><strong class="calibre9">    private Event&lt;Seat&gt; seatEvent;</strong></span>

    @Lock(WRITE)
    public void buyTicket(int seatId) {
        final Seat seat = getSeat(seatId);
        final Seat bookedSeat = seat.getBookedSeat();
        addSeat(bookedSeat);

<span class="strong"><strong class="calibre9">        seatEvent.fire(bookedSeat); [2]</strong></span>
    }  
    // Rest of the code stays the same, as in the previous chapter
}</pre></div><p class="calibre8">Earlier, we mentioned that a preconfigured logger should be injected to a bean if it requests it. We will create a simple logger producer that will use the information about the injection point (the bean that requests a logger) to configure an instance:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter4.util;

import javax.enterprise.inject.Produces;
import javax.enterprise.inject.spi.InjectionPoint;
import org.jboss.logging.Logger;

public class LoggerProducer {
 
    @Produces
    public Logger produceLogger(InjectionPoint injectionPoint) {
        return Logger.getLogger(injectionPoint.getMember().getDeclaringClass().getName());
    }
}</pre></div><p class="calibre8">We also<a id="id442" class="calibre1"/> allowed the injection of <code class="email">FacesContext</code> instead of using <a id="id443" class="calibre1"/>the standard <code class="email">FacesContext.getCurrentInstance()</code> static method. This context is used, for example, to display the stated error messages:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter4.util;

import javax.enterprise.context.RequestScoped;
import javax.enterprise.inject.Produces;
import javax.faces.context.FacesContext;

public class FacesContextProducer {

    @Produces
    @RequestScoped
    public FacesContext produceFacesContext() {
        return FacesContext.getCurrentInstance();
    }
}</pre></div><p class="calibre8">The last class we will include in our project is the <code class="email">Seat</code> bean, known from the previous chapter, which will be used as our model without any change (remember to include it in your project with a proper package).</p><div class="book" title="Building the view"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec32" class="calibre1"/>Building the view</h3></div></div></div><p class="calibre8">Once <a id="id444" class="calibre1"/>we have coded the server side of our example, creating the <a id="id445" class="calibre1"/>front end will be quite easy, as we have made all our resources available through CDI Beans.</p><p class="calibre8">One notable difference between some of the earlier editions of this book is that <span class="strong"><strong class="calibre9">Facelets</strong></span> are now the preferred view technology for JSF. Earlier versions of JSF used <span class="strong"><strong class="calibre9">JavaServer Pages</strong></span> (<span class="strong"><strong class="calibre9">JSP</strong></span>) as<a id="id446" class="calibre1"/> their default view technology. As JSP technology predates JSF, using JSP with JSF sometimes felt unnatural or created problems. For example, the life cycle of JSPs is different from the life cycle of JSF.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note25" class="calibre1"/>Note</h3><p class="calibre8">Compared to the simpler request-response paradigm on which the JSP life cycle is based, the JSF life cycle is much more complex since the core of JSF is the MVC pattern, which has several implications. User actions in JSF-generated views take place in a client that does not have a permanent connection to the server. The delivery of user actions or page events is delayed until a new connection is established. The JSF life cycle must handle this delay between event and event processing. Also, the JSF life cycle must ensure that the view is correct before rendering it, and also that the JSF system includes a phase to validate inputs and another to update the model only after all the inputs pass validation.</p><p class="calibre8">Most of the time Facelets are used to build JavaServer Faces views using HTML-style templates and component trees. Templating is a useful feature available with Facelets that allows you to create a page that will act as the template for the other pages in an application (something like Struts Tiles). The idea is to obtain portions of reusable code without repeating the same code on different pages.</p></div><p class="calibre8">So here's the main application structure that contains a template page named <code class="email">default.xhtml</code> that is referenced by views in the template attribute of the page's composition element. The template contains two main HTML <code class="email">div</code> elements that will be used to contain the main application panel (<code class="email">content</code>) and a footer div (<code class="email">footer</code>), which will barely output the application title.</p><p class="calibre8">In order to add the template at first, add a new JSF page to the <code class="email">WEB-INF/templates</code> folder of your application and name it <code class="email">default.xhtml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      
      &gt;
&lt;h:head&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt;
    &lt;h:outputStylesheet name="style.css"/&gt;
&lt;/h:head&gt;
&lt;h:body&gt;
    &lt;div id="container"&gt;
        &lt;div id="content"&gt;
<span class="strong"><strong class="calibre9">            &lt;ui:insert name="content"&gt;</strong></span>
<span class="strong"><strong class="calibre9">                [Template content will be inserted here]</strong></span>
<span class="strong"><strong class="calibre9">            &lt;/ui:insert&gt;</strong></span>
        &lt;/div&gt;
        &lt;div id="footer"&gt;
            &lt;p&gt;
                &lt;em&gt;WildFly Development Ticket Booking example.&lt;/em&gt;&lt;br/&gt;
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/h:body&gt;
&lt;/html&gt;</pre></div><p class="calibre8">Next, we <a id="id447" class="calibre1"/>will add the main page view, which will be embedded into<a id="id448" class="calibre1"/> your template. For this purpose, add a JSF page named <code class="email">index.xhtml</code> to the <code class="email">webapp</code> folder of your Maven project:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ui:composition 
                
                
                
                <span class="strong"><strong class="calibre9">template="/WEB-INF/templates/default.xhtml"&gt; [1]</strong></span>
    &lt;ui:define name="content"&gt;
        &lt;h1&gt;TicketBooker Machine&lt;/h1&gt;
        &lt;h:form id="reg"&gt;
<span class="strong"><strong class="calibre9">            &lt;h3&gt;Money: $ #{theatreBooker.money}&lt;/h3&gt; [2]</strong></span>
            &lt;h:messages errorClass="error" infoClass="info"
                        globalOnly="true"/&gt;
            &lt;h:panelGrid columns="1" border="1" styleClass="smoke"&gt;
<span class="strong"><strong class="calibre9">                &lt;h:dataTable var="_seat" value="#{seats}" [3]</strong></span>
<span class="strong"><strong class="calibre9">                             rendered="#{not empty seats}" styleClass="simpletablestyle"&gt;</strong></span>

                    &lt;h:column&gt;
                        &lt;f:facet name="header"&gt;Id&lt;/f:facet&gt;
                        #{_seat.id}
                    &lt;/h:column&gt;

                    &lt;h:column&gt;
                        &lt;f:facet name="header"&gt;Name&lt;/f:facet&gt;
                        #{_seat.name}
                    &lt;/h:column&gt;
                    &lt;h:column&gt;
                        &lt;f:facet name="header"&gt;Price&lt;/f:facet&gt;
                        #{_seat.price}$
                    &lt;/h:column&gt;
                    &lt;h:column&gt;
                       &lt;f:facet name="header"&gt;Booked&lt;/f:facet&gt;
                       #{_seat.booked}
                    &lt;/h:column&gt;
                    &lt;h:column&gt;
                       &lt;f:facet name="header"&gt;Action&lt;/f:facet&gt;
                       &lt;h:commandButton id="book"
<span class="strong"><strong class="calibre9">                 action="#{theatreBooker.bookSeat(_seat.id)}" [4]</strong></span>
                       disabled="#{_seat.booked}"
                       value="#{_seat.booked ? 'Reserved' : 'Book'}" /&gt;
                    &lt;/h:column&gt;

                &lt;/h:dataTable&gt;
            &lt;/h:panelGrid&gt;
        &lt;/h:form&gt;
    &lt;/ui:define&gt;
&lt;/ui:composition&gt;</pre></div><p class="calibre8">The <code class="email">ui:composition</code> element<a id="id449" class="calibre1"/> is a templating tag that wraps <a id="id450" class="calibre1"/>content to be included in another Facelet. Specifically, it will be<a id="id451" class="calibre1"/> included in the <code class="email">default.xhtml[1]</code> template.</p><p class="calibre8">The creation of the view is done in three steps. First, we will display the customer's money <code class="email">[2]</code>, which is bound to the session variable called <code class="email">money</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note26" class="calibre1"/>Note</h3><p class="calibre8">Notice how we directly reference CDI Beans (for example, <code class="email">TheatreBooker</code>) from JSF expressions, just as we used to do with JSF Managed Beans.</p></div><p class="calibre8">The next <a id="id452" class="calibre1"/>thing on the checklist is printing all JSF messages <code class="email">[3]</code> that are <a id="id453" class="calibre1"/>meant to be produced by the application via the <code class="email">messages</code> element.</p><p class="calibre8">The main task of this view is to produce a view of all tickets and let the users purchase them. This is achieved by means of a <code class="email">dataTable</code> object <code class="email">[3]</code>that can be used to produce a tabular list of objects, which are generally stored as <code class="email">java.util.List</code> in your beans.</p><p class="calibre8">Pay attention to the value attribute of the <code class="email">dataTable</code> object:</p><div class="informalexample"><pre class="programlisting">&lt;h:dataTable var="_seat" value="#{seats}" 
rendered="#{not empty seats}" styleClass="simpletablestyle"&gt;</pre></div><p class="calibre8">In this case, we don't directly reference a CDI Bean, but we reference an object that has been produced by a CDI Bean. To be precise, it has been produced by <code class="email">TheatreInfo</code> that, as we have seen, has a <code class="email">@Produces</code> and <code class="email">@Named</code> annotation on our list of seats:</p><div class="informalexample"><pre class="programlisting">private List&lt;Seat&gt; seats;

@Produces
@Named
public List&lt;Seat&gt;getSeats() {
   return seats;
}</pre></div><p class="calibre8">This <code class="email">dataTable</code> object will be displayed only if it contains some data in it (as dictated by the <code class="email">not empty seats</code> EL expression). In one of the <code class="email">dataTable</code> columns, we have added <code class="email">commandButton [4]</code> that will be used to book the seat displayed on that row. Notice one of the JSF 2 goodies here, as we call the <code class="email">bookSeat</code> method of <code class="email">TheatreBooker</code> passing an argument as one parameter, which is the <code class="email">seatId</code> field.</p><div class="book" title="JSF 2 facet suggestions"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec05" class="calibre1"/>JSF 2 facet suggestions</h4></div></div></div><p class="calibre8">By<a id="id454" class="calibre1"/> enabling JSF 2 facets on your project configuration, you<a id="id455" class="calibre1"/> can enjoy some additional benefits while designing your views.</p><p class="calibre8">Enabling JSF 2 project facets takes half a minute. Right-click on your project and navigate to <span class="strong"><strong class="calibre9">Properties</strong></span> | <span class="strong"><strong class="calibre9">Project Facets</strong></span>. Then, select the <span class="strong"><strong class="calibre9">JSF 2.2 Project facets</strong></span> checkbox and click on the <span class="strong"><strong class="calibre9">OK</strong></span> button:</p><div class="mediaobject"><img src="../images/00041.jpeg" alt="JSF 2 facet suggestions" class="calibre11"/></div><p class="calibre12"> </p><div class="informalexample" title="Note"><h3 class="title2"><a id="note27" class="calibre1"/>Note</h3><p class="calibre8">Once the JSF facet is enabled, Eclipse will notify you that the JSF library configuration is missing; just disable the JSF library configuration that is a part of Maven's duty.</p></div><p class="calibre8">Once <a id="id456" class="calibre1"/>JSF 2 facets are configured, if you press <span class="strong"><em class="calibre10">Ctrl</em></span> + Space bar<a id="id457" class="calibre1"/> before referencing a field or method, a suggestion pop-up window will let you choose the method or attribute of the Bean you want to reference.</p></div></div><div class="book" title="Getting ready to run the application"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec33" class="calibre1"/>Getting ready to run the application</h3></div></div></div><p class="calibre8">OK, now<a id="id458" class="calibre1"/> your application is almost ready. We just need to <a id="id459" class="calibre1"/>configure a JSF mapping in a <code class="email">web.xml</code> file as follows:</p><div class="informalexample"><pre class="programlisting">&lt;web-app 
         
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1"&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/faces/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;welcome-file-list&gt;
        &lt;welcome-file&gt;faces/index.xhtml&lt;/welcome-file&gt;
    &lt;/welcome-file-list&gt;
&lt;/web-app&gt;</pre></div><p class="calibre8">This will<a id="id460" class="calibre1"/> then run the <code class="email">FacesServlet</code> servlet for all the<a id="id461" class="calibre1"/> pages at <code class="email">/faces/* url</code>.</p><p class="calibre8">Finally, as stated previously, in order to activate our <code class="email">war</code> file as an explicit bean archive, we need to add an empty <code class="email">beans.xml</code> file to the <code class="email">WEB-INF</code> folder of your application.</p><p class="calibre8">So, if you follow the same naming convention used in this chapter, you will end up with the following project structure:</p><div class="mediaobject"><img src="../images/00042.jpeg" alt="Getting ready to run the application" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">At this <a id="id462" class="calibre1"/>point, you must be familiar with building and deploying <a id="id463" class="calibre1"/>your Maven applications using Eclipse or a shell. Assuming that you are managing your application from a shell, start by building up the project using the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">mvn package</strong></span>
</pre></div><p class="calibre8">Then, publish<a id="id464" class="calibre1"/> it using the WildFly Maven plugin, as we did in<a id="id465" class="calibre1"/> the previous chapter.</p><p class="calibre8">If the WildFly server is started, you can execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">mvn wildfly:deploy</strong></span>
</pre></div><p class="calibre8">If the WildFly server is not started, you can execute the following command and then the WildFly Maven plugin will automatically start an instance:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">mvn wildfly:run</strong></span>
</pre></div><p class="calibre8">The application will be available at <code class="email">http://localhost:8080/ticket-agency-cdi</code>.</p><p class="calibre8">Then, to do this with a unique command, you can execute the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">mvn clean package wildfly:deploy</strong></span>
</pre></div><p class="calibre8">After so much work, you will be pleased to have your application running on your browser:</p><div class="mediaobject"><img src="../images/00043.jpeg" alt="Getting ready to run the application" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Right now, you will be able to book tickets up to the budget ($ 100) defined in your <code class="email">SessionScoped</code> bean. So enjoy this first taste of JSF and CDI.</p><p class="calibre8">Of course, in<a id="id466" class="calibre1"/> this chapter, we only scratched the surface <a id="id467" class="calibre1"/>of JSF features. There is also a new higher-level approach introduced in JSF 2.2 that can be used for flow-based scenarios such as a shopping cart. The new<a id="id468" class="calibre1"/> feature is called <span class="strong"><strong class="calibre9">FacesFlow</strong></span> and comes with a <code class="email">@FlowScoped</code> annotation. However, we will now focus on adding some other features to our current application.</p></div><div class="book" title="Combining the scheduler into our application"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec34" class="calibre1"/>Combining the scheduler into our application</h3></div></div></div><p class="calibre8">Up<a id="id469" class="calibre1"/> to now, we have not included the <a id="id470" class="calibre1"/>scheduler, which was in charge of simulating <a id="id471" class="calibre1"/>other customer-requesting tickets, into our application. This was not an oversight; as a matter of fact, introducing an external system in a web application poses some challenges. For example, what if the scheduler updates some data used by the application? How will the user know it?</p><p class="calibre8">There are several strategies to address this requirement; however, they all boil down to using some intelligence in your client application. For example, if you are familiar with web scripting languages, you can use the popular jQuery API to poll the server for some updates. The newest version of JSF 2.2 comes with great support for HTML5 and JavaScript frameworks, thanks to the custom data attributes and pass-through elements. These are simple mechanisms that allow the JSF's render kit to render parts of the page without any further changes so that custom tags may be interpreted by the browser (or a JavaScript framework).</p><p class="calibre8">Since not all Java EE developers might be skilled in JavaScript, we would rather show a simple and effective way<a id="id472" class="calibre1"/> to fulfill our requirement using <span class="strong"><strong class="calibre9">RichFaces</strong></span> libraries (<a class="calibre1" href="http://www.jboss.org/richfaces">http://www.jboss.org/richfaces</a>), which provide advanced Ajax support along with a rich set of ready-to-use components.</p><div class="book" title="Installing RichFaces"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec06" class="calibre1"/>Installing RichFaces</h4></div></div></div><p class="calibre8">Installing<a id="id473" class="calibre1"/> RichFaces requires a set of <a id="id474" class="calibre1"/>core libraries that are generally available at the RichFaces download page.</p><p class="calibre8">Additionally, you need to provide a set of third-party dependencies that are used by the RichFaces API. Never mind, that's what Maven is for! Start by adding the latest <span class="strong"><strong class="calibre9">Bill of Materials</strong></span> (<span class="strong"><strong class="calibre9">BOM</strong></span>) for<a id="id475" class="calibre1"/> the <code class="email">RichFaces</code> API in the upper dependency-management section:</p><div class="informalexample"><pre class="programlisting">&lt;dependencyManagement&gt;
  ...
    &lt;dependency&gt;
        &lt;groupId&gt;org.richfaces&lt;/groupId&gt;
        &lt;artifactId&gt;richfaces-bom&lt;/artifactId&gt;
        &lt;version&gt;4.3.5.Final&lt;/version&gt;
        &lt;scope&gt;import&lt;/scope&gt;
        &lt;type&gt;pom&lt;/type&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</pre></div><p class="calibre8">Then, it's just<a id="id476" class="calibre1"/> a matter of adding the rich <a id="id477" class="calibre1"/>UI libraries and the core API:</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;org.richfaces.ui&lt;/groupId&gt;
    &lt;artifactId&gt;richfaces-components-ui&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.richfaces.core&lt;/groupId&gt;
    &lt;artifactId&gt;richfaces-core-impl&lt;/artifactId&gt;
&lt;/dependency&gt;</pre></div></div><div class="book" title="Making your application rich"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec07" class="calibre1"/>Making your application rich</h4></div></div></div><p class="calibre8">Once we<a id="id478" class="calibre1"/> have installed RichFaces<a id="id479" class="calibre1"/> libraries, we will just need to reference them on each XHTML page in your project. Here's the new <code class="email">index.xhtml</code> page using the RichFaces namespaces:</p><div class="informalexample"><pre class="programlisting">&lt;ui:composition 
                
                
                
<span class="strong"><strong class="calibre9">                </strong></span>
<span class="strong"><strong class="calibre9">                </strong></span>
                template="/WEB-INF/templates/default.xhtml"&gt;
    &lt;ui:define name="content"&gt;
        &lt;f:view&gt;

            &lt;h:form&gt;
                &lt;a4j:poll id="poll" interval="2000"
                 enabled="#{pollerBean.pollingActive}"
                 render="poll,grid,bookedCounter"/&gt;
                &lt;rich:panel header="TicketBooker Machine" 
                            style="width:350px"&gt;

                    &lt;h2&gt;Book your Ticket&lt;/h2&gt;

                    &lt;h3&gt;Money: $ #{theatreBooker.money}&lt;/h3&gt;
                    &lt;h:messages errorClass="error" infoClass="info" globalOnly="true"/&gt;


<span class="strong"><strong class="calibre9">                    &lt;rich:dataTable id="grid" var="_seat" </strong></span>
<span class="strong"><strong class="calibre9">                                    value="#{seats}" </strong></span>
<span class="strong"><strong class="calibre9">                                    rendered="#{not empty seats}" </strong></span>
<span class="strong"><strong class="calibre9">                                    styleClass="simpletablestyle"&gt;</strong></span>

                        &lt;h:column&gt;
                            &lt;f:facet name="header"&gt;Id&lt;/f:facet&gt;
                            #{_seat.id}
                        &lt;/h:column&gt;

                        &lt;h:column&gt;
                            &lt;f:facet name="header"&gt;Name&lt;/f:facet&gt;
                            #{_seat.name}
                        &lt;/h:column&gt;
                        &lt;h:column&gt;
                            &lt;f:facet name="header"&gt;Price&lt;/f:facet&gt;
                            #{_seat.price}
                        &lt;/h:column&gt;
                        &lt;h:column&gt;
                            &lt;f:facet name="header"&gt;Booked&lt;/f:facet&gt;
                            #{_seat.booked}
                        &lt;/h:column&gt;
                        &lt;h:column&gt;
                            &lt;f:facet name="header"&gt;Action&lt;/f:facet&gt;
                            &lt;h:commandButton id="book"
                        action="#{theatreBooker.bookSeat(_seat.id)}"
                        disabled="#{_seat.booked}"
                        value="#{_seat.booked ? 'Not Available' : 'Book'}"/&gt;
                        &lt;/h:column&gt;
                    &lt;/rich:dataTable&gt;
<span class="strong"><strong class="calibre9">         &lt;h:outputText value="Booked seats on this page: #{bookingRecord.bookedCount}"  id="bookedCounter" /&gt;</strong></span>
                &lt;/rich:panel&gt;
            &lt;/h:form&gt;
        &lt;/f:view&gt;
    &lt;/ui:define&gt;
&lt;/ui:composition&gt;</pre></div><p class="calibre8">We <a id="id480" class="calibre1"/>have highlighted the core<a id="id481" class="calibre1"/> enhancements added to this page. At first, as we said, we need to reference the RichFaces libraries at the top of the XHTML page.</p><p class="calibre8">Next, we added a rich Ajax <a id="id482" class="calibre1"/>component, <span class="strong"><strong class="calibre9">a4j:poll</strong></span>, which does a simple but an effective job of polling the server for updates, allowing the re-rendering of our components—<code class="email">grid</code> (which contains the main datatable), <code class="email">poller</code> (to check whether it should still be running), and <code class="email">bookedCounter</code>.</p><p class="calibre8">Additionally, this component references a CDI bean named <code class="email">Poller</code>, which acts just as an on/off flag for our poller. We expect to turn off polling as soon as all the seats are sold out:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter4.controller;

import java.util.Optional;

import javax.enterprise.inject.Model;
import javax.inject.Inject;

import com.packtpub.wflydevelopment.chapter4.boundary.TheatreBox;
import com.packtpub.wflydevelopment.chapter4.entity.Seat;

@Model
public class Poller {

    @Inject
    private TheatreBox theatreBox;

    public boolean isPollingActive() {
        return areFreeSeatsAvailable();
    }

    private boolean areFreeSeatsAvailable() {
        final Optional&lt;Seat&gt; firstSeat = theatreBox.getSeats().stream().filter(seat -&gt; !seat.isBooked()).findFirst();
        return firstSeat.isPresent();
    }
}</pre></div><p class="calibre8">Our seller <a id="id483" class="calibre1"/>service stays nearly <a id="id484" class="calibre1"/>the same as in the previous chapter (the only difference is the <code class="email">logger</code> injection):</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter4.control;

import com.packtpub.wflydevelopment.chapter4.boundary.TheatreBox;
import com.packtpub.wflydevelopment.chapter4.entity.Seat;
import org.jboss.logging.Logger;

import javax.annotation.Resource;
import javax.ejb.EJB;
import javax.ejb.Schedule;
import javax.ejb.Stateless;
import javax.ejb.Timer;
import javax.ejb.TimerService;
import javax.inject.Inject;
import java.util.Collection;
import java.util.Optional;

@Stateless
public class AutomaticSellerService {

    @Inject
    private Logger logger;

    @Inject
    private TheatreBox theatreBox;

    @Resource
    private TimerService timerService;

    @Schedule(hour = "*", minute = "*", second = "*/30", persistent = false)
    public void automaticCustomer() {
        final Optional&lt;Seat&gt; seatOptional = findFreeSeat();

        if (!seatOptional.isPresent()) {
            cancelTimers();
            logger.info("Scheduler gone!");
            return; // No more seats
        }

        final Seat seat = seatOptional.get();

        theatreBox.buyTicket(seat.getId());

        logger.info("Somebody just booked seat number " + seat.getId());
    }

    private Optional&lt;Seat&gt; findFreeSeat() {
        final Collection&lt;Seat&gt; list = theatreBox.getSeats();
        return list.stream().filter(seat -&gt; !seat.isBooked()).findFirst();
    }

    private void cancelTimers() {
        for (Timer timer : timerService.getTimers()) {
            timer.cancel();
        }
    }
}</pre></div><p class="calibre8">Finally, we'll <a id="id485" class="calibre1"/>add a booking record, which<a id="id486" class="calibre1"/> will be bounded with the current view using the view scope. Its role will be to count the number of bookings done by the user in the current view (a single browser tab is considered a single view):</p><div class="informalexample"><pre class="programlisting">package com.packtpub.wflydevelopment.chapter4.controller;

import com.packtpub.wflydevelopment.chapter4.entity.Seat;

import java.io.Serializable;

import javax.enterprise.event.Observes;
import javax.faces.view.ViewScoped;
import javax.inject.Named;

@Named
@ViewScoped
public class BookingRecord implements Serializable {

    private int bookedCount = 0;

    public int getBookedCount() {
        return bookedCount;
    }

    public void bookEvent(@Observes Seat bookedSeat) {
        bookedCount++;
    }
}</pre></div><p class="calibre8">You can experiment with the booked counter by trying to book tickets via two separate tabs in your browser.</p><p class="calibre8">You might have noticed that we placed two annotations on the bean: <code class="email">@Named</code> and <code class="email">@ViewScoped</code>. If you would like to define multiple beans with a specific set of CDI annotations, it<a id="id487" class="calibre1"/> would be a good idea<a id="id488" class="calibre1"/> to create your own custom annotation that already contains the desired ones. This kind of construction is called a stereotype. It is possible to incorporate the following elements:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A default scope</li><li class="listitem">Optionally, interceptor bindings</li><li class="listitem">Optionally, a <code class="email">@Named</code> annotation</li><li class="listitem">Optionally, an <code class="email">@Alternative</code> annotation</li></ul></div><p class="calibre8">To create a stereotype, you need to add the wanted annotations along with the <code class="email">@Stereotype</code> annotation:</p><div class="informalexample"><pre class="programlisting">@ViewScoped
@Named
@Stereotype
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface NamedView {

}</pre></div><p class="calibre8">Now you can define the <code class="email">BookinRecord</code> bean as follows:</p><div class="informalexample"><pre class="programlisting">@NamedView
public class BookingRecord implements Serializable {
    //Some code here
}</pre></div><p class="calibre8">The <code class="email">@Model</code> stereotype<a id="id489" class="calibre1"/> is available in CDI by default. It defines a request scoped named bean, and you can use it on your beans right out of the box.</p></div><div class="book" title="Running the application"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec08" class="calibre1"/>Running the application</h4></div></div></div><p class="calibre8">With <a id="id490" class="calibre1"/>all the libraries in place, you can<a id="id491" class="calibre1"/> now test run your new rich application. As you can see, every 30 seconds a ticket is sold out and buttons are turned, in real time, into <span class="strong"><strong class="calibre9">Not available</strong></span>:</p><div class="mediaobject"><img src="../images/00044.jpeg" alt="Running the application" class="calibre11"/></div><p class="calibre12"> </p></div><div class="book" title="Creating interceptors"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec09" class="calibre1"/>Creating interceptors</h4></div></div></div><p class="calibre8">There<a id="id492" class="calibre1"/> is one more CDI feature worth <a id="id493" class="calibre1"/>mentioning here, the interceptors. Sometimes, applications contain logic and cross-cutting multiple layers; the most simple example is logging. Under the Java EE platform, it can be achieved using interceptors. First, we need to create a new annotation:</p><div class="informalexample"><pre class="programlisting">@Inherited
<span class="strong"><strong class="calibre9">@InterceptorBinding [1]</strong></span>
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD, ElementType.TYPE })
public @interface Logged {
    // empty
}</pre></div><p class="calibre8">This annotation defines an interceptor binding. It can be used to specify methods that you would like to intercept. The bindings can be used on types as well; in that case, every method call on that type is intercepted. The most important part of this definition is the <code class="email">@InterceptorBinding [1]</code> annotation. Be sure to add it!</p><p class="calibre8">Then, we have to create the interceptor definition itself:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">@Interceptor</strong></span>
<span class="strong"><strong class="calibre9">@Logged [1]</strong></span>
public class LoggingInterceptor implements <span class="strong"><strong class="calibre9">Serializable</strong></span> {

<span class="strong"><strong class="calibre9">    @AroundInvoke [2]</strong></span>
    public Object log(InvocationContext context) throws Exception {
        final Logger logger = Logger.getLogger(context.getTarget().getClass());
        logger.infov("Executing method {0}", context.getMethod().toString());
        return <span class="strong"><strong class="calibre9">context.proceed() [3];</strong></span>
    }
}</pre></div><p class="calibre8">We start by stating that our class is <code class="email">@Interceptor</code> and it will be using the interceptor binding that we've defined earlier (<code class="email">@Logged [1]</code>). Next, we create a method log that will be executed around every method execution (<code class="email">@AroundInvoke [2]</code>) on annotated classes. Inside of it, we will call the <code class="email">context.proceed()</code> method that will basically forward the call to the original receiver. Note that the interceptor can decide (based on some security logic, for instance) whether the call should be dropped. It could even analyze or change the returned value.</p><p class="calibre8">Finally, we<a id="id494" class="calibre1"/> have to enable it in the <code class="email">beans.xml</code> file<a id="id495" class="calibre1"/> by adding the following code:</p><div class="informalexample"><pre class="programlisting">&lt;interceptors&gt;
  &lt;class&gt;com.packtpub.wflydevelopment.chapter4.util.LoggingInterceptor&lt;/class&gt;
&lt;/interceptors&gt;</pre></div><p class="calibre8">Now, let's move on to just the annotated classes or methods that you want to log using the <code class="email">@Logged</code> annotation. For instance, refer to the following:</p><div class="informalexample"><pre class="programlisting">@Named
@SessionScoped
@Logged
public class TheatreBooker implements Serializable {
    // Some code
}</pre></div><p class="calibre8">All calls to the <code class="email">TheatreBooker</code> public methods will now be logged in to the console:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">21:02:11 INFO  [com.packtpub.wflydevelopment.chapter4 .controller.TheatreBooker$Proxy$_$$_WeldSubclass] (default task-8) Executing method public int com.packtpub.wflydevelopment.chapter4.controller. TheatreBooker.getMoney()</strong></span>
</pre></div><p class="calibre8">In the case of multiple interceptors, the order in which they are executed is determined by the <code class="email">@Interceptor.Priority</code> annotation. Interceptors with lowest priorities will be called first. Be sure to check the constants defined in the <code class="email">Priority</code> annotation. Your own interceptor's priorities should be between the <code class="email">APPLICATION</code> and <code class="email">LIBRARY_AFTER</code> scope.</p><p class="calibre8">There are also other interesting CDI mechanisms that we will not cover in this book, but are definitely worth exploring: decorators and alternatives. Decorators are basically strongly typed interceptors that are focused on the business logic of your application. Alternatives can be used to provide alternative implementations for specific beans.</p></div></div></div></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Learning Context and Dependency Injection">
<div class="book" title="Introducing Contexts and Dependency Injection">
<div class="book" title="Are EJBs and JSF Managed Beans obsolete?"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch04lvl2sec35" class="calibre1"/>Are EJBs and JSF Managed Beans obsolete?</h2></div></div></div><p class="calibre8">At the<a id="id496" class="calibre1"/> end of this chapter, we would like to give our honest <a id="id497" class="calibre1"/>opinion about a common question posed by developers, that is, how EJB, JSF Managed Beans, and CDI interact and where the boundary between them lies. Are there redundancies between them? It is indeed a bit confusing since there are now multiple component models available in Java EE.</p><p class="calibre8">JSF Managed Beans<a id="id498" class="calibre1"/> have been, for a long time, the actual glue <a id="id499" class="calibre1"/>between the application view and the business methods. Since Release 2.0 of JSF, you can declare JSF Managed Beans via an annotation, and the scopes are expanded <a id="id500" class="calibre1"/>with a <span class="strong"><strong class="calibre9">view scope</strong></span> and the ability to create custom scopes. However, there is very little still going on for JSF Managed Beans. Most of its features can be replaced by CDI Beans that are much more flexible and allow you to have a better integration with other Java EE components. Even the view scope, in the newest version of JSF, has been implemented as a CDI custom scope (<code class="email">javax.faces.view.ViewScoped</code>), which replaces the old <code class="email">javax.faces.bean.ViewScoped</code> (notice the name of the package; it's a common mistake to mix them up).</p><p class="calibre8">On the other hand, EJBs, even though they use a less flexible injection mechanism, still maintain some unique features such as schedulable timers, asynchronous operations, and pooling that are essential for throttling and assuring that the application provides a good quality of service. Beginning from Java EE 7, EJBs no longer are the only components that have<a id="id501" class="calibre1"/> a transactional nature. The new <code class="email">@Transactional</code> annotation allows you to use declarative transactions in CDI beans by simply placing it on selected methods.</p><p class="calibre8">Despite this, it's likely that EJBs are not disappearing from our code, rather it is likely (and desirable too) that they will continue to be used for some of their unique features. For the remaining part though, its functionality will be exposed via CDI instead of EJBs' own annotations such as <code class="email">@Stateless</code> and <code class="email">@EJB</code>.</p></div></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec24" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we provided an introduction to CDI. We covered how JSF pages can access CDI-named beans as if they were JSF Managed Beans. We also covered how CDI makes it easy to inject dependencies into our code via the <code class="email">@Inject</code> annotation. Additionally, we explained how we can add another library of the JBoss ecosystem (RichFaces) uncovering just one aspect of its potentiality.</p><p class="calibre8">Until now, we have worked with in-memory data, so it's time to introduce storage for our CDI applications using the Java Persistence API, which is the theme of the next chapter.</p></div></body></html>