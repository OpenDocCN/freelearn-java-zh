<html><head></head><body>
		<div id="_idContainer090">
			<h1 class="chapter-number" id="_idParaDest-178"><a id="_idTextAnchor188"/>10</h1>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor189"/>Setting Up Our Angular Project and Architecture</h1>
			<p>In the previous chapter, you learned about the concepts of <strong class="bold">JUnit</strong>, which is a testing framework that offers features such as fixtures, test suites, and classes to test the methods in our application. You also learned the application of <strong class="bold">AssertJ</strong> with JUnit, which gives a more flexible way of asserting objects in our unit tests, and lastly, you also understood the importance of Mockito, which provides us with the ability to mock objects and services, omitting the use of the database in <span class="No-Break">unit tests.</span></p>
			<p>In this chapter, we will start building our frontend application using Angular; we will be tackling the main fundamentals of Angular, such as components, modules, directives, and routes. We will also point out some of the best practices for organizing our <span class="No-Break">Angular project.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Organizing features <span class="No-Break">and modules</span></li>
				<li><span class="No-Break">Structuring components</span></li>
				<li>Adding <span class="No-Break">Angular material</span></li>
			</ul>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor190"/>Technical requirements</h1>
			<p>The link to the finished version of this chapter is <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-10/superheroes"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-10/superheroes</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor191"/>Organizing features and modules</h1>
			<p>In this section, we will be discussing<a id="_idIndexMarker707"/> how we can organize and structure<a id="_idIndexMarker708"/> our Angular project to make<a id="_idIndexMarker709"/> it optimized and maintainable. Since Angular is considered a <strong class="bold">Model View Whatever</strong> (<strong class="bold">MVW</strong>) framework, Angular developers have the freedom to implement their choice of pattern in developing the project. This could be confusing, as you will experience different structures and standards switching from one project to another. To solve this dilemma, we will present a commonly used structure in the industry or some kind of baseline structure that you will typically find in <span class="No-Break">Angular projects.</span></p>
			<p>However, before we proceed to our main topic, let us first discuss how to create our Angular project and what the basic concepts that we need to know before coding Angular are. You can skip this part if you are already knowledgeable about Angular and proceed to the <em class="italic">Organizing the folder </em><span class="No-Break"><em class="italic">structure</em></span><span class="No-Break"> section.</span></p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor192"/>Generating an Angular project</h2>
			<p>We can create or set<a id="_idIndexMarker710"/> up the dependencies of our Angular <a id="_idIndexMarker711"/>project using a tool known as the <strong class="bold">Angular CLI</strong>. We can scaffold the project by using a single command responsible for downloading the dependencies and generating the required files for our Angular project to run. The <strong class="bold">Angular CLI</strong> is a handy tool in that it also provides several commands that will help us generate boilerplate codes <span class="No-Break">in Angular.</span></p>
			<p>To install the Angular CLI, we should make sure that we have Node.js installed on our machine, and we will execute the <strong class="source-inline">npm install -g @angular/cli</strong> command. After executing the command, we can verify whether our Angular CLI has been successfully installed – we will have a new global <strong class="source-inline">ng</strong> command that we can use to check the version of the <span class="No-Break">installed CLI.</span></p>
			<p>To check the version, we will execute the <strong class="source-inline">ng --version</strong> command, and we will get the <span class="No-Break">following output:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer072">
					<img alt="Figure 10.1 – Installed version of the Angular CLI" src="image/B18159_10_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Installed version of the Angular CLI</p>
			<p>In the preceding output, we can see that the version<a id="_idIndexMarker712"/> of the Angular CLI and Node.js installed on your machine is displayed after executing the <strong class="source-inline">ng -- version</strong> command. Currently, we have Angular CLI Version 13 installed, which means that once we scaffold<a id="_idIndexMarker713"/> an Angular project, it will be on <span class="No-Break"><strong class="bold">Version 13</strong></span><span class="No-Break">.</span></p>
			<p>After successfully installing the Angular CLI, we can now execute several commands for our project. Here are some of the commands<a id="_idIndexMarker714"/> that we can use in the <span class="No-Break">Angular CLI:</span></p>
			<ul>
				<li><strong class="source-inline">ng new &lt;project name&gt; [options]</strong>: Creates or scaffolds a new <span class="No-Break">Angular project</span></li>
				<li><strong class="source-inline">ng serve &lt;project&gt; [options]</strong>: Builds and serves your <span class="No-Break">Angular application</span></li>
				<li><strong class="source-inline">ng generate &lt;schematic&gt; [options]</strong>: Generates and modifies files with a <span class="No-Break">specific schematic</span></li>
			</ul>
			<p>Some schematics we can generate are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break">Component</span></li>
				<li><span class="No-Break">Module</span></li>
				<li><span class="No-Break">Directive</span></li>
				<li><span class="No-Break">Guard</span></li>
			</ul>
			<ul>
				<li><strong class="source-inline">ng build&lt;project&gt; [options]</strong>: Compiles the Angular application into an output directory named <strong class="source-inline">dist</strong>, which will be used <span class="No-Break">for production</span></li>
				<li><strong class="source-inline">ng test &lt;project&gt; [options]</strong>: Runs the unit test in the <span class="No-Break">Angular project</span></li>
			</ul>
			<p>These are just some of the most commonly <a id="_idIndexMarker715"/>used commands of the Angular CLI. For the complete<a id="_idIndexMarker716"/> commands, you can visit the documentation for Angular <span class="No-Break">at </span><span class="No-Break">https://angular.io/cli</span><span class="No-Break">.</span></p>
			<p>We know the commands we can use in the Angular CLI. Now, let’s generate our Angular project by executing the <strong class="source-inline">ng new superheroes</strong> command on our desired path. This will ask several questions, such as “<em class="italic">would you like to add Angular routing?</em>” and “<em class="italic">which stylesheet format would you like to use?</em>” We can select <em class="italic">Yes</em> and <strong class="bold">Syntactically Awesome Style Sheet</strong> (<strong class="bold">SASS</strong>) for these questions, as we need routes and SASS<a id="_idIndexMarker717"/> to build our <span class="No-Break">application later.</span></p>
			<p>After this step, this will now scaffold a new Angular project named superheroes and will be responsible for configuring the web pack, creating the required settings, and downloading the project’s dependencies. After the scaffold is accomplished, open the superheroes project in Visual Studio Code or any IDE you prefer. We will see that the Angular application is configured and ready to run on our <span class="No-Break">local server.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer073">
					<img alt="Figure 10.2 – Folder structure and dependencies installed after scaffolding" src="image/B18159_10_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Folder structure and dependencies installed after scaffolding</p>
			<p>To run our project, we can open<a id="_idIndexMarker718"/> the VS Code terminal with the <em class="italic">Ctrl</em> + <em class="italic">`</em> shortcut and execute the <strong class="source-inline">ng serve</strong> command. We can also use the defined scripts in our <strong class="source-inline">package.json</strong> file. In this case, we can perform <strong class="source-inline">npm run start</strong> to run our application. We will see in the terminal whether Angular is running successfully on our local server in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer074">
					<img alt="Figure 10.3 – Folder structure and dependencies installed after scaffolding" src="image/B18159_10_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Folder structure and dependencies installed after scaffolding</p>
			<p>After successfully running our Angular application, we can now open the app using the default URL (<strong class="source-inline">http://localhost:4200</strong>) in our browser, and we will see the default page of our <span class="No-Break">Angular project:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer075">
					<img alt="Figure 10.4 – Angular default page" src="image/B18159_10_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Angular default page</p>
			<p>We have successfully <a id="_idIndexMarker719"/>configured and started our Angular application locally. Now, let’s discuss the concepts we will use to build <span class="No-Break">our application.</span></p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor193"/>Angular features</h2>
			<p>The Angular framework<a id="_idIndexMarker720"/> is a component-based framework that allows us to develop reusable components to promote the reusability and maintainability of code. It offers many features that will make our frontend development more powerful. In this section, we will discuss the basic features and fundamentals of Angular that serve as its building blocks; take note that we will not discuss all of the features here, as we will focus more on the organization of <span class="No-Break">the project.</span></p>
			<p>To learn more about the features, you can visit<a id="_idIndexMarker721"/> the official documentation for <span class="No-Break">Angular: </span><span class="No-Break">https://angular.io/start</span><span class="No-Break">.</span></p>
			<h3>Components</h3>
			<p><strong class="bold">Components</strong> are the main building blocks<a id="_idIndexMarker722"/> in Angular. They<a id="_idIndexMarker723"/> are responsible for defining what the behavior and the look of the view will be. Components are annotated with the <strong class="source-inline">@Component</strong> decorator, which assigns several types of metadata that describe the component’s HTML, CSS, <span class="No-Break">and selector.</span></p>
			<p>The following are the commands to generate <span class="No-Break">a component:</span></p>
			<pre class="console">
ng generate component &lt;component-name&gt;
ng g c &lt;component-name&gt;</pre>
			<p>The following is a code example for <span class="No-Break">a component:</span></p>
			<pre class="source-code">
import { Component } from '@angular/core';
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss']
})
export class AppComponent {
  title = 'superheroes';
}</pre>
			<p>Components<a id="_idIndexMarker724"/> have a feature called <strong class="bold">data binding</strong>, which allows us to pass data<a id="_idIndexMarker725"/> into the view. Data binding<a id="_idIndexMarker726"/> can be used to display values to the user, respond to user events, and modify the styles. Angular binding is classified into <span class="No-Break">two groups:</span></p>
			<ul>
				<li><span class="No-Break">One-way binding</span></li>
				<li><span class="No-Break">Two-way binding</span></li>
			</ul>
			<h3>One-way binding</h3>
			<p>As can be inferred from<a id="_idIndexMarker727"/> the name<a id="_idIndexMarker728"/>, data only flows<a id="_idIndexMarker729"/> in one direction here. It can be from a component to the view or <span class="No-Break">vice versa.</span></p>
			<p>There are several ways to achieve one-way binding in Angular, and the two most common ways are using interpolation and <span class="No-Break">property binding.</span></p>
			<h4>Interpolation</h4>
			<p><strong class="bold">Interpolation</strong> is a one-way binding technique<a id="_idIndexMarker730"/> that allows us to display<a id="_idIndexMarker731"/> expressions to a string literal in HTML. Interpolation uses <strong class="source-inline">{{}}</strong> (double curly braces) for expressions inside <span class="No-Break">HTML code.</span></p>
			<p>Let’s have a look at the following <span class="No-Break">example code:</span></p>
			<pre class="source-code">
// app.component.ts
export class AppComponent {
  title = 'superheroes';
}
&lt;!—app.component.html -&gt;
&lt;!-- INTERPOLATE TITLE --&gt;
&lt;span&gt; Title:  {{title}} &lt;/span&gt;</pre>
			<p>In the preceding example, we have used interpolation to display the value of the <strong class="source-inline">title</strong> variable in the view. Using<a id="_idIndexMarker732"/> interpolation, we can also use operators in the <span class="No-Break">template</span><span class="No-Break"><a id="_idIndexMarker733"/></span><span class="No-Break"> expression.</span></p>
			<h4>Property binding</h4>
			<p><strong class="bold">Property binding</strong> allows us to bind HTML element<a id="_idIndexMarker734"/> properties<a id="_idIndexMarker735"/> in the component. Since we bind the HTML element properties, when the bound value changes, the view also changes. We can bind to HTML element properties such as <strong class="source-inline">class</strong>, <strong class="source-inline">href</strong>, <strong class="source-inline">disabled</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">src</strong></span><span class="No-Break">.</span></p>
			<p>Let’s have a look at the following example code on how to use <span class="No-Break">property binding:</span></p>
			<pre class="source-code">
// app.component.ts
export class AppComponent {
  isDisabled = true;
}
&lt;!—app.component.html -&gt;
&lt;button [disabled]="isDisabled"&gt;Can't be clicked&lt;/button&gt;</pre>
			<p>In the preceding example, we have bound the <strong class="source-inline">isDisabled</strong> variable to the disabled property of the button. The button will be disabled, as we have set the value of the <strong class="source-inline">isDisabled</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<h3>Two-way binding</h3>
			<p><strong class="bold">Two-way binding</strong> is a two-way data flow. Any changes<a id="_idIndexMarker736"/> applied to the model<a id="_idIndexMarker737"/> will be reflected<a id="_idIndexMarker738"/> in the view simultaneously and any modifications involved in the view are updated in the component. Two-way data binding helps handle forms, as we want our model to be updated once the values of the form are also updated and <span class="No-Break">vice versa.</span></p>
			<p>To achieve two-way binding, the <strong class="source-inline">ngModel</strong> directive <span class="No-Break">is used.</span></p>
			<h4>ngModel</h4>
			<p><strong class="source-inline">ngModel</strong> is a directive<a id="_idIndexMarker739"/> used to achieve two-way binding in Angular. This is under the Forms module in <strong class="source-inline">@angular/forms</strong>. <strong class="source-inline">ngModel</strong>, once it is bound to an input field or other form element, gives that element a property binding and an event binding. Let’s have a look at the following <span class="No-Break">example code:</span></p>
			<pre class="source-code">
// app.component.ts
export class AppComponent {
  model = 'seiji';
}
&lt;!—app.component.html -&gt;
&lt;input [(ngModel)]="model"/&gt;</pre>
			<p>In the preceding example code, we have bound the model value to an input element using the <strong class="source-inline">ngModel</strong> directive. This syntax<a id="_idIndexMarker740"/> is also known as the <em class="italic">banana in a box</em>, which encloses <strong class="source-inline">ngModel</strong> with a square bracket and parenthesis. The directive will bind the model’s value with the input field using property binding and listen to the input value changes by <span class="No-Break">utilizing </span><span class="No-Break"><strong class="source-inline">ngModelChange</strong></span><span class="No-Break">.</span></p>
			<h3>Directives</h3>
			<p><strong class="bold">Directives</strong> are an Angular feature<a id="_idIndexMarker741"/> that helps<a id="_idIndexMarker742"/> us manipulate the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>). We can modify a DOM<a id="_idIndexMarker743"/> element’s layout, behavior, and<a id="_idIndexMarker744"/> view. Directives are classified into three parts: <strong class="bold">components</strong> are one of the classifications, and the other two are <strong class="bold">attribute</strong> and <span class="No-Break"><strong class="bold">structural</strong></span><span class="No-Break"> directives.</span></p>
			<h4>Structural directives</h4>
			<p><strong class="bold">Structural directives</strong> are directives that can modify<a id="_idIndexMarker745"/> the layout<a id="_idIndexMarker746"/> of the DOM by adding, updating, or removing elements, listed below are some of the structural directives <span class="No-Break">in Angular:</span></p>
			<ul>
				<li><strong class="source-inline">*ngIf</strong>: A directive that is used to add or remove elements in the DOM based on <span class="No-Break">a condition:</span><pre class="console">
&lt;div *ngIf="condition"&gt;Will show if the condition is true&lt;/div&gt;</pre></li>
				<li><strong class="source-inline">*ngFor</strong>: A directive that is used to repeat<a id="_idIndexMarker747"/> HTML elements from the items iterated in a <span class="No-Break">specific list:</span><pre class="console">
// this will display all the users for each row</pre><pre class="console">
&lt;tr *ngFor="let user of users;"&gt;</pre><pre class="console">
    &lt;td&gt;{{user.firstName }}&lt;/td&gt;</pre><pre class="console">
    &lt;td&gt;{{user.lastName}}&lt;/td&gt;</pre><pre class="console">
&lt;/tr&gt;</pre></li>
				<li><strong class="source-inline">*ngSwitch</strong>: A directive that allows<a id="_idIndexMarker748"/> us to add or remove HTML elements using a switch case mechanism. The HTML elements will be displayed if the provided expression <span class="No-Break">is matched:</span><pre class="console">
//evaluates the hero variable and displays the name of the hero base on its value</pre><pre class="console">
&lt;div [ngSwitch]="hero"&gt;</pre><pre class="console">
   &lt;div *ngSwitchCase="'Dr. Strange'"&gt;</pre><pre class="console">
      Stephen Strange&lt;/div&gt;</pre><pre class="console">
   &lt;div *ngSwitchCase="'Hawkeye'"&gt;Clint Barton&lt;/div&gt;</pre><pre class="console">
   &lt;div *ngSwitchCase="'Hulk'"&gt;Bruce Banner&lt;/div&gt;</pre><pre class="console">
&lt;/div&gt;</pre></li>
			</ul>
			<h4>Attribute directives</h4>
			<p><strong class="bold">Attribute directives</strong> are directives used for changing or modifying<a id="_idIndexMarker749"/> the appearance<a id="_idIndexMarker750"/> or behavior of the element. Compared to structural directives, attribute directives cannot add or remove elements in <span class="No-Break">the DOM.</span></p>
			<p>Listed here are some of the attribute directives <span class="No-Break">in Angular:</span></p>
			<ul>
				<li><strong class="bold">ngClass</strong>: A directive used to add CSS classes<a id="_idIndexMarker751"/> to or remove them from an HTML element; this allows us to change the appearance of <span class="No-Break">elements dynamically:</span><pre class="console">
//adds an error class on the input element if the</pre><pre class="console">
//control value is invalid</pre><pre class="console">
&lt;input type="text" [ngClass]="control.isInvalid ? 'error': ''" /&gt;</pre></li>
				<li><strong class="bold">ngStyle</strong>: A directive that allows us to change the styles<a id="_idIndexMarker752"/> of <span class="No-Break">HTML</span><span class="No-Break"><a id="_idIndexMarker753"/></span><span class="No-Break"> elements:</span><pre class="console">
// the color of the element will base on the value of</pre><pre class="console">
// the color variable</pre><pre class="console">
&lt;div [ngStyle]="{'color': color}"&gt; Angular Framework &lt;/div&gt;</pre></li>
			</ul>
			<h3>Modules</h3>
			<p><strong class="bold">Modules</strong> are one of the essential features <a id="_idIndexMarker754"/>of the Angular framework. As our application<a id="_idIndexMarker755"/> gets more complex, it will consist of large blocks of components, directives, and services. This will affect the maintainability of the application’s code base. The Angular framework provides a way of organizing and grouping blocks, known <span class="No-Break">as modules.</span></p>
			<p>Modules in the Angular framework help us develop our application promoting the separation of concerns. They allow us to classify and organize blocks based on their functionality. Angular is also built using modules; the <strong class="source-inline">@angular/core</strong> framework is the primary Angular module, which provides Angular’s core functionalities <span class="No-Break">and services.</span></p>
			<h4>Creating a module</h4>
			<p>We will use the <strong class="source-inline">@NgModule</strong> decorator to create<a id="_idIndexMarker756"/> a module. It consists of several types of metadata that allow us to define the component, services, pipes, and other modules included in the <span class="No-Break">created module.</span></p>
			<p>The following example code shows the properties available for <span class="No-Break">a module:</span></p>
			<pre class="source-code">
@NgModule({
  declarations:[],
  imports:[],
  providers:[],
  exports: [],
  bootstrap:[],
  entrycomponents:[]
})</pre>
			<p>Let’s now discuss<a id="_idIndexMarker757"/> the functionality of <span class="No-Break">each property:</span></p>
			<ul>
				<li><strong class="bold">Declarations</strong>: This is where we place the components, directives, and pipes of our applications. Remember that components, directives, and pipes must be declared in only <span class="No-Break">one module.</span></li>
				<li><strong class="bold">Providers</strong>: This is where we place services to allow them to be available for <span class="No-Break">dependency injection.</span></li>
				<li><strong class="bold">Imports</strong>: This is where we place one or more other modules in our application. Once we import a specific module, all components, pipes, and directives in the imported module can <span class="No-Break">be used.</span></li>
				<li><strong class="bold">Exports</strong>: This is where we place the components, directives, and pipes to be available to other modules <span class="No-Break">once imported.</span></li>
				<li><strong class="bold">Bootstrap</strong>: This is where we place the main component of the module. The Bootstrap property is used mainly for the root module of the Angular application (<strong class="source-inline">AppModule</strong>), as the root module’s responsibility is to load the first view as our <span class="No-Break">application starts.</span></li>
				<li><strong class="bold">Entry components</strong>: This is where we place components that should be dynamically loaded in <span class="No-Break">our application.</span></li>
			</ul>
			<p>The following diagram shows how <strong class="source-inline">NgModule</strong> works in an <span class="No-Break">Angular application:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer076">
					<img alt="Figure 10.5 – Diagram for the flow of an Angular module" src="image/B18159_10_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Diagram for the flow of an Angular module</p>
			<h3>Services and dependency injection</h3>
			<p><strong class="bold">Services</strong> are also one of the<a id="_idIndexMarker758"/> valuable<a id="_idIndexMarker759"/> features<a id="_idIndexMarker760"/> of Angular. It is code<a id="_idIndexMarker761"/> that can be reused in different components of <span class="No-Break">your application.</span></p>
			<p>The primary responsibility<a id="_idIndexMarker762"/> of services is <span class="No-Break">the following:</span></p>
			<ul>
				<li>Reusing logic on <span class="No-Break">different components</span></li>
				<li>Implementing API communication and <span class="No-Break">data access</span></li>
				<li>Promoting single responsibility, as it separates the independent features <span class="No-Break">of components</span></li>
			</ul>
			<p>To create a service in the application, we will create a class and annotate it with the <strong class="source-inline">@Injectable</strong> decorator. To register the service at the root level of your application, we will add the following to our <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">Injectable</strong></span><span class="No-Break"> decorator:</span></p>
			<pre class="source-code">
@Injectable({
  providedIn: 'root',
 })</pre>
			<p>Once we have set the value of the <strong class="source-inline">providedIn</strong> metadata in the root, this will create a single, shared instance of the service throughout the application. On the other hand, if we want to provide the service in a specific module, we will place the service in the provider metadata <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">@NgModule</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
@NgModule({
    providers: [Service1]
})</pre>
			<p>Now that<a id="_idIndexMarker763"/> we have discussed some<a id="_idIndexMarker764"/> of the essential<a id="_idIndexMarker765"/> features<a id="_idIndexMarker766"/> of Angular, we will focus on how to structure your <span class="No-Break">Angular application.</span></p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor194"/>Creating the Angular folder structure</h2>
			<p>The Angular framework<a id="_idIndexMarker767"/> is considered an MVW framework, which means that there are many possible ways of structuring our application. In this case, we would discuss one of the best practices or most commonly used structures that can help your Angular application be scalable <span class="No-Break">and maintainable.</span></p>
			<p>In the previous part, we learned that Angular blocks could be grouped and organized into modules; modules are a good starting point for structuring our Angular application. The first step we can implement is to group and classify modules based on their functionality. Listed here is the classification of <span class="No-Break">our modules.</span></p>
			<h3>Root module</h3>
			<p>The <strong class="bold">root</strong> module is the application’s main<a id="_idIndexMarker768"/> module. This is the first<a id="_idIndexMarker769"/> module loaded as the Angular application starts. The root module is automatically generated when we scaffold an Angular application called <strong class="source-inline">AppModule</strong> and is found under the <span class="No-Break"><strong class="source-inline">src/app</strong></span><span class="No-Break"> folder.</span></p>
			<h3>Feature module</h3>
			<p>The <strong class="bold">feature</strong> module is where we<a id="_idIndexMarker770"/> place modules<a id="_idIndexMarker771"/> that apply a specific feature of our application. This means that most of what our code uses is inside this module. We will create the components, pipes, and directives under the module where they should be included and we can also separate components by placing the components that have a route in a <span class="No-Break">page folder.</span></p>
			<p>Let’s have a look<a id="_idIndexMarker772"/> at an example folder<a id="_idIndexMarker773"/> structure of a feature module <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">AntiHeroModule</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
├── src
│   ├── app
│   │   ├── anti-hero
│   │   │   ├── components
│   │   │   │   ├── shared.component.ts
│   │   │   ├── directives
│   │   │   │   ├── first.directive.ts
│   │   │   │   ├── another.directive.ts
│   │   │   ├── pages
│   │   │   │   ├── form
│   │   │   │   │   ├── form.component.ts
│   │   │   │   ├── list
│   │   │   │   │   ├── list.component.ts
│   │   │   │   ├── anti-hero.component.ts
│   │   │   │   ├── anti-hero.component.html
│   │   │   │   ├── anti-hero.component.css
│   │   │   │   ├── index.ts
│   │   │   ├── pipes
│   │   │   │   ├── first.pipe.ts
│   │   │   ├── anti-hero.module.ts
│   │   │   ├── anti-hero.routing.module.ts
│   │   │   ├── index.ts</pre>
			<p>In the folder structure here, we have divided our anti-hero module into several parts. The first folder is the <strong class="source-inline">components</strong> folder, which contains all of the components shared throughout<a id="_idIndexMarker774"/> this module. These can also be called <strong class="bold">dumb</strong> components, which we will discuss in the <span class="No-Break">next section.</span></p>
			<p>The next two<a id="_idIndexMarker775"/> are the <strong class="source-inline">directives</strong> and <strong class="source-inline">pipes</strong> folders, which contain<a id="_idIndexMarker776"/> the directives and pipes used in <strong class="source-inline">AntiHeroModule</strong>. Lastly, the <strong class="source-inline">pages</strong> folder includes the components in <strong class="source-inline">AntiHeroModule</strong> that have a direct<a id="_idIndexMarker777"/> route. These can also be called <strong class="bold">smart</strong> components. We have also included the <strong class="source-inline">index.ts</strong> file, known as a barrel file, which will provide a centralized place for exporting components, directives, <span class="No-Break">and pipes.</span></p>
			<h3>Shared module</h3>
			<p>The <strong class="bold">shared</strong> module is a module that is used<a id="_idIndexMarker778"/> and shared<a id="_idIndexMarker779"/> throughout the application; this is composed of the components, pipes, and directives that we are required to use in different parts of the application. Remember that a shared module should not have a dependency on other modules in <span class="No-Break">the application.</span></p>
			<p>Shared modules are created under the <span class="No-Break"><strong class="source-inline">src/app/shared</strong></span><span class="No-Break"> folder.</span></p>
			<p>Let’s have a look at the example folder structure of a shared module in <span class="No-Break">our application:</span></p>
			<pre class="source-code">
├── src
│   ├── app
│   │   ├── shared
│   │   │   ├── layout
│   │   │   │   ├── footer
│   │   │   │   │   ├── footer.component.ts
│   │   │   │   │   ├── footer.component.html
│   │   │   │   ├── header
│   │   │   │   │   ├── header.component.ts
│   │   │   │   │   ├── header.component.html
│   │   │   │   ├── layout.module.ts
│   │   │   ├── index.ts</pre>
			<p>In the preceding folder structure, we can<a id="_idIndexMarker780"/> see that we have created two<a id="_idIndexMarker781"/> components named <strong class="source-inline">footer</strong> and <strong class="source-inline">navbar</strong>; these are some of the most commonly shared components <span class="No-Break">in applications.</span></p>
			<h3>Core module</h3>
			<p>The <strong class="bold">core</strong> module is a module for services<a id="_idIndexMarker782"/> shared<a id="_idIndexMarker783"/> throughout the applications. These are singleton services, having only one instance in the application. The services that are included in the core module are usually <span class="No-Break">authentication services.</span></p>
			<p>Since it should only have one instance, the core module must only be imported into the application’s <span class="No-Break">root module.</span></p>
			<p>We can add the following code to our core module to prevent it from being imported into <span class="No-Break">other modules:</span></p>
			<pre class="source-code">
@NgModule({})
export class CoreModule {
  constructor(@Optional() @SkipSelf() core:CoreModule ){
    if (core) {
        throw new Error("Core module should only be
                         imported to the Root Module")
    }
  }
}</pre>
			<p>In the preceding code example, we have added a <strong class="source-inline">CoreModule</strong> parameter to our constructor with <strong class="source-inline">@Optional</strong> and <strong class="source-inline">@SkipSelf</strong> decorators – this will throw an error if the core returns a value indicating that <strong class="source-inline">CoreModule</strong> has already been imported into the <span class="No-Break">root module.</span></p>
			<p>Let’s now proceed to learn how to implement the structure on an <span class="No-Break">Angular application.</span></p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor195"/>Implementing the structure</h2>
			<p>Now that we have learned<a id="_idIndexMarker784"/> the different module categories for our Angular application, let’s apply the folder structure to our <span class="No-Break">superheroes project.</span></p>
			<p>Our goal here is to create<a id="_idIndexMarker785"/> a frontend application with a simple <strong class="bold">Create, Read, Update, and Delete</strong> (<strong class="bold">CRUD</strong>) functionality for heroes <span class="No-Break">and anti-heroes.</span></p>
			<p>First, we will create the shared features and the <strong class="source-inline">core</strong> folder under the <strong class="source-inline">app</strong> directory, and after completing the three main categories, we will make the blocks needed for <span class="No-Break">each module.</span></p>
			<h3>Blocks under the features module</h3>
			<p>We want to create<a id="_idIndexMarker786"/> the blocks under<a id="_idIndexMarker787"/> our features module; the first thing we need to scaffold is <strong class="source-inline">AntiHeroModule</strong>. Execute the <strong class="source-inline">ng g m anti-hero</strong> command to generate the module under the <span class="No-Break"><strong class="source-inline">src/app</strong></span><span class="No-Break"> folder.</span></p>
			<p>Now, under the anti-hero folder, we will create the <span class="No-Break">following folders:</span></p>
			<ul>
				<li><strong class="source-inline">components</strong>: This will contain components that will be shared in <span class="No-Break">this module.</span></li>
				<li><strong class="source-inline">pipes</strong>: This will contain all the pipes used by the <span class="No-Break">anti-hero module.</span></li>
				<li><strong class="source-inline">directives</strong>: This will contain all the directives that the anti-hero module <span class="No-Break">will use.</span></li>
				<li><strong class="source-inline">pages</strong>: This will contain components that have a <span class="No-Break">direct route.</span></li>
			</ul>
			<p>After creating the folders, we will now make the page components for our anti-hero module. We will add two pages where the first one will be the page for displaying the list of anti-heroes and the second one will be a form that allows us to view, create, or modify the selected hero in the list. We can execute the <strong class="source-inline">ng g c anti-hero/pages/pages/form</strong> and <strong class="source-inline">ng g c anti-hero/pages/list</strong> commands to make the two pages. This will create two new components, <strong class="source-inline">form</strong> and <strong class="source-inline">list</strong>, under the <span class="No-Break"><strong class="source-inline">pages</strong></span><span class="No-Break"> folder.</span></p>
			<p>After successfully creating the page components, we will also add a routing module for our anti-hero module. We will<a id="_idIndexMarker788"/> execute the <strong class="source-inline">ng g m anti-hero/anti-hero-routing --flat</strong> command and we will place the following<a id="_idIndexMarker789"/> code in our <span class="No-Break">routing module:</span></p>
			<pre class="source-code">
import {NgModule} from "@angular/core";
import {RouterModule, Routes} from "@angular/router";
import {ListComponent} from "./pages/list/list.component";
import {FormComponent} from "./pages/form/form.component";
const routes: Routes = [
  {
    path: "",
    component: ListComponent,
  },
  {
    path: "form",
    component: FormComponent,
  },
];
@NgModule({
  declarations: [ListComponent, FormComponent],
  imports: [RouterModule.forChild(routes)],
  exports:[RouterModule]
})
export class AntiHeroRoutingModule {}</pre>
			<p>In the preceding example code, we have defined routes for our <strong class="source-inline">form</strong> and <strong class="source-inline">list</strong> pages. This means that the page<a id="_idIndexMarker790"/> components will have direct routes in our application, and we<a id="_idIndexMarker791"/> have also defined <strong class="source-inline">ListComponent</strong> as the base route for <span class="No-Break">this module.</span></p>
			<p>After successfully creating the page components and defining routes, we want our root module (<strong class="source-inline">AppModule</strong>) to have a route <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">AntiHeroModule</strong></span><span class="No-Break">.</span></p>
			<p>To implement this, we will place the following code <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">app-routing.module.ts</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
const routes: Routes = [
  {
    path: "",
    redirectTo: "anti-heroes",
    pathMatch: "full",
  },
  {
    path: "anti-heroes",
    loadChildren: () =&gt;
      import("./anti-hero/anti-hero.module").then((m) =&gt;
             m.AntiHeroModule),
  }
];
@NgModule({
  imports: [RouterModule.forRoot(routes)],
})
export class AppRoutingModule { }</pre>
			<p>In the preceding example code, we have used lazy loading to create a route for <strong class="source-inline">AntiHeroModule</strong>. Once we visit the <strong class="source-inline">{baseUrl}/anti-heroes</strong> URL, this will load <strong class="source-inline">AntiHeroModule</strong> and redirect to the base route, which is <strong class="source-inline">ListComponent</strong>. We have also used <strong class="source-inline">RouterModule.forRoot()</strong> to import the routes, as this is the <span class="No-Break">root module.</span></p>
			<p>After successfully defining the routes for our <strong class="source-inline">AppModule</strong>, we can now see the current structure of <span class="No-Break">our application:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer077">
					<img alt="Figure 10.6 – Folder structure after creating the anti-hero feature" src="image/B18159_10_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Folder structure after creating the anti-hero feature</p>
			<p>Now that we have completed<a id="_idIndexMarker792"/> our feature module in Angular, we have<a id="_idIndexMarker793"/> only the <strong class="source-inline">pages</strong> folder. We will add other blocks such as the components and directives later as we develop the application. The next step is to make the <span class="No-Break">shared module.</span></p>
			<h3>Blocks under the shared module</h3>
			<p>Now, our next goal<a id="_idIndexMarker794"/> is to create the blocks under the shared module. We defined<a id="_idIndexMarker795"/> the shared module as components, directives, and pipes that are shared throughout the application and must not have a dependency on other modules. To create our shared module, we will execute the <strong class="source-inline">ng g m shared</strong> command. This will create a new shared folder and a module file inside the new <span class="No-Break">shared folder.</span></p>
			<p>Now after completing the shared module, we can generate the blocks that will be categorized in this module. In our application, we can include <strong class="source-inline">navbar</strong> and <strong class="source-inline">footer</strong> as shared components, as they will be used in every part of <span class="No-Break">our application.</span></p>
			<p>We will execute the <strong class="source-inline">ng g c shared/layout/navbar</strong> and <strong class="source-inline">ng g c shared/layout/footer</strong> commands to scaffold <strong class="source-inline">navbar</strong> and <strong class="source-inline">footer</strong>. We can see that <strong class="source-inline">FooterComponent</strong> and <strong class="source-inline">NavbarComponent</strong> are automatically added to the <strong class="source-inline">shared.module.ts</strong> file as Angular detects the module closest to <span class="No-Break">the components:</span></p>
			<pre class="source-code">
@NgModule({
  declarations: [
    NavbarComponent,
    FooterComponent
  ],
  imports: [CommonModule]
})
export class SharedModule { }</pre>
			<p>Remember to add the <strong class="source-inline">navbar</strong> and <strong class="source-inline">footer</strong> components in the <strong class="source-inline">exports</strong> metadata of <strong class="source-inline">NgModule</strong> and we will import the shared module in <span class="No-Break">different modules:</span></p>
			<pre class="source-code">
@NgModule({
  declarations: [
    NavbarComponent,
    FooterComponent
  ],
<strong class="bold">  exports: [NavbarComponent, FooterComponent]</strong>
  imports: [CommonModule]
})</pre>
			<p>We can also add shared directives and pipes under the shared folder by executing the <strong class="source-inline">ng g c shared/directive/directive-name</strong> and <strong class="source-inline">ng g c shared/pipes/pipe-name</strong> commands depending on the needs of our application. After successfully creating the blocks, we will have the following <span class="No-Break">folder structure:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer078">
					<img alt="Figure 10.7 – Folder structure after creating the shared module" src="image/B18159_10_07.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Folder structure after creating the shared module</p>
			<p>We must also remember that a shared<a id="_idIndexMarker796"/> module does not need a routing module since it does not have components<a id="_idIndexMarker797"/> that require routes in <span class="No-Break">our application.</span></p>
			<h3>Blocks under the core module</h3>
			<p>The last module<a id="_idIndexMarker798"/> that we need to create is the core module. Core modules<a id="_idIndexMarker799"/> are services that we share throughout the application and they have only one instance. One service that always goes into the core module is the <span class="No-Break">authentication service.</span></p>
			<p>To create our shared module, we will execute the <strong class="source-inline">ng g m core;</strong> command after completing the core module. We will scaffold the authenticate service by running the <strong class="source-inline">ng g s </strong><span class="No-Break"><strong class="source-inline">core/services/authenticate</strong></span><span class="No-Break"> command.</span></p>
			<p>After successfully creating the authenticate service, we will provide it under the <strong class="source-inline">core.module.ts</strong> file to include the service in the module. We can also add shared models under the core module by adding a <strong class="source-inline">models</strong> folder depending on the need of our application. Now, we have the following <span class="No-Break">folder structure:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer079">
					<img alt="Figure 10.8 – Folder structure after creating the shared module" src="image/B18159_10_08.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Folder structure after creating the shared module</p>
			<p>We will make the contents<a id="_idIndexMarker800"/> of the authenticate service as we go through<a id="_idIndexMarker801"/> the development of the application but now that we have created the base structure of our Angular application, we will use this structure to build other parts of the project. Now, we will discuss how we can structure our components <span class="No-Break">in Angular.</span></p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor196"/>Structuring components</h1>
			<p>We have already structured <a id="_idIndexMarker802"/>our Angular application by categorizing our modules based on their use and functionality, which will benefit code reusability and maintainability. However, there is still the possibility that a large number of components could be created under a specific module, which would further improve the maintainability of an application. In this section, we will discuss another strategy for building your Angular architecture at the <span class="No-Break">component level.</span></p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor197"/>Smart and dumb or presentation components</h2>
			<p>The most common<a id="_idIndexMarker803"/> and recommended <strong class="bold">component-level architecture</strong> for building Angular applications<a id="_idIndexMarker804"/> is the smart and<a id="_idIndexMarker805"/> dumb component architecture. In the previous section, we split the modules into different categories based on how we were using them in <span class="No-Break">the application.</span></p>
			<p>This architecture also offers the same concept. We will divide the components into two different types – namely, <strong class="bold">smart components</strong> and <strong class="bold">dumb</strong> or <span class="No-Break"><strong class="bold">presentation components</strong></span><span class="No-Break">.</span></p>
			<p>Let’s discuss the characteristics of each <span class="No-Break">component type.</span></p>
			<h3>Smart components</h3>
			<p><strong class="bold">Smart components</strong> are also known as application-level components<a id="_idIndexMarker806"/> or container components. The primary<a id="_idIndexMarker807"/> responsibility<a id="_idIndexMarker808"/> of these components<a id="_idIndexMarker809"/> is to communicate with services and consume data from a request. Since they are smart, they contain all the dependencies and subscriptions required to get the data for <span class="No-Break">the application.</span></p>
			<p>Smart components can be considered page components that have direct routes in our application and they are the parent components holding the dumb components. Let’s have a look at the following example code for creating <span class="No-Break">smart components:</span></p>
			<pre class="source-code">
@Component({
  selector: 'app-home',
  template: `
    &lt;h2&gt;User List&lt;/h2&gt;
    &lt;div&gt;
        &lt;table class="table"&gt;
            &lt;tbody&gt;
            &lt;tr (click)="selectUser(user)" *ngFor="let user
             of users"&gt;
                &lt;td&gt; {{user.firstName}} &lt;/td&gt;
                &lt;td&gt;
                    &lt;span&gt;{{user.lastName}}&lt;/span&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
`,
  styleUrls: ['./home.component.css']
})
export class HomeComponent implements OnInit {
  users: User[] = [];
  constructor(private userService: UserService) {
  }
  ngOnInit() {
      this. userService.getUsers()
          .subscribe(users =&gt; this.users = users);
  }
  selectUser(user: User) {
     // action
  }
}</pre>
			<p>In the preceding example code, we<a id="_idIndexMarker810"/> have created a component <a id="_idIndexMarker811"/>named <strong class="source-inline">HomeComponent</strong> that will display a list of users in the table. We have also injected <strong class="source-inline">UserService</strong> to get the users from an HTTP request. We know that this component will successfully display the users, but we can see that our template is extensive and might get too complicated as we add more features to <span class="No-Break">this component.</span></p>
			<p>What we would want to do is omit elements that are only for presentation purposes. In this scenario, we would like to remove the table in our <strong class="source-inline">HomeComponent</strong>, and we would have the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
@Component({
  selector: 'app-home',
  template: `
    &lt;h2&gt;User List&lt;/h2&gt;
    &lt;div&gt;
       &lt;!—we will place that dumb component here later--&gt;
    &lt;/div&gt;
`,
  styleUrls: ['./home.component.css']
})
export class HomeComponent implements OnInit {
  users: User[] = [];
  constructor(private userService: UserService) {
  }
  ngOnInit() {
      this. userService.getUsers()
          .subscribe(users =&gt; this.users = users);
  }
  selectUser(user: User) {
     // action
  }
}</pre>
			<p>In the preceding refactored code, we have removed the table displaying the list of users. We only want smart components<a id="_idIndexMarker812"/> to handle dependency<a id="_idIndexMarker813"/> injections, subscriptions, and actions. We have now successfully created our smart components and the next step is to make the <span class="No-Break">presentation components.</span></p>
			<h3>Dumb or presentation components</h3>
			<p><strong class="bold">Dumb components</strong>, also known as presentation components, are responsible<a id="_idIndexMarker814"/> for displaying data<a id="_idIndexMarker815"/> in the application. They should not have dependencies and subscriptions, as their only purpose is to present the data in <span class="No-Break">the view.</span></p>
			<p>Let’s create the table we omitted a while ago as a <span class="No-Break">dumb component:</span></p>
			<pre class="source-code">
@Component({
  selector: 'users-list',
  template: `
        &lt;table class="table"&gt;
            &lt;tbody&gt;
            &lt;tr (click)="selectUser(user)" *ngFor="let user
             of users"&gt;
                &lt;td&gt; {{user.firstName}} &lt;/td&gt;
                &lt;td&gt;
                    &lt;span&gt;{{user.lastName}}&lt;/span&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
  `,
  styleUrls: ['./users-list.component.css']
})
export class UsersListComponent {
  @Input()
  users: User[];
  @Output('user')
  userEmitter = new EventEmitter&lt;User&gt;();
   selectUser(user:User) {
        this.userEmitter.emit(user);
    }
}</pre>
			<p>In the preceding example<a id="_idIndexMarker816"/> code, we have created a separate component<a id="_idIndexMarker817"/> for the table that displays the list of users. Since dumb components have no dependencies injected, the component will need to receive the data from the smart components. To achieve this, we have added an <strong class="source-inline">@Input</strong> binding property to accept the list of users from <strong class="source-inline">HomeComponent</strong>; on the other hand, we have also added an <strong class="source-inline">@Output</strong> binding property to bubble actions to the parent or <span class="No-Break">smart component.</span></p>
			<p>Remember that dumb components must not have any logic or actions; in this case, we will pass the event in the parent component with the use of <strong class="source-inline">EventEmitter</strong> and the parent component will be responsible for the steps needed to be accomplished. In the example code, once a row is clicked, we are passing the user to the <strong class="source-inline">userEmitter</strong> that <strong class="source-inline">HomeComponent</strong> <span class="No-Break">will retrieve.</span></p>
			<p>After successfully creating <strong class="source-inline">UserListComponent</strong>, we can now use this in our <strong class="source-inline">HomeComponent</strong>, and we will have the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
@Component({
  selector: 'app-home',
  template: `
    &lt;h2&gt;User List&lt;/h2&gt;
    &lt;div&gt;
<strong class="bold">       &lt;users-list users="users"</strong>
<strong class="bold">        (user)="selectUser($event)"/&gt;</strong>
    &lt;/div&gt;
`,
  styleUrls: ['./home.component.css']
})
export class HomeComponent implements OnInit {
  users: User[] = [];
  constructor(private userService: UserService) {
  }
  ngOnInit() {
      this. userService.getUsers()
          .subscribe(users =&gt; this.users = users);
  }
  selectUser(user: User) {
     // action
  }
}</pre>
			<p>In the preceding example code, we can<a id="_idIndexMarker818"/> see that we have used <strong class="source-inline">UsersListComponent</strong> as a child component of <strong class="source-inline">HomeComponent</strong>. It accepts<a id="_idIndexMarker819"/> the list of the users retrieved by <strong class="source-inline">HomeComponent</strong> and emits an event once a specific row is clicked. With that, we have now finished discussing the concepts of smart and <span class="No-Break">dumb components.</span></p>
			<p>Let’s apply the architecture to our <span class="No-Break">application now.</span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor198"/>Implementing smart and dumb components in the project</h2>
			<p>Let’s now implement<a id="_idIndexMarker820"/> the smart and dumb component<a id="_idIndexMarker821"/> architecture in our Angular project. We will create our components under <strong class="source-inline">AntiHeroModule</strong>. We have already made our <strong class="bold">smart components</strong> and these are the <strong class="source-inline">form</strong> and <strong class="source-inline">list</strong> components in the <span class="No-Break"><strong class="source-inline">pages</strong></span><span class="No-Break"> folder.</span></p>
			<p>We will always place our smart <a id="_idIndexMarker822"/>components in<a id="_idIndexMarker823"/> the <strong class="source-inline">pages</strong> folder, as these will be our container components throughout the application. The next step is to create our dumb components. We will create two dumb components, namely the <strong class="source-inline">anti-hero-form</strong> and <strong class="source-inline">anti-hero-list</strong> components. To make the components, execute the <strong class="source-inline">ng g c anti-hero/components/anti-hero-form anti-hero/components anti-hero-list</strong> command. After successfully generating the two dumb components, let’s place the <span class="No-Break">following code.</span></p>
			<p>For <strong class="source-inline">AntiHeroListComponent</strong>, we will place the following code into the <span class="No-Break"><strong class="source-inline">anti-hero-list.component.html</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
&lt;table&gt;
    &lt;thead&gt;
        &lt;th *ngFor="let item of headers"&gt;{{item.headerName}}&lt;/th&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr (click)="selectAntiHero(item)"
 *ngFor ="let item of antiHeroes"&gt;
           &lt;ng-container *ngFor="let header of headers"&gt;
               &lt;td&gt;{{item[header.fieldName]}}&lt;/td&gt;
           &lt;/ng-container&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;</pre>
			<p>In the preceding HTML code, we have created a table where the headers and the items are bound to the <strong class="source-inline">antiHeroes</strong> variable. We have also bound the headers and the key values of the anti-hero to display the <span class="No-Break">values dynamically.</span></p>
			<p>Now, let’s add the properties for receiving and emitting data into our <span class="No-Break"><strong class="source-inline">AntiHeroList</strong></span><span class="No-Break"> component:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">anti-hero-list.component.ts</p>
			<pre class="source-code">
export class AntiHeroListComponent implements OnInit {
  @Input() headers: Array&lt;{headerName: string, fieldName:
    keyof AntiHero}&gt; = [];
  @Input() antiHeroes: Array&lt;AntiHero&gt; = [];
  @Output() antiHero = new EventEmitter();
  constructor() { }
  ngOnInit(): void {
  }
  selectAntiHero(antiHero: AntiHero) {
    this.antiHero.emit(antiHero);
  }
}</pre>
			<p>Now, in the <strong class="source-inline">TypeScript</strong> file of the anti-hero<a id="_idIndexMarker824"/> component, we have defined<a id="_idIndexMarker825"/> three properties that we need for the dumb component to accept data from and emit events to the <span class="No-Break">smart component.</span></p>
			<p>The first property is the <strong class="source-inline">headers</strong> property, which has the <strong class="source-inline">@Input</strong> annotation. This will get an array of the <strong class="source-inline">{headerName: string, fieldName: keyof AntiHero}</strong> type, which will be iterated to display the column headers and display the values of each field of an anti-hero item. The second property is <strong class="source-inline">antiHeroes</strong>, which also has an <strong class="source-inline">@Input</strong> annotation. This will accept the list of anti-heroes to be displayed in each row, and lastly, the <strong class="source-inline">antiHero</strong> property, which is annotated with <strong class="source-inline">@Output</strong>. This emits the selected anti-hero to the parent component once a user clicks a <span class="No-Break">single row.</span></p>
			<p>We have also added an interface named <strong class="source-inline">AntiHero</strong> in <strong class="source-inline">anti-hero/models/anti-hero.interface.ts</strong> that will be used to cast <span class="No-Break">object types.</span></p>
			<p>We will have the following code <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">interface</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
export interface <strong class="bold">AntiHero</strong> {
    firstName: string;
    lastName: string;
    house: string;
    kownAs: string;
}</pre>
			<p>In the preceding code<a id="_idIndexMarker826"/> example, we have created<a id="_idIndexMarker827"/> an <strong class="source-inline">AntiHero</strong> interface that will be used as the blueprint of our object. The properties of the anti-hero object are the same as the properties we defined in our <span class="No-Break">Spring application.</span></p>
			<p>After creating the interface for our object, we will now declare and import our components and modules <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">AntiHeroModule</strong></span><span class="No-Break">.</span></p>
			<p>Let’s have a look at the <span class="No-Break">following code:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">anti-hero.module.ts</p>
			<pre class="source-code">
@NgModule({
  declarations: [
    AntiHeroListComponent,
    AntiHeroFormComponent,
    ListComponent,
    FormComponent
  ],
  imports: [
    CommonModule,
    AntiHeroRoutingModule,
  ]
})
export class AntiHeroModule { }</pre>
			<p>In our <strong class="source-inline">anti-hero.module.ts</strong> file, we want to make sure<a id="_idIndexMarker828"/> that our smart components and dumb components<a id="_idIndexMarker829"/> are declared; otherwise, we will have errors at compilation. We also want to check whether our <strong class="source-inline">AntiHeroRoutingModule</strong> is imported for use of <span class="No-Break">the routes.</span></p>
			<p>Let’s now add additional styling to improve the user interface of our application. Let’s have a look at the <span class="No-Break">following code:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">anti-hero-list.component.scss</p>
			<pre class="source-code">
table, th, td {
    border: 1px solid;
    border-collapse: collapse;
    border: 1px solid;
}</pre>
			<p>We have also added a simple CSS code to style our table in the component. Now, we have successfully created our <strong class="source-inline">AntiHeroListComponent</strong>. The next step is to use this presentation component on the <strong class="source-inline">ListComponent</strong> page. Let’s have a look at the following <span class="No-Break">code example:</span></p>
			<pre class="source-code">
export class ListComponent implements OnInit {
  // sample data of anti-hero
  antiHeroes: AntiHero[] = [
    {
      firstName: "Eddie",
      lastName: "Brock",
      house: "New York",
      kownAs: "Venom"
    }
  ]
  headers: {headerName: string, fieldName: keyof
            AntiHero}[] = [
    {headerName: "First Name", fieldName: "firstName"},
    {headerName: "Last Name", fieldName: "lastName"},
    {headerName: "House", fieldName: "house"},
    {headerName: "Known As", fieldName: "kownAs"},
  ]
  constructor() { }
  ngOnInit(): void {
  }
  selectAntiHero(antiHero: AntiHero) {}
}</pre>
			<p>In the <strong class="source-inline">TypeScript</strong> file of <strong class="source-inline">ListComponent</strong>, we have created<a id="_idIndexMarker830"/> the definition<a id="_idIndexMarker831"/> of the headers and an example list of <strong class="source-inline">antiHeroes</strong> for the anti-hero list to display. This will only be temporary, as we just want to test whether our presentation component displays the list of anti-heroes successfully. We have also created the <strong class="source-inline">selectAntiHero()</strong> function for future implementation once a specific anti-hero <span class="No-Break">is selected.</span></p>
			<p>Let’s now define the input and output properties for <strong class="source-inline">AntiHeroList</strong>. Let’s have a look at the <span class="No-Break">following code:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">list.component.html</p>
			<pre class="source-code">
&lt;!-- Dumb component anti hero list --&gt;
&lt;app-anti-hero-list [antiHeroes]="antiHeroes" [headers]="headers" (antiHero)="selectAntiHero($event)"&gt;&lt;/app-anti-hero-list&gt;</pre>
			<p>Now, in the HTML file of <strong class="source-inline">ListComponent</strong>, we have bound <strong class="source-inline">headers</strong> and <strong class="source-inline">antiHeroes</strong> to the properties of <strong class="source-inline">app-anti-hero-list</strong>. We have also used the <strong class="source-inline">selectAntiHero()</strong> function to catch the event once <strong class="source-inline">antiHero</strong> has emitted <span class="No-Break">an action.</span></p>
			<p>After successfully implementing our presentation component, we can run the application and open the application in the browser. We should see the <span class="No-Break">following results:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer080">
					<img alt="Figure 10.9 – AntiHeroList presentation component" src="image/B18159_10_09.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – AntiHeroList presentation component</p>
			<p>We can see in the results that our presentation component has successfully displayed the data coming from the parent component. For the form component, we will implement its functionalities in the next chapter, as creating forms will be another <span class="No-Break">different topic.</span></p>
			<p>Now, we have learned<a id="_idIndexMarker832"/> about the concepts, structure, and implementation<a id="_idIndexMarker833"/> of smart and dumb components. In the next section, we will now use a UI framework that will help us improve the interface of our <span class="No-Break">Angular application.</span></p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor199"/>Adding Angular Material</h1>
			<p>We have already <a id="_idIndexMarker834"/>organized our Angular application using the <strong class="bold">core</strong>, <strong class="bold">feature</strong>, and <strong class="bold">shared</strong> architecture at the module level and the smart and dumb architecture at the component level. Now, we are ready to customize and improve the look and UI by styling our components. We all know that writing CSS code from scratch and developing a base style is another challenge for us developers. It creates additional effort for us beyond just worrying about the logical side of the code. This is where Angular Material saves <span class="No-Break">the day!</span></p>
			<p><strong class="bold">Angular Material</strong> is a library created by Google that provides a wide range of UI components for use in Angular applications, such as tables, cards, inputs, and date pickers. This means that we don’t have to style components from scratch, as a list of components from the material library is ready <span class="No-Break">to use.</span></p>
			<p>Angular Material<a id="_idIndexMarker835"/> has a wide range of growing components under the hood. It provides modules containing the components that can be used in Angular applications which can be imported into a specific application module; components are reusable and easy to customize in terms of their look and feel, as they have built-in properties that we <span class="No-Break">can use.</span></p>
			<p>Let’s configure Angular Material in our <span class="No-Break">Angular project.</span></p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor200"/>Configuring Angular Material</h2>
			<p>Angular Material<a id="_idIndexMarker836"/> is easy to configure in Angular projects, as it provides a schematic to install all the dependencies of Angular Material in just one command. To install Angular Material, we will execute the <span class="No-Break">following command:</span></p>
			<pre class="console">
ng add @angular/material</pre>
			<p>After executing the command, it will ask some questions before installing <span class="No-Break">the resources:</span></p>
			<ul>
				<li><strong class="bold">Choose a prebuilt theme name or “custom” for a custom theme</strong>: Angular Material provides prebuilt themes or you can configure your <span class="No-Break">custom theme.</span></li>
				<li><strong class="bold">Set up global Angular Material typography styles</strong>: Choosing <strong class="bold">yes</strong> will apply the global typography of <span class="No-Break">Angular Material.</span></li>
				<li><strong class="bold">Set up browser animations for Angular Material</strong>: Choosing <strong class="bold">yes</strong> will install <strong class="source-inline">BrowserAnimationsModule</strong> in our root module. This is important when we want to use animations from <span class="No-Break">Angular Material.</span></li>
			</ul>
			<p>After completing all the questions, it will now install Angular Material. This will execute the following actions for <span class="No-Break">our project:</span></p>
			<ol>
				<li>Adding dependencies to <strong class="source-inline">package.json</strong> <strong class="source-inline">(@angular/material</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">@angular/cdk</strong></span><span class="No-Break">).</span></li>
				<li>Adding the <strong class="source-inline">Roboto</strong> font to the <span class="No-Break"><strong class="source-inline">index.html</strong></span><span class="No-Break"> file:</span><pre class="console">
&lt;link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&amp;display=swap" rel="stylesheet"&gt;</pre></li>
				<li>Adding the Material Design icon font to the <span class="No-Break"><strong class="source-inline">index.html</strong></span><span class="No-Break"> file:</span><pre class="console">
&lt;link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"&gt;</pre></li>
				<li>Adding the following <span class="No-Break">CSS styles:</span><ul><li>Setting <strong class="source-inline">height</strong> to <strong class="source-inline">100%</strong> for <strong class="source-inline">html</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">body</strong></span></li><li>Setting <strong class="source-inline">Roboto</strong> as the <span class="No-Break">default font</span></li><li>Removing margins from <span class="No-Break">the body:</span><pre class="console">
html, body { height: 100%; }</pre><pre class="console">
body { margin: 0; font-family: Roboto, "Helvetica Neue", sans-serif; }</pre></li></ul></li>
			</ol>
			<p>After successfully installing<a id="_idIndexMarker837"/> Angular Material in our application, we are now ready to use the components in <span class="No-Break">our application.</span></p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor201"/>Implementing Angular Material</h2>
			<p>We will now implement<a id="_idIndexMarker838"/> Angular Material components in our Angular project. As we mentioned a while ago, Angular Material offers a wide range of components that we can use for building our application. In this example project, we will only define the components that we will use in our application. Let’s list the components that we <span class="No-Break">will implement.</span></p>
			<h3>Button component</h3>
			<p>The native <strong class="source-inline">&lt;button&gt;</strong> or <strong class="source-inline">&lt;a&gt;</strong> elements<a id="_idIndexMarker839"/> that are enhanced with<a id="_idIndexMarker840"/> Material <span class="No-Break">Design styling.</span></p>
			<p>We can import the button component using the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
import {MatButtonModule} from '@angular/material/button';</pre>
			<p>Here’s an example of the <span class="No-Break">button component:</span></p>
			<pre class="source-code">
&lt;div class="example-button-row"&gt;
    &lt;button mat-raised-button&gt;Basic&lt;/button&gt;
    &lt;button mat-raised-button
      color="primary"&gt;Primary&lt;/button&gt;
    &lt;button mat-raised-button
      color="accent"&gt;Accent&lt;/button&gt;
    &lt;button mat-raised-button color="warn"&gt;Warn&lt;/button&gt;
    &lt;button mat-raised-button disabled&gt;Disabled&lt;/button&gt;
    &lt;a mat-raised-button href="
      https://material.angular.io/target=" _blank&gt;Link&lt;/a&gt;
 &lt;/div&gt;</pre>
			<p>In the preceding code<a id="_idIndexMarker841"/> example for the <strong class="bold">Material</strong> button, we can see that we are using<a id="_idIndexMarker842"/> built-in directives from Material Design to change the style and look of the button. The example code will have the <span class="No-Break">following output:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer081">
					<img alt="Figure 10.10 – Example output for the Material button" src="image/B18159_10_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – Example output for the Material button</p>
			<h3>Icon component</h3>
			<p>This component<a id="_idIndexMarker843"/> allows us to add vector-based icons to the application<a id="_idIndexMarker844"/> and supports both icon fonts and <span class="No-Break">SVG icons.</span></p>
			<p>We can import the icon component using the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
import {MatIconModule} from '@angular/material/icon';</pre>
			<p>Here’s an example of the <span class="No-Break">icon component:</span></p>
			<pre class="source-code">
&lt;mat-icon color="primary"&gt;delete&lt;/mat-icon&gt;
&lt;mat-icon color="accent"&gt;fiber_new&lt;/mat-icon&gt;
&lt;mat-icon color="warn"&gt;pageview&lt;/mat-icon&gt;</pre>
			<p>In the preceding<a id="_idIndexMarker845"/> code example, we can<a id="_idIndexMarker846"/> create icons by using the <strong class="source-inline">mat-icon</strong> component. This has several input properties such as color that allow us to customize the color of the icon. The example code will have the <span class="No-Break">following output:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer082">
					<img alt="Figure 10.11 – Example output for the Material icon" src="image/B18159_10_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – Example output for the Material icon</p>
			<h3>Table component</h3>
			<p>This component<a id="_idIndexMarker847"/> allows us to add a data table with Material Design<a id="_idIndexMarker848"/> styling. The Material table<a id="_idIndexMarker849"/> is based on the foundation of the <strong class="bold">CDK data table</strong>. For more information on how to implement a CDK<a id="_idIndexMarker850"/> data table, see the documentation <span class="No-Break">at </span><span class="No-Break">https://material.angular.io/cdk/table/overview</span><span class="No-Break">.</span></p>
			<p>We can import the table component using the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
import {MatTableModule} from '@angular/material/table';</pre>
			<p>Here’s an example of the <span class="No-Break">table component:</span></p>
			<pre class="source-code">
&lt;table mat-table [dataSource]="data" class="mat-elevation-z8"&gt;
  &lt;!-- Position Column --&gt;
  &lt;ng-container matColumnDef="id"&gt;
    &lt;th mat-header-cell *matHeaderCellDef&gt; ID &lt;/th&gt;
    &lt;td mat-cell *matCellDef="let element"&gt;
     {{element.position}} &lt;/td&gt;
  &lt;/ng-container&gt;
  &lt;!-- Name Column --&gt;
  &lt;ng-container matColumnDef="name"&gt;
    &lt;th mat-header-cell *matHeaderCellDef&gt; Name &lt;/th&gt;
    &lt;td mat-cell *matCellDef="let element"&gt;
      {{element.name}} &lt;/td&gt;
  &lt;/ng-container&gt;
  &lt;tr mat-header-row *matHeaderRowDef="columns"&gt;&lt;/tr&gt;
  &lt;tr mat-row *matRowDef="let row; columns: columns;"&gt;&lt;/tr&gt;
&lt;/table&gt;c</pre>
			<p>In the preceding example, we can see<a id="_idIndexMarker851"/> the table uses several properties. The first property<a id="_idIndexMarker852"/> is the <strong class="source-inline">dataSource</strong> property, which will be the one accepting the list of data to be displayed. The next property is <strong class="source-inline">matColumnDef</strong>, which defines the field name of each column that should be included in the <strong class="source-inline">columns</strong> variable that is bound to the <strong class="source-inline">matHeaderRowDef</strong> property. Lastly, the <strong class="source-inline">matHeaderCellDef</strong> and <strong class="source-inline">mattCelDef</strong> properties display the actual column name and the associated values, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer083">
					<img alt="Figure 10.12 – Example output for the Material table" src="image/B18159_10_12.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – Example output for the Material table</p>
			<h3>Toolbar component</h3>
			<p>This component<a id="_idIndexMarker853"/> allows us to add<a id="_idIndexMarker854"/> a toolbar with Material Design styling. This is commonly used as a container for headers, titles, and <span class="No-Break">navigation buttons.</span></p>
			<p>We can import the toolbar component using the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
import {MatToolbarModule} from '@angular/material/toolbar';</pre>
			<p>Here’s an example of the <span class="No-Break">toolbar component:</span></p>
			<pre class="source-code">
  &lt;p&gt;
    &lt;mat-toolbar color="primary"&gt;
      &lt;button mat-icon-button class="example-icon"
        aria-label="Example icon-button with menu icon"&gt;
        &lt;mat-icon&gt;menu&lt;/mat-icon&gt;
      &lt;/button&gt;
      &lt;span&gt;Angular CRUD&lt;/span&gt;
    &lt;/mat-toolbar&gt;
  &lt;/p&gt;</pre>
			<p>In the preceding code example, we have created<a id="_idIndexMarker855"/> a toolbar element using the <strong class="source-inline">mat-toolbar</strong> component. The <strong class="source-inline">mat-toolbar</strong> component uses content<a id="_idIndexMarker856"/> projection that allows us to customize its contents. The example code will have the <span class="No-Break">following output:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer084">
					<img alt="Figure 10.13 – Example output for the Material toolbar" src="image/B18159_10_13.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.13 – Example output for the Material toolbar</p>
			<h3>Form field component</h3>
			<p>This component<a id="_idIndexMarker857"/> allows us to wrap<a id="_idIndexMarker858"/> Material components to apply text field styles such as underlining, hint messages, and floating labels. The following components can be used <span class="No-Break">inside </span><span class="No-Break"><strong class="source-inline">&lt;mat-form-field&gt;</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">input matNativeControl&gt;</strong> and <strong class="source-inline">&lt;textarea matNativeControl&gt;</strong>: Can be used by adding <strong class="source-inline">import {MatInputModule} </strong><span class="No-Break"><strong class="source-inline">from '@angular/material/input';</strong></span></li>
				<li><strong class="source-inline">&lt;mat-select&gt;</strong>: Can be used by adding <strong class="source-inline">import {MatSelectModule} from '@</strong><span class="No-Break"><strong class="source-inline">angular/material/select';</strong></span></li>
				<li><strong class="source-inline">&lt;mat-chip-list&gt;</strong>: Can be used by adding <strong class="source-inline">import {MatChipsModule} from '@</strong><span class="No-Break"><strong class="source-inline">angular/material/chips';</strong></span></li>
			</ul>
			<p>Here’s an example<a id="_idIndexMarker859"/> of the form <span class="No-Break">field</span><span class="No-Break"><a id="_idIndexMarker860"/></span><span class="No-Break"> component:</span></p>
			<pre class="source-code">
&lt;p&gt;
  &lt;mat-form-field appearance="legacy"&gt;
    &lt;mat-label&gt;Legacy form field&lt;/mat-label&gt;
    &lt;input matInput placeholder="Placeholder"&gt;
  &lt;/mat-form-field&gt;
&lt;/p&gt;
&lt;p&gt;
  &lt;mat-form-field appearance="standard"&gt;
    &lt;mat-label&gt;Standard form field&lt;/mat-label&gt;
    &lt;input matInput placeholder="Placeholder"&gt;
  &lt;/mat-form-field&gt;
&lt;/p&gt;
&lt;p&gt;
  &lt;mat-form-field appearance="fill"&gt;
    &lt;mat-label&gt;Fill form field&lt;/mat-label&gt;
    &lt;input matInput placeholder="Placeholder"&gt;
  &lt;/mat-form-field&gt;
&lt;/p&gt;
&lt;p&gt;
  &lt;mat-form-field appearance="outline"&gt;
    &lt;mat-label&gt;Outline form field&lt;/mat-label&gt;
    &lt;input matInput placeholder="Placeholder"&gt;
  &lt;/mat-form-field&gt;
&lt;/p&gt;</pre>
			<p>In the preceding code example, we have created a toolbar element using the <strong class="source-inline">mat-form-field</strong> component. The <strong class="source-inline">mat-form-field</strong> component should have the <strong class="source-inline">mat-label</strong> component <a id="_idIndexMarker861"/>and an input element with the <strong class="source-inline">matInput</strong> directive<a id="_idIndexMarker862"/> as its contents. The example code will have the <span class="No-Break">following output:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer085">
					<img alt="Figure 10.14 – Example output for the Material form field" src="image/B18159_10_14.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.14 – Example output for the Material form field</p>
			<p>For more information<a id="_idIndexMarker863"/> on the list of components from Angular Material, see the documentation <span class="No-Break">at </span><span class="No-Break">https://material.angular.io/components</span><span class="No-Break">.</span></p>
			<p>Now that we have listed the Material components we will use in our application, let’s apply Material Design to <span class="No-Break">our components.</span></p>
			<p>The first step we need to do is to create our Material module. The Material modules will be included in the shared module so that we can use Material design components throughout the application. To generate our Material module in our Angular application, we will execute<a id="_idIndexMarker864"/> the following command: <strong class="source-inline">ng g m material</strong>. After successfully<a id="_idIndexMarker865"/> generating the Material module, we will add the necessary modules from <span class="No-Break">Angular Material:</span></p>
			<pre class="source-code">
@NgModule({
  imports: [
    CommonModule,
    MatToolbarModule,
    MatIconModule,
    MatButtonModule,
    MatTableModule,
    MatFormFieldModule,
    MatSelectModule,
    MatInputModule,
  ],
  exports: [
    MatToolbarModule,
    MatIconModule,
    MatButtonModule,
    MatTableModule,
    MatFormFieldModule,
    MatSelectModule,
    MatInputModule,
  ]
})
export class MaterialModule { }</pre>
			<p>We can see in the preceding example that we have also exported the Material modules, as we will use them on different modules in <span class="No-Break">the application.</span></p>
			<p>Now that we have imported<a id="_idIndexMarker866"/> the needed modules<a id="_idIndexMarker867"/> for our application, let’s convert <span class="No-Break">the components.</span></p>
			<h3>Navbar component</h3>
			<p>The <strong class="bold">navbar component</strong> is found under the shared module. We<a id="_idIndexMarker868"/> will use the toolbar <a id="_idIndexMarker869"/>material to create our navbar component. To implement this, we will place the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
&lt;p&gt;
    &lt;mat-toolbar color="primary"&gt;
      &lt;/button&gt;
      &lt;span&gt;Angular CRUD&lt;/span&gt;
    &lt;/mat-toolbar&gt;
  &lt;/p&gt;</pre>
			<p>In the preceding example, we have used the <strong class="source-inline">mat-toolbar</strong> element to use the toolbar material. We can also add a color property to style the toolbar and add additional <span class="No-Break">elements inside.</span></p>
			<p>We also need to import <strong class="source-inline">MaterialModule</strong> under <strong class="source-inline">SharedModule</strong> for this to recognize <strong class="source-inline">MatToolbarModule</strong> and it will output <span class="No-Break">the following:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer086">
					<img alt="Figure 10.15 – The look of the navbar component after implementing Material" src="image/B18159_10_15.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.15 – The look of the navbar component after implementing Material</p>
			<h3>Anti-hero list component</h3>
			<p>This component is found under <a id="_idIndexMarker870"/>the anti-hero module. We will use the table material to create our list component. To implement this, we will place<a id="_idIndexMarker871"/> the following code <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">anti-hero-list.component.html</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&lt;table mat-table [dataSource]="antiHeroes" class="mat-elevation-z8"&gt;
    &lt;!-- Data for columns --&gt;
    &lt;ng-container *ngFor="let item of headers"
     [matColumnDef]="item.fieldName"&gt;
      &lt;th mat-header-cell *matHeaderCellDef&gt;
        {{item.headerName}} &lt;/th&gt;
      &lt;td mat-cell *matCellDef="let element"&gt;
        {{element[item.fieldName]}} &lt;/td&gt;
    &lt;/ng-container&gt;
    &lt;!-- Actions for specific item --&gt;
    &lt;ng-container matColumnDef="actions"&gt;
        &lt;th mat-header-cell *matHeaderCellDef&gt;
          Actions &lt;/th&gt;
        &lt;td mat-cell *matCellDef="let element"&gt;
            &lt;button (click)="selectAntiHero(element, 0)"
              mat-raised-button color="primary"&gt;
                &lt;mat-icon&gt;pageview&lt;/mat-icon&gt; View
            &lt;/button&gt;
            &amp;nbsp;
            &lt;button (click)="selectAntiHero(element, 1)"
              mat-raised-button color="warn"&gt;
                &lt;mat-icon&gt;delete&lt;/mat-icon&gt; Delete
            &lt;/button&gt;
        &lt;/td&gt;
    &lt;/ng-container&gt;
    &lt;tr mat-header-row *matHeaderRowDef="headerFields"&gt;
    &lt;/tr&gt;
    &lt;tr mat-row *matRowDef="let row; columns:
      headerFields"&gt;&lt;/tr&gt;
  &lt;/table&gt;</pre>
			<p>We<a id="_idIndexMarker872"/> will place<a id="_idIndexMarker873"/> this <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">anti-hero-list.component.ts</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
export class AntiHeroListComponent implements OnInit {
  @Input() headers: Array&lt;{headerName: string, fieldName:
    keyof AntiHero}&gt; = [];
  @Input() antiHeroes: Array&lt;AntiHero&gt; = [];
  @Output() antiHero = new EventEmitter&lt;{antiHero:
    AntiHero, action :TableActions}&gt;();
<strong class="bold">  headerFields: string[] = [];</strong>
  ngOnInit(): void {
<strong class="bold">    this.getHeaderFields();</strong>
  }
<strong class="bold">  getHeaderFields() {</strong>
<strong class="bold">    this.headerFields = this.headers.map((data) =&gt;</strong>
<strong class="bold">      data.fieldName);</strong>
<strong class="bold">    this.headerFields.push("actions");</strong>
<strong class="bold">  }</strong>
  selectAntiHero(antiHero: AntiHero, action: TableActions) {
    this.antiHero.emit({antiHero, action});
  }
}</pre>
			<p>In the preceding example code, we have still used the same variables in our application; the <strong class="source-inline">antiHeroes</strong> variable that holds the list of anti-heroes is now bound to the <strong class="source-inline">dataSource</strong> property and we have also iterated the <strong class="source-inline">headers</strong> property to display the column name and its associated values. Lastly, we have created a new variable named <strong class="source-inline">headerFields</strong> that contains the <strong class="source-inline">fieldName</strong> to display the values of an <span class="No-Break">anti-hero item.</span></p>
			<p>We also need to import <strong class="source-inline">MaterialModule</strong> under <strong class="source-inline">AntiHeroModule</strong> for this to recognize <strong class="source-inline">MatTableModule</strong> and it will have<a id="_idIndexMarker874"/> the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker875"/></span><span class="No-Break"> output:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer087">
					<img alt="Figure 10.16 – The look of the table component after implementing Material" src="image/B18159_10_16.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.16 – The look of the table component after implementing Material</p>
			<h3>Command bar component</h3>
			<p>We will create<a id="_idIndexMarker876"/> a new dumb component<a id="_idIndexMarker877"/> under the anti-hero module. We will execute the <strong class="source-inline">ng g c anti-hero/components/anti-hero-command-bar</strong> command and we will place the following code <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">anti-hero-command-bar.html</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&lt;p&gt;
    &lt;mat-toolbar&gt;
        &lt;button mat-raised-button color="primary"
          (click)="emitAction(0)"&gt;
            &lt;mat-icon&gt;fiber_new&lt;/mat-icon&gt; Create
        &lt;/button&gt;
        &amp;nbsp;
        &lt;button  mat-raised-button color="warn"
          (click)="emitAction(0)"&gt;
            &lt;mat-icon&gt;delete&lt;/mat-icon&gt; Delete All
        &lt;/button&gt;
    &lt;/mat-toolbar&gt;
  &lt;/p&gt;</pre>
			<p>We will place<a id="_idIndexMarker878"/> this<a id="_idIndexMarker879"/> <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">anti-hero-command-bar.ts</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
export class AntiHeroCommandBarComponent implements OnInit {
  @Output() action = new EventEmitter&lt;CommandBarActions&gt;()
  constructor() { }
  ngOnInit(): void {
  }
  emitAction(action: CommandBarActions) {
    this.action.emit(action);
  }
}</pre>
			<p>In the preceding example code, we have also used the toolbar module to create our command bar component. Since this is a dumb component, we should only emit the actions to its parent component and not hold any dependencies. After successfully creating the command bar, we will get the <span class="No-Break">following output:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer088">
					<img alt="Figure 10.17 – The look of the command bar component after implementing Material" src="image/B18159_10_17.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.17 – The look of the command bar component after implementing Material</p>
			<p>Now, we will finalize<a id="_idIndexMarker880"/> the application<a id="_idIndexMarker881"/> layout by placing the components on the <span class="No-Break">following page:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">app.component.html</strong></span><span class="No-Break">:</span><pre class="console">
&lt;app-navbar&gt;&lt;/app-navbar&gt;</pre><pre class="console">
&lt;div class="container"&gt;</pre><pre class="console">
    &lt;router-outlet&gt;&lt;/router-outlet&gt;</pre><pre class="console">
&lt;/div&gt;</pre></li>
				<li><span class="No-Break"><strong class="source-inline">list.component.html</strong></span><span class="No-Break">:</span><pre class="console">
&lt;!—Dumb component command bar </pre><pre class="console">
&lt;app-anti-hero-command-bar&gt;</pre><pre class="console">
&lt;/app-anti-hero-command-bar&gt;—-- Dumb component anti hero list --&gt;</pre><pre class="console">
&lt;app-anti-hero-list [antiHeroe"]="antiHer"es" [header"]="head"rs"&gt;&lt;/app-anti-hero-list&gt;</pre></li>
			</ul>
			<p>After successfully implementing the preceding code, we will now have the <span class="No-Break">following layout:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer089">
					<img alt="Figure 10.18 – Layout for the list component page" src="image/B18159_10_18.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.18 – Layout for the list component page</p>
			<p>We have now created our anti-heroes page component with Material Design. As we go through the following<a id="_idIndexMarker882"/> chapters, we will implement the features<a id="_idIndexMarker883"/> for the action buttons and the <span class="No-Break">form component.</span></p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor202"/>Summary</h1>
			<p>With this, we have reached the end of this chapter. Let’s have a recap of the valuable things you have learned; you have learned about the concepts and fundamentals of Angular and, at the same time, how to scaffold an Angular project and create components, directives, and modules using the Angular CLI. You have also learned some of the best practices for organizing our Angular components, modules, and other parts of our Angular project. This will be very useful for the maintainability of the project, especially for <span class="No-Break">enterprise applications.</span></p>
			<p>In the next chapter, we will learn how to build Reactive forms, essential form control, and grouping form controls in Angular. We will also implement <strong class="source-inline">FormBuilder</strong> and validate <span class="No-Break">form input.</span></p>
		</div>
	</body></html>