<html><head></head><body>
		<div id="_idContainer199">
			<h1 id="_idParaDest-139"><em class="italic"><a id="_idTextAnchor138"/>Chapter 9</em>: Integrating with External Systems</h1>
			<p class="author-quote">Wholeness is not achieved by cutting off a portion of one’s being, but by integration of the contraries.</p>
			<p class="author-quote">– Carl Jung</p>
			<p>So far, we have used DDD to implement a robust core for our application. However, most solutions (by extension-bounded contexts) usually have both upstream and downstream dependencies that usually change at a pace, which is different from these core components. To maintain both agility and reliability and enable loose coupling, it is important to integrate with a peripheral system in a manner that shields the core from everything else that surrounds it. </p>
			<p>In this chapter, we will look at the LC application processing solution and examine the means by which we can integrate with other components in the ecosystem. You will learn how to recognize relationship patterns between components.</p>
			<p>This chapter covers the following main topics:</p>
			<ul>
				<li>Continuing our design journey</li>
				<li>Bounded context relationships</li>
				<li>Implementation patterns</li>
			</ul>
			<p>By the end of the chapter, we will round off by looking at common patterns when integrating with legacy applications. Let’s dive right in!</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor139"/>Continuing our design journey</h1>
			<p>From our domain analysis in earlier chapters, we have arrived at four bounded contexts for our application, as depicted here:</p>
			<div>
				<div id="_idContainer181" class="IMG---Figure">
					<img src="image/B16716_Figure_9.01.jpg" alt="Figure 9.1 – Relationship between bounded contexts&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Relationship between bounded contexts</p>
			<p>So far, our focus has been on the implementation of the internals of the <strong class="bold">LC application</strong> bounded context. While the LC application bounded context is independent of the <a id="_idIndexMarker516"/>other bounded contexts, it is not completely isolated from them. For example, when processing an LC application, we need to perform merchandise and applicant checks that require interactions with the <strong class="bold">compliance</strong> and <strong class="bold">customer onboarding</strong> bounded contexts respectively. This means that these <a id="_idIndexMarker517"/>bounded contexts have a relationship with each other. These relationships are <a id="_idIndexMarker518"/>driven by the nature of collaboration between the teams working on the respective bounded contexts. Let’s examine how these team dynamics influence integration mechanisms between bounded contexts in a way that continues to preserve their individual integrity.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor140"/>Bounded context relationships</h1>
			<p>We need bounded contexts <a id="_idIndexMarker519"/>to be as independent as possible. However, this does not mean that bounded contexts are completely isolated from each other. Bounded contexts need to collaborate with others to provide business value. Whenever there is collaboration required between two bounded contexts, the nature of their relationship is not only influenced by their individual goals and priorities but also by the prevailing organizational realities. In a high-performing environment, it is fairly common to have a single team assume ownership of a bounded context. The relationships between the teams owning these bounded contexts play a significant role in influencing the integration patterns employed to arrive at a solution. At a high level, there are two categories of relationships:</p>
			<ul>
				<li>Symmetric</li>
				<li>Asymmetric</li>
			</ul>
			<p>Let’s look at these relationship types in more detail.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor141"/>Symmetric relationship patterns</h2>
			<p>Two teams, say team A and team B, can <a id="_idIndexMarker520"/>be said to have a symmetric relationship when they have an equal amount of influence in the decision-making <a id="_idIndexMarker521"/>process to arrive at a solution. Both teams are in a position to, and, indeed, do, contribute more or less equally toward the outcome. Here’s a diagrammatic representation:</p>
			<div>
				<div id="_idContainer182" class="IMG---Figure">
					<img src="image/B16716_Figure_9.02.jpg" alt="Figure 9.2 – Both teams have an equal say in influencing the solution&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Both teams have an equal say in influencing the solution</p>
			<p>There are three variations of symmetric relationships, each of which we will outline in more detail in the following subsections.</p>
			<h3>Partnership</h3>
			<p>In a partnership, both teams integrate in an ad hoc manner. There are no fixed responsibilities <a id="_idIndexMarker522"/>assigned when needing complete integration work. Each team picks up work as and when needed without the need for any specific ceremony or fanfare. The nature of the integration is usually two-way, with both teams exchanging solution artifacts as and when needed. Such relationships require extremely high degrees of collaboration and understanding of the work done by both teams. Check the following figure:</p>
			<div>
				<div id="_idContainer183" class="IMG---Figure">
					<img src="image/B16716_Figure_9.03.jpg" alt="Figure 9.3 – There is an ad hoc mutual dependency between teams in a partnership relationship&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – There is an ad hoc mutual dependency between teams in a partnership relationship</p>
			<h4>Example</h4>
			<p>Let’s take as an <a id="_idIndexMarker523"/>example a web frontend team working in close collaboration with an API team building the BFFs (<a href="https://philcalcado.com/2015/09/18/the_back_end_for_front_end_pattern_bff.html">https://philcalcado.com/2015/09/18/the_back_end_for_front_end_pattern_bff.html</a>) for the frontend. The BFF team creates experience APIs meant to be used exclusively by the frontend. To fulfill any functionality, the frontend team requires capabilities to be exposed by the APIs team. On the other hand, the APIs team is dependent on the frontend team to provide advice on what capabilities to build and the order in which to build them. Both teams freely make use of each other’s domain models (for example, the same set of request and response objects that define the API) to implement functionality. Such reuse happens mostly arbitrarily, and when API changes happen, both teams coordinate changes to keep things working.</p>
			<h4>When to use</h4>
			<p>Partnership between teams requires high levels of collaboration, trust, and understanding. Teams tend to use this partnership when team boundaries are informal. It also <a id="_idIndexMarker524"/>helps if these teams are co-located and/or have a significant working time overlap.</p>
			<h4>Potential pitfalls</h4>
			<p>Partnership <a id="_idIndexMarker525"/>relationships between teams can lead to a situation where individual team responsibilities become very unclear, leading a solution toward the dreaded <em class="italic">big ball of mud</em>.</p>
			<h3>Shared kernel</h3>
			<p>Unlike in a partnership, when using a shared kernel, teams have a clear understanding of the solution <a id="_idIndexMarker526"/>artifacts and models they choose to share between themselves. Both teams take equal responsibility for the upkeep of these shared artifacts.</p>
			<h4>Example</h4>
			<p>The <em class="italic">LC application processing</em> and <em class="italic">customer onboarding</em> teams in our LC application may choose <a id="_idIndexMarker527"/>to use a common model to represent <strong class="source-inline">CustomerCreditValidatedEvent</strong>. Any enhancements or changes to the event schema can affect both teams. The responsibility to make any changes is owned by both teams. Intentionally, these teams do not share anything beyond these mutually agreed-upon models and artifacts. Here’s a representation of a shared kernel relationship between teams:</p>
			<div>
				<div id="_idContainer184" class="IMG---Figure">
					<img src="image/B16716_Figure_9.04.jpg" alt="Figure 9.4 – Teams have an explicit understanding of shared models&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Teams have an explicit understanding of shared models</p>
			<h4>When to use</h4>
			<p>The shared kernel form <a id="_idIndexMarker528"/>of collaboration works well if shared artifacts are required to be consumed in an identical fashion in <a id="_idIndexMarker529"/>both contexts. Furthermore, it is attractive for multiple teams to coordinate and continue sharing, as opposed to duplicating identical models in both contexts.</p>
			<h4>Potential pitfalls</h4>
			<p>Changes made to the shared kernel affect both bounded contexts. This means that any change made <a id="_idIndexMarker530"/>to the shared kernel needs to remain compatible for both teams. Needless to say, as the number of teams using the shared kernel increases, the cost of coordination goes up manifold.</p>
			<h3>Separate ways</h3>
			<p>When two teams <a id="_idIndexMarker531"/>choose to not share any artifacts or models between them, they go their own separate ways:</p>
			<div>
				<div id="_idContainer185" class="IMG---Figure">
					<img src="image/B16716_Figure_9.05.jpg" alt="Figure 9.5 – Teams go separate ways and don’t share anything between them&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Teams go separate ways and don’t share anything between them</p>
			<h4>Example</h4>
			<p>The <em class="italic">LC application processing</em> and <em class="italic">customer onboarding</em> teams may start by sharing the same build/deployment scripts for their services. Over a period of time, deployment requirements <a id="_idIndexMarker532"/>may diverge to a point where the shared cost of maintaining these scripts becomes prohibitively expensive, causing these teams to fork their deployments to regain independence from the other team.</p>
			<h4>When to use</h4>
			<p>In some cases, two teams may be unable to collaborate for a variety of reasons, ranging from a drift in <a id="_idIndexMarker533"/>individual team requirements to organizational politics. Whatever the case may be, these teams may decide <a id="_idIndexMarker534"/>that the cost of collaboration is too high, resulting in them going their own separate ways.</p>
			<h4>Potential pitfalls</h4>
			<p>Choosing to go separate ways may result in duplicate work across affected bounded contexts. When <a id="_idIndexMarker535"/>working in bounded contexts that map to core subdomains, this may prove counterproductive, as it can lead to inconsistent behaviors unintentionally.</p>
			<p>It is possible to transition from one relationship type to another over a period of time. In our experience, transitioning from any one of these relationships may not be straightforward. In cases where requirements are relatively clear at the outset, it may be easier to start with a <em class="italic">shared kernel</em>. Conversely, if requirements are unclear, it may be prudent to start either with a loose <em class="italic">partnership</em> or go <em class="italic">separate ways</em> until requirements become clear. In any of these scenarios, it is important to keep evaluating the nature of the relationship and transition to a more appropriate type, based on our enhanced understanding of the requirements and/or the relationship itself.</p>
			<p>In each of the preceding characterized relationships, the teams involved have a more or less equal say in how the relationship evolved and the resulting outcomes. However, this may not always be the case. Let’s look at examples of cases where one team may have a clear upper hand in terms of how the relationship evolves.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor142"/>Asymmetric relationship patterns</h2>
			<p>Two teams can be said to have an asymmetric relationship when one of the teams has a stronger <a id="_idIndexMarker536"/>influence in the decision-making process to arrive at a solution. In other words, there is a clear <a id="_idIndexMarker537"/>customer-supplier (or upstream-downstream) relationship where either the customer or the supplier plays a dominant role that affects solution design approaches. It is also likely that the customer and the supplier do not share common goals. Here is a representation of an asymmetric relationship between customer and supplier:</p>
			<div>
				<div id="_idContainer186" class="IMG---Figure">
					<img src="image/B16716_Figure_9.06.jpg" alt="Figure 9.6 – One of the teams has a dominant say in influencing the solution&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – One of the teams has a dominant say in influencing the solution</p>
			<p>There are <a id="_idIndexMarker538"/>at least three <a id="_idIndexMarker539"/>solution patterns when teams are in an asymmetric relationship, each of which we will outline in more detail in the following subsections. </p>
			<h3>Conformist (CF)</h3>
			<p>It is not unusual for the side playing the supplier role to have a dominant say in how the relationship <a id="_idIndexMarker540"/>with one or more customers is implemented. Furthermore, the customer may simply choose to conform to the supplier-provided solution as is, making it an integral part of their own solution. In other words, the supplier provides a set of models and the customer uses those same models to build their solution. In this case, the customer is considered to be a <em class="italic">conformist</em>:</p>
			<div>
				<div id="_idContainer187" class="IMG---Figure">
					<img src="image/B16716_Figure_9.07.jpg" alt="Figure 9.7 – The customer accepts dependency on the supplier model&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – The customer accepts dependency on the supplier model</p>
			<h4>Example</h4>
			<p>When building a <a id="_idIndexMarker541"/>solution to validate the United States postal addresses of LC applicants, we chose to conform to the USPS Web Tools address validation API schema (<a href="https://www.usps.com/business/web-tools-apis/">https://www.usps.com/business/web-tools-apis/</a>). Given that the business started with just US-based applicants, this made sense. This means that any references to the address model in our bounded contexts mimic the schema prescribed by the USPS. Furthermore, it means that we will need to keep up with changes that occur in the USPS API <a id="_idIndexMarker542"/>as and when they occur (regardless of whether those changes are needed for our own functionality).</p>
			<h4>When to use</h4>
			<p>Being a conformist is not necessarily a negative thing. The supplier’s models may be a well-accepted industry standard, or they may simply be good enough for our needs. It may <a id="_idIndexMarker543"/>also be that the team may not have the necessary skills, motivation, or immediate need to do something different from what the supplier has provided. This approach also enables teams to make quick progress, leveraging work mostly done by other experts.</p>
			<h4>Potential pitfalls</h4>
			<p>An overuse of the conformist pattern may dilute the ubiquitous language of our own bounded contexts, resulting in a situation where there is no clear separation between the supplier <a id="_idIndexMarker544"/>and customer concepts. It may also be that concepts that are core to the supplier’s context leak into our own, despite those concepts carrying little to no meaning in our context. This may result in these bounded contexts being very tightly coupled with each other. And if a need arises to switch to another supplier or support multiple suppliers, the cost of change may be prohibitively expensive.</p>
			<h3>Anti-Corruption Layer</h3>
			<p>There may be scenarios where a customer may need to collaborate with a supplier but may <a id="_idIndexMarker545"/>want to shield themselves from the supplier’s ubiquitous language and models. In such cases, it may be prudent to redefine these conflicting models in the customer’s own ubiquitous language using a <a id="_idIndexMarker546"/>translation layer at the time of integration, also known as an <strong class="bold">Anti-Corruption Layer</strong> (<strong class="bold">ACL</strong>). See the following figure:</p>
			<div>
				<div id="_idContainer188" class="IMG---Figure">
					<img src="image/B16716_Figure_9.08.jpg" alt="Figure 9.8 – The customer wants to protect themselves from supplier models&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – The customer wants to protect themselves from supplier models</p>
			<h4>Example</h4>
			<p>In the address validation example referenced in the <em class="italic">Conformist (CF)</em> section, the <em class="italic">LC application processing</em> team may need to support Canadian applicants as well. In such a case, being a conformist to a system that supports only US addresses may prove restrictive <a id="_idIndexMarker547"/>and even confusing. For example, the US <em class="italic">state</em> is analogous to a <em class="italic">province</em> in Canada. Similarly, a <em class="italic">ZIP code</em> in the US is called a <em class="italic">postal code</em> in Canada. In addition, US ZIP codes are numeric whereas Canadian postal codes are alphanumeric. Most importantly, we currently do not have the notion of a <em class="italic">country code</em> in our address model, but now we will need to introduce this concept to differentiate addresses within the respective countries. Let’s look at the address models from the respective countries here:</p>
			<div>
				<div id="_idContainer189" class="IMG---Figure">
					<img src="image/B16716_Figure_9.09.jpg" alt="Figure 9.9 – The address models of different countries &#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – The address models of different countries </p>
			<p>While we initially conformed to the USPS model, we have now evolved to support more countries. For example, <em class="italic">region</em> is used to represent the concept of <em class="italic">state/province</em>. Also, we <a id="_idIndexMarker548"/>have introduced the <em class="italic">country</em> value object, which was missing earlier.</p>
			<h4>When to use</h4>
			<p>ACLs come in handy when the customer models are part of a core domain. The ACL shields <a id="_idIndexMarker549"/>the customer from changes in the supplier’s models and can help produce more loosely coupled integrations. It may also be necessary when we are looking to integrate similar concepts from multiple suppliers.</p>
			<h4>Potential pitfalls</h4>
			<p>Using an ACL may be tempting in a lot of cases. However, it is less beneficial when the concepts being integrated don’t often change or are defined by a well-known authority. Using <a id="_idIndexMarker550"/>an ACL with a custom language may only cause more confusion. Creating an ACL usually requires additional translations and thereby may increase the overall complexity of the customer’s bounded context and may be considered premature optimization.</p>
			<h3>Open host service</h3>
			<p>Unlike the <a id="_idIndexMarker551"/>conformist <a id="_idIndexMarker552"/>and the ACL, where customers do not have a formal means to interface with the supplier, with the <strong class="bold">Open Host Service</strong> (<strong class="bold">OHS</strong>), the supplier defines a clear interface to interact with its customers. This interface may be made available in the form of a well-known published language (for example, a REST interface or a client SDK):</p>
			<div>
				<div id="_idContainer190" class="IMG---Figure">
					<img src="image/B16716_Figure_9.10.jpg" alt="Figure 9.10 – An OHS using a Published Language (PL)&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – An OHS using a Published Language (PL)</p>
			<h4>Example</h4>
			<p>The LC application <a id="_idIndexMarker553"/>processing bounded context can expose an HTTP interface for each of its commands, as shown here:</p>
			<div>
				<div id="_idContainer191" class="IMG---Figure">
					<img src="image/9-1.jpg" alt=""/>
				</div>
			</div>
			<p>As an addition to the HTTP interface shown here, we can even provide a client SDK in some of the more popular languages used by our customers. This helps hide more implementation details such as the MIME type and version from customers.</p>
			<h4>When to use</h4>
			<p>When the supplier wants to hide its internal models (ubiquitous language), making an OHS enables <a id="_idIndexMarker554"/>the supplier to evolve while providing a stable interface to its customers. In a sense, the OHS pattern is a reversal of the ACL pattern – instead of the customer, the supplier implements the translation of its internal model. Also, the supplier can consider providing <a id="_idIndexMarker555"/>an OHS when it is interested in providing a richer user experience for its customers.</p>
			<h4>Potential pitfalls</h4>
			<p>While suppliers may have good intentions by providing an OHS for its customers, it may result in <a id="_idIndexMarker556"/>increased implementation complexity (for example, there may be a need to support multiple versions of an API, or client SDKs in multiple languages). If the OHS does not take into account the common usage patterns of its customers, it may result in poor customer usability and also in degraded performance for the supplier.</p>
			<p>It is important to note that the conformist and the ACL are patterns that customers implement, whereas the OHS is a supplier-side pattern. For example, the following scenario where the supplier provides an <em class="italic">OHS</em> to one customer who is a <em class="italic">conformist</em> and another who has an <em class="italic">ACL</em> can be true, as depicted here:</p>
			<div>
				<div id="_idContainer192" class="IMG---Figure">
					<img src="image/B16716_Figure_9.11.jpg" alt="Figure 9.11 – Asymmetric relationships with multiple customers&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Asymmetric relationships with multiple customers</p>
			<p>Now that we have seen the various ways in which bounded contexts can integrate with each other, here is one possible implementation for our LC application, depicted in the form of a context map:</p>
			<div>
				<div id="_idContainer193" class="IMG---Figure">
					<img src="image/B16716_Figure_9.12.jpg" alt="Figure 9.12 – A simplified context map for the LC application&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – A simplified context map for the LC application</p>
			<p>So far, we have examined the various ways in which inter-team dynamics influence integration <a id="_idIndexMarker557"/>mechanisms. While having clarity at the conceptual level helps, let’s see how these relationships manifest themselves at the implementation level.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor143"/>Implementation patterns</h1>
			<p>We have looked at integration between bounded contexts at a design level, but these concepts need <a id="_idIndexMarker558"/>to be translated into code. There are three broad categories that can be employed when integrating two bounded contexts:</p>
			<ul>
				<li>Data-based</li>
				<li>Code-based</li>
				<li>API-based</li>
			</ul>
			<p>Let’s look at each method in more detail now.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor144"/>Data-based</h2>
			<p>In this style of integration, the bounded contexts in question share data with each other. If the relationship is symmetric, the teams owning these bounded contexts may choose to share entire databases with free access to read, write, and change underlying structures. Conversely, in an asymmetric relationship, the supplier may constrain the scope of access, based on the type of relationship.</p>
			<h3>Shared database</h3>
			<p>The simplest form of data integration is the use of a shared database. In this style of integration, all <a id="_idIndexMarker559"/>participating <a id="_idIndexMarker560"/>bounded contexts have unrestricted access to the schemas and the underlying data, as shown here:</p>
			<div>
				<div id="_idContainer194" class="IMG---Figure">
					<img src="image/B16716_Figure_9.13.jpg" alt="Figure 9.13 – Integration using a shared database&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – Integration using a shared database</p>
			<h4>When to use</h4>
			<p>The shared database presents a very low barrier to entry for teams looking to quickly enable new or <a id="_idIndexMarker561"/>enhance existing functionality by providing ready access to data for read and/or write use cases. More importantly, it also allows the use of local database transactions, which usually provides strong consistency, lower complexity, and better performance (especially when working with relational databases).</p>
			<h4>Potential pitfalls</h4>
			<p>However, this symmetric integration style where multiple teams have shared ownership is usually frowned <a id="_idIndexMarker562"/>upon because it often leads to a situation where there is no clear ownership. Furthermore, the shared databases can become a source of tight coupling, accelerating the path toward the dreaded <em class="italic">big ball of mud</em>. Additionally, users of the shared database can suffer from the <em class="italic">noisy neighbor</em> effect where <a id="_idIndexMarker563"/>one co-tenant monopolizing resources adversely affects all other tenants. For these reasons, teams will be well advised to choose this style of integration sparingly.</p>
			<h3>Replicated data</h3>
			<p>In the case of asymmetric relationships, suppliers may be unwilling to provide direct access to their data. However, they may choose to integrate with customers using a mechanism based <a id="_idIndexMarker564"/>on data sharing. An alternate <a id="_idIndexMarker565"/>form of integration is to provide a copy of the data required by consumers. There are many variations on how this can be implemented; we depict the more common ways here:</p>
			<div>
				<div id="_idContainer195" class="IMG---Figure">
					<img src="image/B16716_Figure_9.14.jpg" alt="Figure 9.14 – Integration using data replication&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – Integration using data replication</p>
			<ul>
				<li><strong class="bold">Database views</strong>: In this form, the consumer gets or is provided access to a subset of data using query-based or materialized views. In either case, the customer usually has read-only access to the data, and both supplier and customer continue to share the same physical resources (usually the database engine).</li>
				<li><strong class="bold">Full read replica</strong>: In this form, the customer gets access to a read replica of the supplier’s entire database, usually on a physically disparate infrastructure.</li>
				<li><strong class="bold">Partial read replica</strong>: In this form, the customer gets access to a read replica of a subset of the supplier’s database, again on a physically disparate infrastructure.</li>
			</ul>
			<h4>When to use</h4>
			<p>This style of integration may be required when there is an asymmetric relationship between the <a id="_idIndexMarker566"/>supplier and the customer. Like the shared database, this integration style usually requires less upfront effort to integrate. This is also apt when suppliers intend to provide read-only access to a subset of their data. It may also suffice to use data replication when customers are only required to read a subset of the supplier’s data.</p>
			<h4>Potential pitfalls</h4>
			<p>If we choose to use database views, we may continue to suffer from the noisy neighbor effect. On the <a id="_idIndexMarker567"/>other hand, if we choose to create physically disparate replicas, we will need to incur the cost of additional operational complexity. More importantly, the consumers remain tightly coupled to the supplier’s domain models and ubiquitous language.</p>
			<p>Next, let’s look at some ways to make the most of data-based integrations.</p>
			<h4>Increasing effectiveness</h4>
			<p>When sharing data, the schema (the structure of the database) acts as a means to enforce <a id="_idIndexMarker568"/>contracts, especially when using databases that require specifying a formal structure (for example, relational databases). When multiple parties are involved, managing the schema can become a challenge.</p>
			<p>To mitigate undesirable changes, teams sharing data may want to consider the use of a schema <a id="_idIndexMarker569"/>migration tool. Relational databases work well with tools such as Liquibase (<a href="https://www.liquibase.org/">https://www.liquibase.org/</a>) or Flyway (<a href="https://flywaydb.org/">https://flywaydb.org/</a>). When working with <a id="_idIndexMarker570"/>databases that do not formally enforce a schema, it may be best to avoid employing this style of integration, especially when working in symmetric relationships where ownership is unclear.</p>
			<p>In any case, if using one of the shared data styles of integration is unavoidable, teams may want to strongly consider employing one or more of the aforementioned techniques in refactoring databases to make it more manageable.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor145"/>Code-based</h2>
			<p>In this style of integration, teams coordinate by sharing code artifacts, either directly in the form of source code and/or binaries. At a high level, there are two forms:</p>
			<ul>
				<li>Sharing source code</li>
				<li>Sharing binaries</li>
			</ul>
			<p>We will describe each of these here.</p>
			<h3>Sharing source code</h3>
			<p>A fairly <a id="_idIndexMarker571"/>common practice within organizations is to share source code with the objective of promoting reuse and standardization. This may include utilities (such as logging and authentication), build/deployment scripts, and data transfer objects – in other words, any piece of source code where the cost of duplication is seen to be higher than reuse.</p>
			<h4>When to use</h4>
			<p>Depending on the relationship type (symmetric/asymmetric), teams sharing code may have varying levels <a id="_idIndexMarker572"/>of influence on how the shared artifacts evolve. This works well in a symmetric relationship, where both teams are empowered to make changes compatible with each other. Similarly, in an asymmetric relationship, the supplier may accept changes from customers, while retaining ownership and control of the shared artifacts. This also tends to work well in the case of non-core, infrequently changing code artifacts. Sharing source code also enables higher levels of transparency and visibility for the internals of the shared artifacts (a case in point is open source software).</p>
			<h4>Potential pitfalls</h4>
			<p>Sharing code artifacts means that individual teams take on the responsibility to make sure that the <a id="_idIndexMarker573"/>process of converting source code into binary executables is uniform and compatible with the requirements of all parties. This may include code conventions, static quality checks, tests (the presence or lack thereof), compilation/build flags, and versioning. When a relatively large number of teams is involved, maintaining this form of compatibility may become burdensome.</p>
			<h3>Sharing binary artifacts</h3>
			<p>Another relatively common practice is to share artifacts at the binary level. In this scenario, the <a id="_idIndexMarker574"/>consumers may <a id="_idIndexMarker575"/>or may not have direct access to source code artifacts. Examples include third-party libraries, client SDKs, and API documentation. This form of integration is fairly common when the relationship between the coordinating parties is asymmetric. The supplier of the library has clear ownership of maintaining the life cycle of the shared artifacts.</p>
			<h4>When to use</h4>
			<p>Sharing just binary artifacts may be necessary when the supplier is unable/unwilling to share source <a id="_idIndexMarker576"/>artifacts, possibly because they may be proprietary and/or part of the supplier’s intellectual property. Because the supplier takes ownership of the <em class="italic">build</em> process, it behooves the supplier to produce artifacts that are compatible with most potential consumers. Hence, this works well when the supplier is willing to do that. On the other hand, it means that the customer places high levels of trust (<a href="https://www.thoughtworks.com/en-us/insights/podcasts/technology-podcasts/securing-software-supply-chain">https://www.thoughtworks.com/en-us/insights/podcasts/technology-podcasts/securing-software-supply-chain</a>) in the supplier’s software supply chain (<a href="https://blog.sonatype.com/software-supply-chain-a-definition-and-introductory-guide">https://blog.sonatype.com/software-supply-chain-a-definition-and-introductory-guide</a>) when producing these artifacts.</p>
			<h4>Potential pitfalls</h4>
			<p>Integration through the use of binary artifact sharing reduces the visibility of the build process of the <a id="_idIndexMarker577"/>shared artifacts for consumers. If consumers rely on slow-moving suppliers, this can become untenable. For example, if a critical security bug is discovered in the shared binary, the consumer is solely reliant on the supplier to remediate it. This can be a huge risk if such dependencies are in critical, business-differentiating <a id="_idIndexMarker578"/>aspects of the solution (especially in the core subdomain). This risk can be exacerbated without the use of appropriate ACLs and/or <strong class="bold">Service-Level Agreements</strong> (<strong class="bold">SLAs</strong>).</p>
			<h3>Increasing effectiveness</h3>
			<p>When sharing code artifacts, it becomes a lot more important to be explicit in how changes are <a id="_idIndexMarker579"/>made while continuing to maintain high levels of quality – especially when multiple teams are involved. Let’s examine some of these techniques in more detail:</p>
			<ul>
				<li><strong class="bold">Static analysis</strong>: This can be as simple as adhering to a set of coding standards using a tool such as Checkstyle. More importantly, these tools can be used to conform to a set of naming conventions to allow the firmer use of the ubiquitous language throughout the code base. In addition, tools such as SpotBugs and PMD/CPD can be used to statically analyze code for the presence of bugs and duplicate code.</li>
				<li><strong class="bold">Code architecture tests</strong>: While static inspection tools are effective at operating at the level of a single compilation unit, runtime inspection can take this one level further to identify package cycles, dependency checks, inheritance trees, and so on to <a id="_idIndexMarker580"/>apply lightweight architecture governance. The use of tools such as JDepend and ArchUnit can help here.</li>
				<li><strong class="bold">Unit tests</strong>: When working with shared code bases, team members are looking to make changes safely and reliably. The presence of a comprehensive suite of fast-running unit tests can go a long way toward increasing confidence. We strongly recommend employing test-driven design to further maximize creating a code base that is well designed and enables easier refactoring.</li>
				<li><strong class="bold">Code reviews</strong>: While automation can go a long way, augmenting the process where a human reviews changes can be highly effective for multiple reasons. This can take the form of offline reviews (using pull requests) or active peer reviews (using paired programming). All of these techniques serve to enhance collective understanding, thereby reducing risk when changes are made.</li>
				<li><strong class="bold">Documentation</strong>: Needless to say, well-structured documentation can be invaluable when making contributions and also when consuming binary code artifacts. Teams will be well advised to proliferate the use of the ubiquitous language by striving to write self-documenting code throughout to maximize the derived benefits.</li>
				<li><strong class="bold">Dependency management</strong>: When sharing binary code artifacts, managing dependencies can become fairly complicated due to having too many dependencies, long dependency chains, conflicting/cyclic dependencies, and so on. Teams should strive to reduce afferent (incoming) coupling as much as possible to mitigate the problems described previously.</li>
				<li><strong class="bold">Versioning</strong>: In addition to minimizing the amount of afferent coupling, using an explicit versioning <a id="_idIndexMarker581"/>strategy can go a long way toward making dependency management easier. We strongly recommend considering the use of a technique such as semantic versioning for shared code artifacts.</li>
			</ul>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor146"/>IPC-based</h2>
			<p>In this style of integration, the <a id="_idIndexMarker582"/>bounded contexts exchange messages using some form of <strong class="bold">Inter-Process Communication</strong> (<strong class="bold">IPC</strong>) to interact with each other. This can take the form of synchronous or asynchronous communication.</p>
			<h3>Synchronous messaging</h3>
			<p>Synchronous messaging is a style of communication where the sender of the request waits for a <a id="_idIndexMarker583"/>response from the receiver, which implies that the sender and the <a id="_idIndexMarker584"/>receiver need to be active for this style to work. Usually, this form of communication is point to point. HTTP is one of the commonly used protocols for this style of communication. A visual representation of this form of communication is shown here:</p>
			<div>
				<div id="_idContainer196" class="IMG---Figure">
					<img src="image/B16716_Figure_9.15.jpg" alt="Figure 9.15 – Synchronous messaging&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – Synchronous messaging</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Please take a look at the HTTP APIs for the commands used during LC application processing, which are included with the code examples for this chapter.</p>
			<h4>When to use</h4>
			<p>This form of integration is used when the customer is interested in the supplier’s response to <a id="_idIndexMarker585"/>the request. The response is then used to determine whether the request was successful or not. Given that the customer needs to wait for the response, it is advisable to use this style of messaging for low-latency operations. This form of integration is popular when exposing public APIs over the internet (for example, GitHub’s REST API, which you can learn more about at <a href="https://docs.github.com/en/rest">https://docs.github.com/en/rest</a>).</p>
			<h4>Potential pitfalls</h4>
			<p>When using synchronous messaging, the customer’s ability to scale is heavily dependent on the supplier <a id="_idIndexMarker586"/>to satisfy the customer’s requirements. On the flip side, customers making requests at too high a rate may compromise the supplier’s ability to serve customers in a predictable manner. If there is a chain of synchronous messaging, the probability of cascading failure becomes much higher.</p>
			<h3>Asynchronous messaging</h3>
			<p>Asynchronous <a id="_idIndexMarker587"/>messaging is a style of communication where the sender does <a id="_idIndexMarker588"/>not wait for an explicit response from the receiver.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We are using the terms <em class="italic">sender</em> and <em class="italic">receiver</em> instead of <em class="italic">customer</em> and <em class="italic">supplier</em> because they both can play the role of sender or receiver.</p>
			<p>This is typically achieved by introducing an intermediary in the form of a message channel. The presence of the intermediary enables both one-to-one and one-to-many modes of communication. Typically, the intermediary can take the form of a shared filesystem, database, or queueing system:</p>
			<div>
				<div id="_idContainer197" class="IMG---Figure">
					<img src="image/B16716_Figure_9.16.jpg" alt="Figure 9.16 – Asynchronous messaging&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – Asynchronous messaging</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Please take a look at the event APIs for the commands used during LC application processing, which are included with the code examples for this chapter.</p>
			<h4>When to use</h4>
			<p>This form of integration is used when the sender does not care about receiving an <strong class="bold">immediate</strong> response from the receiver(s), resulting in the respective systems becoming a lot more <a id="_idIndexMarker589"/>decoupled from each other. This further enables these systems to scale independently. This also makes it possible to have the same message being processed by multiple receivers. For example, in our LC application processing system, <strong class="source-inline">LCApplicationSubmittedEvent</strong> is received by both the <em class="italic">compliance</em> and <em class="italic">customer onboarding</em> systems.</p>
			<h4>Potential pitfalls</h4>
			<p>The introduction of <a id="_idIndexMarker590"/>the intermediary component adds complexity to the overall solution. The non-functional characteristics of the intermediary can have a profound effect on the resilience characteristics of the system as a whole. It can also be tempting to add processing logic to the intermediary, thereby coupling the overall system very tightly to this component. To ensure reliable communication <a id="_idIndexMarker591"/>between the sender and the receiver, the intermediary may have to support a variety of enhanced capabilities (such as ordering, producer flow control, durability, and transactions).</p>
			<h3>Increasing effectiveness</h3>
			<p>When implementing integration using some form of IPC, a lot of the techniques discussed <a id="_idIndexMarker592"/>in the code-based implementation patterns section continue to apply. As discussed earlier, API documentation plays a significant role in reducing friction for customers. In addition, here are a few more techniques that apply specifically when using IPC-based integration:</p>
			<ul>
				<li><strong class="bold">Typed protocols</strong>: When working with this form of integration, it is important to minimize the amount of time taken to gather feedback on structural validations. This is especially critical given that the supplier and the customer may be in a constant state of independent evolution. The use of typed protocols such as Protocol Buffers, Avro, Netflix’s Falcor, and GraphQL can make it easier for customers to interact with suppliers while maintaining a lightweight mechanism to validate whether requests are correct.</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">The key word here is <strong class="bold">lightweight</strong>. It is pertinent to note that we are not advising against the use of JSON-based HTTP APIs (typically advertised as being RESTful), which do not enforce the use of an explicit schema. Neither are we promoting the use of (arguably) legacy protocols such as SOAP, WSDL, and CORBA. Each of these, while being well-meaning, suffered from being fairly heavyweight.</p>
			<ul>
				<li><strong class="bold">Self-discovery</strong>: As outlined previously, when working with an IPC-based integration mechanism, we should look to reduce the barrier to entry. When working with RESTful APIs, the use of HATEOAS (<a href="https://restfulapi.net/hateoas">https://restfulapi.net/hateoas</a>), although difficult for suppliers to implement, can make it <a id="_idIndexMarker593"/>easier for customers to understand and consume APIs. In addition, making use of a service registry and/or a schema registry can further reduce consumption friction.</li>
				<li><strong class="bold">Contract tests</strong>: In the spirit of failing fast and shifting left, the practice of contract testing and consumer-driven contracts can further increase the quality and speed of <a id="_idIndexMarker594"/>integration. Tools such as Pact (https://pact.io/) and Spring <a id="_idIndexMarker595"/>Cloud Contract (<a href="https://spring.io/projects/spring-cloud-contract">https://spring.io/projects/spring-cloud-contract</a>) make the adoption of these practices relatively simple.</li>
			</ul>
			<p>So far, we’ve discussed implementation patterns, broadly categorized into data-based, code-based, and <a id="_idIndexMarker596"/>IPC-based integrations. Hopefully, this gives you a good start in consciously choosing the appropriate approach by considering the benefits and caveats that they bring along with them.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor147"/>Summary</h1>
			<p>In this chapter, we looked at the different types of bounded context relationships. We also examined common integration patterns that can be used when implementing these bounded context relationships.</p>
			<p>You have learned when specific techniques can be used, about potential pitfalls, and ideas on how to increase effectiveness when employing these methods.</p>
			<p>In the next chapter, we will explore the means to distribute these bounded contexts into independently deployable components (in other words, employ a microservices-based architecture).</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor148"/>Further reading</h1>
			<div>
				<div id="_idContainer198" class="IMG---Figure">
					<img src="image/B16716_Table_9.1.jpg" alt=""/>
				</div>
			</div>
		</div>
	</body></html>