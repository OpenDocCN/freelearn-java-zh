<html><head></head><body>
<div id="_idContainer030">
<h1 class="chapter-number" id="_idParaDest-34"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.2.1">Key Architectural Patterns in Microservices – DDD, CQRS, and Event Sourcing</span></h1>
<p><span class="koboSpan" id="kobo.3.1">This chapter is all about appreciation of the backbone of microservices – the central patterns that make our software designs strong, scalable, </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">and effective.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">So first off, we’ll want to delve into the world of domain-driven design. </span><span class="koboSpan" id="kobo.5.2">It’s an approach to software that fits business concerns to any given software project. </span><span class="koboSpan" id="kobo.5.3">It’s akin to ensuring our software speaks the same lingo as the business challenges it’s working </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">to answer.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Coming up is Command Query Responsibility Segregation. </span><span class="koboSpan" id="kobo.7.2">It’s a nice way to divide how we manipulate data in two – one for updating and another for retrieving. </span><span class="koboSpan" id="kobo.7.3">It divides our software duties in a cleaner, more </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">efficient way.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">Next, there is Event Sourcing. </span><span class="koboSpan" id="kobo.9.2">We record each change as a series of events here. </span><span class="koboSpan" id="kobo.9.3">It is like an itemized account of everything that has happened – one which can be very powerful for looking back at the history of our data </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">and choices.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">As we progress through this chapter, we will understand why architectural patterns are important and how to apply them in order to build our microservices correctly. </span><span class="koboSpan" id="kobo.11.2">We will learn not only what architectural patterns are but their practical application as well. </span><span class="koboSpan" id="kobo.11.3">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Introduction to architectural patterns </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">in microservices</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.15.1">Domain-Driven </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.16.1">Design</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.17.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.18.1">DDD</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.20.1">Command Query Responsibility </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.21.1">Segregation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.22.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.23.1">CQRS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">)</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.25.1">Event Sourcing</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">Brief overview of other </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">architectural patterns</span></span></li>
</ul>
<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.28.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.29.1">To better understand this chapter, it would be beneficial if you had knowledge in the </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">following areas:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.31.1">Solid understanding of microservice architecture principles</span></strong><span class="koboSpan" id="kobo.32.1">: Grasp the foundational concepts that </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">underpin microservices</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.34.1">Familiarity with software design patterns</span></strong><span class="koboSpan" id="kobo.35.1">: Know the common patterns that solve software </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">design problems</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.37.1">Basic programming concepts</span></strong><span class="koboSpan" id="kobo.38.1">: Have a good command of the fundamental principles </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">of programming</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.40.1">Understanding of distributed systems</span></strong><span class="koboSpan" id="kobo.41.1">: Be aware of how distributed systems work and </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">their challenges</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.43.1">Knowledge of microservices’ purpose and implementation</span></strong><span class="koboSpan" id="kobo.44.1">: Understand why microservices are used, how they are implemented, and </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">their benefits</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.46.1">Grasp of microservice communication and operation</span></strong><span class="koboSpan" id="kobo.47.1">: Know how microservices communicate with each other and operate within a </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">larger system</span></span></li>
</ul>
<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.49.1">Introduction to architectural patterns in microservices</span></h1>
<p><span class="koboSpan" id="kobo.50.1">Alright, so in this section, we’re going to</span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.51.1"> look at how to implement design patterns</span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.52.1"> into microservices. </span><span class="koboSpan" id="kobo.52.2">To really understand this topic, let’s first go over some subheadings to help build up the </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">big picture.</span></span></p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.54.1">Why do we need an architectural design in the first place?</span></h2>
<p><span class="koboSpan" id="kobo.55.1">An architectural pattern is, simply put, a proven balanced solution from experience to tackle some recurring problem in software architecture. </span><span class="koboSpan" id="kobo.55.2">These patterns solve issues from hardware limitation to </span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.56.1">high availability and minimizing </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">business risk.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">One significant advantage is that they offer ways of solving software problems since most of the basic architectural design problems have been already tested. </span><span class="koboSpan" id="kobo.58.2">They streamline the process through which tightly connected and communicating modules that work together with minimal coupling are created. </span><span class="koboSpan" id="kobo.58.3">This also helps to make the overall system easier to understand and maintain by allowing variations in the structure depending on what is </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">actually needed.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">Another great advantage is that design patterns help increase the effectiveness of communication between developers and designers. </span><span class="koboSpan" id="kobo.60.2">When working on system design, if developers or designers refer to a pattern by its name, then everyone knows the general high-level design they’re talking about </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">right away.</span></span></p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.62.1">What are design patterns?</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.63.1">Design patterns</span></strong><span class="koboSpan" id="kobo.64.1"> are basically templates </span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.65.1">that developers use to solve common problems in software design. </span><span class="koboSpan" id="kobo.65.2">Each pattern shows you a typical solution that you can then customize for your own project’s needs. </span><span class="koboSpan" id="kobo.65.3">For example, if you often have to structure a program a certain way, a design pattern can provide a proven approach for you to modify </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">as needed.</span></span></p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.67.1">What are microservices?</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.68.1">Microservices</span></strong><span class="koboSpan" id="kobo.69.1"> are an architecture style</span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.70.1"> where you basically break up an application into a bunch of small, independent services. </span><span class="koboSpan" id="kobo.70.2">Each service focuses on doing one specific thing really well and communicates with the other services through simple protocols. </span><span class="koboSpan" id="kobo.70.3">The big benefit is that teams can work on their own services separately without affecting the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">the app.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">This approach allows teams to focus solely on their specific tasks without worrying about how changes might impact other parts of the application. </span><span class="koboSpan" id="kobo.72.2">They can iterate quickly on their code and features without the need for extensive coordination and testing across the entire codebase. </span><span class="koboSpan" id="kobo.72.3">When done right, microservices make the development process more efficient since teams have autonomy over their </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">own services.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">The separation also makes the application more scalable and resilient. </span><span class="koboSpan" id="kobo.74.2">Since each service is independent, teams can update their code and deploy new versions without disrupting the other services. </span><span class="koboSpan" id="kobo.74.3">If one </span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.75.1">service experiences an outage or needs to be taken offline for maintenance, it doesn’t bring down the entire application. </span><span class="koboSpan" id="kobo.75.2">Companies are able to keep their software running smoothly even if some parts are </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">temporarily unavailable.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">Additionally, the modular design means the application can grow really large without everything getting too tangled and complex. </span><span class="koboSpan" id="kobo.77.2">New features don’t require changes throughout the codebase. </span><span class="koboSpan" id="kobo.77.3">Teams can simply build out additional services to handle new capabilities. </span><span class="koboSpan" id="kobo.77.4">With microservices, companies can build software really fast since teams don’t slow each other down by waiting on code reviews </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">and deployments.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">The tradeoff is that keeping the services separate takes more work upfront. </span><span class="koboSpan" id="kobo.79.2">There’s additional complexity in managing the communication between independent parts. </span><span class="koboSpan" id="kobo.79.3">However, for large applications, microservices provide benefits that outweigh the initial cost by enabling rapid, reliable development </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">at scale.</span></span></p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.81.1">What are the principles behind microservices?</span></h2>
<p><span class="koboSpan" id="kobo.82.1">The six main principles behind microservices are</span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.83.1"> autonomy, loose coupling, reuse, fault tolerance, composability, and discoverability. </span><span class="koboSpan" id="kobo.83.2">Let me explain a bit more about </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">each one:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.85.1">Autonomy</span></strong><span class="koboSpan" id="kobo.86.1"> means that each </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.87.1">microservice is independent and in control of its own runtime and database. </span><span class="koboSpan" id="kobo.87.2">This makes it faster and more reliable since it’s not dependent on other services. </span><span class="koboSpan" id="kobo.87.3">As long as it stays stateless, it can also scale </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">up easily.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.89.1">Loose coupling</span></strong><span class="koboSpan" id="kobo.90.1"> means the services don’t rely too much on each other. </span><span class="koboSpan" id="kobo.90.2">By using standardized APIs, one service can </span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.91.1">change without affecting the others. </span><span class="koboSpan" id="kobo.91.2">This allows for more flexibility and evolution over time. </span><span class="koboSpan" id="kobo.91.3">It also makes development and </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">fixes faster.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.93.1">Reuse</span></strong><span class="koboSpan" id="kobo.94.1"> is still important but at a more specific domain level within the business. </span><span class="koboSpan" id="kobo.94.2">Teams can decide how to adapt</span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.95.1"> services for new uses case by case. </span><span class="koboSpan" id="kobo.95.2">This guided reuse approach is better than a rigid </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">predetermined model.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.97.1">Fault tolerance</span></strong><span class="koboSpan" id="kobo.98.1"> means each </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.99.1">service can keep working even if another fails. </span><span class="koboSpan" id="kobo.99.2">Things</span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.100.1"> like circuit breakers stop individual failures from spreading. </span><span class="koboSpan" id="kobo.100.2">This keeps the whole </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">system reliable.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.102.1">Composability</span></strong><span class="koboSpan" id="kobo.103.1"> means services can</span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.104.1"> deliver value in different combinations. </span><span class="koboSpan" id="kobo.104.2">Multiple services working together become the new way of </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">building applications.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.106.1">Discoverability</span></strong><span class="koboSpan" id="kobo.107.1"> means each </span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.108.1">service clearly communicates what business problem it solves and how other teams can use its technical interface. </span><span class="koboSpan" id="kobo.108.2">This makes it easy for developers to understand the microservices’ functionality and how to consume the events </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">it publishes.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.110.1">In summary, these six principles of autonomy, loose coupling, reuse, fault tolerance, composability, and discoverability form the foundation of </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">microservices architecture.</span></span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.112.1">Microservices design patterns</span></h2>
<p><span class="koboSpan" id="kobo.113.1">Up to this point, we have discussed why </span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.114.1">we need an architectural design, what design patterns</span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.115.1"> and microservices are, and the principles behind microservices. </span><span class="koboSpan" id="kobo.115.2">In this section, our focus is on the microservice design patterns. </span><span class="koboSpan" id="kobo.115.3">That is, as previously explained, design patterns help in such a way that they fix the particular challenge of microservice architecture and also help to reduce the risk of failure in microservices – but only if we understand </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">them clearly.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">The next question is what exactly those design patterns are. </span><span class="koboSpan" id="kobo.117.2">Well, I’d like to share a diagram that illustrates the big picture of design patterns in microservices architecture. </span><span class="koboSpan" id="kobo.117.3">It does not cover all design patterns, but the most </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">common designs.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<span class="koboSpan" id="kobo.119.1"><img alt="Figure 2.1: Common microservice design patterns" src="image/B18400_02_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.120.1">Figure 2.1: Common microservice design patterns</span></p>
<p><span class="koboSpan" id="kobo.121.1">In previous sections, we talked about microservice architecture and the importance of having well-defined patterns when </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.122.1">you are designing microservices. </span><span class="koboSpan" id="kobo.122.2">Microservices can get complicated very fast based on the fact that there are so many moving parts; design patterns help to take care of some specific problems while reducing the risks of failure. </span><span class="koboSpan" id="kobo.122.3">In this section, we would like to</span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.123.1"> take a slightly deeper dive into some of the most common microservice design patterns that it’s good to have an </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">awareness of.</span></span></p>
<p><span class="koboSpan" id="kobo.125.1">We are going to talk about a couple of the most common microservice design patterns and give a bit of explanation about each </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">of them.</span></span></p>
<h3><span class="koboSpan" id="kobo.127.1">Aggregator design pattern</span></h3>
<p><span class="koboSpan" id="kobo.128.1">The Aggregator pattern is useful </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.129.1">when you need to display data from multiple microservices on a single page or interface. </span><span class="koboSpan" id="kobo.129.2">For example, if you have a</span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.130.1"> dashboard that pulls in various metrics and statuses from different services, the Aggregator pattern allows you to collect that data in one </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">place efficiently.</span></span></p>
<h3><span class="koboSpan" id="kobo.132.1">API Gateway design pattern</span></h3>
<p><span class="koboSpan" id="kobo.133.1">The API gateway acts as a single entry point or “front door” for your microservices. </span><span class="koboSpan" id="kobo.133.2">All requests must go through the API gateway, which handles authentication, authorization, monitoring, and routing requests to</span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.134.1"> the appropriate services. </span><span class="koboSpan" id="kobo.134.2">This </span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.135.1">provides an extra layer of security compared to exposing </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">services directly.</span></span></p>
<h3><span class="koboSpan" id="kobo.137.1">Saga design pattern</span></h3>
<p><span class="koboSpan" id="kobo.138.1">The Saga pattern is useful when you have a </span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.139.1">business process that involves multiple services, and the steps must be executed transactionally. </span><span class="koboSpan" id="kobo.139.2">For example, when posting a photo to a social profile, the Saga </span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.140.1">pattern coordinates saving the photo, updating the profile, and notifying followers all in a reliable way, even if some </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">services fail.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">To sum up, there are so many different microservice design patterns out there these days. </span><span class="koboSpan" id="kobo.142.2">It can be tough to decide which ones might work best for your particular project. </span><span class="koboSpan" id="kobo.142.3">But I’ve found that oftentimes, you can actually use a couple of different patterns at the same time, depending on what you’re trying </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">to accomplish.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">For example, let’s say you have a project with multiple independent services, all of which need to access the same database. </span><span class="koboSpan" id="kobo.144.2">In that case, a Gateway pattern might make sense for the database access to avoid having every service connect directly. </span><span class="koboSpan" id="kobo.144.3">That way you consolidate the database connections through a </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">single service.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">At the same time though, some of your services might work really well with a Client/Server pattern between them. </span><span class="koboSpan" id="kobo.146.2">Maybe one service acts as a server providing data to others functioning as clients. </span><span class="koboSpan" id="kobo.146.3">So, in that part of the architecture, Client/Server could be a </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">good fit.</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">The main thing is to think about the goals and needs of each individual service or group of services. </span><span class="koboSpan" id="kobo.148.2">What patterns will help you achieve things such as loose coupling, scalability, fault tolerance, and the like? </span><span class="koboSpan" id="kobo.148.3">As long as you can clearly explain why you’ve selected the patterns that you have, and how they help address specific goals, then using more than one pattern in a project is totally reasonable. </span><span class="koboSpan" id="kobo.148.4">The patterns are there to serve your design – not the other </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">way around.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">After discussing various microservice design patterns and their applications for specific architectural challenges, we will move on to the next section. </span><span class="koboSpan" id="kobo.150.2">Here, we will explore DDD, which will help us understand how each microservice can be responsible for </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">domain-specific actions.</span></span></p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.152.1">Exploring DDD</span></h1>
<p><span class="koboSpan" id="kobo.153.1">We’re going to be breaking down </span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.154.1">DDD for you in a way that’s easy to understand. </span><span class="koboSpan" id="kobo.154.2">Now if you’ve never heard of DDD before, don’t stress – it’s mainly used for big projects that take around six months or longer to complete. </span><span class="koboSpan" id="kobo.154.3">But even if you’re just doing smaller stuff, learning the basics can still </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">be helpful.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">DDD is all about structuring your code around the specific problem or “domain” that your software is trying to solve. </span><span class="koboSpan" id="kobo.156.2">In simpler terms, it’s organizing your code to match what your app is </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">actually about.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">Firstly, we will discuss some basic terminologies such as domain and DDD, and then later, we will explore how to implement DDD. </span><span class="koboSpan" id="kobo.158.2">Finally, we will go over a </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">real-world example.</span></span></p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.160.1">What is a domain exactly?</span></h2>
<p><span class="koboSpan" id="kobo.161.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.162.1">domain</span></strong><span class="koboSpan" id="kobo.163.1"> refers to the main topic or area that your app focuses on. </span><span class="koboSpan" id="kobo.163.2">For example, if you’re building an ordering app, the domain would likely be online shopping or order processing. </span><span class="koboSpan" id="kobo.163.3">It’s important to really understand the domain too, because </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.164.1">one company could be working in multiple domains at the same time, such as shopping, delivery, transportation, repairs – you get </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">the idea.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">Sometimes a domain might seem too broad, such as “food,” for example. </span><span class="koboSpan" id="kobo.166.2">In these cases, you should specify the exact part of that industry you’re tackling. </span><span class="koboSpan" id="kobo.166.3">Now for really big domain models, you can break them into smaller </span><em class="italic"><span class="koboSpan" id="kobo.167.1">bounded contexts</span></em><span class="koboSpan" id="kobo.168.1"> to make things easier to manage. </span><span class="koboSpan" id="kobo.168.2">For example, within a food company, there may be separate contexts for the sales team and delivery team, each with its </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">own experts.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">These domain experts work closely with developers to nail the functionality. </span><span class="koboSpan" id="kobo.170.2">Dividing the domain into bounded contexts simplifies the work and keeps </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">everything organized.</span></span></p>
<p><span class="koboSpan" id="kobo.172.1">So, in summary, DDD is a way to develop software for complex problems by focusing on domains and contexts to make sure your code matches the specifics of what you’re trying </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">to solve.</span></span></p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.174.1">What is DDD?</span></h2>
<p><span class="koboSpan" id="kobo.175.1">We’re now going to talk about </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.176.1">DDD. </span><span class="koboSpan" id="kobo.176.2">DDD is all about deeply linking your code to the core concepts or context of your business domain. </span><span class="koboSpan" id="kobo.176.3">The goal is to help handle complex scenarios by facilitating effective collaboration between the domain experts and developers. </span><span class="koboSpan" id="kobo.176.4">This way there’s less room </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">for misunderstandings.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">DDD really shines in big projects with lots of moving parts, where you need experts weighing in and everyone working together. </span><span class="koboSpan" id="kobo.178.2">But it’s probably overkill for smaller solo projects that you can manage on your own. </span><span class="koboSpan" id="kobo.178.3">The key to successful collaboration is communication. </span><span class="koboSpan" id="kobo.178.4">With DDD, both the developers and experts (such as architecture and domain experts) share a </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.179.1">common language that they use when discussing things, building the domain model, and writing the code. </span><span class="koboSpan" id="kobo.179.2">This helps speed up the </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">feedback loop.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">But you have to be careful. </span><span class="koboSpan" id="kobo.181.2">If you don’t keep enriching and defining that shared language, separate languages could start forming within the teams. </span><span class="koboSpan" id="kobo.181.3">And then it’s goodbye to effective communication – this causes inaccuracies and confusion. </span><span class="koboSpan" id="kobo.181.4">For example, the term “client” could mean a user in one context but a system service in another. </span><span class="koboSpan" id="kobo.181.5">So, it’s super important to clearly define what </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">everything means.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">Also, each domain should have its own custom language to avoid conflicts. </span><span class="koboSpan" id="kobo.183.2">And we’ll want to establish boundaries between domains to prevent cross-contamination. </span><span class="koboSpan" id="kobo.183.3">One way to shield a domain is with an </span><strong class="bold"><span class="koboSpan" id="kobo.184.1">Anti-Corruption Layer</span></strong><span class="koboSpan" id="kobo.185.1">. </span><span class="koboSpan" id="kobo.185.2">This layer acts like a translator between different </span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.186.1">domain models, using patterns like adapters, facades, or translators to help the domains communicate without polluting each other. </span><span class="koboSpan" id="kobo.186.2">This helps explain what DDD is </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">all about.</span></span></p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.188.1">How to define DDD structure?</span></h2>
<p><span class="koboSpan" id="kobo.189.1">In this section, we will break down the DDD structure for an online shopping app example that we will discuss later in</span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.190.1"> this section. </span><span class="koboSpan" id="kobo.190.2">There are a few key layers we need to focus on to make our application </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">run smoothly:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.192.1">First up is the </span><strong class="bold"><span class="koboSpan" id="kobo.193.1">UI layer</span></strong><span class="koboSpan" id="kobo.194.1">. </span><span class="koboSpan" id="kobo.194.2">This is what the </span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.195.1">customers see when they’re browsing on their phones or computers. </span><span class="koboSpan" id="kobo.195.2">It displays the products and lets them add stuff to their carts and checkout. </span><span class="koboSpan" id="kobo.195.3">It takes the user input and sends it to the </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">next layer.</span></span></li>
<li><span class="koboSpan" id="kobo.197.1">The next layer is the </span><strong class="bold"><span class="koboSpan" id="kobo.198.1">application layer</span></strong><span class="koboSpan" id="kobo.199.1">. </span><span class="koboSpan" id="kobo.199.2">Now this layer </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.200.1">doesn’t have any actual business logic, it just guides the user through the UI process and talks to other systems. </span><span class="koboSpan" id="kobo.200.2">It organizes all the objects and makes sure the tasks get done</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.201.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">right order.</span></span></li>
<li><span class="koboSpan" id="kobo.203.1">Now we get to the </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">domain layer</span></strong><span class="koboSpan" id="kobo.205.1">, which is like the heart and soul of the whole operation. </span><span class="koboSpan" id="kobo.205.2">This layer has all the core concepts that </span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.206.1">make the business tick. </span><span class="koboSpan" id="kobo.206.2">It has things such as users, products, orders – basically anything related to the main functions of the app. </span><span class="koboSpan" id="kobo.206.3">Each </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.207.1">entity has its own unique ID so it can be tracked no matter what </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">else changes.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.209.1">The services here also have predefined behaviors that everyone understands. </span><span class="koboSpan" id="kobo.209.2">The domain layer stands on its own and doesn’t rely on the other layers, but they can all depend on the domain layer since it’s got all the important business rules </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">locked down.</span></span></p></li>
<li><span class="koboSpan" id="kobo.211.1">Finally, we’ve got the </span><strong class="bold"><span class="koboSpan" id="kobo.212.1">infrastructure layer</span></strong><span class="koboSpan" id="kobo.213.1">. </span><span class="koboSpan" id="kobo.213.2">This layer facilitates the communication between all the other layers. </span><span class="koboSpan" id="kobo.213.3">It </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.214.1">also provides things such as libraries to help the UI work smoothly. </span><span class="koboSpan" id="kobo.214.2">But it doesn’t actually have any business logic – it just supports the technical functions behind </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">the scenes.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.216.1">So, in summary – the UI layer talks to users, the application layer manages tasks, the domain layer handles the core business functions, and the infrastructure layer helps them all work together seamlessly. </span><span class="koboSpan" id="kobo.216.2">Make sure each layer stays focused on your </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">app architecture.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.218.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.219.1">.2</span></em><span class="koboSpan" id="kobo.220.1"> helps you understand the relationship between different </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">layers visually:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.222.1"><img alt="Figure 2.2: Relationship between the DDD layers" src="image/B18400_02_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.223.1">Figure 2.2: Relationship between the DDD layers</span></p>
<p><span class="koboSpan" id="kobo.224.1">We’re now going to go through an example by following the DDD structure to make it clear and picturesque in our mind – we’re going to break down microservices using a real-world example of an </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">online store.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">We all know shopping online is </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.227.1">huge these days, so let me walk through how an e-commerce site could be structured using a </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">domain-driven design:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.229.1">First up, you’ve got to have a </span><strong class="bold"><span class="koboSpan" id="kobo.230.1">User Service</span></strong><span class="koboSpan" id="kobo.231.1">. </span><span class="koboSpan" id="kobo.231.2">This handles all the</span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.232.1"> account details – logging in, profiles, addresses, payment information, and all </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">related details.</span></span></li>
<li><span class="koboSpan" id="kobo.234.1">Next is the </span><strong class="bold"><span class="koboSpan" id="kobo.235.1">Product Service</span></strong><span class="koboSpan" id="kobo.236.1">. </span><span class="koboSpan" id="kobo.236.2">This one is in </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.237.1">charge of the product catalog – keeping track of inventory levels, product details, descriptions – all the information about the items you </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">can buy.</span></span></li>
<li><span class="koboSpan" id="kobo.239.1">Then we have the </span><strong class="bold"><span class="koboSpan" id="kobo.240.1">Order Service</span></strong><span class="koboSpan" id="kobo.241.1">. </span><span class="koboSpan" id="kobo.241.2">As you</span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.242.1"> can probably guess, this one creates orders when people checkout. </span><span class="koboSpan" id="kobo.242.2">It also processes payments using different methods such as credit cards or PayPal. </span><span class="koboSpan" id="kobo.242.3">And of course, it ships out orders </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">to customers.</span></span></li>
<li><span class="koboSpan" id="kobo.244.1">After that is the </span><strong class="bold"><span class="koboSpan" id="kobo.245.1">Payment Service</span></strong><span class="koboSpan" id="kobo.246.1">. </span><span class="koboSpan" id="kobo.246.2">Now this one</span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.247.1"> specifically focuses on processing payments from different sources such as Visa, Mastercard, or digital wallets. </span><span class="koboSpan" id="kobo.247.2">It interacts with the </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">payment gateways.</span></span></li>
<li><span class="koboSpan" id="kobo.249.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.250.1">Review Service</span></strong><span class="koboSpan" id="kobo.251.1"> manages all the </span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.252.1">reviews, ratings, and feedback left by customers – people should be able to see what others think of a product before </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">buying, right?</span></span></li>
<li><span class="koboSpan" id="kobo.254.1">And finally, we have the </span><strong class="bold"><span class="koboSpan" id="kobo.255.1">Notification Service</span></strong><span class="koboSpan" id="kobo.256.1">. </span><span class="koboSpan" id="kobo.256.2">This </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.257.1">one sends out emails or push notifications to let customers know about their orders, sales, new products – you name it – keeping everyone in </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">the loop!</span></span></li>
</ul>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.259.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.260.1">.3</span></em><span class="koboSpan" id="kobo.261.1"> illustrates these microservices following the </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">DDD approach:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.263.1"><img alt="Figure 2.3: The services of the project in DDD structure" src="image/B18400_02_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.264.1">Figure 2.3: The services of the project in DDD structure</span></p>
<p><span class="koboSpan" id="kobo.265.1">So, in summary, these are the main microservices an online store might use following a </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">DDD approach.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">We have a good understanding of a DDD approach now. </span><span class="koboSpan" id="kobo.267.2">We segregate the microservices per business domain. </span><span class="koboSpan" id="kobo.267.3">Next, we will explore CQRS – as you can understand from its name, we will again be segregating microservices, but in a </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">different way.</span></span></p>
<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.269.1">Learning about CQRS</span></h1>
<p><span class="koboSpan" id="kobo.270.1">In this section, we’re going to </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.271.1">talk about CQRS, which is an awesome software architecture pattern! </span><span class="koboSpan" id="kobo.271.2">CQRS is based on separating the responsibilities of the commands and queries in a system. </span><span class="koboSpan" id="kobo.271.3">This means we slice our application </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">logic vertically.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">By dividing commands and queries, our system becomes greatly efficient. </span><span class="koboSpan" id="kobo.273.2">Commands focus on data changes without worrying about queries. </span><span class="koboSpan" id="kobo.273.3">Queries focus only on reading data without impacting commands. </span><span class="koboSpan" id="kobo.273.4">Each part of the system optimizes itself, for its single purpose. </span><span class="koboSpan" id="kobo.273.5">It’s like dividing and conquering to make </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">everything faster!</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">In this section, we will discuss the context of CQRS with its cons and pros. </span><span class="koboSpan" id="kobo.275.2">Later on, we will see a real-world scenario </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.276.1">and how CQRS help to solve </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">real problems.</span></span></p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.278.1">What is the context of CQRS?</span></h2>
<p><span class="koboSpan" id="kobo.279.1">You may be thinking, </span><em class="italic"><span class="koboSpan" id="kobo.280.1">“Why should I care about CQRS?”</span></em><span class="koboSpan" id="kobo.281.1"> The simple answer is efficiency and simplicity. </span><span class="koboSpan" id="kobo.281.2">We can </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.282.1">easily optimize each part separately when we split the app into command and </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">query parts.</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">Let’s talk about these two </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">main components:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.286.1">The command side is all about actions – creating, updating, and deleting data. </span><span class="koboSpan" id="kobo.286.2">As we can see, these are the ‘do-er’ operations of </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">our application.</span></span></li>
<li><span class="koboSpan" id="kobo.288.1">On the other side, the query side is the ‘viewer’ or ‘reader’. </span><span class="koboSpan" id="kobo.288.2">It fetches the data, but doesn’t make any changes to the state of </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">the data.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.290.1">So, with such a clear separation, you can see how easy it is to optimize and scale commands and queries according to </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">their needs.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">However, we must remember that CQRS isn’t a one-size-fits-all solution. </span><span class="koboSpan" id="kobo.292.2">If all other architecture designs of our system have unbalanced command and query operations, then we should choose this design. </span><span class="koboSpan" id="kobo.292.3">Otherwise, it will increase the complexity of </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">our application.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">To wrap it up, CQRS is all</span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.295.1"> about dividing your application into two parts – one for commands (doing) and one for queries (viewing). </span><span class="koboSpan" id="kobo.295.2">This separation can lead to more efficient, maintainable, and scalable applications. </span><span class="koboSpan" id="kobo.295.3">But remember, evaluating whether CQRS fits your project’s needs is crucial. </span><span class="koboSpan" id="kobo.295.4">And now in the next section, we will see the best practices and common mistakes when we implement CQRS in </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">our solution.</span></span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.297.1">What are best practices and common pitfalls?</span></h2>
<p><span class="koboSpan" id="kobo.298.1">As all other architecture design</span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.299.1"> patterns, there are some best practices to follow up and some common mistakes we need to consider while we are implementing this </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">architecture design.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">Let’s start with </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">best practices:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.303.1">Start simple</span></strong><span class="koboSpan" id="kobo.304.1">: Begin with a plain approach. </span><span class="koboSpan" id="kobo.304.2">You don’t need to split every piece of your application into commands and queries from the beginning. </span><span class="koboSpan" id="kobo.304.3">You are still in the microservices realm and can determine each service’s </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">needs individually.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.306.1">Keep communication clear</span></strong><span class="koboSpan" id="kobo.307.1">: Ensure the communication between the command and query sides is well defined. </span><span class="koboSpan" id="kobo.307.2">This relates to the next item because if you design your database well, you can build clear communication between the command and </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">query sides.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.309.1">Optimize database design</span></strong><span class="koboSpan" id="kobo.310.1">: Design your </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.311.1">database to suit the split nature of CQRS. </span><span class="koboSpan" id="kobo.311.2">Please consider this design carefully, this is not just creating a table – in this database design, one side of the code inserts data, and the other side of the code will view it. </span><span class="koboSpan" id="kobo.311.3">You need to pay attention to this database design more than other </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">design patterns.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.313.1">Regularly test and refine</span></strong><span class="koboSpan" id="kobo.314.1">: Continuously test and refine your implementation. </span><span class="koboSpan" id="kobo.314.2">This is an inevitable step for all implementations. </span><span class="koboSpan" id="kobo.314.3">You can only be comfortable with our designs if we </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">test them.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.316.1">While implementing CQRS, there are some mistakes</span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.317.1"> we want </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">to avoid:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.319.1">Overcomplication</span></strong><span class="koboSpan" id="kobo.320.1">: You need to be sure that your system is manageable and is doing what it needs to do, nothing more, </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">nothing less.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.322.1">Misjudging the scale</span></strong><span class="koboSpan" id="kobo.323.1">: Implementing CQRS in a system that doesn’t really need it is like using an 18-wheeler to drive to the grocery store. </span><span class="koboSpan" id="kobo.323.2">You must be very careful while assessing whether your application truly benefits </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">from CQRS.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.325.1">Ignoring business logic separation</span></strong><span class="koboSpan" id="kobo.326.1">: You must keep our command and query responsibilities strictly separate. </span><span class="koboSpan" id="kobo.326.2">You need to keep checking this for each pull request we create and each code review you do, because if it gets mixed up, the application may soon </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">become garbage.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.328.1">Underestimating the learning curve</span></strong><span class="koboSpan" id="kobo.329.1">: You must recognize that CQRS requires a learning curve for </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.330.1">your team. </span><span class="koboSpan" id="kobo.330.2">You need learning tools for new joiners to touch base with them on </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">our system.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.332.1">By following these best practices and avoiding common pitfalls, you can make your CQRS implementation successful. </span><span class="koboSpan" id="kobo.332.2">It’s about finding that sweet spot for making your system efficient without overcomplicating it. </span><span class="koboSpan" id="kobo.332.3">Remember, the goal is to create a system that’s as smooth and efficient as a well-tuned car, ready to take you wherever you need </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">to go.</span></span></p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.334.1">What are the benefits of the CQRS design pattern?</span></h2>
<p><span class="koboSpan" id="kobo.335.1">With CQRS, you get some totally awesome </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.336.1">features including </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.338.1">Independent scaling</span></strong><span class="koboSpan" id="kobo.339.1"> – CQRS allows the read and write workloads to scale separately, which means </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">fewer slowdowns.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.341.1">Optimized schemas</span></strong><span class="koboSpan" id="kobo.342.1"> – The read side can have a schema perfectly optimized for querying, while the write side focuses on updates. </span><span class="koboSpan" id="kobo.342.2">With CQRS, you can scale the command side (write operations) by adding more instances or resources dedicated to handling these commands without necessarily increasing the load on the query side querying, while the write side focuses </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">on updates.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.344.1">Security</span></strong><span class="koboSpan" id="kobo.345.1"> – It’s way easier to make sure only the right people are making writes to </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">the data.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.347.1">Separation of concerns</span></strong><span class="koboSpan" id="kobo.348.1"> – Splitting read and write means models that are so much easier to maintain and adapt. </span><span class="koboSpan" id="kobo.348.2">Most complex business logic goes in the write model, while reading is simple </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">and sweet.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.350.1">Using these patterns together maximizes performance at the cost of more complex implementation. </span><span class="koboSpan" id="kobo.350.2">But it ensures your domain model and data are adaptable to any </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">future changes!</span></span></p>
<p><span class="koboSpan" id="kobo.352.1">Up to now, we have learned about CQRS, its benefits, best practices, and common pitfalls. </span><span class="koboSpan" id="kobo.352.2">But CQRS has a twin brother, and they are mostly used together – namely, Event Sourcing. </span><span class="koboSpan" id="kobo.352.3">In the next section, we will learn </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.353.1">about the core concepts of Event Sourcing and how they work together </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">with CQRS.</span></span></p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.355.1">Understanding Event Sourcing</span></h1>
<p><span class="koboSpan" id="kobo.356.1">In this section, we’re going to talk about Event Sourcing. </span><span class="koboSpan" id="kobo.356.2">We will also examine </span><strong class="bold"><span class="koboSpan" id="kobo.357.1">Event-Driven Architecture</span></strong><span class="koboSpan" id="kobo.358.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.359.1">EDA</span></strong><span class="koboSpan" id="kobo.360.1">) and will break down the differences between EDA and Event Sourcing. </span><span class="koboSpan" id="kobo.360.2">Additionally, we mentioned CQRS previously, but in this section we will learn</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.361.1"> where CQRS fits into the whole picture, and I’ll explain it all in a way that’s easy </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">to understand.</span></span></p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.363.1">Event-Driven Architecture</span></h2>
<p><span class="koboSpan" id="kobo.364.1">In this section, we’re going to break </span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.365.1">down some key concepts in EDA. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.366.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.367.1">.4</span></em><span class="koboSpan" id="kobo.368.1"> shows some basic examples of events and commands in </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">this architecture.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.370.1"><img alt="Figure 2.4: Examples of events and commands" src="image/B18400_02_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.371.1">Figure 2.4: Examples of events and commands</span></p>
<p><span class="koboSpan" id="kobo.372.1">First up, we have </span><strong class="bold"><span class="koboSpan" id="kobo.373.1">events</span></strong><span class="koboSpan" id="kobo.374.1">. </span><span class="koboSpan" id="kobo.374.2">Events are</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.375.1"> basically things that happen – such as a user logging in, or an order </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.376.1">being placed. </span><span class="koboSpan" id="kobo.376.2">Then we have </span><strong class="bold"><span class="koboSpan" id="kobo.377.1">commands</span></strong><span class="koboSpan" id="kobo.378.1">. </span><span class="koboSpan" id="kobo.378.2">Commands are like orders or requests, telling something else to </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">do something.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">Events can be communicated as event notifications, and commands as messages. </span><span class="koboSpan" id="kobo.380.2">These are pretty similar – they both contain information. </span><span class="koboSpan" id="kobo.380.3">Sometimes an event notification is called a message too. </span><span class="koboSpan" id="kobo.380.4">In practice, people often just call both events. </span><span class="koboSpan" id="kobo.380.5">But technically, an event is something that happens, not a notification about it. </span><span class="koboSpan" id="kobo.380.6">Events are different from commands, which are more about intention. </span><span class="koboSpan" id="kobo.380.7">But for this section, we’ll just call them events to keep it simple. </span><span class="koboSpan" id="kobo.380.8">These</span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.381.1"> events can have data about what happened, or just be a notification. </span><span class="koboSpan" id="kobo.381.2">And they’re immutable, meaning they can’t be changed once created. </span><span class="koboSpan" id="kobo.381.3">EDA is based around these events. </span><span class="koboSpan" id="kobo.381.4">There’s some debate about whether it’s just events or includes other messages too. </span><span class="koboSpan" id="kobo.381.5">But for now, just focus on the events flowing through </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.383.1">Okay, so in EDA, there are usually three main </span><strong class="bold"><span class="koboSpan" id="kobo.384.1">components</span></strong><span class="koboSpan" id="kobo.385.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<span class="koboSpan" id="kobo.387.1"><img alt="Figure 2.5: EDA components" src="image/B18400_02_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.388.1">Figure 2.5: EDA components</span></p>
<p><span class="koboSpan" id="kobo.389.1">First, the </span><strong class="bold"><span class="koboSpan" id="kobo.390.1">producer</span></strong><span class="koboSpan" id="kobo.391.1"> creates the</span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.392.1"> events. </span><span class="koboSpan" id="kobo.392.2">Then the </span><strong class="bold"><span class="koboSpan" id="kobo.393.1">broker</span></strong><span class="koboSpan" id="kobo.394.1"> redirects events</span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.395.1"> to the right </span><strong class="bold"><span class="koboSpan" id="kobo.396.1">consumers</span></strong><span class="koboSpan" id="kobo.397.1">, and consumers react to events and take </span><a id="_idIndexMarker099"/><span class="No-Break"><span class="koboSpan" id="kobo.398.1">action accordingly.</span></span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.399.1">What is Event Sourcing?</span></h2>
<p><span class="koboSpan" id="kobo.400.1">In this section, we will talk about Event Sourcing and how it can be useful for tracking changes in your apps. </span><span class="koboSpan" id="kobo.400.2">Basically, instead of just saving the final state, you can record every single change that happens as an event. </span><span class="koboSpan" id="kobo.400.3">These events get stored in something called an </span><strong class="bold"><span class="koboSpan" id="kobo.401.1">event log</span></strong><span class="koboSpan" id="kobo.402.1">, which</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.403.1"> keeps them in order so you can see the full history. </span><span class="koboSpan" id="kobo.403.2">By reading through the event log from start to finish, you can literally rebuild the entire state of your app! </span><span class="koboSpan" id="kobo.403.3">This is </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.404.1">what people call </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.405.1">event sourcing</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">Let’s now go through an example event log schema and then talk a bit about one of the main features of Event Sourcing – </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">parallel processing.</span></span></p>
<h3><span class="koboSpan" id="kobo.409.1">Example of event log schema</span></h3>
<p><span class="koboSpan" id="kobo.410.1">Let’s take the example of an e-commerce store again. </span><span class="koboSpan" id="kobo.410.2">Say you want to keep track of inventory levels for all your products. </span><span class="koboSpan" id="kobo.410.3">Well, you could have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">ProductAdded</span></strong><span class="koboSpan" id="kobo.412.1"> event that stores the product ID and how </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.413.1">many products were added whenever you stock up. </span><span class="koboSpan" id="kobo.413.2">And when someone buys something, you’d log a </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">ProductPurchased</span></strong><span class="koboSpan" id="kobo.415.1"> event with the ID and amount. </span><span class="koboSpan" id="kobo.415.2">By replaying all these events in order, you can always know the current inventory levels no matter what. </span><span class="koboSpan" id="kobo.415.3">Event sourcing is super useful for anything where you need the full audit trail of all changes over time. </span><span class="koboSpan" id="kobo.415.4">This is definitely something worth checking out if you want your apps to have that kind of </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">historical data.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.417.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.418.1">.6</span></em><span class="koboSpan" id="kobo.419.1"> shows how the events log orders </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">the inventory.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<span class="koboSpan" id="kobo.421.1"><img alt="Figure 2.6: Event log – detailed example" src="image/B18400_02_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.422.1">Figure 2.6: Event log – detailed example</span></p>
<p><span class="koboSpan" id="kobo.423.1">Now let me break this down for you real quick. </span><span class="koboSpan" id="kobo.423.2">First, we add some products to our inventory – let’s say we add 10 products. </span><span class="koboSpan" id="kobo.423.3">Later on, some customers start buying those products. </span><span class="koboSpan" id="kobo.423.4">We get a purchase event for one product, then another purchase event for another product. </span><span class="koboSpan" id="kobo.423.5">Now here’s the cool part – we can look at our event log at any time and figure out what our current inventory is! </span><span class="koboSpan" id="kobo.423.6">We know we started with 10 products. </span><span class="koboSpan" id="kobo.423.7">Then we had two purchase events, so that means we must have eight products </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">left now.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">The key thing about Event Sourcing is that we can reset our inventory to zero at any time. </span><span class="koboSpan" id="kobo.425.2">We can delete how many products we have. </span><span class="koboSpan" id="kobo.425.3">But as long as we have that event log, we can always go back and recalculate how many products we should have based on all </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">the events!</span></span></p>
<p><span class="koboSpan" id="kobo.427.1">So, in summary, Event Sourcing uses an event log to keep track of everything that happens, so you can always go back in time and see what your data looked like at any point and check the previous states of your data. </span><span class="koboSpan" id="kobo.427.2">For example, let’s say on day 1 you added 10 products to your inventory. </span><span class="koboSpan" id="kobo.427.3">On day 2, someone bought one product. </span><span class="koboSpan" id="kobo.427.4">And on day 3, someone else grabbed</span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.428.1"> another product. </span><span class="koboSpan" id="kobo.428.2">With Event Sourcing, you can look back and see exactly what your inventory looked like on day 2 or even day 1. </span><span class="koboSpan" id="kobo.428.3">This is super useful for debugging or replicating your data somewhere else. </span><span class="koboSpan" id="kobo.428.4">All you have to do is replay the log of events – there’s no need to manually set everything up </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">from scratch.</span></span></p>
<h3><span class="koboSpan" id="kobo.430.1">Parallel processing</span></h3>
<p><span class="koboSpan" id="kobo.431.1">Parallel processing is a super useful feature </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.432.1">of Event Sourcing when you have multiple apps or services reading from the same data source. </span><span class="koboSpan" id="kobo.432.2">Instead of each app having to wait their turn to read stuff, they can all read at the same time in parallel. </span><span class="koboSpan" id="kobo.432.3">This is perfect if you have way more readers </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">than writers.</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">Let’s say you have an event log that tracks everything happening in your system. </span><span class="koboSpan" id="kobo.434.2">Instead of one app reading the log and then the next, they can all read simultaneously, as </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">shown here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.436.1"><img alt="Figure 2.7: Parallel processing feature" src="image/B18400_02_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.437.1">Figure 2.7: Parallel processing feature</span></p>
<p><span class="koboSpan" id="kobo.438.1">As long as the data in the log doesn’t change, you can have tons of parallel reading, no problem. </span><span class="koboSpan" id="kobo.438.2">This comes in super clutch because it means each app can independently grab what it needs from the log and do its own process without getting in the way of the others. </span><span class="koboSpan" id="kobo.438.3">They can process in</span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.439.1"> parallel. </span><span class="koboSpan" id="kobo.439.2">As long as the log only ever adds new events and doesn’t modify old ones, everything </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">stays consistent.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">So, parallel reading is a great way to maximize your throughput and take full advantage of all </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">your resources.</span></span></p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.443.1">Differences between Event-Driven Architecture and Event Sourcing</span></h2>
<p><span class="koboSpan" id="kobo.444.1">EDA is all about components communicating through events. </span><span class="koboSpan" id="kobo.444.2">When something important happens in the system, it emits an event. </span><span class="koboSpan" id="kobo.444.3">Other components can then </span><strong class="bold"><span class="koboSpan" id="kobo.445.1">subscribe</span></strong><span class="koboSpan" id="kobo.446.1"> to those events and react accordingly. </span><span class="koboSpan" id="kobo.446.2">This loose coupling makes EDA great for scalability </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.447.1">and real-time responsiveness. </span><span class="koboSpan" id="kobo.447.2">You see it a lot in microservices, messaging systems, and </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">IoT apps.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">With Event Sourcing, instead of just storing the current data state, it stores a log of all the events that changed the data over time. </span><span class="koboSpan" id="kobo.449.2">So, the current state is reconstructed by replaying all those past events. </span><span class="koboSpan" id="kobo.449.3">This is useful for auditing, having different versions, and analyzing historical data. </span><span class="koboSpan" id="kobo.449.4">Event Sourcing also works well with CQRS, which separates reading from writing. </span><span class="koboSpan" id="kobo.449.5">The write side stores events while the read side is optimized </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">for queries.</span></span></p>
<p><span class="koboSpan" id="kobo.451.1">While both EDA and Event Sourcing involve events, they focus on different things. </span><span class="koboSpan" id="kobo.451.2">EDA is more about how components communicate through events. </span><span class="koboSpan" id="kobo.451.3">Event Sourcing is about persisting event logs to represent state changes over time to benefit from things including auditing and versions. </span><span class="koboSpan" id="kobo.451.4">You can have Event Sourcing as part of an event-driven system, but they each solve their </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">own problems.</span></span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.453.1">A real-world example of the Event Sourcing pattern</span></h2>
<p><span class="koboSpan" id="kobo.454.1">In Event Sourcing, every single change is</span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.455.1"> written down in order so that we can always look back and see how things changed with timelines. </span><span class="koboSpan" id="kobo.455.2">We will understand this better with a story about someone named Sarah and how she interacts with an online platform. </span><span class="koboSpan" id="kobo.455.3">Her activities, say putting up a status or adding contact details, are recorded as a series of events. </span><span class="koboSpan" id="kobo.455.4">Every event is part of a transaction and has a single sequence ID ensuring that every change is tracked to chronology. </span><span class="koboSpan" id="kobo.455.5">In our following example, every</span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.456.1"> event is </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.457.1">kept in </span><strong class="bold"><span class="koboSpan" id="kobo.458.1">Java Script Object Notation</span></strong><span class="koboSpan" id="kobo.459.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.460.1">JSON</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">) format.</span></span></p>
<p><span class="koboSpan" id="kobo.462.1">Here is the list of events created by </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">Sarah’s operation:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.464.1">Event 1 – Account Creation</span></strong><span class="koboSpan" id="kobo.465.1"> – The journey begins with Sarah creating </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">her account:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.467.1">
  {
    "event": "Account Created",
    "transactionId": "tx200",
    "sequenceId": 1,
    "date": "2023-03-01",
    "userId": "user123",
    "details": {
      "name": "Sarah",
      "email": "sarah@example.com"
    }
  }</span></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.468.1">Event 2 – Email Update</span></strong><span class="koboSpan" id="kobo.469.1"> – Shortly after, Sarah </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.470.1">updates her </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">email address:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.472.1">
  {
    "event": "Email Updated",
    "transactionId": "tx200",
    "sequenceId": 2,
    "date": "2023-03-05",
    "userId": "user123",
    "details": {
      "newEmail": "s.new@example.com"
    }
  }</span></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.473.1">Event 3 – Add Mailing Address</span></strong><span class="koboSpan" id="kobo.474.1"> – Sarah then adds a mailing address to </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">her profile:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.476.1">
  {
    "event": "Address Added",
    "transactionId": "tx200",
    "sequenceId": 3,
    "date": "2023-03-10",
    "userId": "user123",
    "details": {
      "address": "123 Main St, Anytown, USA"
    }
  }</span></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.477.1">Event 4 – Name Update</span></strong><span class="koboSpan" id="kobo.478.1"> – Later, she</span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.479.1"> decides to update her name on </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">the profile:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.481.1">
  {
    "event": "Name Updated",
    "transactionId": "tx200",
    "sequenceId": 4,
    "date": "2023-03-15",
    "userId": "user123",
    "details": {
      "name": "Sarah N."
</span><span class="koboSpan" id="kobo.481.2">    }
  }</span></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.482.1">Event 5 – Phone Number Added</span></strong><span class="koboSpan" id="kobo.483.1"> – Finally, Sarah adds her </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">phone number:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.485.1">
  {
    "event": "Phone Number Added",
    "transactionId": "tx200",
    "sequenceId": 5,
    "date": "2023-03-20",
    "userId": "user123",
    "details": {
      "phoneNumber": "555-1234"
    }
  }</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.486.1">When we process these events in the sequence in which they were recorded, we are able to reconstruct the current state of Sarah’s profile at any point in time. </span><span class="koboSpan" id="kobo.486.2">Every event is immutable so once an event is put to record, it cannot be changed. </span><span class="koboSpan" id="kobo.486.3">This account gives a very clear and comprehensive </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.487.1">history of how Sarah’s profile has changed </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">with time.</span></span></p>
<p><span class="koboSpan" id="kobo.489.1">In conclusion, Event Sourcing presents a very strong framework for recording as well as managing changes to the states of systems. </span><span class="koboSpan" id="kobo.489.2">It excels in scenarios requiring detailed audit trails and historical data analysis. </span><span class="koboSpan" id="kobo.489.3">Event Sourcing logs every change as a distinct event, providing a powerful overview of data evolution, allowing the systems not only to present the current state but to revisit and analyze the past states. </span><span class="koboSpan" id="kobo.489.4">This, therefore, is an invaluable approach to complex systems where understanding the journey of data is as important as the </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">system itself.</span></span></p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.491.1">The relation of Event Sourcing with CQRS</span></h1>
<p><span class="koboSpan" id="kobo.492.1">We mentioned, at the beginning of </span><em class="italic"><span class="koboSpan" id="kobo.493.1">Event Sourcing</span></em><span class="koboSpan" id="kobo.494.1"> section, that we will discover how CQRS fits into the larger picture, so let’s now combine all of the concepts we learned in the previous sections. </span><span class="koboSpan" id="kobo.494.2">Alright! </span><span class="koboSpan" id="kobo.494.3">Basically, with</span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.495.1"> CQRS, the way you write data is different from how you read it. </span><span class="koboSpan" id="kobo.495.2">In the past, you might have just used one database for everything. </span><span class="koboSpan" id="kobo.495.3">You could do operations such as inserting data and then get it right back out of the same place, and that works fine if you’re just doing basic create, read, update, and delete operations. </span><span class="koboSpan" id="kobo.495.4">But sometimes you might want to scale how much you can write versus read separately. </span><span class="koboSpan" id="kobo.495.5">Or maybe you need different views of the data for reading versus writing. </span><span class="koboSpan" id="kobo.495.6">That’s where CQRS </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">comes in.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.497.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.498.1">.8</span></em><span class="koboSpan" id="kobo.499.1"> shows how commands and queries interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">the database:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.501.1"><img alt="Figure 2.8: Representation of CQRS pattern" src="image/B18400_02_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.502.1">Figure 2.8: Representation of CQRS pattern</span></p>
<p><span class="koboSpan" id="kobo.503.1">The basic idea is that you split up how you write data from how you query or get data out. </span><span class="koboSpan" id="kobo.503.2">So you could write to one database that’s optimized for the speed of inserts, and then have a separate database setup just for reading where you combine data from other services to give customized views of the information. </span><span class="koboSpan" id="kobo.503.3">Separating writing and reading gives you more flexibility to scale both independently based on your specific needs. </span><span class="koboSpan" id="kobo.503.4">It also lets you transform the data in different ways for </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">different uses.</span></span></p>
<p><span class="koboSpan" id="kobo.505.1">So, let’s say we have a few services – we have a Payment service, Shipping service, and Order service. </span><span class="koboSpan" id="kobo.505.2">Each of these services is keeping track of what’s going on in their part of the process using an </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">event log.</span></span></p>
<p><span class="koboSpan" id="kobo.507.1">The Payment service knows what payments went through and which ones failed. </span><span class="koboSpan" id="kobo.507.2">The Shipping service knows where all the deliveries are at. </span><span class="koboSpan" id="kobo.507.3">The Order service has the full history of orders for </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">each user.</span></span></p>
<p><span class="koboSpan" id="kobo.509.1">Now we want to make a page</span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.510.1"> that shows a user all their past orders in one place. </span><span class="koboSpan" id="kobo.510.2">Well, to do that, our Orders review feature is going to use all three services to show all past orders in one place. </span><span class="koboSpan" id="kobo.510.3">It’s going to ask the Payment service for the payment information, the Shipping service for shipping statuses, and the Order service for the basic </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">order details.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.512.1"><img alt="Figure 2.9: Zoom in on the service side" src="image/B18400_02_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.513.1">Figure 2.9: Zoom in on the service side</span></p>
<p><span class="koboSpan" id="kobo.514.1">Then it takes all that data and combines it into one nice clean page for the user to see the full story of their order history in one spot. </span><span class="koboSpan" id="kobo.514.2">Pretty cool how even though each service handles its own part independently using events, we can still tie them all together to give the user a </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">unified view!</span></span></p>
<p><span class="koboSpan" id="kobo.516.1">The main benefit of </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.517.1">using CQRS is that it allows you to split the reads and the writes in different systems. </span><span class="koboSpan" id="kobo.517.2">This allows you to scale them independently. </span><span class="koboSpan" id="kobo.517.3">If you’re having more reads than writes, or the other way around, you can scale each of these parts independently. </span><span class="koboSpan" id="kobo.517.4">You can also have different logic – you can have additional processing when you write, or additional layers or capabilities when you’re reading. </span><span class="koboSpan" id="kobo.517.5">You can also get information from </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">different systems.</span></span></p>
<p><span class="koboSpan" id="kobo.519.1">Finally, let’s take a look at how the Event Sourcing and CQRS patterns work together in the </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">bigger picture:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.521.1"><img alt="Figure 2.10: Event Sourcing pattern with CQRS" src="image/B18400_02_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.522.1">Figure 2.10: Event Sourcing pattern with CQRS</span></p>
<p><span class="koboSpan" id="kobo.523.1">Let’s walk through together </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.524.1">through </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">this diagram:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.526.1">UI</span></strong><span class="koboSpan" id="kobo.527.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">User Interface</span></span><p class="list-inset"><span class="koboSpan" id="kobo.529.1">First up, the UI is like the front desk of our office. </span><span class="koboSpan" id="kobo.529.2">This is where you, the user, go to interact. </span><span class="koboSpan" id="kobo.529.3">You can either give instructions (commands) or ask for </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">information (queries).</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.531.1">Command</span></strong><span class="koboSpan" id="kobo.532.1">: Getting </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">things done</span></span><p class="list-inset"><span class="koboSpan" id="kobo.534.1">Issuing commands through the UI is like sending off requests to get something done – maybe adding a new file or updating an existing one. </span><span class="koboSpan" id="kobo.534.2">This command is taken up by the system, does its magic, and updates our “write” database, where we keep track of all </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">these changes.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.536.1">Query</span></strong><span class="koboSpan" id="kobo.537.1">: Asking </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">for information</span></span><p class="list-inset"><span class="koboSpan" id="kobo.539.1">Now if it is information you are interested in, that’s a query. </span><span class="koboSpan" id="kobo.539.2">It’s like asking someone at the office to pull out a file for you. </span><span class="koboSpan" id="kobo.539.3">This information is pulled from another database specially designed for reading purposes. </span><span class="koboSpan" id="kobo.539.4">It’s faster and cleaner, sort of like having a set of files ready</span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.540.1"> for viewing </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">each time.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.542.1">Event Sourcing</span></strong><span class="koboSpan" id="kobo.543.1">: Detailed </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">record keeping</span></span><p class="list-inset"><span class="koboSpan" id="kobo.545.1">And now, the interesting part. </span><span class="koboSpan" id="kobo.545.2">Rather than keeping only the latest update, in Event Sourcing, a detailed log of every single individual change is kept by the system – more like a diary entry for every single action. </span><span class="koboSpan" id="kobo.545.3">Each such action, adding or taking something away, is recorded as </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">an event.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.547.1">Event Store or Log</span></strong><span class="koboSpan" id="kobo.548.1">: The </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">system’s memory</span></span><p class="list-inset"><span class="koboSpan" id="kobo.550.1">The Log or Event Store is literally the memory of the system. </span><span class="koboSpan" id="kobo.550.2">It holds on to all these event records. </span><span class="koboSpan" id="kobo.550.3">If there ever were a need, one could scroll back through this log and see its full history of changes or even replay them to understand how the system got to its </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">current state.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.552.1">Publishing Events</span></strong><span class="koboSpan" id="kobo.553.1">: Spreading </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">the news</span></span><p class="list-inset"><span class="koboSpan" id="kobo.555.1">Upon successful processing of a command, the system doesn’t just update the database, but also broadcasts an event. </span><span class="koboSpan" id="kobo.555.2">It functions as an announcement shouting at the world what has </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">just changed.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.557.1">Event Handler or Bus</span></strong><span class="koboSpan" id="kobo.558.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">The messenger</span></span><p class="list-inset"><span class="koboSpan" id="kobo.560.1">The event bus or handler is no different than an office messenger. </span><span class="koboSpan" id="kobo.560.2">It captures the event and delivers the news to all relevant places so that the read database is updated with the </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">latest information.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.562.1">Database (Read)</span></strong><span class="koboSpan" id="kobo.563.1">: Optimized for </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">quick access</span></span><p class="list-inset"><span class="koboSpan" id="kobo.565.1">The read database is there to make access to information rapid and easy. </span><span class="koboSpan" id="kobo.565.2">It is different from the write database, and it’s set up to enable you to pull information swiftly and </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">without hesitation.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.567.1">Materialized View</span></strong><span class="koboSpan" id="kobo.568.1">: Information ready </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">to go</span></span><p class="list-inset"><span class="koboSpan" id="kobo.570.1">Finally, we come with the materialized view. </span><span class="koboSpan" id="kobo.570.2">It’s a snapshot of the data essentially already prepared </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.571.1">and optimized for your queries. </span><span class="koboSpan" id="kobo.571.2">Think of it as a summary report, ready at </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">your fingertips.</span></span></p></li>
</ul>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.573.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.574.1">.10</span></em><span class="koboSpan" id="kobo.575.1"> shows a smart and efficient system, where tasking is neatly divided among all the other resources that facilitate and manage the interrogations you make to that data warehouse </span><em class="italic"><span class="koboSpan" id="kobo.576.1">and</span></em><span class="koboSpan" id="kobo.577.1"> the actual data warehouse itself. </span><span class="koboSpan" id="kobo.577.2">On the one side, you have commands changing things and on the other side, you have queries getting information. </span><span class="koboSpan" id="kobo.577.3">And in Event Sourcing, there’s a complete history of every change. </span><span class="koboSpan" id="kobo.577.4">It’s like running a smooth, highly efficient, organized, and transparent company office workflow where nothing is misplaced or lost in </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">the process.</span></span></p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.579.1">A real-world example of CQRS with Event Sourcing</span></h1>
<p><span class="koboSpan" id="kobo.580.1">In this section, I’m going to provide a </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.581.1">real-world example diagram of a banking system using CQRS with Event Sourcing. </span><span class="koboSpan" id="kobo.581.2">We’re going to focus on the bank account side. </span><span class="koboSpan" id="kobo.581.3">Take, for instance, a bank that has to do with opening accounts, depositing money, processing transactions, and closing accounts. </span><span class="koboSpan" id="kobo.581.4">To execute these tasks adequately, the bank puts into practice a system based on CQRS combined with </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">Event Sourcing.</span></span></p>
<p><span class="koboSpan" id="kobo.583.1">The following diagram shows how the </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">system works:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.585.1"><img alt="Figure 2.11: Banking example using the CQRS pattern with Event Sourcing" src="image/B18400_02_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.586.1">Figure 2.11: Banking example using the CQRS pattern with Event Sourcing</span></p>
<p><span class="koboSpan" id="kobo.587.1">Let’s break down this diagram in </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">simple terms:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.589.1">Command</span></strong><span class="koboSpan" id="kobo.590.1">: This is where you tell the bank what you want to do. </span><span class="koboSpan" id="kobo.590.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">OpenAccountCommand</span></strong><span class="koboSpan" id="kobo.592.1"> is like walking into the bank and saying, </span><em class="italic"><span class="koboSpan" id="kobo.593.1">“I want to open a new account.”</span></em><span class="koboSpan" id="kobo.594.1"> These commands</span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.595.1"> are part of the </span><strong class="bold"><span class="koboSpan" id="kobo.596.1">Bank Account Command API</span></strong><span class="koboSpan" id="kobo.597.1">, which is just some fancy way of saying that this system</span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.598.1"> understands and handles what you ask your bank </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">to do.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.600.1">Command Handler</span></strong><span class="koboSpan" id="kobo.601.1">: This could be considered as the bank employees who take your request and initiate the process. </span><span class="koboSpan" id="kobo.601.2">The handler ensures all steps necessary for your command </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">are taken.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.603.1">EventStore</span></strong><span class="koboSpan" id="kobo.604.1">: Everything that a user does (such as opening an account) gets stored as an </span><em class="italic"><span class="koboSpan" id="kobo.605.1">event</span></em><span class="koboSpan" id="kobo.606.1"> in a special database called the </span><em class="italic"><span class="koboSpan" id="kobo.607.1">EventStore</span></em><span class="koboSpan" id="kobo.608.1">. </span><span class="koboSpan" id="kobo.608.2">It’s like a meticulous diary of everything </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">that happens.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.610.1">Event Publisher</span></strong><span class="koboSpan" id="kobo.611.1">: This is a loudspeaker in the bank, which tells everyone what has just happened. </span><span class="koboSpan" id="kobo.611.2">For example, when you open an account, then the event publisher goes and tells the whole system, </span><em class="italic"><span class="koboSpan" id="kobo.612.1">“Hey, a new account </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.613.1">was opened!”</span></em></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.614.1">Apache Kafka Message Queue Broker</span></strong><span class="koboSpan" id="kobo.615.1">: Apache Kafka is like the mail system at a bank that makes sure messages (events) go to the right department. </span><span class="koboSpan" id="kobo.615.2">It’s really efficient and even if the bank’s super busy, every single message </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">gets through.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.617.1">Event Consumer</span></strong><span class="koboSpan" id="kobo.618.1">: This component of the system is a listener. </span><span class="koboSpan" id="kobo.618.2">It listens for any announcements (events) that are pertinent </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">to it.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.620.1">Event Handler</span></strong><span class="koboSpan" id="kobo.621.1">: If the event consumer is like the employee listening for an announcement, then the event handler is the actual employee that takes that information and updates the bank’s </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">records accordingly.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.623.1">Queries</span></strong><span class="koboSpan" id="kobo.624.1">: On the other hand, we have tasks that ask the bank for information, such as </span><em class="italic"><span class="koboSpan" id="kobo.625.1">“How much money do I have in my account?”</span></em><span class="koboSpan" id="kobo.626.1"> These queries take the form of things such </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">FindAllAccountsQueries</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.630.1">Query Handler</span></strong><span class="koboSpan" id="kobo.631.1">: This is much</span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.632.1"> the same as the customer service representative that accepts your query and looks up the information </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">for you.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.634.1">Read Database</span></strong><span class="koboSpan" id="kobo.635.1">: This is a separate database where the bank holds information that can be read – for example, your account balance, or even a list of all the accounts. </span><span class="koboSpan" id="kobo.635.2">It is organized such that any form of information can be reached easily </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">and quickly.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.637.1">The preceding diagram essentially just details two different processes in the bank’s system – one for doing things (for example, the process of opening an account) and another for querying things (such as how much money you have in your account). </span><span class="koboSpan" id="kobo.637.2">They work together but are separate, making the whole bank system run smoothly and efficiently. </span><span class="koboSpan" id="kobo.637.3">The “doing” part records whatever happens as events and remembers everything, while the “asking” part uses a simplified database in order to give you quick answers to </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">your questions.</span></span></p>
<p><span class="koboSpan" id="kobo.639.1">Up to now, we have learned about some commonly used architecture designs that are used in microservice architecture. </span><span class="koboSpan" id="kobo.639.2">In the next section, we will briefly discuss some other </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">architectural designs.</span></span></p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.641.1">Brief overview of other architectural patterns</span></h1>
<p><span class="koboSpan" id="kobo.642.1">In this section, we’re going to mention some additional architectural patterns. </span><span class="koboSpan" id="kobo.642.2">Using patterns is helpful because it makes your development way more efficient and productive. </span><span class="koboSpan" id="kobo.642.3">It also helps optimize costs </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.643.1">and improve planning – basically, it just makes </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">everything easier.</span></span></p>
<p><span class="koboSpan" id="kobo.645.1">There are tons of different enterprise patterns you can check out. </span><span class="koboSpan" id="kobo.645.2">To help you pick the right ones for your project, I have rounded up summaries of a few </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">of them.</span></span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.647.1">Service Oriented Architecture (SOA) design pattern</span></h2>
<p><span class="koboSpan" id="kobo.648.1">Service-oriented design patterns are kind of</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.649.1"> like building with LEGO blocks for software. </span><span class="koboSpan" id="kobo.649.2">You break the whole program down into smaller </span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.650.1">reusable pieces </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">called </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.652.1">services</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.654.1">Each service has its own specific job to do. </span><span class="koboSpan" id="kobo.654.2">It can</span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.655.1"> work on its own without needing the whole program. </span><span class="koboSpan" id="kobo.655.2">But these services talk to each other to get everything </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">done together.</span></span></p>
<p><span class="koboSpan" id="kobo.657.1">It’s kind of like if you had a big project and broke it into parts for different people. </span><span class="koboSpan" id="kobo.657.2">Each person focuses just on their part without worrying what the others are doing. </span><span class="koboSpan" id="kobo.657.3">Then it all comes together in </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">the end.</span></span></p>
<p><span class="koboSpan" id="kobo.659.1">This makes the software more flexible and easier to change later. </span><span class="koboSpan" id="kobo.659.2">Just as with LEGO blocks, you can use the same pieces to build lots of different things without always starting from scratch. </span><span class="koboSpan" id="kobo.659.3">It’s easier to swap things in </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">and out.</span></span></p>
<p><span class="koboSpan" id="kobo.661.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.662.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.663.1">.12</span></em><span class="koboSpan" id="kobo.664.1">, we can see the general design </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">of SOA:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.666.1"><img alt="Figure 2.12: Example of the SOA design pattern" src="image/B18400_02_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.667.1">Figure 2.12: Example of the SOA design pattern</span></p>
<p><span class="koboSpan" id="kobo.668.1"> As we can see, there is an </span><strong class="bold"><span class="koboSpan" id="kobo.669.1">Event Service Bus</span></strong><span class="koboSpan" id="kobo.670.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.671.1">ESB</span></strong><span class="koboSpan" id="kobo.672.1">) in between the services and the users. </span><span class="koboSpan" id="kobo.672.2">It delegates the tasks among the</span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.673.1"> services. </span><span class="koboSpan" id="kobo.673.2">There is a </span><strong class="bold"><span class="koboSpan" id="kobo.674.1">Shared</span></strong><span class="koboSpan" id="kobo.675.1"> layer between the services and database systems. </span><span class="koboSpan" id="kobo.675.2">Through this layer, all services can reach all the data they need, even data that wasn’t created by that </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">given service.</span></span></p>
<p><span class="koboSpan" id="kobo.677.1">So in summary, this pattern </span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.678.1">breaks programs into</span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.679.1"> smaller communicating services, much like breaking projects into parts or building with reusable blocks. </span><span class="koboSpan" id="kobo.679.2">It makes software simpler to work with as it changes </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">over time.</span></span></p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.681.1">The Circuit Breaker pattern</span></h2>
<p><span class="koboSpan" id="kobo.682.1">The Circuit Breaker pattern is all about</span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.683.1"> building software that can handle problems without crashing. </span><span class="koboSpan" id="kobo.683.2">Circuit breakers in code work similarly to those in electrical circuits. </span><span class="koboSpan" id="kobo.683.3">A lot of programs these days rely on</span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.684.1"> lots of different parts all working together over a network, right? </span><span class="koboSpan" id="kobo.684.2">But sometimes one of those parts can crash. </span><span class="koboSpan" id="kobo.684.3">With the Circuit Breaker pattern, your program is constantly checking that the different pieces are communicating okay. </span><span class="koboSpan" id="kobo.684.4">If it notices the same part is erroring out over and over, it will temporarily block any more requests to that part. </span><span class="koboSpan" id="kobo.684.5">This keeps the whole system from getting overwhelmed by one small glitch. </span><span class="koboSpan" id="kobo.684.6">Instead of everything grinding to a halt, the program can keep chugging along while that problem part gets its act together. </span><span class="koboSpan" id="kobo.684.7">Pretty handy for creating software that bends but </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">doesn’t break!</span></span></p>
<p><span class="koboSpan" id="kobo.686.1">In order to understand this pattern better, see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.687.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.688.1">.13:</span></em></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.689.1"><img alt="Figure 2.13: Example of the Circuit Breaker pattern" src="image/B18400_02_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.690.1">Figure 2.13: Example of the Circuit Breaker pattern</span></p>
<p><span class="koboSpan" id="kobo.691.1">In the Circuit Breaker pattern, as shown in our diagram, </span><strong class="bold"><span class="koboSpan" id="kobo.692.1">Service A</span></strong><span class="koboSpan" id="kobo.693.1"> is the main one responsible for dealing with users’ requests and has some critical internal components such </span><strong class="bold"><span class="koboSpan" id="kobo.694.1">Health Checker</span></strong><span class="koboSpan" id="kobo.695.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.696.1">Request Processor</span></strong><span class="koboSpan" id="kobo.697.1"> looking after the system healthiness and how it interacts with the users. </span><span class="koboSpan" id="kobo.697.2">This </span><strong class="bold"><span class="koboSpan" id="kobo.698.1">Service A</span></strong><span class="koboSpan" id="kobo.699.1"> is mediated by the key player, the </span><strong class="bold"><span class="koboSpan" id="kobo.700.1">Circuit Breaker</span></strong><span class="koboSpan" id="kobo.701.1">, which watches for failed requests and as soon as a certain number is reached, it trips just like a real </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.702.1">circuit breaker, stopping any further requests from taking place to prevent the system from getting overloaded, thus allowing for </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">recovery time.</span></span></p>
<p><span class="koboSpan" id="kobo.704.1">This mechanism aimed not </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.705.1">only at protecting </span><strong class="bold"><span class="koboSpan" id="kobo.706.1">Service A</span></strong><span class="koboSpan" id="kobo.707.1"> but also a way of safeguarding the external dependencies such as </span><strong class="bold"><span class="koboSpan" id="kobo.708.1">Service B</span></strong><span class="koboSpan" id="kobo.709.1"> and databases from being overwhelmed. </span><span class="koboSpan" id="kobo.709.2">It’s a failsafe that helps bring stability to a system, and in turn, prevents the other services that comprise the microservices architecture from falling over </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">like dominoes.</span></span></p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.711.1">The Layered design pattern</span></h2>
<p><span class="koboSpan" id="kobo.712.1">The Layered design pattern is a way for</span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.713.1"> programmers to structure their </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.714.1">code in an organized fashion. </span><span class="koboSpan" id="kobo.714.2">Basically what it does is break the software up into different levels, each with its own </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">specific job.</span></span></p>
<p><span class="koboSpan" id="kobo.716.1">The levels are stacked on top of each other, with the lower levels providing services for the higher ones. </span><span class="koboSpan" id="kobo.716.2">So, the bottom level would focus on things such as data access or hardware interfaces. </span><span class="koboSpan" id="kobo.716.3">Then the next level up could use those lower services to do things such as business logic, while the top levels are more about interfaces, such as the </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">user interface.</span></span></p>
<p><span class="koboSpan" id="kobo.718.1">By separating everything like this, it makes the code easier to manage and maintain. </span><span class="koboSpan" id="kobo.718.2">Programmers can work on individual levels without worrying too much about the other pieces. </span><span class="koboSpan" id="kobo.718.3">And it’s easier to reuse code since each level has a clear purpose. </span><span class="koboSpan" id="kobo.718.4">If you need to update how data is stored, you only have to change the bottom level rather than digging through the </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">whole program.</span></span></p>
<p><span class="koboSpan" id="kobo.720.1">Overall it promotes a logical structure where each new level you build on top of relies on the work done below. </span><span class="koboSpan" id="kobo.720.2">This hierarchical setup helps organize large and complex software systems into understandable and </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">manageable chunks.</span></span></p>
<p><span class="koboSpan" id="kobo.722.1">In the following </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.723.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.724.1">.14</span></em><span class="koboSpan" id="kobo.725.1">, we can see</span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.726.1"> what the layered design pattern looks </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">like overall:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.728.1"><img alt="Figure 2.14: Example of the Layered design pattern" src="image/B18400_02_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.729.1">Figure 2.14: Example of the Layered design pattern</span></p>
<p><span class="koboSpan" id="kobo.730.1">As you can see in the diagram, each layer is</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.731.1"> isolated from the others, and they can’t skip one layer and communicate with another one directly. </span><span class="koboSpan" id="kobo.731.2">So, by this design, you can keep user interactions in the controller </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.732.1">layer, perform the</span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.733.1"> business logic in the application layer, and keep database operations in the </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">data layer.</span></span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.735.1">The MVC design pattern</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.736.1">MVC</span></strong><span class="koboSpan" id="kobo.737.1"> stands for </span><strong class="bold"><span class="koboSpan" id="kobo.738.1">Model-View-Controller</span></strong><span class="koboSpan" id="kobo.739.1"> and basically </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.740.1">splits everything into three parts. </span><span class="koboSpan" id="kobo.740.2">It is such a common design pattern for building </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.741.1">web and </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">mobile applications!</span></span></p>
<p><span class="koboSpan" id="kobo.743.1">The Model is where all the important stuff is stored, such as user accounts, posts, products – you name it! </span><span class="koboSpan" id="kobo.743.2">That’s the core data and logic of </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">the app.</span></span></p>
<p><span class="koboSpan" id="kobo.745.1">The View is what the user sees on their screen – things such as HTML, CSS, and maybe templates if it’s a single-page app. </span><span class="koboSpan" id="kobo.745.2">This renders the Model data so users can view </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">it all.</span></span></p>
<p><span class="koboSpan" id="kobo.747.1">Then we’ve got the Controller! </span><span class="koboSpan" id="kobo.747.2">This handles everything the user does including clicks, forms, and API calls. </span><span class="koboSpan" id="kobo.747.3">When something happens, the Controller figures it out, updates the Model if needed, and tells the View to </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">change up.</span></span></p>
<p><span class="koboSpan" id="kobo.749.1">By separating the code out like this, it stays super clean and organized over time. </span><span class="koboSpan" id="kobo.749.2">You can tweak one part without messing </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.750.1">up the others as much. </span><span class="koboSpan" id="kobo.750.2">Plus it gives flexibility to reuse or swap pieces in </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">and out.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.752.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.753.1">.15</span></em><span class="koboSpan" id="kobo.754.1"> shows an example MVC design, and we will next discuss how the request returns to </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">a view:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.756.1"><img alt="Figure 2.15: Example of MVC design pattern" src="image/B18400_02_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.757.1">Figure 2.15: Example of MVC design pattern</span></p>
<p><span class="koboSpan" id="kobo.758.1">In the preceding diagram, we can</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.759.1"> see a very similar diagram to the previous Layered architecture design pattern. </span><span class="koboSpan" id="kobo.759.2">However, here, we don’t have an application layer. </span><span class="koboSpan" id="kobo.759.3">The business logic is divided between the controller and model layers. </span><span class="koboSpan" id="kobo.759.4">When the </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.760.1">user makes a request, after the business logic has been applied, the controller returns a view, which can be a web page or a </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">JSON object.</span></span></p>
<p><span class="koboSpan" id="kobo.762.1">In summary, MVC is the best pattern for building user interfaces in a way that’s maintainable and organized for the long run. </span><span class="koboSpan" id="kobo.762.2">It really makes app development a </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">total breeze!</span></span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.764.1">The Saga design pattern</span></h2>
<p><span class="koboSpan" id="kobo.765.1">The Saga design pattern is so cool for building </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.766.1">distributed systems! </span><span class="koboSpan" id="kobo.766.2">It helps </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.767.1">manage long transactions and keeps data consistent between different services. </span><span class="koboSpan" id="kobo.767.2">Maintaining atomicity and consistency is tough when you have multiple related steps spread across multiple services. </span><span class="koboSpan" id="kobo.767.3">But Saga has </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">you covered!</span></span></p>
<p><span class="koboSpan" id="kobo.769.1">Saga is perfect when you have a big distributed system made up of many microservices. </span><span class="koboSpan" id="kobo.769.2">Sometimes you need a business transaction that involves multiple steps happening across different services. </span><span class="koboSpan" id="kobo.769.3">No problem! </span><span class="koboSpan" id="kobo.769.4">With Saga, you can break the transaction into a sequence of smaller transactions, with each one fully contained within a single service. </span><span class="koboSpan" id="kobo.769.5">It coordinates all data flows to make sure each request lines up properly in the end, without needing complicated distributed transactions. </span><span class="koboSpan" id="kobo.769.6">Distributed transactions can be complex and hard to scale, but Saga avoids all that for </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">smooth sailing.</span></span></p>
<p><span class="koboSpan" id="kobo.771.1">As reflected in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.772.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.773.1">.16</span></em><span class="koboSpan" id="kobo.774.1">, the</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.775.1"> Saga design pattern is a technique to deal with complex, multi-service transactions such as the order, payment, and shipping services in an </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">e-commerce context:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.777.1"><img alt="Figure 2.16: Example of the Saga design pattern" src="image/B18400_02_16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.778.1">Figure 2.16: Example of the Saga design pattern</span></p>
<p><span class="koboSpan" id="kobo.779.1">Let’s break down the preceding diagram. </span><span class="koboSpan" id="kobo.779.2">The order service initiates a multi-step transaction, each step of which gets handled by a different service. </span><span class="koboSpan" id="kobo.779.3">They communicate through event streams, making sure every step of the transaction happens in order. </span><span class="koboSpan" id="kobo.779.4">If anything goes wrong with any step, special</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.780.1"> actions (some abstraction saying what happened would be needed, not shown on the diagram) should be taken to </span><em class="italic"><span class="koboSpan" id="kobo.781.1">undo</span></em><span class="koboSpan" id="kobo.782.1"> previous steps that ensure </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.783.1">everything </span><em class="italic"><span class="koboSpan" id="kobo.784.1">reverts</span></em><span class="koboSpan" id="kobo.785.1">. </span><span class="koboSpan" id="kobo.785.2">Each service has its own database, hence they can operate independently, while the Saga pattern ensures that the entire transaction either fully succeeds or is properly </span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.786.1">compensated in case of any hiccups. </span><span class="koboSpan" id="kobo.786.2">This is key in managing complicated transactions in systems where there are different services that have to work </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">together seamlessly.</span></span></p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.788.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.789.1">Let’s review what we have learned in this chapter and then look forward to the things that we’ll cover next. </span><span class="koboSpan" id="kobo.789.2">Here’s what </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">we learned:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.791.1">DDD</span></strong><span class="koboSpan" id="kobo.792.1">: A strategy to ensure that our software development work aligns properly with the specific requirements of a business. </span><span class="koboSpan" id="kobo.792.2">This method guides us to create software that really serves its </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">intended purpose.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.794.1">CQRS</span></strong><span class="koboSpan" id="kobo.795.1">: We learned to manage data effectively, separating the operations that change data (commands) from those that retrieve them (queries). </span><span class="koboSpan" id="kobo.795.2">This separation aims to empower the performance and reliability of our systems, making them more feasible in terms of their actual use </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">case scenarios.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.797.1">Event Sourcing</span></strong><span class="koboSpan" id="kobo.798.1">: This pattern involves the logging of every change in the system as an event. </span><span class="koboSpan" id="kobo.798.2">It particularly shines when you are tracking changes over time and is a fundamental building block for systems where understanding the history of decisions and actions throughout their lifetime is core to </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">their operation.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.800.1">Benefits of design architectures</span></strong><span class="koboSpan" id="kobo.801.1">: We learned how to structure robust, efficient, and business-aligned systems, how to structure software in order to manage data better, and how to share the expected functional and nonfunctional requirements of modern </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">business applications.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.803.1">Now we look forward to </span><a href="B18400_03.xhtml#_idTextAnchor064"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.804.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.805.1">, where we will learn about building reactive REST APIs using Spring Boot and delve into the principles of asynchronous systems and back-pressure. </span><span class="koboSpan" id="kobo.805.2">This chapter focuses on advanced principles and concepts for designing web applications considering our understanding of software architecture from </span><em class="italic"><span class="koboSpan" id="kobo.806.1">Chapters 1 </span></em><span class="koboSpan" id="kobo.807.1">and</span><em class="italic"><span class="koboSpan" id="kobo.808.1"> 2</span></em><span class="koboSpan" id="kobo.809.1"> in order to develop applications that are both responsive </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">and efficient.</span></span></p>
</div>
</body></html>