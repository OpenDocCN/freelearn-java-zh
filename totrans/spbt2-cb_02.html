<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Configuring Web Applications</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we learned about how to create a starting application template, add some basic functionalities, and set up a connection to a database. In this chapter, we will continue to evolve our BookPub application and give it a web presence.</p>
<p>In this chapter, we will learn about the following topics:</p>
<ul>
<li>Creating a basic RESTful application</li>
<li>Creating Spring Data REST service</li>
<li>Configuring custom servlet filters</li>
<li>Configuring custom interceptors</li>
<li>Configuring custom HttpMessageConverters</li>
<li>Configuring custom PropertyEditors</li>
<li>Configuring custom type formatters</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a basic RESTful application</h1>
                </header>
            
            <article>
                
<p>While the command-line applications do have their place and use, most of today's application development is centered around web, REST, and data services. Let's start with enhancing our <kbd>BookPub</kbd> application by providing it with a web-based API in order to get access to the book catalogs.</p>
<p>We will start where we left off in the previous chapter, so there should already be an application skeleton with the entity objects and a repository service defined and a connection to the database configured.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>The very first thing that we will need to do is add a new dependency to <kbd>build.gradle</kbd> with the <kbd>spring-boot-starter-web</kbd> starter to get us all the necessary libraries for web-based functionality. The following code snippet is what it will look like:</li>
</ol>
<pre style="padding-left: 60px">dependencies { 
  compile("org.springframework.boot:spring-boot-starter-data-jpa") 
  compile("org.springframework.boot:spring-boot-starter-jdbc") 
  compile("org.springframework.boot:spring-boot-starter-web") 
  runtime("com.h2database:h2") <br/>  runtime("mysql:mysql-connector-java")
  testCompile("org.springframework.boot:spring-boot-starter-test") 
} </pre>
<ol start="2">
<li>Next, we will need to create a Spring controller that will be used to handle the web requests for the catalog data in our application. Let's start by creating a new package structure to house our controllers so that we have our code nicely grouped by its appropriate purposes. Create a package folder called <kbd>controllers</kbd> in the <kbd>src/main/java/com/example/bookpub</kbd> directory from the root of our project.</li>
<li>As we will be exposing the book data, let's create the controller class file called <kbd>BookController</kbd> in our newly created package with the following content:</li>
</ol>
<pre style="padding-left: 60px">@RestController 
@RequestMapping("/books") 
public class BookController { 
  @Autowired 
  private BookRepository bookRepository; 
 
  @RequestMapping(value = "", method = RequestMethod.GET) 
  public Iterable&lt;Book&gt; getAllBooks() { 
    return bookRepository.findAll(); 
  } 
 
  @RequestMapping(value = "/{isbn}", method =  
    RequestMethod.GET) 
  public Book getBook(@PathVariable String isbn) { 
    return bookRepository.findBookByIsbn(isbn); 
  } 
} </pre>
<ol start="4">
<li>Start the application by running <kbd>./gradlew clean bootRun</kbd>.</li>
<li>After the application has started, open the browser and go to <kbd>http://localhost:8080/books</kbd> and you should see a response: <kbd>[]</kbd>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The key to getting the service exposed to web requests is the <kbd>@RestController</kbd> annotation. This is yet another example of a meta-annotation or a convenience annotation, as the Spring documentation refers to it at times, which we have seen in previous recipes. In <kbd>@RestController</kbd>, two annotations are defined: <kbd>@Controller</kbd> and <kbd>@ResponseBody</kbd>. So we could just as easily annotate <kbd>BookController</kbd>, as follows:</p>
<pre style="padding-left: 60px">@Controller 
@ResponseBody 
@RequestMapping("/books") 
public class BookController {...} </pre>
<p>Let's take a look at the following annotations from the preceding code snippet:</p>
<ul>
<li><kbd>@Controller</kbd>: This is a Spring stereotype annotation that is similar to <kbd>@Bean</kbd> and <kbd>@Repository</kbd> and declares the annotated class as an MVC</li>
<li><kbd>@ResponseBody</kbd>: This is a Spring MVC annotation indicating that responses from the <span>web-request-mapped methods constitute </span>the entire content of the HTTP response body payload, which is typical for the RESTful applications</li>
<li><kbd>@RequestMapping</kbd>: This is a Spring MVC annotation indicating that requests to <kbd>/books/*</kbd> URL will be routed to  this controller.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating Spring Data REST service</h1>
                </header>
            
            <article>
                
<p>In the previous example, we fronted our <kbd>BookRepository</kbd> interface with a REST controller in order to expose the data behind it via a web RESTful API. While this is definitely a quick and easy way to make the data accessible, it does require us to manually create a controller and define the mappings for all the desired operations. To minimize the boilerplate code, Spring provides us with a more convenient way: <kbd>spring-boot-starter-data-rest</kbd>. This allows us to simply add an annotation to the repository interface and Spring will do the rest to expose it to the web.</p>
<p>We will continue from where we finished in the previous recipe, and so the entity models and the <kbd>BookRepository</kbd> interface should already exist.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>We will start by adding another dependency to our <kbd>build.gradle</kbd> file in order to add the <kbd>spring-boot-starter-data-rest</kbd> artifact:</li>
</ol>
<pre style="padding-left: 60px">dependencies { 
  ... 
  compile("org.springframework.boot:spring-boot-starter-data-rest") 
  ... 
} </pre>
<ol start="2">
<li>Now, let's create a new interface to define <kbd>AuthorRepository</kbd> in the <kbd>src/main/java/com/example/bookpub/repository</kbd> directory from the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">@RepositoryRestResource 
public interface AuthorRepository extends  
  PagingAndSortingRepository&lt;Author, Long&gt; { 
}</pre>
<ol start="3">
<li>While we are at it—given how little code it takes—let's create the repository interfaces for the remaining entity models, <kbd>PublisherRepository</kbd> and <kbd>ReviewerRepository</kbd> by placing the files in the same package directory as <kbd>AuthorRepository</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 60px">@RepositoryRestResource 
public interface PublisherRepository extends  
  PagingAndSortingRepository&lt;Publisher, Long&gt; { 
} </pre>
<p style="padding-left: 60px">Otherwise, you can use the following code instead of the preceding code:</p>
<pre style="padding-left: 60px">@RepositoryRestResource 
public interface ReviewerRepository extends  
  PagingAndSortingRepository&lt;Reviewer, Long&gt; { 
} </pre>
<ol start="4">
<li>Start the application by running <kbd>./gradlew clean bootRun</kbd></li>
<li>After the application has started, open the browser and go to <kbd>http://localhost:8080/authors</kbd> and you should see the following response:
<div class="packt_figure CDPAlignCenter CDPAlign"><a><img src="assets/71ab0b14-d267-43a9-a664-393a315e3ff5.png"/><br/></a></div>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As is evidenced from the browser view, we will get significantly more information than we got when we wrote the books controller. This is in part due to us extending not a <kbd>CrudRepository</kbd> interface, but a <kbd>PagingAndSortingRepository</kbd> one, which in turn is an extension of <kbd>CrudRepository</kbd>. The reason that we've decided to do this is to get the extra benefits provided by <kbd>PagingAndSortingRepository</kbd>. This will add the extra functionality to retrieve entities using the pagination and being able to sort them.</p>
<p>The <kbd>@RepositoryRestResource</kbd> annotation, while optional, provides us with the ability to have finer control over the exposure of the repository as a web data service. For example, if we wanted to change the URL <kbd>path</kbd> or <kbd>rel</kbd> value, to <kbd>writers</kbd> instead of <kbd>authors</kbd>, we could have tuned the annotation as follows:</p>
<pre>@RepositoryRestResource(collectionResourceRel = "writers", path = "writers") </pre>
<p>As we included <kbd>spring-boot-starter-data-rest</kbd> in our build dependencies, we will also get the <kbd>spring-hateoas</kbd> library support, which gives us nice ALPS metadata, such as a <kbd>_links</kbd> object. This can be very helpful when building an API-driven UI, which can deduce the navigational capabilities from the metadata and present them appropriately.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring custom servlet filters</h1>
                </header>
            
            <article>
                
<p>In a real-world web application, we almost always find a need to add facades or wrappers to service requests, to log them, filter out bad characters for XSS, perform authentication, and so on. Out of the box, Spring Boot automatically adds <kbd>OrderedCharacterEncodingFilter</kbd> and <kbd>HiddenHttpMethodFilter</kbd>, but we can always add more. Let's see how Spring Boot helps us achieve this task.</p>
<p>Among the various assortments of Spring Boot, Spring Web, Spring MVC, and others, there is already a vast variety of different servlet filters that are available and all we have to do is define them as beans in the configuration. Let's say that our application will be running behind a load balancer proxy and we would like to translate the real request IP that is used by the users instead of the IP from the proxy when our application instance receives the request. Luckily, Apache Tomcat 8 already provides us with an implementation: <kbd>RemoteIpFilter</kbd>. All we will need to do is add it to our filter chain.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>It is a good idea to separate and group the configurations into different classes in order to provide more clarity about what kind of things are being configured. So, let's create a separate configuration class called <kbd>WebConfiguration</kbd> in the <kbd>src/main/java/com/example/bookpub</kbd> directory from the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">@Configuration 
public class WebConfiguration { 
    @Bean 
    public RemoteIpFilter remoteIpFilter() { 
        return new RemoteIpFilter(); 
    } 
} </pre>
<ol start="2">
<li>Start the application by running <kbd>./gradlew clean bootRun</kbd>.</li>
<li>In the startup log, we should see the following line, indicating that our filter has been added:</li>
</ol>
<pre style="padding-left: 60px">...FilterRegistrationBean : Mapping filter: 'remoteIpFilter' to: [/*]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The magic behind this functionality is actually very simple. Let's start from the separate configuration class and work our way to the filter bean detection.</p>
<p>If we look in our main class, <kbd>BookPubApplication</kbd>, we will see that it is annotated with <kbd>@SpringBootApplication</kbd>, which in turn is a convenience meta-annotation that declares <kbd>@ComponentScan</kbd> among others. We discussed this in detail in one of our earlier recipes. The presence of <kbd>@ComponentScan</kbd> instructs Spring Boot to detect <kbd>WebConfiguration</kbd> as a <kbd>@Configuration</kbd> class and add its definitions to the context. So, anything that we will declare in <kbd>WebConfiguration</kbd> is as good as if we were to put it right in <kbd>BookPubApplication</kbd> itself.</p>
<p>The <kbd>@BeanpublicRemoteIpFilterremoteIpFilter() {...}</kbd> declaration simply creates a Spring bean for the <kbd>RemoteIpFilter</kbd> class. When Spring Boot detects all the beans of <kbd>javax.servlet.Filter</kbd>, it will add them to the filter chain automatically. So, all we have to do, if we want to add more filters, is to just declare them as <kbd>@Bean</kbd> configurations. For example, for a more advanced filter configuration, if we want a particular filter to apply only to specific URL patterns, we can create a <kbd>@Bean</kbd> configuration of a <kbd>FilterRegistrationBean</kbd> type and use it to configure the precise settings.</p>
<div class="packt_tip">To make supporting this use-case easier Spring Boot provides us with configuration properties that can be used instead of manually configuring the <kbd>RemoteIpFilter</kbd> bean for occasions when Tomcat servlet container is being used. Use <kbd>server.use-forward-headers=true</kbd> to indicate to Spring Boot that it needs to automatically configure support for proxy headers, to provide proper request obfuscation. Specifically for Tomcat, one can also use <kbd>server.tomcat.remote_ip_header=x-forwarded-for</kbd> and <kbd>server.tomcat.protocol_header=x-forwarded-proto</kbd> properties to configure what specific header names should be used to retrieve the values.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring custom interceptors</h1>
                </header>
            
            <article>
                
<p>While servlet filters are a part of the Servlet API and have nothing to do with Spring besides being automatically added in the filter chain --Spring MVC provides us with another way of wrapping web requests: <kbd>HandlerInterceptor</kbd>. According to the documentation, <kbd>HandlerInterceptor</kbd> is just like a filter. Instead of wrapping a request in a nested chain, an interceptor gives us cutaway points at different phases, such as before the request gets handled, after the request has been processed, before the view has been rendered, and at the very end, after the request has been fully completed. It does not let us change anything about the request, but it does let us stop the execution by throwing an exception or returning false if the interceptor logic determines so.</p>
<p>Similar to using filters, Spring MVC comes with a number of premade <kbd>HandlerInterceptors</kbd>. The commonly used ones are <kbd>LocaleChangeInterceptor</kbd> and <kbd>ThemeChangeInterceptor</kbd>; but there are certainly others that provide great value. So let's add <kbd>LocaleChangeInterceptor</kbd> to our application in order to see how it is done.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Despite what you might think, after seeing the previous recipe, adding an interceptor is not as straightforward as just declaring it as a bean. We actually need to do it via <kbd>WebMvcConfigurer</kbd> or by overriding <kbd>WebMvcConfigurationSupport</kbd>. Let's take a look at the following steps:</p>
<ol>
<li>Let's enhance our <kbd>WebConfiguration</kbd> class to implement <kbd>WebMvcConfigurer</kbd>:</li>
</ol>
<pre style="padding-left: 60px">public class WebConfiguration implements WebMvcConfigurer {...} </pre>
<ol start="2">
<li>Now we will add a <kbd>@Bean</kbd> declaration for <kbd>LocaleChangeInterceptor</kbd>:</li>
</ol>
<pre style="padding-left: 60px">@Bean 
public LocaleChangeInterceptor localeChangeInterceptor() { 
  return new LocaleChangeInterceptor(); 
} </pre>
<ol start="3">
<li>This will actually create the interceptor Spring bean, but will not add it to the request handling chain. For this to happen, we will need to override the <kbd>addInterceptors</kbd> method and add our interceptor to the provided registry:</li>
</ol>
<pre style="padding-left: 60px">@Override 
public void addInterceptors(InterceptorRegistry registry) { 
  registry.addInterceptor(localeChangeInterceptor()); 
} </pre>
<ol start="4">
<li>Start the application by running <kbd>./gradlew clean bootRun</kbd></li>
<li>In the browser, go to <kbd>http://localhost:8080/books?locale=foo</kbd></li>
<li>Now, if you look at the console logs, you will see a bunch of stack trace errors basically saying the following:</li>
</ol>
<pre style="padding-left: 60px">Caused by: java.lang.UnsupportedOperationException: Cannot change HTTP accept header - use a different locale resolution strategy</pre>
<div class="mce-root packt_infobox">While the error is not because we entered an invalid locale, but because the default locale resolution strategy does not allow the resetting of the locale that is requested by the browser, the fact that we got an error shows that our interceptor is working.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When it comes to configuring the Spring MVC internals, it is not as simple as just defining a bunch of beans at least not always. This is due to the need to provide a more fine-tuned mapping of the MVC components to requests. To make things easier, Spring provides us with a collection of default methods in <kbd>WebMvcConfigurer</kbd> interface that we can extend and override the settings of that we need.</p>
<p>In the particular case of configuring interceptors, we are overriding the <kbd>addInterceptors(InterceptorRegistry registry)</kbd> method. This is a typical callback method where we are given a registry in order to register as many additional interceptors as we need. During the MVC autoconfiguration phase, Spring Boot, just like in the case of filters, detects instances of <kbd>WebMvcConfigurer</kbd> and sequentially calls the callback methods on all of them. It means that we can have more than one implementation of the <kbd>WebMvcConfigurer</kbd> class if we want to have some logical separation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring custom HttpMessageConverters</h1>
                </header>
            
            <article>
                
<p>While we were building our RESTful web data service, we defined the controllers, repositories, and put some annotations on them; but nowhere did we do any kind of object translation from the Java entity beans to the HTTP data stream output. However, behind the scenes, Spring Boot automatically configured <kbd>HttpMessageConverters</kbd> so as to translate our entity beans into a JSON representation written to HTTP response using the <kbd>Jackson</kbd> library. When multiple converters are available, the most applicable one gets selected based on the message object class and the requested content type.</p>
<p>The purpose of <kbd>HttpMessageConverters</kbd> is to translate various object types into their corresponding HTTP output formats. A converter can either support a range of multiple data types or multiple output formats, or a combination of both. For example, <kbd>MappingJackson2HttpMessageConverter</kbd> can translate any Java object into <kbd>application/json</kbd>, whereas <kbd>ProtobufHttpMessageConverter</kbd> can only operate on instances of <kbd>com.google.protobuf.Message</kbd> but can write them to the wire as <kbd>application/json</kbd>, <kbd>application/xml</kbd>, <kbd>text/plain</kbd>, or <kbd>application/x-protobuf</kbd>. <kbd>HttpMessageConverters</kbd> support not only writing out to the HTTP stream but also converting HTTP requests to appropriate Java objects as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>There are a number of ways in which we can configure converters. It all depends on which one you prefer or how much control you want to achieve.</p>
<ol>
<li>Let's add <kbd>ByteArrayHttpMessageConverter</kbd> as <kbd>@Bean</kbd> to our <kbd>WebConfiguration</kbd> class in the following manner:</li>
</ol>
<pre style="padding-left: 60px">@Bean 
public  
  ByteArrayHttpMessageConverter  
    byteArrayHttpMessageConverter() { 
  return new ByteArrayHttpMessageConverter(); 
} </pre>
<ol start="2">
<li>Another way to achieve this is to override the <kbd>configureMessageConverters</kbd> method in the <kbd>WebConfiguration</kbd> class, which extends <kbd>WebMvcConfigurerAdapter</kbd>, defining such a method as follows:</li>
</ol>
<pre style="padding-left: 60px">@Override 
public void configureMessageConverters<br/>            (List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { 
  converters.add(new ByteArrayHttpMessageConverter()); 
}</pre>
<ol start="3">
<li>If you want to have a bit more control, we can override the <kbd>extendMessageConverters</kbd> method in the following way:</li>
</ol>
<pre style="padding-left: 60px">@Override 
public void extendMessageConverters<br/>            (List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { 
  converters.clear(); 
  converters.add(new ByteArrayHttpMessageConverter()); 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As you can see, Spring gives us multiple ways of achieving the same thing and it all depends on our preference or particular details of the implementation.</p>
<p>We covered three different ways of adding <kbd>HttpMessageConverter</kbd> to our application. So what is the difference, one might ask?</p>
<p>Declaring <kbd>HttpMessageConverter</kbd> as <kbd>@Bean</kbd> is the quickest and simplest way of adding a custom converter to the application. It is similar to how we added servlet filters in an earlier example. If Spring detects a bean of the <kbd>HttpMessageConverter</kbd> type, it will add it to the list automatically. If we did not have a <kbd>WebConfiguration</kbd> class that implements <kbd>WebMvcConfigurer</kbd>, it would have been the preferred approach.</p>
<p>When the application needs to define a more precise control over the settings, like interceptors, mappings, etc, it is best to use <kbd>WebMvcConfigurer</kbd> implementation to configure those, as it would be more consistent to override the <kbd>configureMessageConverters</kbd> method and add our converter to the list. As there can be multiple instances of <kbd>WebMvcConfigurers</kbd>, which could be either added by us or via the auto-configuration settings from various Spring Boot starters, there is no guarantee that our method can get called in any particular order.</p>
<p>If we need to do something even more drastic such as removing all the other converters from the list or clearing it of duplicate converters, this is where overriding <kbd>extendMessageConverters</kbd> comes into play. This method gets invoked after all the <kbd>WebMvcConfigurers</kbd> get called for <kbd>configureMessageConverters</kbd> and the list of converters is fully populated. Of course, it is entirely possible that some other instance of <kbd>WebMvcConfigurer</kbd> could override <kbd>extendMessageConverters</kbd> as well; but the chances of this are very low so you have a high degree of having the desired impact.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring custom PropertyEditors</h1>
                </header>
            
            <article>
                
<p>In the previous example, we learned how to configure converters for an HTTP request and response data. There are other kinds of conversions that take place, especially in regards to dynamically converting parameters to various objects, such as Strings to Date or an Integer.</p>
<p>When we declare a mapping method in a controller, Spring allows us to freely define the method signature with the exact object types that we require. The way in which this is achieved is via the use of the <kbd>PropertyEditor</kbd> implementations. <kbd>PropertyEditor</kbd> is a default concept defined as part of the JDK and designed to allow the transformation of a textual value to a given type. It was initially intended to be used to build Java Swing / <strong>Abstract Window Toolkit</strong> (<strong>AWT</strong>) GUI and later proved to be a good fit for Spring's need to convert web parameters to method argument types.</p>
<p>Spring MVC already provides you with a lot of <kbd>PropertyEditor</kbd> implementations for most of the common types, such as Boolean, Currency, and Class. Let's say that we want to create a proper <kbd>Isbn</kbd> class object and use this in our controller instead of a plain String.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>First, we will need to remove the <kbd>extendMessageConverters</kbd> method from our <kbd>WebConfiguration</kbd> class as the <kbd>converters.clear()</kbd> call will break the rendering because we removed all of the supported type converters</li>
<li>Let's create a new package called <kbd>model</kbd> under the <kbd>src/main/java/com/example/bookpub</kbd> directory from the root of our project</li>
<li>Next we create a class named <kbd>Isbn</kbd> under our newly created package directory from the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">package com.example.bookpub.model; 
 
import org.springframework.util.Assert; 
 
public class Isbn { 
    private String eanPrefix; 
    private String registrationGroup; 
    private String registrant; 
    private String publication; 
    private String checkDigit; 
 
    public Isbn(String eanPrefix, String registrationGroup, 
                String registrant, String publication,  
                String checkDigit) { 
 
        this.eanPrefix = eanPrefix; 
        this.registrationGroup = registrationGroup; 
        this.registrant = registrant; 
        this.publication = publication; 
        this.checkDigit = checkDigit; 
    } 
 
    public String getEanPrefix() { 
        return eanPrefix; 
    } 
 
    public void setEanPrefix(String eanPrefix) { 
        this.eanPrefix = eanPrefix; 
    } 
 
    public String getRegistrationGroup() { 
        return registrationGroup; 
    } 
 
    public void setRegistrationGroup<br/>                (String registrationGroup)  { 
        this.registrationGroup = registrationGroup; 
    } 
 
    public String getRegistrant() { 
        return registrant; 
    } 
 
    public void setRegistrant(String registrant) { 
        this.registrant = registrant; 
    } 
 
    public String getPublication() { 
        return publication; 
    } 
 
    public void setPublication(String publication) { 
        this.publication = publication; 
    } 
 
    public String getCheckDigit() { 
        return checkDigit; 
    } 
 
    public void setCheckDigit(String checkDigit) { 
        this.checkDigit = checkDigit; 
    } 
 
    public static Isbn parseFrom(String isbn) { 
        Assert.notNull(isbn); 
        String[] parts = isbn.split("-"); 
        Assert.state(parts.length == 5); 
        Assert.noNullElements(parts); 
        return new Isbn(parts[0], parts[1], parts[2],  
            parts[3], parts[4]); 
    } 
 
    @Override<br/>    public String toString() {<br/>        return eanPrefix + '-'<br/>            + registrationGroup + '-'<br/>            + registrant + '-'<br/>            + publication + '-'<br/>            + checkDigit;<br/>     } 
} </pre>
<ol start="4">
<li>Let's create a new package called <kbd>editors</kbd> under the <kbd>src/main/java/com/example/bookpub</kbd> directory from the root of our project</li>
<li>Let's create a class named <kbd>IsbnEditor</kbd> under our newly created package directory from the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">package com.example.bookpub.editors;<br/><br/>import org.springframework.util.StringUtils;<br/>import com.example.bookpub.model.Isbn;<br/><br/>import java.beans.PropertyEditorSupport;<br/><br/>public class IsbnEditor extends PropertyEditorSupport {<br/>    @Override<br/>    public void setAsText(String text) {<br/>        if (text == null) {<br/>            setValue(null);<br/>        }<br/>        else {<br/>            String value = text.trim();<br/>            if (!StringUtils.isEmpty(value)) {<br/>                setValue(Isbn.parseFrom(value));<br/>            } else {<br/>                setValue(null);<br/>            }<br/>        }<br/>    }<br/><br/>    @Override<br/>    public String getAsText() {<br/>        Object value = getValue();<br/>        return (value != null ? value.toString() : "");<br/>    }<br/>}</pre>
<ol start="6">
<li>Next, we will add a method, <kbd>initBinder</kbd>, to <kbd>BookController</kbd> where we will configure the <kbd>IsbnEditor</kbd> method with the following content:</li>
</ol>
<pre style="padding-left: 60px">@InitBinder 
public void initBinder(WebDataBinder binder) { 
  binder.registerCustomEditor(Isbn.class, new  
    IsbnEditor()); 
} </pre>
<ol start="7">
<li>Our <kbd>getBook</kbd> method in <kbd>BookController</kbd> will also change in order to accept the <kbd>Isbn</kbd> object, in the following way:</li>
</ol>
<pre style="padding-left: 60px">@RequestMapping(value = "/{isbn}", method =  
  RequestMethod.GET) 
public Book getBook(@PathVariable Isbn isbn) {  <br/>    return bookRepository.findBookByIsbn(isbn.toString()); 
} </pre>
<ol start="8">
<li>Start the application by running <kbd>./gradlew clean bootRun</kbd></li>
<li>In the browser, go to <kbd>http://localhost:8080/books/978-1-78528-415-1</kbd></li>
<li>While we will not observe any visible changes,  <kbd>IsbnEditor</kbd> is indeed at work, creating an instance of an <kbd>Isbn</kbd> class object from the <kbd>{isbn}</kbd> parameter</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Spring automatically configures a large number of default editors; but for custom types, we have to explicitly instantiate new editors for every web request. This is done in the controller in a method that is annotated with <kbd>@InitBinder</kbd>. This annotation is scanned and all the detected methods should have a signature of accepting <kbd>WebDataBinder</kbd> as an argument. Among other things, <kbd>WebDataBinder</kbd> provides us with an ability to register as many custom editors as we require for the controller methods to be bound properly.</p>
<div class="packt_infobox">It is very important to know that <kbd>PropertyEditor</kbd> is not thread-safe! For this reason, we have to create a new instance of our custom editors for every web request and register them with <kbd>WebDataBinder</kbd>.</div>
<p>In case a new <kbd>PropertyEditor</kbd> is needed, it is best to create one by extending <kbd>PropertyEditorSupport</kbd> and overriding the desired methods with custom implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring custom type formatters</h1>
                </header>
            
            <article>
                
<p>Mostly because of its statefulness and lack of thread safety, since version 3, Spring has added a <kbd>Formatter</kbd> interface as a replacement for <kbd>PropertyEditor</kbd>. The formatters are intended to provide a similar functionality but in a completely thread-safe manner and focusing on a very specific task of parsing a String in an object type and converting an object to its String representation.</p>
<p>Let's suppose that for our application, we would like to have a formatter that would take the ISBN number of a book in a String form and convert it to a book entity object. This way, we can define the controller request methods with a <kbd>Book</kbd> argument when the request URL signature only contains an ISBN number or a database ID.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>First, let's create a new package called <kbd>formatters</kbd> in the <kbd>src/main/java/com/example/bookpub</kbd> directory from the root of our project</li>
<li>Next, we will create the <kbd>Formatter</kbd> implementation called <kbd>BookFormatter</kbd> in our newly created package directory from the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">public class BookFormatter implements Formatter&lt;Book&gt; { 
  private BookRepository repository; 
  public BookFormatter(BookRepository repository) { 
    this.repository= repository; 
  } 
  @Override 
  public Book parse(String bookIdentifier, Locale locale) <br/>       throws ParseException {      <br/>    Book book = repository.findBookByIsbn(bookIdentifier);      <br/>    return book != null ? book : <br/>         repository.findById(Long.valueOf(bookIdentifier))<br/>           .get(); 
    } 
  @Override 
  public String print(Book book, Locale locale) { 
    return book.getIsbn(); 
  } 
} </pre>
<ol start="3">
<li>Now that we have our formatter, we will add it to the registry by overriding an <kbd>addFormatters(FormatterRegistry registry)</kbd> method in the <kbd>WebConfiguration</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">@Autowired  
private BookRepository bookRepository; 
@Override 
public void addFormatters(FormatterRegistry registry) { 
  registry.addFormatter(new BookFormatter(bookRepository)); 
} </pre>
<ol start="4">
<li>Finally, let's add a new request method to our <kbd>BookController</kbd> class located in the <kbd>src/main/java/com/example/bookpub/controllers</kbd> directory from the root of our project that will display the reviewers for a given ISBN of a book:</li>
</ol>
<pre style="padding-left: 60px">@RequestMapping(value = "/{isbn}/reviewers", method = <br/>    RequestMethod.GET)<br/>public List&lt;Reviewer&gt; getReviewers(@PathVariable("isbn") <br/>    Book book) { 
  return book.getReviewers(); 
}</pre>
<ol start="5">
<li>Just so we can have some data to play with, let's manually (for now) populate our database with some test data by adding two more autowired repositories to the <kbd>StartupRunner</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">@Autowired 
private AuthorRepository authorRepository; 
@Autowired 
private PublisherRepository publisherRepository; </pre>
<ol start="6">
<li>The following code snippet is destined for the <kbd>run(...)</kbd> method of <kbd>StartupRunner</kbd>:</li>
</ol>
<pre style="padding-left: 60px">Author author = new Author("Alex", "Antonov"); 
author = authorRepository.save(author); 
Publisher publisher = new Publisher("Packt"); 
publisher = publisherRepository.save(publisher); 
Book book = new Book("978-1-78528-415-1",  
    "Spring Boot Recipes", author, publisher); 
bookRepository.save(book); </pre>
<ol start="7">
<li>Start the application by running <kbd>./gradlew clean bootRun</kbd></li>
<li>Let's open <kbd>http://localhost:8080/books/978-1-78528-415-1/reviewers</kbd> in the browser and you should be able to see the following results:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/1e5987be-68ce-4e93-b772-67b5b6403036.png"/></div>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The formatter facility is aims to provide a similar functionality to <kbd>PropertyEditors</kbd>. By registering our formatter with <kbd>FormatterRegistry</kbd> in the overridden <kbd>addFormatters</kbd> method, we are instructing Spring to use our formatter to translate a textual representation of our book into an entity object and back. As formatters are stateless, we don't need to do the registration in our controller for every call; we have to do it only once and this will ensure Spring uses it for every web request.</p>
<div class="packt_tip">It is also good to remember that if you want to define a conversion of a common type, such as String or Boolean, for example trimming text, it is best to do this via <kbd>PropertyEditors</kbd> in controller's <kbd>InitBinder</kbd> because such a change is probably not globally desired and is only needed for a particular functionality.</div>
<p>You have probably noticed that we also autowired <kbd>BookRepository</kbd> to a <kbd>WebConfiguration</kbd> class, as this was needed to create <kbd>BookFormatter</kbd>. This is one of the cool parts about Spring --it lets us combine the configuration classes and make them dependent on the other beans at the same time. As we indicated that in order for a <kbd>WebConfiguration</kbd> class to be created we need <kbd>BookRepository</kbd>, Spring ensured that <kbd>BookRepository</kbd> will be created first and then automatically injected as a dependency during the creation of the <kbd>WebConfiguration</kbd> class. After <kbd>WebConfiguration</kbd> is instantiated, it is processed for configuration instructions.</p>
<p>The rest of the added functionalities should already be familiar as we covered them in our previous recipes. We will explore how to automatically populate databases with schemas and data in <a href="1136c424-e79e-467a-8f7f-8af2099306d7.xhtml"><span class="ChapterrefPACKT">Chapter 5</span></a>, <em>Application Testing</em>, in detail, where we will also talk about application testing.</p>


            </article>

            
        </section>
    </body></html>