- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling Behavior with Ports and Use Cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have defined the business rules in the Domain hexagon, we can start
    thinking about ways to use those rules to create software features while considering
    how the system will handle the data coming from users and other applications.
    Ports and use cases address such concerns in the hexagonal architecture, where
    we need to orchestrate system data and business rules to provide useful software
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore how to employ use cases to define the behaviors
    supported by the software. Through the integration of input and output ports with
    use cases, we’ll understand the role of such ports in establishing the communication
    flow within the hexagonal system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Expressing software behavior with use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing use cases with input ports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using output ports to deal with external data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating behavior with the Application hexagon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “By the end of this chapter, you’ll be able to employ ports and use cases to
    coordinate all the things a hexagonal system must do to fulfill user requirements.”
    Once you have grasped the fundamentals of ports and use cases, it will be possible
    to utilize them to combine elements from both the Domain and Application hexagons
    to construct powerful features.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile and run the code examples presented in this chapter, you will need
    the latest **Java SE Development Kit** and **Maven 3.8** installed on your computer.
    They are both available for the Linux, Mac, and Windows operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Designing-Hexagonal-Architecture-with-Java/tree/main/Chapter03](https://github.com/PacktPublishing/Designing-Hexagonal-Architecture-with-Java/tree/main/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Expressing software behavior with use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **software system** is nothing more than a set of behaviors working together
    to achieve the goals defined by users or even other software systems. A software
    behavior, in turn, is a worthy action that, alone or combined with other software
    actions, contributes to realizing a worthy software goal. Such goals are intimately
    connected to the desires expressed by interested users or systems.
  prefs: []
  type: TYPE_NORMAL
- en: We can classify those interested folks as stakeholders or actors from which
    we will ultimately derive the real-world needs that will be transmuted into goals.
    These actors' goals will be fulfilled by the **System under Discussion** (**SuD**),
    or simply the software you are developing.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the hexagonal architecture’s standpoint, we can relate these actors to
    what we saw in [*Chapter 1*](B19777_01.xhtml#_idTextAnchor014), *Why Hexagonal
    Architecture?*, when discussing driver and driven operations. In the same vein,
    we can classify the SuD actors: the **driver actor** is a person or system that
    triggers one of the SuD behaviors, while the **driven actor** is an external system
    consumed by the SuD.'
  prefs: []
  type: TYPE_NORMAL
- en: To express what a system does in both functional and non-functional terms, people
    such as Ivar Jacobson and Alistair Cockburn and the Agile community, in general,
    have contributed to developing useful techniques to transform business requirements
    into meaningful written descriptions of how a system should behave. Among those
    techniques, one that stands out is that of use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the UML, which depicts a high-level view of the system through the relationship
    between diagrams, use cases perform a deeper dive by providing a detailed written
    description of SuD behaviors. **Use cases** are a valuable technique to set SuD
    goals, the means or behaviors to fulfill them, the possible failure scenarios,
    and what to do when they occur. When combined with DDD techniques, use cases are
    instrumental in bridging the gap of dealing with application-specific activities
    that mean more to the SuD – and the Application hexagon – than to the problem
    domain and its business rules in the Domain hexagon. By thinking in terms of use
    cases, we are making a significant step to improve the separation of concerns
    in the hexagonal architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We can create use cases by simply writing a description about them, but it’s
    also possible to express them through code. Next, we’ll learn how to create use
    cases both in written and code form.
  prefs: []
  type: TYPE_NORMAL
- en: How to create a use case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are elaborate approaches to creating written use cases where you may
    specify detailed and standardized information about the input data, possible behaviors,
    and use case results. Cockburn classifies those detailed use cases as fully dressed
    ones. Fully dressed use cases may be helpful in new teams, where people are not
    used to working together. The standards enforced by the fully dressed approach
    help provide a clear path about how a use case should be built. It helps prevent
    situations where a person may consider certain use case aspects that are not present
    in use cases written by another person. An example of a fully dressed use case
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Actor**: Infrastructure engineer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Goal**: To add a new network to an edge router'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scope**: Infrastructure department'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trigger**: A particular reason to segregate network access through a different
    network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input data**: Router ID, network name, address, and CIDR'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look up the router ID.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate that the network address doesn’t already exist.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate that the CIDR is not below the minimum allowed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the previous validations are okay, add the network to the informed router.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On the opposite side, we have the less formal and casual types of use cases.
    The main characteristic of casual use cases is that they don’t follow standards
    about how the information should be recorded. They try to convey as much meaning
    as possible in one or two paragraphs, as mentioned in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: The infrastructure engineer sends a request to the application containing the
    router ID, network name, address, and CIDR. The application performs a lookup
    in the router ID, then validates that the network does not already exist, followed
    by another validation to confirm that the CIDR value is not below the minimum
    allowed. If all the validations are okay, then the system proceeds to add the
    network to the informed router.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the formal and casual written techniques, it’s possible to express
    user intent directly in the code through automated tests. That approach relies
    on **behavior-driven design** (**BDD**) principles related to discovery, formulation,
    and automation. In such an approach, you start talking with business people trying
    to discover what they need. The output of this discovery process contains examples
    of situations and behaviors depicting the business need. Then, you move on to
    the formulation phase, where structured documentation is created based on those
    examples. Finally, the automation phase is where tests are created and executed
    to validate those behaviors from examples described and structured in previous
    phases.
  prefs: []
  type: TYPE_NORMAL
- en: When employing BDD earlier in software development, we have the opportunity
    to create use cases iteratively based on examples and tests created to validate
    business ideas.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the aid of tools such as Cucumber, we can adopt the BDD approach in our
    hexagonal application. To convert the written use cases we built previously, we
    need to create a Cucumber feature file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: public class AddNetworkStepsTest {
  prefs: []
  type: TYPE_NORMAL
- en: private RouterId routerId;
  prefs: []
  type: TYPE_NORMAL
- en: private Router router;
  prefs: []
  type: TYPE_NORMAL
- en: private RouterNetworkFileAdapter routerNetworkFileAdapter
  prefs: []
  type: TYPE_NORMAL
- en: = RouterNetworkFileAdapter.getInstance();
  prefs: []
  type: TYPE_NORMAL
- en: Network network = new Network(new IP("20.0.0.0"),
  prefs: []
  type: TYPE_NORMAL
- en: '"Marketing", 8);'
  prefs: []
  type: TYPE_NORMAL
- en: /** Code omitted **/
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '@Given("I provide a router ID and the network details")'
  prefs: []
  type: TYPE_NORMAL
- en: public void obtain_routerId() {
  prefs: []
  type: TYPE_NORMAL
- en: this.routerId = RouterId.withId(
  prefs: []
  type: TYPE_NORMAL
- en: '"ca23800e-9b5a-11eb-a8b3-0242ac130003");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '@When("I found the router")'
  prefs: []
  type: TYPE_NORMAL
- en: public void lookup_router() {
  prefs: []
  type: TYPE_NORMAL
- en: router =
  prefs: []
  type: TYPE_NORMAL
- en: routerNetworkFileAdapter.fetchRouterById(routerId);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '@And('
  prefs: []
  type: TYPE_NORMAL
- en: '"The network address is valid and doesn''t already exist")'
  prefs: []
  type: TYPE_NORMAL
- en: public void check_address_validity_and_existence() {
  prefs: []
  type: TYPE_NORMAL
- en: var availabilitySpec =
  prefs: []
  type: TYPE_NORMAL
- en: new NetworkAvailabilitySpecification(
  prefs: []
  type: TYPE_NORMAL
- en: network.getAddress(), network.getName(),
  prefs: []
  type: TYPE_NORMAL
- en: network.getCidr());
  prefs: []
  type: TYPE_NORMAL
- en: if(!availabilitySpec.isSatisfiedBy(router))
  prefs: []
  type: TYPE_NORMAL
- en: throw new IllegalArgumentException("Address already
  prefs: []
  type: TYPE_NORMAL
- en: exist");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '@Given("The CIDR is valid")'
  prefs: []
  type: TYPE_NORMAL
- en: public void check_cidr() {
  prefs: []
  type: TYPE_NORMAL
- en: var cidrSpec = new CIDRSpecification();
  prefs: []
  type: TYPE_NORMAL
- en: if(cidrSpec.isSatisfiedBy(network.getCidr()))
  prefs: []
  type: TYPE_NORMAL
- en: throw new IllegalArgumentException(
  prefs: []
  type: TYPE_NORMAL
- en: '"CIDR is below"+CIDRSpecification.'
  prefs: []
  type: TYPE_NORMAL
- en: MINIMUM_ALLOWED_CIDR);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '@Then("Add the network to the router")'
  prefs: []
  type: TYPE_NORMAL
- en: public void add_network() {
  prefs: []
  type: TYPE_NORMAL
- en: router.addNetworkToSwitch(network);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: public interface RouterNetworkUseCase {
  prefs: []
  type: TYPE_NORMAL
- en: Router addNetworkToRouter(RouterId routerId, Network
  prefs: []
  type: TYPE_NORMAL
- en: network);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: public class RouterNetworkInputPort implements RouterNet
  prefs: []
  type: TYPE_NORMAL
- en: workUseCase {
  prefs: []
  type: TYPE_NORMAL
- en: private final RouterNetworkOutputPort
  prefs: []
  type: TYPE_NORMAL
- en: routerNetworkOutputPort;
  prefs: []
  type: TYPE_NORMAL
- en: public RouterNetworkInputPort(RouterNetworkOutputPort
  prefs: []
  type: TYPE_NORMAL
- en: routerNetworkOutputPort){
  prefs: []
  type: TYPE_NORMAL
- en: this.routerNetworkOutputPort =
  prefs: []
  type: TYPE_NORMAL
- en: routerNetworkOutputPort;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public Router addNetworkToRouter(RouterId routerId, Network
  prefs: []
  type: TYPE_NORMAL
- en: network) {
  prefs: []
  type: TYPE_NORMAL
- en: var router = fetchRouter(routerId);
  prefs: []
  type: TYPE_NORMAL
- en: return createNetwork(router, network);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: private Router fetchRouter(RouterId routerId) {
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: routerNetworkOutputPort.fetchRouterById(routerId);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: private Router createNetwork(Router router, Network net
  prefs: []
  type: TYPE_NORMAL
- en: work) {
  prefs: []
  type: TYPE_NORMAL
- en: var newRouter =
  prefs: []
  type: TYPE_NORMAL
- en: NetworkOperation.createNewNetwork(router, network);
  prefs: []
  type: TYPE_NORMAL
- en: 'return persistNetwork(router) ? newRouter : router;'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: private boolean persistNetwork(Router router) {
  prefs: []
  type: TYPE_NORMAL
- en: return routerNetworkOutputPort.persistRouter(router);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: public interface RouterNetworkOutputPort {
  prefs: []
  type: TYPE_NORMAL
- en: Router fetchRouterById(RouterId routerId);
  prefs: []
  type: TYPE_NORMAL
- en: boolean persistRouter(Router router);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: public interface PasswordResetTokenRepository extends
  prefs: []
  type: TYPE_NORMAL
- en: JpaRepository<PasswordResetToken, Long> {
  prefs: []
  type: TYPE_NORMAL
- en: PasswordResetToken findByToken(String token);
  prefs: []
  type: TYPE_NORMAL
- en: PasswordResetToken findByUser(User user);
  prefs: []
  type: TYPE_NORMAL
- en: Stream<PasswordResetToken>
  prefs: []
  type: TYPE_NORMAL
- en: findAllByExpiryDateLessThan(Date now);
  prefs: []
  type: TYPE_NORMAL
- en: void deleteByExpiryDateLessThan(Date now);
  prefs: []
  type: TYPE_NORMAL
- en: '@Modifying'
  prefs: []
  type: TYPE_NORMAL
- en: '@Query(«delete from PasswordResetToken t where'
  prefs: []
  type: TYPE_NORMAL
- en: t.expiryDate <= ?1")
  prefs: []
  type: TYPE_NORMAL
- en: void deleteAllExpiredSince(Date now);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: public interface PasswordResetTokenOutputPort {
  prefs: []
  type: TYPE_NORMAL
- en: PasswordResetToken findByToken(String token);
  prefs: []
  type: TYPE_NORMAL
- en: PasswordResetToken findByUser(User user);
  prefs: []
  type: TYPE_NORMAL
- en: Stream<PasswordResetToken>
  prefs: []
  type: TYPE_NORMAL
- en: findAllByExpiryDateLessThan(Date now);
  prefs: []
  type: TYPE_NORMAL
- en: void deleteByExpiryDateLessThan(Date now);
  prefs: []
  type: TYPE_NORMAL
- en: void deleteAllExpiredSince(Date now);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: public class RouterNetworkInputPort implements RouterNet
  prefs: []
  type: TYPE_NORMAL
- en: workUseCase {
  prefs: []
  type: TYPE_NORMAL
- en: private final RouterNetworkOutputPort
  prefs: []
  type: TYPE_NORMAL
- en: routerNetworkOutputPort;
  prefs: []
  type: TYPE_NORMAL
- en: public RouterNetworkInputPort(RouterNetworkOutputPort
  prefs: []
  type: TYPE_NORMAL
- en: routerNetworkOutputPort){
  prefs: []
  type: TYPE_NORMAL
- en: this.routerNetworkOutputPort =
  prefs: []
  type: TYPE_NORMAL
- en: routerNetworkOutputPort;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: private Router fetchRouter(RouterId routerId) {
  prefs: []
  type: TYPE_NORMAL
- en: return routerNetworkOutputPort.fetchRouterById
  prefs: []
  type: TYPE_NORMAL
- en: (routerId);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: private boolean persistNetwork(Router router) {
  prefs: []
  type: TYPE_NORMAL
- en: return routerNetworkOutputPort.persistRouter
  prefs: []
  type: TYPE_NORMAL
- en: (router);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: public class CreditCard {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /** Code omitted **/
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: double availableCredit;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public boolean
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: isAvailableCreditGreaterOrEqualThan(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: double transactionAmount) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return  availableCredit>=transactionAmount;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public interface CreditCheckUseCase {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: boolean hasEnoughCredit(String cardId, double
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: transactionAmount);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public interface CreditCheckOutputPort {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CreditCard getCreditCard(String cardId);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public class CreditCheckMySQLOutputAdapter implements
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CreditCheckOutputPort {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Override'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public CreditCard getCreditCard(String cardId) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /** Code omitted **/
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return creditCard;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public class CreditCheckInputPort implements
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CreditCheckUseCase {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CreditCheckOutputPort creditCheckOutputPort;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@Override'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public boolean hasEnoughCredit(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: String cardId, double transactionAmount) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: getCreditCard(cardId)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .isAvailableCreditGreaterOrEqualThan
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (transactionAmount);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: private CreditCard getCreditCard(String cardId) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return creditCheckOutputPort
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .getCreditCard(cardId);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
