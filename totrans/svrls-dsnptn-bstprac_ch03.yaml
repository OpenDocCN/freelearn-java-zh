- en: A Three-Tier Web Application Pattern with GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](svrls-dsnptn-bstprac_ch02.html), *A* *Three**-Tier Web Application
    Using REST*,  we walked through the entire process of authoring a REST API on
    top of a serverless system with accompanying hosted services for the data and
    presentation layers. Our serverless logic layer was implemented with AWS Lambda
    and API Gateway, which provide many advantages regarding deployment, iteration
    speed, and scalability. REST APIs are well understood among the web development
    community and a safe choice when building a new web-based API. However, emerging
    tools and protocols are taking shape and providing us with alternatives to REST.
    GraphQL is arguably one of the most popular alternatives to REST APIs lately,
    evidenced by AWS and other platforms releasing hosted GraphQL services. You don't
    need to look very deep to find the uptick in GraphQL's popularity.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll walk through the process of updating the three-tier example
    API to use a GraphQL interface rather than a REST interface. These changes will
    focus on only the logic layer, as the data layer will not change at all. We will
    learn how to set up and author a single GraphQL serverless endpoint as opposed
    to multiple endpoints as in the REST-based design.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look into and discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to author a GraphQL API using AWS Lambda and Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The differences in function layout between GraphQL and REST serverless applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to query our GraphQL endpoint as a client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST has been around for nearly 20 years and remains a popular choice for web
    APIs, both internal and public. As popular as REST is, it does have its flaws
    and is more of an idea as opposed to a specification. Anyone who has designed
    or worked with third-party APIs knows that there is often little overlap in implementation
    and design choices from one API to another. At best, this makes using or designing
    REST APIs challenging. When approaching a new REST API, there is always the work
    of exploring the various API endpoints, hunting for the data you'll need, understanding
    the different resource types and how they relate, and so on. Of course, when working
    with a new API, there will always be some level of investment and discovery to
    learn the data with which you'll be working.
  prefs: []
  type: TYPE_NORMAL
- en: Facebook designed GraphQL internally in 2012 and released it to the public in
    2015\. GraphQL is the new kid on the block and is picking up substantial traction
    as an alternative to REST. While the end goal is the same as REST (to get data
    from a client to the server), the implementation and mechanisms for doing so are
    drastically different. Perhaps most different from REST, GraphQL is an actual
    specification that client and server implementations can reference and agree on.
    In contrast, REST is a set of principles and ideas that are subject to interpretation.
    GraphQL defines a new query language and allows clients to ask for the data they
    need consistently. With REST, the addition, removal, or permutation of return
    values usually requires server-side code changes. With GraphQL, clients are able
    to define the structure of the return payload in an ad hoc fashion on a query-by-query
    basis. For clients, the boundaries in a REST API are the endpoints provided at
    a given point in time and their return values, whereas the limits in a GraphQL
    API are the full domain of the API.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL is a big and complex topic. It's still relatively new, especially when
    comparing it to REST and other web technologies. Because GraphQL digests so many
    of the complexities of a web API, any conversation about GraphQL quickly becomes
    a discussion about the intricacies of GraphQL itself. In this chapter, I attempt
    to give just the right amount of detail on GraphQL to demonstrate the underlying
    serverless pattern. If you find yourself wanting a deeper understanding of GraphQL
    during reading or at the end of this chapter, I encourage you to read the many
    articles and blog posts that exist on this topic. The following introduction from
    Facebook is a great place to start: [https://reactjs.org/blog/2015/05/01/graphql-introduction.html](https://reactjs.org/blog/2015/05/01/graphql-introduction.html).[](https://reactjs.org/blog/2015/05/01/graphql-introduction.html)
  prefs: []
  type: TYPE_NORMAL
- en: In short, clients working with a GraphQL API can fetch precisely the data they
    need, no more, no less. Over-fetching (getting more data than the client needs)
    and under-fetching (needing to make multiple API calls to get the data the client
    needs) issues disappear when working with GraphQL, which arguably was a significant
    driver in Facebook's design of GraphQL and provides many benefits for clients.
    Another exciting and powerful attribute of GraphQL is that it isn't an HTTP-only
    specification. While HTTP is currently the primary use case, GraphQL isn't tied
    directly to HTTP and may be used with other transport protocols.
  prefs: []
  type: TYPE_NORMAL
- en: System architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our system architecture, at a high level, will be the same as in the REST API
    version of our sample application. Requests from the web will hit the CloudFront
    CDN, which is backed by S3\. Our JavaScript code from the served-up HTML files
    will query the serverless API, which itself will communicate with the RDS-backed
    data layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7738859c-3d36-405c-8272-da1f262788bd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Thinking through this application from a top-down approach, the steps in fetching
    data will be the same regardless of how the logic layer is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: End-user requests a website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static assets are served to the user from CloudFront and S3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static assets request data via logic layer/web APIs (GraphQL in this case)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logic layer fetches/writes data from/to Postgres database in the data layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving our example web application from a REST design to GraphQL means focusing
    on the **logic layer**, as the presentation and data layers won't change much,
    if at all. Of course, any changes to our API mean that our presentation layer
    (that is, the client) will need to change; however, as that is not our primary
    area of focus, we won't delve too deeply into the client-side changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find all of the code in this chapter in the following repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/brianz/serverless-design-patterns/tree/master/ch3](https://github.com/brianz/serverless-design-patterns/tree/master/ch3)'
  prefs: []
  type: TYPE_NORMAL
- en: Logic layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GraphQL simplifies life for clients because there is a single HTTP endpoint.
    In some ways, this makes the pattern for a serverless GraphQL API extremely simple
    and in some ways quite dull.
  prefs: []
  type: TYPE_NORMAL
- en: If we were starting this GraphQL web application from scratch, there would be
    plenty of decisions to make and material to cover to make our application code
    modular, easy to test, and well designed. Since we're porting the example REST
    web application, we have already implemented the vast majority of the needed functionality
    and software layers. These sections may seem terser than expected, especially
    if you have skipped [Chapter 2](svrls-dsnptn-bstprac_ch02.html), *A Three-Tier
    Web Application using REST*. Any gaps in code organization or layout, configuration
    strategy, deployments, and so on can be filled by reviewing [Chapter 2](svrls-dsnptn-bstprac_ch02.html),
    *A **Three-Tier Web Application using REST*.
  prefs: []
  type: TYPE_NORMAL
- en: Organization of the Lambda functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'REST APIs are built around resources that each own their own URI, in part to
    give clients a well-known or predictable way to interact. GraphQL takes a different
    approach. Note that the *QL* in GraphQL stands for *query language*. Data-fetching
    logic is moved into the query language itself, rather than being distributed among
    different API endpoints as in the case of REST. Clients no longer need to work
    through the process of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Determining what resource they need and where it lives on the list of URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking up documentation to determine the input parameters and output data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If applicable, reading the documentation on pagination or limiting of returned
    data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A formal specification currently found at [http://facebook.github.io/graphql/October2016/](http://facebook.github.io/graphql/October2016/)
    defines GraphQL in absolute terms. As with any specification, any framework or
    library that aims at providing GraphQL functionality to users must abide by this
    formal contract. Both clients and servers work within the bounds of this specification
    so that there is a single way to handle common bits of functionality. To keep
    these points in context, the logic for this functionality is implemented in a
    single endpoint and hence Lambda function, regardless of the resource or any other
    data being requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows what the move from a REST API to GraphQL looks
    like regarding supported URLs and backing functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fdc3b768-7432-47ac-8f03-d5e3153d9b70.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we saw in  [Chapter 2](svrls-dsnptn-bstprac_ch02.html), *A **Three-Tier Web
    Application using REST*, a REST API in a serverless system is or may be composed
    of a serverless function (AWS Lambda or the like) for one or more API endpoints.
    As the API grows, so too does the number of serverless functions.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL, on the other hand, contains all of the logic for an entire API, including
    creation, reading, and updating of data. It should be clear from the preceding
    diagram that regardless of how a system changes, there are no changes required
    to the serverless functions backing the GraphQL API. Any changes in business logic
    or application logic are wrapped up in application code, in contrast to requiring changes
    in URL structure and hence serverless functions or layout.
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, we will be working on a single AWS Lambda function and HTTP
    endpoint that will handle all GraphQL requests. Do note, however, that GraphQL
    clients may make requests over both `GET` and `POST`, so our Lambda function will
    be set up to handle both request types.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more details on serving GraphQL over HTTP in the official documentation
    at [http://graphql.org/learn/serving-over-http/](http://graphql.org/learn/serving-over-http/).[](http://graphql.org/learn/serving-over-http/)
  prefs: []
  type: TYPE_NORMAL
- en: Organization of the application code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As noted previously, organizing serverless functions and application code is
    not exactly the same thing. With a GraphQL system, our lives as developers are
    slightly more comfortable since there is only a single endpoint to support.  The
    overall organization of application code isn't changing at all from our REST API.
    The only real changes are that there will be much *less* application code to manage,
    but the overall layout, structure, and routing strategy will not change in any
    way. For details, readers may review [Chapter 2](svrls-dsnptn-bstprac_ch02.html),
    *A **Three-Tier Web Application using REST*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other parts of our API that will remain constant in the GraphQL implementation
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration strategy via environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall code structure and layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our GraphQL endpoint will be handled by a single AWS Lambda function, via either
    the `GET` or `POST` HTTP method. For completeness, the diagram of the AWS API
    Gateway request to the AWS Lambda function looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/304a0f02-d5d0-4c95-b8a4-4cfc93ee9171.png)'
  prefs: []
  type: TYPE_IMG
- en: While it may seem a bit pedantic to review this, I think it's important to stress
    the simplicity of this pattern and the advantages gained by adopting GraphQL.
    Of course, there are always trade-offs, and GraphQL is no different. Since so
    much functionality is pushed down into the logic layers, most of your time will
    likely be spent in application code, ensuring your API provides the same functionality
    as before and learning the details of GraphQL itself. Not being a GraphQL expert
    myself, and because GraphQL isn't the main topic of this book, we won't be covering
    all of the possible scenarios and functionality of a GraphQL API.
  prefs: []
  type: TYPE_NORMAL
- en: Presentation layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In  [Chapter 2](https://cdp.packtpub.com/serverless_design_patterns_and_best_practices/wp-admin/post.php?post=50&action=edit#post_27),
    *A* *Three-Tier Web Application using REST*, our React application was making
    API calls to our REST endpoints. This REST API that we built returns JSON, which
    our frontend code easily digests and feeds into our React code for rendering UI
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: With a change to a GraphQL-based API, our frontend code will need to change
    somewhat drastically for the data-fetching sections. GraphQL behaves very differently
    than REST, and there is no corollary between a REST endpoint, which returns a
    known set of data, and GraphQL. Each GraphQL query is unique in that the client
    is responsible for asking for a specific set of data.
  prefs: []
  type: TYPE_NORMAL
- en: We won't review the changes to the frontend code. At the time of writing, popular
    choices for GraphQL for the frontend are Apollo and Relay. Apollo comes out of
    the Meteor Development Group and Facebook is behind Relay. Both are open source
    and popular in the GraphQL community. There are many resources on both topics
    all over the internet and readers are encouraged to learn more on their own. For
    this chapter, we'll interact with our GraphQL backend using an API client.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the logic layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding this GraphQL endpoint will consist of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new entry point to handle the new Lambda function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing the HTTP payload (which is a GraphQL query or mutation) to a function
    that will execute GraphQL code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Admittedly, GraphQL is new enough that libraries and the ecosystem are not entirely
    polished or rich with documentation, at least in my experience. Still, it's possible
    to make quick progress, and once the basics are solved, GraphQL by its nature
    enables a vast range of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Since the coffee cupping example application is implemented using Python, we
    will continue down that path and augment it with some additional libraries for
    GraphQL. At the time of writing, Graphene is the de facto library for working
    with GraphQL from Python. Along with the base library, there are several other
    libraries that make working with various data stores easier. Luckily for us, one
    of the add-on libraries is Graphene-SQLAlchemy, which will work with our own SQLAlchemy
    code.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about Graphene and its related integrations at [http://graphene-python.org](http://graphene-python.org).[](http://graphene-python.org)
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the entry point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the addition of a new Lambda function that will respond to requests at
    the `/graphql` endpoint, we need one new entry in our existing `handler.py` file.
    For consistency with the other handlers in this file, the function will do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract the HTTP method and payload from the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hand the HTTP method and payload to another function for processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Construct and return the final response to API Gateway:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There isn't much to do in this function and one can see that the bulk of the
    logic is in the `handle_graphql` function, which we import at the top of the file
    and that lives in `cupping/handlers/graphql.py`. Using this pattern is extremely
    helpful since all of our path setups has already been completed and other standard
    code, such as the `cors` headers, is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing GraphQL queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the boilerplate out of the way, it's time to focus on our actual GraphQL
    implementation. Many software layers that powered the REST API will also power
    the GraphQL API, specifically the model/validation layer and persistence/SQLAlchemy
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are new to GraphQL, know there are two types of operations, which GraphQL
    treats differently and which require slightly different code, at least when using
    Python and Graphene. Those two actions are queries and mutations, or reads and
    writes, respectively. In this section, we will cover queries. This code provides
    all of the functionality for every query interaction in our example API. Details
    of each part of this code will be discussed in later. The main entry point is
    this handler code is the `handle_graphql` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code implements the same functionality as our REST API's `GET`
    endpoints, getting a listing of all cupping sessions and individual cupping sessions.
    Following on from the top-level `handler.py`, the `handle_graphql` function accepts
    an HTTP method, which isn't even used, along with a JSON-encoded payload from
    the request. From there, it's handed off to a small helper function that decodes
    the JSON payload via a decorator we authored earlier. Some light error handling
    ensures that errors come back in the right format. This function ultimately returns
    a Python dictionary with either errors or the result of the GraphQL execution.
     Ultimately, this dictionary is JSON-encoded and returned to the client, as we
    saw in `handler.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Query` class is the central place where most, if not all, of the functionality,
    will occur for fetching data from our backend. Our API has two main resources,
    `Session` and `Cupping`.  Since we are making this API have functional parity
    with our REST API, two class attributes will give us the ability to respond to
    queries for either `cuppings` or `sessions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Taking `sessions` as an example, we define the `sessions` attribute to be a
    list of GraphQL objects, where each item in the list is a `SessionObject`. Fortunately,
    `SessionObject` is trivial to implement since we can take advantage of Graphene-SQLAlchemy
    and map the Session SQLAlchemy model to a Graphene-compatible object type. In
    reality, we could have performed this entirely on our own, but it would have required
    manually constructing an object that maps SQLAlchemy fields to Graphene fields
    and writing more code. Graphene-SQLAlchemy handles all of this work automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Two additional keyword arguments are passed into `graphene.List`, `id`, and
    `account_id`. Attributes that we want to use to query need to be explicitly defined
    when building `Query` items. The addition of `id` and `account_id` mean the API
    can now accept either or both fields from clients and use them to filter results.
     Do note that we have surpassed the REST API in functionality, albeit only slightly.
    By adding `account_id` as a query field, we've given our API new functionality
    that didn't exist in the REST version.  Also, this GraphQL API can return a list
    of cupping resources, which wasn't possible in the REST API. If you think through
    the steps of adding this functionality to the REST API, we'd need to add a new
    endpoint to return the new cupping resources by themselves and either come up
    with an entirely new API endpoint or shoehorn in some query parameters as `GET`
    arguments to filter `Sessions` by account. While either approach can work, it
    should be clear that this speaks to some of the inconsistencies and areas for
    interpretation with REST APIs. Here, there is one, and only one, way to add query
    parameters to a GraphQL query.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined the return values, there is still the work of actually
    fetching the data. Graphene makes this quite simple by requiring a method prepended
    with `resolve_` in order to fetch whichever resource we've implemented. The preceding
    code for both resolve functions, `resolve_sessions`, and `resolve_cuppings`, makes
    calls to our SQLAlchemy query functions and also passes through any filters that
    arrive via the extra keyword arguments defined on the `graphene.List` attributes
    previously described. Both resolve functions will return lists of SQLAlchemy objects;
    however, because the attributes that are requesting the data are themselves defined
    as  `SQLAlchemyObjectType`, the SQLAlchemy return values are transformed to the
    correct data types to fulfill the GraphQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: A couple of example queries later in this chapter may help solidify the flow
    of data and the code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing GraphQL mutations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After querying comes mutation, which is an operation which writes or otherwise
    transforms data. In our API, we''ll be implementing a single mutation that will
    create new `Session` records, which themselves have accompanying cupping records.
    Again, we''re able to reuse helper functions and code to perform some of this
    work and can focus on the GraphQL code. The following additions to the `handlers/graphql.py`
    code implements creating new `Session` records. There is a slight change to the
    creation of the `schema` object, where we pass in a reference to our `Mutation`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First, notice that the `Mutation` class is the wrapper around all mutations
    that need to be defined and passed into our `Schema`. Just like the `Query` class,
    the `Mutation` class will specify one or more mutation types, which themselves
    subclass `graphene.Mutation`. The entry point for a `Mutation` class is the `mutate`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Before the `mutate` method can be invoked, the class needs to define a set of
    input attributes that will accept the actual input data used to create new data.
    In this case, we need to identify the input data types manually using the raw
    `graphene` type. Look at the `Arguments` class and you should be able to see the
    one-to-one correspondence with the SQLAlchemy models. GraphQL objects can be nested
    arbitrarily deep, that can be seen previously, where the `cuppings` attribute
    is a list of `CuppingInput` objects, itself a custom input type specific to our
    API.
  prefs: []
  type: TYPE_NORMAL
- en: As in the `resolve_` functions in a `Query` attribute, the `mutate` method delegates
    the creation of records to an existing SQLAlchemy function ultimately. All of
    the input data from a client's GraphQL mutation arrive as `kwargs` to `mutate`.
    Those key-value pairs in the form of a Python dictionary are used to create a
    model, validate, and finally write a new record to the database. At this point,
    any validation errors are handled by our model layer and error bubble up to the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With a new Lambda function comes the need to deploy our code, which requires
    a full deployment via `sls deploy`. As a reminder, any time you add, remove, or
    otherwise update an AWS resource, a complete `CloudFormation` update is needed.
    We need to add a couple of new entries in the `serverless.yml` file, which will
    call the new `graphql` handler functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: GraphQL will accept both `GET` and `POST` requests, so we'll wire methods to
    the same `/graphql` endpoint and make sure we enable CORS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re using new libraries, Graphene and Graphene-SQLAlchemy, we''ll
    need to update our requirements file and rebuild our supporting libraries. I''ve
    added the following library to a specific commit to the `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Graphene is a requirement for Graphene-SQLAlchemy, so we get both libraries
    with this single requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use our Docker container as a build tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s safe to do the full deployment, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have a new `/graphql` endpoint, which accepts both `GET` and `POST`
    requests. Next, it's time to test out some GraphQL queries on our serverless endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Astute readers may notice the root URL changing between example deployments.
    During development, this is a frequent occurrence, as you'll often be deploying
    new stacks and then tearing them down when no longer needed. For each deployment,
    a unique base URL will be created by API Gateway via CloudFormation. Of course,
    if this were a production API, you wouldn't be tearing down your serverless stack
    every evening and rebuilding it in the morning.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the deployed application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning the GraphQL language is a topic in and of itself. In this section,
    I'll show some queries and mutations using the Insomnia client on macOS. Insomnia
    is a client application that can be used to make standard REST API requests and
    also has a lovely GraphQL interface when working with GraphQL endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple query to get a list of cupping sessions, returning only the ID and
    name of the `Sessions`, looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When you think back to the implementation of the `Query` class, you might recall
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Hopefully, things are becoming clearer now. The preceding query is named `allSessions`,
    and inside it''s explicitly asking for `sessions`. Our GraphQL code responds in
    kind by noticing that the query is for sessions and invoking the `resolve_sessions`
    function. The following screenshot shows an `allSessions` query using the Insomnia
    client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2707983c-782c-49bb-98b3-1a5b9e989d46.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is great, and the return data may suffice for a client who has a listing
    of all `Sessions`. But what happens when we want more data? In GraphQL, we merely
    ask for the data we need. Assume our client application now wants a listing of
    `Sessions`, but with a few more fields present, including the related `cupping`
    objects for each `Session.` To accomplish this, we update the query schema that
    we''ll send to the `/graphql` endpoint. Rather than just asking for `id` and `name`,
    I''ll add in `formName`, along with two attributes of the related `cuppings` items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows this query along with the response in the Insomnia
    client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eeb5cf2c-4dfb-4bc7-a072-344055faf230.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I have to admit, I was quite excited to see how easy it is to control the output
    when I got this working. So what if we need to filter some data? Remember the
    API that didn''t exist in our REST API but now does? Let''s fetch all of the `cupping`
    objects that are related to a single `Session`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, let''s tie this back to our application code and remember what the `cuppings`
    attribute was in our `Query`, class.  Inside `Query` we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Graphene does include some magic for auto *CamelCase* input and output data.
    Even though the `cuppings` attribute specifies `session_id` as an input filter,
    the client uses `SessionId`. The end result is that the Python code receives `session_id`
    as a keyword argument that is passed to the SQLAlchemy query. The end result is
    that SQLAlchemy performs a query analogous to the following SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows a GraphQL query that will fetch a single `Session`
    based on a numeric ID from our GraphQL API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/168b60ec-30bf-4fe4-9bbe-b0976ae6d17e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, let''s take a look at the mutation portion of our code and create
    some new data. You might expect this to be fairly simple, and it is for the most
    part. One slight complication is that the cupping scores field in the database
    is a PostgreSQL JSONB type, which allows for maximum flexibility. Inputting JSON
    requires escaping this field, which is the reason for all of the backslashes in
    the mutation request. The following code snippet is a GraphQL mutation that creates
    a new `Session` record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'I won''t go through all of the application code, but at a high level, our request
    sends in a `createSession` mutation to the application. This input payload maps
    directly to our `create_session` attribute on the `Mutation` class thanks to the
    auto *CamelCasing* from Graphene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The input data in the preceding mutation is reasonably small. What is more verbose
    is the section for the return values. Our mutation returns an `ok` attribute,
    which is a Boolean, along with the newly created `Session` resource. Because of
    that, our mutation can request precisely what it needs from the newly created
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the input and output when creating a new `Session`
    record in the Insomnia client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bebb18e-c720-4159-8023-071114ad13d8.png)'
  prefs: []
  type: TYPE_IMG
- en: GraphQL has much more to offer, and I only wish there was more time to cover
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration and deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While developing this code using the existing repository, I repeatedly needed
    to update just the GraphQL portion of the stack. Using the Serverless Framework
    and its ability to update a single Lambda function made this very easy. With the
    shortcut in the `Makefile`, deploying a single function looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It's hard to give exact numbers, but deployments like this after iteration on
    code take in the order of two-five seconds. Deployment speed will mostly depend
    on your upload speeds and the final size of the application package.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, iterating and adding new code means writing more tests. Serverless
    applications can be slightly tricky since it's possible to write a rich set of
    unit tests, only to see the deployed application fail due to missing or presumptuous
    tests higher up in the stack. My advice is to write the right mix of unit tests,
    without being academic about it, along with a very rich set of integration tests
    as the highest level of code that is practical.
  prefs: []
  type: TYPE_NORMAL
- en: Using a concrete example, this GraphQL query and mutation code above is 100%
    tested, as is the `cupping.handlers.graphql.handle_graphql` function. This strategy
    ensures that all of the error handling, JSON decoding of the payload, and other
    utility code is behaving as expected, in addition to testing the GraphQL business
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we walked through the entire process of creating a three-tier
    web application with a serverless architecture using a GraphQL interface. The
    vast majority of this application is similar to the REST version of the same application.
    We learned the changes needed to migrate from a REST interface and design to a
    GraphQL design, both from the perspective of application code and serverless functions.
  prefs: []
  type: TYPE_NORMAL
- en: Readers should now have a high-level understanding of the advantages of employing
    a GraphQL interface in a serverless architecture and have enough knowledge to
    begin implementation of their own serverless GraphQL application.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](svrls-dsnptn-bstprac_ch04.html), *Integrating Legacy APIs with
    the Proxy Pattern*, we will work through yet another web application pattern for
    proxying API requests from clients through a serverless application to a legacy
    API.
  prefs: []
  type: TYPE_NORMAL
