- en: Chapter 5. Conversations and Journeys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Success is liking yourself, liking what you do, and liking how you
    do it."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Maya Angelou* |'
  prefs: []
  type: TYPE_TB
- en: In this chapter, we devote our attention to the JSF conversation scope. This
    scope defines the lifecycle of a managed backing bean that spans between the request
    and the session scope. This allows the data in the form to survive in a lifespan
    that sits between the request-scope and the session-scope. The conversation scope
    is also said to be contextual. This term is appropriated from the **Context and
    Dependency Injection** (**CDI**) specification, and it means that the life span
    of the beans marked with a conversation scope are treated as being part of a context.
    You can think of this as a dotted marker that the CDI container draws around the
    object instances to define them as a private group, which denotes a lifecycle.
    The CDI container does this job of gathering the object instances together as
    it associates one object bean with a dependency on another.
  prefs: []
  type: TYPE_NORMAL
- en: In CDI, Context represents the CDI container's ability to bind a group of object
    instances that are stateful components into well-defined and extendible lifecycles.
  prefs: []
  type: TYPE_NORMAL
- en: In CDI, Dependency Injection represents the CDI container's capability to inject
    components into an application with type safety in mind. The CDI container chooses,
    at runtime, the implementation of the Java interface that is to be injected.
  prefs: []
  type: TYPE_NORMAL
- en: JavaServer Faces integrates into the standard CDI scope, including the conversational
    scope. Examples of conversation include several types of contemporary digital
    customer journeys. You probably have seen this yourself whilst applying for a
    new job online, going through the shipping and delivery flow of an e-commerce
    website, or setting up a government resource or function like a tax assessment
    or return. In this chapter, we are going look at one example customer journey,
    where the developer or user is applying for an instant secured loan. You may have
    already seen these or actually have been fortunate, or unfortunate, to peruse
    a payday loan facility.
  prefs: []
  type: TYPE_NORMAL
- en: The conversation scope maintains a state with a client. The controller or POJO,
    which is demarcated with the conversation scope, and its component instances become
    part of its state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram outlines the conversation scope around the managed bean
    controller that we will be studying in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Conversations and Journeys](img/image00396.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An illustration of the several bean instances with different CDI scopes
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows two different customers, which are logged into the
    enterprise application. Starting from left to right, we have the **UserProfile**
    instances that capture the login information of the customer, which are stored
    in the CDI session scope. These beans are shared with only the particular customer
    associated with the `javax.servlet.http.HttpSession` object.
  prefs: []
  type: TYPE_NORMAL
- en: Moving over to the right, we have an object graph of bean instances, the **LendingController**,
    **ContactDetail**, and **BankDetails**, which are stored in the conversation scope.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the diagram, inside the application scope, we have the bean
    instances, **Utility** and **DataHelperController**. All web application users
    share the beans. The conversation beans are able to access the shared information
    in the current session scope and also in the application scope.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on CDI, please read the sister book, *Java EE 7 Developer
    Handbook*, *Packt Publishing*.
  prefs: []
  type: TYPE_NORMAL
- en: Digital e-commerce applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java EE applications are well-suited to digital sites that maintain state. If
    the site maintains any sort state with the user in their customer journey, then
    the users are usually involved with conversations. UX testing has shown that,
    for many enterprise sites where lots of interactions occur, there are several
    conversations. To paraphrase, a fellow Java Champion, Antonio Gonclaves, who was
    a member of the Java EE 7 expert group, if your intention is to build digital
    web applications, then it must be able to handle complex flow management.
  prefs: []
  type: TYPE_NORMAL
- en: An instant loan is not quite in the same league of the products that fast start-ups
    and entrepreneurs effectively provided as an end-state solution to the global
    economic credit crunch. With the rise in competition from these new agile upstarts,
    many domestic household banks in several of the developed nations have had to
    quickly assemble an instant loan facility product. In this chapter, we will develop
    an instant secure loan facility. Our product is not a full solution, but it shows
    the way to deliver the initial prototype for a digital customer. We do not integrate
    with the financial services, whereas a commercial solution would need management
    information reporting as well as integration with the commercial banking infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the conversational scope more extensively.
  prefs: []
  type: TYPE_NORMAL
- en: Conversational scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conversational scope is defined by a lifecycle that spans many HTTP requests
    to the server. The developer determines when the scope begins and ends, and most
    importantly, it is associated with a user. The key annotation is defined by a
    CDI specification called `@javax.enterprise.context.ConversationScoped`. When
    you apply this annotation to a controller or POJO, remember to ensure that you
    implement the marker interface, `java.io.Serializable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'CDI also defines an interface, `javax.enterprise.context.Conversation` that
    represents the conversation interface. A conversation can be two distinct states
    of existence: transient and long-running. The transient state means that the conversation
    is a temporary state. When you annotate a bean with `@ConversationScoped`, it
    will be in the transient state by default.'
  prefs: []
  type: TYPE_NORMAL
- en: The developer controls when the conversation switches from the transient to
    the long-running state. The conversation, then, becomes active and it maintains
    the holds state of the HTTP user connection, which is usually associated with
    a particular web browser tab. Essentially, a conversation is a unit of work. A
    conversation is started and, eventually, ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the definition of `javax.enterprise.context.Conversation`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The methods, `begin()` initiate a conversation. A conversational scope POJO
    is marked for long running storage by the CDI container. A conversation has an
    identifier; the other method `begin(String id)` allows the developer to provide
    an explicit one.
  prefs: []
  type: TYPE_NORMAL
- en: The method `end()` terminates a conversation, the CDI container effectively
    discards the contextual information associated with the POJO, and the state returns
    to transient. In order to find out if a conversation is transient, the call `isTransient()`
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the lifecycle of a CDI conversation scope
    bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Conversational scope](img/image00397.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Conversation timeout and serialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed earlier, the lifespan of a conversation scope is beyond the
    request scope, but cannot survive beyond the session scope. The CDI container
    can timeout a conversation scope and terminate the contextual information in order
    to preserve or recover a resource. This is partially the reason that an annotated
    bean with `@ConversationScoped` must be `Serializable`. A smart CDI container
    and servlet container may transfer a conversation to disk or even to another running
    JVM instance, but it could never attempt this without serialization.
  prefs: []
  type: TYPE_NORMAL
- en: The application developer can retrieve the timeout and set it with the methods,
    `getTimeout()` and `setTimeout()`.
  prefs: []
  type: TYPE_NORMAL
- en: So now we know what are `@ConversationScoped` and `Conversation`. Let's put
    them to good use in our instant secure lending application.
  prefs: []
  type: TYPE_NORMAL
- en: The conversation scope controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The heart of our digital customer journey is a managed bean called `LendingController`.
    We will break it down gently into easier sections as we go through this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial implementation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This might appear a complicated controller on the first observation, however,
    there are two important items here. First, we annotate the `LendingController`
    with `@ConversationScoped` and second, we ask the CDI to inject a `Conversation`
    instance into this bean. We also implement the `Serializable` marker interface
    to allow the servlet container to have the freedom to persist and reload beans
    on the fly, if it so chooses and if the implementation supports this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Pay particular attention to the helper methods, `checkAndStart()` and `checkAndEnd()`.
    The `checkAndStart()` method starts a new long-running conversation if the current
    state is transient. The `checkAndEnd()` method terminates a long-running conversation
    provided that the current Conversational instance is in the running state.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that some elements of the previous contact detail application have
    made it into our instant lending application. This is by deliberate design.
  prefs: []
  type: TYPE_NORMAL
- en: The `LendingController` bean contains an instance member of `Applicant`, which
    is the domain master detail record. It is a JPA entity bean that stores the applicant's
    data. You have already seen the date-of-birth fields. The controller also has
    members related to the monthly payment amount and the total payable amount of
    the loan. It also contains the lower and upper limits for the loan amount and
    the rate, which are exposed as getters and setters.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the CDI injects a utility instance into `LendingController`. This is
    an application scoped POJO, which neatly lets us avoid writing a static singleton.
    We shall see the details of the utility class later, but first we must side step
    into a design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The Entity-Control-Boundary design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This instant lending application takes advantage of a particular design pattern
    called Entity-Control-Boundary. This is a pattern that separates the concerns
    and responsibilities for a group of objects in an application. The clue is in
    the imported package names for `LendingController`.
  prefs: []
  type: TYPE_NORMAL
- en: To explain very briefly, the notion of entities represents the data model in
    a software application. The control elements are the components in the software
    application that manage the flow of information. The boundary elements belong
    to the application system, but lie on the periphery of the system.
  prefs: []
  type: TYPE_NORMAL
- en: You are quite correct in your assumption that this pattern resembles the Model-View-Controller,
    except that the ECB is applicable to the entire software system and the control
    element is more responsible than the controller and user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: In this application, I placed `LendingController` in the control package, because
    the source code shows that it contains the majority of the business logic. Perhaps,
    for a proper production application, we could delegate our logic into another
    CDI bean or EJB. As a consultant once said to his client, *it depends on the situation*.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the entity package, there is no controversy; I added the `Applicant`,
    `ContactDetail`, and `Address` classes. These are persistence capable objects.
    You have already seen the `ContactDetail` entity bean in [Chapter 4](part0043.xhtml#aid-190861
    "Chapter 4. JSF Validation and AJAX"), *JSF Validation and AJAX*.
  prefs: []
  type: TYPE_NORMAL
- en: I put the `ApplicantService` EJB in the boundary package, because it lies on
    the periphery and it is responsible for data access.
  prefs: []
  type: TYPE_NORMAL
- en: The customer journey
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's delve back into `LendingController` and reveal our customer journey. We
    assume that we have sat with creative designers and the UX team and come up with
    a design. The application is based on a series of linear web pages organized into
    a wizard. For the sake of this basic example, we only allow the consumer to progress
    to the next page when they successfully enter valid information for the current
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topographical titles for each page:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Step | Page | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Getting started | Provide the customers with information about the eligibility
    criteria |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Your details | The customers enter their personal contact detail and
    date of birth |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Your rate | The customers selects their loan amount and term |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Your address | The customers enters their full home address and telephone
    numbers |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Confirm | The consumers agree to the legal terms of service and view
    the summary |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Completion | The consumers see an acknowledgement of their application
    form submission |'
  prefs: []
  type: TYPE_TB
- en: 'This is now quite simple to implement in the controller with the following
    extract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `LendingController` bean has several action methods that correspond to the
    user requirements, namely `doGettingStarted()`, `doYourDetails()`, `doYourRate()`,
    `doYourAddress()`, `doConfirm()`, and `doCompletion()`. These action methods progress
    the customer to the next page view by simply returning the name. For most of these
    methods, apart from `doCompletion()`, we ensure that the conversation is in a
    long-running state by calling `checkAndStart()`. In the `doCompletion()` and `cancel()`
    methods, we invoke `checkAndEnd()` to ensure that the conversation reverts to
    the transient state. The method `doCompletion()` utilizes `ApplicationService`
    to save the data, the `Applicant` entity instance, to the underlying database.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the example code, we are cheating slightly by applying `checkAndStart()`
    at the beginning of each action method. For production code, we should usually
    ensure that it is an error or a redirection if the user jumps into a bookmarkable
    URL that is supposed to have a conversation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine the entities and fill in more of the blanks.
  prefs: []
  type: TYPE_NORMAL
- en: Entity classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The entity `Applicant` is a master detail record. This is known as the core
    domain object. It stores the data for the customer's application for the instant
    secured loan. We capture the customer's loan information such as the contact details
    (`ContactDetail`), the address (`Address`), the telephone numbers (home, work,
    and mobile), and, most importantly, the financial details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Applicant` entity would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Applicant` entity stores the loan amount, rate, term, and also a submission
    date. It also contains the home, work, and mobile telephone numbers. An applicant
    has a one-to-one unidirectional relationship with both, the `ContactDetail` and
    `Address` entities.
  prefs: []
  type: TYPE_NORMAL
- en: For the financial properties such as `loanRate` and `loanAmount`, please note
    that we prefer to use `BigDecimal` rather than the primitive floating-point type
    for monetary accuracy during calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to explain a domain object to the stakeholder would be: a customer
    has a loan rate, a loan term, and must agree electronically to the legal conditions.
    With this information, the system can compute the loan and how much the customer
    pays back each month, and displays it at the time of applying for the loan.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have already seen the `ContactDetail` entity. It is exactly the same as
    before and only the package name has been refactored to entity. The following
    is the extract code of the `Address` entity bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The entity `Address` represents the applicant's correspondence and legal personal
    address. There is nothing special to see here. It is a bog standard entity bean
    that you will see in e-commerce applications.
  prefs: []
  type: TYPE_NORMAL
- en: May I remind you that the source code for the examples are online and are a
    part of this book for your reference.
  prefs: []
  type: TYPE_NORMAL
- en: Data service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How do we save the customer's input into persistence storage? Our application
    utilizes a stateful session EJB, and it provides methods to save and retrieve
    the `Applicant` entity records.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class `ApplicantService` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `add()` method inserts a new applicant into the database. The `findAll()`
    and `findById()` are not used in the instant loan example. These query methods
    are there for illustrative purposes only. Presumably, one requires access to the
    applicant data in another part of the full application.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered the entity, control, and boundary of our application. It is
    time to examine the page views.
  prefs: []
  type: TYPE_NORMAL
- en: Page views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The flow of control for the view is defined by the customer journey. Each page
    view represents a particular requirement that the business stakeholder wants to
    see. The index page view is a requirement, because the lender wants the customer
    to see a landing page. It is also a legal duty of compliance required by national
    government authorities. You will also notice that the customer journey maps to
    a linear flow, but not for all journeys.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Payday loan scheme must follow compliance requirements. Refer to the websites
    of the UK Financial Conduct Authority ([https://goo.gl/NfbFbK](https://goo.gl/NfbFbK))
    and the US Consumer Financial Protection Bureau ([http://goo.gl/3V9fxk](http://goo.gl/3V9fxk)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table outlines the relationship between the controller actions
    and the view pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| View source | View target | Action method |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `index` | `getting-started` | `jumpGettingStarted()` |'
  prefs: []
  type: TYPE_TB
- en: '| `getting-started` | `your-detail` | `doGettingStarted()` |'
  prefs: []
  type: TYPE_TB
- en: '| `your-details` | `your-rate` | `doYourDetails()` |'
  prefs: []
  type: TYPE_TB
- en: '| `your-rate` | `your-address` | `doYourRate()` |'
  prefs: []
  type: TYPE_TB
- en: '| `your-address` | `confirm` | `doYourAddress()` |'
  prefs: []
  type: TYPE_TB
- en: '| `confirm` | `completion` | `doConfirm()` |'
  prefs: []
  type: TYPE_TB
- en: '| `completion` | `index` | `doCompletion()` |'
  prefs: []
  type: TYPE_TB
- en: All the view pages are suffixed with the extension `xthml` in the preceding
    table. It is quite clear there is a linear flow of work happening in the conversation.
    The conversation scope ideally begins when the customer enters the getting-started
    view through the `jumpGettingStarted()` action method.
  prefs: []
  type: TYPE_NORMAL
- en: An initial page view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the initial `index.xhtml` page view. This is the landing page
    of the loan application. The following is a screenshot of our loan application
    and the landing page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An initial page view](img/image00398.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The view for this page `index.xhtml` is very straightforward. It features a
    basic link button component and features a Bootstrap carousel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `<h:link>` element is the most important feature of this view. The outcome
    of this custom tag references the `jumpGettingStarted()` method in the controller,
    which begins a long-running conversation.
  prefs: []
  type: TYPE_NORMAL
- en: Even at this stage, before a conversation begins, we can deliver information
    to the customer. So, in a further section of the page view, we tell the customer
    about the minimum and maximum loan amounts and the rates using expression language.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code, which is also a part of the page view `index.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This page makes use of the JSF core tag `<f:convertNumber>` to format the floating
    numbers into monetary formats. The HTML entity character `&#37;` represents the
    percent character (`%`). Remember, the view technology is strictly Facelets and
    not HTML5.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started page view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The getting started view is even simpler. We present the customer with information
    regarding their eligibility to apply for a loan. The customer must be 18 years
    or over; we repeat how much they borrow and for how long.
  prefs: []
  type: TYPE_NORMAL
- en: 'The view is called `getting-started.xhtml` and looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started page view](img/image00399.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is a single JSF form with a button to move the customer to the next page
    view, `your-details.xhtml`. There is no need to see the full source code for this
    view, because it is mainly mark-up HTML. However, we have another command link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Contact details page view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next view is the familiar contact details screen. We've subsumed it from
    the previous chapters into the instant secure loan example. We've also repurposed
    the JSF expression language to reference the controller and the nested properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The page-authoring code for the first name field is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The EL `#{lendingController.applicant.contactDetail.firstName}` refers to the
    relevant nested entity bean property. We also retain the AJAX JSF validation features
    from [Chapter 4](part0043.xhtml#aid-190861 "Chapter 4. JSF Validation and AJAX"),
    *JSF Validation and AJAX* to provide a rich customer journey.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this view, we use a JSF command button to submit the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We also have the obligatory cancel operation just in case the customer no longer
    wants to apply for the loan that day.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the `your-details.xhtml` view, which allows
    the customer to enter their contact details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Contact details page view](img/image00400.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now it is time for something new. How about adding in some HTML5 goodness to
    the good old JavaServer Faces?
  prefs: []
  type: TYPE_NORMAL
- en: Your rate page view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The loan amount and rate page view relies on the HTML5 range control element,
    which, on most standard compliant browsers, is rendered as a horizontal slider.
    JSF has no built-in support for a range control; so for this view, we make use
    of the JSF HTML5 friendly support capability. The JSF specification allows us
    to write a markup that looks like a standard HTML component, but if we supply
    a special attribute, JSF treats it as a UI component. The pass-through ability
    works only with the markup that resembles the existing JSF core controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'A picture is worth a thousand words, so let''s take a look at the following
    screenshot of `your-rate.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Your rate page view](img/image00401.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The view uses AJAX partial updates and the HTML5 friendly markup facility.
    Let me show you the code for the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As with all JSF forms, we first declare a form called `yourRateForm` and style
    it using Bootstrap CSS. Concentrating on the control element, you will notice
    that it is written as `<input>` as not `<h:inputText>`. This is because the JSF
    `<h:inputText>` does not support the new HTML5 Range element. Ordinarily, the
    lack of access to a richer UI component would have been an issue for the instant
    secure lending.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML5 Range Input element accepts a minimum, a maximum, and the current
    value. It also accepts a step size.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 friendly support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSF 2.2 allows HTML5 friendly components with a new tag library URI for an XML
    namespace of ``. With the attributes `jsf:id`, `jsf:label`, and `jsf:attribute`,
    HTML5 tags have a visibility within the JSF framework.``
  prefs: []
  type: TYPE_NORMAL
- en: '``The full XML namespace for `your-rate.xhtml` looks as follows:``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`We will discuss composite components later in the chapter. The HTML5 friendly
    tag library exposes a standard HTML input component to the JSF lifecycle. It is
    also easier for the creatives, not experienced in JSF or Java, to understand a
    page view. We do not have to worry any longer about the special name mangling
    that JSF applies to the view IDs; this means that component IDs are useful for
    both, HTML and JavaScript.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Using AJAX for a partial update`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '``In [Chapter 4](part0043.xhtml#aid-190861 "Chapter 4. JSF Validation and AJAX"),
    *JSF Validation and AJAX*, we learnt how to validate the form properties using
    Ajax. JSF allows the developers to perform a partial page update using the `<f:ajax>`
    custom tag.``'
  prefs: []
  type: TYPE_NORMAL
- en: '`To enable a rich user example, whenever the customer changes the loan amount
    slider, we invoke the server side to recalculate the monthly payment amount. We
    achieve this by attaching an event listener to the change in value. The code for
    this would be as follows:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`A new addition to the code is the render attribute, which specifies the unique
    ID of the JSF UI components that will be re-rendered on an AJAX response. In other
    words, we declaratively specify the components to be re-rendered on the completion
    of an AJAX behavior to JSF, and thus, obtain a partial update.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Binding components`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Let''s see the other components that the HTML5 Range element, the loan amount
    in this case, binds with.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Take a look at the following code:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '``The progress markup is directly copied from the Bootstrap CSS component examples.
    We plugged in the value expressions to pull information from the `LendingController`
    and the `Applicant` instances.``'
  prefs: []
  type: TYPE_NORMAL
- en: '``Right at the top of the preceding code extract, we set the initial value
    of the progress bar with the JSTL core tag `<c:set>`.``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '``This demonstrates that the unified expression language in EL 3.0 has the
    ability to retrieve the late bounded values in JSF to compute a result. The result
    is set in a page scope variable called `loanAmountWide`. This variable is accessed
    later with `$(loanAmountWidth)` and it sets the initial position value of the
    Bootstrap CSS progress bar component..``'
  prefs: []
  type: TYPE_NORMAL
- en: '`The HTML5 standard has no built-in support for displaying the value of an
    HTML5 Range element that works across all the top web browsers. At the time of
    writing, this feature was missing, and the W3C or WHATWG may tighten up this weakness
    in the HTML5 specification in the near future. Until then, we will use jQuery
    and JavaScript to fill the void.`'
  prefs: []
  type: TYPE_NORMAL
- en: '``If you noticed, the text is identified with `loanAmountText` and the progress
    component is denoted by `loanAmountProgress` in the preceding code. It is trivial
    to write the jQuery for binding the HTML5 Range elements to these fields.``'
  prefs: []
  type: TYPE_NORMAL
- en: '``We need a JavaScript module to achieve the binding. The complete code to
    `/resources/app/main.js` is given as follows:``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '``The module `instantLending.Main` defines a binding of an HTML Range element
    to two other components: a progress bar and a label text area. For a quick revision
    of the JavaScript module, refer to [Chapter 1](part0015.xhtml#aid-E9OE1 "Chapter 1. Digital
    Java EE 7"), *Digital Java EE 7*.``'
  prefs: []
  type: TYPE_NORMAL
- en: '``The module has an `init()` function that sets up the binding using the jQuery
    document loading mechanism. It calls a function called `associateRangeToText()`,
    which computes the percentage travelled for the progress bar and writes that value
    into the text element area. The function accepts the document ID for the relevant
    components: the range, progress, and text label components. It attaches an anonymous
    function to the range element; when the user changes the component, it updates
    the associated component.``'
  prefs: []
  type: TYPE_NORMAL
- en: '``The module `main.js` also defines a helpful prototype method added to the
    JavaScript number type. The following code shows how it works:``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '``The method `formatMoney()` formats a floating-point value type to the monetary
    output as a String. This code has been contributed by Patrick Desjardins to Stack
    Overflow. The following code illustrates how to invoke this function:``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`The first parameter is the fixed fraction size, the second parameter determines
    the decimal symbol, and the third specifies the thousand-unit character.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`With this module, we bound the HTML5 Range element to other elements in the
    page, thus demonstrating the HTML5 friendly support within JSF.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Updating areas with AJAX partial updates`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '``How does JSF update an area of the page with an AJAX response? The developer
    specifies the UI components that are updated with the render attribute of the
    `<f:ajax>` tag. In modern web design, which component can be treated as an HTML
    Layer element `<div>` inside the standard JSF rendering kit? The answer for this
    is to use the `<h:panelGroup>` JSF custom tag. We can supply this UI component
    with a unique identifier, and when the AJAX behavior completes, JSF renders this
    component.``'
  prefs: []
  type: TYPE_NORMAL
- en: '``The following is the code extract for the instant loan rate where the div
    element is identified by `loanRateOutput`:``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '``The `<h:panelGroup>` renders a div layer by default and thus contains the
    progress bar component and the text output content. The div is rendered after
    an invocation to the method `recalculatePMT()` in `LendingController`. Refer to
    the preceding sections for a reminder of this code.``'
  prefs: []
  type: TYPE_NORMAL
- en: '``The functions `recalclulatePMT()` and `recalculateLoanRate()` look as follows:``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '``The function `recalculatePMT()` uses the classic mathematical formula to
    evaluate the monthly payment amount for the loan based on the principal amount,
    length of the term and, of course, the rate.``'
  prefs: []
  type: TYPE_NORMAL
- en: '``The function `recalculateLoanRate()` uses a utility, an application-scoped
    CDI bean, to work out the rate according to a table of rate limits that vary according
    to the loan account.``'
  prefs: []
  type: TYPE_NORMAL
- en: '``So let''s recap. The JavaScript module `instantLending::Main` updates on
    the client side. When the customer changes the loan amount then this module changes
    the progress bar component and the text content. Simultaneously, JSF invokes an
    AJAX request to the server side and invokes the action event listener, `recalculatePMT()`.
    The framework eventually receives the AJAX response and then re-renders the loan
    rate, term control, and the summary area.``'
  prefs: []
  type: TYPE_NORMAL
- en: '``To complete the XHTML, let''s inspect the remaining content on this page
    view, your-`rate.xhtml`. The following is the content for the loan term, which
    is a drop-down component:``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '``The component also features a `<f:ajax>` custom tag that invokes the recalculation
    event listener. Therefore, if the customer selects a different term for the loan,
    `loanRateOutput` and `paymentMonthlyOutput` also change along with the summary
    due to a partial AJAX update.``'
  prefs: []
  type: TYPE_NORMAL
- en: '`Finally, let''s see the content for the summary area:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '``In the preceding code extract, we use `<h:outputText>` instead of `<h:panelGroup>`
    to update only certain parts of the content using partial AJAX updates. A JSF
    output text element is a JSF UI component, so it works by asking for the AJAX
    behavior to be re-rendered.``'
  prefs: []
  type: TYPE_NORMAL
- en: '`The address page view`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`The address page view captures the customer''s primary home address. This
    page also features an AJAX validation on the client side.`'
  prefs: []
  type: TYPE_NORMAL
- en: '``This code is so similar to the contact details form that we will leave out
    the code extract and the trees here. I will only show the first `houseOrFlatNumber`
    fields in the following code:``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '``The following is a screenshot of the `your-address.xhtml` pageview.``'
  prefs: []
  type: TYPE_NORMAL
- en: '`![The address page view](img/image00402.jpeg)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`The confirmation page view`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '``The confirmation page view is where the customer sees all the details about
    their instant loan. In this view, they have a chance to read the terms and conditions
    of the contract. The customer must either select the checkbox to accept the agreement,
    or they can hit the cancel button to terminate the conversation. The cancel button
    invokes the `cancel()` method in `LendingController`, which, in turn, invokes
    `checkAndEnd()`.``'
  prefs: []
  type: TYPE_NORMAL
- en: '`The only relevant code here is for the terms of agreement checkbox. The code
    extract is as follows:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '``We use `<h:selectBooleanCheckBox>` with immediate AJAX validation on the
    blur event. This ensures that the Boolean property is set to true on the server
    side. However, we must still verify on form submission, as we see in the action
    controller method:``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '``Inside the `doConfirm()` method, we recalculate the monthly payment term
    just to be sure. We check that the the applicant''s data values have not changed,
    set the date of submission, and then we invoke the `ApplicationService` to insert
    a new record into the database. After this method, the customer is said to have
    applied successfully.``'
  prefs: []
  type: TYPE_NORMAL
- en: '``We include a manual check on `isTermsAgreed()`, because it is a legal requirement
    in the contract for the customer to accept the terms and conditions. It is probably
    controversial to raise an application error `IllegalStateException` here. More
    likely, the developer would print a message to an error log, and also raise an
    exception. The servlet specification allows different exceptions to be trapped
    and sent to a certain error page. Therefore, if we created a custom runtime exception
    such as `LegalTermsAgreementException`, we could responsibly handle such conditions.``'
  prefs: []
  type: TYPE_NORMAL
- en: '`In a production system, the end of this sequence would probably trigger an
    additional business process. For instance, the work message might be sent to another
    case working area using a messaging bus, JMS. In a modern digital application,
    the customer should expect an e-mail to be sent with the confirmation and the
    loan contract details. Of course, this is an additional exercise for the reader
    to deliver this requirement.`'
  prefs: []
  type: TYPE_NORMAL
- en: '``The following is a screenshot for the confirmation view, `confirm.xhtml`:``'
  prefs: []
  type: TYPE_NORMAL
- en: '`![The confirmation page view](img/image00403.jpeg)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Let''s move to the final page view of completion.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`The completion page view`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '``The complete stage is straightforward. The customer has submitted his application,
    so we only need to inform him or her about this and then the conversation ends.
    The following is the full code for the `doCompletion()` method in `LendingController`:``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`This method simply ends the conversation scope, because the user''s digital
    customer journey is finished by then.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Now we have a complete flow, a digital customer journey. What is missing?
    We should add the steps to accept a valid bank account, a bank sorting code, IBAN
    number, and an integration into the national bank infrastructure! Of course, we
    would also need a certain level of financial capital, enough money to satisfy
    the regulators; in the United Kingdom, this would be the Financial Conduct Authority
    ([http://www.fca.org.uk/](http://www.fca.org.uk/)).`'
  prefs: []
  type: TYPE_NORMAL
- en: '``A screenshot of this page view, `completion.xhtml`, is as follows:``'
  prefs: []
  type: TYPE_NORMAL
- en: '`![The completion page view](img/image00404.jpeg)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Utility classes`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '``Often in applications, we refactor common methods and properties into a separate
    utility class, which has features so common that they do not make sense in any
    particular package domain. We often place these concepts inside static methods
    in a singleton. With Java EE, we can do much better than that. Since CDI supports
    application scope, we can simply move our commons methods into a POJO and make
    CDI inject the bean into dependent objects. It is the smart way to handle the
    data, the time and monthly payment term calculation in the `LendingController`
    example.``'
  prefs: []
  type: TYPE_NORMAL
- en: '``The application scope bean `DateTimeController` acts as a helper for the
    page author views:``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '``The `DateHelperController` method is used in `your-details.view`, and it
    generates the data for the drop-down day and month of the date-of-birth fields.
    This code was originally a part of the `ContactDetailsController` method in [Chapter
    4](part0043.xhtml#aid-190861 "Chapter 4. JSF Validation and AJAX"), *JSF Validation
    and AJAX*. It has been refactored for reuse.``'
  prefs: []
  type: TYPE_NORMAL
- en: '`There is an other POJO with an application scope and it is called Utility.`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '``In the preceding code, the method `calculateMonthlyPayment()` calculates
    the monthly payment amount. The arguments are `pv` (that specifies the principal
    value), `apr` (that specifies the annual percentage rate), and the `np`, which
    stands for the notice period measured in months.``'
  prefs: []
  type: TYPE_NORMAL
- en: '``The method `getTaxRate()` looks up the appropriate tax rate given the principal
    value, that is, the loan amount that the customer wants. The class `LoanRateBounds`
    is a simple POJO, as shown in the following code:``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '``This `LoanRateBounds` POJO is an immutable object and is thread-safe.``'
  prefs: []
  type: TYPE_NORMAL
- en: "[PRE30] package uk.co.xenonique.digital.instant.control; import javax.faces.component.*;\
    \ import javax.faces.context.FacesContext; import java.io.IOException;  @FacesComponent(\"\
    workerBannerComponent\") public class WorkerBannerComponent extends UINamingContainer\
    \ {   private String gettingStartedActive;   private String yourDetailsActive;\
    \   private String yourRateActive;   private String yourAddressActive;   private\
    \ String confirmActive;   private String completedActive;    @Override   public\
    \ void encodeAll(FacesContext context) throws IOException {     if (context ==\
    \ null) {         throw new NullPointerException(\"no faces context supplied\"\
    );     }     String sectionName = (String)getAttributes().get(\"sectionName\"\
    );     gettingStartedActive = yourDetailsActive = yourRateActive = yourAddressActive\
    \ = confirmActive = completedActive = \"\";      if ( \"gettingStarted\".equalsIgnoreCase(sectionName))\
    \ {         gettingStartedActive = \"active\";     }     else if ( \"yourDetails\"\
    .equalsIgnoreCase(sectionName)) {         yourDetailsActive = \"active\";    \
    \ }     else if ( \"yourRate\".equalsIgnoreCase(sectionName)) {         yourRateActive\
    \ = \"active\";     }     else if ( \"yourAddress\".equalsIgnoreCase(sectionName))\
    \ {         yourAddressActive = \"active\";     }     else if ( \"confirm\".equalsIgnoreCase(sectionName))\
    \ {         confirmActive = \"active\";     }     else if ( \"completed\".equalsIgnoreCase(sectionName))\
    \ {         completedActive = \"active\";     }     super.encodeAll(context);\
    \   }    // Getters and setters omitted } [PRE31] <!DOCTYPE html> <html      \
    \                 >   <cc:interface componentType=\"workerBannerComponent\"> \
    \    <cc:attribute name=\"sectionName\" required=\"true\"/>   </cc:interface>\
    \    <cc:implementation>     <div class=\"workflow-wrapper\">       <div class=\"\
    workflow-column\">         <div class=\"workflow-title  #{cc.gettingStartedActive}\
    \ pull-left\" >             Getting Started         </div>         <div class=\"\
    workflow-arrow-right #{cc.gettingStartedActive}  pull-left\"></div>       </div>\
    \        <div class=\"workflow-column\">         <div class=\"workflow-title \
    \ #{cc.yourDetailsActive} pull-left\" >             Your Details         </div>\
    \         <div class=\"workflow-arrow-right  #{cc.yourDetailsActive} pull-left\"\
    ></div>       </div>        <div class=\"workflow-column\">         <div class=\"\
    workflow-title  #{cc.yourRateActive} pull-left\" >             Your Rate     \
    \    </div>         <div class=\"workflow-arrow-right  #{cc.yourRateActive} pull-left\"\
    ></div>       </div>        <div class=\"workflow-column\">         <div class=\"\
    workflow-title  #{cc.yourAddressActive} pull-left\" >             Your Address\
    \         </div>         <div class=\"workflow-arrow-right  #{cc.yourAddressActive}\
    \ pull-left\"></div>       </div>        ...        </div>     </div>   </cc:implementation>\
    \ </html> [PRE32] <html                                    >    <ui:composition\
    \ template=\"/basic_layout.xhtml\">     <ui:define name=\"mainContent\">     \
    \  <xen:workflow-banner sectionName=\"yourRate\"/>       ...                 </html>\
    \ [PRE33] <!DOCTYPE html> <html        >    <cc:interface/>\P      <cc:implementation>\
    \     <div class=\"alert alert-info\">       <h:outputText value=\"Own ID: #{component.id},\
    \ parent composite ID: #{cc.id}\" />       <br/>       <h:outputText value=\"\
    Own ID: #{component.id}, parent composite ID: #{cc.id}\" />       <br/>      \
    \ <h:outputText value=\"Own ID: #{component.id}, parent composite ID: #{cc.id}\"\
    \ />     </div>   </cc:implementation> </html> [PRE34] <!DOCTYPE html> <html \
    \            >    <ui:composition template=\"/basic_layout.xhtml\">     <ui:define\
    \ name=\"mainContent\">       <h1> Custom Composite Demonstations</h1>       \
    \ <xen:workflow-banner sectionName=\"gettingStarted\"/>       <pro:infoSec message=\"\
    The definition of digital transformation\" />       <xen:component-report/>  \
    \      <a class=\"btn btn-primary btn-lg\"         href=\"#{request.contextPath}/index.xhtml\"\
    > Home </a>      </ui:define> <!--name=\"mainContent\" -->   </ui:composition>\
    \ </html> [PRE35] package uk.co.xenonique.digital.instant.control; import javax.faces.component.FacesComponent;\
    \ import javax.faces.component.UINamingContainer; import javax.faces.context.FacesContext;\
    \ import javax.faces.context.ResponseWriter; import java.io.IOException; import\
    \ java.security.Principal;  @FacesComponent(   value=\"informationSecurity\",\
    \   namespace = \"http:/www.xenonique.co.uk/jsf/instant/lending\",   tagName =\
    \ \"infoSec\", createTag = true) public class InfoSecurityComponent extends UINamingContainer\
    \ {   private String message;    @Override   public String getFamily() {     return\
    \ \"instant.lending.custom.component\";   }    @Override   public Object saveState(FacesContext\
    \ context) {     Object values[] = new Object[2];     values[0] = super.saveState(context);\
    \     values[1] = message;     return ((Object) (values));   }    @Override  \
    \ public void restoreState(FacesContext context, Object state) {     Object values[]\
    \ = (Object[]) state;     super.restoreState(context, values[0]);     message\
    \ = (String) values[1];   }    public void encodeBegin(FacesContext context) \
    \        throws IOException {     ResponseWriter writer = context.getResponseWriter();\
    \     writer.startElement(\"div\", this);     writer.writeAttribute(\"role\",\
    \ \"alert\", null );     Principal principal = FacesContext.getCurrentInstance()\
    \         .getExternalContext().getUserPrincipal();     String name;     if (\
    \ principal !=null ) {       writer.writeAttribute(\"class\",\"alert  alert-success\"\
    ,null);       name = principal.getName();     }     else {       writer.writeAttribute(\"\
    class\",\"alert  alert-danger\",null);       name = \"unknown\";     }     writer.write(\
    \       String.format(\"[USER: <strong>%s</strong>] - %s\",       name, message));\
    \   }    public void encodeEnd(FacesContext context)           throws IOException\
    \ {     ResponseWriter writer = context.getResponseWriter();     writer.endElement(\"\
    div\");     writer.flush();   }   // Getter and setter omitted } [PRE36] <html\
    \      ...          >  ...     <pro:infoSec message=\"Hello world component\"\
    \ /> [PRE37] <div class=\"alert alert-success\" role=\"alert\">   [USER: <strong>unknown</strong>]\
    \ - Hello world component </div> [PRE38]`"
  prefs: []
  type: TYPE_NORMAL
