<html><head></head><body>
		<div id="_idContainer012">
			<h1 class="chapter-number" id="_idParaDest-75"><a id="_idTextAnchor074"/>4</h1>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/>Java Object Pooling</h1>
			<p>Our mission to make our Java applications<a id="_idIndexMarker212"/> highly performant includes a look at Java <strong class="bold">object pooling</strong>. This chapter dives into the concept of object pooling in Java and how to achieve high performance with them in your <span class="No-Break">Java applications.</span></p>
			<p>The chapter begins with an explanation of object pooling<a id="_idIndexMarker213"/> and how to implement an <strong class="bold">object pool</strong> in Java. Sample code is provided to help you understand object pooling operations specific to the Java programming language. You will also have the opportunity to learn about the advantages and disadvantages of object pooling in Java. Finally, the chapter shows how you can implement performance testing with Java <span class="No-Break">object pools.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Jumping into the <span class="No-Break">object pool</span></li>
				<li>Advantages <span class="No-Break">and disadvantages</span></li>
				<li><span class="No-Break">Performance testing</span></li>
			</ul>
			<p>By the end of this chapter, you should have a strong theoretical understanding of Java object pooling as well as hands-on implementation experience. This experience can help ensure you get high performance out of your <span class="No-Break">Java applications.</span></p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Technical requirements</h1>
			<p>To follow the examples and instructions in this chapter, you will need the ability to load, edit, and run Java code. If you have not set up your development environment, please refer back to <a href="B21942_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></p>
			<p>The finished code for this chapter can be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter04"><span class="No-Break">https://github.com/PacktPublishing/High-Performance-with-Java/</span><span class="No-Break">tree/main/Chapter04</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>Jumping into the object pool</h1>
			<p>Before we jump into the object<a id="_idIndexMarker214"/> pool, let’s look at what an object <span class="No-Break">pool</span><span class="No-Break"> is.</span></p>
			<p class="callout-heading">Object pool</p>
			<p class="callout">An object pool is a collection (pool) of objects that can <span class="No-Break">be reused.</span></p>
			<p>Using object pools is an optimization approach that can positively impact the performance of an application. Instead of recreating objects every time we need them, we pool a collection of objects and simply recycle them. To help understand object pooling, consider a real-world example of a physical library. The library can lend out books (our objects) and return them to the collection (our pool) when the person is done with the book. This allows the library to reissue the book to the next person that needs it. Consider the alternative. If the library destroyed (garbage collection) the book after each use, it would have to create a new one each time it is needed. This would not <span class="No-Break">be efficient.</span></p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>Database example</h2>
			<p>A common object pooling implementation<a id="_idIndexMarker215"/> in Java programming is with database connections. The typical approach to database connections is to open a connection to the database and then perform the desired operations to update or query the database. The <strong class="bold">open-query-close</strong> process is used. The problem<a id="_idIndexMarker216"/> with this approach is that opening and closing databases frequently can impact the overall performance of the Java application. This processing overhead is something we should try <span class="No-Break">to avoid.</span></p>
			<p>The object pooling approach, with our database example, involves maintaining a pool of pre-created database requests that are idle. When the app signals a request for a database connection, one is used from the pool. The next section demonstrates how to create and use these pools in a <span class="No-Break">Java application.</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Implementing an object pool in Java</h2>
			<p>Implementing an object pool, based<a id="_idIndexMarker217"/> on the database connection example<a id="_idIndexMarker218"/> from the previous section, involves a database connection class, an object pool class, and a class that contains a <strong class="source-inline">main()</strong> method. Let’s look at each of <span class="No-Break">these individually.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">This example simulates object pooling and does not connect to an <span class="No-Break">actual database.</span></p>
			<p>First, we have our <strong class="source-inline">DBConnect</strong> class. This is the class that we <span class="No-Break">will pool:</span></p>
			<pre class="source-code">
public class DBConnect {
  static int dbConnectionCount = 0;
  private int dbConnectID;
  public DBConnect() {
    this.dbConnectID = ++dbConnectionCount;
    System.out.println("Database connection created: DBConnect" + 
    dbConnectID + ".");
  }
  public void dbMethod() {
    // placeholder
  }
  public void dbConnectionClose() {
    System.out.println("Database connection closed: DBConnect" + 
    dbConnectID + ".");
  }
}</pre>			<p>As you can see by the preceding<a id="_idIndexMarker219"/> code, there are placeholders<a id="_idIndexMarker220"/> <span class="No-Break">for functionality.</span></p>
			<p>Next, we create a <strong class="source-inline">DBConnectObjectPool</strong> class to maintain a collection (pool) of <span class="No-Break"><strong class="source-inline">DBConnect</strong></span><span class="No-Break"> objects:</span></p>
			<pre class="source-code">
import java.util.LinkedList;
import java.util.Queue;
public class DBConnectObjectPool {
  private final Queue&lt;DBConnect&gt; pool;
  private final int maxSize;
  public DBConnectObjectPool(int size) {
    this.maxSize = size;
    this.pool = new LinkedList&lt;&gt;();
  }
  public synchronized DBConnect getConnection() {
    if (pool.isEmpty()) {
      if (DBConnect.dbConnectionCount &lt; maxSize) {
        return new DBConnect();
      }
      throw new RuntimeException("Error: Maximum object pool size 
      reached. There are no DB connections available.");
    }
    return pool.poll();
  }
  public synchronized void releaseConnection(DBConnect dbConnection) {
    if (pool.size() &lt; maxSize) {
      pool.offer(dbConnection);
      System.out.println("Splash: Connection object returned to the 
      pool.");
    } else {
      dbConnection.dbConnectionClose();
    }
  }
}</pre>			<p>As shown in the preceding<a id="_idIndexMarker221"/> code, we assume a maximum number<a id="_idIndexMarker222"/> of connections. This is considered a <span class="No-Break">best practice.</span></p>
			<p>Lastly, we have a partial application to demonstrate how to use our <span class="No-Break">object pool:</span></p>
			<pre class="source-code">
public class ObjectPoolDemoApp {
  public static void main(String[] args) {
    DBConnectObjectPool objectPool = new DBConnectObjectPool(8);
    for (int i = 0; i &lt; 10; i++) {
      DBConnect conn = objectPool.getConnection();
      conn.dbMethod();
      objectPool.releaseConnection(conn);
    }
  }
}</pre>			<p>When our application requests a database connection, one is provided from the pool. In the case when a connection is not available from the pool, a new one is created. We do check to ensure that we do not exceed<a id="_idIndexMarker223"/> the maximum number <a id="_idIndexMarker224"/>of allowed connections. Lastly, after a <strong class="source-inline">DBConnect</strong> object is used, it is returned to the <span class="No-Break">object pool.</span></p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Advantages and disadvantages of object pooling</h1>
			<p>Now that you understand what object pooling is and how to implement it in Java, we should consider if this is the right strategy for our application. With most application code optimization approaches, there are both advantages and disadvantages. This section looks <span class="No-Break">at both.</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Advantages</h2>
			<p>There are several potential <a id="_idIndexMarker225"/>advantages of using object pooling. These advantages can be grouped into performance, resource management, and <span class="No-Break">scalability categories.</span></p>
			<h3>Performance advantages</h3>
			<p>Implementing object pooling stands to allow us to avoid the overhead from object creation. This approach is especially useful in high transaction applications and when system response time is important. Through object pooling, we can help ensure our Java applications are able to be more performant by avoiding excessive <span class="No-Break">object creation.</span></p>
			<p>We can also experience consistent performance between app usage. For example, using object pooling should result in consistent app performance with both a minimal load and a heavy load. This predictable behavior is possible due to the stability of our application. That stability is enabled by avoiding frequent object creation and a heavy reliance on <span class="No-Break">garbage collection.</span></p>
			<h3>Resource management advantages</h3>
			<p>In the context of object pooling advantages, a resource refers to real time, processing load, and memory. Reducing the number of object creation and destruction operations is a benefit of the object pooling approach. The example used earlier in this chapter was with database connections. That example was used because database connection operations are notoriously resource hogs. The object pooling approach reduces the time it takes to perform these operations and is less <span class="No-Break">resource intensive.</span></p>
			<p>Another resource management advantage is that it increases our memory management schema. When object creation is not controlled, the amount of memory consumed is variable and could result in <span class="No-Break">system errors.</span></p>
			<h3>Scalability advantages</h3>
			<p>The third category of advantages is the ability for our applications to be more scalable. This is especially true when we have applications with a large number of simultaneous users. It is also beneficial when dealing with database connections where the database is a shared resource. The object pool essentially serves as a buffer for <span class="No-Break">those requests.</span></p>
			<p>Another reason our applications<a id="_idIndexMarker226"/> that use object pooling are more scalable is the increased amount of control we have with our resources. In the database connection example presented earlier in this chapter, we set the maximum number of objects that could be in <span class="No-Break">the pool.</span></p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/>Disadvantages</h2>
			<p>Unfortunately, there are more potential<a id="_idIndexMarker227"/> disadvantages to using object pooling than there are advantages. These disadvantages can be grouped into code complexity and resource <span class="No-Break">management categories.</span></p>
			<h3>Code complexity disadvantages</h3>
			<p>Like with any non-standard programming approach, object pooling adds complexity to our code. We create our object pooling-related classes, which must contain algorithms to manage the object pool and interfaces with the main program. Although it is not apt to result in bloated code, it can make it difficult <span class="No-Break">to maintain.</span></p>
			<p>Object pooling, when implemented in a Java application, adds another component to test each time the system, connected systems, or data changes. This can be time and <span class="No-Break">resource intensive.</span></p>
			<h3>Resource management disadvantages</h3>
			<p>There is always a risk, especially during peak load times, of having enough available resources. When we set a maximum size of our object pools, they might not be sufficient to handle those peak load times. This can also be referred to as <strong class="bold">resource starvation</strong> because all objects in our pool<a id="_idIndexMarker228"/> have been allocated, preventing new requests from being queued. These delays can result in overall performance lag and <span class="No-Break">user dissatisfaction.</span></p>
			<p>Working with memory allocation and deallocation can be problematic. If we do not, for example, manage how objects are returned to the pool, there could be data loss. This could compound a situation where there are no objects available in the pool. Implementing error checking and exception handling <span class="No-Break">becomes critical.</span></p>
			<p>Finally, we need to maintain the balance of an object pool being too large or too small. If it is too small, it could result in extensive queue times for pooled objects. If the pool is too large, the application might overconsume memory, taking away from other areas of the application that could make<a id="_idIndexMarker229"/> use <span class="No-Break">of it.</span></p>
			<p>After looking at both the advantages and disadvantages, you should be able to determine whether object pooling is ideally suited for <span class="No-Break">your application.</span></p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Performance testing</h1>
			<p>When we implement object pooling<a id="_idIndexMarker230"/> in our Java applications, we want to do <span class="No-Break">three things:</span></p>
			<ul>
				<li>Ensure our <span class="No-Break">program works</span></li>
				<li>Prove that our implementation resulted in <span class="No-Break">greater performance</span></li>
				<li>Quantify <span class="No-Break">the optimization</span></li>
			</ul>
			<p>In previous sections, we looked at how to implement object pools in Java. In this section, we will look at how to design a performance test, how to implement the object pooling performance test, and how to analyze the <span class="No-Break">testing results.</span></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>Designing a performance test</h2>
			<p>After we decide to implement<a id="_idIndexMarker231"/> a performance test, our first action is to design the test. The questions we need to answer here include <span class="No-Break">the following:</span></p>
			<ul>
				<li>What is <span class="No-Break">our goal?</span></li>
				<li>What will <span class="No-Break">we measure?</span></li>
				<li>How will <span class="No-Break">we measure?</span></li>
				<li>What conditions will exist for <span class="No-Break">our tests?</span></li>
			</ul>
			<p>With these questions in mind, we can start designing our performance test. We should have a clear goal or set of goals for our performance test. We might, for example, want to focus on system memory, CPU load, and <span class="No-Break">so on.</span></p>
			<p>Once we have a specific goal, we must decide what to measure. In testing, what<a id="_idIndexMarker232"/> we measure are considered <strong class="bold">key performance indicators</strong> (<strong class="bold">KPIs</strong>). The performance testing of object pools might be memory usage, CPU use, data throughput, and response time. These are just <span class="No-Break">some examples.</span></p>
			<p>Next, we will need to set<a id="_idIndexMarker233"/> up our test environment and create test scenarios. The test environment closely replicates the production system. You might duplicate your system in a development environment, so the live system is not impacted. Likewise, the test scenarios should closely resemble the real-world use of your system. To the extent possible, we should create as many different scenarios as needed to represent what our live <span class="No-Break">system handles.</span></p>
			<p>At this point, you are ready to document your test plan and implement it. The next section covers how to implement a <span class="No-Break">performance test.</span></p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/>Implementing a performance test</h2>
			<p>Implementing your test plan<a id="_idIndexMarker234"/> should not be terribly difficult. Here, you are simply putting your plan into action. The test environment is established, and you run your test scenarios. As the test is running, you should be collecting the data for later analysis. Of critical importance is the ability to reproduce your test conditions to support future <span class="No-Break">comparative tests.</span></p>
			<p>Let’s look at how a performance test might be written in Java using the database connection example from this chapter. We will set the goal of decreasing the time our application takes to obtain a database connection from our object pool and perform a simple operation on that database. Our test plan will compare the results of our test with the same test on a version of our application that does not implement an <span class="No-Break">object pool.</span></p>
			<p>Our code starts with the class declaration and <span class="No-Break">class variables:</span></p>
			<pre class="source-code">
public class DBConnectionPerformanceTest {
  private static final int NUMBER_OF_TESTS = 3000;
  private static DBConnectObjectPool dbPool = new 
  DBConnectObjectPool(24);</pre>			<p>Next, we will write the first<a id="_idIndexMarker235"/> part of the <strong class="source-inline">main()</strong> method. This first snippet of code will be how we perform the test with our <span class="No-Break">object pool:</span></p>
			<pre class="source-code">
public static void main(String[] args) {
  long startTime_withPooling = System.nanoTime();
  for (int i = 0; i &lt; NUMBER_OF_TESTS; i++) {
    DBConnect conn = dbPool.getConnection();
    conn.dbMethod();
    dbPool.releaseConnection(conn);
  }
  long endTime_withPooling = System.nanoTime();</pre>			<p>Now, we will write the code to test without using the <span class="No-Break">object pool:</span></p>
			<pre class="source-code">
long startTime_withoutPooling = System.nanoTime();
  for (int i = 0; i &lt; NUMBER_OF_TESTS; i++) {
    DBConnect conn = new DBConnect();
    conn.dbMethod();
    conn.dbConnectionClose();
  }
long endTime_withoutPooling = System.nanoTime();</pre>			<p>With both sets of performance testing written, we need to add the ability to calculate and output the results. We generate the results by simply subtracting the <strong class="source-inline">startTime</strong> value from the <strong class="source-inline">endTime</strong> value and converting it to milliseconds. We then output the results to <span class="No-Break">the console:</span></p>
			<pre class="source-code">
long totalTime_withPooling = (endTime_withPooling - startTime_withPooling) / 1_000_000;
long totalTime_withoutPooling = (endTime_withoutPooling - startTime_withoutPooling) / 1_000_000;
System.out.println("Total time with object pooling: " + totalTime_withPooling + " ms");
System.out.println("Total time without object pooling: " + totalTime_withoutPooling + " ms");</pre>			<p>This simple example of an object pool performance test is intended to give you a general idea of how to code these tests. Every application<a id="_idIndexMarker236"/> is different and how you write your performance tests <span class="No-Break">will vary.</span></p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>Analyzing the results</h2>
			<p>Once our tests have concluded, we can<a id="_idIndexMarker237"/> analyze the results. How you analyze the results will depend on your goals and KPIs. The analysis task should not be rushed. Remember, you collected this data so it could help inform your decision on your object pool. The complexity will vary based on the performance <span class="No-Break">test plan.</span></p>
			<p>Given the database connection example, we can simply add it to the bottom of our <strong class="source-inline">DBConnectionPerformanceTest</strong> class to compare the two sets of results. Here is the first section of <span class="No-Break">that code:</span></p>
			<pre class="source-code">
if (totalTime_withPooling &lt; totalTime_withoutPooling) {
  System.out.println("Results with object pooling: " + totalTime_
  withPooling);
  System.out.println("Results without object pooling: " + totalTime_
  withoutPooling);
  System.out.println("Analysis: Object pooling is faster by " + 
  (totalTime_withoutPooling - totalTime_withPooling) + " ms");
}</pre>			<p>As you can see, we simply check to see whether <strong class="source-inline">totalTime_withPooling</strong> is less than <strong class="source-inline">totalTime_withoutPooling</strong>. If this is the case, the relevant results are displayed on <span class="No-Break">the console.</span></p>
			<p>Next, we will check to see whether <strong class="source-inline">totalTime_withPooling</strong> is greater than <strong class="source-inline">totalTime_withoutPooling</strong>. The relevant results are displayed on <span class="No-Break">the console:</span></p>
			<pre class="source-code">
} else if (totalTime_withPooling &gt; totalTime_withoutPooling) {
  System.out.println("Results with object pooling: " + totalTime_
  withPooling);
  System.out.println("Results without object pooling: " + totalTime_
  withoutPooling);
  System.out.println("Analysis: Object pooling is slower by " + 
  (totalTime_withPooling - totalTime_withoutPooling) + " ms");
}</pre>			<p>Our final code snippet executes when the first two conditions are not met. This means that both tests took the same amount <span class="No-Break">of time:</span></p>
			<pre class="source-code">
} else {
  System.out.println("Results with object pooling: " + totalTime_
  withPooling);
  System.out.println("Results without object pooling: " + totalTime_
  withoutPooling);
  System.out.println("Analysis: No significant time difference between 
  object pooling and non-pooling.");
}</pre>			<p>As with all testing, you should<a id="_idIndexMarker238"/> document your plan, the test results, your analysis, your conclusions, and your actions following the testing. This robust documentation approach will help you retain the history of your testing <span class="No-Break">in detail.</span></p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor087"/>Summary</h1>
			<p>This chapter took an in-depth look at Java object pooling. It was suggested that object pooling is an important technique for ensuring our Java applications perform at a high level. Armed with theoretical knowledge, the chapter explored the advantages and disadvantages of object pooling. We focused on areas such as memory, CPU use, and code complexity. Finally, we demonstrated how to create a performance testing plan, how to implement it, and how to analyze <span class="No-Break">the results.</span></p>
			<p>In the next chapter, we will focus on algorithm efficiencies. Our goal will be to ensure our algorithms have low time complexities. The chapter will demonstrate inefficient algorithms and how to transform them to support <span class="No-Break">high performance.</span></p>
		</div>
	</body></html>