<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Hash Tables and Binary Search Trees</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the preceding chapter, we introduced the concept of data structures by looking at arrays, linked lists, queues, and stacks. In this chapter, we will use some of these primitive structures to build more complex ones. We'll start the chapter by looking at hash tables, which are useful data structures for fast key-value lookup. In the second part of the chapter, we will learn about a more complex data structure that supports range queries, called binary trees.</p>
<p class="mce-root"><span class="calibre14">By the end of this chapter, you will be able to:<br class="calibre7"/></span></p>
<ul class="calibre12">
<li class="calibre13"><span class="calibre10">Describe how hash tables work</span></li>
<li class="calibre13"><span class="calibre10">Implement two main techniques to deal with hash collisions</span></li>
<li class="calibre13"><span class="calibre10">Characterize different hashing choices</span></li>
<li class="calibre13"><span class="calibre10">Explain the terminology, structure, and operations of binary trees</span></li>
<li class="calibre13"><span class="calibre10">Demonstrate various tree traversal techniques</span></li>
<li class="calibre13"><span class="calibre10">Define balanced binary search trees</span></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Introducing Hash Tables</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A data structure that gives us the ability to insert, search, and optionally delete elements in a collection is called a <strong class="calibre6">data dictionary</strong>. Commonly, the type of data used is a key-value pair association, where we insert the key-value pair but search using a key to obtain the value.</p>
<p class="mce-root">Hash tables provide us with a fast data structure for organizing these key value pairs and implementing our data dictionary. They are useful in a wide variety of applications due to the quick lookup and ease of use for in-memory data storage. Insertion and search operations have a typical average runtime complexity of <em class="calibre19">O(1)</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Understanding Hash Tables</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's look at an example problem to help us understand the need for hash tables. Imagine you are a teacher, instructing a class of a maximum capacity of 30 students. The students sit at their assigned desks every day. To make your life easier, you decide to assign a sequential number from one to 30 to each desk. You then use this number to identify each student, and use your self-developed app to bring up the student's records after you enter the desk number (see <em class="calibre19">Figure 3.1</em>). This way, you can quickly look up details such as the student's name, date of birth, notes, and exam history:</p>
<p class="cdpaligncenter"><img src="Images/edfe6217-a5f9-4529-90a1-38aee455f640.png" width="764" height="463" class="calibre53"/></p>
<div class="packt_figref"><span class="calibre10">Figure 3.1: App for displaying student's records for student at desk number eight</span></div>
<p class="mce-root"><span class="calibre14">In this problem, a simple array can be used to store all students' records in memory. Each of the array's positions can contain one student record. This would allow you to access the array directly using a strategy of</span> <em class="calibre19"><span class="calibre14">index = deskNumber - 1</span></em><span class="calibre14">. If, in a particular year you have fewer students, and not all the desks are occupied, you will place nulls at the corresponding array index. This solution is shown in</span> <em class="calibre19"><span class="calibre14">Figure 3.2</span></em><span class="calibre14">.</span></p>
<p class="mce-root"><span class="calibre14">This is an example of direct addressing, where each student's record is accessed using a key (the desk number). This type of solution can only be used when the possible key range is small enough to fit in an array which is directly in memory:</span></p>
<p class="cdpaligncenter"><img src="Images/738f0a76-df15-4b08-b50f-cab05fce1cec.png" width="1404" height="708" class="calibre54"/></p>
<div class="packt_figref"><span class="calibre10">Figure 3.2: Example of direct addressing</span></div>
<p class="mce-root">To help us determine how efficiently we are using memory, we can measure the load factor. The load factor is simply a metric showing how fully utilized our data structure is. When the class is at max capacity, all the elements in the array will contain a record. We say that the load factor of our data structure is 1 (or at 100%). If, for example, only 15 students out of 30 spaces have registered for a particular year, the load factor is 0.5 (50%). A lower load factor value means that we are under-utilizing and wasting memory.</p>
<p class="mce-root">Now, let's expand our example to include not just a class but an entire school, and instead of teaching one class, you have now been promoted to the head of the entire school. In this new position, you want to keep student records for every person currently enrolled. You also want to store historical records for any past students that are no longer in the school. You decide to use the national ID or passport number as a key to uniquely identify each one of your students. Assuming this is a US or an EU school, the national ID or passport number typically consists of nine numeric digits or more.</p>
<p class="mce-root">Since our input range is quite big, directly addressing this would be very impractical.</p>
<div class="packt_infobox">Since the US passport number (or national ID) is typically nine numeric digits, we would have to construct a huge array to store any possible number. For a nine-digit numeric range, the array's size would be 1,000,000,000. Assuming each pointer is four bytes, this array alone would  consume almost 4 GB! The load factor of this example would also be terribly low. Most of the array will be empty, as the school will only have a few thousand present and past students.<span class="calibre10"><br class="calibre2"/></span></div>
<p class="mce-root">We can still store the students' records in an array sized to a few thousand. All we need to do is find a way to squeeze our input key range into our array index range. Essentially, this means mapping our nine-digit numeric passport into a four-digit one. This job can be done by what is known as a hash function. A hash function would accept a key (our passport number) and return an array index within the size of our array (see <em class="calibre19">Figure 3.3</em>).</p>
<p class="mce-root">We say that a hash function maps our input key universe to our chosen hash range, which in this example is our array size:</p>
<p class="cdpaligncenter"><img src="Images/6a09b166-4f1a-4a62-8b2c-0f819930271f.png" width="1403" height="593" class="calibre55"/></p>
<div class="packt_figref"><span class="calibre10">Figure 3.3: Using hash functions</span></div>
<p class="mce-root"/>
<p class="mce-root">Using a hash function enables us to use a much smaller array and saves us a lot of memory. However, there is a catch. Since we are forcing a bigger key space into a smaller one, there is a risk that multiple keys map to the same hashed array index. This is what is called a <strong class="calibre6">collision</strong>; we have a key hash to an already filled position. The strategy on how to deal with collisions together with the choice of hash function make up our hash table. The following code snippet shows a Java interface that defines our hash table API. We will gradually implement this interface in later sections of this chapter:</p>
<pre class="calibre20"><span class="calibre10">public interface HashTable&lt;K,V&gt; {<br class="calibre2"/>  void put(K key,V value);<br class="calibre2"/>  Optional&lt;V&gt; get(K key);<br class="calibre2"/>  void remove(K key);<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 3.1: Hashtable interface. Source class name:</span> <span class="calibre10">Hashtable</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/FK1q6k" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/FK1q6k</span></a> <span class="calibre10">to access this code.</span></div>
<p class="mce-root">In Java, the classes <kbd class="calibre15">java.util.Hashtable</kbd> and <kbd class="calibre15">java.util.HashMap</kbd> both implement the interface <kbd class="calibre15">HashTable</kbd>. The main difference between the two classes is that the <kbd class="calibre15">HashMap</kbd> is unsynchronized and permits nulls.</p>
<p class="mce-root">In this section, we first introduced direct addressing by looking at an example scenario. Later, we expanded the problem to a bigger key space, showing how hash tables can be used in such a scenario. In the next section, we will see two common solutions for dealing with hash table collisions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Dealing with Collisions with Chaining</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">What do we do when two keys hash to the same slot in our array? Overwriting the element in our array is not an option as this would mean losing records. One common solution to deal with collisions is a technique called <strong class="calibre6">chaining</strong>. In this solution, the hash table data is stored outside the actual array itself.</p>
<p class="mce-root">The idea behind chaining is that each entry in our hash array has a pointer to its own linked list. Any items we add to our hash table are stored in these linked lists. Initially, every entry in the array is initialized to contain an empty linked list. Whenever we insert a particular array slot in the hash table, we insert it at the head of the linked list associated with that position. In this way, we can support hash collisions. Another insert, on an already occupied array slot, would result in a new item at the head of its linked list. <em class="calibre19">Figure 3.4</em> shows an example in which two entries with different keys have hashed to the same array slot, resulting in the two records stored in the linked list:</p>
<p class="cdpaligncenter"><img src="Images/31c99548-bf7a-480e-bf9c-537ea923bc44.png" width="1398" height="592" class="calibre56"/></p>
<div class="packt_figref"><span class="calibre10">Figure 3.4: Using linked lists to chain multiple entries in one hash slot</span></div>
<p class="mce-root">Searching for a particular key requires first locating the array slot, and then traversing the linked list, one item at a time, looking for the required key until there is a match or the end of the list is reached. <em class="calibre19">Snippet 3.2</em> shows the search (<kbd class="calibre15">get</kbd>) and insert (<kbd class="calibre15">put</kbd>). The delete (<kbd class="calibre15">remove</kbd>) operation can be found by the URL provided after the snippet. We make use of Java's linked list collection for this hash table implementation. In the constructor, the array is initialized with the given capacity, and each element is filled with an empty linked list.</p>
<p class="mce-root">Using the Java linked list collections enables us to use Java's lambda expressions when searching for the key in the <kbd class="calibre15">get(key)</kbd> method. When searching, we try to match the key with the ones found in the linked list and only return the optional value if a match is found.</p>
<p class="mce-root">Using the lambda expressions also enables us to implement the <kbd class="calibre15">delete</kbd> operation in a clean manner by just calling the <kbd class="calibre15">removeif()</kbd> method with a key-matching predicate (the <kbd class="calibre15">delete</kbd> operation can be found by the URL provided after the code snippet):</p>
<pre class="calibre20"><span class="calibre10">public void put(K key, V value) {<br class="calibre2"/>  int hashValue = hashProvider.hashKey(key, array.length);<br class="calibre2"/>  array[hashValue].addFirst(new Pair&lt;&gt;(key, value));<br class="calibre2"/>}<br class="calibre2"/>public Optional&lt;V&gt; get(K key) {<br class="calibre2"/>  int hashValue = hashProvider.hashKey(key, array.length);<br class="calibre2"/>  return array[hashValue].stream()<br class="calibre2"/>    .filter(keyValue -&gt; keyValue.getKey().equals(key))<br class="calibre2"/>    .findFirst()<br class="calibre2"/>    .map(Pair::getValue);<br class="calibre2"/></span><span class="calibre10">}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 3.2: The chained hash table. Source class name:</span> <span class="calibre10">ChainedHashTable</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/mrzQfY" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/mrzQfY</span></a> <span class="calibre10">to access this code.</span><span class="calibre10"><br class="calibre2"/></span></div>
<p class="mce-root">The best case runtime complexity for the search operation (<kbd class="calibre15">get()</kbd> method) shown in <em class="calibre19">Snippet 3.2</em> when the hash table contains <em class="calibre19">n</em> items is when we have no collisions, resulting in <em class="calibre19">O(1)</em>, and the worst is when we have n collisions, resulting in <em class="calibre19">O(n)</em>.</p>
<p class="mce-root">The <kbd class="calibre15">HashProvider</kbd> interface shown in <em class="calibre19">Snippet 3.2</em> simply provides us with a method that implements a hash function. We will implement this interface in the following sections when we explore different hash techniques. The runtime complexity for the chained hash table is dictated by how long our linked lists get. The best case is when every single item we insert in the hash table hashes to a different slot, that is, when there are no collisions. In the best case, we have a runtime of <em class="calibre19">O(1)</em> when each linked list only contains one item, and we can directly access any item.</p>
<p class="mce-root">The worst-case is the other extreme, when every single item hashes to the same value, resulting in a linked list with n items. When this happens, the performance degrades to <em class="calibre19">O(n)</em> time to search for the required key. This is because we need to traverse the linked list of <em class="calibre19">n</em> nodes to search the required key.</p>
<p class="mce-root">This worst runtime complexity of <em class="calibre19">O(n)</em> is applicable to all hash tables, not just chained ones. However, on average, and if the right hash function is chosen, the runtime performance of hash tables can be close to <em class="calibre19">O(1)</em>.</p>
<div class="packt_infobox"><span class="calibre10">A chained hash table has no load limit. Even in situations where none of the slots are empty, we can still add more items to the hash tables by continuing to append to the linked lists. This means that the load factor of a chained hash table can exceed the value of 1.</span></div>
<p class="mce-root">Chained hash tables are the most popular collision resolution implementation. The reason for this is that they are easy to implement, provide a good performance, and unlike some other techniques, allow the hash table structure to scale dynamically, and grow beyond the load factor of <em class="calibre19">1</em>. In the next section, we will discuss another solution dealing with collisions, called <strong class="calibre6">open addressing</strong>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Dealing with Collisions with Open Addressing</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the previous section, we saw how we can deal with collisions using linked lists at each array position. A chained hash table will keep on growing without any load limit. Open addressing is just another way of tackling hash collisions. In open addressing, all items are stored in the array itself, making the structure static with a maximum load factor limit of <em class="calibre19">1</em>. This means that once the array is full, you can't add any more items. The advantage of using open addressing is that, since you're not using linked lists, you're saving a bit of memory since you don't have to store any pointer references.</p>
<p class="mce-root">You can then use this extra memory to have an even larger array and hold more of your key value pairs. To insert in an open-addressed hash table, we hash the key and simply insert the item in the hash slot, the same as a normal hash table. If the slot is already occupied, we search for another empty slot and insert the item in it. The manner in which we search for another empty slot is called the <strong class="calibre6">probe sequence</strong>.</p>
<p class="mce-root">A simple strategy, shown in <em class="calibre19">Figure 3.5</em>, is to search by looking at the next available slot. This is called <strong class="calibre6">linear probing</strong>, where we start from the array index at the hash value and keep on increasing the index by one until we find an empty slot. The same probing technique needs to be used when searching for a key. We start from the hash slot and keep on advancing until we match the key or encounter an empty slot:</p>
<p class="cdpaligncenter"><img src="Images/7091d53a-8d89-4771-b0ac-6a3fc775c52e.png" width="1663" height="498" class="calibre57"/></p>
<div class="packt_figref"><span class="calibre10">Figure 3.5: Linear probing in open addressing</span></div>
<p class="mce-root">The next code snippet shows the pseudocode for linear probing insert. In this code, after we find the hash value we keep on increasing a pointer by one, searching for an empty slot.</p>
<p class="mce-root">Once we reach the end of the array, we wrap around to the start using the <em class="calibre19">modulus</em> operator. This technique is similar to one we used when we implemented array-based stacks. We stop increasing the array pointer either when we find a null value (empty slot) or when we get back to where we started, meaning the hash table is full. Once we exit the loop, we store the key-value pair, but only if the hash table is not full.</p>
<p class="mce-root">The pseudocode is as follows:</p>
<pre class="calibre20"><span class="calibre10">insert(key, value, array)<br class="calibre2"/>  s = length(array)<br class="calibre2"/>  hashValue = hash(key, s)<br class="calibre2"/>  i = 0<br class="calibre2"/>  while (i &lt; s and array[(hashValue + i) mod s] != null)<br class="calibre2"/>    i = i + 1<br class="calibre2"/>  if (i &lt; s) array[(hashValue + i) mod s] = (key, value)</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 3.3: Pseudocode for inserting using linear probing</span></div>
<p class="mce-root">Searching for a key is similar to the insert operation. We first need to find the hash value from the key and then search the array in a linear fashion until we encounter the key, find a null value, or traverse the length of the array.</p>
<p class="mce-root">If we want to delete items from our open, addressed hash table, we cannot simply remove the entry from our array and mark it as null. If we did this, the search operation would not be able to check all possible array positions for which the key might have been found. This is because the search operation stops as soon as it finds a null.</p>
<p class="mce-root">One solution is to add a flag at each array position to signify that an item has been deleted without setting the entry to null. The search operation can then be modified to continue past entries marked as deleted. The insert operation also needs to be changed so that, if it encounters an entry marked as deleted, it writes the new item at that position.</p>
<p class="mce-root">Linear probing suffers from a problem called <strong class="calibre6">clustering</strong>. This occurs when a long succession of non-empty slots develop, degrading the search and insert performance. One way to improve this is to use a technique called <strong class="calibre6">quadratic probing</strong>. This strategy is similar to linear probing, except that we probe for the next empty slot using a quadratic formula of the form <em class="calibre19">h + (ai + bi<sup class="calibre32">2</sup>)</em>, where <em class="calibre19">h</em> is the initial hash value, and <em class="calibre19">a</em> and <em class="calibre19">b</em> are constants. <em class="calibre19">Figure 3.6</em> shows the difference between using linear and quadratic probing with <em class="calibre19">a = 0</em> and <em class="calibre19">b = 1</em>. The diagram shows the order in which both techniques explore the array.</p>
<p class="mce-root">In quadratic probing, we would change <em class="calibre19">Snippet 3.3</em> to check at array indexes of the following:</p>
<pre class="calibre20"> <span class="calibre10">array[(hashValue + a*i + b*i^2) mod s]</span> </pre>
<div class="cdpaligncenter1"><img src="Images/89bf429a-fa38-4aee-b961-c970c6e2ace1.png" width="1130" height="781" class="calibre58"/></div>
<div class="packt_figref"><span class="calibre10">Figure 3.6 Linear versus quadratic probing</span></div>
<div class="packt_infobox"><span class="calibre10">Although quadratic probing reduces the effect of clustering, it suffers from a problem called secondary clustering. This is a milder form of clustering, however, it will still degrade performance. In addition, the constants</span> <em class="calibre21"><span class="calibre10">a</span></em> <span class="calibre10">and</span> <em class="calibre21"><span class="calibre10">b</span></em><span class="calibre10">, and the array size need to be carefully chosen so that the probing explores the entire array.</span></div>
<p class="mce-root">One other probing strategy used in open-addressing hash tables is called <strong class="calibre6">double hashing</strong>. This makes use of another hash function to determine the step offset from the initial hash value. In double hashing, we probe the array using the expression <em class="calibre19">h + ih'(k)</em>, where <em class="calibre19">h</em> is the hash value and <em class="calibre19">h'(k)</em> is a secondary hash function applied on the key. The probing mechanism is similar to linear probing, where we start with an <em class="calibre19">i</em> of zero and increase by one on every collision. Doing so results in probing the array every <em class="calibre19">h'(k)</em> step. The advantage of double hashing is that the probing strategy changes on every key insert, reducing the chances of clustering.</p>
<p class="mce-root">In double hashing, care must be taken to ensure that the entire array is explored. This can be achieved using various tricks. For example, we can size our array to an even number and make sure the secondary hash function returns only odd numbers.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Carrying out the Linear Probing Search Operation</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre14">The aim here is to develop pseudocode for the search operation in linear probing.</span></p>
<p class="mce-root">Perform the following steps:</p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Write pseudocode similar to</span> <em class="calibre21"><span class="calibre10">Snippet 3.3</span></em> <span class="calibre10">to show the search operation. The operation should return null if the key is not found in the hash table. The search function should have a signature as follows:</span></li>
</ol>
<pre class="calibre30"> <span class="calibre10">search(key, array)</span>  </pre>
<ol start="2" class="calibre17">
<li class="chapter"><span class="calibre10">The pseudocode can be developed as follows:</span></li>
</ol>
<pre class="calibre30"><span class="calibre10">search(key, array)<br class="calibre2"/>s = length(array)<br class="calibre2"/>hashValue = hash(key, s)<br class="calibre2"/>i = 0<br class="calibre2"/>while (i &lt; s and array[(hashValue + i) mod s] != null<br class="calibre2"/>  and array[(hashValue + i) mod s].key != key)<br class="calibre2"/>  i = i + 1<br class="calibre2"/>keyValue = array[(hashValue + i) mod s]<br class="calibre2"/>if (keyValue != null &amp;&amp; keyValue.key == key) <br class="calibre2"/></span></pre>
<pre class="calibre30"><span class="calibre10">  return keyValue.value<br class="calibre2"/>else return null <br class="calibre2"/></span></pre>
<div class="packt_figref"><span class="calibre10">Snippet 3.4: Solution pseudocode for searching using linear probing</span></div>
<p class="mce-root">In this section, we have seen another manner for dealing with hash collisions by keeping all items in the array itself, saving memory, but limiting the structure statically. In the next subsection, we shall go into detail about some of the various hash functions available.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Remainder and Multiplication Hash Functions</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">For hash tables, a hash function maps a specific key's space into a smaller number range. More formally, a hash function, <em class="calibre19">f</em>, maps keys of a specific data type to integers in a fixed interval <em class="calibre19">[0,..., N - 1]</em>. We say <em class="calibre19">f(x)</em> hashes the value of <em class="calibre19">x</em>.</p>
<p class="mce-root">The hash function can accept only numeric data types. To allow us to use hash tables on more complex data types, we usually need to convert all these types into numeric representations. This translation varies, depending on the type of data. For example, a character can be changed into its UTF-8 (or ASCII) numeric equivalent. Converting a full string can be done by converting each character separately and then using a strategy to combine the characters into one value.</p>
<div class="packt_infobox">In Java, the <kbd class="calibre31">hashCode()</kbd> method converts an object into a numeric representation, which is ready to be used by a hash function. It is present in the object class and can be overridden using a custom implementation.</div>
<p class="mce-root">There are many techniques on how we can map keys from a wide range into smaller ones. An ideal hash function is one that reduces collisions to a minimum. In other words, when a good hash function is used, each key has the same probability of filling any of the slots in our array. In practice, finding an ideal hash function is very difficult unless we know the input distribution.</p>
<p class="mce-root">A simple technique to implement a hash function is what is known as the <strong class="calibre6">remainder method</strong>. The hash function simply takes in any numeric key, divides it by the table size (size of the array), and uses the resultant remainder as the hash value. This value can then be used as an index on the array.</p>
<p class="mce-root">The following code shows how the remainder hashing method can be implemented in Java using the modulus operator:</p>
<pre class="calibre20"><span class="calibre10">public int hashKey(Integer key, int tableSize) {<br class="calibre2"/>  return key % tableSize;<br class="calibre2"/></span><span class="calibre10">}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 3.5: The remainder method. Source class name:</span> <span class="calibre10">RemainderHashing</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/wNyWWX" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/wNyWWX</span></a> <span class="calibre10">to access this code.</span></div>
<p class="mce-root">The reminder method might result in many collisions if care is not taken when choosing an appropriate table size. Once again, consider the example given in the beginning of this section where we are using the student's passport or national ID number to identify a student in the school. To demonstrate the problem, we use an array-based hash table with a size of 1,000 elements. It just so happens that in the country where the school is based, the last four digits of the passport numbers represent the year of birth of the passport holder.</p>
<p class="mce-root">When using the remainder method in this scenario, all the students with the same year of birth will hash to the same value, causing a lot of collisions on the hash table.<span class="calibre14"><br class="calibre7"/></span></p>
<p class="mce-root">A better choice of a table size is to use a prime number, ideally not too close to the power of 2. For example, the value of 1,447 is a good choice in our example, since it's not too close to 1,024 or 2,048 (2<sup class="calibre32">10</sup> and 2<sup class="calibre32">11</sup>) and is also prime. Using this value as a table size for our example would reduce collisions.</p>
<p class="mce-root">Using the remainder method restricts us on the choice of size for our hash table (to reduce the chance of collisions). To address this, we can use a different hashing technique, called the <strong class="calibre6">multiplication method</strong>. In this method, we multiply the key by a constant double value, <em class="calibre19">k</em>, in the range <em class="calibre19">0 &lt; k &lt; 1</em>. We then extract the fractional part from the result and multiply it by the size of our hash table.</p>
<p class="mce-root">The hash value is then the floor of this result:</p>
<div class="cdpaligncenter1"><img class="fm-editor-equation" src="Images/3aea6a0b-1dfa-4092-9355-77455fc9f222.png" width="1900" height="204"/></div>
<p class="mce-root"><span class="calibre14">Where:</span></p>
<ul class="calibre12">
<li class="calibre13"><em class="calibre21"><span class="calibre10">k</span></em> <span class="calibre10">is a decimal in the range between 0 and 1</span></li>
<li class="calibre13"><em class="calibre21"><span class="calibre10">s</span></em> <span class="calibre10">is the size of the hash table</span></li>
<li class="calibre13"><em class="calibre21"><span class="calibre10">x</span></em> <span class="calibre10">is the key</span></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing the Multiplication Method for a Hash Table</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre14">The aim here is to develop a code in Java for implementing the multiplication method for a hash table.</span></p>
<p class="mce-root">Perform the following steps:</p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Implement a class with a method which accepts an integer and returns a hash value using the multiplication method shown in this section. The constant <em class="calibre21">k</em> is passed in as the class constructor. The method signature should be:</span></li>
</ol>
<pre class="calibre30"> <span class="calibre10">int hashKey(int key, int tableSize)</span> </pre>
<ol start="2" class="calibre17">
<li class="chapter"><span class="calibre10">The following code shows an implementation for the multiplication hash function:</span></li>
</ol>
<pre class="calibre30"><span class="calibre10">private double k;<br class="calibre2"/>public MultiplicationHashing(double k) {<br class="calibre2"/>  this.k = k;<br class="calibre2"/>}<br class="calibre2"/>public int hashKey(Integer key, int tableSize) {<br class="calibre2"/>  return (int) (tableSize * (k * key % 1));<br class="calibre2"/></span><span class="calibre10">}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 3.6: Solution for the multiplication method. Source class name: </span><span class="calibre10">MultiplicationHashing.</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/xJ7i1b" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/xJ7i1b</span></a> <span class="calibre10">to access this code.</span></div>
<p class="mce-root">In this section, we have seen two basic techniques on how to compute hash values, the remainder method and the multiplication method. Both of these strategies are widely used in hash tables.</p>
<p class="mce-root">In the next section, we will examine yet another mechanism, called <strong class="calibre6">universal hashing</strong>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Universal Hashing</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Both the remainder and multiplication hashing methods have a common vulnerability. If an attacker knows the details of our hash function (table size and any constant values), he/she could devise an input key sequence resulting in a collision on every item, turning our hash table into a linked list and slowing down our program. To address this problem, a hashing technique called universal hashing can be used.</p>
<p class="mce-root">Universal hashing works by choosing a random function from a universal set of hash functions at the start of execution. This makes it difficult for an attacker to guess the exact workings of the hashing technique used. By using this technique, the same sequence of keys will produce a different sequence of hash values on every execution.</p>
<p class="mce-root">A set of hash functions, <em class="calibre19">H</em>, with size <em class="calibre19">n</em>, where each function maps a universe of keys ∪ to a fixed range of <em class="calibre19">[0, s)</em>, is said to be universal for all pairs, where <em class="calibre19">a</em>, <em class="calibre19">b ∈ ∪</em>, <em class="calibre19">a ≠ b</em> and the probability that <em class="calibre19">h(a) = h(b)</em>, <em class="calibre19">h ∈ H</em> is less than or equal to <em class="calibre19">n/s</em>. </p>
<p class="mce-root">We can construct our set of universal hash functions by using two integer variables, <em class="calibre19">i</em> in a range of <em class="calibre19">[1, p)</em>, and <em class="calibre19">j</em> in a range of <em class="calibre19">[0, p)</em>, where <em class="calibre19">p</em> is a prime number larger than any possible value of the input key universe. We can then generate any hash function from this set using:</p>
<p class="cdpaligncenter"><img class="fm-editor-equation1" src="Images/8bb2319b-4912-42a6-b894-271b6b11f47e.png" width="1900" height="169"/></p>
<p class="mce-root"><span class="calibre14">Where</span> <em class="calibre19"><span class="calibre14">s</span></em> <span class="calibre14">is the size of the hash table and</span> <em class="calibre19"><span class="calibre14">x</span></em> <span class="calibre14">is the key.</span></p>
<p class="mce-root">The following code snippet shows a Java implementation of universal hashing suitable for integer-type keys. Note how our implementation makes use of the <kbd class="calibre15">BigInteger</kbd> class to work out the hash key. This is needed because multiplying a long Java numeric type with a large integer might result in a big enough value that exceeds the maximum capacity of a Java long. The choice of <kbd class="calibre15">p</kbd> in this method is such that any integer key input will always have a smaller value, since in Java an integer only has a maximum value of <em class="calibre19">2</em><sup class="calibre32"><em class="calibre19">31</em>:</sup></p>
<pre class="calibre20"><span class="calibre10">public UniversalHashing() {<br class="calibre2"/>  j = BigInteger.valueOf((long) (Math.random() * p));<br class="calibre2"/>  i = BigInteger.valueOf(1 + (long) (Math.random() * (p -</span>  <span class="calibre10">1L)));</span> <br class="calibre2"/><span class="calibre10">}<br class="calibre2"/>public int hashKey(Integer key, int tableSize) {<br class="calibre2"/>  return i.multiply(BigInteger.valueOf(key)).add(j)<br class="calibre2"/>    .mod(BigInteger.valueOf(p))<br class="calibre2"/></span></pre>
<pre class="calibre20"><span class="calibre10">    .mod(BigInteger.valueOf(tableSize))<br class="calibre2"/>    .intValue();<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 3.7: Universal hashing for integer keys. Source class name:</span> <span class="calibre10">UniversalHashing</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/5Kv7qG" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/5Kv7qG</span></a> <span class="calibre10">to access this code.</span></div>
<p class="mce-root">Java provides hash tables and built-in hashing mechanisms using the <kbd class="calibre15">Object.hashcode()</kbd> method. As a result of this, it is very difficult to implement a universal hashing table which integrates with Java's existing <kbd class="calibre15">hashcode()</kbd> method, since the <kbd class="calibre15">i</kbd> and <kbd class="calibre15">j</kbd> variables in the preceding code would have to be shared between different objects being inserted in the same table.</p>
<div class="packt_infobox">For more information and mathematical proofs about why we pick a larger than key prime number, refer to Carter and Wegman, <em class="calibre21">Universal Classes of Hash Functions</em>, <em class="calibre21">Journal of Computer and System Sciences</em>: <a href="https://doi.org/10.1016/0022-0000(79)90044-8" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2">https://doi.org/10.1016/0022-0000(79)90044-8</a>.<span class="calibre10"><br class="calibre2"/></span></div>
<p class="mce-root">Universal hashing provides us with good results, minimizing collisions, and is immune to malicious attacks, since the function parameters are chosen at random.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Activity: Implementing Open Addressing</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre14"><strong class="calibre6">Scenario</strong><br class="calibre7"/></span></p>
<p class="mce-root"><span class="calibre14">We have been asked to develop an algorithm to search and remove data from a hash table using the open addressing technique.<br class="calibre7"/></span></p>
<p class="mce-root"><span class="calibre14"><strong class="calibre6">Aim</strong><br class="calibre7"/></span></p>
<p class="mce-root"><span class="calibre14">To implement a hash table using open addressing with linear probing. </span></p>
<p class="mce-root"><span class="calibre14"><strong class="calibre6">Prerequisites</strong><br class="calibre7"/></span></p>
<p class="mce-root"><span class="calibre14">To solve this activity, you have to implement the methods found in the class that is available on GitHub at the following URL:</span></p>
<p class="mce-root"><a href="https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson3/activity/openaddressing/OpenAddrHashTable.java" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson3/activity/openaddressing/OpenAddrHashTable.java</a></p>
<div class="packt_infobox"><span class="calibre10">If you have your project set up, you can run the following unit test for this activity by running:<br class="calibre2"/></span><br class="calibre2"/>
<kbd class="calibre31"><strong class="calibre3">gradlew test --tests com.packt.datastructuresandalg.lesson3.activity.openaddressing*</strong></kbd></div>
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Steps for Completion</span></strong></p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Study the pseudocode shown in</span> <em class="calibre21"><span class="calibre10">Snippet 3.3</span></em> <span class="calibre10">and</span> <em class="calibre21"><span class="calibre10">Snippet 3.4</span></em></li>
<li class="chapter"><span class="calibre10">Implement them in Java</span></li>
<li class="chapter"><span class="calibre10">Create a container class that will hold your key and value in the hash table</span></li>
<li class="chapter"><span class="calibre10">Have a flag on this container to indicate when an item is deleted</span></li>
<li class="chapter"><span class="calibre10">Use this flag in the insert operation to overwrite it if it is deleted</span></li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting Started with Binary Search Trees</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Like hash tables, binary search trees are fast lookup data structures for organizing key value pairs and implement the data dictionary operations. In addition to providing insert, search, and delete, binary tree supports efficient querying such as finding minimum and maximum, successor, and predecessor. When using balanced binary search trees, insert and search operations have a worst-case runtime complexity of <em class="calibre19">O(log n)</em>. This is a big theoretical improvement over the worst-case scenario of a hash table, which is <em class="calibre19">O(n)</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Binary Tree Structure</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre14">The structure of a binary tree is composed of a series of nodes connected together via pointers.</span> <em class="calibre19"><span class="calibre14">Figure 3.8</span></em> <span class="calibre14">shows the fundamental relation between nodes. Each node can have a maximum of two child nodes, a left one and a right one.</span></p>
<p class="mce-root"><span class="calibre14">Each node (except the top-level node) also has exactly one parent:</span></p>
<p class="cdpaligncenter"><img src="Images/7ab6a211-a10f-45e0-9da5-0451b3557c4f.png" width="563" height="369" class="calibre59"/></p>
<div class="packt_figref"><span class="calibre10">Figure 3.8: Showing a simple binary tree relation</span></div>
<p class="mce-root"><em class="calibre19"><span class="calibre14">Figure 3.9</span></em> <span class="calibre14">shows some more terminology applied to binary trees. In this diagram, we also show that binary tree nodes can hold data items by showing the node storing different shapes. The top-level node is called the root node. The root node in a tree structure is the only node that doesn't have a parent. Nodes that don't have any children are called leaf nodes. The height of a tree is the number of hops</span> <span class="calibre14">it would</span> <span class="calibre14">take you to get from the root node to the furthest leaf node. The diagram shows an example of a tree which has a height of 2.</span></p>
<p class="mce-root"><span class="calibre14">The height of a tree is an important metric, as it affects the performance. The shallower a tree is (smaller height), the more performant a tree structure is.</span></p>
<p class="cdpaligncenter"><img src="Images/2182c344-d7d7-4f7e-8206-ea8eb1a98530.png" width="1257" height="685" class="calibre60"/></p>
<div class="packt_figref"><span class="calibre10">Figure 3.9: Binary tree terminology</span></div>
<p class="mce-root"><span class="calibre14">Similar to a linked list, the binary tree structure is modeled using pointers and node objects. In a linked list node, we only have a next pointer, referencing the next node in the list. Similarly, in a binary tree node we have two pointers, each one linking to one child. These are the left and right child pointers. The following code snippet shows how we can model the binary tree node using a Java class:</span></p>
<pre class="calibre20"><span class="calibre10">public class BinaryTreeNode&lt;K,V&gt; {<br class="calibre2"/>  private BinaryTreeNode&lt;K,V&gt; left;<br class="calibre2"/>  private BinaryTreeNode&lt;K,V&gt; right;<br class="calibre2"/>  private K key;<br class="calibre2"/>  private V value;<br class="calibre2"/>  public BinaryTreeNode(K key, V value) {<br class="calibre2"/>    this.key = key;<br class="calibre2"/>    this.value = value;<br class="calibre2"/></span><span class="calibre10">  }</span> </pre>
<div class="packt_figref"><span class="calibre10">Snippet 3.8: The Binary tree node class. Some getters and setters have been omitted for brevity. Source class name:</span> <span class="calibre10">BinaryTreeNode</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/D6Jvo2" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/D6Jvo2</span></a> <span class="calibre10">to access this code.</span></div>
<p class="mce-root"><span class="calibre14">We can then have another class representing the binary tree itself, where the operations will be implemented. This class only needs to hold a pointer to the root node, since any node can be reached by starting from the root node and navigating down. In the following code snippet, we show an interface declaring the binary tree:</span></p>
<pre class="calibre20"><span class="calibre10">public interface BinaryTree&lt;K,V&gt; {<br class="calibre2"/>  void put(K key,V value);<br class="calibre2"/>  Optional&lt;V&gt; get(K key);<br class="calibre2"/>}</span> </pre>
<div class="packt_figref"><span class="calibre10">Snippet 3.9: Binary tree interface. Source class name:</span> <span class="calibre10">BinaryTree.</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/jRcLhu" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/jRcLhu</span></a> <span class="calibre10">to access this code.</span></div>
<p class="mce-root">In this section, we have introduced the structure and terminology of binary trees. We then learned how to model each node using Java classes. In the next section, we will continue building on these concepts by introducing binary search trees and implementing the insert and search operations.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Binary Search Tree Operations</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Binary search trees are normal binary trees in which data is organized in an ordered manner. Consider the same problem we encountered in the previous section, of the school keeping a student's records by using the passport numbers as a key. <em class="calibre19">Figure 3.10</em> shows an example of how you can organize the data in a binary tree.</p>
<p class="mce-root">Note how at each node the left child has a key which is less than its own. On the other hand, the right child has a larger key. Shown in the diagram, the root node has a left child containing a key of a smaller value than the root key. On the other hand, the right child has a key of a larger value than the root.</p>
<p class="mce-root">This rule is repeated through the entire tree. In a binary search tree, the left child will always have a smaller key than the parent, while the right child will have a larger one. Using this binary search tree property, we can create efficient operations on the tree structure:</p>
<p class="cdpaligncenter"><img src="Images/ecfba1cb-3fe1-43ce-9cdc-b80f506be227.png" width="1050" height="768" class="calibre61"/></p>
<div class="packt_figref"><span class="calibre10">Figure 3.10: An example of a binary search tree</span></div>
<p class="mce-root">As a result of this simple rule, the tree exhibits important properties. For example, note how all the nodes that are descendants of the left child of the root node have a smaller key than the root. This property is valid for any node of the tree. All keys on the left subtree of a node will always have smaller keys, and vice versa.</p>
<p class="mce-root">Searching in a binary search tree requires us to follow some simple instructions. We start at the root and at each node, we ask ourselves: "<q class="pcalibre5 pcalibre4 calibre33">Is the key we're looking for equal to less than, or greater than the key on this node?</q>" If the key is equal, we're done and we have found our node. If the key is less, we follow the left child pointer, otherwise we follow the right one. We repeat this step until we find our key or hit a <em class="calibre19">null child pointer</em>.</p>
<p class="mce-root">Another important property of a binary search tree is being able to easily find the maximum and minimum key in the tree. Finding the maximum key in a binary tree is easy. Conceptually, this is the rightmost node. This can be found by starting at the root and always picking the right child until there isn't any right child to choose. The reverse is valid (picking the left child) for the minimum key.<span class="calibre14"><br class="calibre7"/></span></p>
<p class="mce-root">The following code snippet shows the search implementation. In this implementation, we use the power of recursion to perform the search. We start by checking if the tree is empty by checking whether the root is null. If a root node is present, we compare the key and either return the value or recursively search the child nodes. To compare the key, we assume the provided key implements the comparable interface. Using Java's optional flat mapping makes our implementation much more concise:</p>
<pre class="calibre20"><span class="calibre10">public Optional&lt;V&gt; get(K key) {<br class="calibre2"/>  return Optional.ofNullable(root).flatMap(n -&gt; get(key, n));<br class="calibre2"/>}<br class="calibre2"/>private Optional&lt;V&gt; get(K key, BinaryTreeNode&lt;K, V&gt; node) {<br class="calibre2"/>  if (((Comparable) key).compareTo(node.getKey()) == 0)<br class="calibre2"/>    return Optional.of(node.getValue());<br class="calibre2"/>  else if (((Comparable) key).compareTo(node.getKey()) &lt; 0)<br class="calibre2"/>    return node.getLeft().flatMap(n -&gt; get(key, n));<br class="calibre2"/>  else<br class="calibre2"/>    return node.getRight().flatMap(n -&gt; get(key, n));<br class="calibre2"/>}</span> </pre>
<div class="packt_figref"><span class="calibre10">Snippet 3.10: Binary search tree search operation. Source class name:</span> <span class="calibre10">SimpleBinaryTree.</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/xE2GvH" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/xE2GvH</span></a> <span class="calibre10">to access this code.</span></div>
<p class="mce-root"><span class="calibre14">Java's</span> <kbd class="calibre15"><span class="calibre10">objectA.compareTo(objectB)</span></kbd> <span class="calibre14">method in the comparable interface returns a negative integer, zero, or a positive integer as</span> <kbd class="calibre15"><span class="calibre10">objectA</span></kbd> <span class="calibre14">is less than, equal to, or greater than</span> <kbd class="calibre15"><span class="calibre10">objectB</span></kbd><span class="calibre14">. Thus, the following statement:</span></p>
<pre class="calibre20"><span class="calibre10">((Comparable) key).compareTo(node.getKey()) &lt; 0</span> </pre>
<p class="mce-root"><span class="calibre14">Is conceptually the same as the following:</span></p>
<pre class="calibre20"><span class="calibre10">key &lt; node.getKey()</span></pre>
<p class="mce-root">Inserting in a binary tree follows the same logic as the search operation. We start from the root and keep on looking for a location where we need to create a new node. This is shown in the next code snippet. Like the search operation, this Java implementation is also recursive. If the root node is absent we just create a new one, otherwise we recursively insert the key value pair each time by choosing the left or right child depending on the value of the key.</p>
<p class="mce-root">We have three stopping conditions for the recursive call that are, as follows:</p>
<ul class="calibre12">
<li class="calibre13"><span class="calibre10">When the <em class="calibre21">key is equal</em> to the one on the node, we simply overwrite the entry</span></li>
<li class="calibre13"><span class="calibre10">When the <em class="calibre21">left child is not present</em>, we create a new node with the key value pair</span></li>
<li class="calibre13"><span class="calibre10">When the <em class="calibre21">right child is not present</em>, we create a new node with the key </span><span class="calibre10">value pair</span></li>
</ul>
<p class="mce-root"><span class="calibre14">The following code demonstrates the binary search tree insert operation:</span></p>
<pre class="calibre20"><span class="calibre10">if (((Comparable) key).compareTo(node.getKey()) == 0) {<br class="calibre2"/>  node.setKey(key);<br class="calibre2"/>  node.setValue(value);<br class="calibre2"/>} else if (((Comparable) key).compareTo(node.getKey()) &lt;0) {<br class="calibre2"/>  if (node.getLeft().isPresent())<br class="calibre2"/>    put(key, value, node.getLeft().get());<br class="calibre2"/>  else<br class="calibre2"/>    node.setLeft(new BinaryTreeNode&lt;&gt;(key, value));<br class="calibre2"/>} else {<br class="calibre2"/>  if (node.getRight().isPresent())<br class="calibre2"/>    put(key, value, node.getRight().get());<br class="calibre2"/>  else<br class="calibre2"/>    node.setRight(new BinaryTreeNode&lt;&gt;(key, value));<br class="calibre2"/>}</span></pre>
<div class="packt_figref"><span class="calibre10">Snippet 3.11: Binary search tree insert operation. Source class name:</span> <span class="calibre10">SimpleBinaryTree</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/hHpeiP" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/hHpeiP</span></a> <span class="calibre10">to access this code.</span></div>
<p class="mce-root">Binary tree deletion requires matching the subtree structure with a number of patterns and performing different actions with each case. In some situations, it requires that you connect the subtree with the parent of the deleted node, which can be quite complex. For this reason, the deletion algorithm is beyond the scope of this book. <span class="calibre14">For information on the deletion operation, you may refer to the following sources:</span></p>
<ul class="calibre12">
<li class="calibre13"><span class="calibre10"><em class="calibre21">The Art of Computer Programming, Volume 3: Sorting and Searching</em>, by Donald Knuth.</span></li>
<li class="calibre13"><span class="calibre10">Paul E. Black, "binary search tree", in Dictionary of <em class="calibre21">Algorithms and Data Structures</em> [online], Vreda Pieterse and Paul E. Black, eds. January 26, 2015. Available at <a href="https://www.nist.gov/dads/HTML/binarySearchTree.html" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">https://www.nist.gov/dads/HTML/binarySearchTree.html</a>.</span></li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Searching for a Minimum Key in a Binary Tree</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre14">The aim is to implement a method in Java to search for the minimum key in a binary tree.</span></p>
<p class="mce-root">Perform the following steps:</p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Add a method to the binary tree implementation with the following signature:</span></li>
</ol>
<pre class="calibre30"> <span class="calibre10">public Optional&lt;K&gt; minKey()</span>  </pre>
<ol start="2" class="calibre17">
<li class="chapter"><span class="calibre10">The method needs to find the minimum key in the tree and return it. If the tree is empty, it should return an empty optional.</span></li>
<li class="chapter"><span class="calibre10">Finding the minimum in a binary search tree requires us to always follow the left child node until we reach a node with no left child pointer. The following code demonstrates this:</span></li>
</ol>
<pre class="calibre30"><span class="calibre10">public Optional&lt;K&gt; minKey() {<br class="calibre2"/>  return Optional.ofNullable(root).map(this::minKey);<br class="calibre2"/>}<br class="calibre2"/>private K minKey(BinaryTreeNode&lt;K, V&gt; node) {<br class="calibre2"/>  return node.getLeft().map(this::minKey).orElse(node.getKey());<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 3.12: Minimum key operation. Source class name:</span> <span class="calibre10">SimpleBinaryTre</span>e.</div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/YbZz6i" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/YbZz6i</span></a> <span class="calibre10">to access this code.</span></div>
<p class="mce-root">In this section, we have introduced binary search trees and explored how they can be used to organize key value pairs. We also saw how binary search trees can be used for simple range queries, such as finding the maximum and minimum keys. In the next section, we learn about all the different ways we can traverse a binary search tree.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Traversing a Binary Search Tree</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre14">Traversing a binary tree is the process of stepping through each node of the tree and performing some sort of action on the data contained in the node (such as printing the key value pair). There are two main techniques to perform tree traversal: depth-first search and breadth-first search, more commonly known as DFS and BFS, respectively.</span></p>
<p class="mce-root">In depth-first search, the algorithm goes down a path of tree nodes until it cannot go any further. Once it cannot go further, it backtracks and discovers any remaining unexplored branches. A recursive implementation is shown in the following code. In this traversal method, a different output sequence is produced depending on where the action is executed in the method.</p>
<p class="mce-root">In a <strong class="calibre6">preorder</strong> execution, we perform the action immediately, as soon as a new node is discovered. A <strong class="calibre6">postorder</strong> execution, on the other hand, is when both children of a node have been explored and we're about to backtrack. An <strong class="calibre6">inorder</strong> execution is done when the left child has been processed but before processing the right one. When using an inorder traversal, the keys in the binary search trees will be processed in ascending order:</p>
<pre class="calibre20"><span class="calibre10">public void printDfs() {<br class="calibre2"/>  Optional.ofNullable(root).ifPresent(this::printDfs);<br class="calibre2"/>}<br class="calibre2"/>private void printDfs(BinaryTreeNode&lt;K, V&gt; node) {<br class="calibre2"/>  //System.out.println("PREORDER " + node.getKey());<br class="calibre2"/>  node.getLeft().ifPresent(this::printDfs);<br class="calibre2"/>  System.out.println("INORDER " + node.getKey());<br class="calibre2"/>  node.getRight().ifPresent(this::printDfs);<br class="calibre2"/>  //System.out.println("POSTORDER " + node.getKey());<br class="calibre2"/>}</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 3.13: Depth-first search. Source class name:</span> <span class="calibre10">SimpleBinaryTree</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/xMzkbE" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/xMzkbE</span></a> <span class="calibre10">to access this code.</span></div>
<p class="mce-root">In the breadth-first search traversal, the algorithm explores the binary tree one level at a time, left to right. The traversal starts from the root node and finishes at the leaf nodes. The output of an example binary tree is shown in <em class="calibre19">Figure 3.11</em>. To implement a BFS traversal of a binary tree, we can make use of a queue initialized to contain the root node. Then, while the queue is not empty, we read the first node on the queue, process it, and add first the left and then the right child to the queue:</p>
<p class="cdpaligncenter"><img src="Images/0e506e9a-dfee-4baa-b211-c002bbe27a13.png" width="1278" height="604" class="calibre62"/></p>
<div class="packt_figref"><span class="calibre10">Figure 3.11: Breadth-first search on a binary tree</span></div>
<p class="mce-root"><span class="calibre14">We show the pseudocode of this as follows:</span></p>
<pre class="calibre20"><span class="calibre10">breadthFirstSearch(root)<br class="calibre2"/>  if (root != null)<br class="calibre2"/>    queue = createQueue()<br class="calibre2"/>    enqueue(queue, root)<br class="calibre2"/>    while (not isEmpty(queue))<br class="calibre2"/>      node = dequeue(queue)<br class="calibre2"/>      process(node)<br class="calibre2"/>      if (node.left != null) enqueue(queue, node.left)<br class="calibre2"/>      if (node.right != null) enqueue(queue, node.right)</span>  </pre>
<div class="packt_figref"><span class="calibre10">Snippet 3.14: Pseudocode for breadth-first search</span></div>
<div class="packt_infobox"><span class="calibre10">If we substitute the queue </span><span class="calibre10">with a stack, </span>the algorithm shown in <em class="calibre21">Snippet 3.14</em> changes from breadth-first search to the non-recursive depth-first search. In fact, the way to implement a non-recursive DFS is to make use of a stack.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Activity: Implementing BFS in Java</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre6">Scenario</strong></p>
<p class="mce-root"><span class="calibre14">We have been asked to write code to implement an algorithm that searches the binary tree one level at a time, left to right. The traversal starts from the root node and finishes at the leaf nodes.</span></p>
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Aim</span></strong></p>
<p class="mce-root"><span class="calibre14">To apply BFS traversal in Java.</span></p>
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Steps for Completion</span></strong></p>
<ol class="calibre17">
<li class="chapter"><span class="calibre10">Implement the algorithm shown in the preceding code in Java.</span></li>
<li class="chapter"><span class="calibre10">Use the Java</span> <span class="calibre10"><kbd class="calibre15">LinkedList</kbd></span> <span class="calibre10">collection to implement the queue shown in the pseudocode. The method signature should be as follows:</span></li>
</ol>
<pre class="calibre30"> <span class="calibre10">public void printBfs</span><span class="calibre10">()</span> </pre>
<p class="mce-root">In this section, we have learned about the various ways we can traverse a binary tree and the different ordering produced by each strategy. We have also seen how these algorithms can be implemented both in a recursive and in an iterative manner. In the next section, we will discuss a more restrictive type of binary search tree that ensures our data structure maintains a good performance, even in the worst input case.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Balanced Binary Search Trees</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The performance of a binary search tree is proportional to its height. This is because the search and insert operations start from the root and proceed down the tree one node at a time, doing a key comparison at each step. The taller the tree, the more steps are needed to accomplish this. Thus, if we determine the maximum possible height of a binary tree in relation to its input, we can find out the worst runtime complexity.</p>
<p class="mce-root">If we insert keys in a binary tree, by always adding on the right child of the parent node, we end up with a tree similar to the one shown on the left-hand side of <em class="calibre19">Figure 3.12</em>. In this diagram, only the right child pointers on each node are being used. We end up with a tree of height <em class="calibre19">n</em>, where <em class="calibre19">n</em> is the number of items added to our data structure. We get this kind of one-sided tree when the key input pattern is in order.</p>
<p class="mce-root">In the example shown in <em class="calibre19">Figure 3.12</em>, we first insert <span class="calibre14">5</span> as a root, then <span class="calibre14">7</span> is added as the right child, the next is <span class="calibre14">12</span> as the next right child, and so on. Always inserting an increasing number results in the next node on the right. This one type of input pattern makes our binary search tree operations (search, insert, and delete) behave in the worst-case runtime of <em class="calibre19">O(n)</em>:</p>
<p class="cdpaligncenter"><img src="Images/d5df6774-db10-4444-8504-d745772daded.png" width="1408" height="690" class="calibre63"/></p>
<div class="packt_figref"><span class="calibre10">Figure 3.12: Unbalanced versus balanced binary trees</span></div>
<div class="packt_infobox"><span class="calibre10">The result is similar if we start from a big number and decrease it each time. We end up with a mirror of the tree shown on the left-hand side of</span><span class="calibre10"> </span><em class="calibre21"><span class="calibre10">Figure 3.12</span></em><span class="calibre10">.</span><br class="calibre2"/>
The output of a BFS traversal in a normal binary search tree when the key insert order is "1,2,3,4,5,6,7" would be in the same order as the input, that is, "1,2,3,4,5,6,7". We end up  creating a new right child at every insert. Since BFS traversal processes one level after another, starting from the root, the traversal output is the same as the input.<span class="calibre10"><br class="calibre2"/></span></div>
<p class="mce-root">In <em class="calibre19">Figure 3.12</em>, on the right-hand side, we show another binary tree containing the same keys. This binary tree has been restructured with the effect that the tree is now shorter. Note that the tree is still valid, that is, the left child always has a key that is smaller than its parent, and vice versa. A balanced binary tree has a height of about <em class="calibre19">log<sub class="calibre40">2</sub>n</em>.</p>
<p class="mce-root">If we manage to find a way to rebalance the binary search tree at each insert in <em class="calibre19">O(log n)</em> or better, the worst-case runtime performance for inserts and searches would also be of <em class="calibre19">O(log n)</em>.</p>
<p class="mce-root"><span class="calibre14">Luckily, various algorithms exist that self-balance the tree structure as you perform inserts. Some of the most common ones are as follows:<br class="calibre7"/></span></p>
<ul class="calibre12">
<li class="calibre13"><span class="calibre10">AVL trees</span></li>
<li class="calibre13"><span class="calibre10">Red black trees</span></li>
<li class="calibre13"><span class="calibre10">AA trees</span></li>
</ul>
<p class="mce-root"><span class="calibre14">All of these algorithms check that the binary tree is following specific balancing rules at key insert. If, due to a new node being inserted, the tree becomes unbalanced, the self-balancing algorithm kicks in and restructures some of the nodes to keep the</span> tree balanced. The technique to rebalance the nodes relies on tree rotations, where under certain conditions some of the parent and child nodes are rotated. Importantly, these modifications are also performed in the worst-case of <em class="calibre19">O(log n)</em>, meaning that both inserts and searches on binary trees have a worst runtime complexity of <em class="calibre19">O(log n)</em>. In this section, we will examine tree rotations as they are the base operation for most self-balancing trees.</p>
<div class="packt_infobox">For more information about self-balancing trees, you may refer the following resources:<br class="calibre2"/>
<span class="calibre10"><em class="calibre21">The Art of Computer Programming</em>, <em class="calibre21">Volume 3: Sorting and Searching by </em></span><em class="calibre21">Donald Knuth</em>.<br class="calibre2"/>
Paul E. Black, "<em class="calibre21">red-black tree</em>", in <em class="calibre21">Dictionary of Algorithms and Data Structures</em> [online], Vreda Pieterse and Paul E. Black, eds. 13 April 2015. Available at the link: <a href="https://www.nist.gov/dads/HTML/redblack.html" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2">https://www.nist.gov/dads/HTML/redblack.html</a>.<span class="calibre10"><br class="calibre2"/></span></div>
<p class="mce-root"><em class="calibre19">Figure 3.13</em> shows an example of a left and right rotation. Note how the node being rotated (node <span class="calibre14">5</span> in the right rotation and <span class="calibre14">9</span> in the left rotation) ends up being the new parent. Importantly, there is a constant number of child pointer reassignments. The properties of a binary search tree are still valid after a tree rotates, that is, a left child pointer always has a smaller key that points to its parent, and vice versa. This means that we can perform any number of these tree rotations and our binary search tree will still be valid:</p>
<p class="cdpaligncenter"><img src="Images/7f5c66a9-a6a2-42bf-96d1-c40479d1c864.png" width="1222" height="567" class="calibre64"/></p>
<div class="packt_figref"><span class="calibre10">Figure 3.13: Left and right tree rotations</span></div>
<p class="mce-root"><em class="calibre19">Snippet 3.15</em> shows how we perform a right rotation in Java. The method accepts a top-level node that needs rotation (node <span class="calibre14">5</span> in <em class="calibre19">Figure 3.13</em>) and its parent node. The method requires the parent node since it has to reassign its child pointer. Performing the opposite right rotation on the tree node is the mirror image of the following method:</p>
<pre class="calibre20"><span class="calibre10">public void leftRotate(BinaryTreeNode&lt;K, V&gt; nodeX,<br class="calibre2"/> BinaryTreeNode&lt;K, V&gt; parent) {<br class="calibre2"/>  BinaryTreeNode&lt;K, V&gt; nodeY = nodeX.getRight().get();<br class="calibre2"/>  nodeX.setRight(nodeY.getLeft().orElse(null));<br class="calibre2"/>  if (parent == null)<br class="calibre2"/>    this.root = nodeY;<br class="calibre2"/>  else if (parent.getLeft().filter(n -&gt; n == nodeX).isPresent())<br class="calibre2"/>    parent.setLeft(nodeY);<br class="calibre2"/>  else<br class="calibre2"/>    parent.setRight(nodeY);<br class="calibre2"/>    nodeY.setLeft(nodeX);<br class="calibre2"/></span><span class="calibre10">}</span> </pre>
<div class="packt_figref"><span class="calibre10">Snippet 3.15: Java implementation of the left tree rotation. Source class name: </span><span class="calibre10">SimpleBinaryTree</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/Ts3JBu" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/Ts3JBu</span></a> <span class="calibre10">to access this code.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Applying Right Tree Rotation</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The aim is to <span class="calibre14">implement a right tree rotation in Java.</span></p>
<p class="mce-root"><span class="calibre14">Modify</span> <em class="calibre19"><span class="calibre14">Snippet 3.15</span></em> <span class="calibre14">to make the method perform a right tree rotation instead of a left tree rotation. The following code shows the required modification:</span></p>
<pre class="calibre20"><span class="calibre10">public void rightRotate(BinaryTreeNode&lt;K, V&gt; nodeX,<br class="calibre2"/> BinaryTreeNode&lt;K, V&gt; parent) {<br class="calibre2"/>  BinaryTreeNode&lt;K, V&gt; nodeY = nodeX.getLeft().get();<br class="calibre2"/>  nodeX.setLeft(nodeY.getRight().orElse(null));<br class="calibre2"/>  if (parent == null)<br class="calibre2"/>    this.root = nodeY;<br class="calibre2"/>  else if (parent.getRight().filter(n -&gt; n == nodeX).isPresent())<br class="calibre2"/>    parent.setRight(nodeY);<br class="calibre2"/>  else<br class="calibre2"/>    parent.setLeft(nodeY);<br class="calibre2"/>    nodeY.setRight(nodeX);<br class="calibre2"/>}</span> </pre>
<div class="packt_figref"><span class="calibre10">Snippet 3.16: Java implementation of the right tree rotation. Source class name: </span><span class="calibre10">SimpleBinaryTree</span></div>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">Go to</span> <a href="https://goo.gl/KKDWUa" class="pcalibre pcalibre3 calibre28 pcalibre1 pcalibre2"><span class="calibre10">https://goo.gl/KKDWUa</span></a> <span class="calibre10">to access this code.</span></div>
<p class="mce-root">The right rotation is an exact mirror image of the left rotation. It's enough to change all the left references with right references and vice versa.</p>
<p class="mce-root">In this section, we saw how we can improve the performance of binary search trees by using tree rotations to balance the data structure. This enables the tree to remain of a shorter height with a runtime complexity of <em class="calibre19">O(log n)</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Activity: Retrieving the Successor of an Element When the Tree is Traversed in Inorder</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Scenario</span></strong></p>
<p class="mce-root">We need to write a method that, given a key as an argument, returns the next in order key found in the binary search tree. If the key given as an argument is not found, the method should still return the next in order key. If the binary tree is empty or all the stored keys are smaller than the argument, then the return value should be empty. For example, using a collection of {10, 13, 52, 67, 68, 83} stored in the binary search tree:</p>
<ul class="calibre12">
<li class="calibre13">An input of 13 results in 52</li>
<li class="calibre13">An input of 67 results in 68</li>
<li class="calibre13">An input of 55 results in 67</li>
<li class="calibre13">An input of 5 results in 10</li>
<li class="calibre13">An input of 83 results in <kbd class="calibre15">Optional.empty</kbd></li>
<li class="calibre13">An input of 100 results in <kbd class="calibre15">Optional.empty</kbd></li>
<li class="calibre13">Any input on an empty binary tree results in <kbd class="calibre15">Optional.empty</kbd></li>
</ul>
<p class="mce-root">Both the in order successor and predecessor algorithms have many applications. As an example, think about if you had to keep a scoreboard at some sports event where you only want to show the first three runners. If you keep your data in a binary search tree, you can find the maximum key and then work out the next two predecessor nodes.</p>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">The solution needs to have a runtime complexity of</span> <em class="calibre21"><span class="calibre10">O(log n)</span></em><span class="calibre10">.</span></div>
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Aim</span></strong></p>
<p class="mce-root"><span class="calibre14">To retrieve the successor of an element when the tree is traversed in inorder.</span></p>
<p class="mce-root"><span class="calibre14"><strong class="calibre6">Prerequisites</strong><br class="calibre7"/></span></p>
<p class="mce-root"><span class="calibre14">Implement the following method, provided in the</span> <span class="calibre14"><kbd class="calibre15">InOrderSuccessorBinaryTree</kbd> </span><span class="calibre14">class that extends the</span> <kbd class="calibre15"><span class="calibre10">SimpleBinaryTree</span></kbd> <span class="calibre14">class, which is available on GitHub at the following link:</span></p>
<p class="mce-root"><a href="https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson3/activity/inordersuccessor/InOrderSuccessorBinaryTree.java" class="pcalibre pcalibre3 calibre11 pcalibre1 pcalibre2">https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson3/activity/inordersuccessor/InOrderSuccessorBinaryTree.java</a></p>
<pre class="calibre20"> <span class="calibre10">public Optional&lt;K&gt; inOrderSuccessorKey(K key)</span> </pre>
<div class="packt_infobox"><br class="calibre2"/>
<span class="calibre10">If you have your project set up, you can run the unit test for this activity by running:<br class="calibre2"/>
<kbd class="calibre31">gradlew test --tests com.packt.datastructuresandalg.lesson3.<span class="calibre10">activity</span>.inordersuccessor*</kbd><br class="calibre2"/></span></div>
<p class="mce-root"><strong class="calibre6"><span class="calibre14">Steps for Completion</span></strong></p>
<ol class="calibre17">
<li class="chapter">Use a non-recursive search operation first to find the first node with a key equal to or less than the input</li>
<li class="chapter">Realize that the inorder successor can be in only one of two places, either as a parent of this node or the minimum key on the subtree of the right child of this node (if any)</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we have studied two of the most commonly used data structures for implementing the data dictionary operation. Hash tables provide fast in-memory insertion and lookup operations. In addition, binary trees also give us the ability to perform various range queries such as successor, predecessor, minimum and maximum. In this chapter, we have seen examples of both data structures, and implementations of these operations.</p>


            </article>

            
        </section>
    </div>



  </body></html>