<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Health Monitoring and Data Visualization</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Writing custom health indicators</li>
<li>Configuring management context</li>
<li>Emitting metrics</li>
<li>Monitoring Spring Boot via JMX</li>
<li>Managing Spring Boot via SSHd Shell and writing custom remote Shell commands</li>
<li>Integrating Micrometer metrics with Graphite</li>
<li>Integrating Micrometer metrics with Dashing</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, you learned a few techniques to efficiently package and get the application ready for deployment and we looked at a number of techniques to provide an environmental configuration without changing the code. With the deployment and configuration woes behind us, the last (but not least) important step remains—ensuring that we have complete visibility, monitoring, and management control of our application, as it is running in the production environment and is exposed to the harsh environment of customers' (ab)use.</p>
<p>Just as airline pilots don't like to fly blind, developers don't get excited if they can't see how their beloved application, that they worked hard on, performs in production. We want to know, at any given time, what the CPU utilization is like, how much memory we are consuming, whether our connection to the database is up and available, the number of customers who use the system in any given time interval, and so on. Not only do we want to know all these things, but we also want to be able to see it in pretty charts, graphs, and visual dashboards. These come in very handy to put on the big Plasma displays for monitoring as well as impressing your boss, so as to show that you are on the top of things and have it all under control.</p>
<p>This chapter will help you learn the necessary techniques to enhance our application in order to expose custom metrics, health statuses, and so on, as well as how to get the monitoring data out of our application and either store it in Graphite for historical reference or use this data to create real-time monitoring dashboards using the Dashing and Grafana frameworks. We will also take a look at the capability to connect to running instances and perform various management tasks using the powerful CRaSH framework integration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing custom health indicators</h1>
                </header>
            
            <article>
                
<p>Knowing the state of the application that is running in production, especially in a large-scale distributed system, is just as (if not more) important as having things such as automated testing and deployment. In today's fast-paced IT world, we can't really afford much downtime, so we need to have the information about the health of the application at our fingertips, ready to go at a minute's notice. If the all-so-important database connections go down, we want to see it right away and be able to quickly remedy the situation; the customers are not going to be waiting around for long before they go to another site.</p>
<p>We will resume working on our <kbd>BookPub</kbd> application in the state in which we left it in the previous chapter. In this recipe, we will add the necessary Spring Boot starters to enable the monitoring and instrumentation of our application and will even write our own health indicator.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>The first thing that we need to do is add a dependency to the Spring Boot Actuator starter in our <kbd>build.gradle</kbd> file with the following content:</li>
</ol>
<pre style="padding-left: 60px">dependencies { 
    ... 
    compile("org.springframework.boot:spring-boot-starter-<br/>    data-rest") 
    // compile("org.springframework.boot:spring-boot-starter-<br/>    jetty") //   <br/>    Need to use Jetty instead of Tomcat 
    compile("org.springframework.boot:spring-boot-starter- <br/>    actuator") 
    compile project(':db-count-starter') 
    ... 
} </pre>
<ol start="2">
<li>Adding this dependency alone already gives us the ability to access the Spring management <kbd>/actuator/*</kbd> endpoints, such as <kbd>/env</kbd>, <kbd>/info</kbd>, <kbd>/metrics</kbd>, and <kbd>/health</kbd>, (though they are disabled by default, unless a <kbd>management.endpoints.web.exposure.include=*</kbd> property is configured in the <kbd>application.properties</kbd> file). So, let's start our application by executing the <kbd>./gradlew clean bootRun</kbd> command line and then we can access the newly available <kbd>/health</kbd> endpoint by opening our browser and going to <kbd>http://localhost:8080/actuator/health</kbd> so as to see the new endpoint in action, as shown in the following screenshot:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="217" src="assets/fed372cf-11a0-4774-8904-4d532e658b25.png" style="color: black;font-size: 1em" width="445"/></div>
<ol start="3">
<li>To get more details about the health state of our application, let's configure it to show the detailed health output by adding the <kbd>management.endpoint.health.show-details=always</kbd> <span>property to the</span> <kbd>application.properties</kbd> file <span>and then restarting our application. Now, when we go to</span> <kbd>http://localhost:8080/actuator/health</kbd> <span>in the browser, we should see something similar to the following screenshot:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img height="206" src="assets/cbf41ff6-7cba-4f01-b691-c33a8e068754.png" width="456"/></div>
<ol start="4">
<li>With the <kbd>actuator</kbd> dependency added, and detailed <kbd>/health</kbd> endpoint configured, we can now add and perform all kinds of monitoring functions on our application. Let's go ahead and populate the <kbd>/info</kbd> endpoint with some data by adding a directive to the <kbd>build.gradle</kbd> file located at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">springBoot { 
    buildInfo { 
        properties { 
            additional = [ 
                'description' : project.description 
            ] 
        } 
    } 
} 
 </pre>
<ol start="5">
<li>Next, we will create a new properties file named <kbd>gradle.properties</kbd> in the root directory of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">version=0.0.1-SNAPSHOT 
description=BookPub Catalog Application</pre>
<ol start="6">
<li>We will also add <kbd>rootProject.name='BookPub-ch7'</kbd> to the <kbd>settings.gradle</kbd> file located in the root directory of our project.</li>
<li>Now, let's start our application by executing <kbd>./gradlew clean bootRun</kbd> and then we can access the newly available <kbd>/info</kbd> endpoint by opening our browser and going to <kbd>http://localhost:8080/actuator/info</kbd> to see the new endpoint in action, as follows:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="213" src="assets/3a847adf-f02e-454c-9e45-901943fd86fd.png" width="438"/></div>
<ol start="8">
<li>As we have got the hang of how things work, let's go ahead and make our custom health indicator, which will be accessible via the <kbd>/health</kbd> endpoint in order to report the count status of the entries for each of our repositories. If they are greater than or equal to zero, we are <kbd>UP</kbd>, otherwise we are not really sure what's going on. Obviously, if an exception has occurred, we would be reporting <kbd>DOWN</kbd>. Let's start by relaxing the <kbd>getRepositoryName(...)</kbd> method visibility from <kbd>private</kbd> to <kbd>protected</kbd> in the <kbd>DbCountRunner.java</kbd> file located in the <kbd>db-count-starter/src/main/java/com/example/bookpubstarter/dbcount</kbd> directory at the root of our project.</li>
<li>Next, we will add the same dependency to the <kbd>compile("org.springframework.boot:spring-boot-starter-actuator")</kbd> library in the <kbd>build.gradle</kbd> file in the <kbd>db-count-starter</kbd> directory at the root of our project.</li>
</ol>
<ol start="10">
<li>Now, we will create a new file named <kbd>DbCountHealthIndicator.java</kbd> in the <kbd>db-count-starter/src/main/java/com/example/bookpubstarter/dbcount</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">public class DbCountHealthIndicator implements HealthIndicator { 
    private CrudRepository repository; 
 
    public DbCountHealthIndicator(CrudRepository repository) { 
        this.repository = repository; 
    } 
 
    @Override 
    public Health health() { 
        try { 
            long count = repository.count(); 
            if (count &gt;= 0) { 
                return Health.up().withDetail("count", <br/>                count).build(); 
            } else { 
                return Health.unknown().withDetail("count",  <br/>                count).build(); 
            } 
        } catch (Exception e) { 
            return Health.down(e).build(); 
        } 
    } 
} </pre>
<ol start="11">
<li>Next, we will modify the <kbd>@Import</kbd> annotation in the <kbd>EnableDbCounting.java</kbd> file located in the <kbd>db-count starter/src/main/java/com/example/bookpubstarter/dbcount</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">@Import({DbCountAutoConfiguration.class, 
        HealthIndicatorAutoConfiguration.class})</pre>
<ol start="12">
<li>Finally, for the automatic registration of our <kbd>HealthIndicator</kbd> class, we will enhance the <kbd>DbCountAutoConfiguration.java</kbd> file located in the <kbd>db-count-starter/src/main/java/com/example/bookpubstarter/dbcount</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">@Autowired 
private HealthAggregator healthAggregator; 
@Bean 
public HealthIndicator dbCountHealthIndicator(Collection&lt;CrudRepository&gt; repositories) { 
    CompositeHealthIndicator compositeHealthIndicator = new <br/>      CompositeHealthIndicator(healthAggregator); 
    for (CrudRepository repository : repositories) { 
        String name = DbCountRunner.getRepositoryName<br/>         (repository.getClass()); 
        compositeHealthIndicator.addHealthIndicator(name, new  <br/>          DbCountHealthIndicator(repository)); 
    } 
    return compositeHealthIndicator; 
} </pre>
<ol start="13">
<li>So, let's start our application by executing the <kbd>./gradlew clean bootRun</kbd> command line, and then we can access the <kbd>/health</kbd> endpoint by opening our browser and going to <kbd>http://localhost:8080/actuator/health</kbd> to see our new <kbd>HealthIndicator</kbd> class in action, as follows:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="202" src="assets/6ddc9b6d-b0f2-4080-a5d3-96b34cd5486f.png" width="415"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The Spring Boot Actuator starter adds a number of important features that give insight into the runtime state of the application. The library contains a number of autoconfigurations that add and configure the various endpoints to access the runtime monitoring data and health of the application. Those endpoints all share a common context path: <kbd>/actuator</kbd>. To expose any other endpoints besides <kbd>/info</kbd> and <kbd>/health</kbd>, we need to explicitly expose them by setting the <kbd>management.endpoints.web.exposure.include=*</kbd> property. When the value is set to <kbd>*</kbd>, it will expose all of the endpoints. The following endpoints are available to aid us in getting an insight into the application runtime state and configuration:</p>
<ul>
<li><kbd>/env</kbd>: This endpoint enables us to query the application about all of the environment variables that the application has access to via the environment implementation, which we have seen earlier. It is very useful when you need to debug a particular issue and want to know a value of any given configuration property. If we access the endpoint by going to <kbd>http://localhost:8080/actuator/env</kbd>, we will see a number of different configuration sections, for example, the class path resource <kbd>[tomcat.https.properties]</kbd>, <kbd>applicationConfig: [classpath:/application.properties]</kbd>, <kbd>commonsConfig</kbd>, <kbd>systemEnvironment</kbd>, <kbd>systemProperties</kbd>, and others. They all represent an instance of an individual <kbd>PropertySource</kbd> implementation that is available in the environment and depending on their place in the hierarchy, may or may not be used to provide the value resolution at the runtime. To find out exactly which entry is used to resolve a particular value, for example, for the <kbd>book.count.rate</kbd> property, we can query it by going to the <kbd>http://localhost:8080/actuator/env/book.counter.rate</kbd> URL. By default, we should get 10,000 as a result unless, of course, a different value was set via the system environment or command-line arguments as an override. If you really want to dig deep into the code, the <kbd>EnvironmentEndpoint</kbd> class is responsible for handling the logic behind this capability.</li>
<li><kbd>/configprops</kbd>: This endpoint provides you with an insight into the settings of the various configuration property objects, such as our <kbd>WebConfiguration.TomcatSslConnectorProperties</kbd> starter. It is slightly different from the <kbd>/env</kbd> endpoint as it provides insight into the configuration object bindings. If we open the browser to go to <kbd>http://localhost:8080/actuator/configprops</kbd> and search for <kbd>custom.tomcat.https</kbd>, we will see the entry for our configuration property object that we will use to configure <kbd>TomcatSslConnector</kbd>, which was automatically populated and bound for us by Spring Boot.</li>
<li><kbd>/conditions</kbd>: This endpoint serves as a web-based analog to the AutoConfiguration Report, which we saw in <a href="6139967b-794e-479a-8461-d3197eb0322e.xhtml">Chapter 4</a>, <em>Writing Custom Spring Boot Starters</em>. This way, we can get the report using the browser at any time without having to start the application with the specific flags to get it printed.</li>
<li><kbd>/beans</kbd>: This endpoint is designed to list all the beans that have been created by Spring Boot and are available in application context.</li>
<li><kbd>/mappings</kbd>: This endpoint exposes a list of all the URL mappings that are supported by the application as well as a reference to the <kbd>HandlerMapping</kbd> bean implementation. This is very useful for answering the question of where would a specific URL get routed to. Try going to <kbd>http://localhost:8080/actuator/mappings</kbd> to see the list of all the routes that our application can handle.</li>
<li><kbd>/threaddump</kbd>: This endpoint allows extraction of the Thread Dump information from the running application. It is rather useful when trying to diagnose a potential thread deadlock.</li>
<li><kbd>/heapdump</kbd>: This endpoint is similar to <kbd>/dump</kbd> with the exception that it produces Heap Dump information instead.</li>
<li><kbd>/info</kbd>: This endpoint shows the basic description and application information that we added and we've seen this in action, so it should be familiar to us as of now. The nice support in the build tools gives us the ability to configure additional or replace existing values inside our <kbd>build.gradle</kbd> configuration, which would then be propagated to be consumed by the <kbd>/info</kbd> endpoint. Additionally, any properties defined in the <kbd>application.properties</kbd> file, that start with <kbd>info.</kbd> will be displayed while accessing the <kbd>/info</kbd> endpoint, so you are definitely not limited to only the <kbd>build.gradle</kbd> configuration. Configuring this specific endpoint in order to return the relevant information can be very helpful when building various automated discovery and monitoring tools as it is a great way to expose application-specific information in the form of a nice JSON RESTful API.</li>
<li><kbd>/actuator</kbd>: This endpoint gives a nice JSON-formatted list of links in a <strong>Hypertext Application Language</strong> (<strong>HAL</strong>) style for all the available actuator endpoints.</li>
<li><kbd>/health</kbd>: This endpoint provides information about the general application health status as well as a detailed breakdown and health status of the individual components.</li>
<li><kbd>/metrics</kbd>: This endpoint gives an overview of all the various data points that are emitted by the metrics subsystem. You can experiment with it by accessing it via the <kbd>http://localhost:8080/actuator/metrics</kbd> URL in the browser. We will cover this in more detail in the next recipe.</li>
</ul>
<p>Now that we know in general what is being provided for us by Spring Boot Actuator, we can move on to take a look at the details of what we did to get our custom <kbd>HealthIndicator</kbd> class working and how the whole health monitoring subsystem in Spring Boot functions.</p>
<p>As you saw, getting the basic <kbd>HealthIndicator</kbd> interface to work is very easy; all we have to do is create an implementing class that will return a <kbd>Health</kbd> object upon a call to the <kbd>health()</kbd> method. All you have to do is expose the instance of the <kbd>HealthIndicator</kbd> class as <kbd>@Bean</kbd> for Spring Boot to pick it up and add it to the <kbd>/health</kbd> endpoint.</p>
<p>In our case, we went a step further because we had to deal with the need to create <kbd>HealthIndicator</kbd> for each <kbd>CrudRepository</kbd> instance. To accomplish this, we created an instance of <kbd>CompositeHealthIndicator</kbd> to which we added all the instances of <kbd>DbHealthIndicator</kbd> for each <kbd>CrudRepository</kbd>. We then returned this as <kbd>@Bean</kbd> and this is what was used by Spring Boot to represent the health status. Being a composite, it preserved the inner hierarchy as is evident from the returned JSON data representing the health status. We also added some extra data element to provide the indication of the entry count as well as the name of each particular repository so that we can tell them apart.</p>
<p>Looking at the code, you are probably wondering: what is this <kbd>HealthAggregator</kbd> instance that we've wired in? The reason that we needed a <kbd>HealthAggregator</kbd> instance is because <kbd>CompositeHealthIndicator</kbd> needs to know how to decide if the inner composition of all the nested <kbd>HeathIndicators</kbd> represents good or bad health as a whole. Imagine that all the repositories, but one, return <kbd>UP</kbd> but one is <kbd>DOWN</kbd>. What does this mean? Is the composite indicator healthy as a whole or should it also report <kbd>DOWN</kbd> because one inner repository has issues?</p>
<p>By default, Spring Boot already creates and uses an instance of <kbd>HealthAggregator</kbd>, so we just autowired it and used it in our use case as well. We did have to explicitly add the import of the <kbd>HealthIndicatorAutoConfiguration</kbd> and <kbd>MetricsDropwizardAutoConfiguration</kbd> classes in order to satisfy the bean dependency during slice tests for <kbd>DataJpaTest</kbd> and <kbd>WebMvcTest</kbd>, since those only partially instantiate the context, and the actuator autoconfigurations are missing.</p>
<p>Even though the default implementation is an instance of <kbd>OrderedHealthAggregator</kbd>, which just collects all the inner status responses and chooses the lowest on the priority level out of <kbd>DOWN</kbd>, <kbd>OUT_OF_SERVICE</kbd>, <kbd>UP</kbd>, and <kbd>UNKNOWN</kbd>, it doesn't always have to be that way. For example, if the composite indicator consists of the indicators for redundant service connections, your combined result could be <kbd>UP</kbd> as long as at least one of the connections is healthy. Creating a custom <kbd>HealthAggregator</kbd> interface is very easy; all you have to do is either extend <kbd>AbstractHealthAggregator</kbd> or implement a <kbd>HealthAggregator</kbd> interface itself.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring management context</h1>
                </header>
            
            <article>
                
<p>Spring Boot Actuator out of the box creates a set of management endpoints and the supporting beans in the main application context and those endpoints are available on the <kbd>server.port</kbd> configured HTTP port. There are, however, cases where for security or isolation reasons we would want to separate the main application context from the management one or expose the management endpoints on a different port than the main application.</p>
<p>Spring Boot provides us with an ability to configure a separate child application context for the management beans, which would inherit everything from the main application context, but allow for defining beans that are only available for the management functions as well. The same goes for exposing the endpoints on a different port or even using different connector security in such a way that the main application could be using SSL, but the management endpoints are accessible using plain HTTP.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's imagine that, for whatever reason, we want to change our JSON converter to output field names using <kbd>SNAKE_CASE</kbd> (all lowercase letters separating words with an underscore).</p>
<ol>
<li>First, let's create a class holding our configuration for the management context named <kbd>ManagementConfiguration.java</kbd> located in the <kbd>src/main/java/com/example/bookpub</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">@ManagementContextConfiguration 
public class ManagementConfiguration  
       implements WebMvcConfigurer { 
  @Override 
  public void configureMessageConverters( 
              List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { 
    HttpMessageConverter c = new <br/>     MappingJackson2HttpMessageConverter( 
        Jackson2ObjectMapperBuilder.json(). 
        propertyNamingStrategy(PropertyNamingStrategy.SNAKE_CAS). 
        build() 
        ); 
    converters.add(c); 
  } 
} </pre>
<ol start="2">
<li>We also need to add this class to <kbd>spring.factories</kbd> located in the <kbd>src/main/resources/META-INF</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">org.springframework.boot.actuate.autoconfigure.web.ManagementContextConfiguration=com.example.bookpub.ManagementConfiguration </pre>
<ol start="3">
<li>To avoid our configuration being detected by the component scan for the main application context, we need to exclude it by adding the following to <kbd>BookPubApplication.java</kbd> located in the <kbd>src/main/java/com/example/bookpub</kbd> directory at the root of our project:</li>
</ol>
<pre style="padding-left: 60px">@ComponentScan(excludeFilters =  
    @ComponentScan.Filter( 
        type = FilterType.ANNOTATION,  
        classes = ManagementContextConfiguration.class 
    ) 
) </pre>
<ol start="4">
<li>To have a separate management context, we need to launch it using a different port, so let's amend <kbd>application.properties</kbd> located in the <kbd>src/main/resources</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">management.server.port=8081 
management.endpoints.web.exposure.include=*</pre>
<ol start="5">
<li>Finally, let's start our application by executing <kbd>./gradlew clean bootRun</kbd> and then we can access the <kbd>/threaddump</kbd> endpoint by opening our browser and going to <kbd>http://localhost:8081/actuator/threaddump</kbd> to see our new configuration take place. The field names of the returned JSON should all be in lowercase and words should be separated using an underscore, or in <kbd>SNAKE_CASE</kbd>, as it is called. Alternatively, by going to the <kbd>http://localhost:8080/books/978-1-78528-415-1</kbd> endpoint, we should continue seeing JSON field names in the <kbd>LOWER_CAMEL_CASE</kbd> format.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Spring Boot recognizes that there are many reasons and it needs to be able to provide separate configuration for the way management endpoints and other actuator components work, which is different from the main application. The first level of such configurations can be achieved by setting the myriad of available properties that intuitively start with <kbd>management.*</kbd>. We have used one such property, <kbd>management.server.port</kbd>, to set the port for the management interface to be <kbd>8081</kbd>. We could also set things like the SSL configuration, security settings, or network IP interface address to bind the listener to. We also have the capability to configure each individual <kbd>actuator</kbd> endpoint by setting their corresponding properties, which start with <kbd>management.endpoint.&lt;name&gt;.*</kbd> and have a variety of settings, depending on the specific endpoint goals.</p>
<p>For security reasons, the data that is exposed by the various management endpoints, especially the ones from sensitive ones such as <kbd>/health</kbd>, <kbd>/env</kbd>, and others can be very lucrative for malicious people on the outside. To prevent this from happening, Spring Boot provides us with the ability to configure if we want the endpoints to be available via <kbd>management.endpoint.&lt;name&gt;.enabled=false</kbd>. We can specify which individual endpoints we want to disable by setting an appropriate <kbd>management.endpoint&lt;name&gt;.enabled=false</kbd> property as well, or using <kbd>management.endpoints.web.exposure.exclude=&lt;name&gt;</kbd> to tell Spring Boot if this endpoint should be enabled, but not exposed via the WEB HTTP API method of access.</p>
<p>Alternatively, we can set <kbd>management.server.port=-1</kbd> to disable the HTTP exposure of these endpoints or use a different port number in order to have the management endpoints and live services on different ports. If we want to enable access only via a localhost, we can achieve this by configuring <kbd>management.server.address=127.0.0.1</kbd> to prevent external access. Even the context URL path can be configured to something else, say <kbd>/admin</kbd>, via <kbd>management.server.context-path=/admin</kbd>. This way, to get access to a <kbd>/health</kbd> endpoint, we would go to <kbd>http://127.0.0.1/admin/health</kbd> instead of the default <kbd>/actuator</kbd> context path. This can be useful if you want to control and restrict access via the firewall rules, so you can just add a filter to block external access to anything, <kbd>/admin/*</kbd>, for all the applications from the outside. With the addition of Spring Security, an authentication can also be configured to require a user login to get access to the endpoints.</p>
<p>In situations when controlling behavior using properties is not enough, Spring Boot provides a mechanism to provide alternative application context configuration via the use of <kbd>spring.factories</kbd> and the accompanying <kbd>ManagementContextConfiguration</kbd> annotation. This enables us to tell Spring Boot which configurations should be automatically loaded when management context is being created. The intended use of this annotation is to have the configuration live in a separate, sharable dependency library, outside of the main application's code.</p>
<p>In our example, because we put it in the same codebase (for simplicity), we had to do an extra step and define the exclusion filter in the <kbd>BookPubApplication.java</kbd> file to exclude the <kbd>ManagementContextConfiguration</kbd> classes from component scan when setting up the main application. The reason we had to do that is simple—if we look inside the <kbd>ManagementContextConfiguration</kbd> annotation definition, we will see that it is a meta-annotation with the <kbd>@Configuration</kbd> annotation inside it. What this means is that when our main application is being configured, the component scan will automatically detect all the classes in the classpath tree of the application code that are annotated with <kbd>@Configuration</kbd>, and as such, it will put all the configurations marked with <kbd>ManagementContextConfiguration</kbd> in the main context as well. We have avoided that using the exclusion filter. Alternatively, a better way is to have those configurations in a separate library using a different package hierarchy, which would prevent the component scan picking them up, but the autoconfiguration will still works because of the <kbd>spring.factories</kbd> entry for <kbd>org.springframework.boot.actuate.autoconfigure.web.ManagementContextConfiguration</kbd> telling Spring Boot to automatically add those configurations to the management context.</p>
<p>In order to have the management context separate from the main application, it is necessary to configure it to run on a separate port using the <kbd>management.server.port</kbd> property. Without this setting, all of the objects will be using shared application context.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Emitting metrics</h1>
                </header>
            
            <article>
                
<p>The previous recipe gave an overview of the capabilities provided by Spring Boot Actuators. We played with different management endpoints such as <kbd>/info</kbd> and <kbd>/health</kbd> and even created our own health metrics to add to the default set. However, besides the health status, there are a number of things that we, as developers and operations folks, want to be able to see and monitor on an ongoing basis, and just knowing that the uplink is functional is not good enough. We would also like to see the number of open sessions, concurrent requests to the application, latency, and so on. In this recipe, you will learn about the metric reporting facilities in Spring Boot as well as how to add our own metrics and some quick and simple ways of visualizing them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>To help us visualize the metrics better, we will use a great open source project, <kbd>spring-boot-admin</kbd>, located at <a href="https://github.com/codecentric/spring-boot-admin">https://github.com/codecentric/spring-boot-admin</a>. It provides a simple web UI on top of the Spring Boot Actuators to give a nicer view of the various data.</p>
<p>We will create a simple admin application in Gradle using the instructions from <a href="https://github.com/codecentric/spring-boot-admin#server-application">https://github.com/codecentric/spring-boot-admin#server-application</a> by performing the following simple steps:</p>
<ol>
<li>Go to <a href="http://start.spring.io">start.spring.io</a> and create a new application template with the following fields:</li>
</ol>
<ul>
<li style="padding-left: 30px"><span class="packt_screen">Generate a</span>: <span class="packt_screen">Gradle Project</span></li>
<li style="padding-left: 30px"><span class="packt_screen">With</span>:<span> </span><span class="packt_screen">Java</span></li>
<li style="padding-left: 30px"><span class="packt_screen">Spring Boot</span>: <span class="packt_screen">2.0.0 (SNAPSHOT)</span></li>
<li style="padding-left: 30px"><span class="packt_screen">Group</span>: <kbd>org.sample.admin</kbd></li>
<li style="padding-left: 30px"><span class="packt_screen">Artifact</span>: <kbd>spring-boot-admin-web</kbd></li>
<li style="padding-left: 30px"><span class="packt_screen">Name</span>: <kbd>Spring Boot Admin Web</kbd></li>
<li style="padding-left: 30px"><span class="packt_screen">Description</span>: <kbd>Spring Boot Admin Web Application</kbd></li>
<li style="padding-left: 30px"><span class="packt_screen">Package Name</span>: <kbd>org.sample.admin</kbd></li>
<li style="padding-left: 30px"><span class="packt_screen">Packaging</span>: <span class="packt_screen">Jar</span></li>
<li style="padding-left: 30px"><span class="packt_screen">Java Version</span>: <span class="packt_screen"><span class="packt_screen">8</span></span></li>
</ul>
<ol start="2">
<li>Select the <span class="packt_screen">Actuator</span> option under <span class="packt_screen">Search for dependencies</span></li>
<li>Click on <span class="packt_screen">Generate Project alt +</span> to download the application template archive</li>
<li>Extract the contents from the directory of your choice</li>
<li>In the extracted directory, execute the <kbd>gradle wrapper</kbd> command line to generate a gradlew script</li>
<li>In the <kbd>build.gradle</kbd> file, add the following dependencies to the <kbd>dependencies</kbd> block:</li>
</ol>
<pre style="padding-left: 60px">compile("de.codecentric:spring-boot-admin-server:2.0.0-SNAPSHOT") 
compile("de.codecentric:spring-boot-admin-server-ui:2.0.0-SNAPSHOT ") </pre>
<ol start="7">
<li>We also need to update the <kbd>repositories</kbd> block with a reference to use the <kbd>snapshots</kbd> repository (as the time of writing, the SBA is not yet released):</li>
</ol>
<pre style="padding-left: 60px">maven { url "https://oss.sonatype.org/content/repositories/snapshots/" } </pre>
<ol start="8">
<li>Open the <kbd>SpringBootAdminWebApplication.java</kbd> file located in the <kbd>src/main/java/spring-boot-admin-web</kbd> directory and add the following annotations to the <kbd>SpringBootAdminWebApplication</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">@SpringBootApplication 
@EnableAdminServer 
public class SpringBootAdminWebApplication { 
 
  public static void main(String[] args) { 
    SpringApplication.run( 
                      SpringBootAdminWebApplication.class, <br/>                      args); 
  } 
} </pre>
<ol start="9">
<li>Open the <kbd>application.properties</kbd> file located in the <kbd>src/main/resources</kbd> directory and add the following settings:</li>
</ol>
<pre style="padding-left: 60px">server.port: 8090 
spring.application.name: Spring Boot Admin Web 
spring.cloud.config.enabled: false 
spring.jackson.serialization.indent_output: true</pre>
<ol start="10">
<li>We are now ready to start our Admin Web Console by running <kbd>./gradlew bootRun</kbd> and open the browser to <kbd>http://localhost:8090</kbd> to see the following output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-medium wp-image-342 image-border" height="238" src="assets/3cbd2f7b-868f-499d-95a3-4cdf96c0e1af.png" width="292"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>With the <strong>Admin Web</strong> up and running, we are now ready to start adding various metrics to our <kbd>BookPub</kbd> application. Let's expose the same information about our data repositories as we did in <kbd>HealthIndicators</kbd>, but this time, we will expose the counts data as a metric. We will continue to add code to our <kbd>db-count-starter</kbd> subproject. So, let's create a new file named <kbd>DbCountMetrics.java</kbd> in the <kbd>db-count-starter/src/main/java/com/example/bookpubstarter/dbcount</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">public class DbCountMetrics implements MeterBinder { 
    private Collection&lt;CrudRepository&gt; repositories; 
 
    public DbCountMetrics(Collection&lt;CrudRepository&gt; repositories) <br/>    { 
        this.repositories = repositories; 
    } 
 
    @Override 
    public void bindTo(MeterRegistry registry) { 
        for (CrudRepository repository : repositories) { 
            String name = DbCountRunner.getRepositoryName<br/>              (repository.getClass()); 
            String metricName = "counter.datasource."  
                              + name; 
            Gauge.builder(metricName, repository, 
                          CrudRepository::count) 
                 .tags("name", name) 
                 .description("The number of entries in "  
                             + name + "repository") 
                 .register(registry); 
        } 
    } 
} </pre>
<ol start="2">
<li>Next, for the automatic registration of <kbd>DbCountMetrics</kbd>, we will enhance <kbd>DbCountAutoConfiguration.java</kbd> located in the <kbd>db-count-starter/src/main/java/com/example/bookpubstarter/dbcount</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">@Bean 
public DbCountMetrics<br/>  dbCountMetrics(Collection&lt;CrudRepository&gt; repositories) { 
    return new DbCountMetrics(repositories); 
} </pre>
<ol start="3">
<li>In order for the Thread Dump to properly display in the Spring Boot Admin UI, we need to change our JSON converter from <kbd>SNAKE_CASE</kbd> to <kbd>LOWER_CAMEL_CASE</kbd> by changing <kbd>ManagementConfiguration.java</kbd> located in the <kbd>src/main/java/com/example/bookpub</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">propertyNamingStrategy( 
    PropertyNamingStrategy.LOWER_CAMEL_CASE 
)</pre>
<ol start="4">
<li>So, let's start our application by executing <kbd>./gradlew clean bootRun</kbd> and then we can access the <kbd>/metrics</kbd> endpoint by opening our browser and going to <kbd>http://localhost:8081/actuator/metrics</kbd> to see our new <kbd>DbCountMetrics</kbd> class added to the existing metrics list, as follows:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="210" src="assets/939b9e18-ff5c-4881-bfe7-16e7b8b5e968.png" width="479"/></div>
<ol start="5">
<li>Our next step would be to get our application to appear in the Spring Boot Admin Web, which we created earlier. To make this happen, we will need to add a dependency on the <kbd>compile("de.codecentric:spring-boot-admin-starter-client:2.0.0-SNAPSHOT")</kbd> library to <kbd>build.gradle</kbd> in the directory at the root of our project.</li>
<li>Additionally, <kbd>application.properties</kbd> located in the <kbd>src/main/resources</kbd> directory in the root of our project needs to be enhanced with the following entries:</li>
</ol>
<pre style="padding-left: 60px">spring.application.name=BookPub Catalog Application 
server.port=8080 
spring.boot.admin.client.url=http://localhost:8090</pre>
<ol start="7">
<li>Once again, let's start our application by executing <kbd>./gradlew clean bootRun</kbd>, and if we now go to Spring Boot Admin Web by directing our browser to <kbd>http://localhost:8090</kbd>, we should see a new entry for our application named <kbd>BookPub Catalog Application</kbd> appear in the list. If we click on the <span class="packt_screen">Details</span> button on the right-hand side and scroll down to the <span class="packt_screen">Health</span> section, we will see our custom health indicators along with the others reported in a form of nicer looking hierarchical entries in a table, as follows:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="320" src="assets/a78eec07-1892-49b9-a071-d877d0628db6.png" style="text-align: center;color: black;font-size: 1em" width="420"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>A few words about Spring Boot Admin Web before we delve into the details of creating and emitting metrics. It is a simple web GUI that, in the backend, uses the same endpoints exposed by Spring Boot Actuator, which we learned about in the previous recipe. The data is extracted from the application as we click on the various links in Admin Web and displayed in a nice graphical way—no magic!</p>
<p>We only had to configure a few properties in addition to adding the client library dependency in order to get our application to connect and register with Admin Web:</p>
<ul>
<li><kbd>spring.application.name=BookPub Catalog Application</kbd>: This configures the name of the application that we have chosen to use. It is also possible to take the value from the description property defined in <kbd>gradle.properties</kbd> using the resource processing task in Gradle. Admin Web uses this value when displaying the application list.</li>
<li><kbd>spring.boot.admin.client.url=http://localhost:8090</kbd>: This configures the location of the Admin Web application so that our application knows where to go in order to register itself. As we are running on port <kbd>8080</kbd>, we chose to configure Admin Web to listen on port <kbd>8090</kbd>, but any port can be chosen as desired. You can see more configuration options by visiting <a href="https://codecentric.github.io/spring-boot-admin/current/">https://codecentric.github.io/spring-boot-admin/current/</a>.</li>
</ul>
<p>If we also want to enable the logging level control through the UI, we will need to add a Jolokia JMX library to our <kbd>compile("org.jolokia:jolokia-core:+")</kbd> build dependency as well as a <kbd>logback.xml</kbd> file in the <kbd>src/main/resources</kbd> directory in the root of the project with the following content:</p>
<pre style="padding-left: 30px">&lt;configuration&gt; 
  &lt;include <br/>     resource="org/springframework/boot/logging/logback/base.xml"/&gt; <br/>  &lt;jmxConfigurator/&gt;  
&lt;/configuration&gt; </pre>
<p>The metrics facility in Spring Boot is very powerful and extendable, offering a number of different approaches for emitting and consuming metrics. Starting with Spring Boot 2.0, the <kbd>Micrometer.io</kbd> library is being used under the hood to provide a very comprehensive monitoring solution. Out of the box, Spring Boot already configures a number of data metrics that monitor the system resources, such as heap memory, thread counts, system uptime, and many others as well as the database usage and HTTP session counts. The MVC endpoints are also instrumented to gauge the request latency, which is measured in milliseconds, as well as a counter for each endpoint request status.</p>
<p>Various metrics, such as gauges, counters, timers, and so on, are emitted via the <kbd>MeterRegistry</kbd> implementation that is provided by Spring Boot at runtime. The registry can be easily autowired into any Spring-managed object and be used to emit metrics.</p>
<p>For example, we can easily count the number of times a particular method gets invoked. All we need to do is to autowire an instance of <kbd>MeterRegistry</kbd> into our object during creation, and place the following line at the beginning of the method:</p>
<pre>meterRegistry.counter("objectName.methodName.invoked").increment();</pre>
<p>Each time the method gets called, the particular metric count will be incremented.</p>
<p>This approach will give us the counts that we can increment, but if we want to measure latency or any other arbitrary value, we will need to use <kbd>Gauge</kbd> to submit our metrics. To measure how long it will take for our method to execute, we can use <kbd>MeterRegistry</kbd> and at the beginning of the method, record the time:</p>
<pre>long start = System.currentTimeMillis();</pre>
<p>We will then place our code and before the return, capture the time again:</p>
<pre>long end = System.currentTimeMillis();.</pre>
<p>Then, we will emit the metric <kbd>meterRegistry.gauge("objectName.methodName.latency", end - start);</kbd>, which will update the last. The use of <kbd>gauge</kbd> for timing purposes is very rudimentary and <kbd>MeterRegistry</kbd> actually provides a specialized type of meter—Timer. The Timer meter, for example, provides the ability to wrap runnable or callable lambdas and automatically time the execution. Another benefit of using a Timer instead of <kbd>Gauge</kbd> is that a Timer meter keeps both the event counts as well as the latency it took to execute each occurrence.</p>
<p>The <kbd>MeterRegistry</kbd> implementation covers most of the simple use cases and is very handy when we operate in our own code and have the flexibility to add them where we need to. However, it is not always the case, and in these cases, we will need to resort to wrapping whatever it is we want to monitor by creating a custom implementation of <kbd>MeterBinder</kbd>. In our case, we will use it to expose the counts for each of the repositories in the database as we can't insert any monitoring code into the <kbd>CrudRepository</kbd> proxy implementations.</p>
<p>Whenever the <kbd>MeterRegistry</kbd> implementation does not provide enough flexibility, for example, when there is a need to wrap an object in a meter like <kbd>Gauge</kbd>, most meter implementations provide fluid builders to gain more flexibility. In our example, to wrap the repository metrics, we used a <kbd>Gauge</kbd> fluid builder to construct <kbd>Gauge</kbd>:</p>
<pre>Gauge.builder(metricName, repository, CrudRepository::count)</pre>
<p>The main builder method takes the following three arguments:</p>
<ul>
<li><kbd>metricName</kbd>: This specifies the name to use to uniquely identify this metric</li>
<li><kbd>repository</kbd>: This provides an object on which we invoke the method that should return a numeric value that <kbd>gauge</kbd> will report</li>
<li><kbd>CrudRepository::count</kbd>: This is the method that should be called on the <kbd>repository</kbd> object to get the current count of entries</li>
</ul>
<p>This enables us to build flexible wrappers because all we have to do is provide an object that would expose the necessary numeric value and a function reference to a function that should be called on the instance to get that value during the <kbd>gauge</kbd> evaluation.</p>
<p>The <kbd>MeterBinder</kbd> interface, used to export the Meter, has only one method defined,<br/>
<kbd>void bindTo(MeterRegistry);</kbd>, which the implementer needs to code with the definition of what exactly is being monitored. The implementation class needs to be exposed as <kbd>@Bean</kbd>, and it will automatically be picked up and processed during the application initialization. Assuming that one actually registered the created <kbd>Meter</kbd> instance with the provided <kbd>MeterRegistry</kbd> implementation, typically by terminating the fluid builder's chain by calling <kbd>.builder(...).register(registry)</kbd>, the metrics will be exposed via <kbd>MetricsEndpoint</kbd>, which will expose all the meters registered with the registry every time the <kbd>/metrics</kbd> actuator is called.</p>
<p>It is important to mention that we have created the <kbd>MeterBinder</kbd> and <kbd>HealthIndicator</kbd> beans inside the main application context and not in the management one. The reason being that even though the data is being exposed via the management endpoints, the endpoint beans, such as <kbd>MetricsEndpoint</kbd>, get defined in the main application context, and thus expect all the other autowired dependencies to be defined there as well.</p>
<p>This approach is safe because in order to get access to the information, one needs to go through the <kbd>WebMvcEndpointHandlerMapping</kbd> implementation facade, which is created in the management context and use the delegate endpoint from the main application context. Take a look at the <kbd>MetricsEndpoint</kbd> class and the corresponding <kbd>@Endpoint</kbd> annotation to see the details.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Monitoring Spring Boot via JMX</h1>
                </header>
            
            <article>
                
<p>In today's day and age, the RESTful HTTP JSON services are a de facto way of accessing data, but this is not the only way to do so. Another fairly popular and common way of managing systems in real time is via JMX. The good news is that Spring Boot already comes with the same level of support to expose the management endpoints over JMX as it does over HTTP. Actually, these are exactly the same endpoints; they are just wrapped around the MBean container.</p>
<p>In this recipe, we will take a look at how to retrieve the same information via JMX as we did via HTTP as well as how to expose some MBeans, which are provided by third-party libraries through HTTP using the Jolokia JMX library.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>If you haven't done so already for the previous recipe, then add the Jolokia JMX library to our <kbd>compile("org.jolokia:jolokia-core:+")</kbd> build dependency and add the <kbd>management.jolokia.enabled=true</kbd> property to <kbd>application.properties</kbd>, as we will need them to expose MBeans via HTTP.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root"><span>After we add the Jolokia JMX dependency, all we need to do is build and start our application by executing <kbd>./gradlew clean bootRun</kbd> and now we can simply launch jConsole to see the the various endpoints exposed under the <kbd>org.springframework.boot</kbd> domain:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="472" src="assets/45a84151-7fc1-4cfb-804e-49e48dfa700c.png" width="581"/></div>
<ol start="2">
<li>Having the Jolokia JMX library added to the classpath, Spring Boot also enables the accessing of all the registered MBeans via HTTP API using the <kbd>/jolokia</kbd> endpoint. To find out the <kbd>maxThreads</kbd> setting for our Tomcat HTTP port <kbd>8080</kbd> connector, we can either look it up using jConsole by selecting the <kbd>maxThreads</kbd> attribute on the <kbd>Tomcat:type=ThreadPool,name="http-nio-8080"</kbd> MBean to get the value of <kbd>200</kbd> or we can use Jolokia JMX HTTP by opening our browser and going to <kbd>http://localhost:8081/actuator/jolokia/read/Tomcat:type=ThreadPool,name=%22http-nio-8080%22/maxThreads</kbd> and we should see the following JSON response:</li>
</ol>
<pre style="padding-left: 60px">{"request": 
  {"mbean":"Tomcat:name="http-nio-8080",type=ThreadPool", 
   "attribute":"maxThreads", 
   "type":"read" 
  }, 
 "value":200,"timestamp":1436740537,"status":200}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>By default, the Spring Boot Actuator, when added to the application, comes with all the endpoints and management services enabled. This includes the JMX access as well. If, for some reason, one would like to disable the exposure of a particular endpoint via JMX, this can easily be configured by adding <kbd>management.endpoints.jmx.exclude=&lt;id&gt;</kbd> or in order to disable the exporting of all the Spring MBeans, we can configure the <kbd>spring.jmx.enabled=false</kbd> setting in <kbd>application.properties</kbd>.</p>
<p>The presence of the Jolokia library in the classpath triggers Spring Boot <kbd>JolokiaManagementContextConfiguration</kbd>, which would automatically configure <kbd>ServletRegistrationBean</kbd> accepting requests on the <kbd>/jolokia</kbd> actuator path. It is also possible to set various Jolokia-specific configuration options via the <kbd>management.endpoint.jolokia.config.*</kbd> set of properties. A complete list is available at <a href="https://jolokia.org/reference/html/agents.html#agent-war-init-params">https://jolokia.org/reference/html/agents.html#agent-war-init-params</a>. In case you would like to use Jolokia, but want to manually set it up, we can tell Spring Boot to ignore its presence by configuring a <kbd>management.endpoint.jolokia.enabled=false</kbd> property setting in <kbd>application.properties</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing Spring Boot via SSHd Shell and writing custom remote Shell commands</h1>
                </header>
            
            <article>
                
<p>Some of you are probably reminiscing about the good old days where all the administration was done via SSH directly on the machine, where one has complete flexibility and control, or even using SSH to connect to a management port and apply whatever changes were needed directly to a running application. Even though Spring Boot has removed native integration with the CRaSH Java Shell in version 2.0, there is an open source project, <kbd>sshd-shell-spring-boot</kbd>, which brings back that ability.</p>
<p>For this recipe, we will use the health indicator and management endpoint, which we created earlier in this chapter. We will expose the same capabilities via the SSH console access.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>The first step to getting SSHd Shell to work is to add the necessary dependency starters to our <kbd>build.gradle</kbd> file, as follows:</li>
</ol>
<pre style="padding-left: 60px">dependencies { 
    ... 
    compile("org.springframework.boot:spring-boot-starter-actuator") 
    compile("io.github.anand1st:sshd-shell-spring-boot-starter:3.2.1") 
    compile("de.codecentric:spring-boot-admin-starter-client:2.0.0-SNAPSHOT") 
    compile("org.jolokia:jolokia-core:+") 
    ... 
} </pre>
<ol start="2">
<li>We also need to explicitly enable it by setting the following property in <kbd>application.properties</kbd>, located in the <kbd>src/main/resources</kbd> directory in the root of our project it needs to be enhanced with the following entries:</li>
</ol>
<pre style="padding-left: 60px">sshd.shell.enabled=true 
management.endpoint.shutdown.enabled=true</pre>
<ol start="3">
<li>Now, let's start our application by executing <kbd>./gradlew clean bootRun</kbd> and then connect to it via SSH by executing <kbd>ssh -p 8022 admin@localhost</kbd>.</li>
<li>We will be prompted for a password so let's find the autogenerated hash key in the application startup log, which would look as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>********** User password not set. Use following password to login:  </strong><br/><strong>8f20cf10-7d67-42ac-99e4-3a4a77ca6c5f **********
  </strong></pre>
<ol start="5">
<li>If the password is entered correctly, we will be greeted by the following welcome prompt:</li>
</ol>
<pre style="padding-left: 60px"><strong>Enter 'help' for a list of supported commands 
app&gt; </strong></pre>
<ol start="6">
<li>Next, we will invoke our existing <kbd>/health</kbd> endpoint by typing health and we should get the following result:</li>
</ol>
<pre style="padding-left: 30px">    {
      "status" : "UP",
      "details" : {
        "dbCount" : {
          "status" : "UP",
          "details" : {
            "ReviewerRepository" : {
              ...
            },
            "PublisherRepository" : {
              ...
            },
            "AuthorRepository" : {
              ...
            },
            "BookRepository" : {
              ...
            }
          }
        },
        "diskSpace" : {
          "status" : "UP",
          "details" : {
            "total" : 249795969024,
            "free" : 14219882496,
            "threshold" : 10485760
          }
        },
        "db" : {
          "status" : "UP", 
          "details" : { "database" : "H2", "hello" : 1 }
        }
      }
    }
  </pre>
<ol start="7">
<li>Typing <kbd>help</kbd> will show the list of all the existing commands so you can play with some of them to see what they do and then we will proceed with adding our own SSHd Shell command, which will enable us to add new publishers to the system via the command line.</li>
<li>Make a new directory named commands in <kbd>src/main/java/com/example/bookpub/command</kbd> at the root of our project.</li>
<li>Add a file named <kbd>Publishers.java</kbd> in the <kbd>src/main/java/com/example/bookpub/command</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">package com.example.bookpub.command;<br/><br/>import com.example.bookpub.entity.Publisher;<br/>import com.example.bookpub.repository.PublisherRepository;<br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.stereotype.Component;<br/>import sshd.shell.springboot.autoconfiguration.SshdShellCommand;<br/>import sshd.shell.springboot.console.ConsoleIO;<br/><br/>import java.util.HashMap;<br/>import java.util.Map;<br/><br/>@Component<br/>@SshdShellCommand(value = "publishers", description = "Publisher management. Type 'publishers' for supported subcommands")<br/>public class PublishersCommand {<br/>    @Autowired<br/>    private PublisherRepository repository;<br/><br/>    @SshdShellCommand(value = "list", description = "List of publishers")<br/>    public String list(String _arg_) {<br/>        List list = new ArrayList();<br/><br/>        repository.findAll().forEach(publisher -&gt;<br/>            list.add(publisher);<br/>        );<br/><br/>        return ConsoleIO.asJson(list);<br/>    }<br/><br/>    @SshdShellCommand(value = "add", description = "Add a new publisher. Usage: publishers add &lt;name&gt;")<br/>    public String add(String name) {<br/>        Publisher publisher = new Publisher(name);<br/>        try {<br/>            publisher = repository.save(publisher);<br/>            return ConsoleIO.asJson(publisher);<br/>        } catch (Exception e) {<br/>            return String.format("Unable to add new publisher named %s%n%s", name, e.getMessage());<br/>        }<br/>    }<br/><br/>    @SshdShellCommand(value = "remove", description = "Remove existing publisher. Usage: publishers remove &lt;id&gt;")<br/>    public String remove(String id) {<br/>        try {<br/>            repository.deleteById(Long.parseLong(id));<br/>            return ConsoleIO.asJson(String.format("Removed publisher %s", id));<br/>        } catch (Exception e) {<br/>            return String.format("Unable to remove publisher with id %s%n%s", id, e.getMessage());<br/>        }<br/>    }<br/>} 
 </pre>
<ol start="10">
<li>With the commands built up, now let's start our application by executing <kbd>./gradlew clean bootRun</kbd> and then connect to it via SSH by executing <kbd>ssh -p 8022 admin@localhost</kbd> and log in using the generated password hash.</li>
<li>When we type publishers, we will see the list of all the possible commands, as follows:</li>
</ol>
<pre style="padding-left: 60px">app&gt; publishers 
Supported subcommand for publishers 
add       Add a new publisher. Usage: publishers add &lt;name&gt; 
list      List of publishers 
remove    Remove existing publisher. Usage: publishers remove &lt;id&gt;</pre>
<p style="padding-left: 60px"/>
<ol start="12">
<li>Let's add a publisher by typing <kbd>publishers add Fictitious Books</kbd> and we should see the following message:</li>
</ol>
<pre style="padding-left: 60px">{ 
  "id" : 2, 
  "name" : "Fictitious Books" 
} </pre>
<ol start="13">
<li>If we will now type publishers list, we will get a list of all the books:</li>
</ol>
<pre style="padding-left: 60px">[ { 
  "id" : 1, 
  "name" : "Packt" 
}, { 
  "id" : 2, 
  "name" : "Fictitious Books" 
} ] </pre>
<ol start="14">
<li>Removing a publisher is a simple command <kbd>publishers remove 2</kbd> that should respond with the <kbd>"Removed publisher 2"</kbd> message.</li>
<li>Just to confirm that the publisher is really gone, execute publishers list and we should see the following output:</li>
</ol>
<pre style="padding-left: 60px">[ { 
  "id" : 1, 
  "name" : "Packt" 
} ] </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The SSHd Shell integration with Spring Boot provides you with many commands out of the box. We can invoke the same management end points that were available to us over HTTP and JMX. We can get access to the JVM information, make changes to the logging configuration, and even interact with the JMX server and all the registered MBeans. The list of all the possibilities is really impressive and very rich in functionalities, so I would definitely advise you to read the reference documentation on SSHd Shell by going to <a href="https://github.com/anand1st/sshd-shell-spring-boot">https://github.com/anand1st/sshd-shell-spring-boot</a>.</p>
<p>In Spring Boot, the expectation is that any class annotated with <kbd>@SshdShellCommand</kbd> will be automatically picked up and registered as an SSHd Shell command. The value of the annotation attribute translates into the main command name. In our case, we set the class annotation attribute value field to <kbd>publishers</kbd> and this became the top-level command name in the SSH Shell console.</p>
<p>If the command contains sub-commands, as in our publishers command example, then, the methods of the class that are also annotated with <kbd>@SshdShellCommand</kbd> get registered as sub-commands to the main command. If a class has only one method, it will automatically become the only command for a given class that would be executed when the command name is typed. If we want multiple sub-commands to reside in the class command, as we did with publishers, each method that translates into a command needs to be annotated with <kbd>@SshdShellCommand</kbd>.</p>
<p>Currently, SSHd Shell framework has a limitation of being able to pass only one attribute argument to the command, but there is work going on to expand on that capability. In the mean time, it is recommended that JSON payload is used to communicate with the commands as inputs or outputs.</p>
<p>The following attributes are available on the annotations:</p>
<ul>
<li><kbd>value</kbd>: This attribute defines the command or sub-command name. Even though the name of the method does not need to match the name of the command, it is a good convention for keeping the two in sync to make the code more readable.</li>
<li><kbd>description</kbd>: This attribute defines the text that gets displayed when the <kbd>help</kbd> command is invoked. It is a good place to communicate with the users how the command is expected to be used, what inputs it takes, and so on. It is a good idea to provide as much description and documentation as possible as in the Shell, one would like to clearly educate the users of what needs to happen and how to call the command. The man pages are great so keep the documentation top notch.</li>
<li><kbd>roles</kbd>: This attribute enables us to define a security constraint on who is allowed to execute the given command. If Spring Security is also used, SSHd Shell provides the ability to configure a custom or specific <kbd>AuthenticationProvider</kbd> to be used for handling user authentication and role binding. For example, it would be easy to connect your application to the company's LDAP server and allow developers to use their regular credentials and also configure different role access controls, based on the needs of the particular organization.</li>
</ul>
<p>Each command can be queried for its usage by using help, or in the case of a command containing sub-commands, by typing the name of the top-level command.</p>
<p>While SSHd Shell comes with many built-in commands, one can easily add custom commands, taking advantage of standard Spring / Spring Boot programming style, using the <kbd>@Autowired</kbd> and <kbd>@Component</kbd> annotations to get the necessary dependencies to be wired in and automatically configured during the application start life cycle.</p>
<p>SSHd Shell also provides a nice functionality enabling the use of post-processors, invoked by a pipe (<kbd>|</kbd>) symbol. The current support allows for output highlighting <kbd>| h packt</kbd>, which will highlight the word <kbd>packt</kbd> in the output, or emailing response output  <kbd>| m</kbd> <kbd>my@email.com</kbd>, which will email the response of a command to the specified email address, given that <strong>Spring Mail</strong> is also configured and available.</p>
<p>It would be great if we could chain different commands together, like in Linux proper, so as to help process the output and filter out the necessary data when the amount of information tends to get overwhelming. Imagine that our publishers list command returns not <kbd>2</kbd>, but <kbd>2000</kbd> publishers. From this list, we want to find the ones that start with <kbd>Pa</kbd>.</p>
<p>Even though SSHd Shell does not provide this type of functionality out of the box, it does offer us an ability to implement our own post-processors by defining beans that extend the <kbd>BaseUserInputProcessor</kbd> class. Let's create one that would provide support for filtering JSON responses, something similar to how the <kbd>jq</kbd> command-line utility works.</p>
<p>To achieve this, let's create another class named <kbd>JsonPathUserInputProcessor.java</kbd> in the <kbd>src/main/java/com/example/bookpub/command</kbd> directory at the root of our project with the following content:</p>
<pre>@Component 
@Order(3) 
public class JsonPathUserInputProcessor <br/>             extends BaseUserInputProcessor { 
 
    private final Pattern pattern = Pattern.compile("[\w\W]+\s?\|\s?jq (.+)"); 
 
    @Override 
    public Optional&lt;UsageInfo&gt; getUsageInfo() { 
        return Optional.of(new UsageInfo(Arrays.&lt;UsageInfo.Row&gt;asList( 
                new UsageInfo.Row("jq &lt;arg&gt;", "JSON Path Query &lt;arg&gt; in response output of command execution"), 
                new UsageInfo.Row("", "Example usage: help | jq $.&lt;name&gt;")))); 
    } 
 
    @Override 
    public Pattern getPattern() { 
        return pattern; 
    } 
 
    @Override 
    public void processUserInput(String userInput) throws   <br/>      InterruptedException, ShellException{ 
        String[] part = splitAndValidateCommand(userInput, "\|", 2); 
        Matcher matcher = pattern.matcher(userInput); 
        Assert.isTrue(matcher.find(), "Unexpected error"); 
        String jsonQuery = matcher.group(1).trim(); 
        try { 
            String output = processCommands(part[0]); 
            Object response = JsonPath.read(output, jsonQuery); 
            ConsoleIO.writeJsonOutput(response); 
        } catch (Exception e) { 
            ConsoleIO.writeOutput(String.format("Unable to process <br/>            query %s%n%s", jsonQuery, e.getMessage())); 
        } 
    } 
} </pre>
<p>Using the pipe functionality, we can easily chain the <kbd>publishers list</kbd> command with the <kbd>jq</kbd> command in the following way:</p>
<pre>publishers list | jq $..[?(@.name =~ /Pa.*/i)]</pre>
<p>In our example, this should return us only one record, as follows:</p>
<pre style="padding-left: 30px">[ {<br/>    "id" : 1,<br/>    "name" : "Packt"<br/>} ]</pre>
<p>While it is not a full-fledged pipe functionality, the use of input processors allows for adding functionalities such as sorting, filtering, and displaying rendering, which give more flexibility to modularize and reuse common behaviors.</p>
<p>The SSHd Shell Spring Boot integration comes with a number of configuration options allowing us to disable the component, configure authentication settings, and specify usernames, passwords, and even key certificates. For example, if we want to use a specific username and password, we can do so by configuring the following properties:</p>
<pre style="padding-left: 30px">sshd.shell.username=remote
sshd.shell.password=shell
  </pre>
<p>In a real-world enterprise environment, it is more common to use the shared keys for restricted access and these can be configured using the <kbd>sshd.shell.publicKeyFile=&lt;key path&gt;</kbd> or <kbd>sshd.shell.hostKeyFile=&lt;key path&gt;</kbd> properties. Alternatively, and probably a better approach, as was already mentioned earlier, using a custom <kbd>AuthenticationProvider</kbd> implementation together with Spring Security allows the integrate of authentication mechanisms into the company's authentication system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating Micrometer metrics with Graphite</h1>
                </header>
            
            <article>
                
<p>Earlier in this chapter, you learned about the monitoring capabilities that are provided by Spring Boot. We saw examples of writing custom <kbd>HealthIndicators</kbd>, creating metrics, and using <kbd>MeterRegistry</kbd> to emit data. The simple Spring Boot Admin Web framework gave us some nice graphical UI to visualize the data, but all of these metrics were in-the-moment, with no long-term retention and historical access. Not being able to observe the trends, detect the deviations from the baseline, and compare today with last week is not a very good strategy, especially for an enterprise-complex system. We all want to be able to have access to the time series data going weeks, if not months, back and set up alarms and thresholds, if something goes unplanned.</p>
<p>This recipe will introduce us to an amazing time series graphical tool: Graphite. Graphite is a two-part system. It provides storage for numeric time series data as well as a service to render this data in a form of on-demand graphs or expose the graph data as a JSON stream. You will learn how to integrate and configure Spring's Micrometer monitoring framework with Graphite in order to send the monitoring data from a Spring Boot application to Graphite and play a bit with Graphite to visualize the different statistics that we've gathered.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Graphite is an application that is written in Python and is, thus, capable of running on virtually any system supporting Python and its libraries. There are multiple ways of installing Graphite on any given system, ranging from compilation from a source, using <kbd>pip</kbd> all the way, to prebuilt RPMs for various Linux distributions.</p>
<p>For all the different installation strategies, take a look at the Graphite documentation at <a href="http://graphite.readthedocs.org/en/latest/install.html">http://graphite.readthedocs.org/en/latest/install.html</a>. OS X users can read a very good step-by-step guide located at <a href="https://gist.github.com/relaxdiego/7539911">https://gist.github.com/relaxdiego/7539911</a>.</p>
<p>For the purposes of this recipe, we will use a premade Docker container containing Graphite as well as its counterpart Grafana. While there is an abundance of various prebuilt variants of Docker images containing combinations of Graphite and Grafana, we will use the one from <a href="https://registry.hub.docker.com/u/alexmercer/graphite-grafana/">https://registry.hub.docker.com/u/alexmercer/graphite-grafana/</a> as it contains all the right configurations that will make it easy for us to get started quickly:</p>
<ol>
<li>The first step will be to download the desired Docker container image. We will do this by executing <kbd>docker pull alexmercer/graphite-grafana</kbd>. The container size is about 500 MB; so the download might take a few minutes depending on your connection speed.</li>
<li>Both Graphite and Grafana store their data in the database files. We will need to create external directories, which will reside outside the container, and we will connect them to a running instance via Docker data volumes.
<ul>
<li>Make a directory for the Graphite data anywhere in your system, for example, in <kbd>&lt;user_home&gt;/data/graphite</kbd>.</li>
<li> Make a directory for the Grafana data, for example, in <kbd>&lt;user_home&gt;/data/grafana</kbd>.</li>
</ul>
</li>
<li>In this container, the Graphite data will go to <kbd>/var/lib/graphite/storage/whisper</kbd>, while Grafana stores its data in <kbd>/usr/share/grafana/data</kbd>. So, we will use these paths as internal volume mount destinations when starting the container.</li>
<li>Run the container by executing <kbd>docker run -v &lt;user_home&gt;/data/graphite:/var/lib/graphite/storage/whisper -v &lt;user_home&gt;/data/grafana:/usr/share/grafana/data -p 2003:2003 -p 3000:3000 -p 8888:80 -d alexmercer/graphite-grafana</kbd>.
<ul>
<li>In Docker, the <kbd>-v</kbd> <span>option configures a volume mount binding. In our example, we configured the external</span> <kbd>&lt;user_home&gt;/data/graphite</kbd> <span>directory to be the same as the</span> <kbd>/var/lib/graphite/storage/whisper</kbd> <span>directory reference in the container. The same goes for the</span> <kbd>&lt;user_home&gt;/data/grafana</kbd> <span>mapping. We can even look in the</span> <kbd>&lt;user_home&gt;/data/graphite or data/grafana</kbd> <span><span>directories to see them contain the subdirectories and files.</span></span></li>
<li>The <kbd>-p</kbd> <span>option configures the port mappings similar to the directory volumes. In our example, we mapped the following three different ports to be accessible from outside the container to the internal ports to which the various services are bound:</span><span><br/></span><kbd>2003:2003</kbd>: This port mapping externalizes the Graphite data stream listener known as <strong>Carbon-Cache Line Receiver</strong>, to which we will connect in order to send the metrics data.<br/>
<kbd>3000:3000</kbd>: This port mapping externalizes the Grafana Web Dashboard UI, which we will use to create visual dashboards on top of the Graphite data.<br/>
<kbd>8888:80</kbd>: This port mapping externalizes the Graphite Web UI. Though it is running on port <kbd>80</kbd> in the container, it is unlikely that on our development machine, port <kbd>80</kbd> is open; so it is better to map it to some other higher number port such as <kbd>8080</kbd> or <kbd>8888</kbd> in our case, as <kbd>8080</kbd> is already taken by our <kbd>BookPub</kbd> application.</li>
</ul>
</li>
</ol>
<ol start="5">
<li>If everything has gone according to the plan, Graphite and Grafana should be up and running and thus, we can access Graphite by pointing our browser to <kbd>http://localhost:8888</kbd> and we should see the following output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="300" src="assets/1714b0f1-661c-4b52-ae20-2779dbb1d2d7.png" width="468"/></div>
<ol start="6">
<li>To see Grafana, point the browser to <kbd>http://localhost:3000</kbd> so as to see the following output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="302" src="assets/8dae836b-455e-477f-a3f0-8dd6870e0883.png" width="472"/></div>
<ol start="7">
<li>The default login and password for Grafana are <kbd>admin</kbd>/<kbd>admin</kbd> and can be changed via the Web UI Admin.</li>
</ol>
<div class="packt_infobox">For the OS X users who use boot2docker, the IP would not be of the <kbd>localhost</kbd>, but rather a result of the boot2docker IP call.</div>
<ol start="8">
<li>Once we are in Grafana, we will need to add our Graphite instance as <kbd>DataSource</kbd>, so click on the icon, go to <span><span class="packt_screen">Data Sources</span>, and add a new source of the</span> <kbd>Type Graphite, Url http://localhost:80, Access</kbd><span>  proxy:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="223" src="assets/dfda06db-afca-4e90-bf61-8cdd8e23eec9.png" width="510"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>With Graphite and Grafana up and running, we are now ready to start configuring our application in order to send the metrics to the Graphite listener on port <kbd>2003</kbd>. To do this, we will use the Codahale/Dropwizard metrics library, which is fully supported by Spring Boot and thus requires a minimum amount of configuration:</p>
<ol>
<li>The first thing on our list is to add the necessary library dependencies. Extend the dependencies block in the <kbd>build.gradle</kbd> file with the following content:</li>
</ol>
<pre style="padding-left: 60px">compile("io.micrometer:micrometer-registry-graphite:latest.release") </pre>
<ol start="2">
<li>Create a file named <kbd>MonitoringConfiguration.java</kbd> in the <kbd>src/main/java/com/example/bookpub</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">@Configuration 
@ConditionalOnClass(GraphiteMeterRegistry.class) 
public class MonitoringConfiguration { 
 
    private static final Pattern blacklistedChars = 
                         Pattern.compile("[{}(),=\[\]/]"); 
 
    @Bean 
    public MeterRegistryCustomizer&lt;GraphiteMeterRegistry&gt;  
                              meterRegistryCustomizer() { 
        return registry -&gt; { 
           registry.config() 
             .namingConvention(namingConvention()); 
        }; 
    } 
 
    @Bean 
    public HierarchicalNameMapper hierarchicalNameMapper(){ 
        return (id, convention) -&gt; { 
            String prefix = "bookpub.app."; 
            String tags = ""; 
 
            if (id.getTags().iterator().hasNext()) { 
                tags = "."  
                        + id.getConventionTags(convention) 
                        .stream() 
                        .map(t -&gt; t.getKey() + "."  
                                                + t.getValue() 
                        ) 
                        .map(nameSegment -&gt;  
                                 nameSegment.replace(" ", "_") 
                        ) 
                        .collect(Collectors.joining(".")); 
            } 
 
            return prefix  
                   + id.getConventionName(convention)  
                   + tags; 
        }; 
    } 
 
    @Bean 
    public NamingConvention namingConvention() { 
        return new NamingConvention() { 
            @Override 
            public String name(String name,  
                               Meter.Type type,  
                               String baseUnit) { 
                return format(name); 
            } 
 
            @Override 
            public String tagKey(String key) { 
                return format(key); 
            } 
 
            @Override 
            public String tagValue(String value) { 
                return format(value); 
            } 
 
            private String format(String name) { 
                String sanitized = 
                   Normalizer.normalize(name, 
                                    Normalizer.Form.NFKD); 
                // Changes to the original  
                // GraphiteNamingConvention to use "dot"  
                // instead of "camelCase" 
                sanitized =  
                   NamingConvention.dot.tagKey(sanitized); 
 
                return blacklistedChars 
                           .matcher(sanitized) 
                           .replaceAll("_"); 
            } 
        }; 
    } 
} </pre>
<ol start="3">
<li>We will also need to add the configuration property settings for our Graphite instance to the <kbd>application.properties</kbd> file in the <kbd>src/main/resources</kbd> directory at the root of our project:</li>
</ol>
<pre style="padding-left: 60px">management.metrics.export.graphite.enabled=true 
management.metrics.export.graphite.host=localhost 
management.metrics.export.graphite.port=2003 
management.metrics.export.graphite.protocol=plaintext 
management.metrics.export.graphite.rate-units=seconds 
management.metrics.export.graphite.duration-units=milliseconds 
management.metrics.export.graphite.step=1m </pre>
<ol start="4">
<li>Now, let's build and run our application by executing <kbd>./gradlew clean bootRun</kbd> and if we have configured everything correctly, it should start without any issues.</li>
</ol>
<ol start="5">
<li>With the application up and running, we should start seeing some data that is in the Graphite and <kbd>bookpub</kbd> data nodes getting added to the tree under metrics. To add some more realism, let's open our browser and load a book URL, <kbd>http://localhost:8080/books/978-1-78528-415-1/</kbd>, a few dozen times to generate some metrics.</li>
<li>Let's go ahead and look at some of the metrics in Graphite and set the data time range to 15 minutes in order to get some close-look graphs, which will look similar to the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="301" src="assets/d7ccfc50-6bb0-40c8-a426-a3a92e5f7311.png" width="490"/></div>
<ol start="7">
<li>We can also create some fancy looking dashboards using this data in Grafana by creating a new dashboard and adding a <span class="packt_screen">Graph</span> panel, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="130" src="assets/ac6f0880-0768-48bb-a84e-7dd6dee1ffd9.png" width="249"/></div>
<ol start="8">
<li>The newly created <span class="packt_screen">Graph</span> panel will look like this:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="113" src="assets/2840eb11-b5f1-4535-9534-ad4a4dac34ea.png" width="244"/></div>
<ol start="9">
<li>Click on the <span class="packt_screen">no title (click here)</span> label, choose <span class="packt_screen">edit</span>, and enter the metric name <kbd>bookpub.app.http.server.requests.exception.None.method.GET.status.200.uri._books__isbn_.count</kbd> in the text field as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/398fcd94-9ce8-4ef1-8243-8a5bec4e6c00.png"/></div>
<ol start="10">
<li>Clicking on <span class="packt_screen">Dashboard</span> will take you out of the edit mode.</li>
</ol>
<p>For a more detailed tutorial, visit <a href="http://docs.grafana.org/guides/gettingstarted/">http://docs.grafana.org/guides/gettingstarted/</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>To enable exporting metrics via Graphite, we added an extra dependency on the <kbd>io.micrometer:micrometer-registry-graphite</kbd> library. Under the hood, however, it depends on the Dropwizard metrics library to provide Graphite integration, so it will add the following new dependencies to our <kbd>build</kbd> file:</p>
<ul>
<li><kbd>io.dropwizard.metrics:metrics-core</kbd>: This dependency adds the basic Dropwizard functionality, <kbd>MetricsRegistry</kbd>, common API interfaces, and base classes. This is the bare minimum that is required to get Dropwizard working and integrated into Spring Boot to handle the metrics.</li>
<li><kbd>io.dropwizard.metrics:metrics-graphite</kbd>: This adds support for <kbd>GraphiteReporter</kbd> and is needed in order to configure Dropwizard to send the monitoring data that it collects to our Graphite instance.</li>
</ul>
<p>In order to keep things clean and nicely separated, we created a separate configuration class with all the monitoring-related beans and settings: <kbd>MonitoringConfiguration</kbd>. In this class, we configured three <kbd>@Bean</kbd> instances: a custom <kbd>MeterRegistryCustomizer</kbd> implementation to customize the <kbd>GraphiteMeterRegistry</kbd> instance, <kbd>HigherarchicalNameMapper</kbd>, and <kbd>NamingConvention</kbd> to go along with it.</p>
<p>The reason why we had to create our own customization is twofold. We wanted to comply with the classic Graphite metric naming scheme, which uses the dot (<kbd>.</kbd>) notation to separate metric names in a hierarchy. Unfortunately, for whatever reason, Micrometer Graphite implementation has opted for using the <kbd>camelCase</kbd> collapsing notation instead, which made metric names like <kbd>counter.datasource.BookRepository</kbd> translate into the <kbd>counterDatasourceBookRepository</kbd> name to be displayed inside Graphite. Having such a long name, without hierarchical tree makes for a very difficult search and discovery inside Graphite UI, when many metrics are present. Also, all the metrics get placed under a root (<kbd>/</kbd>) tree, without creating a dedicated application folder, which also leads to poor readability and usage. We have added code to our <kbd>HigherarchicalNameMapper</kbd> instance to prepend <span>the application prefix to all the metrics being exported to Graphite so that they all get put into <kbd>subtree: /bookpub/app/*.</kbd></span>:</p>
<pre>String prefix = "bookpub.app."; 
... 
return prefix + id.getConventionName(convention) + tags; </pre>
<p>The <kbd>NamingConvention</kbd> provides precise configuration about how to convert particular Meter names, keys, values, and tags into proper Graphite variants. Inside the <kbd>format(String name)</kbd> method, we declare that we want to use a dot (<kbd>.</kbd>) separation between elements via the <kbd>NamingConvention.dot</kbd> implementation.</p>
<p>The <kbd>management.metrics.export.graphite</kbd> group of properties define how to send the data to the Graphite instance. We configured it to do so every 1 minute, translate all the time duration intervals, such as the latency measurements, into milliseconds and all the variable rates, such as the number of requests per some time frame, into seconds. Most of these values have their default configuration settings for Graphite provided, but can be changed, if desired.</p>
<p>Notice that we've used the <kbd>@ConditionalOnClass</kbd> annotation to indicate that we only want to apply this <kbd>@Configuration</kbd> if the Micrometer Graphite provided class <kbd>GraphiteMeterRegistry.class</kbd> is present in the classpath. This is needed to not try to instantiate Graphite beans during tests, as there might not be a Graphite instance running and available in the testing environment.</p>
<p>As you can see from the available metrics from Graphite UI, there are many metrics that are provided out of the box. Some notable ones are about JVM and OS metrics, which expose the memory and thread metrics to Graphite in the memory and threads data nodes among other data. They can be found in <kbd>Metrics/bookpub/app/jvm</kbd>, <kbd>Metrics/bookpub/app/process</kbd>, or <kbd>Metrics/bookpub/app/system</kbd> in the Graphite tree.</p>
<p>Micrometer core library provides a number of meter binders for additional system metrics. If there is a need to export things like thread or executor information, or get a view into the file descriptors, one can export additional beans by simply declaring a method returning <kbd>new JvmThreadMetrics()</kbd> or <kbd>new FileDescriptorMetrics()</kbd> for example.</p>
<p>The running application will gather all the metrics registered with <kbd>MeterRegistry</kbd> and every configured exporter (in our case, <kbd>GraphiteMeterRegistry</kbd>) reports all these metrics at a timed interval to its destination. The proper exporter implementations run in a separate <kbd>ThreadPool</kbd>, thus outside of the main application threads and not interfering with them. However, this should be kept in mind in case the Meter implementations use some <kbd>ThreadLocal</kbd> data internally, which would not be available to exporters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating Micrometer metrics with Dashing</h1>
                </header>
            
            <article>
                
<p>The previous recipe has given us a glimpse of how we can collect the various metrics from our application during its runtime. We've also seen how powerful the ability to visualize this data as a set of graphs of historical trends can be.</p>
<p>While Grafana and Graphite offer us the very powerful capability of manipulating the data in the form of graphs and building elaborate dashboards that are full of thresholds, applied data functions, and much more, sometimes we want something simpler, more readable, and something widgety. This is exactly the kind of dashboard experience that is provided by Dashing.</p>
<p><strong>Dashing</strong> is a popular dashboard framework developed by Shopify and written in Ruby/Sinatra. It provides you with an ability to create an assortment of dashboards that are comprised of different types of widgets. We can have things such as graphs, meters, lists, numeric values, or just plain text to display the information.</p>
<p>In this recipe, we will install the Dashing framework, learn how to create dashboards, send and consume the data to report from an application directly as well as fetch it from Graphite, and use the Dashing API to push the data to the Dashing instance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In order to get Dashing to run, we will need to have an environment that has a Ruby 1.9+ installed with RubyGems.</p>
<p>Typically, Ruby should be available on any common distribution of Linux and OS X. If you are running Windows, I would suggest using <a href="http://rubyinstaller.org">http://rubyinstaller.org</a> in order to get the installation bundle.</p>
<p>Once you have such an environment available, we will install Dashing and create a new dashboard application for our use, as follows:</p>
<ol>
<li>Installing Dashing is very easy; simply execute the gem install dashing command to install Dashing RubyGems on your system.</li>
<li>With the RubyGem successfully installed, we will create the new dashboard named <kbd>bookpub_dashboard</kbd> by executing the dashing new <kbd>bookpub_dashboard</kbd> command in the directory where you want the dashboard application to be created.</li>
<li>Once the dashboard application has been generated, go to the <kbd>bookpub_dashboard</kbd> directory and execute the <kbd>bundle</kbd> command to install the required dependency gems.</li>
<li>After the gems bundle has been installed, we can start the dashboard application by executing the <kbd>dashing start</kbd> command and then pointing our browser to <kbd>http://localhost:3030</kbd> to see the following result:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="245" src="assets/10c6167a-a909-4e1a-a0d7-dbb50453f232.png" width="382"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>If you look carefully at the URL of our shiny new dashboard, you will see that it actually says <kbd>http://localhost:3030/sample</kbd> and displays a sample dashboard that was automatically generated. We will use this sample dashboard to make some changes in order to display some metrics from our application directly as well as get some raw metrics from the Graphite data API endpoint.</p>
<p>To demonstrate how to connect the data from the application <kbd>/actuator/metrics</kbd> endpoint so as to display it in the Dashing dashboard, we will change the <kbd>Buzzwords</kbd> widget to display the counts of our data repositories, as follows:</p>
<ol>
<li>Before we start, we will need to add the <kbd>'httparty', '&gt;= 0.13.3'</kbd> gem to the <kbd>Gemfile</kbd> file located in the <kbd>bookpub_dashboard</kbd> directory, which will enable us to use an HTTP client in order to extract the monitoring metrics from the HTTP endpoints.</li>
<li>After adding the gem, run the <kbd>bundle</kbd> command one more time to install the newly added gem.</li>
<li>Next, we will need to modify the <kbd>sample.erb</kbd> dashboard definition located in the <kbd>bookpub_dashboard/dashboards</kbd> directory, replacing <kbd>&lt;div data-id="buzzwords" data-view="List" data-unordered="true" data-title="Buzzwords" data-moreinfo="# of times said around the office"&gt;&lt;/div&gt;</kbd> with <kbd>&lt;div data-id="repositories" data-view="List" data-unordered="true" data-title="Repositories Count" data-moreinfo="# of entries in data repositories"&gt;&lt;/div&gt;</kbd>.</li>
<li>With the widget replaced, we will create a new data provisioning job file named <kbd>repo_counters.rb</kbd> in the <kbd>bookpub_dashboard/jobs</kbd> directory with the following content:</li>
</ol>
<pre style="padding-left: 60px">require 'httparty' 
 
repos = ['AuthorRepository', 'ReviewerRepository', 'BookRepository', 'PublisherRepository'] 
 
SCHEDULER.every '10s' do 
  data = JSON.parse(HTTParty.get("http://localhost:8081/metrics").body) 
  repo_counts = [] 
 
  repos.each do |repo| 
    current_count = data["counter.datasource.#{repo}"] 
    repo_counts &lt;&lt; { label: repo, value: current_count } 
  end 
 
  send_event('repositories', { items: repo_counts }) 
end </pre>
<ol start="5">
<li>With all the code changes in place, let's start our dashboard by executing the <kbd>dashing start</kbd> command. Go to <kbd>http://localhost:3030/sample</kbd> in the browser to see our new widget displaying the data as shown in the following icon:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="280" src="assets/6b360ec9-ce6b-4d45-ba47-bc3f576b422f.png" width="182"/></div>
<ol start="6">
<li>If we use the remote Shell to log in to the application, as we did earlier in this chapter, and add a publisher, we would see the counter on the dashboard increase.</li>
<li>Another way to push the data to the dashboard is to use their RESTful API. Let's update the text in the top left text widget by executing <kbd>curl -d '{ "auth_token": "YOUR_AUTH_TOKEN", "text": "My RESTful dashboard update!" }' http://localhost:3030/widgets/welcome</kbd>.</li>
</ol>
<ol start="8">
<li>If everything has worked correctly, we should see the text updated to our new value, <kbd>My RESTful dashboard update!</kbd>, under the <span class="packt_screen">Hello</span> title.</li>
</ol>
<ol start="9">
<li>In an environment where multiple instances of the same application kind are running, it is probably not a good idea to directly pull the data from each node, especially if they are very dynamic and can come and go as they please. It is advised that you consume the data from a more static and well-known location, such as a Graphite instance. To get a demonstration of volatile data metrics, we will consume the memory pool data for the <kbd>Eden</kbd>, <kbd>Survivor</kbd>, and <kbd>OldGen</kbd> spaces and display them instead of the <span class="packt_screen">Convergence</span>, <span class="packt_screen">Synergy</span>, and <span class="packt_screen">Valuation</span> graph dashboards. We will start by replacing the content of the <kbd>sample.rb</kbd> job file located in the <kbd>bookpub_dashboard/jobs</kbd> directory with the following content:</li>
</ol>
<pre style="padding-left: 60px">require 'httparty' 
require 'date' 
 
eden_key = "bookpub.app.jvm.memory.used.area.heap.id.PS_Eden_Space" 
survivor_key = "bookpub.app.jvm.memory.used.area.heap.id.PS_Survivor_Space" 
oldgen_key = "bookpub.app.jvm.memory.used.area.heap.id.PS_Old_Gen" 
 
SCHEDULER.every '60s' do 
  data = JSON.parse(HTTParty.get("http://localhost:8888/render/?from=-11minutes&amp;target=#{eden_key}&amp;target=#{survivor_key}&amp;target=#{oldgen_key}&amp;format=json&amp;maxDataPoints=11").body) 
 
  data.each do |metric| 
    target = metric["target"] 
    # Remove the last data point, which typically has empty value 
    data_points = metric["datapoints"][0...-1] 
    if target == eden_key 
      points = [] 
      data_points.each_with_index do |entry, idx| 
        value = entry[0] rescue 0 
        points &lt;&lt; { x: entry[1], y: value.round(0)} 
      end 
      send_event('heap_eden', points: points) 
    elsif target == survivor_key 
      current_survivor = data_points.last[0] rescue 0 
      current_survivor = current_survivor / 1048576 
      send_event("heap_survivor", { value: <br/>                   current_survivor.round(2)}) 
    elsif target == oldgen_key 
      current_oldgen = data_points.last[0] rescue 0 
      last_oldgen = data_points[-2][0] rescue 0 
      send_event("heap_oldgen", { <br/>                   current: current_oldgen.round(2), <br/>                   last: last_oldgen.round(2)<br/>                 }) 
    end 
  end 
end </pre>
<ol start="10">
<li>In the <kbd>sample.erb</kbd> template located in the <kbd>bookpub_dashboard/dashboards</kbd> directory, we will replace the <span class="packt_screen">Synergy</span>, <span class="packt_screen">Valuation</span>, and <span class="packt_screen">Convergence</span> graphs with the following alternatives:</li>
</ol>
<ul>
<li style="padding-left: 30px"><kbd>&lt;div data-id="synergy" data-view="Meter" data-title="Synergy" data-min="0" data-max="100"&gt;&lt;/div&gt;</kbd> gets replaced with <kbd>&lt;div data-id="heap_survivor" data-view="Meter" data-title="Heap: Survivor" data-min="0" data-max="100" data-moreinfo="In megabytes"&gt;&lt;/div&gt;</kbd></li>
<li style="padding-left: 30px"><kbd>&lt;div data-id="valuation" data-view="Number" data-title="Current Valuation" data-moreinfo="In billions" data-prefix="$"&gt;&lt;/div&gt;</kbd> gets replaced with <kbd>&lt;div data-id="heap_oldgen" data-view="Number" data-title="Heap: OldGen" data-moreinfo="In bytes" &gt;&lt;/div&gt;</kbd></li>
<li style="padding-left: 30px"><kbd>&lt;div data-id="convergence" data-view="Graph" data-title="Convergence" style="background-color:#ff9618"&gt;&lt;/div&gt;</kbd> gets replaced with <kbd>&lt;div data-id="heap_eden" data-view="Graph" data-title="Heap: Eden" style="background-color:#ff9618" data-moreinfo="In bytes"&gt;&lt;/div&gt;</kbd></li>
</ul>
<ol start="11">
<li>After all the changes are made, we can restart the dashboard application and reload our browser to <kbd>http://localhost:3030</kbd> to see the following result:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="278" src="assets/37b6ceef-0e4a-4208-9b87-67d91838806b.png" width="466"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we have seen how to extract the data directly from our application and via Graphite, and render it using the Dashing dashboard as well as pushing information directly to Dashing using their RESTful API. It is no secret that it is better to see something once than hear about it seven times. This is true when it comes to trying to get a holistic picture of the key metrics that represent how the systems behave at runtime and to be able to act on the data quickly.</p>
<p>Without going in to great detail about the internals of Dashing, it is still important to mention a few things about how data gets in to Dashing. This can happen in the following two ways:</p>
<ul>
<li><strong>Scheduled jobs</strong>: This is used to pull data from the external sources</li>
<li><strong>RESTful API</strong>: This is used to push data to Dashing from outside</li>
</ul>
<p>The scheduled jobs are defined in the jobs directory in the generated dashboard application. Each file has a piece of ruby code wrapped in the <kbd>SCHEDULER.every</kbd> block, which computes the data points and sends an event to an appropriate widget with the new data for an update.</p>
<p>In our recipe, we created a new job named <kbd>repo_counters.rb</kbd> where we used the <kbd>httparty</kbd> library in order to make a direct call to our application instance's <kbd>/actuator/metrics/#{name}</kbd> endpoint and extracted the counters for each of the predefined repositories. Looping over the metrics, we created a <kbd>repo_counts</kbd> collection with data for each repository containing a label display and a value count. The resulting collection was sent to the repositories widget for an update in the form of <kbd>event: send_event('repositories', { items: repo_counts })</kbd>.</p>
<p>We configured this job to get executed every 10 seconds, but if the rate of data change is not very frequent, the number can be changed to a few minutes or even hours. Every time the scheduler runs our job, the repositories widget is updated via the client-side websockets communication with the new data. Looking in dashboards/<kbd>sample.erb</kbd>, we can find the widget's definition using <kbd>data-id="repositories"</kbd>.</p>
<p>Besides adding our own new job, we also changed the existing <kbd>sample.rb</kbd> job to pull data from Graphite using Graphite's RESTful API to populate the different types of widgets in order to display the memory heap data. As we were not pulling data directly from the application instance, it was a good idea not to put the code in the same job because the jobs could—and in our case, do—have different time intervals. As we send data to Graphite only once every minute, it does not make sense to pull it any less frequently than this.</p>
<p>To get the data out of Graphite, we used the following API call:</p>
<pre>/render/?from=-11minutes&amp;target= bookpub.app.jvm.memory.used.area.heap.id.PS_Eden_Space &amp;target= bookpub.app.jvm.memory.used.area.heap.id.PS_Survivor_Space &amp;target= bookpub.app.jvm.memory.used.area.heap.id.PS_Old_Gen &amp;format=json&amp;maxDataPoints=11
  </pre>
<p>Take a look at the following parameters mentioned in the preceding code snippet:</p>
<ul>
<li><kbd>target</kbd>: This parameter is a repeated value that defines a list of all the different metrics that we want to retrieve.</li>
<li><kbd>from</kbd>: This parameter specifies the time range; in our case, we asked for data going back 11 minutes to.</li>
<li><kbd>format</kbd>: This parameter configures the desired output format. We chose JSON but many others are available. Refer to <a href="http://graphite.readthedocs.org/en/latest/render_api.html#format">http://graphite.readthedocs.org/en/latest/render_api.html#format</a>.</li>
<li><kbd>maxDataPoints</kbd>: This parameter indicates how many entries we want to get.</li>
</ul>
<p>The reason we asked for 11 entries and not 10 is due to a frequent occurrence where the last entry of short-ranged requests, which consist of only a few minutes, sometimes get returned as empty. We just use the first 10 entries and ignore the most recent ones to avoid weird data visualization.</p>
<p>Iterating over the target data, we will populate the appropriate widgets such as <kbd>heap_eden</kbd>, <kbd>heap_survivor</kbd>, and <kbd>heap_oldgen</kbd>, with their designated data, as follows:</p>
<ul>
<li><kbd>heap_eden</kbd>: This is a <kbd>Graph</kbd> widget, as defined in the <kbd>sample.erb</kbd> template in the form of a <kbd>data-view="Graph" </kbd> attribute, so it wants a data input in the form of the points collection containing a value for <kbd>x</kbd> and <kbd>y</kbd>. The <kbd>x</kbd> value represents a timestamp, which conveniently gets returned to us by Graphite and is automatically converted to the minutes display value by the Graph widget. The <kbd>y</kbd> value represents the memory pool utilization in bytes. As the value from Graphite is in the form of a decimal number, we will need to convert it to a whole number so as to make it look better.</li>
<li><kbd>heap_survivor</kbd>: This is a <kbd>Meter</kbd> widget, as defined in the <kbd>sample.erb</kbd> template in the form of a <kbd>data-view="Meter"</kbd> attribute, so it wants a data input as a simple value number between a template configured range. In our case, the range is set as the <kbd>data-min="0" data-max="100"</kbd> attribute. Even though we chose to round the number to two decimal positions, it could probably just be an integer as it is precise enough for the purpose of a dashboard display. You will also notice that inside <kbd>sample.rb</kbd>, we convert the raw value, which is in bytes, into megabytes, for better readability— <kbd>current_survivor = current_survivor / 1048576</kbd>.</li>
<li><kbd>heap_oldgen</kbd>: This is a <kbd>Number</kbd> widget, as defined in the <kbd>sample.erb</kbd> template in the form of a <kbd>data-view="Number"</kbd> attribute, so it wants a data input as a current value and optionally a last value; in this case, a percentage change with the change direction will be displayed as well. As we get the last 10 entries, we have no issues in retrieving both the current and last values so we can easily satisfy this requirement.</li>
</ul>
<p>In this recipe, we also experimented with Dashing's RESTful API by trying to use a <kbd>curl</kbd> command to update the value of the welcome widget. This was a push operation and can be used in situations where there is no data API exposed, but you have the capability of creating some sort of a script or piece of code that could send the data to Dashing instead. To achieve this, we used the following command: <kbd>curl -d '{ "auth_token": "YOUR_AUTH_TOKEN", "text": "My RESTful dashboard update!" }' http://localhost:3030/widgets/welcome</kbd>.</p>
<p>The Dashing API accepts data in a JSON format, sent via a POST request that contains the following parameters needed for the widgets as well as the widget ID, which is a part of the URL path itself:</p>
<ul>
<li><kbd>auth_token</kbd>: This allows for a secure data update and can be configured in the dashboard root directory in the <kbd>config.ru</kbd> file.</li>
<li><kbd>text</kbd>: This is a <kbd>widget</kbd> property that is being changed. As we are updating a <kbd>Text</kbd> widget, as defined in the <kbd>sample.erb</kbd> template in the form of a <kbd>data-view="Text"</kbd> attribute, we need to send it to text to update.</li>
<li><kbd>/widgets/&lt;widget id&gt;</kbd>: This URL path identifies the particular widget where the update is destined to. The <kbd>id</kbd> corresponds to a declaration in the <kbd>sample.erb</kbd> template. In our case, it looks like <kbd>data-id="welcome"</kbd>.</li>
</ul>
<p>The definition of the various widgets can also be manipulated and a very rich collection of the various widgets has been created by the community, which is available at <a href="https://github.com/Shopify/dashing/wiki/Additional-Widgets">https://github.com/Shopify/dashing/wiki/Additional-Widgets</a>. The widgets get installed in the widgets directory in the dashboard and can be installed by simply running <kbd>dashing install &lt;GIST&gt;</kbd>, where <kbd>GIST</kbd> is the hash of the GitHub Gist entry.</p>
<p>The dashboard template files, similar to our <kbd>sample.erb</kbd> template, can be modified in order to create the desired layout for each particular dashboard as well as multiple dashboard templates, which can be rotated or directly loaded manually.</p>
<p>Each dashboard represents a grid in which the various widgets get placed. Each widget is defined by a <kbd>&lt;div&gt;</kbd> entry with the appropriate configuration attributes and it should be nested in the <kbd>&lt;li&gt;</kbd> grid element. We can use the data element attributes to control the positioning of each widget in the grid, which is as follows:</p>
<ul>
<li><kbd>data-row</kbd>: This represents the row number where the widget should be positioned</li>
<li><kbd>data-col</kbd>: This represents the column number where the widget should be positioned</li>
<li><kbd>data-sizex</kbd>: This defines the number of columns the widget will span horizontally</li>
<li><kbd>data-sizey</kbd>: This defines the number of rows the widget will span vertically</li>
</ul>
<p>The existing widgets can be modified to change their look and feel as well as extend their functionality; so the sky is the limit for what kind of information display we can have. You should definitely check out <a href="http://dashing.io">http://dashing.io</a> for more details.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>