- en: Algorithm Design Paradigms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法设计范式
- en: In the previous chapter, we learned about hash tables and binary search trees.
    In this chapter, we will explore algorithm design paradigms. These design patterns
    can be seen as the generic methods or approaches that motivate the design of a
    class of algorithms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了哈希表和二叉搜索树。在这一章中，我们将探讨算法设计范式。这些设计模式可以被视为激发一类算法设计的通用方法或方法。
- en: Just as an algorithm is a higher abstraction than a computer program, an algorithm design
    paradigm is an abstraction higher than an algorithm. The choice of an algorithm
    paradigm is an important one when designing an algorithm.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如算法是比计算机程序更高层次的抽象一样，算法设计范式是比算法更高层次的抽象。在设计算法时，选择算法范式是一个重要的决定。
- en: 'This chapter will focus on the following three algorithm paradigms:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍以下三个算法范式：
- en: Greedy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贪心
- en: Divide and conquer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分治
- en: Dynamic programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态规划
- en: By becoming familiar with these higher abstractions, you can make more informed decisions
    when designing algorithms.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过熟悉这些更高层次的抽象，你可以在设计算法时做出更明智的决定。
- en: In a previous chapter, we have come across the merge sort and quick sort algorithms,
    which are examples of the divide and conquer paradigm. As the name suggests, both
    of these algorithms *divide* the input into smaller parts, which are then solved
    recursively (*conquer*).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们遇到了归并排序和快速排序算法，它们是分治范式的例子。正如其名所示，这两个算法都将输入*分割*成更小的部分，然后递归地解决（*征服*）。
- en: There are obviously more algorithm design paradigms, but these three already
    cover a broad range of problems. Some other paradigms we're not talking about
    in this book are backtracking and prune and search. There are even paradigms focused
    on specific branches of computer science. The sweep line algorithms, in computational geometry,
    is an example of this.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，还有更多的算法设计范式，但这三个已经涵盖了广泛的问题范围。本书中未讨论的其他范式包括回溯和剪枝搜索。甚至还有一些范式专注于计算机科学的特定分支。计算几何中的扫描线算法就是这类范式的例子。
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Describe greedy, divide and conquer, and dynamic programming algorithm paradigms
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述贪心、分治和动态规划算法范式
- en: Analyze common problems solved by using the described paradigms
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析使用描述的范式解决的常见问题
- en: List the properties of a problem to be solved by each paradigm
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出每个范式要解决的问题的性质
- en: Solve some well-known problems that explain the applicability of each paradigm
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决一些解释每个范式适用性的知名问题
- en: Introducing Greedy Algorithms
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍贪心算法
- en: Algorithms typically go through a sequence of steps, wherein each step you have
    a set of choices. Greedy algorithms, as the name suggests, follow the heuristic
    of making the locally choice at each step, with the hope of arriving at a global
    optimum. To better understand what we mean by this, let's introduce a problem.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 算法通常经过一系列步骤，其中每个步骤你都有一个选择集。贪心算法，正如其名所示，在每个步骤都遵循局部最优的启发式方法，希望达到全局最优。为了更好地理解我们所说的这个，让我们引入一个问题。
- en: The Activity Selection Problem
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动选择问题
- en: Peter is an energetic guy, and usually has many things to do in a given day.
    However, with the amount of things he wants to do, he is usually unable to do
    them all in a single day. What he usually does after waking up is write up a list
    of activities that he has to do, along with their time span. Then, looking at
    that list, he devises a plan for the day, trying to accommodate as many activities
    as possible.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 彼得是一个充满活力的人，通常在给定的一天里有很多事情要做。然而，由于他想做的事情很多，他通常无法在一天内完成所有的事情。他通常在醒来后写下他必须做的事情的清单，包括它们的时间范围。然后，看着这个清单，他制定了一天的计划，试图尽可能多地安排活动。
- en: 'Being an energetic guy, he usually rushes through this process and finds himself
    doing fewer activities than possible throughout the day. Can you help him maximize
    the amount of activities he can do in a day, given his schedule? An example of
    a schedule for Peter is given in the following table:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于他是一个充满活力的人，他通常会快速完成这个过程，发现自己一天中做的活动比可能做的要少。你能帮助他根据他的日程表最大化他一天内能做的事情的数量吗？彼得的一个日程表示例如下表所示：
- en: '| **ID** | **Activity** | **Time Span** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **ID** | **Activity** | **Time Span** |'
- en: '| 1 | Tidy up his room | 10:00 - 12:00 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 整理他的房间 | 10:00 - 12:00 |'
- en: '| 2 | Going to the rock concert | 20:00 - 23:00 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 去参加摇滚音乐会 | 20:00 - 23:00 |'
- en: '| 3 | Play chess at the local club | 17:00 - 19:00 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 在当地俱乐部下棋 | 17:00 - 19:00 |'
- en: '| 4 | Take a shower | 10:00 - 10:30 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 洗澡 | 10:00 - 10:30 |'
- en: '| 5 | Dinner with friends | 19:00 - 20:30 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 和朋友吃晚餐 | 19:00 - 20:30 |'
- en: '| 6 | Play Civilization VI | 21:30 - 23:00 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 玩文明VI | 21:30 - 23:00 |'
- en: '| 7 | Have lunch with friends | 12:30 - 13:30 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 和朋友吃午餐 | 12:30 - 13:30 |'
- en: '| 8 | Go to the cinema | 20:00 - 22:00 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 去电影院 | 20:00 - 22:00 |'
- en: '| 9 | Go biking in the park | 17:00 - 19:30 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 在公园骑自行车 | 17:00 - 19:30 |'
- en: '| 10 | Go to the beach | 16:00 - 19:00 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 去海滩 | 16:00 - 19:00 |'
- en: '| 11 | Go to the library | 15:00 - 17:00 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 去图书馆 | 15:00 - 17:00 |'
- en: 'Table 4.1: Peter''s schedule'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1：彼得的时间表
- en: This is known as the **activity selection problem**. The problem is to schedule
    several competing activities that require exclusive use of a common resource (which
    is Peter, in this case), with the goal of selecting a maximum size set of activities
    that are mutually compatible.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**活动选择问题**。问题是要安排几个相互竞争的活动，这些活动需要使用一个共同的资源（在这种情况下是彼得），目标是选择一个最大数量的相互兼容活动集合。
- en: In other words, we are trying to find the biggest set of activities that Peter
    can perform in a day. Each activity (*a[i]*) has a start time (*s[i]*) and a finish
    time (*f[i]*). Two activities, *a[i]* and *a[j]*, are considered compatible if
    the intervals (*s[i]*, *f[i]*) and (*s[j]*, *f[j]*) do not overlap, for example,
    *s[i] ≥ f[j]* or *s[j] ≥ f[i]*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们正在尝试找到彼得在一天内可以执行的最大活动集合。每个活动 (*a[i]*) 都有一个开始时间 (*s[i]*) 和一个结束时间 (*f[i]*).
    如果两个活动 *a[i]* 和 *a[j]* 的区间 (*s[i]*, *f[i]*) 和 (*s[j]*, *f[j]*) 不重叠，例如，*s[i] ≥
    f[j]* 或 *s[j] ≥ f[i]*，则认为这两个活动是兼容的。
- en: 'Looking at Peter''s schedule, and converting the start and finish times to
    minutes since the start of a day, we can arrive at the following table. To convert
    the times to minutes since the start of the day, we multiply the hours by 60 and
    add the minutes. For example, `activity 1` runs from 10:00 to 12:00\. 10:00 is
    *600 (10*60 + 0)* minutes since the start of the day, and 12:00 is *720 (12*60
    + 0)* minutes since the start of the day:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 观察彼得的日程安排，并将开始和结束时间转换为一天开始以来的分钟数，我们可以得到以下表格。要将时间转换为一天开始以来的分钟数，我们将小时数乘以60并加上分钟数。例如，`activity
    1` 从 10:00 到 12:00\. 10:00 是从一天开始以来的 *600 (10*60 + 0)* 分钟，12:00 是从一天开始以来的 *720
    (12*60 + 0)* 分钟：
- en: '| **ai** | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **ai** | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 |'
- en: '| **si** | 600 | 1200 | 1020 | 600 | 1140 | 1290 | 750 | 1200 | 1020 | 960
    | 900 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **si** | 600 | 1200 | 1020 | 600 | 1140 | 1290 | 750 | 1200 | 1020 | 960
    | 900 |'
- en: '| **fi** | 720 | 1380 | 1140 | 630 | 1230 | 1380 | 810 | 1320 | 1170 | 1140
    | 1020 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **fi** | 720 | 1380 | 1140 | 630 | 1230 | 1380 | 810 | 1320 | 1170 | 1140
    | 1020 |'
- en: 'Table 4.2: Start and finish times of peter''s activities'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2：彼得活动的开始和结束时间
- en: 'For this example, the subset *{a[1], a[3], a[5], a[6]}* consists of mutually
    compatible activities, as their times don''t overlap. It is not a maximum subset
    (that is, we can find a set with a larger number of activities), since the subset
    *{a[3], a[4], a[5], a[6], a[7], a[11]}* is larger (note that the order of the
    activities is *a[4]*, *a[7]*, *a[11]*, *a[3]*, *a[5]* and *a[6]*). In fact, it
    is a larger subset of mutually compatible activities. It is not the only one:
    another possible larger subset is *{a[1], a[7], a[11], a[3], a[5], a[6]}*.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，子集 *{a[1], a[3], a[5], a[6]}* 包含相互兼容的活动，因为它们的执行时间不重叠。它不是一个最大子集（也就是说，我们可以找到一个包含更多活动数量的集合），因为子集
    *{a[3], a[4], a[5], a[6], a[7], a[11]}* 更大（注意活动的顺序是 *a[4]*, *a[7]*, *a[11]*, *a[3]*,
    *a[5]* 和 *a[6]*）。实际上，它是一个更大的相互兼容活动子集。它不是唯一的：另一个可能更大的子集是 *{a[1], a[7], a[11], a[3],
    a[5], a[6]}*。
- en: How should we approach this problem to find the maximum size set of activities
    that are mutually compatible? It turns out we should do the greedy choice. What
    this means is that, at each step of the algorithm, from the set of activities
    that we can still perform, we should choose one greedily.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何解决这个问题，以找到最大数量的相互兼容活动集合？结果是我们应该进行贪心选择。这意味着在算法的每一步中，从我们还可以执行的活动集合中，我们应该选择一个贪心选择。
- en: The greedy choice may not be immediate, but you can intuitively think that we
    should select activities that leave Peter available for as many other activities
    as possible.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 贪心选择可能不是立即的，但你可以直观地认为我们应该选择尽可能让彼得可以参加更多其他活动的活动。
- en: 'We can have two approaches to resolve this problem, and they are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有两种方法来解决这个问题，如下所示：
- en: Always choose the activity with the earliest starting time; however, we can
    have the activity with the earliest starting time finishing after all the other
    activities.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是选择开始时间最早的活动；然而，我们可以选择一个在所有其他活动之后结束的活动。
- en: Choose the activity that consumes the least amount of time; however, we can
    have a small activity overlapping two or more non-overlapping activities (for
    example, activities *[1, 4)*, *[3, 5)* and *[4, 8)*).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择耗时最少的活动；然而，我们可以有一个小的活动与两个或更多非重叠活动重叠（例如，活动 *[1, 4)*，*[3, 5)* 和 *[4, 8)*）。
- en: Hence, both of these approaches don't work.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这两种方法都不适用。
- en: From the set of activities that we are able to choose, we must choose the first
    one to finish, as that is the activity that would leave Peter available for as
    many of the activities that follow it as possible. If we sort activities by finish
    time, we can then always select the first activity we find that is compatible
    with the last activity selected for Peter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们能够选择的活动集合中，我们必须选择第一个完成的活动，因为那将是使彼得能够尽可能多地参与后续活动的活动。如果我们按完成时间对活动进行排序，那么我们就可以始终选择第一个与彼得最后选择的活动兼容的活动。
- en: Solving the Activity Selection Problem
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决活动选择问题
- en: To implement the greedy algorithm in Java to solve the activity selection problem,
    as **described previously**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，用Java实现贪心算法以解决活动选择问题。
- en: 'A possible implementation of the algorithm described to solve the activity
    selection problem is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 解决活动选择问题的算法的一个可能的实现如下：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Navigate to [https://goo.gl/xYT2Ho](https://goo.gl/xYT2Ho) to access complete
    code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 导航至 [https://goo.gl/xYT2Ho](https://goo.gl/xYT2Ho) 以访问完整的代码。
- en: After having sorted the activities by finish time, the selection part of the
    algorithm runs in *O(n)* time. Since we can't sort in *O(n)*, the overall complexity
    of this algorithm is bounded by the complexity of the sorting algorithm. As seen
    in previous chapters, we can sort in *O(nlog(n))* so that's the runtime complexity
    of the algorithm we've devised for the activity selection problem. The algorithm
    looks good, but how can we be sure that it always arrives at the optimal solution?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在按完成时间对活动排序后，算法的选择部分运行在 *O(n)* 时间内。由于我们无法在 *O(n)* 时间内排序，因此该算法的整体复杂度受排序算法的复杂度限制。如前几章所见，我们可以以
    *O(nlog(n))* 的时间进行排序，因此这是我们为活动选择问题设计的算法的运行时间复杂度。算法看起来不错，但我们如何确保它总是到达最优解呢？
- en: Ingredients of a Greedy Algorithm
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贪心算法的成分
- en: 'There are two basic ingredients every greedy algorithm has in common. They
    are as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个贪心算法都有两个基本成分是共通的。它们如下：
- en: Optimal substructure property
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最优子结构属性
- en: Greedy choice property
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贪心选择属性
- en: Optimal Substructure Property
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最优子结构属性
- en: The first step in solving an optimization problem by using a greedy approach
    is to characterize the structure of an optimal solution. A problem exhibits the
    optimal substructure property if an optimal solution to the problem within it
    contains optimal solutions to subproblems.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用贪心方法解决优化问题的第一步是描述最优解的结构。如果问题内的一个最优解包含子问题的最优解，则问题表现出最优子结构属性。
- en: Intuitively, we can think that the activity selection problem exhibits the optimal
    substructure property in the sense that, if we suppose that a given activity belongs
    to a maximum size set of mutually compatible activities, then we are left to choose
    the maximum size set of mutually compatible activities from the ones that finish
    before this activity starts and that start after this activity finishes. Those
    two sets must also be maximum sets for the compatible activities, so that they
    can showcase the optimal substructure of this problem.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 直观上，我们可以认为活动选择问题表现出最优子结构属性，即如果我们假设一个给定的活动属于一个最大尺寸的相互兼容活动集合，那么我们只需从在活动开始之前完成并且在该活动结束后开始的活动中选择最大尺寸的相互兼容活动集合。这两个集合也必须是兼容活动的最大集合，以便它们可以展示这个问题的最优子结构。
- en: 'Formally, it is possible to prove that the activity selection problem exhibits
    optimal substructure. Let''s assume we have the set of activities sorted in monotonically
    increasing order of finish time so that the following can be true for activities
    *i* and *j*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 形式上，我们可以证明活动选择问题表现出最优子结构。假设我们按完成时间的单调递增顺序对活动集合进行排序，那么以下对于活动 *i* 和 *j* 可以成立：
- en: '*f[i] ≤ f[j] if i ≤ j*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*f[i] ≤ f[j] if i ≤ j*'
- en: Whereas *f[i]* is denoting the finish time of activity *i*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 而 *f[i]* 表示活动 *i* 的完成时间。
- en: Suppose we denote by *S[ij]*; the set of activities that start after activity
    *a[i]* finish, and they finish before activity *a[j]* starts. Thus, we wish to
    find a maximum set of mutually compatible activities in *S[ij]*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们用 *S[ij]* 表示活动集合，这些活动在活动 *a[i]* 完成后开始，并在活动 *a[j]* 开始前完成。因此，我们希望找到 *S[ij]*
    中相互兼容的最大活动集。
- en: 'Let''s say that the set is *A[ij]*, and includes activity *a[k]*. By including
    *a[k]* in an optimal solution, we are left with two subproblems that are finding
    the maximum subset of mutually compatible activities in the set *S[ik]* and set
    *S[kj]*, which can be represented as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设集合是 *A[ij]*，并包括活动 *a[k]*。通过将 *a[k]* 包含在最优解中，我们剩下两个子问题，即在该集合 *S[ik]* 和集合 *S[kj]*
    中找到相互兼容的最大活动子集，这可以表示如下：
- en: '*A[ij] = A[ik] ∪ {a[k]} ∪ A[kj]*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*A[ij] = A[ik] ∪ {a[k]} ∪ A[kj]*'
- en: 'Thus, the size of the maximum size set of mutually compatible activities in
    *S[ij]* is given by the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 *S[ij]* 中相互兼容的最大活动集的大小由以下公式给出：
- en: '*|A[ij]| = |A[ik]| + |A[kj]| + 1*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*|A[ij]| = |A[ik]| + |A[kj]| + 1*'
- en: 'If we could find a set *A''[kj]* of mutually compatible activities in *S[kj]*
    where *|A''[kj]| > |A[kj]|*, then we could use *A''[kj]* instead of *A[kj]* in
    the optimal solution to the subproblem for *S[ij]*. But that way, we would have
    something that contradicts the assumption that *A[ij]* is an optimal solution:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能在 *S[kj]* 中找到一个相互兼容的活动集 *A'[kj]*，其中 *|A'[kj]| > |A[kj]|*，那么我们可以在 *S[ij]*
    的子问题的最优解中使用 *A'[kj]* 来代替 *A[kj]*。但这样，我们就会得到与假设 *A[ij]* 是最优解相矛盾的东西：
- en: '*|A[ik]| + |A''[kj]| + 1 > |A[ik]| + |A[kj]| + 1 = |A[ij]|*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*|A[ik]| + |A''[kj]| + 1 > |A[ik]| + |A[kj]| + 1 = |A[ij]|*'
- en: Greedy Choice Property
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贪婪选择属性
- en: When searching for a possible solution to a problem, we usually consider various solutions,
    which we call the solution space.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找问题的可能解时，我们通常考虑各种解，我们称之为解空间。
- en: When trying to find the best solution to a problem, we're usually interested
    in a global optimum, that is, the optimal solution from the whole set of possible
    solutions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当试图找到问题的最佳解时，我们通常对全局最优解感兴趣，即从所有可能解的整个集合中的最优解。
- en: However, the solution space can exhibit other optimums. Namely, we can have
    local optimums, which are optimal solutions in a small neighborhood of possible
    solutions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，解空间可以表现出其他最优解。也就是说，我们可以有局部最优解，它们是在可能解的小邻域内的最优解。
- en: The greedy choice property states that from a local optimum we can reach a global
    optimum, without having to reconsider decisions that have already been made.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 贪婪选择属性表明，从一个局部最优解我们可以达到全局最优解，而不必重新考虑已经做出的决策。
- en: In the activity selection problem for Peter, we applied the greedy choice by
    always choosing the activity with the earliest finish time from the set of available
    activities.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在彼得的活动选择问题中，我们通过总是从可用活动集中选择最早完成时间的活动来应用贪婪选择。
- en: Intuitively, we can think that this problem exhibits the greedy choice property
    in the sense that if we have a maximum size subset and we replace the activity
    from that set with the earliest finish time with one that finishes even earlier,
    we are always left with a maximum size set, making it safe to always choose the
    one with the earliest finish time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 直观上，我们可以认为这个问题在以下意义上表现出贪婪选择属性：如果我们有一个最大尺寸的子集，并且用完成时间更早的活动替换该子集中的活动，我们总是剩下最大尺寸的子集，这使得总是选择最早完成时间的安全。
- en: It is possible to prove that the greedy choice is always part of some optimal
    solution.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可以证明贪婪选择总是某些最优解的一部分。
- en: Let's try to prove that, for any nonempty subproblem *S[k]*, if *a[m]* is an
    activity in *S[k]* with the earliest finish time, then *a[m]* is included in some
    maximum size subset of mutually compatible activities of *S[k]*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试证明，对于任何非空子问题 *S[k]*，如果 *a[m]* 是 *S[k]* 中完成时间最早的活动，那么 *a[m]* 包含在 *S[k]*
    的某个相互兼容的最大尺寸活动子集中。
- en: 'To prove it, let''s assume the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，让我们假设以下情况：
- en: '*A[k]* is a maximum size subset of mutually compatible activities in *S[k]*'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A[k]* 是 *S[k]* 中相互兼容的最大尺寸活动子集'
- en: '*a[j]* is the activity in *A[k]* with the earliest finish time'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*a[j]* 是 *A[k]* 中完成时间最早的活动'
- en: If *a[j] = a[m]*, we are done. If *a[j] != a[m]*, we can try to replace a[j]
    by am in *A[k]*, producing the set *A'[k] = A[k] - {a[k]} ∪ {a[m]}*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *a[j] = a[m]*，我们就完成了。如果 *a[j] != a[m]*，我们可以尝试将 *a[j]* 在 *A[k]* 中替换为 *a[m]*，产生集合
    *A'[k] = A[k] - {a[k]} ∪ {a[m]}*。
- en: We can safely do that since the activities in *A[k]* are disjoined. *a[j]* is
    the first activity to finish in *A[k]*, and *f[m] <= f[j]*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安全地这样做，因为*A[k]*中的活动是互斥的。*a[j]*是*A[k]*中第一个完成的活动，且*f[m] <= f[j]*。
- en: Since *|A'[k]| = |A[k]|*, we conclude that *A'[k]* is a maximum size subset
    of mutually compatible activities of *S[k]*, and that it includes *a[m]*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*|A'[k]| = |A[k]|*，我们得出结论，*A'[k]*是*S[k]*相互兼容活动的最大子集，并且它包括*a[m]*。
- en: Intuition usually helps us decide whether a greedy algorithm produces the optimal
    solution, without having to formally prove the optimal substructure and the greedy
    choice properties. We're also going to cover a different paradigm of algorithm
    design in this chapter, which is dynamic programming that also requires problems
    to exhibit the optimal substructure property. If you are not sure if a greedy
    algorithm works for a given problem due to the greedy choice, you can always build
    a dynamic programming solution for it to gain some insight.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 直觉通常帮助我们决定贪心算法是否产生最优解，而无需正式证明最优子结构和贪心选择属性。我们还将在本章中介绍算法设计的另一种范式，即动态规划，它也要求问题表现出最优子结构属性。如果你不确定贪心算法是否适用于给定的问题，因为贪心选择，你总是可以构建一个动态规划解决方案来获得一些见解。
- en: Huffman Coding
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Huffman 编码
- en: To gain more insight about greedy algorithms, let's look at another problem
    that is solvable by a greedy algorithm.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地了解贪心算法，让我们看看另一个可以用贪心算法解决的问题。
- en: Huffman codes represent a way of compressing data effectively. Data is considered to
    be a sequence of characters. Huffman's greedy algorithm uses a table with the
    frequency of each character to build up an optimal way of representing each character
    as a binary string.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Huffman 码代表了一种有效地压缩数据的方法。数据被认为是字符序列。Huffman 的贪心算法使用一个表，其中包含每个字符的频率，以构建表示每个字符作为二进制字符串的最佳方式。
- en: 'To illustrate this, imagine we have a 1,00,000 character data file that we
    wish to store in a compressed fashion. The frequency of each character in the
    data file is given by the following table:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，假设我们有一个包含100,000个字符的数据文件，我们希望以压缩的形式存储它。数据文件中每个字符的频率如下表所示：
- en: '| **Character** | a | b | c | d | e | f |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **字符** | a | b | c | d | e | f |'
- en: '| **Frequency** | 45,000 | 13,000 | 12,000 | 16,000 | 9,000 | 5,000 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **频率** | 45,000 | 13,000 | 12,000 | 16,000 | 9,000 | 5,000 |'
- en: 'Table 4.3: Frequency of each character in a data file'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.3：数据文件中每个字符的频率
- en: 'There are various ways to represent this information. For the purpose of this
    problem, let''s say that we want to design a binary character code in which each
    character is represented by a unique binary string (which we shall call a **code
    word**). One option is to use a fixed-length code (for example, each character
    is represented by a code word of the same size). If we opt for that, we need three
    bits to represent each the six characters, as shown in the following table:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式来表示这些信息。为了本问题的目的，让我们假设我们想要设计一种二进制字符码，其中每个字符都由一个唯一的二进制字符串（我们将其称为**码字**）表示。一个选项是使用固定长度的码（例如，每个字符都由相同大小的码字表示）。如果我们选择这样做，我们需要三个位来表示每个六个字符，如下表所示：
- en: '| **Character** | a | b | c | d | e | f |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **字符** | a | b | c | d | e | f |'
- en: '| **Frequency** | 45,000 | 13,000 | 12,000 | 16,000 | 9,000 | 5,000 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **频率** | 45,000 | 13,000 | 12,000 | 16,000 | 9,000 | 5,000 |'
- en: '| **Code Word** | 000 | 001 | 010 | 011 | 100 | 101 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **码字** | 000 | 001 | 010 | 011 | 100 | 101 |'
- en: 'Table 4.4: Code word for each character'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.4：每个字符的码字
- en: Using this method, we need 3,00,000 bits to code the entire sequence of characters.
    Can we do better?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们需要3,00,000位来编码整个字符序列。我们能做得更好吗？
- en: 'A variable-length code can do a lot better than a fixed-length code. Since
    we want to minimize the size of the compressed sequence of bits, we want to give
    short code words to frequent characters and long code words to infrequent characters.
    A possible code for this character sequence is shown in the following table:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可变长度的码比固定长度的码要好得多。由于我们希望最小化压缩位序列的大小，我们希望给频率高的字符分配短的码字，给频率低的字符分配长的码字。以下表格显示了该字符序列的一个可能的码：
- en: '| **Character** | a | b | c | d | e | f |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **字符** | a | b | c | d | e | f |'
- en: '| **Frequency** | 45,000 | 13,000 | 12,000 | 16,000 | 9,000 | 5,000 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **频率** | 45,000 | 13,000 | 12,000 | 16,000 | 9,000 | 5,000 |'
- en: '| **Code Word** | 0 | 101 | 100 | 111 | 1101 | 1100 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **码字** | 0 | 101 | 100 | 111 | 1101 | 1100 |'
- en: 'Table 4.5: Possible code for character sequence'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.5：字符序列的可能码
- en: Instead of 3,00,000 bits, this code requires only 2,24,000 bits to represent
    the character sequence. Using this code, we save around 28% of space. The code
    we have presented is also an optimal character code for this sequence, as we shall
    see.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与3,00,000位相比，此码只需要2,24,000位来表示字符序列。使用此码，我们可以节省大约28%的空间。我们提出的码也是此序列的最优字符码，正如我们将看到的。
- en: Building a Huffman Code
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建霍夫曼码
- en: Before we start studying an algorithm to solve this problem, we should introduce
    something called **prefix codes**. Prefix codes are codes in which no code word
    is also a prefix of some other code word. As you have seen from the proposed variable-length
    code, we must make sure that no code word is also a prefix of some other code
    word, since we want to concatenate on code words and unambiguously be able to
    decode it afterwards.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始研究解决这个问题的算法之前，我们应该介绍一个叫做**前缀码**的概念。前缀码是一种码，其中没有码字也是其他码字的前缀。正如你所看到的提出的可变长度码，我们必须确保没有码字也是其他码字的前缀，因为我们想将码字连接起来，并在之后无歧义地解码。
- en: For example, using the code shown previously, we encode the string `abc` as
    `0101100`. Since no code word is a prefix of any other, decoding is vastly simplified,
    as we can identify the initial code word, translate it, and repeat the process
    on the remainder of the encoded sequence.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用前面显示的代码，我们将字符串`abc`编码为`0101100`。由于没有码字是其他码字的前缀，解码大大简化了，因为我们能够识别初始码字，将其翻译，然后对编码序列的剩余部分重复此过程。
- en: 'A convenient (for decoding purposes) representation of prefix codes is a binary
    tree whose leaves are the characters of the original data sequence. For the proposed
    variable-length code, we have the following binary tree:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于解码来说，一个方便的前缀码表示是一个二叉树，其叶子节点是原始数据序列中的字符。对于所提出的可变长度码，我们有以下二叉树：
- en: '![](img/59c876aa-4888-44ae-8c40-4db8b7c60f33.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59c876aa-4888-44ae-8c40-4db8b7c60f33.png)'
- en: 'Figure 4.1: A Representation of prefix codes'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：前缀码的表示
- en: The binary code word for a character is the path from the root to that character,
    following in the binary digits in each edge. Note that each node also holds the
    frequency of characters under its subtree. Such a tree also has some interesting
    properties. A tree for an optimal prefix code has exactly *|C|* leaves, *C* being
    the alphabet from which the characters are drawn. The number of internal nodes
    is exactly *|C| - 1*. We also know that the number of bits necessary to encode
    a particular character in a sequence is equal to the frequency of that character
    multiplied by the depth of the leaf that holds the character. As such, the number
    of bits required to encode the full character sequence is simply the sum of these
    values for all the characters in the alphabet.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字符的二进制码字是从根节点到该字符的路径，沿着每条边的二进制位进行。注意，每个节点还持有其子树下字符的频率。这样的树也有一些有趣的性质。一个最优前缀码的树恰好有*|C|*个叶子节点，*C*是从中抽取字符的字母表。内部节点的数量恰好是*|C|
    - 1*。我们还知道，在序列中对特定字符进行编码所需的位数等于该字符频率乘以持有该字符的叶子的深度。因此，对整个字符序列进行编码所需的位数仅仅是所有字母表中的字符这些值的总和。
- en: If we can build such a tree, we can compute an optimal prefix code. David A.
    Huffman invented a greedy algorithm to construct an optimal prefix code, called
    a **Huffman Code**. Its basic idea is to build the tree in a bottom-up fashion.
    We start with just the leaf, one for each character. We then repeatedly join the
    two least-frequent nodes, until we are left with a single node, which is the root
    of the tree.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以构建这样的树，我们就可以计算出一个最优前缀码。大卫·A·霍夫曼发明了一个贪婪算法来构建最优前缀码，称为**霍夫曼码**。其基本思想是自底向上构建树。我们开始时只有一个叶子节点，每个字符一个。然后我们重复地将两个频率最低的节点合并，直到只剩下一个节点，这个节点就是树的根节点。
- en: Developing an Algorithm to Generate Code Words Using Huffman Coding
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发使用霍夫曼编码生成码字的算法
- en: 'To implement an algorithm capable of building the tree that generates the binary code
    words for the character in a data file using Java:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个算法，使用Java构建生成数据文件中字符二进制码字的树：
- en: Use a priority queue to store nodes with the character frequency.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用优先队列存储具有字符频率的节点。
- en: 'Repeatedly join the two nodes with the least frequencies until you are left with
    a single node. The source code for this algorithm is as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复地将两个频率最低的节点合并，直到只剩下一个节点。该算法的源代码如下：
- en: '[PRE1]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Snippet 4.2: Huffman code. Source class name: Huffman'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段4.2：霍夫曼码。源类名：Huffman
- en: Go to [https://goo.gl/indhgT](https://goo.gl/indhgT) to access the full code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/indhgT](https://goo.gl/indhgT) 访问完整的代码。
- en: We make use of a priority queue to store our nodes, making it very efficient
    *(O(logn))* to extract the node with the least frequency. A priority queue is
    like a queue, or a stack, but each element has an additional **priority** associated
    with it. An element with a higher priority is served before an element with lower
    priority. Priority queues are usually implemented using heaps, which usually provide
    *O(1)* time to find the element with a higher priority, *O(logn)* to insert an
    element, and *O(logn)* time to remove the element with a higher priority.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用优先队列来存储我们的节点，这使得提取具有最少频率的节点非常高效 *(O(logn))*。优先队列类似于队列或栈，但每个元素都有一个与之相关的额外
    **优先级**。具有更高优先级的元素先于具有较低优先级的元素服务。优先队列通常使用堆实现，通常提供 *O(1)* 的时间来找到具有更高优先级的元素，*O(logn)*
    的时间来插入一个元素，以及 *O(logn)* 的时间来移除具有更高优先级的元素。
- en: To analyze the running time of Huffman's algorithm, let's break it down into
    steps. We first go through each character in the frequencies map and build a node
    that we later insert in the priority queue. It takes *O(logn)* time to insert
    a node in the priority queue. Since we go through each character, it takes *O(nlogn)*
    to create and initially populate the priority queue. The second for loop executes
    exactly *n-1* times. Each time, we perform two removes from the priority queue,
    each one taking *O(logn)* time. In its whole, the `for` loop takes *O(nlogn)*
    time. We thus have two steps, each taking *O(nlogn)* time, which leaves us at
    a total running time on a set of *n* characters of *O(nlogn)*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析霍夫曼算法的运行时间，让我们将其分解为步骤。我们首先遍历频率映射中的每个字符，并构建一个节点，稍后将其插入到优先队列中。在优先队列中插入一个节点需要
    *O(logn)* 的时间。由于我们遍历每个字符，创建和最初填充优先队列需要 *O(nlogn)* 的时间。第二个 for 循环恰好执行 *n-1* 次。每次，我们从优先队列中执行两次移除操作，每次移除都需要
    *O(logn)* 的时间。整个 for 循环需要 *O(nlogn)* 的时间。因此，我们有两个步骤，每个步骤都需要 *O(nlogn)* 的时间，这使我们对于一组
    *n* 个字符的总运行时间为 *O(nlogn)*。
- en: 'Activity: Implementing a Greedy Algorithm to Compute Egyptian Fractions'
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：实现计算埃及分数的贪婪算法
- en: '**Scenario**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: For this activity, we will be building a greedy algorithm to compute Egyptian fractions.
    Every positive fraction can be represented as a sum of unique unit fractions.
    A fraction is a unit fraction if its numerator is one and its denominator is a
    positive integer. For example, *1/3* is a unit fraction. Such a representation,
    for example, a sum of unique unit fractions, is called an Egyptian fraction, since
    it was used by the ancient Egyptians.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个活动，我们将构建一个贪婪算法来计算埃及分数。每个正分数都可以表示为唯一单位分数的和。如果一个分数的分子是1且分母是正整数，那么这个分数就是一个单位分数。例如，*1/3*
    就是一个单位分数。这种表示，例如，唯一单位分数的和，被称为埃及分数，因为古埃及人曾使用它。
- en: For example, the Egyptian fraction representation of *2/3* is *1/2 + 1/6*. The
    Egyptian fraction representation of *6/14* is *1/3 + 1/11 + 1/231*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*2/3* 的埃及分数表示为 *1/2 + 1/6*。*6/14* 的埃及分数表示为 *1/3 + 1/11 + 1/231*。
- en: '**Aim**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To implement a greedy algorithm to compute Egyptian fractions, as described
    previously.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，实现一个计算埃及分数的贪婪算法。
- en: '**Prerequisites**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: 'Implement the `build` method of the `EgyptianFractions` class, which returns
    a list of denominators for the Egyptian fraction representation, in increasing
    order, which is available on GitHub at:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `EgyptianFractions` 类的 `build` 方法，该方法返回埃及分数表示的分母列表，按升序排列，可在 GitHub 上找到：
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson4/activity/egyptian/EgyptianFractions.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson4/activity/egyptian/EgyptianFractions.java)'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson4/activity/egyptian/EgyptianFractions.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson4/activity/egyptian/EgyptianFractions.java)'
- en: Assume that the denominator is always larger than the numerator, and that the
    returned denominators always fit in a Long
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设分母总是大于分子，并且返回的分母总是适合一个 Long。
- en: To verify that your solution is correct, run `./gradlew test` in the command
    line.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证你的解决方案是否正确，请在命令行中运行 `./gradlew test`。
- en: '**Steps for Completion**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Check whether the numerator divides the denominator without leaving a remainder,
    and that we're left with a single fraction
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查分子是否能整除分母而不留下余数，并且我们只剩下一个分数。
- en: If not, find the greatest possible unit fraction, subtract it from the original fraction,
    and recur on the remaining fraction
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不是，找到可能的最大单位分数，从原始分数中减去它，然后对剩余的分数进行递归。
- en: 'In this first section, we introduced the greedy paradigm of algorithm design
    using the activity selection problem as a running example. We introduced the two
    properties a problem must observe to be optimally solved by a greedy algorithm:
    optimal substructure and greedy choice. To gain intuition about the applicability
    of greedy algorithms, we later explored two other problems that are solvable by
    a greedy approach: Huffman coding and Egyptian fractions.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过活动选择问题作为运行示例，介绍了算法设计中的贪婪范式。我们介绍了问题必须观察的两个属性，以便最优地通过贪婪算法解决：最优子结构和贪婪选择。为了获得对贪婪算法适用性的直观理解，我们后来探讨了两个可以用贪婪方法解决的问题：霍夫曼编码和埃及分数。
- en: Getting Started with Divide and Conquer Algorithms
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用分而治之算法
- en: In [Chapter 2](ab7975d0-4b38-437d-9ff5-8f6c20199874.xhtml), *Sorting Algorithms
    and Fundamental Data Structures*, we introduced, among other sorting algorithms,
    merge and quick sort. A peculiarity of both algorithms is that they divide the
    problem into subproblems that are smaller instances of the same, solve each one
    of the subproblems recursively, and then combine the solutions to the subproblems
    into the solution for the original problem. This strategy forms the basis of the
    divide and conquer paradigm.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ab7975d0-4b38-437d-9ff5-8f6c20199874.xhtml)，*排序算法和基本数据结构*中，我们介绍了其他排序算法，包括归并排序和快速排序。这两种算法的一个特点是它们将问题分解为子问题，这些子问题是相同问题的较小实例，递归地解决每个子问题，然后将子问题的解合并到原始问题的解中。这种策略构成了分而治之范式的基础。
- en: The Divide and Conquer Approach
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分而治之方法
- en: 'In a divide and conquer approach, we solve a problem recursively, applying
    the following three steps at each level of recursion:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在分而治之方法中，我们递归地解决问题，在递归的每一级应用以下三个步骤：
- en: '**Divide** the problem into more than one subproblems that are smaller instances
    of the same problem.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分解**问题为多个子问题，这些子问题是相同问题的较小实例。'
- en: '**Conquer** the subproblems by solving them recursively. Eventually, the subproblem
    sizes are small enough for them to be solved in a straightforward manner.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决**子问题通过递归地解决它们。最终，子问题的大小足够小，可以以直接的方式解决。'
- en: '**Combine** the solutions to the subproblems in the solution for the original
    problem.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合并**子问题的解到原始问题的解中。'
- en: When a subproblem is large enough to be solved recursively, we call that the
    **recursive case**. When a subproblem becomes small enough that recursion is no
    longer necessary, we say that we have reached to the **base case**. It is common
    to solve subproblems that are different from the original problem, in addition
    to the subproblems that are smaller instances of the main problem. Solving these
    problems is considered to be part of the combine step.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个子问题足够大，可以递归解决时，我们称之为**递归情况**。当一个子问题变得足够小，以至于递归不再必要，我们说我们已经达到了**基本情况**。通常，除了解决与原始问题不同的子问题外，还要解决主要问题的较小实例的子问题。解决这些问题被认为是合并步骤的一部分。
- en: 'In [Chapter 2](ab7975d0-4b38-437d-9ff5-8f6c20199874.xhtml), *Sorting Algorithms
    and Fundamental Data Structures*, we saw that the runtime complexity of merge
    sort was *O(nlogn)*. We can also see that the worst-case running time *T(n)* of
    merge sort can be described by the following recurrence:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ab7975d0-4b38-437d-9ff5-8f6c20199874.xhtml)，*排序算法和基本数据结构*中，我们看到了归并排序的时间复杂度为*O(nlogn)*。我们还可以看到归并排序的最坏情况运行时间*T(n)*可以用以下递归关系来描述：
- en: '![](img/6ecc74ee-27be-45ee-950b-fb75990d6893.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ecc74ee-27be-45ee-950b-fb75990d6893.png)'
- en: 'These kinds of recurrences arise frequently and characterize divide and conquer algorithms.
    If we generalize the recursion to the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的递归经常出现，并表征分而治之算法。如果我们将递归推广到以下形式：
- en: '![](img/e675b4ff-2902-4f87-893f-9aa79d8a6bfb.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e675b4ff-2902-4f87-893f-9aa79d8a6bfb.png)'
- en: Where *a >= 1, b > 1* and *f(n)* is a given function, we have the recurrence
    for the worst-case running time of a divide and conquer algorithm that creates
    subproblems, each being of size *1/b* of the original problem, and in which the
    combine steps together take *f(n)* time.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *a >= 1, b > 1* 且 *f(n)* 是一个给定的函数，我们得到了创建子问题的分治算法的最坏情况运行时间的递归公式，每个子问题的规模是原始问题规模的
    *1/b*，并且合并步骤总共需要 *f(n)* 的时间。
- en: 'When it comes to divide and conquer algorithms, it is often easier to come
    up with this recursion, but harder to derive the runtime complexity. Fortunately,
    there are at least three methods to provide **O** bounds for these recurrences:
    the substitution method, the recursion tree method, and the master method. For
    the purpose of this book, we will only be focused on the master method.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到分治算法时，提出这种递归通常更容易，但推导运行时间复杂度却更难。幸运的是，至少有三种方法可以提供这些递归的 **O** 界限：替换法、递归树法和主定理。对于本书的目的，我们将只关注主定理。
- en: The Master Method
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主定理
- en: 'The master method provides a way to solve recurrences of the following form:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 主定理提供了一种解决以下形式递归的方法：
- en: '*T(n) = aT(n/b) + f(n)*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*T(n) = aT(n/b) + f(n)*'
- en: 'Where:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '*a >= 1* and *b > 1* are constants, *f(n)* is an asymptotically positive function'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*a >= 1* 和 *b > 1* 是常数，*f(n)* 是一个渐进正函数'
- en: The master method consists of three cases, which will allow you to solve these
    kind of recurrences quite easily. Before we delve into these three cases, it is
    important to note that the recurrence is not actually well defined, since *n/b*
    may not be an integer. Whether we replace it with the floor or ceiling of the
    *n/b* division will not affect the asymptotic behavior of the recurrence.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 主定理由三个情况组成，这将使你能够非常容易地解决这类递归。在我们深入探讨这三个情况之前，重要的是要注意，递归实际上并没有很好地定义，因为 *n/b* 可能不是一个整数。无论我们是用
    *n/b* 除法的下取整还是上取整来替换它，都不会影响递归的渐进行为。
- en: The big O notation describes the asymptotic upper bound of the growth rate of
    a function. There are also other notations to describe bounds on the growth rate
    of functions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 大O符号描述了一个函数增长率的渐进上界。也有其他符号用来描述函数增长率的界限。
- en: For the purpose of the master method, we're interested in the big-theta notation
    (*Ө*) and the big-omega notation (*Ω*).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主定理的目的，我们关注的是大-theta符号 (*Ө*) 和大-omega符号 (*Ω*)。
- en: The big-theta notation describes the asymptotic tight bound of the growth rate.
    It's called tight bound because the running time is nailed within a constant factor
    above and below. It is a tighter bound than *O(n)*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 大-theta符号描述了一个函数增长率的渐进紧界。它被称为紧界，因为运行时间被限制在常数因子之上和之下。它比 *O(n)* 的界限更紧。
- en: When we say that an algorithm is *O(f(n))*, we're saying that the running time
    of the algorithm as *n* gets larger is at most proportional to *f(n)*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说一个算法是 *O(f(n))* 时，我们的意思是随着 *n* 的增大，算法的运行时间最多与 *f(n)* 成正比。
- en: When we say that an algorithm is *Ө(f(n))*, we're saying that the running time
    of the algorithm as *n* gets larger is proportional to *f(n)*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说一个算法是 *Ө(f(n))* 时，我们的意思是随着 *n* 的增大，算法的运行时间与 *f(n)* 成正比。
- en: The big-omega notation describes an asymptotic lower bound of the growth rate.
    When we say that an algorithm is *Ω(f(n))*, we're saying that the running time
    of the algorithm as n gets larger is at least proportional to *f(n)*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 大-omega符号描述了一个函数增长率的渐进下界。当我们说一个算法是 *Ω(f(n))* 时，我们的意思是随着 *n* 的增大，算法的运行时间至少与 *f(n)*
    成正比。
- en: 'Having clarified all the necessary notations, we can present the three cases
    to derive the asymptotic bounds from a recurrence of type *T(n) = aT(n/b) + f(n)*
    as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在明确了所有必要的符号之后，我们可以按照以下方式从类型 *T(n) = aT(n/b) + f(n)* 的递归中推导出渐进界限：
- en: '*If f(n) = O(n^(log[b])^(a-∈))* for some constant *∈ > 0*, then *T(n) = θ(n^(log[b])^a)
    = O(n^(log[b])^a)*'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*如果 f(n) = O(n^(log[b])^(a-∈)) 对于某个常数 *∈ > 0*，那么 *T(n) = θ(n^(log[b])^a) =
    O(n^(log[b])^a)*'
- en: If *f(n) = θ(n^(log[b])^a)*, then *T(n) = θ(n^(log[b])^a log(n)) = O(n^(log[b])^a
    log(n))*
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 *f(n) = θ(n^(log[b])^a)*，那么 *T(n) = θ(n^(log[b])^a log(n)) = O(n^(log[b])^a
    log(n))*
- en: If *f(n) = Ω(n^(log[b])^(a+∈))* for some constant *∈ > 0*, and if *a f(n/b)
    ≤ c f(n)* for some constant *c < 1* and all sufficiently large *n*, then *T(n)
    = T(n) = θ(f(n)) = O(f(n))*
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果对于某个常数 *∈ > 0*，有 *f(n) = Ω(n^(log[b])^(a+∈))*, 并且对于某个常数 *c < 1* 和所有足够大的 *n*，有
    *a f(n/b) ≤ c f(n)*，那么 *T(n) = T(n) = θ(f(n)) = O(f(n))*
- en: Note that in all three cases we're comparing the function *f(n)* with the function
    n^(log[b])^a. This function is usually called the **critical exponent**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这三种情况下，我们都是在比较函数 *f(n)* 与函数 n^(log[b])^a。这个函数通常被称为 **临界指数**。
- en: We can see intuitively that the larger of the two functions determines the solution
    to the recurrence.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直观地看出，两个函数中较大的那个决定了递归的解。
- en: In *case 2*, the functions are of the same size, so we multiply by a logarithmic
    factor.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *case 2* 中，函数的大小相同，所以我们乘以一个对数因子。
- en: One other way to see this is that in *case 1*, the work to split and recombine
    a problem is dwarfed by subproblems; in *case 2*, the work to split and recombine
    a problem is comparable to subproblems; and in *case 3*, the work to split and
    recombine a problem dominates the subproblems.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待这个问题的方式是，在 *case 1* 中，分割和重新组合问题的工怍被子问题所淹没；在 *case 2* 中，分割和重新组合问题的工怍与子问题相当；在
    *case 3* 中，分割和重新组合问题的工怍支配了子问题。
- en: To get some practice on using the master method, let's look at some examples.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习使用主方法，让我们看看一些例子。
- en: 'For the first case, let''s consider the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种情况，让我们考虑以下内容：
- en: '![](img/12f13cde-6a96-4453-b439-e303f7414a7d.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/12f13cde-6a96-4453-b439-e303f7414a7d.png)'
- en: For this recurrence, we have *a = 9*, *b = 3*, *f(n) = n*, and thus we have
    *n^(log[b])^a = n^(log[3])**⁹ = θ(n²)*. Since *f(n) = Ω(n^(log[4])**^(3+∈))*,
    *∈* being one, we can apply *case 1* of the master theorem and conclude that *T(n)
    = O(n2)*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个递归，我们有 *a = 9*，*b = 3*，*f(n) = n*，因此我们得到 *n^(log[b])^a = n^(log[3])**⁹ =
    θ(n²)*。由于 *f(n) = Ω(n^(log[4])**^(3+∈))*，其中 *∈* 为 1，我们可以应用主定理的 *case 1* 并得出结论
    *T(n) = O(n²)*。
- en: 'For the second case, let''s consider the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二种情况，让我们考虑以下内容：
- en: '![](img/0bcc4829-6d16-4475-a815-dc5f2a9c328d.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0bcc4829-6d16-4475-a815-dc5f2a9c328d.png)'
- en: For this recurrence, we have *a = 2*, *b = 2*, *f(n) = 10n*, and thus we have
    *n^(log[b])**⁹ = n^(log[2])**² = O(n)*. Since *f(n) = O(n)*, we can apply *case
    2* of the master theorem and conclude that *T(n) = O(nlogn)*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个递归，我们有 *a = 2*，*b = 2*，*f(n) = 10n*，因此我们得到 *n^(log[b])**⁹ = n^(log[2])**²
    = O(n)*。由于 *f(n) = O(n)*，我们可以应用主定理的 *case 2* 并得出结论 *T(n) = O(nlogn)*。
- en: 'For the third and final case, let''s consider the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三种和最后一种情况，让我们考虑以下内容：
- en: '![](img/fa684dd6-9968-4e85-8634-3516a4a3d102.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa684dd6-9968-4e85-8634-3516a4a3d102.png)'
- en: For this recurrence, we have *a = 3*, *b = 4*, *f(n) = nlog(n)*, and thus we
    have *n^(log[b])**^a = n^(log[4])**³ = O(n^(0.793))*. Since *f(n) = Ω(n^(log[4])**^(3+∈))*,
    *∈* being around *0.2*, we can apply *case 3* as long as the condition holds for
    *f(n)*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个递归，我们有 *a = 3*，*b = 4*，*f(n) = nlog(n)*，因此我们得到 *n^(log[b])**^a = n^(log[4])**³
    = O(n^(0.793))*. 由于 *f(n) = Ω(n^(log[4])**^(3+∈))*，其中 *∈* 大约为 *0.2*，只要 *f(n)*
    满足条件，我们就可以应用 *case 3*。
- en: For sufficiently large *n*, we have *af(n/b) = 3(n/4)log(n/4) <= (3/4)nlogn
    (for c = 3/4)*. Consequently, *T(n) = O(nlogn)*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于足够大的 *n*，我们有 *af(n/b) = 3(n/4)log(n/4) <= (3/4)nlogn (对于 c = 3/4)*。因此，*T(n)
    = O(nlogn)*。
- en: The Closest Pair of Points Problem
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最接近的点对问题
- en: Now that we know what characterizes a divide and conquer algorithm and are familiar
    with the master method to derive bounds from recurrences, let's look at a problem
    solvable by a divide and conquer approach.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了什么是划分和征服算法的特征，并且熟悉了从递归中推导界限的主方法，让我们看看一个可以通过划分和征服方法解决的问题。
- en: 'The problem we will be looking at is the problem of finding the closest pair
    of points on a plane. We are given an array of *n* points in the plane, and we
    want to find out the closest pair of points in this array. Recall that the distance
    between two points, *p* and *q*, is given by the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要研究的问题是平面上最接近点对的问题。我们给定平面上 *n* 个点的数组，并希望找出这个数组中最接近的点对。回想一下，两点 *p* 和 *q* 之间的距离由以下公式给出：
- en: '![](img/7fdfc998-b219-47ee-905f-d62184129d1f.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7fdfc998-b219-47ee-905f-d62184129d1f.png)'
- en: 'Our first approach may be to compute the distance between each pair and return
    the smallest, for a runtime complexity of *O(n²)*. The following snippet implements
    this algorithm:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一种方法可能是计算每对之间的距离并返回最小的，这样运行时间复杂度为 *O(n²)*。以下代码片段实现了这个算法：
- en: '[PRE2]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Snippet 4.3: Brute force for closest pair of points. Source class name: ClosestPairOfPoints'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段 4.3：最接近点对的暴力算法。源类名：ClosestPairOfPoints
- en: Go to [https://goo.gl/FrRW3i](https://goo.gl/FrRW3i) to access this code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/FrRW3i](https://goo.gl/FrRW3i) 访问此代码。
- en: 'The proposed algorithm solves this problem, but we can do better by using a
    divide and conquer approach. The algorithm makes use of a preprocessing step in
    which it sorts the input array by its *x* coordinate. Then, it proceeds as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 提出的算法解决了这个问题，但我们可以通过使用划分和征服方法做得更好。该算法利用了一个预处理步骤，在这个步骤中，它按 *x* 坐标对输入数组进行排序。然后，它继续如下操作：
- en: '**Divides** the array into two halves'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**划分**数组为两半'
- en: '**Recursively** finds the smallest distances in both subarrays (**conquer**)'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**递归地**在两个子数组中找到最小的距离（**征服**）'
- en: '**Combines** the results by taking the minimum distance from both halves and
    additionally considers pairs so that one point in the pair is from the left subarray
    and another is from the right subarray'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**合并**结果，通过取两半的最小距离，并额外考虑成对的情况，使得一对中的一个点来自左子数组，另一个点来自右子数组'
- en: 'The approach seems straightforward, except for the combine part. After finding
    the minimum distance *d* from both the left and right subarrays, we have an upper
    bound of the minimum distance for this subproblem. Therefore, we only need to
    consider points whose *x* coordinate is closer than *d* to the middle vertical
    line. We can then sort those points by *y* coordinates and find the smallest distance
    in the strip, as shown in the following diagram:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 方法看起来很简单，除了合并部分。在找到左子数组和右子数组的最近距离*d*后，我们有了此子问题的最小距离的上界。因此，我们只需要考虑*x*坐标比中间垂直线近于*d*的点。然后我们可以按*y*坐标对这些点进行排序，并在条带中找到最小的距离，如图所示：
- en: '![](img/74bdf3ed-7e65-4c80-95e5-608f9fdc79c0.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/74bdf3ed-7e65-4c80-95e5-608f9fdc79c0.png)'
- en: 'Figure 4.2: Method to calculate closest pair of points'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：计算最近点对的方法
- en: 'The following code snippet computes the minimum distance in the strip, considering the
    minimum distance computed so far:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段计算条带中的最小距离，考虑到目前为止计算的最小距离：
- en: '[PRE3]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Snippet 4.4: Computing the minimum distance between pairs of points in the
    middle strip. Source class name: ClosestPairOfPoints'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 4.4节代码片段：计算中间条带中点对之间的最小距离。源类名：ClosestPairOfPoints
- en: Go to [https://goo.gl/PwUrTc](https://goo.gl/PwUrTc) to access the full code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://goo.gl/PwUrTc](https://goo.gl/PwUrTc)以获取完整代码。
- en: Looking at this code, it seems to have a runtime of *O(n²)*, which doesn't really
    improve our brute force approach. However, it can be proved geometrically that
    for every point in the strip, a maximum of seven points after it need to be checked.
    This reduces the runtime of this step to *O(nlogn)* due to the sorting step.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 观察此代码，它似乎有*O(n²)*的时间复杂度，这并没有真正改进我们的暴力方法。然而，可以通过几何方法证明，对于条带中的每个点，最多需要检查其后的七个点。这由于排序步骤，将此步骤的运行时间降低到*O(nlogn)*。
- en: You can refer to [http://people.csail.mit.edu/indyk/6.838-old/handouts/lec17.pdf](http://people.csail.mit.edu/indyk/6.838-old/handouts/lec17.pdf)
    for the geometric proof of the preceding problem.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考[http://people.csail.mit.edu/indyk/6.838-old/handouts/lec17.pdf](http://people.csail.mit.edu/indyk/6.838-old/handouts/lec17.pdf)以获取先前问题的几何证明。
- en: We can even do better on this step if we sort the initial input by the *y *coordinate
    and keep a relationship between the points on the *x*-sorted array and the *y*-sorted
    array, effectively reducing the runtime of this step to *O(n)*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按*y*坐标对初始输入进行排序，并保持*x*排序数组上的点和*y*排序数组上的点之间的关系，我们可以在此步骤中将运行时间有效降低到*O(n)*。
- en: '[PRE4]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Snippet 4.5: Combine Step of the divide and conquer algorithm to find the closest
    pair of points'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 4.5节代码片段：划分和征服算法寻找最近点对的合并步骤
- en: 'on a plane. Source class name: ClosestPairOfPoints'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在平面上。源类名：ClosestPairOfPoints
- en: Go to [https://goo.gl/wyQkBc](https://goo.gl/wyQkBc) to access this code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://goo.gl/wyQkBc](https://goo.gl/wyQkBc)以获取此代码。
- en: The proposed algorithm divides all points into two sets and recursively solves
    both subproblems. After dividing, it finds the strip in *O(n)* time and finds
    the closest points in *O(n)* time (we're assuming the improvement of not requiring
    the sort in this step). Therefore, *T(n)* can be expressed as *T(n) = 2T(n/2)
    + O(n) + O(n) = 2T(n/2) + O(n)*, which is a bound of *O(nlogn)*, being better
    than the brute force approach.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 提出的算法将所有点分为两个集合，并递归地解决两个子问题。在划分后，它在*O(n)*时间内找到条带，并在*O(n)*时间内找到最近点（我们假设在此步骤中不需要排序的改进）。因此，*T(n)*可以表示为*T(n)
    = 2T(n/2) + O(n) + O(n) = 2T(n/2) + O(n)*，这是一个*O(nlogn)*的上界，比暴力方法更好。
- en: 'Activity: Solving the Maximum Subarray Problem'
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：解决最大子数组问题
- en: '**Scenario**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: 'Create an algorithm to solve the maximum subarray problem. Find the non-empty,
    contiguous subarray of the input array whose values have the largest sum. You
    can see an example array with the maximum subarray indicated in the following
    diagram:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个算法来解决最大子数组问题。找到输入数组中具有最大和的非空、连续子数组。您可以在以下图中看到一个带有最大子数组的示例数组：
- en: '![](img/599a327f-5d66-4291-ac25-597488b7e4d2.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/599a327f-5d66-4291-ac25-597488b7e4d2.png)'
- en: The *O(n²)* brute force algorithm that tests all combinations for the start
    and end indices of the subarray is trivial to implement. Try to solve this using
    the divide and conquer algorithm.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 测试子数组起始和结束索引所有组合的*O(n²)*暴力算法是显而易见的。尝试使用分治算法解决这个问题。
- en: '**Aim**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To design and implement an algorithm to solve the maximum subarray problem with
    a better runtime than the *O(n²)* brute force algorithm, using a divide and conquer
    approach.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计并实现一个算法，以比*O(n²)*的暴力算法更好的运行时间来解决最大子数组问题，采用分治方法。
- en: '**Prerequisites**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: 'You need to implement the `maxSubarray()` method of the `MaximumSubarray` class
    in the source code, which returns the sum of values for the maximum subarray of
    the input array. The code is available on the following path:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要在源代码中实现`MaximumSubarray`类的`maxSubarray()`方法，该方法返回输入数组最大子数组的值之和。代码可在以下路径找到：
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson4/activity/maxsubarray/MaximumSubarray.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson4/activity/maxsubarray/MaximumSubarray.java)'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson4/activity/maxsubarray/MaximumSubarray.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson4/activity/maxsubarray/MaximumSubarray.java)'
- en: Assume that the sum always fits in an int, and that the size of the input array
    is at most 100,000.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设总和总是适合存储在int类型中，并且输入数组的最大大小为100,000。
- en: The source code comes with a test suite for this class, so to verify that your
    solution is correct, run `./gradlew test` in the command line.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 该源代码附带了一个用于此类的测试套件，因此为了验证你的解决方案是否正确，请在命令行中运行`./gradlew test`。
- en: '**Steps for Completion**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: 'The divide and conquer approach suggests that we divide the subarray into two subarrays
    of as equal size as possible. After doing so, we know that a maximum subarray
    must lie in exactly one of following three places:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 分治方法建议我们将子数组尽可能平均地分成两个子数组。这样做之后，我们知道最大子数组必须恰好位于以下三个位置之一：
- en: Entirely in the left subarray
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全位于左子数组中
- en: Entirely in the right subarray
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全位于右子数组中
- en: Crossing the midpoint
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨越中点
- en: The maximum subarray of the arrays on the left and right is given recursively,
    since those subproblems are smaller instances of the original problem.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 由于那些子问题是原始问题的较小实例，因此左部和右部的最大子数组是递归给出的。
- en: Find a maximum subarray that crosses the midpoint.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个跨越中点的最大子数组。
- en: There exists an even faster dynamic programming algorithm with a runtime of
    *O(n)* to solve the maximum subarray problem. The algorithm is called Kadane's
    algorithm. Dynamic programming will be explored in the next section.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个运行时间为*O(n)*的甚至更快的动态规划算法来解决最大子数组问题。该算法被称为Kadane算法。动态规划将在下一节中探讨。
- en: In the second section, we introduced the divide and conquer paradigm of algorithm
    design. We formalized the steps that a divide and conquer algorithm goes through,
    and showed the students how to go from a recurrence relationship to a runtime
    complexity bound using the master theorem. To gain intuition about the applicability
    of divide and conquer algorithms, we explored the problem of finding the closest
    pair of points on a plane.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，我们介绍了算法设计的分治范式。我们正式化了分治算法所经历的步骤，并展示了如何使用主定理将递归关系转换为运行时间复杂度界限。为了获得对分治算法适用性的直观理解，我们探讨了在平面上寻找最近点对的问题。
- en: Understanding Dynamic Programming
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解动态规划
- en: After greedy and divide and conquer, we will turn our attention to dynamic programming.
    Dynamic programming is an algorithm design paradigm that also attempts to solve
    optimization problems by combining solutions with subproblems. Unlike divide and
    conquer, subproblems need to exhibit optimal substructure for dynamic programming
    to be applicable.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在贪婪算法和分治之后，我们将把注意力转向动态规划。动态规划是一种算法设计范式，它也试图通过结合子问题的解决方案来解决优化问题。与分治不同，子问题必须表现出最优子结构，动态规划才能适用。
- en: Elements of a Dynamic Programming Problem
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态规划问题的要素
- en: 'There are two key ingredients that an optimization problem must have for dynamic
    programming to be applicable: optimal substructure and overlapping subproblems.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了动态规划适用，一个优化问题必须有两个关键要素：最优子结构和重叠子问题。
- en: Optimal Substructure
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最优子结构
- en: 'Optimal substructure is something we already covered when we introduced greedy
    algorithms. Recall that a problem exhibits optimal substructure, if an optimal
    solution to the problem contains within it, the optimal solutions to the sub-problems.
    There''s a common pattern when trying to discover optimal substructure for a problem
    that can be explained as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最优子结构是我们介绍贪婪算法时已经讨论过的内容。回想一下，如果问题的最优解包含子问题的最优解，则问题表现出最优子结构。在尝试发现问题的最优子结构时，存在一个常见的模式，可以解释如下：
- en: Show that a solution to the problem consists of making a choice, which leaves
    one or more subproblems to be solved. This choice may not be obvious and it is
    likely that many choices have to be tried (contrary to a greedy approach, in which
    a single optimal choice is made).
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证明该问题的解包括做出一个选择，这个选择会留下一个或多个待解决的问题。这个选择可能并不明显，并且可能需要尝试许多选择（与贪婪方法相反，在贪婪方法中，只做出一个最优选择）。
- en: Supposing that you are given the choice that leads to an optimal solution, determine
    the subproblems that follow.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设你被给出了导致最优解的选择，确定后续的子问题。
- en: Show that the solutions to the subproblems used within an optimal solution to
    the problem must themselves be optimal
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证明问题最优解中使用的子问题的解本身必须是最优的
- en: Usually, a *cut-and-paste* technique is used here. By supposing that each subproblem
    solution is not optimal, if a non-optimal solution is *cut out* and an optimal
    one is *pasted in*, a better solution to the original problem is produced, contradicting
    the supposition that the original solution to the problem was optimal
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，这里使用 *cut-and-paste* 技术在这里。通过假设每个子问题的解不是最优的，如果从非最优解中 *cut out* 并 *paste in*
    一个最优解，就会产生一个比原始问题更好的解决方案，这与假设原始问题的解决方案是最优的相矛盾。
- en: Overlapping Subproblems
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重叠子问题
- en: Another ingredient that optimization problems must have for dynamic programming
    to apply is that the space of subproblems should be **small**. Hence, a recursive
    algorithm for the problem should solve the same subproblems repeatedly. Typically,
    the total number of distinct subproblems is a polynomial in the input size. A
    recursive algorithm is said to have overlapping subproblems if it visits the same
    problem repeatedly. It's therefore typical for dynamic programming algorithms
    to cache solutions to subproblems to avoid re-computation of the same solutions
    over and over.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优化问题必须具备的、使动态规划适用的条件是子问题的空间应该 **小**。因此，该问题的递归算法应该反复解决相同的子问题。通常，不同子问题的总数是输入大小的多项式。如果一个递归算法反复访问相同的问题，则称它具有重叠子问题。因此，动态规划算法通常缓存子问题的解以避免重复计算相同的解。
- en: 0-1 Knapsack
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 0-1 背包问题
- en: To showcase a dynamic programming solution, exploring the properties of the
    problem that make it solvable by this technique, we shall look at the **0-1 knapsack** problem.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示动态规划解决方案，我们将探讨使该问题可以通过此技术解决的问题的性质，我们将查看 **0-1 背包** 问题。
- en: You are given weights and values of *n* items. You must put these items in a
    knapsack of capacity *W* to get the maximum value of the knapsack. You cannot
    break an item. You can either pick it or not pick it (hence the *0-1* property).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你被给出了 *n* 个项目的权重和价值。你必须将这些项目放入容量为 *W* 的背包中，以获得背包的最大价值。你不能分割一个项目。你可以选择它或不选择它（因此具有
    *0-1* 属性）。
- en: In other words, you are given two arrays, *values[0...n-1]* and *weights[0...n-1]*,
    which represent values and weights associated with n items, respectively. You
    want to find the maximum value subset of *values[]* such that the sum of weights
    of the subset is smaller than or equal to *W*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你被给出了两个数组，*values[0...n-1]* 和 *weights[0...n-1]*，分别代表与 n 个项目相关的值和权重。你想要找到
    *values[]* 的最大值子集，使得该子集的权重之和小于或等于 *W*。
- en: 'The first immediate solution to this problem is to consider all subsets of
    items and calculate the total weight and value of all subsets, considering only
    those whose total weight is smaller than *W*. To consider all subsets of items,
    we can observe that there are two choices for each item: either it is included
    in the optimal subset, or it is not. Hence, the maximum value we can obtain from
    *n* items is the maximum of two values:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的第一个直接方法是考虑所有项目的子集，并计算所有子集的总权重和总价值，只考虑那些总权重小于 *W* 的子集。为了考虑所有项目的子集，我们可以观察到每个项目有两种选择：要么它包含在最优子集中，要么它不包含。因此，从
    *n* 个项目中可以获得的最大值是两个值中的最大值：
- en: The maximum value obtained by *n-1* items and *W* weight (that is, they don't include
    the *n^(th)* item in the optimal solution)
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过*n-1*个物品和*W*重量获得的最大值（即它们不包括最优解中的*n^(th)*项）
- en: The value of the *n^(th)* item plus the maximum value obtained by *n-1* items
    and *W* minus the weight of the *n^(th)* item (for example, including the *n^(th)*
    item)
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第*n*个物品的价值加上通过*n-1*个物品和*W*重量获得的最大值减去第*n^(th)*个物品的重量（例如，包括第*n^(th)*个物品）
- en: With the previous observation, we've shown the optimal substructure property
    for the *0-1* knapsack problem.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 基于之前的观察，我们已经展示了**0-1背包问题**的最优子结构属性。
- en: Solving the 0-1 Knapsack Problem Using Recursion
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用递归解决0-1背包问题
- en: To write a code for solving the *0-1* knapsack problem by implementing the recursive approach.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个代码来解决通过实现递归方法来解决的**0-1背包问题**。
- en: 'Remember that this is a recursive top-down approach, thus it repeatedly computes
    the same subproblems for an exponential runtime complexity (2^n). The following
    code snippet solves this problem using a recursive approach:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这是一个递归自顶向下的方法，因此它反复计算相同的子问题，导致指数级的运行时间复杂度(2^n)。以下代码片段使用递归方法解决这个问题：
- en: '[PRE6]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Snippet 4.6: Recursive solution for the 0-1 Knapsack problem. Source class
    name: Knapsack'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段4.6：0-1背包问题的递归解决方案。源类名：Knapsack
- en: Go to [https://goo.gl/RoNb5L](https://goo.gl/RoNb5L) to access this code.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://goo.gl/RoNb5L](https://goo.gl/RoNb5L)访问此代码。
- en: 'The following diagram of tree shows the recursion for *n* and *W*, with inputs
    *values[] = {10, 20, 30}* and *weights[] = {1, 1, 1}*:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下树形图显示了*n*和*W*的递归，输入*values[] = {10, 20, 30}*和*weights[] = {1, 1, 1}*：
- en: '![](img/8b975d86-dbdc-473f-8dd6-aefd117c7609.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b975d86-dbdc-473f-8dd6-aefd117c7609.png)'
- en: 'Figure 4.3: Tree Showing the recursion for N and W'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：显示N和W的递归树
- en: 'Since problems are evaluated again, this has the overlapping subproblems property.
    When we have a recursive top-down approach to a problem with the overlapping subproblems
    property, we can improve things by modifying the procedure to save the result
    of each subproblem (in an array or hash table). The procedure now first checks
    to see whether it has previously solved the subproblem. If so, it returns the
    saved value; if not, it computes, stores, and returns it. It is said that the
    recursive procedure has been memoized, remembering what results it has computed
    previously. Such an approach is therefore usually called top-down with memoization.
    The following code snippet adapts the previous one to use memoization:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于问题再次被评估，这具有重叠子问题的属性。当我们对一个具有重叠子问题属性的问题采用递归自顶向下的方法时，我们可以通过修改程序来保存每个子问题的结果（在数组或哈希表中）来改进事情。程序现在首先检查是否已经解决了子问题。如果是，则返回保存的值；如果不是，则计算、存储并返回它。据说递归程序已经被记忆化，它记得之前计算过的结果。因此，这种方法通常被称为带有记忆化的自顶向下方法。以下代码片段将上一个代码片段调整为使用记忆化：
- en: '[PRE7]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Snippet 4.7: Top down with memoization approach for the 0-1 knapsack problem.
    Source class name: Knapsack'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段4.7：0-1背包问题的自顶向下带记忆化方法。源类名：Knapsack
- en: Go to [https://goo.gl/VDEZ1B](https://goo.gl/VDEZ1B) to access this code.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://goo.gl/VDEZ1B](https://goo.gl/VDEZ1B)访问此代码。
- en: By applying memoization, we reduce the runtime complexity of the algorithm from
    exponential (*2^n*) to quadratic (*n*W*). It is also possible to solve this problem
    using a bottom-up approach.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用记忆化，我们将算法的运行时间复杂度从指数级(*2^n*)降低到二次级(*n*W*)。也可以使用自底向上的方法来解决这个问题。
- en: Use of a bottom-up approach typically depends on some natural notion of the
    *size* of the subproblems. We must sort the subproblems by size and solve them
    in order, smallest first, so that we're sure that we already have computed the
    solutions for smaller subproblems when we need them for a larger one.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 自底向上方法的使用通常取决于子问题的某种自然的大小概念。我们必须按大小对子问题进行排序，并按顺序解决它们，从小到大，这样我们就可以确保在需要时已经计算了较小子问题的解决方案。
- en: 'A bottom-up approach usually yields the same asymptotic running time as a top-down
    approach, but it is typical for it to have much better constant factors, since
    it has less overhead for procedure calls. A bottom-up approach for solving the
    *0-1* Knapsack problem is shown in the following code snippet:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 自底向上的方法通常与自顶向下的方法具有相同的渐进运行时间，但它通常具有更好的常数因子，因为它在过程调用中具有更少的开销。以下代码片段展示了解决**0-1背包问题**的自底向上方法：
- en: '[PRE8]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Go to [https://goo.gl/bYyTs8](https://goo.gl/bYyTs8) to access this code.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://goo.gl/bYyTs8](https://goo.gl/bYyTs8)访问此代码。
- en: Longest Common Subsequence
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最长公共子序列
- en: Now, let's look at a different problem which is solvable by a dynamic programming
    algorithm. The problem we're now interested in is the longest common subsequence
    problem.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个可以通过动态规划算法解决的问题。我们现在感兴趣的问题是最长公共子序列问题。
- en: The difference between a subsequence and a substring is that a substring is
    a consecutive subsequence. For example, *[a, d, f]* is a subsequence of *[a, b,
    c, d, e, f]*, but not a substring. *[b, c, d]* is a substring and a subsequence
    of *[a, b, c, d, e, f]*.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 子序列和子字符串之间的区别在于，子字符串是一个连续的子序列。例如，*[a, d, f]*是*[a, b, c, d, e, f]*的子序列，但不是子字符串。*[b,
    c, d]*是子字符串，也是*[a, b, c, d, e, f]*的子序列。
- en: We're interested in finding similarities between two given sequences by computing
    the **Longest Common Subsequence** (**LCS**) between them. A common subsequence,
    *S[3]*, of two given sequences, *S[1]* and *S[2]*, is a sequence whose elements
    appear in both *S* and *S[2]* in the same order, but not necessarily consecutively.
    This problem is usually applicable when finding DNA similarities of different
    organisms.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的是通过计算两个给定序列之间的**最长公共子序列**（**LCS**）来找出这两个序列之间的相似性。两个给定序列，*S[1]*和*S[2]*，的公共子序列，*S[3]*，是一个其元素在*S*和*S[2]*中出现的顺序相同，但不一定是连续的序列。这个问题通常适用于寻找不同生物体的DNA相似性。
- en: 'For example, if we have two strands, *S[1]* and *S[2]*, as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有两个链，*S[1]*和*S[2]*，如下所示：
- en: '*S[1] = ACCGGTCGAGTGCGCGGAGCCGGCCGAA*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*S[1] = ACCGGTCGAGTGCGCGGAGCCGGCCGAA*'
- en: '*S[2] = GTCGTTCGGAATGCCGTTGCTCTGTAAAA*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*S[2] = GTCGTTCGGAATGCCGTTGCTCTGTAAAA*'
- en: 'Then the longest common strand between those two, let''s call it S[3], would
    be as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，那两个之间的最长公共链，让我们称它为S[3]，如下所示：
- en: '*S[3] = GTCGTCGGAAGCCGGCCGAA*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*S[3] = GTCGTCGGAAGCCGGCCGAA*'
- en: '![](img/ad9bd457-e4b4-4cde-b38b-dfe89c9518e6.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad9bd457-e4b4-4cde-b38b-dfe89c9518e6.png)'
- en: 'Figure 4.4: Calculating the longest common subsequence'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：计算最长公共子序列
- en: This problem is solvable using dynamic programming. If we go for a brute force
    approach, we can enumerate all subsequences of *S[1]* and check each subsequence
    to see if it is also a subsequence of *S[2]*, keeping track of the longest one
    we find.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题可以通过动态规划来解决。如果我们采取暴力方法，我们可以枚举*S[1]*的所有子序列，并检查每个子序列是否也是*S[2]*的子序列，同时跟踪我们找到的最长子序列。
- en: However, if *|S[1]| = m*, then *S[1]* has *2m* subsequences, making it impractical
    for long sequences. The **LCS** exhibits the optimal-substructure property.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果*|S[1]| = m*，那么*S[1]*有*2m*个子序列，这使得对于长序列来说不切实际。**LCS**展示了最优子结构属性。
- en: 'One way for this to become evident is to think in terms of prefixes. Let''s
    assume that we have the following two sequences:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使其变得明显的一种方式是从前缀的角度思考。让我们假设我们有两个以下序列：
- en: '*X = {x[1], x[2]… x[m]}*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*X = {x[1], x[2]… x[m]}*'
- en: '*Y = {y[1], y[2]… y[n]}*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*Y = {y[1], y[2]… y[n]}*'
- en: 'Let *Z* be any LCS of *X* and *Y* that can be represented as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让*Z*是任何可以表示如下形式的*X*和*Y*的LCS：
- en: '*Z = {z[1], z[2]… z[k]}*'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*Z = {z[1], z[2]… z[k]}*'
- en: 'Then, the following cases are possible:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可能出现以下情况：
- en: If *x[m] = y[n]*, then *z[k] = x[m] = y[n]*, and therefore *Z[k]-1* is a LCS
    of *X[m]-1* and *Y[n]-1*
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*x[m] = y[n]*，那么*z[k] = x[m] = y[n]*，因此*Z[k]-1*是*X[m]-1*和*Y[n]-1*的LCS
- en: If *x[m] != y[n]*, then *z[k] != x[m]* implies that *Z* is a LCS of *X[m]-1*
    and *Y*
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*x[m] != y[n]*，那么*z[k] != x[m]*意味着*Z*是*X[m]-1*和*Y*的LCS
- en: If *x[m] != y[n]*, then *z[k] != y[n]* implies that *Z* is a LCS of *X* and
    *Yn-1*
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*x[m] != y[n]*，那么*z[k] != y[n]*意味着*Z*是*X*和*Yn-1*的LCS
- en: 'This tells us that an LCS of two sequences contains the LCS of prefixes of
    the two sequences, exhibiting the optimal-substructure property. If we define
    *c[i][j]* to be the length of a LCS of sequences *X[i]* and *Y[j]*, then we can
    arrive at the following recursive formula, which guides us toward the dynamic
    programming solution for the problem that can be represented as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，两个序列的最长公共子序列（LCS）包含了这两个序列的前缀的LCS，展示了最优子结构属性。如果我们定义*c[i][j]*为序列*X[i]*和*Y[j]*的LCS的长度，那么我们可以得到以下递归公式，它指导我们找到以下问题的动态规划解决方案：
- en: '![](img/200e5215-3062-41cd-b1ed-5e67d99fe77e.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/200e5215-3062-41cd-b1ed-5e67d99fe77e.png)'
- en: Looking at the recurrence, the property of overlapping subproblems immediately
    pops out.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 看到递归关系，重叠子问题的属性立即显现出来。
- en: To find a LCS of *X* and *Y*, we may need to find the LCS's of *X* and *Y[n-1]*
    and *X[m-1]* and *Y*, but each of these have the problem of finding the LCS of
    *X[m-1]* and *Y[n-1]*. Many other subproblems share sub-subproblems.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到*X*和*Y*的LCS，我们可能需要找到*X*和*Y[n-1]*以及*X[m-1]*和*Y*的LCS，但每个这些都有找到*X[m-1]*和*Y[n-1]*的LCS的问题。许多其他子问题共享子子问题。
- en: 'Using this recurrence, in a bottom-up fashion (where we have solutions for
    subproblems readily computed), we can produce the following dynamic programming
    algorithm to compute the length of the longest common subsequence of two strings:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个递归关系，以自底向上的方式（我们已准备好子问题的解决方案），我们可以生成以下动态规划算法来计算两个字符串的最长公共子序列的长度：
- en: '[PRE9]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Snippet 4.9: Computing the length of the longest common subsequence of two
    Strings using dynamic programming algorithm. Source class name: LongestCommonSubsequence'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段 4.9：使用动态规划算法计算两个字符串的最长公共子序列的长度。源代码类名：LongestCommonSubsequence
- en: Go to [https://goo.gl/4TdNVQ](https://goo.gl/4TdNVQ) to access this code.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://goo.gl/4TdNVQ](https://goo.gl/4TdNVQ) 访问此代码。
- en: It is possible to also compute the longest common subsequence, and not only
    the length of it if we keep track of the **direction** we go in the *c* matrix
    on each step (either up or left), taking into account that we only add a new character
    to the optimal subsequence when *x[i] = y[j]*.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们跟踪在 *c* 矩阵上的每一步的**方向**（向上或向左），并且考虑到我们只有在 *x[i] = y[j]* 时才向最优子序列添加新字符，那么我们也可以计算最长公共子序列，而不仅仅是它的长度。
- en: 'We don''t cover the solution to this problem in this book. If you are interested
    in it, the Wikipedia page for the LCS problem has a detailed walkthrough on the
    implementation of it: [https://en.wikipedia.org/wiki/Longest_common_subsequence_problem](https://en.wikipedia.org/wiki/Longest_common_subsequence_problem).'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中不涵盖这个问题的解决方案。如果你对此感兴趣，LCS 问题的维基百科页面有关于其实施的详细说明：[https://en.wikipedia.org/wiki/Longest_common_subsequence_problem](https://en.wikipedia.org/wiki/Longest_common_subsequence_problem)。
- en: 'Activity: The Coin Change Problem'
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动内容：零钱兑换问题
- en: '**Scenario**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: 'In this activity, we will be building a dynamic programming algorithm to solve
    the coin change problem. Given a value, *N*, if we want to split it into coins,
    and we have an infinite supply of each of *S={S[1], S[2], …, S[m]}* valued coins,
    in how many ways can we do it? The order of the coins doesn''t matter. For *N
    = 4* and *S = {1, 2, 3}*, there are four solutions: *{1, 1, 1, 1}*, *{1, 1, 2}*,
    *{2, 2}*, and *{1, 3}*, so the result should be four.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将构建一个动态规划算法来解决零钱兑换问题。给定一个值，*N*，如果我们想将其拆分为硬币，并且我们有无限供应的每种面值的硬币，*S={S[1],
    S[2], …, S[m]}*，我们有多少种方法可以做到？硬币的顺序不重要。对于 *N = 4* 和 *S = {1, 2, 3}*，有四种解决方案：*{1,
    1, 1, 1}*, *{1, 1, 2}*, *{2, 2}*, 和 *{1, 3}*，所以结果应该是四个。
- en: '**Aim**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To solve the coin change problem as described previously using a dynamic programming
    algorithm.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动态规划算法解决前面描述的零钱兑换问题。
- en: '**Prerequisites**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: 'You need to implement the `ways()` method of the `CoinChange` class, which
    returns the number of ways to produce a given change for amount *N*, given a set
    of coins. It is available on the following path:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要实现 `CoinChange` 类的 `ways()` 方法，该方法返回使用一组硬币产生给定兑换金额 *N* 的方法数。它可在以下路径找到：
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson4/activity/coinchange/CoinChange.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson4/activity/coinchange/CoinChange.java).'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson4/activity/coinchange/CoinChange.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson4/activity/coinchange/CoinChange.java)。'
- en: The source code comes with a test suite for this class, so to verify that your
    solution is correct, run `./gradlew test` in the command line.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的源代码附带了一个测试套件，因此为了验证你的解决方案是否正确，请在命令行中运行 `./gradlew test`。
- en: '**Steps for Completion**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: 'When going through a coin *S[m]*, in order to count the number of solutions,
    we can divide the solution into two sets:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在遍历硬币 *S[m]* 时，为了计算解决方案的数量，我们可以将解决方案分为两个集合：
- en: Those that do not contain any coin *S[m]*
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不包含任何硬币 *S[m]*
- en: Those that contain at least one *S[m]*
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少包含一个 *S[m]*
- en: 'If *w[i][j]* counts the number of ways to make change for *i* using coins up
    to *S[j]*, then we have the following recursion:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 *w[i][j]* 计算使用硬币 *S[j]* 及以下面值的硬币来兑换 *i* 的方法数，那么我们有以下递归关系：
- en: '![](img/257e69cc-0b87-4387-878c-347011e03777.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](img/257e69cc-0b87-4387-878c-347011e03777.png)'
- en: 'In this third and final section, we introduced the dynamic programming paradigm
    of algorithm design, using the *0-1* knapsack and the longest common subsequence
    problems as examples. We introduced the two properties a problem must observe
    to be optimally solved by a dynamic programming algorithm: optimal substructure
    and overlapping subproblems, and showed the students how to identify these properties.
    We''ve also seen the differences between a top-down (with memoization) and a bottom-up
    approach in dynamic programming algorithms.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第三部分和最后一部分中，我们介绍了算法设计中的动态规划范式，以*0-1*背包问题和最长公共子序列问题为例。我们介绍了问题必须观察的两个属性，以便通过动态规划算法最优解决：最优子结构和重叠子问题，并展示了学生如何识别这些属性。我们还看到了动态规划算法中自顶向下（带有记忆化）和自底向上的方法之间的区别。
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have discussed three different algorithm design paradigms.
    We've seen example problems for all of them and discussed how we can identify
    whether problems may be solvable by one of the given paradigms. In the next chapter,
    we will be focusing on some string matching algorithms that use the paradigms
    introduced here.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了三种不同的算法设计范式。我们看到了所有这些范式的示例问题，并讨论了如何识别问题是否可能通过给定的范式之一来解决。在下一章中，我们将重点关注一些使用这里介绍范式的字符串匹配算法。
