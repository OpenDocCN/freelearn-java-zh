<html><head></head><body>
		<div id="_idContainer032">
			<h1 class="chapter-number" id="_idParaDest-206"><a id="_idTextAnchor205"/>12</h1>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor206"/>Frameworks for Optimization</h1>
			<p>Optimization frameworks are libraries, tools, and guidelines designed to help developers enhance the performance of their Java applications. Examples include streamlining processes, reducing resource utilization, and reducing processor burdens. That is the focus of this chapter. We will start by looking at asynchronous input and output, its importance, and associated libraries and frameworks. The chapter then explores buffered input and output to include use cases and performance impacts. You can learn how both asynchronous and buffered input/output operations can improve efficiency and reduce latency. The benefits of batch operations, and related frameworks and APIs, will be explored. We will review techniques to optimize batch operations, minimizing resource utilization and maximizing <span class="No-Break">data flow.</span></p>
			<p>The chapter introduces microservices and covers specific frameworks that can be used with microservices. These frameworks, along with those for cloud-native applications, will be explored, as these advanced architectures are pervasive in modern software development. We will highlight how those frameworks can be implemented to optimize the performance of our Java applications. To conclude the chapter, we will review several case studies and performance analyses, providing practical context to use the chapter’s featured frameworks in <span class="No-Break">real-world scenarios.</span></p>
			<p>By the end of this chapter, you should have a foundational understanding of key frameworks to optimize Java applications. The case studies should help deepen your understanding of how these frameworks can impact application performance. You should also be comfortable creating and implementing optimization strategies, based on the frameworks presented in <span class="No-Break">this chapter.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li><span class="No-Break">Asynchronous input/output</span></li>
				<li><span class="No-Break">Buffered input/output</span></li>
				<li><span class="No-Break">Batch operations</span></li>
				<li>Frameworks <span class="No-Break">for microservices</span></li>
				<li>Frameworks for <span class="No-Break">cloud-native applications</span></li>
				<li>Case studies and <span class="No-Break">performance analysis</span></li>
			</ul>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor207"/>Technical requirements</h1>
			<p>To follow the examples and instructions in this chapter, you will need the ability to load, edit, and run Java code. If you have not set up your development environment, refer to <a href="B21942_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Peeking Inside the Java Virtual </em><span class="No-Break"><em class="italic">Machine (JVM)</em></span><span class="No-Break">.</span></p>
			<p>The finished code for this chapter can be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter12"><span class="No-Break">https://github.com/PacktPublishing/High-Performance-with-Java/</span><span class="No-Break">tree/main/Chapter12</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor208"/>Asynchronous input/output</h1>
			<p><strong class="bold">Asynchronous</strong> refers to uncoordinated (unsynchronized) communication<a id="_idIndexMarker593"/> operations. In the context of input/output operations, data does not have to be transmitted in a steady stream. This is a technique that we can use in Java to allow our programs to handle input and output operations without blocking the main thread’s execution. While it may not always be necessary to employ this technique, it can offer great performance advantages when dealing with systems that rely on high responsiveness <span class="No-Break">and performance.</span></p>
			<p>For brevity, let’s refer to <strong class="bold">asynchronous input/output</strong> using the <strong class="bold">AIO</strong> acronym. With AIO, we can initiate<a id="_idIndexMarker594"/> processes and then have them run independently, which allows our main application to continue running other processes. Consider the <strong class="bold">synchronous </strong>alternative, where the main<a id="_idIndexMarker595"/> application must wait for one operation to complete before running another one. The synchronous approach can result in latency, longer response times, and <span class="No-Break">other inefficiencies.</span></p>
			<p>Now that you have a foundational understanding of asynchronous input/output, let’s examine the advantages and best practices of using this technique to improve Java <span class="No-Break">application performance.</span></p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor209"/>Advantages and best practices</h2>
			<p>There are several advantages to AIO, and they are best leveraged when following industry best practices. First, we will review the advantages, followed by the <span class="No-Break">best practices.</span></p>
			<h3>Advantages</h3>
			<p>Here are three advantages<a id="_idIndexMarker596"/> to implementing AIO in our <span class="No-Break">Java applications:</span></p>
			<ul>
				<li><strong class="bold">Efficiency</strong>: AIO implementation can result in resource efficiency because we can use threads for processing, instead of waiting on <span class="No-Break">input/output operations.</span></li>
				<li><strong class="bold">Responsiveness</strong>: When we decouple input/output operations from the main thread execution, we increase the application’s overall responsiveness. With AIO, the main application can remain responsive to input (i.e., user interactions) while other input/output operations <span class="No-Break">are occurring.</span></li>
				<li><strong class="bold">Scalability</strong>: If your application needs to be scalable, you will most certainly want to consider implementing AIO, which is essential for building scalable applications. AIO helps us manage multiple simultaneous connections without the need for additional threads. This significantly <span class="No-Break">reduces overhead.</span></li>
			</ul>
			<p>Keeping these advantages in mind, let’s review the best practices to optimize them <span class="No-Break">in Java.</span></p>
			<h3>Best practices</h3>
			<p>Here are several best practices <a id="_idIndexMarker597"/>to help guide your use <span class="No-Break">of AIO:</span></p>
			<ul>
				<li><strong class="bold">Error handling</strong>: Your AIO implementation strategy should include robust error handling to catch and <span class="No-Break">handle exceptions.</span></li>
				<li><strong class="bold">Handlers</strong>: The use of <strong class="bold">callback handlers</strong> to react to input/output events<a id="_idIndexMarker598"/> is advisable to help you keep your code organized <span class="No-Break">and maintainable.</span></li>
				<li><strong class="bold">Resource management</strong>: As with most programming, you should ensure that all resources used in your application (i.e., network sockets) are closed after their associated operation concludes. This will help prevent<a id="_idIndexMarker599"/> <span class="No-Break">resource/memory leaks.</span></li>
			</ul>
			<p>We have established that implementing AIO is an approach that can positively impact the performance of our applications. In the next section, we will look at how to implement AIO <span class="No-Break">in Java.</span></p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor210"/>Implementing AIO</h2>
			<p>The Java<a id="_idIndexMarker600"/> platform includes a <strong class="bold">New Input/Output</strong> (<strong class="bold">NIO</strong>) library that includes the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker601"/></span><span class="No-Break"> capabilities:</span></p>
			<ul>
				<li><strong class="source-inline">AsynchronousFileChannel</strong>: This class enables us to read and write from and to files without blocking <span class="No-Break">other tasks.</span></li>
				<li><strong class="source-inline">AsynchronousServerSocketChannel</strong> and  <strong class="source-inline">AsynchronousSocketChannel</strong>: These classes are used to handle asynchronous network operations, which helps make our <span class="No-Break">applications scalable.</span></li>
				<li><strong class="bold">Channels</strong> and <strong class="bold">buffers</strong>: Java’s NIO library relies heavily on channels and buffers. Channels are the connections to components that perform input/output operations, such as network sockets. Buffers handle <span class="No-Break">the data.</span></li>
			</ul>
			<p>There are several AIO-related frameworks and libraries available to us, in addition to Java NIO. Here are <span class="No-Break">two examples:</span></p>
			<ul>
				<li><strong class="bold">Akka</strong>: This is a toolkit consisting of libraries<a id="_idIndexMarker602"/> to help us build resilient Java applications, with a focus on distributed and <span class="No-Break">current systems.</span></li>
				<li><strong class="bold">Netty</strong>: This is a framework for high-performance<a id="_idIndexMarker603"/> applications that makes it easy for developers to create network applications. It supports both AIO and event-driven <span class="No-Break">communication models.</span></li>
			</ul>
			<p>Let’s look at AIO in code. The following example application demonstrates the <strong class="source-inline">AsynchronousFileChannel</strong> class to conduct an asynchronous file read operation. As you will see, the application employs a callback mechanism to handle the read <span class="No-Break">operation’s completion.</span></p>
			<p>Our application starts with a series of <strong class="source-inline">import</strong> statements required by it. As you can see, we are leveraging<a id="_idIndexMarker604"/> Java’s <span class="No-Break">NIO library:</span></p>
			<pre class="source-code">
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousFileChannel;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.concurrent.Future;</pre>			<p>Next is our <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
public class CH12AsyncFileReadExample {
  public static void main(String[] args) {
    Path path = Paths.get("ch12.txt");
    try (AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, StandardOpenOption.READ)) {
      ByteBuffer buffer = ByteBuffer.allocate(1024);
      Future&lt;Integer&gt; result = fileChannel.read(buffer, 0);
      while (!result.isDone()) {
        System.out.println("Processing something else while reading 
        input...");
      }
      int bytesRead = result.get();
      System.out.println(bytesRead + " bytes read");
      buffer.flip();
      byte[] data = new byte[bytesRead];
      buffer.get(data);
      System.out.println("Read data: " + new String(data));
    } catch (Exception e) {
       System.err.println("Error encountered: " + e.getMessage());
    }
  }
}</pre>			<p>As we can see from the preceding code, we open the <strong class="source-inline">ch12.txt</strong> file using <strong class="source-inline">AsychnronousFileChannel</strong>. We open it asynchronously using <strong class="source-inline">AsynchronousFileChannel.open()</strong>, specify the path, and set the read-only open option. Next, we use a <strong class="source-inline">ByteBuffer</strong> to hold the data we read from the file. This is a non-blocking method, which immediately returns a <strong class="source-inline">Future</strong> object that represents the pending result. We simulate processing other tasks during the read operation and print a message from the main thread. Lastly, we implemented a while loop to determine whether the read operation was completed <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">isDone()</strong></span><span class="No-Break">.</span></p>
			<p>Implementing AIO in our Java applications<a id="_idIndexMarker605"/> can help us achieve high performance and increased responsiveness and scalability. Next, we will examine <span class="No-Break">buffered input/output.</span></p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor211"/>Buffered input/output</h1>
			<p>The buffered approach<a id="_idIndexMarker606"/> to input/output, commonly referred to as <strong class="bold">buffered input/output</strong>, can be implemented to reduce the number of input/output operations required. This approach is accomplished using temporary storage, known as a <strong class="bold">buffer</strong>. Buffers temporarily hold data<a id="_idIndexMarker607"/> during the transfer process. The goal of this approach is to minimize direct interactions with hardware and data streams. Java delivers on this promise by accumulating data in a buffer before <span class="No-Break">processing it.</span></p>
			<p>Now that you have a foundational<a id="_idIndexMarker608"/> understanding of buffered input/output, let’s examine the advantages and best practices of using this technique to improve Java <span class="No-Break">application performance.</span></p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor212"/>Advantages and best practices</h2>
			<p>There are several advantages to buffered input/output, and they are best leveraged when following industry best practices. Next, we will review the advantages followed by <span class="No-Break">best practices.</span></p>
			<h3>Advantages</h3>
			<p>Here are three advantages<a id="_idIndexMarker609"/> to implementing buffered input/output in our <span class="No-Break">Java applications:</span></p>
			<ul>
				<li><strong class="bold">Data handling</strong>: Buffered input/output can increase the efficiency of data handling because it allows for data to be temporarily stored during read and write operations. This is especially beneficial when working with data streams and <span class="No-Break">large files.</span></li>
				<li><strong class="bold">Flexibility</strong>: We can use buffered classes to encapsulate our input and output streams. This makes them more adaptable for <span class="No-Break">varied uses.</span></li>
				<li><strong class="bold">Performance</strong>: Buffered input/output aims to reduce the number of input/output operations, thereby reducing interaction overhead and ultimately increasing the overall <span class="No-Break">application performance.</span></li>
			</ul>
			<p>Keeping these advantages in mind, let’s review the best practices for optimizing them <span class="No-Break">in Java.</span></p>
			<h3>Best practices</h3>
			<p>Here are several best practices<a id="_idIndexMarker610"/> to help guide your use of <span class="No-Break">buffered input/output:</span></p>
			<ul>
				<li><strong class="bold">Buffer size</strong>: Testing should be conducted to determine what the most optimal buffer size is. Each use case is different and depends on the data, application, <span class="No-Break">and hardware.</span></li>
				<li><strong class="bold">Error handling</strong>: It is always good practice to add robust error handling to your applications. This is especially pertinent for situations where input/output operations could fail due to external issues (e.g., file access permissions or <span class="No-Break">network issues).</span></li>
				<li><strong class="bold">Resource management</strong>: Closing buffered streams will free up system resources and help<a id="_idIndexMarker611"/> avoid <span class="No-Break">memory leaks.</span></li>
			</ul>
			<p>We have established that implementing buffered input/output is an approach that can positively impact the performance of our applications. In the next section, we will look at how to implement buffered input/output <span class="No-Break">in Java.</span></p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor213"/>Implementing buffered input/output</h2>
			<p>The Java platform includes<a id="_idIndexMarker612"/> several classes in the <strong class="source-inline">java.io</strong> library with the <span class="No-Break">following capabilities:</span></p>
			<ul>
				<li><strong class="source-inline">BufferedInputStream</strong>: This class is used to read binary data from a stream. The data is stored in a buffer, permitting efficient <span class="No-Break">data retrieval.</span></li>
				<li><strong class="source-inline">BufferedOutputStream</strong>: This class writes bytes to a stream, collecting the data in a buffer, and then writes to the <span class="No-Break">output device.</span></li>
				<li><strong class="source-inline">BufferedReader</strong>: This class reads from an input stream and buffers <span class="No-Break">the data.</span></li>
				<li><strong class="source-inline">BufferedWriter</strong>: This class writes data to an output stream, buffering the data to enable efficient writing operations from <span class="No-Break">the buffer.</span></li>
			</ul>
			<p>Let’s look at buffered input/output <span class="No-Break">in code:</span></p>
			<pre class="source-code">
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
public class CH12BufferedReadWriteExample {
  public static void main(String[] args) {
    String inputFilePath = "input.txt";
    String outputFilePath = "output.txt";
    try (BufferedReader reader = new BufferedReader(new 
    FileReader(inputFilePath));
    BufferedWriter writer = new BufferedWriter(new 
    FileWriter(outputFilePath))) {
      String line;
      while ((line = reader.readLine()) != null) {
        writer.write(line);
        writer.newLine();
      }
    } catch (IOException e) {
        System.err.println("An error occurred: " + e.getMessage());
    }
  }
}</pre>			<p>As you can see in the example code, we use <strong class="source-inline">BufferedReader</strong> and <strong class="source-inline">BufferedWriter</strong> to read and write to a file. The <strong class="source-inline">readLine</strong> method is used to efficiently read lines from the input file, and <strong class="source-inline">BufferedWriter</strong> can quickly write to a file with minimal <span class="No-Break">input/output operations.</span></p>
			<p>By leveraging the buffered input/output<a id="_idIndexMarker613"/> classes covered in this section, and following the provided best practices, we can significantly increase the performance of our Java applications, especially those that have frequent <span class="No-Break">read/write operations.</span></p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor214"/>Batch operations</h1>
			<p>The concept of <strong class="bold">batch operations</strong> suggests that we process a lot of data<a id="_idIndexMarker614"/> at once or combine multiple tasks into a single operation. This type of processing, as opposed to doing things individually, can result in tremendous efficiencies and reduce overhead. Implementing batch operations is usually a good method of improving performance, especially with large-scale data operations, file processing, and <span class="No-Break">database interactions.</span></p>
			<p>Batch operations in practice involve executing a series of jobs, usually with large datasets treated as groups. These groupings are based on natural or logical groupings, with the goal of reducing the computational overhead associated with the repetitive starting and <span class="No-Break">stopping processes.</span></p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor215"/>Advantages and best practices</h2>
			<p>There are several advantages to batch operations, and they are best leveraged when following industry best practices. Next, we will review the advantages followed by <span class="No-Break">best practices.</span></p>
			<h3>Advantages</h3>
			<p>Here are three advantages<a id="_idIndexMarker615"/> to implementing batch operations in our <span class="No-Break">Java applications:</span></p>
			<ul>
				<li><strong class="bold">Performance</strong>: Batch operations represent a tremendous increase in performance. Given the scenario where 100 files need to be processed if handled individually, 100 operations would be required. Handling these 100 files with a batch operation would run faster because there would be a significant reduction in system calls. Network latency would also <span class="No-Break">be improved.</span></li>
				<li><strong class="bold">Resource usage</strong>: Implementing batch operations reduces overhead and maximizes <span class="No-Break">resource utilization.</span></li>
				<li><strong class="bold">Scalability</strong>: Batch operations make it easier for our systems to process large datasets. This approach is <span class="No-Break">inherently scalable.</span></li>
			</ul>
			<p>Keeping these advantages<a id="_idIndexMarker616"/> in mind, let’s review the best practices to optimize them <span class="No-Break">in Java.</span></p>
			<h3>Best practices</h3>
			<p>Here are several best practices<a id="_idIndexMarker617"/> to help guide your use of <span class="No-Break">batch operations:</span></p>
			<ul>
				<li><strong class="bold">Batch size</strong>: There is a balance between having a batch size that is too small and one that is too big. If it is too small, you are not likely to gain the performance benefits, and if it is too large, your application may run into memory issues. Determining the right size requires testing and is influenced by the type of processing and the type of <span class="No-Break">data involved.</span></li>
				<li><strong class="bold">Error handling</strong>: As part of your error handling of batch operations, be sure to account for each part of the batch operations if one <span class="No-Break">part fails.</span></li>
				<li><strong class="bold">Monitoring</strong>: As with all major systems, the importance of logging and monitoring those logs cannot <span class="No-Break">be overstated.</span></li>
			</ul>
			<p>Now, let’s see how to implement batch operations <span class="No-Break">in Java.</span></p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor216"/>Implementing batch operations</h2>
			<p>The Java platform includes the following<a id="_idIndexMarker618"/> APIs and frameworks to help us implement <span class="No-Break">batch operations:</span></p>
			<ul>
				<li><strong class="bold">Java batch</strong>: The <strong class="bold">Java Specification Request</strong> (<strong class="bold">JSR</strong>) specification 352 provides a standard approach<a id="_idIndexMarker619"/> to batch processing implementation. It includes definitions <span class="No-Break">and steps.</span></li>
				<li><strong class="bold">JDBC batch processing</strong>: <strong class="bold">Java Database Connectivity</strong> (<strong class="bold">JDBC</strong>) batch processing is<a id="_idIndexMarker620"/> used to handle batch <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) statements. We will demonstrate<a id="_idIndexMarker621"/> this in the <span class="No-Break">following section.</span></li>
				<li><strong class="bold">Spring batch</strong>: This is a framework that provides a host of batch processing capabilities to include job processing statistics, resource optimization, and <span class="No-Break">transaction management.</span></li>
			</ul>
			<p>Let’s look at an example using<a id="_idIndexMarker622"/> JDBC batch processing. The following sample program demonstrates how to use JDBC batch processing to efficiently insert multiple records into a database. Note that the database <span class="No-Break">is simulated.</span></p>
			<p>Our example starts with the <span class="No-Break"><strong class="source-inline">import</strong></span><span class="No-Break"> statements:</span></p>
			<pre class="source-code">
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;</pre>			<p>Next, we create our class and <strong class="source-inline">main()</strong> method. This section includes connecting to and logging into the <span class="No-Break">simulated database:</span></p>
			<pre class="source-code">
public class CH12JDBCBatchExample {
  public static void main(String[] args) {
    String url = "jdbc:mysql://localhost/testdb";
    String user = "root";
    String password = "password";</pre>			<p>The following statement is the SQL statement we plan to use in our batch operation. Following that statement, we use encase our batch operations in a <span class="No-Break"><strong class="source-inline">try</strong></span><span class="No-Break">-</span><span class="No-Break"><strong class="source-inline">catch</strong></span><span class="No-Break"> block:</span></p>
			<pre class="source-code">
    String sql = "INSERT INTO staff (name, department) VALUES (?, ?)";
    try (Connection conn = DriverManager.getConnection(url, user, 
    password);
      PreparedStatement statement = conn.prepareStatement(sql)) {
      conn.setAutoCommit(false); // Turn off auto-commit
      // Add batch operations
      statement.setString(1, "Brenda");
      statement.setString(2, "Marketing");
      statement.addBatch();
      statement.setString(1, "Chris");
      statement.setString(2, "Warehouse");
      statement.addBatch();
      statement.setString(1, "Diana");
      statement.setString(2, "HR");
      statement.addBatch();
      int[] updateCounts = statement.executeBatch();
      conn.commit(); // Commit all the changes
      System.out.println("Rows inserted: " + updateCounts.length);
    } catch (SQLException e) {
       System.err.println("SQL Exception: " + e.getMessage());
    }
  }
}</pre>			<p>Our simple example program grouped multiple <strong class="source-inline">INSERT</strong> statements into a batch, and they were executed in a single request to the <span class="No-Break">simulated database.</span></p>
			<p>Incorporating batch operations<a id="_idIndexMarker623"/> in our Java applications, if applicable, can significantly enhance application performance. It can also increase scalability and <span class="No-Break">system maintainability.</span></p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor217"/>Frameworks for microservices</h1>
			<p><strong class="bold">Microservices</strong> are a software architectural approach<a id="_idIndexMarker624"/> that consists of loosely coupled modules (microservices) that comprise an entire application. The benefits of microservices include the ability to have teams working on individual ones simultaneously, the ability to update one independent of an entire application, increased scalability, and more efficient maintainability. This section focuses on optimization frameworks <span class="No-Break">for microservices.</span></p>
			<p>Now that you have a foundational understanding of frameworks for microservices, let’s examine the advantages and best practices of using this technique to improve Java <span class="No-Break">application performance.</span></p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor218"/>Advantages and best practices</h2>
			<p>There are several advantages to implementing frameworks for microservices, and they are best leveraged when following industry best practices. Next, we will review the advantages followed by <span class="No-Break">best practices.</span></p>
			<h3>Advantages</h3>
			<p>Here are three advantages<a id="_idIndexMarker625"/> to implementing frameworks for microservices in our <span class="No-Break">Java applications:</span></p>
			<ul>
				<li><strong class="bold">Fault isolation</strong>: One of the key advantages of using microservices is to isolate faults. This is possible because each microservice is loosely coupled with another one. This means a fault in one microservice will not necessarily <span class="No-Break">impact others.</span></li>
				<li><strong class="bold">Flexibility</strong>: Adopting the microservice framework provides greater agility and flexibility when developing and <span class="No-Break">maintaining systems.</span></li>
				<li><strong class="bold">Scalability</strong>: Microservices’ distributed nature enables great scalability; they are <span class="No-Break">inherently scalable.</span></li>
			</ul>
			<p>Keeping these advantages<a id="_idIndexMarker626"/> in mind, let’s review the best practices to optimize them <span class="No-Break">in Java.</span></p>
			<h3>Best practices</h3>
			<p>Here are several best practices<a id="_idIndexMarker627"/> to help guide your use of frameworks <span class="No-Break">for microservices:</span></p>
			<ul>
				<li><strong class="bold">API design</strong>: When designing and developing APIs, it is important to thoroughly vet their stability and <span class="No-Break">backward compatibility.</span></li>
				<li><strong class="bold">Configuration management</strong>: A formal version control system should be used so that there is consistency across <span class="No-Break">all microservices.</span></li>
				<li><strong class="bold">Monitoring</strong>: It is imperative to create a robust logging system and for those logs to be monitored. This can help identify issues before they <span class="No-Break">become critical.</span></li>
			</ul>
			<p>We have established that implementing frameworks for microservices is an approach that can positively impact the performance of our applications. In the next section, we will look at how to implement a framework for microservices <span class="No-Break">in Java.</span></p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor219"/>Implementing microservices frameworks</h2>
			<p>Systems designed with a microservice<a id="_idIndexMarker628"/> architecture essentially consist of individual services (microservices) that are standalone applications, based on a business function. Each microservice has its own data. There are several frameworks available to implement microservices in Java. Here are four <span class="No-Break">of them:</span></p>
			<ul>
				<li><strong class="bold">Helidon</strong>: This framework is provided by Oracle<a id="_idIndexMarker629"/> and helps us create applications using the microservices architecture. This is a modern framework, and the API offers <span class="No-Break">many options.</span></li>
				<li><strong class="bold">Micronaut</strong>: This is a modern and robust JVM-based<a id="_idIndexMarker630"/> framework that includes features such as dependency injection and <span class="No-Break">container management.</span></li>
				<li><strong class="bold">Quarkus</strong>: If you use Kubernetes<a id="_idIndexMarker631"/> for containerization, Quarkus is a good option to create <span class="No-Break">microservices applications.</span></li>
				<li><strong class="bold">Spring boot</strong>: This is the most used framework<a id="_idIndexMarker632"/> to implement microservices in Java. It is easy to set up, configure, <span class="No-Break">and use.</span></li>
			</ul>
			<p>Let’s look at a simple microservice application<a id="_idIndexMarker633"/> using Micronaut. We will use a <span class="No-Break">three-step approach:</span></p>
			<ol>
				<li>The first step is to set up our project. This can be done<a id="_idIndexMarker634"/> with the Micronaut <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) or a supported <strong class="bold">Integrated Development</strong> <strong class="bold">Environment</strong> (<strong class="bold">IDE</strong>), such as IntelliJ<a id="_idIndexMarker635"/> IDEA. Using the CLI, here is what the setup code might <span class="No-Break">look like:</span><pre class="source-code">
mn create-app example.micronaut.CH12Service --features=http-server</pre></li>				<li>Next, we need to create a controller to handle HTTP requests. Here is how that can <span class="No-Break">be done:</span><pre class="source-code">
package example.micronaut;
import io.micronaut.http.annotation.Controller;
import io.micronaut.http.annotation.Get;
@Controller("/ch12")
public class CH12Controller {
    @Get("/")
    public String index() {
        return "Hello from CH12's Micronaut!";
    }
}</pre></li>				<li>The third and final step is to simply run the application. Note that the following<a id="_idIndexMarker636"/> example refers to the <span class="No-Break"><strong class="bold">Gradle Wrapper</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">./gradlew run</strong></pre></li>			</ol>
			<p>Examining the code further, we can<a id="_idIndexMarker637"/> see that we use the <strong class="source-inline">@Controller</strong> annotation to identify our class as a controller, whose base URI is <strong class="source-inline">/ch12</strong>. When the application is run, the service will be located <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">http://localhost:8080/ch12</strong></span><span class="No-Break">.</span></p>
			<p>Microservices frameworks such as Helidon, Micronaut, Quarkus, and Spring Boot provide us with a multitude of capabilities to create Java applications using the <span class="No-Break">microservices architecture.</span></p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor220"/>Frameworks for cloud-native applications</h1>
			<p>Developing <strong class="bold">cloud-native applications</strong> is a strategic decision, typically<a id="_idIndexMarker638"/> based on the desire to exploit the scalability, resiliency, security, and flexibility inherent in <span class="No-Break">cloud computing.</span></p>
			<p class="callout-heading">Cloud-native</p>
			<p class="callout">In the context of software development, cloud-native<a id="_idIndexMarker639"/> refers to the use of cloud computing to create applications from the ground up and <span class="No-Break">deploy them.</span></p>
			<p>There are several frameworks available to us that support cloud-native application development in Java. Cloud-native applications are built from start to finish using the cloud environment. These applications are typically built as microservices, which are packaged into containers, orchestrated, and <a id="_idIndexMarker640"/>managed using <span class="No-Break"><strong class="bold">DevOps</strong></span><span class="No-Break">-accepted processes.</span></p>
			<p>Now that you have a foundational<a id="_idIndexMarker641"/> understanding of cloud-native applications, let’s examine the advantages and best practices of using this technique to improve Java <span class="No-Break">application performance.</span></p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor221"/>Advantages and best practices</h2>
			<p>There are several advantages to cloud-native frameworks, and they are best leveraged when following industry best practices. Next, we will review the advantages followed by the <span class="No-Break">best practices.</span></p>
			<h3>Advantages</h3>
			<p>Here are three advantages<a id="_idIndexMarker642"/> to implementing cloud-native frameworks in our <span class="No-Break">Java applications:</span></p>
			<ul>
				<li><strong class="bold">Efficiencies</strong>: One of the greatest advantages of using cloud-native frameworks for our Java applications is the great efficiencies that are introduced, due to automation, development consistency, <span class="No-Break">and testing.</span></li>
				<li><strong class="bold">Fault tolerance</strong>: Because cloud-native applications are written as microservices, a fault in one service will not necessarily <span class="No-Break">impact others.</span></li>
				<li><strong class="bold">Scalability</strong>: The microservices architecture is inherently scalable, as is the cloud environment. This empowers us to build highly scalable <span class="No-Break">Java applications.</span></li>
			</ul>
			<p>Keeping these advantages in mind, let’s review the best practices to optimize them <span class="No-Break">in Java.</span></p>
			<h3>Best practices</h3>
			<p>Here are several best practices to help guide your use of frameworks for <span class="No-Break">cloud-native applications:</span></p>
			<ul>
				<li><strong class="bold">Containerization</strong>: Applications should be packaged along with their dependencies in containers. This will help ensure that there is consistency with each service, regardless of the <span class="No-Break">runtime environment.</span></li>
				<li><strong class="bold">Continuous Integration/Continuous Delivery (CI/CD)</strong>: Adopting the CI/CD approach with automated deployment and testing can significantly increase the speed of development and minimize errors inherent in <span class="No-Break">non-automated processes.</span></li>
				<li><strong class="bold">Monitoring</strong>: Creating robust logs and continuously monitoring them can help identify potential issues <a id="_idIndexMarker643"/>before they come <span class="No-Break">to fruition.</span></li>
			</ul>
			<p>We have established that implementing cloud-native frameworks is an approach that can positively impact the performance of our applications. In the next section, we will look at how to implement them <span class="No-Break">in Java.</span></p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor222"/>Implementing a cloud-native application</h2>
			<p>There are several frameworks available<a id="_idIndexMarker644"/> to us to help develop cloud-native applications in Java. Here are three <span class="No-Break">popular frameworks:</span></p>
			<ul>
				<li><strong class="bold">Eclipse MicroProfile</strong>: This is a portable API designed<a id="_idIndexMarker645"/> for Java enterprise application optimization, specific to microservice architectures. It has many capabilities, including health checks, metrics, and <span class="No-Break">fault tolerance.</span></li>
				<li><strong class="bold">Quarkus</strong>: This framework uses a <strong class="bold">container-first</strong> philosophy and works best<a id="_idIndexMarker646"/> <span class="No-Break">with Kubernetes.</span></li>
				<li><strong class="bold">Spring Cloud</strong>: Part of the Spring environment (i.e., Spring Boot), this<a id="_idIndexMarker647"/> is a set of development tools to build common software patterns, such as configurations and service discovery, specific to the <span class="No-Break">cloud environment.</span></li>
			</ul>
			<p>Let’s look at a simple cloud-native application using <span class="No-Break">Eclipse MicroProfile:</span></p>
			<pre class="source-code">
import org.eclipse.microprofile.config.inject.ConfigProperty;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
@Path("/hello")
public class CH12HelloController {
    @ConfigProperty(name = "username")
    String username;
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "Hello " + username + ", from MicroProfile!";
    }
}</pre>			<p>The preceding code snippet demonstrates<a id="_idIndexMarker648"/> how MicroProfile can be used to inject configuration properties (e.g., a username). This very simple example underscores the benefit of using this type of framework to effectively handle configuration and other <span class="No-Break">microservices-related concerns.</span></p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor223"/>Case studies and performance analysis</h1>
			<p>So far in this chapter, we have argued that implementing optimization frameworks can greatly increase the performance and scalability of our Java applications. This section reviews two case studies and explores performance analysis to help determine the impact framework adoption has on our <span class="No-Break">Java applications.</span></p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor224"/>Case studies</h2>
			<p>Reviewing case studies <a id="_idIndexMarker649"/>based on plausible real-world situations can help demonstrate the advantages of adopting optimization frameworks. Here are two <span class="No-Break">case studies.</span></p>
			<h3>Case study 1</h3>
			<p><strong class="bold">Name</strong>: A microservices-based <span class="No-Break">e-commerce application</span></p>
			<p><strong class="bold">Background</strong>: The Reinstate LLC company is a large e-commerce retailer that recently transitioned to a microservices architecture from its previous monolithic architecture. They used Spring Boot and Spring Cloud to improve scalability, reliability, <span class="No-Break">and maintainability.</span></p>
			<p><strong class="bold">Opportunity</strong>: Reinstate LLC had difficulty scaling its monolithic system during peak times. They also noted that their development cycles were too long and attributed it to the interconnected nature of their <span class="No-Break">application’s components.</span></p>
			<p><strong class="bold">Solution</strong>: Each application component was refactored into a microservice, based on a business function or logic. These microservices included customer profiles, inventory management, order management, and cart management. Spring Boot was used to create individual microservices, and Spring Cloud was used for service discovery, load balancing, and <span class="No-Break">configuration management.</span></p>
			<p><strong class="bold">Result</strong>: After implementing the microservices architecture, Reinstate LLC experienced a 65% reduction in downtime and a 42% improvement in <span class="No-Break">response time.</span></p>
			<h3>Case study 2</h3>
			<p><strong class="bold">Name</strong>: Financial services’ <span class="No-Break">batch processing.</span></p>
			<p><strong class="bold">Background</strong>: CashNow, a financial services<a id="_idIndexMarker650"/> company, wanted to process large volumes of transactions each data while ensuring high accuracy and reliability, using <span class="No-Break">batch processing.</span></p>
			<p><strong class="bold">Opportunity</strong>: CashNow’s existing system was inefficient and commonly experienced transaction delays. This wreaked havoc on its reporting and end-of-day <span class="No-Break">reconciliation process.</span></p>
			<p><strong class="bold">Solution</strong>: CashNow implemented Spring Batch to help them manage and optimize their batch processing. This framework empowered them to implement job processing, processing chunks, and <span class="No-Break">error handling.</span></p>
			<p><strong class="bold">Result</strong>: CashNow noted a 92% reduction in batch processing time as well as a significant decrease in errors. This change helped them streamline their daily processes to include end-of-day reconciliation <span class="No-Break">and reporting.</span></p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor225"/>Performance analysis</h2>
			<p>Implementing optimization frameworks<a id="_idIndexMarker651"/> is only one part of the solution. Once they are implemented, we want to ensure they result in improvements. We also want to make sure the changes work the way we intend them to. This is typically accomplished by observing metrics <span class="No-Break">over time.</span></p>
			<p>A common performance analysis approach involves profiling tools (see <a href="B21942_14.xhtml#_idTextAnchor250"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>, <em class="italic">Profiling Tools</em>) and monitoring tools. Examples include <strong class="bold">JProfiler</strong> and <strong class="bold">VisualVM</strong>. Using robust profiling<a id="_idIndexMarker652"/> and monitoring<a id="_idIndexMarker653"/> tools can help us identify potential bottlenecks, such as memory leaks and slow <span class="No-Break">database queries.</span></p>
			<p>The case studies and performance analysis presented in this section underscore the importance of implementing optimization frameworks in our Java applications to help increase performance, scalability, <span class="No-Break">and maintainability.</span></p>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor226"/>Summary</h1>
			<p>This chapter explored various optimization frameworks and techniques to help increase the performance of our Java applications, support scalability, make our code more maintainable, and provide efficient development cycles. We covered asynchronous input/output, buffered input/output, batch operations, frameworks for microservices, and frameworks for cloud-native applications. We concluded the chapter with a review of two realistic case studies and an overview of <span class="No-Break">performance analysis.</span></p>
			<p>Hopefully, the comprehensive overview provided in this chapter will help you further optimize your Java applications. The frameworks and techniques covered in this chapter can help you enhance the performance of your applications and increase scalability, consistency, reliability, <span class="No-Break">and maintainability.</span></p>
			<p>In the next chapter (<a href="B21942_13.xhtml#_idTextAnchor227"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, <em class="italic">Performance-Focused Libraries</em>), we will explore several open source Java libraries designed to provide high performance. These fully optimized libraries can be leveraged to our advantage. Notable libraries covered include <strong class="bold">Java Microbenchmark Harness</strong> (<strong class="bold">JHM</strong>), which is part of the OpenJDK project; Netty to work with network protocols, which can be used to reduce latency; and FasterXML Jackson, which is a suite of data <span class="No-Break">processing tools.</span></p>
		</div>
	</body></html>