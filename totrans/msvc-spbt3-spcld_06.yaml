- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Adding Persistence
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加持久化
- en: In this chapter, we will learn how to persist data that a microservice is using.
    As already mentioned in *Chapter 2*, *Introduction to Spring Boot*, we will use
    the Spring Data project to persist data to MongoDB and MySQL databases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何持久化微服务使用的数据。正如在*第2章*，*Spring Boot简介*中提到的，我们将使用Spring Data项目将数据持久化到MongoDB和MySQL数据库。
- en: The `product` and `recommendation` microservices will use Spring Data for MongoDB
    and the `review` microservice will use Spring Data for the **Java Persistence
    API** (**JPA**) to access a MySQL database. We will add operations to the RESTful
    APIs to be able to create and delete data in the databases. The existing APIs
    for reading data will be updated to access the databases. We will run the databases
    as Docker containers, managed by Docker Compose, that is, in the same way as we
    run our microservices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`product`和`recommendation`微服务将使用Spring Data for MongoDB，而`review`微服务将使用Spring
    Data for **Java Persistence API**（**JPA**）来访问MySQL数据库。我们将向RESTful API添加操作以能够在数据库中创建和删除数据。现有的读取数据API将更新以访问数据库。我们将以Docker容器的方式运行数据库，由Docker
    Compose管理，即以与我们运行微服务相同的方式。'
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Adding a persistence layer to the core microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将持久化层添加到核心微服务
- en: Writing automated tests that focus on persistence
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写关注持久化的自动化测试
- en: Using the persistence layer in the service layer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务层中使用持久化层
- en: Extending the composite service API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展组合服务API
- en: Adding databases to the Docker Compose landscape
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据库添加到Docker Compose环境中
- en: Manual testing of the new APIs and the persistence layer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新API和持久化层的手动测试
- en: Updating the automated tests of the microservice landscape
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新微服务景观的自动化测试
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For instructions on how to install the tools used in this book and how to access
    the source code for this book, see:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何安装本书中使用的工具以及如何访问本书源代码的说明，请参阅：
- en: '*Chapter 21*, *Installation Instructions for macOS*'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第21章*，*macOS安装说明*'
- en: '*Chapter 22*, *Installation Instructions for Microsoft Windows with WSL 2 and
    Ubuntu*'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第22章*，*使用WSL 2和Ubuntu的Microsoft Windows安装说明*'
- en: To access the databases manually, we will use the CLI tools provided in the
    Docker images used to run the databases. We will also expose the standard ports
    used for each database in Docker Compose, `3306` for MySQL and `27017` for MongoDB.
    This will enable us to use our favorite database tools to access the databases
    in the same way as if they were running locally on our computers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动访问数据库，我们将使用运行数据库时使用的Docker镜像中提供的CLI工具。我们还将公开Docker Compose中每个数据库的标准端口，`3306`用于MySQL和`27017`用于MongoDB。这将使我们能够像它们在本地计算机上运行一样使用我们喜欢的数据库工具访问数据库。
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter06`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例均来自`$BOOK_HOME/Chapter06`的源代码。
- en: If you want to view the changes applied to the source code in this chapter,
    that is, see what it took to add persistence to the microservices using Spring
    Data, you can compare it with the source code for *Chapter 5*, *Adding an API
    Description Using OpenAPI*. You can use your favorite `diff` tool and compare
    the two folders, `$BOOK_HOME/Chapter05` and `$BOOK_HOME/Chapter06`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看本章源代码中应用的变化，即查看使用Spring Data将持久化添加到微服务中所需的内容，你可以将其与*第5章*，*使用OpenAPI添加API描述*的源代码进行比较。你可以使用你喜欢的`diff`工具比较两个文件夹，`$BOOK_HOME/Chapter05`和`$BOOK_HOME/Chapter06`。
- en: Before going into details, let’s see where we are heading.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入细节之前，让我们看看我们将走向何方。
- en: Chapter objectives
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章目标
- en: 'By the end of this chapter, we will have layers inside our microservices that
    look like the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们微服务中的层级结构将如下所示：
- en: '![](img/B19825_06_01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19825_06_01.png)'
- en: 'Figure 6.1: The microservice landscape we’re aiming for'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：我们追求的微服务景观
- en: The **Protocol layer** handles protocol-specific logic. It is very thin, only
    consisting of the `RestController` annotations in the `api` project and the common
    `GlobalControllerExceptionHandler` in the `util` project. The main functionality
    of each microservice resides in each **Service layer**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议层**处理特定协议的逻辑。它非常薄，仅由`api`项目中的`RestController`注解和`util`项目中的通用`GlobalControllerExceptionHandler`组成。每个微服务的主要功能都位于各自的**服务层**。'
- en: The `product-composite` service contains an **Integration layer** used to handle
    the communication with the three core microservices. The core microservices will
    all have a **Persistence layer** used for communicating with their databases.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be able to access data stored in MongoDB with a command like the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The result of the command should look like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19825_06_02.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Accessing data stored in MongoDB'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding data stored in MySQL, we will be able to access it with a command
    like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result of the command should look as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19825_06_03.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Accessing data stored in MySQL'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The output from the `mongo` and `mysql` commands has been shortened for improved
    readability.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how to implement this. We will start by adding persistence functionality
    to our core microservices!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Adding a persistence layer to the core microservices
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start with adding a persistence layer to the core microservices. Besides
    using Spring Data, we will also use a Java bean mapping tool, **MapStruct**, which
    makes it easy to transform between Spring Data entity objects and the API model
    classes. For further details, see [http://mapstruct.org/](http://mapstruct.org/).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to add dependencies to MapStruct, Spring Data, and the JDBC drivers
    for the databases we intend to use. After that, we can define our Spring Data
    entity classes and repositories. The Spring Data entity classes and repositories
    will be placed in their own Java package, `persistence`. For example, for the
    product microservice, they will be placed in the Java package `se.magnus.microservices.core.product.persistence`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Adding dependencies
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use MapStruct v1.5.3, so we will start by defining a variable holding
    the version information in the build file for each core microservice, `build.gradle`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we declare a dependency on MapStruct:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since MapStruct generates the implementation of the bean mappings at compile
    time by processing MapStruct annotations, we need to add an `annotationProcessor`
    and a `testAnnotationProcessor` dependency:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To make the compile-time generation work in popular IDEs such as IntelliJ IDEA,
    we also need to add the following dependency:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you are using IntelliJ IDEA, you also need to ensure that support for annotation
    processing is enabled. Open **Preferences** and navigate to **Build**, **Execute**,
    **Deployment | Compiler | Annotations Processors**. Verify that the checkbox named
    **Enable annotation processing** is selected!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `product` and `recommendation` microservices, we declare the following
    dependencies to Spring Data for MongoDB:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For the `review` microservice, we declare a dependency on Spring Data for JPA
    and a JDBC driver for MySQL like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To enable the use of MongoDB and MySQL when running automated integration tests,
    we will use **Testcontainers** and its support for JUnit 5, MongoDB, and MySQL.
    For the `product` and `recommendation` microservices, we declare the following
    test dependencies:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在运行自动化集成测试时启用MongoDB和MySQL的使用，我们将使用**Testcontainers**及其对JUnit 5、MongoDB和MySQL的支持。对于`product`和`recommendation`微服务，我们声明以下测试依赖项：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For the `review` microservices, we declare the following test dependencies:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`review`微服务，我们声明以下测试依赖项：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For more information on how Testcontainers is used in integration tests, see
    the *Writing automated tests that focus on persistence* section later on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何在集成测试中使用Testcontainers的更多信息，请参阅后面的*编写关注持久性的自动化测试*部分。
- en: Storing data with entity classes
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用实体类存储数据
- en: The entity classes are similar to the corresponding API model classes in terms
    of what fields they contain; see the Java package `se.magnus.api.core` in the
    `api` project. We will add two fields, `id` and `version`, in the entity classes
    compared to the API model classes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实体类在包含的字段方面与相应的API模型类相似；请参阅`api`项目中的Java包`se.magnus.api.core`。与API模型类相比，实体类中我们将添加两个字段，`id`和`version`。
- en: The `id` field is used to hold the database identity of each stored entity,
    corresponding to the primary key when using a relational database. We will delegate
    the responsibility of generating unique values for the `id` field to Spring Data.
    Depending on the database used, Spring Data can delegate this responsibility to
    the database engine or handle it on its own. In either case, the application code
    does not need to consider how a unique database `id` value is set. The `id` field
    is not exposed in the API, as a best practice from a security perspective. The
    fields in the model classes that identify an entity will be assigned a unique
    index in the corresponding entity class, to ensure consistency in the database
    from a business perspective.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`字段用于存储每个存储实体的数据库标识符，对应于使用关系型数据库时的主键。我们将委托Spring Data生成`id`字段的唯一值的责任。根据所使用的数据库，Spring
    Data可以将此责任委托给数据库引擎或自行处理。在任何情况下，应用程序代码都不需要考虑如何设置唯一的数据库`id`值。出于安全角度的最佳实践，`id`字段不在API中公开。在模型类中标识实体的字段将在相应的实体类中被分配一个唯一索引，以确保从业务角度在数据库中的一致性。'
- en: The `version` field is used to implement optimistic locking, allowing Spring
    Data to verify that updates of an entity in the database do not overwrite a concurrent
    update. If the value of the `version` field stored in the database is higher than
    the value of the `version` field in an update request, this indicates that the
    update is performed on stale data—the information to be updated has been updated
    by someone else since it was read from the database. Attempts to perform updates
    based on stale data will be prevented by Spring Data. In the section on writing
    persistence tests, we will see tests verifying that the optimistic locking mechanism
    in Spring Data prevents updates performed on stale data. Since we only implement
    APIs for create, read, and delete operations, we will not expose the `version`
    field in the API.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`version`字段用于实现乐观锁，允许Spring Data验证数据库中实体的更新不会覆盖并发更新。如果数据库中存储的`version`字段的值高于更新请求中`version`字段的值，这表明更新是在过时数据上进行的——要更新的信息自从从数据库读取以来已被其他人更新。基于过时数据进行的更新尝试将被Spring
    Data阻止。在编写持久性测试的部分，我们将看到验证Spring Data中的乐观锁机制防止对过时数据进行更新的测试。由于我们只实现了创建、读取和删除操作的API，因此我们不会在API中公开`version`字段。'
- en: 'The most interesting parts of the product entity class, used for storing entities
    in MongoDB, look like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 产品实体类中最有趣的部分，用于在MongoDB中存储实体，如下所示：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here are some observations from the preceding code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是从前面的代码中得出的几点观察：
- en: The `@Document(collection = "products")` annotation is used to mark the class
    as an entity class used for MongoDB, that is, mapped to a collection in MongoDB
    with the name `products`.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@Document(collection = "products")`注解来标记该类为用于MongoDB的实体类，即映射到MongoDB中名为`products`的集合。
- en: The `@Id` and `@Version` annotations are used to mark the `id` and `version`
    fields to be used by Spring Data, as explained previously.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@Id`和`@Version`注解来标记`id`和`version`字段，以便Spring Data使用，如前所述。
- en: The `@Indexed(unique = true)` annotation is used to get a unique index created
    for the business key, `productId`.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@Indexed(unique = true)`注解来创建一个用于业务键`productId`的唯一索引。
- en: 'The most interesting parts of the `Recommendation` entity class, also used
    for storing entities in MongoDB, look like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Added to the explanations for the preceding product entity, we can see how a
    unique compound index is created using the `@CompoundIndex` annotation for the
    compound business key based on the `productId` and `recommendationId` fields.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the most interesting parts of the `Review` entity class, used for
    storing entities in a SQL database like MySQL, look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notes from the preceding code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The `@Entity` and `@Table` annotations are used to mark the class as an entity
    class used for JPA—mapped to a table in a SQL database with the name `reviews`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Table` annotation is also used to specify that a unique compound index
    will be created for the compound business key based on the `productId` and `reviewId`
    fields.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Id` and `@Version` annotations are used to mark the `id` and `version`
    fields to be used by Spring Data, as explained previously. To direct Spring Data
    to JPA in order to automatically generate unique `id` values for the `id` field,
    we are using the `@GeneratedValue` annotation.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the full source code of the entity classes, see the `persistence` package
    in each of the core microservice projects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Defining repositories in Spring Data
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring Data comes with a set of interfaces for defining repositories. We will
    use the interfaces `CrudRepository` and `PagingAndSortingRepository`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The `CrudRepository` interface provides standard methods for performing basic
    create, read, update, and delete operations on the data stored in the databases.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PagingAndSortingRepository` interface adds support for paging and sorting
    to the `CrudRepository` interface.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use the `CrudRepository` interface as the base for the `Recommendation`
    and `Review` repositories and also the `PagingAndSortingRepository` interface
    as the base for the `Product` repository.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: We will also add a few extra query methods to our repositories for looking up
    entities using the business key, `productId`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data supports defining extra query methods based on naming conventions
    for the signature of the method. For example, the `findByProductId(int productId)`
    method signature can be used to direct Spring Data to automatically create a query
    that returns entities from the underlying collection or table. In this case, it
    will return entities that have the `productId` field set to the value specified
    in the `productId` parameter. For more details on how to declare extra queries,
    see [https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods.query-creation](https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods.query-creation).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Product` repository class looks like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since the `findByProductId` method might return zero or one product entity,
    the return value is marked to be optional by wrapping it in an `Optional` object.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Recommendation` repository class looks like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Recommendation`仓库类的样子如下：'
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, the `findByProductId` method will return zero to many recommendation
    entities, so the return value is defined as a list.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`findByProductId`方法将返回零到多个推荐实体，因此返回值被定义为列表。
- en: 'Finally, the `Review` repository class looks like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Review`仓库类的样子如下：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since SQL databases are transactional, we have to specify the default transaction
    type—read-only in our case—for the query method, `findByProductId()`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SQL数据库是事务性的，我们必须为查询方法`findByProductId()`指定默认的事务类型——在我们的案例中是只读。
- en: That’s it—this is all it takes to establish a persistence layer for our core
    microservices.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了——这就是为我们的核心微服务建立持久化层所需的所有内容。
- en: For the full source code of the repository classes, see the `persistence` package
    in each of the core microservice projects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看仓库类的完整源代码，请参阅每个核心微服务项目中的`persistence`包。
- en: Let’s start using the persistence classes by writing some tests to verify that
    they work as intended.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一些测试来验证持久化类是否按预期工作，开始使用持久化类。
- en: Writing automated tests that focus on persistence
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写关注持久化的自动化测试
- en: When writing persistence tests, we want to start a database when the tests begin
    and tear it down when the tests are complete. However, we don’t want the tests
    to wait for other resources to start up, for example, a web server such as Netty
    (which is required at runtime).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写持久化测试时，我们希望在测试开始时启动数据库，在测试完成后将其关闭。然而，我们不想让测试等待其他资源启动，例如，一个运行时所需的Web服务器（如Netty）。
- en: 'Spring Boot comes with two class-level annotations tailored to this specific
    requirement:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot提供了两个针对此特定要求的类级别注解：
- en: '`@DataMongoTest`: This annotation starts up a MongoDB database when the test
    starts.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@DataMongoTest`：这个注解在测试开始时启动一个MongoDB数据库。'
- en: '`@DataJpaTest`: This annotation starts up a SQL database when the test starts:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@DataJpaTest`：这个注解在测试开始时启动一个SQL数据库：'
- en: By default, Spring Boot configures the tests to roll back updates to the SQL
    database to minimize the risk of negative side effects on other tests. In our
    case, this behavior will cause some of the tests to fail. Therefore, automatic
    rollback is disabled with the class-level annotation `@Transactional(propagation
    = NOT_SUPPORTED)`.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Boot会将测试配置为回滚SQL数据库的更新，以最小化对其他测试的负面影响。在我们的案例中，这种行为将导致一些测试失败。因此，使用类级别的注解`@Transactional(propagation
    = NOT_SUPPORTED)`禁用了自动回滚。
- en: To handle the startup and tear-down of databases during the execution of the
    integration tests, we will use Testcontainers. Before looking into how to write
    persistence tests, let’s learn about how to use Testcontainers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在执行集成测试期间处理数据库的启动和关闭，我们将使用Testcontainers。在探讨如何编写持久化测试之前，让我们了解一下如何使用Testcontainers。
- en: Using Testcontainers
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Testcontainers
- en: '**Testcontainers** ([https://www.testcontainers.org](https://www.testcontainers.org))
    is a library that simplifies running automated integration tests by running resource
    managers like a database or a message broker as a Docker container. Testcontainers
    can be configured to automatically start up Docker containers when JUnit tests
    are started and tear down the containers when the tests are complete.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**Testcontainers** ([https://www.testcontainers.org](https://www.testcontainers.org))是一个库，通过运行资源管理器（如数据库或消息代理）作为Docker容器来简化自动集成测试。Testcontainers可以配置为在JUnit测试启动时自动启动Docker容器，并在测试完成后销毁容器。'
- en: To enable Testcontainers in an existing test class for a Spring Boot application
    like the microservices in this book, we can add the `@Testcontainers` annotation
    to the test class. Using the `@Container` annotation, we can, for example, declare
    that the `Review` microservice’s integration tests will use a Docker container
    running MySQL.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在现有的Spring Boot应用程序（如本书中的微服务）的测试类中启用Testcontainers，我们可以在测试类中添加`@Testcontainers`注解。使用`@Container`注解，例如，我们可以声明`Review`微服务的集成测试将使用运行MySQL的Docker容器。
- en: 'The code looks like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来是这样的：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The version specified for MySQL, 8.0.32, is copied from Docker Compose files
    to ensure that the same version is used.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为MySQL指定的版本8.0.32是从Docker Compose文件中复制的，以确保使用相同的版本。
- en: 'A disadvantage of this approach is that each test class will use its own Docker
    container. Bringing up MySQL in a Docker container takes a few seconds, typically
    10 seconds on my Mac. Running multiple test classes that use the same type of
    test container will add this latency for each test class. To avoid this extra
    latency, we can use the **Single Container Pattern** (see [https://www.testcontainers.org/test_framework_integration/manual_lifecycle_control/#singleton-containers](https://www.testcontainers.org/test_framework_integration/manual_lifecycle_control/#singleton-containers)).
    Following this pattern, a base class is used to launch a single Docker container
    for MySQL. The base class, `MySqlTestBase`, used in the `Review` microservice
    looks like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是每个测试类都会使用自己的Docker容器。在Docker容器中启动MySQL需要几秒钟，通常在我的Mac上需要10秒钟。运行多个使用相同类型测试容器的测试类将为每个测试类增加这种延迟。为了避免这种额外的延迟，我们可以使用**单容器模式**（见[https://www.testcontainers.org/test_framework_integration/manual_lifecycle_control/#singleton-containers](https://www.testcontainers.org/test_framework_integration/manual_lifecycle_control/#singleton-containers)）。遵循此模式，使用一个基类来启动MySQL的单个Docker容器。在`Review`微服务中使用的基类`MySqlTestBase`如下所示：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Explanations for the preceding source code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对前面源代码的解释：
- en: The `database` container is declared in the same way as in the preceding example,
    with the addition of an extended wait period of five minutes for the container
    to start up.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`database`容器声明的方式与前面的示例相同，只是在容器启动时增加了五分钟的扩展等待期。'
- en: A `static` block is used to start the database container before any JUnit code
    is invoked.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个`static`块在调用任何JUnit代码之前启动数据库容器。
- en: The database container will get some properties defined when started up, such
    as which port to use. To register these dynamically created properties in the
    application context, a static method `databaseProperties()` is defined. The method
    is annotated with `@DynamicPropertySource` to override the database configuration
    in the application context, such as the configuration from an `application.yml`
    file.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库容器在启动时会获取一些属性定义，例如使用哪个端口。为了将这些动态创建的属性注册到应用程序上下文中，定义了一个静态方法`databaseProperties()`。该方法使用`@DynamicPropertySource`注解来覆盖应用程序上下文中的数据库配置，例如来自`application.yml`文件的配置。
- en: 'The test classes use the base class as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类如下使用基类：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For the `product` and `review` microservices, which use MongoDB, a corresponding
    base class, `MongoDbTestBase`, has been added.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用MongoDB的`product`和`review`微服务，已添加相应的基类`MongoDbTestBase`。
- en: 'By default, the log output from Testcontainers is rather extensive. A **Logback**
    configuration file can be placed in the `src/test/resource` folder to limit the
    amount of log output. Logback is a logging framework ([http://logback.qos.ch](http://logback.qos.ch)),
    and it is included in the microservices by using the `spring-boot-starter-webflux`
    dependency. For details, see [https://www.testcontainers.org/supported_docker_environment/logging_config/](https://www.testcontainers.org/supported_docker_environment/logging_config/).
    The configuration file used in this chapter is named `src/test/resources/logback-test.xml`
    and looks like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Testcontainers的日志输出相当详细。可以在`src/test/resource`文件夹中放置一个**Logback**配置文件来限制日志输出的数量。Logback是一个日志框架([http://logback.qos.ch](http://logback.qos.ch))，它通过使用`spring-boot-starter-webflux`依赖项包含在微服务中。有关详细信息，请参阅[https://www.testcontainers.org/supported_docker_environment/logging_config/](https://www.testcontainers.org/supported_docker_environment/logging_config/)。本章使用的配置文件名为`src/test/resources/logback-test.xml`，其内容如下：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Some notes from the above `XML` file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 关于上面`XML`文件的一些说明：
- en: The config file includes two config files provided by Spring Boot to define
    the default values, and a log appender is configured that can write log events
    to the console.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件包括Spring Boot提供的两个配置文件来定义默认值，并配置了一个可以将日志事件写入控制台的日志追加器。
- en: The config file limits log output to the `INFO` log level, discarding the `DEBUG`
    and `TRACE` log records emitted by the Testcontainers library.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该配置文件将日志输出限制在`INFO`日志级别，丢弃Testcontainers库发出的`DEBUG`和`TRACE`日志记录。
- en: For details on Spring Boot’s support for logging and the use of Logback, see
    [https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto-configure-logback-for-logging](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto-configure-logback-for-logging).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Spring Boot对日志的支持和Logback的使用详情，请参阅[https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto-configure-logback-for-logging](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto-configure-logback-for-logging)。
- en: Finally, when using the `@DataMongoTest` and `@DataJpaTest` annotations instead
    of the `@SpringBootTest` annotation to only start up the MongoDB and SQL database
    during the integration test, there is one more thing to consider. The `@DataJpaTest`
    annotation is designed to start an embedded database by default. Since we want
    to use a containerized database, we have to disable this feature.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `@DataJpaTest` annotation, this can be done by using an `@AutoConfigureTestDatabase`
    annotation like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With Testcontainers introduced, we are ready to see how persistence tests can
    be written.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Writing persistence tests
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The persistence tests for the three core microservices are similar to each other,
    so we will only go through the persistence tests for the `product` microservice.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'The test class, `PersistenceTests`, declares a method, `setupDb()`, annotated
    with `@BeforeEach`, which is executed before each test method. The setup method
    removes any entities from previous tests in the database and inserts an entity
    that the test methods can use as the base for their tests:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next come the various test methods. First is a `create` test:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This test creates a new entity, verifies that it can be found using the `findById`
    method, and wraps up by asserting that there are two entities stored in the database,
    the one created by the `setup` method and the one created by the test itself.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update` test looks like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This test updates the entity created by the `setup` method, reads it again from
    the database using the standard `findById()` method, and asserts that it contains
    expected values for some of its fields. Note that, when an entity is created,
    its `version` field is set to `0` by Spring Data, so we expect it to be `1` after
    the update.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'The `delete` test looks like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This test deletes the entity created by the `setup` method and verifies that
    it no longer exists in the database.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'The `read` test looks like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This test uses the `findByProductId()` method to get the entity created by the
    `setup` method, verifies that it was found, and then uses the local helper method,
    `assertEqualsProduct()`, to verify that the entity returned by `findByProductId()`
    looks the same as the entity stored by the `setup` method.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Next are two test methods that verify alternative flows—handling error conditions.
    First is a test that verifies that duplicates are handled correctly:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The test tries to store an entity with the same business key as used by the
    entity created by the `setup` method. The test will fail if the save operation
    succeeds, or if the save fails with an exception other than the expected `DuplicateKeyException`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'The other negative test is, in my opinion, the most interesting test in the
    test class. It is a test that verifies correct error handling in the case of updates
    of stale data—it verifies that the optimistic locking mechanism works. It looks
    like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is observed from the code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: First, the test reads the same entity twice and stores it in two different variables,
    `entity1` and `entity2`.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, it uses one of the variables, `entity1`, to update the entity. The update
    of the entity in the database will cause the `version` field of the entity to
    be increased automatically by Spring Data. The other variable, `entity2`, now
    contains stale data, manifested by its `version` field, which holds a lower value
    than the corresponding value in the database.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the test tries to update the entity using the variable `entity2`, which
    contains stale data, it is expected to fail by throwing an `OptimisticLockingFailureException`
    exception.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test wraps up by asserting that the entity in the database reflects the
    first update, that is, contains the name `"n1"`, and that the `version` field
    has the value `1`; only one update has been performed on the entity in the database.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the `product` service contains a test that demonstrates the usage
    of built-in support for sorting and paging in Spring Data:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Explanations for the preceding code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The test starts by removing any existing data, then inserts 10 entities with
    the `productId` field ranging from `1001` to `1010`.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, it creates `PageRequest`, requesting a page count of `4` entities per
    page and a sort order based on `ProductId` in ascending order.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it uses a helper method, `testNextPage`, to read the expected three
    pages, verifying the expected product IDs on each page and verifying that Spring
    Data correctly reports back whether more pages exist or not.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The helper method `testNextPage` looks like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The helper method uses the page request object, `nextPage`, to get the next
    page from the repository method, `findAll()`. Based on the result, it extracts
    the product IDs from the returned entities into a string and compares it to the
    expected list of product IDs. Finally, it returns the next page.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: For the full source code of the persistence tests, see the test class `PersistenceTests`
    in each of the core microservice projects.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'The persistence tests in the `product` microservice can be executed using Gradle
    with a command like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After running the tests, it should respond with the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19825_06_04.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: BUILD SUCCESSFUL response'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: With a persistence layer in place, we can update the service layer in our core
    microservices to use the persistence layer.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Using the persistence layer in the service layer
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to use the persistence layer in the service
    layer to store and retrieve data from a database. We will go through the following
    steps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Logging the database connection URL
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding new APIs
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling the persistence layer from the service layer
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declaring a Java bean mapper
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating the service tests
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Logging the database connection URL
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When scaling up the number of microservices where each microservice connects
    to its own database, it can be hard to keep track of what database each microservice
    actually uses. To avoid this confusion, a good practice is to add a `LOG` statement
    directly after the startup of a microservice that logs connection information
    that is used to connect to the database.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the startup code for the `product` service looks like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The call to the `LOG.info` method will write something like the following to
    the log:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19825_06_05.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Expected log output'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: For the full source code, see the main application class in each of the core
    microservice projects, for example, `ProductServiceApplication` in the `product-service`
    project.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Adding new APIs
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can use the persistence layer to create and delete information in
    the database, we need to create the corresponding API operations in our core service
    APIs.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'The API operations for creating and deleting a product entity look like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The implementation of the delete operation will be **idempotent**; that is,
    it will return the same result if called several times. This is a valuable characteristic
    in fault scenarios. For example, if a client experiences a network timeout during
    a call to a delete operation, it can simply call the delete operation again without
    worrying about varying responses, for example, **OK** (**200**) in response the
    first time and **Not Found** (**404**) in response to consecutive calls, or any
    unexpected side effects. This implies that the operation should return the status
    code **OK** (**200**) even though the entity no longer exists in the database.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The API operations for the `recommendation` and `review` entities look similar;
    however, note that when it comes to the delete operation for the `recommendation`
    and `review` entities, it will delete all `recommendations` and `reviews` for
    the specified `productId`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: For the full source code, see the interface declarations (`ProductService`,
    `RecommendationService`, and `ReviewService`) of the core microservices in the
    `api` project.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Calling the persistence layer from the service layer
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The source code in the service layer for using the persistence layer is structured
    in the same way for all core microservices. Therefore, we will only go through
    the source code for the `product` microservice.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to inject the repository class from the persistence layer and
    a Java bean mapper class into the constructor:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the next section, we will see how the Java mapper class is defined.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `createProduct` method is implemented as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `createProduct` method used the `save` method in the repository to store
    a new entity. It should be noted that the mapper class is used to convert Java
    beans between an API model class and an entity class using the two mapper methods,
    `apiToEntity()` and `entityToApi()`. The only error we handle for the `create`
    method is the `DuplicateKeyException` exception, which we convert into an `InvalidInputException`
    exception.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getProduct` method looks like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After some basic input validation (that is, ensuring that `productId` is not
    negative), the `findByProductId()` method in the repository is used to find the
    product entity. Since the repository method returns an `Optional` product, we
    can use the `orElseThrow()` method in the `Optional` class to conveniently throw
    a `NotFoundException` exception if no product entity is found. Before the product
    information is returned, the `serviceUtil` object is used to fill in the currently
    used address of the microservice.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s see the `deleteProduct` method:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `delete` method also uses the `findByProductId()` method in the repository
    and uses the `ifPresent()` method in the `Optional` class to conveniently delete
    the entity only if it exists. Note that the implementation is idempotent; it will
    not report any failure if the entity is not found.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: For the full source code, see the service implementation class in each of the
    core microservice projects, for example, `ProductServiceImpl` in the `product-service`
    project.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a Java bean mapper
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, what about the magic Java bean mapper?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned, MapStruct is used to declare our mapper classes. The use
    of MapStruct is similar in all three core microservices, so we will only go through
    the source code for the mapper object in the `product` microservice.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mapper` class for the `product` service looks like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following can be noted from the code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The `entityToApi()` method maps entity objects to the API model object. Since
    the entity class does not have a field for `serviceAddress`, the `entityToApi()`
    method is annotated to ignore the `serviceAddress` field in the API model object.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `apiToEntity()` method maps API model objects to entity objects. In the
    same way, the `apiToEntity()` method is annotated to ignore the `id` and `version`
    fields that are missing in the API model class.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not only does MapStruct support mapping fields by name but it can also be directed
    to map fields with different names. In the mapper class for the `recommendation`
    service, the `rating` entity field is mapped to the API model field, `rate`, using
    the following annotations:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: After a successful Gradle build, the generated mapping implementation can be
    found in the `build/classes` folder for each project. For example, `ProductMapperImpl.java`
    in the `product-service` project.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: For the full source code, see the mapper class in each of the core microservice
    projects, for example, `ProductMapper` in the `product-service` project.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Updating the service tests
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tests of the APIs exposed by the core microservices have been updated since
    the previous chapter with tests covering the create and delete API operations.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The added tests are similar in all three core microservices, so we will only
    go through the source code for the service tests in the `product` microservice.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure a known state for each test, a setup method, `setupDb()`, is declared
    and annotated with `@BeforeEach`, so it is executed before each test. The setup
    method removes any previously created entities:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The test method for the create API verifies that a product entity can be retrieved
    after it has been created and that creating another product entity with the same
    `productId` results in an expected error, `UNPROCESSABLE_ENTITY`, in the response
    to the API request:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The test method for the delete API verifies that a product entity can be deleted
    and that a second delete request is idempotent—it also returns the status code
    OK, even though the entity no longer exists in the database:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To simplify sending the create, read, and delete requests to the API and verify
    the response status, three helper methods have been created:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '`postAndVerifyProduct()`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getAndVerifyProduct()`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deleteAndVerifyProduct()`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `postAndVerifyProduct()` method looks like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The helper method performs the actual HTTP request and verifies the response
    code and content type of the response body. Added to that, the helper method also
    returns the body of the response for further investigations by the caller, if
    required. The other two helper methods for read and delete requests are similar.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: The source code for the three service test classes can be found in each of the
    core microservice projects, for example, `ProductServiceApplicationTests` in the
    `product-service` project.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to see how we extend a composite service API.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Extending the composite service API
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will see how we can extend the composite API with operations
    for creating and deleting composite entities. We will go through the following
    steps:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Adding new operations to the composite service API
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding methods to the integration layer
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the new composite API operations
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating the composite service tests
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding new operations to the composite service API
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The composite versions of creating and deleting entities and handling aggregated
    entities are similar to the create and delete operations in the core service APIs.
    The major difference is that they have annotations added for OpenAPI-based documentation.
    For an explanation of the usage of the OpenAPI annotations `@Operation` and `@ApiResponse`,
    refer to *Chapter 5*, *Adding an API Description Using OpenAPI*, specifically
    the *Adding API-specific documentation to the ProductCompositeService interface*
    section.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'The API operation for creating a composite product entity is declared as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The API operation for deleting a composite product entity is declared as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For the full source code, see the Java interface `ProductCompositeService` in
    the `api` project.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to, as before, add the descriptive text of the API documentation
    to the property file, `application.yml`, in the `product-composite` project:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Using the Swagger UI viewer, the updated OpenAPI documentation will look like
    this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B19825_06_06.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Updated OpenAPI documentation'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Later on in this chapter, we will use the Swagger UI viewer to try out the new
    composite API operations.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Adding methods to the integration layer
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can implement the new create and delete APIs in the composite services,
    we need to extend the integration layer so it can call the underlying create and
    delete operations in the APIs of the core microservices.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: The methods in the integration layer for calling the create and delete operations
    in the three core microservices are straightforward and similar to each other,
    so we will only go through the source code for the methods that call the `product`
    microservice.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'The `createProduct()` method looks like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It simply delegates the responsibility of sending the HTTP request to the `RestTemplate`
    object and delegates error handling to the helper method, `handleHttpClientException`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'The `deleteProduct()` method looks like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It is implemented in the same way as for the create method but performs an HTTP
    `delete` request instead.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The full source code for the integration layer can be found in the `ProductCompositeIntegration`
    class in the `product-composite` project.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the new composite API operations
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we can implement the composite create and delete methods!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'The composite create method will split up the aggregate product object into
    discrete objects for `product`, `recommendation`, and `review` and call the corresponding
    create methods in the integration layer:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The composite delete method simply calls the three delete methods in the integration
    layer to delete the corresponding entities in the underlying databases:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The full source code for the service implementation can be found in the `ProductCompositeServiceImpl`
    class in the `product-composite` project.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: For happy-day scenarios, this implementation will work fine, but if we consider
    various error scenarios, we see that this implementation will cause trouble!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: What if, for example, one of the underlying core microservices is temporarily
    not available, for instance, due to internal, network, or database problems?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: This might result in partly created or deleted composite products. For the delete
    operation, this can be fixed if the requester simply calls the composite’s delete
    method until it succeeds. However, if the underlying problem remains for a while,
    the requester will probably give up, resulting in an inconsistent state of the
    composite product— which is not acceptable in most cases!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *Chapter 7*, *Developing Reactive Microservices*, we will
    see how we can address these types of shortcomings with synchronous APIs as a
    RESTful API.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: For now, let’s move on with this fragile design in mind.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Updating the composite service tests
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing composite services, as already mentioned in *Chapter 3*, *Creating a
    Set of Cooperating Microservices* (refer to the *Adding automated microservice
    tests in isolation* section), is limited to using simple mock components instead
    of the actual core services. This restricts us from testing more complex scenarios,
    for example, error handling when trying to create duplicates in the underlying
    databases.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests for the composite create and delete API operations are therefore
    relatively simple:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The full source code for the service test can be found in the `ProductCompositeServiceApplicationTests`
    class in the `product-composite` project.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: These are all the changes required in the source code. Before we can test the
    microservices together, we must learn how to add databases to the system landscape
    managed by Docker Compose.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Adding databases to the Docker Compose landscape
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we have all of the source code in place. Before we can start up the microservice
    landscape and try out the new APIs together with the new persistence layer, we
    must start up some databases.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: We will bring MongoDB and MySQL into the system landscape controlled by Docker
    Compose and add configuration to our microservices so that they can find their
    databases when running.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: The Docker Compose configuration
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MongoDB and MySQL are declared as follows in the Docker Compose configuration
    file, `docker-compose.yml`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Notes from the preceding code:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: We will use the official Docker image for MongoDB v6.0.4 and MySQL 8.0.32 and
    forward their default ports `27017` and `3306` to the Docker host, also made available
    on `localhost` when using Docker Desktop for Mac.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For MySQL, we also declare some environment variables, defining the following:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root password
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the database that will be created on container startup
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A username and password for a user that is set up for the database on container
    startup
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We also declare a health check that Docker will run to determine the status
    of the MongoDB and MySQL databases.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To avoid microservices trying to connect to databases before they are up and
    running, the `product` and `recommendation` services are declared as dependent
    on the MongoDB database, as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'For the same reason, the `review` service is declared as dependent on the MySQL
    database:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This means that Docker Compose will not start up the microservice containers
    until the database containers are launched and reported as healthy by their health
    checks.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Database connection configuration
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the database in place, we now need to set up the configuration for the
    core microservices so they know how to connect to their databases. This is set
    up in each core microservice’s configuration file, `application.yml`, in the `product-service`,
    `recommendation-service`, and `review-service` projects.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration for the `product` and `recommendation` services are similar,
    so we will only look into the configuration of the `product` service. The following
    part of the configuration is of interest:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Important parts of the preceding code:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: When running without Docker using the default Spring profile, the database is
    expected to be reachable on `localhost:27017`.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the log level for `MongoTemplate` to `DEBUG` will allow us to see which
    MongoDB statements are executed in the log.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When running inside Docker using the Spring profile, `docker`, the database
    is expected to be reachable on `mongodb:27017`.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The configuration for the `review` service, which affects how it connects to
    its SQL database, looks like the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Explanations for the preceding code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: By default, Hibernate will be used by Spring Data JPA as JPA’s EntityManager.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `spring.jpa.hibernate.ddl-auto` property is used to tell Spring Data JPA
    to create new or update existing SQL tables during startup.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**: It is strongly recommended to set the `spring.jpa.hibernate.ddl-auto`
    property to `none` or `validate` in a production environment—this prevents Spring
    Data JPA from manipulating the structure of the SQL tables. For more information,
    see [https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-database-initialization](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-database-initialization).'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: When running without Docker, using the default Spring profile, the database
    is expected to be reachable on `localhost` using the default port `3306`.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, HikariCP is used by Spring Data JPA as the JDBC connection pool.
    To minimize startup problems on computers with limited hardware resources, the
    `initializationFailTimeout` parameter is set to 60 seconds. This means that the
    Spring Boot application will wait for up to 60 seconds during startup to establish
    a database connection.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The log-level settings for Hibernate will cause Hibernate to print the SQL statements
    used and the actual values used. Please note that when used in a production environment,
    writing the actual values to the log should be avoided for privacy reasons.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When running inside Docker using the Spring profile, `docker`, the database
    is expected to be reachable on the `mysql` hostname using the default port `3306`.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this configuration in place, we are ready to start up the system landscape.
    But before we do that, let’s learn how we can run database CLI tools.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: The MongoDB and MySQL CLI tools
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have started to run some tests with the microservices, it will be interesting
    to see what data is actually stored in the microservices’ databases. Each database
    Docker container comes with CLI-based tools that can be used to query the database
    tables and collections. To be able to run the database CLI tools, the Docker Compose
    `exec` command can be used.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: The commands described in this section will be used when we get to the manual
    tests in the next section. Don’t try to run them now; they will fail since we
    have no databases up and running yet!
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the MongoDB CLI tool, `mongo`, inside the `mongodb` container, run
    the following command:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Enter `exit` to leave the `mongo` CLI.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the MySQL CLI tool, `mysql`, inside the `mysql` container and log
    in to `review-db` using the user created at startup, run the following command:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `mysql` CLI tool will prompt you for a password; you can find it in the
    `docker-compose.yml` file. Look for the value of the environment variable `MYSQL_PASSWORD`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Enter `exit` to leave the `mysql` CLI.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: We will see the usage of these tools in the next section.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer graphical database tools, you can run them locally as well, since
    both the MongoDB and the MySQL containers expose their standard ports on localhost.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Manual tests of the new APIs and the persistence layer
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we have everything in place to test the microservices together. We will
    build new Docker images and start up the system landscape using Docker Compose
    based on the Docker images. Next, we will use the Swagger UI viewer to run some
    manual tests. Finally, we will use the database CLI tools to see what data was
    inserted into the databases.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and start the system landscape with the following command:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Open Swagger UI in a web browser, `http://localhost:8080/openapi/swagger-ui.html`,
    and perform the following steps on the web page:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **ProductComposite** service and the **POST** method to expand
    them.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Try it out** button and go down to the body field.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the default value, `0`, of the `productId` field with `123456`.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down to the **Execute** button and click on it.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the returned response code is **200**.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is a sample screenshot after hitting the **Execute** button:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_06_07.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Testing the server response'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'In the log output from the `docker-compose up` command, we should be able to
    see output like the following (abbreviated for increased readability):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19825_06_08.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: Log output from docker-compose up'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the database CLI tools to see the actual content in the different
    databases.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Look up the content in the `product` service, that is, the `products` collection
    in MongoDB, with the following command:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Expect a response like this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_06_09.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: Looking up products'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'Look up the content in the `recommendation` service, that is, the `recommendations`
    collection in MongoDB, with the following command:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Expect a response like this:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_06_10.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: Looking up recommendations'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'Look up the content in the `review` service, that is, the `reviews` table in
    MySQL, with the following command:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `mysql` CLI tool will prompt you for a password; you can find it in the
    `docker-compose.yml` file. Look for the value of the environment variable `MYSQL_PASSWORD`.
    Expect a response like the following:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19825_06_11.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Looking up reviews'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Bring down the system landscape by interrupting the `docker-compose up` command
    with *Ctrl* + *C*, followed by the command `docker-compose down`. After this,
    let us see how to update the automated tests in a microservice landscape.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Updating the automated tests of the microservice landscape
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The automated tests of the microservice landscape, `test-em-all.bash`, need
    to be updated so that they ensure that the database of each microservice has a
    known state before it runs the tests.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: The script is extended with a setup function, `setupTestdata()`, which uses
    the composite create and delete APIs to set up test data used by the tests.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setupTestdata` function looks like this:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It uses a helper function, `recreateComposite()`, to perform the actual requests
    to the delete and create APIs:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `setupTestdata` function is called directly after the `waitForService`
    function:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The main purpose of the `waitForService` function is to verify that all microservices
    are up and running. In the previous chapter, the get API on the composite product
    service was used. In this chapter, the delete API is used instead. When using
    the get API, only the `product` core microservice is called if the entity is not
    found; the `recommendation` and `review` services will not be called to verify
    that they are up and running. The call to the delete API will also ensure that
    the *Not Found* test on `productId 13` will succeed. In the next chapter, we will
    see how we can define specific APIs for checking the health state of a microservice
    landscape.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the updated test script with the following command:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The execution should end by writing a log message like this:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_06_12.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: Log message at the end of test execution'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the updates on the automated tests of the microservice landscape.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how we can use Spring Data to add a persistence layer
    to the core microservices. We used the core concepts of Spring Data, repositories,
    and entities to store data in both MongoDB and MySQL. The programming model is
    similar for a NoSQL database such as MongoDB and a SQL database such as MySQL,
    even though it’s not fully portable. We also saw how Spring Boot’s annotations,
    `@DataMongoTest` and `@DataJpaTest`, can be used to conveniently set up tests
    targeted for persistence; this is where a database is started automatically before
    the test runs, but no other infrastructure that the microservice will need at
    runtime, for example, a web server such as Netty, is started up. To handle the
    startup and teardown of databases, we have used Testcontainers, which runs the
    databases in Docker containers. This results in persistence tests that are easy
    to set up and that start with minimum overhead.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen how the persistence layer can be used by the service layer
    and how we can add APIs for creating and deleting entities, both core and composite.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how convenient it is to start up databases such as MongoDB
    and MySQL at runtime using Docker Compose and how to use the new create and delete
    APIs to set up test data before running automated tests of the microservice-based
    system landscape.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: However, one major concern was identified in this chapter. Updating (creating
    or deleting) a composite entity—an entity whose parts are stored in a number of
    microservices—using synchronous APIs can lead to inconsistencies, if not all involved
    microservices are updated successfully. This is, in general, not acceptable. This
    leads us into the next chapter, where we will look into why and how to build reactive
    microservices, that is, microservices that are scalable and robust.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Data, a common programming model based on entities and repositories,
    can be used for different types of database engines. From the source code examples
    in this chapter, what are the most important differences in the persistence code
    for MySQL and MongoDB?
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is required to implement optimistic locking using Spring Data?
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is MapStruct used for?
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does it mean if an operation is idempotent and why is that useful?
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we access the data that is stored in the MySQL and MongoDB databases
    without using the API?
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
