- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to persist data that a microservice is using.
    As already mentioned in *Chapter 2*, *Introduction to Spring Boot*, we will use
    the Spring Data project to persist data to MongoDB and MySQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: The `product` and `recommendation` microservices will use Spring Data for MongoDB
    and the `review` microservice will use Spring Data for the **Java Persistence
    API** (**JPA**) to access a MySQL database. We will add operations to the RESTful
    APIs to be able to create and delete data in the databases. The existing APIs
    for reading data will be updated to access the databases. We will run the databases
    as Docker containers, managed by Docker Compose, that is, in the same way as we
    run our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a persistence layer to the core microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing automated tests that focus on persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the persistence layer in the service layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the composite service API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding databases to the Docker Compose landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual testing of the new APIs and the persistence layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the automated tests of the microservice landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For instructions on how to install the tools used in this book and how to access
    the source code for this book, see:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 21*, *Installation Instructions for macOS*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 22*, *Installation Instructions for Microsoft Windows with WSL 2 and
    Ubuntu*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To access the databases manually, we will use the CLI tools provided in the
    Docker images used to run the databases. We will also expose the standard ports
    used for each database in Docker Compose, `3306` for MySQL and `27017` for MongoDB.
    This will enable us to use our favorite database tools to access the databases
    in the same way as if they were running locally on our computers.
  prefs: []
  type: TYPE_NORMAL
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter06`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to view the changes applied to the source code in this chapter,
    that is, see what it took to add persistence to the microservices using Spring
    Data, you can compare it with the source code for *Chapter 5*, *Adding an API
    Description Using OpenAPI*. You can use your favorite `diff` tool and compare
    the two folders, `$BOOK_HOME/Chapter05` and `$BOOK_HOME/Chapter06`.
  prefs: []
  type: TYPE_NORMAL
- en: Before going into details, let’s see where we are heading.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter objectives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By the end of this chapter, we will have layers inside our microservices that
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19825_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: The microservice landscape we’re aiming for'
  prefs: []
  type: TYPE_NORMAL
- en: The **Protocol layer** handles protocol-specific logic. It is very thin, only
    consisting of the `RestController` annotations in the `api` project and the common
    `GlobalControllerExceptionHandler` in the `util` project. The main functionality
    of each microservice resides in each **Service layer**.
  prefs: []
  type: TYPE_NORMAL
- en: The `product-composite` service contains an **Integration layer** used to handle
    the communication with the three core microservices. The core microservices will
    all have a **Persistence layer** used for communicating with their databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be able to access data stored in MongoDB with a command like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the command should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19825_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Accessing data stored in MongoDB'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding data stored in MySQL, we will be able to access it with a command
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the command should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19825_06_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Accessing data stored in MySQL'
  prefs: []
  type: TYPE_NORMAL
- en: The output from the `mongo` and `mysql` commands has been shortened for improved
    readability.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how to implement this. We will start by adding persistence functionality
    to our core microservices!
  prefs: []
  type: TYPE_NORMAL
- en: Adding a persistence layer to the core microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start with adding a persistence layer to the core microservices. Besides
    using Spring Data, we will also use a Java bean mapping tool, **MapStruct**, which
    makes it easy to transform between Spring Data entity objects and the API model
    classes. For further details, see [http://mapstruct.org/](http://mapstruct.org/).
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to add dependencies to MapStruct, Spring Data, and the JDBC drivers
    for the databases we intend to use. After that, we can define our Spring Data
    entity classes and repositories. The Spring Data entity classes and repositories
    will be placed in their own Java package, `persistence`. For example, for the
    product microservice, they will be placed in the Java package `se.magnus.microservices.core.product.persistence`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use MapStruct v1.5.3, so we will start by defining a variable holding
    the version information in the build file for each core microservice, `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we declare a dependency on MapStruct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Since MapStruct generates the implementation of the bean mappings at compile
    time by processing MapStruct annotations, we need to add an `annotationProcessor`
    and a `testAnnotationProcessor` dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the compile-time generation work in popular IDEs such as IntelliJ IDEA,
    we also need to add the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you are using IntelliJ IDEA, you also need to ensure that support for annotation
    processing is enabled. Open **Preferences** and navigate to **Build**, **Execute**,
    **Deployment | Compiler | Annotations Processors**. Verify that the checkbox named
    **Enable annotation processing** is selected!
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `product` and `recommendation` microservices, we declare the following
    dependencies to Spring Data for MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `review` microservice, we declare a dependency on Spring Data for JPA
    and a JDBC driver for MySQL like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable the use of MongoDB and MySQL when running automated integration tests,
    we will use **Testcontainers** and its support for JUnit 5, MongoDB, and MySQL.
    For the `product` and `recommendation` microservices, we declare the following
    test dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `review` microservices, we declare the following test dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For more information on how Testcontainers is used in integration tests, see
    the *Writing automated tests that focus on persistence* section later on.
  prefs: []
  type: TYPE_NORMAL
- en: Storing data with entity classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The entity classes are similar to the corresponding API model classes in terms
    of what fields they contain; see the Java package `se.magnus.api.core` in the
    `api` project. We will add two fields, `id` and `version`, in the entity classes
    compared to the API model classes.
  prefs: []
  type: TYPE_NORMAL
- en: The `id` field is used to hold the database identity of each stored entity,
    corresponding to the primary key when using a relational database. We will delegate
    the responsibility of generating unique values for the `id` field to Spring Data.
    Depending on the database used, Spring Data can delegate this responsibility to
    the database engine or handle it on its own. In either case, the application code
    does not need to consider how a unique database `id` value is set. The `id` field
    is not exposed in the API, as a best practice from a security perspective. The
    fields in the model classes that identify an entity will be assigned a unique
    index in the corresponding entity class, to ensure consistency in the database
    from a business perspective.
  prefs: []
  type: TYPE_NORMAL
- en: The `version` field is used to implement optimistic locking, allowing Spring
    Data to verify that updates of an entity in the database do not overwrite a concurrent
    update. If the value of the `version` field stored in the database is higher than
    the value of the `version` field in an update request, this indicates that the
    update is performed on stale data—the information to be updated has been updated
    by someone else since it was read from the database. Attempts to perform updates
    based on stale data will be prevented by Spring Data. In the section on writing
    persistence tests, we will see tests verifying that the optimistic locking mechanism
    in Spring Data prevents updates performed on stale data. Since we only implement
    APIs for create, read, and delete operations, we will not expose the `version`
    field in the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most interesting parts of the product entity class, used for storing entities
    in MongoDB, look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some observations from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@Document(collection = "products")` annotation is used to mark the class
    as an entity class used for MongoDB, that is, mapped to a collection in MongoDB
    with the name `products`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Id` and `@Version` annotations are used to mark the `id` and `version`
    fields to be used by Spring Data, as explained previously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Indexed(unique = true)` annotation is used to get a unique index created
    for the business key, `productId`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most interesting parts of the `Recommendation` entity class, also used
    for storing entities in MongoDB, look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Added to the explanations for the preceding product entity, we can see how a
    unique compound index is created using the `@CompoundIndex` annotation for the
    compound business key based on the `productId` and `recommendationId` fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the most interesting parts of the `Review` entity class, used for
    storing entities in a SQL database like MySQL, look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Notes from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@Entity` and `@Table` annotations are used to mark the class as an entity
    class used for JPA—mapped to a table in a SQL database with the name `reviews`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Table` annotation is also used to specify that a unique compound index
    will be created for the compound business key based on the `productId` and `reviewId`
    fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Id` and `@Version` annotations are used to mark the `id` and `version`
    fields to be used by Spring Data, as explained previously. To direct Spring Data
    to JPA in order to automatically generate unique `id` values for the `id` field,
    we are using the `@GeneratedValue` annotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the full source code of the entity classes, see the `persistence` package
    in each of the core microservice projects.
  prefs: []
  type: TYPE_NORMAL
- en: Defining repositories in Spring Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring Data comes with a set of interfaces for defining repositories. We will
    use the interfaces `CrudRepository` and `PagingAndSortingRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `CrudRepository` interface provides standard methods for performing basic
    create, read, update, and delete operations on the data stored in the databases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PagingAndSortingRepository` interface adds support for paging and sorting
    to the `CrudRepository` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use the `CrudRepository` interface as the base for the `Recommendation`
    and `Review` repositories and also the `PagingAndSortingRepository` interface
    as the base for the `Product` repository.
  prefs: []
  type: TYPE_NORMAL
- en: We will also add a few extra query methods to our repositories for looking up
    entities using the business key, `productId`.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data supports defining extra query methods based on naming conventions
    for the signature of the method. For example, the `findByProductId(int productId)`
    method signature can be used to direct Spring Data to automatically create a query
    that returns entities from the underlying collection or table. In this case, it
    will return entities that have the `productId` field set to the value specified
    in the `productId` parameter. For more details on how to declare extra queries,
    see [https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods.query-creation](https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods.query-creation).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Product` repository class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Since the `findByProductId` method might return zero or one product entity,
    the return value is marked to be optional by wrapping it in an `Optional` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Recommendation` repository class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `findByProductId` method will return zero to many recommendation
    entities, so the return value is defined as a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `Review` repository class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Since SQL databases are transactional, we have to specify the default transaction
    type—read-only in our case—for the query method, `findByProductId()`.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it—this is all it takes to establish a persistence layer for our core
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: For the full source code of the repository classes, see the `persistence` package
    in each of the core microservice projects.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start using the persistence classes by writing some tests to verify that
    they work as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Writing automated tests that focus on persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing persistence tests, we want to start a database when the tests begin
    and tear it down when the tests are complete. However, we don’t want the tests
    to wait for other resources to start up, for example, a web server such as Netty
    (which is required at runtime).
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Boot comes with two class-level annotations tailored to this specific
    requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@DataMongoTest`: This annotation starts up a MongoDB database when the test
    starts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@DataJpaTest`: This annotation starts up a SQL database when the test starts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, Spring Boot configures the tests to roll back updates to the SQL
    database to minimize the risk of negative side effects on other tests. In our
    case, this behavior will cause some of the tests to fail. Therefore, automatic
    rollback is disabled with the class-level annotation `@Transactional(propagation
    = NOT_SUPPORTED)`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To handle the startup and tear-down of databases during the execution of the
    integration tests, we will use Testcontainers. Before looking into how to write
    persistence tests, let’s learn about how to use Testcontainers.
  prefs: []
  type: TYPE_NORMAL
- en: Using Testcontainers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Testcontainers** ([https://www.testcontainers.org](https://www.testcontainers.org))
    is a library that simplifies running automated integration tests by running resource
    managers like a database or a message broker as a Docker container. Testcontainers
    can be configured to automatically start up Docker containers when JUnit tests
    are started and tear down the containers when the tests are complete.'
  prefs: []
  type: TYPE_NORMAL
- en: To enable Testcontainers in an existing test class for a Spring Boot application
    like the microservices in this book, we can add the `@Testcontainers` annotation
    to the test class. Using the `@Container` annotation, we can, for example, declare
    that the `Review` microservice’s integration tests will use a Docker container
    running MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The version specified for MySQL, 8.0.32, is copied from Docker Compose files
    to ensure that the same version is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'A disadvantage of this approach is that each test class will use its own Docker
    container. Bringing up MySQL in a Docker container takes a few seconds, typically
    10 seconds on my Mac. Running multiple test classes that use the same type of
    test container will add this latency for each test class. To avoid this extra
    latency, we can use the **Single Container Pattern** (see [https://www.testcontainers.org/test_framework_integration/manual_lifecycle_control/#singleton-containers](https://www.testcontainers.org/test_framework_integration/manual_lifecycle_control/#singleton-containers)).
    Following this pattern, a base class is used to launch a single Docker container
    for MySQL. The base class, `MySqlTestBase`, used in the `Review` microservice
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Explanations for the preceding source code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `database` container is declared in the same way as in the preceding example,
    with the addition of an extended wait period of five minutes for the container
    to start up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `static` block is used to start the database container before any JUnit code
    is invoked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The database container will get some properties defined when started up, such
    as which port to use. To register these dynamically created properties in the
    application context, a static method `databaseProperties()` is defined. The method
    is annotated with `@DynamicPropertySource` to override the database configuration
    in the application context, such as the configuration from an `application.yml`
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The test classes use the base class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For the `product` and `review` microservices, which use MongoDB, a corresponding
    base class, `MongoDbTestBase`, has been added.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the log output from Testcontainers is rather extensive. A **Logback**
    configuration file can be placed in the `src/test/resource` folder to limit the
    amount of log output. Logback is a logging framework ([http://logback.qos.ch](http://logback.qos.ch)),
    and it is included in the microservices by using the `spring-boot-starter-webflux`
    dependency. For details, see [https://www.testcontainers.org/supported_docker_environment/logging_config/](https://www.testcontainers.org/supported_docker_environment/logging_config/).
    The configuration file used in this chapter is named `src/test/resources/logback-test.xml`
    and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Some notes from the above `XML` file:'
  prefs: []
  type: TYPE_NORMAL
- en: The config file includes two config files provided by Spring Boot to define
    the default values, and a log appender is configured that can write log events
    to the console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The config file limits log output to the `INFO` log level, discarding the `DEBUG`
    and `TRACE` log records emitted by the Testcontainers library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For details on Spring Boot’s support for logging and the use of Logback, see
    [https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto-configure-logback-for-logging](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto-configure-logback-for-logging).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when using the `@DataMongoTest` and `@DataJpaTest` annotations instead
    of the `@SpringBootTest` annotation to only start up the MongoDB and SQL database
    during the integration test, there is one more thing to consider. The `@DataJpaTest`
    annotation is designed to start an embedded database by default. Since we want
    to use a containerized database, we have to disable this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `@DataJpaTest` annotation, this can be done by using an `@AutoConfigureTestDatabase`
    annotation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With Testcontainers introduced, we are ready to see how persistence tests can
    be written.
  prefs: []
  type: TYPE_NORMAL
- en: Writing persistence tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The persistence tests for the three core microservices are similar to each other,
    so we will only go through the persistence tests for the `product` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test class, `PersistenceTests`, declares a method, `setupDb()`, annotated
    with `@BeforeEach`, which is executed before each test method. The setup method
    removes any entities from previous tests in the database and inserts an entity
    that the test methods can use as the base for their tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next come the various test methods. First is a `create` test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This test creates a new entity, verifies that it can be found using the `findById`
    method, and wraps up by asserting that there are two entities stored in the database,
    the one created by the `setup` method and the one created by the test itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update` test looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This test updates the entity created by the `setup` method, reads it again from
    the database using the standard `findById()` method, and asserts that it contains
    expected values for some of its fields. Note that, when an entity is created,
    its `version` field is set to `0` by Spring Data, so we expect it to be `1` after
    the update.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `delete` test looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This test deletes the entity created by the `setup` method and verifies that
    it no longer exists in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `read` test looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This test uses the `findByProductId()` method to get the entity created by the
    `setup` method, verifies that it was found, and then uses the local helper method,
    `assertEqualsProduct()`, to verify that the entity returned by `findByProductId()`
    looks the same as the entity stored by the `setup` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next are two test methods that verify alternative flows—handling error conditions.
    First is a test that verifies that duplicates are handled correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The test tries to store an entity with the same business key as used by the
    entity created by the `setup` method. The test will fail if the save operation
    succeeds, or if the save fails with an exception other than the expected `DuplicateKeyException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other negative test is, in my opinion, the most interesting test in the
    test class. It is a test that verifies correct error handling in the case of updates
    of stale data—it verifies that the optimistic locking mechanism works. It looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is observed from the code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the test reads the same entity twice and stores it in two different variables,
    `entity1` and `entity2`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, it uses one of the variables, `entity1`, to update the entity. The update
    of the entity in the database will cause the `version` field of the entity to
    be increased automatically by Spring Data. The other variable, `entity2`, now
    contains stale data, manifested by its `version` field, which holds a lower value
    than the corresponding value in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the test tries to update the entity using the variable `entity2`, which
    contains stale data, it is expected to fail by throwing an `OptimisticLockingFailureException`
    exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test wraps up by asserting that the entity in the database reflects the
    first update, that is, contains the name `"n1"`, and that the `version` field
    has the value `1`; only one update has been performed on the entity in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the `product` service contains a test that demonstrates the usage
    of built-in support for sorting and paging in Spring Data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Explanations for the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The test starts by removing any existing data, then inserts 10 entities with
    the `productId` field ranging from `1001` to `1010`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, it creates `PageRequest`, requesting a page count of `4` entities per
    page and a sort order based on `ProductId` in ascending order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it uses a helper method, `testNextPage`, to read the expected three
    pages, verifying the expected product IDs on each page and verifying that Spring
    Data correctly reports back whether more pages exist or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The helper method `testNextPage` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The helper method uses the page request object, `nextPage`, to get the next
    page from the repository method, `findAll()`. Based on the result, it extracts
    the product IDs from the returned entities into a string and compares it to the
    expected list of product IDs. Finally, it returns the next page.
  prefs: []
  type: TYPE_NORMAL
- en: For the full source code of the persistence tests, see the test class `PersistenceTests`
    in each of the core microservice projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The persistence tests in the `product` microservice can be executed using Gradle
    with a command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the tests, it should respond with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19825_06_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: BUILD SUCCESSFUL response'
  prefs: []
  type: TYPE_NORMAL
- en: With a persistence layer in place, we can update the service layer in our core
    microservices to use the persistence layer.
  prefs: []
  type: TYPE_NORMAL
- en: Using the persistence layer in the service layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to use the persistence layer in the service
    layer to store and retrieve data from a database. We will go through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Logging the database connection URL
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding new APIs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling the persistence layer from the service layer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declaring a Java bean mapper
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating the service tests
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Logging the database connection URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When scaling up the number of microservices where each microservice connects
    to its own database, it can be hard to keep track of what database each microservice
    actually uses. To avoid this confusion, a good practice is to add a `LOG` statement
    directly after the startup of a microservice that logs connection information
    that is used to connect to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the startup code for the `product` service looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to the `LOG.info` method will write something like the following to
    the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19825_06_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Expected log output'
  prefs: []
  type: TYPE_NORMAL
- en: For the full source code, see the main application class in each of the core
    microservice projects, for example, `ProductServiceApplication` in the `product-service`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can use the persistence layer to create and delete information in
    the database, we need to create the corresponding API operations in our core service
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API operations for creating and deleting a product entity look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of the delete operation will be **idempotent**; that is,
    it will return the same result if called several times. This is a valuable characteristic
    in fault scenarios. For example, if a client experiences a network timeout during
    a call to a delete operation, it can simply call the delete operation again without
    worrying about varying responses, for example, **OK** (**200**) in response the
    first time and **Not Found** (**404**) in response to consecutive calls, or any
    unexpected side effects. This implies that the operation should return the status
    code **OK** (**200**) even though the entity no longer exists in the database.
  prefs: []
  type: TYPE_NORMAL
- en: The API operations for the `recommendation` and `review` entities look similar;
    however, note that when it comes to the delete operation for the `recommendation`
    and `review` entities, it will delete all `recommendations` and `reviews` for
    the specified `productId`.
  prefs: []
  type: TYPE_NORMAL
- en: For the full source code, see the interface declarations (`ProductService`,
    `RecommendationService`, and `ReviewService`) of the core microservices in the
    `api` project.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the persistence layer from the service layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The source code in the service layer for using the persistence layer is structured
    in the same way for all core microservices. Therefore, we will only go through
    the source code for the `product` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to inject the repository class from the persistence layer and
    a Java bean mapper class into the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will see how the Java mapper class is defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `createProduct` method is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `createProduct` method used the `save` method in the repository to store
    a new entity. It should be noted that the mapper class is used to convert Java
    beans between an API model class and an entity class using the two mapper methods,
    `apiToEntity()` and `entityToApi()`. The only error we handle for the `create`
    method is the `DuplicateKeyException` exception, which we convert into an `InvalidInputException`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getProduct` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: After some basic input validation (that is, ensuring that `productId` is not
    negative), the `findByProductId()` method in the repository is used to find the
    product entity. Since the repository method returns an `Optional` product, we
    can use the `orElseThrow()` method in the `Optional` class to conveniently throw
    a `NotFoundException` exception if no product entity is found. Before the product
    information is returned, the `serviceUtil` object is used to fill in the currently
    used address of the microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s see the `deleteProduct` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `delete` method also uses the `findByProductId()` method in the repository
    and uses the `ifPresent()` method in the `Optional` class to conveniently delete
    the entity only if it exists. Note that the implementation is idempotent; it will
    not report any failure if the entity is not found.
  prefs: []
  type: TYPE_NORMAL
- en: For the full source code, see the service implementation class in each of the
    core microservice projects, for example, `ProductServiceImpl` in the `product-service`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a Java bean mapper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, what about the magic Java bean mapper?
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned, MapStruct is used to declare our mapper classes. The use
    of MapStruct is similar in all three core microservices, so we will only go through
    the source code for the mapper object in the `product` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mapper` class for the `product` service looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following can be noted from the code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `entityToApi()` method maps entity objects to the API model object. Since
    the entity class does not have a field for `serviceAddress`, the `entityToApi()`
    method is annotated to ignore the `serviceAddress` field in the API model object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `apiToEntity()` method maps API model objects to entity objects. In the
    same way, the `apiToEntity()` method is annotated to ignore the `id` and `version`
    fields that are missing in the API model class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not only does MapStruct support mapping fields by name but it can also be directed
    to map fields with different names. In the mapper class for the `recommendation`
    service, the `rating` entity field is mapped to the API model field, `rate`, using
    the following annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: After a successful Gradle build, the generated mapping implementation can be
    found in the `build/classes` folder for each project. For example, `ProductMapperImpl.java`
    in the `product-service` project.
  prefs: []
  type: TYPE_NORMAL
- en: For the full source code, see the mapper class in each of the core microservice
    projects, for example, `ProductMapper` in the `product-service` project.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the service tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tests of the APIs exposed by the core microservices have been updated since
    the previous chapter with tests covering the create and delete API operations.
  prefs: []
  type: TYPE_NORMAL
- en: The added tests are similar in all three core microservices, so we will only
    go through the source code for the service tests in the `product` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure a known state for each test, a setup method, `setupDb()`, is declared
    and annotated with `@BeforeEach`, so it is executed before each test. The setup
    method removes any previously created entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The test method for the create API verifies that a product entity can be retrieved
    after it has been created and that creating another product entity with the same
    `productId` results in an expected error, `UNPROCESSABLE_ENTITY`, in the response
    to the API request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The test method for the delete API verifies that a product entity can be deleted
    and that a second delete request is idempotent—it also returns the status code
    OK, even though the entity no longer exists in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To simplify sending the create, read, and delete requests to the API and verify
    the response status, three helper methods have been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '`postAndVerifyProduct()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getAndVerifyProduct()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deleteAndVerifyProduct()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `postAndVerifyProduct()` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The helper method performs the actual HTTP request and verifies the response
    code and content type of the response body. Added to that, the helper method also
    returns the body of the response for further investigations by the caller, if
    required. The other two helper methods for read and delete requests are similar.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for the three service test classes can be found in each of the
    core microservice projects, for example, `ProductServiceApplicationTests` in the
    `product-service` project.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to see how we extend a composite service API.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the composite service API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will see how we can extend the composite API with operations
    for creating and deleting composite entities. We will go through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding new operations to the composite service API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding methods to the integration layer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the new composite API operations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating the composite service tests
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding new operations to the composite service API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The composite versions of creating and deleting entities and handling aggregated
    entities are similar to the create and delete operations in the core service APIs.
    The major difference is that they have annotations added for OpenAPI-based documentation.
    For an explanation of the usage of the OpenAPI annotations `@Operation` and `@ApiResponse`,
    refer to *Chapter 5*, *Adding an API Description Using OpenAPI*, specifically
    the *Adding API-specific documentation to the ProductCompositeService interface*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API operation for creating a composite product entity is declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The API operation for deleting a composite product entity is declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: For the full source code, see the Java interface `ProductCompositeService` in
    the `api` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to, as before, add the descriptive text of the API documentation
    to the property file, `application.yml`, in the `product-composite` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the Swagger UI viewer, the updated OpenAPI documentation will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B19825_06_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Updated OpenAPI documentation'
  prefs: []
  type: TYPE_NORMAL
- en: Later on in this chapter, we will use the Swagger UI viewer to try out the new
    composite API operations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding methods to the integration layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can implement the new create and delete APIs in the composite services,
    we need to extend the integration layer so it can call the underlying create and
    delete operations in the APIs of the core microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The methods in the integration layer for calling the create and delete operations
    in the three core microservices are straightforward and similar to each other,
    so we will only go through the source code for the methods that call the `product`
    microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `createProduct()` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: It simply delegates the responsibility of sending the HTTP request to the `RestTemplate`
    object and delegates error handling to the helper method, `handleHttpClientException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `deleteProduct()` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: It is implemented in the same way as for the create method but performs an HTTP
    `delete` request instead.
  prefs: []
  type: TYPE_NORMAL
- en: The full source code for the integration layer can be found in the `ProductCompositeIntegration`
    class in the `product-composite` project.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the new composite API operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we can implement the composite create and delete methods!
  prefs: []
  type: TYPE_NORMAL
- en: 'The composite create method will split up the aggregate product object into
    discrete objects for `product`, `recommendation`, and `review` and call the corresponding
    create methods in the integration layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The composite delete method simply calls the three delete methods in the integration
    layer to delete the corresponding entities in the underlying databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The full source code for the service implementation can be found in the `ProductCompositeServiceImpl`
    class in the `product-composite` project.
  prefs: []
  type: TYPE_NORMAL
- en: For happy-day scenarios, this implementation will work fine, but if we consider
    various error scenarios, we see that this implementation will cause trouble!
  prefs: []
  type: TYPE_NORMAL
- en: What if, for example, one of the underlying core microservices is temporarily
    not available, for instance, due to internal, network, or database problems?
  prefs: []
  type: TYPE_NORMAL
- en: This might result in partly created or deleted composite products. For the delete
    operation, this can be fixed if the requester simply calls the composite’s delete
    method until it succeeds. However, if the underlying problem remains for a while,
    the requester will probably give up, resulting in an inconsistent state of the
    composite product— which is not acceptable in most cases!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *Chapter 7*, *Developing Reactive Microservices*, we will
    see how we can address these types of shortcomings with synchronous APIs as a
    RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let’s move on with this fragile design in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the composite service tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing composite services, as already mentioned in *Chapter 3*, *Creating a
    Set of Cooperating Microservices* (refer to the *Adding automated microservice
    tests in isolation* section), is limited to using simple mock components instead
    of the actual core services. This restricts us from testing more complex scenarios,
    for example, error handling when trying to create duplicates in the underlying
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests for the composite create and delete API operations are therefore
    relatively simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The full source code for the service test can be found in the `ProductCompositeServiceApplicationTests`
    class in the `product-composite` project.
  prefs: []
  type: TYPE_NORMAL
- en: These are all the changes required in the source code. Before we can test the
    microservices together, we must learn how to add databases to the system landscape
    managed by Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Adding databases to the Docker Compose landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we have all of the source code in place. Before we can start up the microservice
    landscape and try out the new APIs together with the new persistence layer, we
    must start up some databases.
  prefs: []
  type: TYPE_NORMAL
- en: We will bring MongoDB and MySQL into the system landscape controlled by Docker
    Compose and add configuration to our microservices so that they can find their
    databases when running.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker Compose configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MongoDB and MySQL are declared as follows in the Docker Compose configuration
    file, `docker-compose.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Notes from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: We will use the official Docker image for MongoDB v6.0.4 and MySQL 8.0.32 and
    forward their default ports `27017` and `3306` to the Docker host, also made available
    on `localhost` when using Docker Desktop for Mac.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For MySQL, we also declare some environment variables, defining the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root password
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the database that will be created on container startup
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A username and password for a user that is set up for the database on container
    startup
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We also declare a health check that Docker will run to determine the status
    of the MongoDB and MySQL databases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To avoid microservices trying to connect to databases before they are up and
    running, the `product` and `recommendation` services are declared as dependent
    on the MongoDB database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'For the same reason, the `review` service is declared as dependent on the MySQL
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This means that Docker Compose will not start up the microservice containers
    until the database containers are launched and reported as healthy by their health
    checks.
  prefs: []
  type: TYPE_NORMAL
- en: Database connection configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the database in place, we now need to set up the configuration for the
    core microservices so they know how to connect to their databases. This is set
    up in each core microservice’s configuration file, `application.yml`, in the `product-service`,
    `recommendation-service`, and `review-service` projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration for the `product` and `recommendation` services are similar,
    so we will only look into the configuration of the `product` service. The following
    part of the configuration is of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Important parts of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: When running without Docker using the default Spring profile, the database is
    expected to be reachable on `localhost:27017`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the log level for `MongoTemplate` to `DEBUG` will allow us to see which
    MongoDB statements are executed in the log.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When running inside Docker using the Spring profile, `docker`, the database
    is expected to be reachable on `mongodb:27017`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The configuration for the `review` service, which affects how it connects to
    its SQL database, looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Explanations for the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: By default, Hibernate will be used by Spring Data JPA as JPA’s EntityManager.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `spring.jpa.hibernate.ddl-auto` property is used to tell Spring Data JPA
    to create new or update existing SQL tables during startup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note**: It is strongly recommended to set the `spring.jpa.hibernate.ddl-auto`
    property to `none` or `validate` in a production environment—this prevents Spring
    Data JPA from manipulating the structure of the SQL tables. For more information,
    see [https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-database-initialization](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-database-initialization).'
  prefs: []
  type: TYPE_NORMAL
- en: When running without Docker, using the default Spring profile, the database
    is expected to be reachable on `localhost` using the default port `3306`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, HikariCP is used by Spring Data JPA as the JDBC connection pool.
    To minimize startup problems on computers with limited hardware resources, the
    `initializationFailTimeout` parameter is set to 60 seconds. This means that the
    Spring Boot application will wait for up to 60 seconds during startup to establish
    a database connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The log-level settings for Hibernate will cause Hibernate to print the SQL statements
    used and the actual values used. Please note that when used in a production environment,
    writing the actual values to the log should be avoided for privacy reasons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When running inside Docker using the Spring profile, `docker`, the database
    is expected to be reachable on the `mysql` hostname using the default port `3306`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this configuration in place, we are ready to start up the system landscape.
    But before we do that, let’s learn how we can run database CLI tools.
  prefs: []
  type: TYPE_NORMAL
- en: The MongoDB and MySQL CLI tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have started to run some tests with the microservices, it will be interesting
    to see what data is actually stored in the microservices’ databases. Each database
    Docker container comes with CLI-based tools that can be used to query the database
    tables and collections. To be able to run the database CLI tools, the Docker Compose
    `exec` command can be used.
  prefs: []
  type: TYPE_NORMAL
- en: The commands described in this section will be used when we get to the manual
    tests in the next section. Don’t try to run them now; they will fail since we
    have no databases up and running yet!
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the MongoDB CLI tool, `mongo`, inside the `mongodb` container, run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Enter `exit` to leave the `mongo` CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the MySQL CLI tool, `mysql`, inside the `mysql` container and log
    in to `review-db` using the user created at startup, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `mysql` CLI tool will prompt you for a password; you can find it in the
    `docker-compose.yml` file. Look for the value of the environment variable `MYSQL_PASSWORD`.
  prefs: []
  type: TYPE_NORMAL
- en: Enter `exit` to leave the `mysql` CLI.
  prefs: []
  type: TYPE_NORMAL
- en: We will see the usage of these tools in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer graphical database tools, you can run them locally as well, since
    both the MongoDB and the MySQL containers expose their standard ports on localhost.
  prefs: []
  type: TYPE_NORMAL
- en: Manual tests of the new APIs and the persistence layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we have everything in place to test the microservices together. We will
    build new Docker images and start up the system landscape using Docker Compose
    based on the Docker images. Next, we will use the Swagger UI viewer to run some
    manual tests. Finally, we will use the database CLI tools to see what data was
    inserted into the databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and start the system landscape with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Open Swagger UI in a web browser, `http://localhost:8080/openapi/swagger-ui.html`,
    and perform the following steps on the web page:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **ProductComposite** service and the **POST** method to expand
    them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Try it out** button and go down to the body field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the default value, `0`, of the `productId` field with `123456`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down to the **Execute** button and click on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the returned response code is **200**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is a sample screenshot after hitting the **Execute** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_06_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Testing the server response'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the log output from the `docker-compose up` command, we should be able to
    see output like the following (abbreviated for increased readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19825_06_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: Log output from docker-compose up'
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the database CLI tools to see the actual content in the different
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look up the content in the `product` service, that is, the `products` collection
    in MongoDB, with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect a response like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_06_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: Looking up products'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look up the content in the `recommendation` service, that is, the `recommendations`
    collection in MongoDB, with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect a response like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_06_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: Looking up recommendations'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look up the content in the `review` service, that is, the `reviews` table in
    MySQL, with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mysql` CLI tool will prompt you for a password; you can find it in the
    `docker-compose.yml` file. Look for the value of the environment variable `MYSQL_PASSWORD`.
    Expect a response like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19825_06_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Looking up reviews'
  prefs: []
  type: TYPE_NORMAL
- en: Bring down the system landscape by interrupting the `docker-compose up` command
    with *Ctrl* + *C*, followed by the command `docker-compose down`. After this,
    let us see how to update the automated tests in a microservice landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the automated tests of the microservice landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The automated tests of the microservice landscape, `test-em-all.bash`, need
    to be updated so that they ensure that the database of each microservice has a
    known state before it runs the tests.
  prefs: []
  type: TYPE_NORMAL
- en: The script is extended with a setup function, `setupTestdata()`, which uses
    the composite create and delete APIs to set up test data used by the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setupTestdata` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'It uses a helper function, `recreateComposite()`, to perform the actual requests
    to the delete and create APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setupTestdata` function is called directly after the `waitForService`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The main purpose of the `waitForService` function is to verify that all microservices
    are up and running. In the previous chapter, the get API on the composite product
    service was used. In this chapter, the delete API is used instead. When using
    the get API, only the `product` core microservice is called if the entity is not
    found; the `recommendation` and `review` services will not be called to verify
    that they are up and running. The call to the delete API will also ensure that
    the *Not Found* test on `productId 13` will succeed. In the next chapter, we will
    see how we can define specific APIs for checking the health state of a microservice
    landscape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the updated test script with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution should end by writing a log message like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_06_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: Log message at the end of test execution'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the updates on the automated tests of the microservice landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how we can use Spring Data to add a persistence layer
    to the core microservices. We used the core concepts of Spring Data, repositories,
    and entities to store data in both MongoDB and MySQL. The programming model is
    similar for a NoSQL database such as MongoDB and a SQL database such as MySQL,
    even though it’s not fully portable. We also saw how Spring Boot’s annotations,
    `@DataMongoTest` and `@DataJpaTest`, can be used to conveniently set up tests
    targeted for persistence; this is where a database is started automatically before
    the test runs, but no other infrastructure that the microservice will need at
    runtime, for example, a web server such as Netty, is started up. To handle the
    startup and teardown of databases, we have used Testcontainers, which runs the
    databases in Docker containers. This results in persistence tests that are easy
    to set up and that start with minimum overhead.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen how the persistence layer can be used by the service layer
    and how we can add APIs for creating and deleting entities, both core and composite.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how convenient it is to start up databases such as MongoDB
    and MySQL at runtime using Docker Compose and how to use the new create and delete
    APIs to set up test data before running automated tests of the microservice-based
    system landscape.
  prefs: []
  type: TYPE_NORMAL
- en: However, one major concern was identified in this chapter. Updating (creating
    or deleting) a composite entity—an entity whose parts are stored in a number of
    microservices—using synchronous APIs can lead to inconsistencies, if not all involved
    microservices are updated successfully. This is, in general, not acceptable. This
    leads us into the next chapter, where we will look into why and how to build reactive
    microservices, that is, microservices that are scalable and robust.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Data, a common programming model based on entities and repositories,
    can be used for different types of database engines. From the source code examples
    in this chapter, what are the most important differences in the persistence code
    for MySQL and MongoDB?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is required to implement optimistic locking using Spring Data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is MapStruct used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does it mean if an operation is idempotent and why is that useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we access the data that is stored in the MySQL and MongoDB databases
    without using the API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
