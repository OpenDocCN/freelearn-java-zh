<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Aspect-Oriented Programming and Interceptors</h1>
                
            
            <article>
                
<p class="mce-root1">So far, we have learned about the <span class="calibre11">concept of</span><span class="calibre11"> </span><span class="calibre11">dependency injection and its implementation in popular frameworks, such as Spring and Google Guice. We also learned how to control the object creation process by scoping beans based on business requirements. In this chapter, we will learn another way of implementing separation of concerns: <strong class="calibre4">aspect-oriented programming</strong> (<strong class="calibre4">AOP</strong>).</span></p>
<p class="calibre2">AOP solves a different portion of the design problem by isolating repeated code from the application and plugging it in dynamically. AOP, along with <strong class="calibre4">Inversion of Control</strong> (<strong class="calibre4">IoC</strong>), brings modularity to the application. AOP helps in organizing your application in layer fashion, which would be impossible in the traditional object-oriented approach.</p>
<p class="calibre2">AOP permits you to intercept the flow of business code and straightforwardly inject a set of functionalities, without touching or altering the original code. This makes your application loosely coupled from those common functionalities. Before we dive into this concept, let's first understand the scenario, what the problem is, and how we can use AOP as an effective solution.</p>
<p class="calibre2">In this chapter, we will discover and discuss the following interesting topics:</p>
<ul class="calibre9">
<li class="calibre10">What AOP is, and what problems you can solve with AOP</li>
<li class="calibre10">How to achieve AOP in Spring Framework</li>
<li class="calibre10">Choosing AOP frameworks and a style of configuration</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">AOP introduction</h1>
                
            
            <article>
                
<p class="calibre2">While writing any software application, the best practice is to divide your code into multiple independent modules based on business use cases. For example, you write an <strong class="calibre4">Employee Service</strong> class for all employee-related functions, an <strong class="calibre4">HRService</strong> class for all HR-related functions, and so on and so forth.</p>
<p class="calibre2">In general, the whole application consists of a set of independent classes <span class="calibre11">that span multiple verticals and doesn’t share the same class hierarchy. This diagram depicts this scenario:</span> </p>
<div class="mce-root"><img src="../images/00043.jpeg" class="calibre41"/></div>
<p class="calibre2">Irrespective of the independent nature of each vertical, there are a few common items you need to implement across all of them, such as <strong class="calibre4">transaction management</strong>, <strong class="calibre4">session management</strong>, <strong class="calibre4">audit logging</strong>, <strong class="calibre4">security</strong>, <strong class="calibre4">caching</strong>, or any such custom processing mechanism based on rules.</p>
<p class="calibre2">If you wish to implement these common services across verticals with a traditional approach, you need to put them into each of the methods in these classes manually. Taking an example of a logging mechanism, for this, you would need to write a l<span class="calibre11">ittle bit of code at the beginning and end of every method.</span></p>
<p class="calibre2">This leads to code duplication, as the same logic needs to be placed several times. This leads to a maintenance nightmare in the later part of the application development process when any changes are introduced. Let's understand how.</p>
<p class="calibre2">Suppose, as per your business requirements, you add audit logs after each update and delete method. You put the method name and its time in the log. Now, let's say your business needs to place the name of currently logged-in users in the log. In this case, you need to update the logging details <span class="calibre11">manually </span>in several methods.</p>
<p class="calibre2">This is just one example. You will end up changing the code for each of the common services, spread across multiple verticals. The effective solution is to keep them isolated from verticals. Implement them in one place and plug them into other core business classes as and when required based on certain rules or criteria.</p>
<p class="calibre2"><span class="calibre11">In essence, the core part of the business logic does not have to know that something that is common across multiple classes has been included, removed, or changed, and can keep working as before. </span>Separating common functionalities (cross-cutting concerns in the AOP paradigm) and turning them on and off without touching or modifying the core business logic, will eventually increase modularity and bring great flexibility in terms of maintenance <span class="calibre11">in any application</span>. <span class="calibre11">AOP aims to provide a way to achieve this solution. </span><span class="calibre11">AOP is </span><span class="calibre11">mainly </span><span class="calibre11">used to provide declarative services.</span></p>
<p class="calibre2">To understand AOP concepts, it's crucial to understand the terminology used in the AOP paradigm:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Concern:</strong> This is a behavior or functionality we want to achieve in our application. For example, HR management and employee management are two functionalities, and are thus considered as concerns in AOP.</li>
<li class="calibre10"><strong class="calibre1">Aspect:</strong> In very simple terms, this is a common behavior that spans multiple classes in the same or different hierarchy. In other words, the common concept that cuts across multiple concerns is called the aspect. In our example, the logging mechanism is called the aspect in AOP terminology. </li>
<li class="calibre10"><strong class="calibre1">Join-point:</strong> This is a point during the execution flow of the application where you need to apply <strong class="calibre1">Advice</strong>. For example, a method invocation or a place where you need to handle an exception could be join-point.</li>
<li class="calibre10"><strong class="calibre1">Advice:</strong> This is an action performed on a specific join-point by the AOP framework. Conceptually, it's a common functionality implementation at that join-point. The process of applying <strong class="calibre1">Advice</strong> can be controlled by specifying various types, such as <kbd class="calibre12">around</kbd>, <kbd class="calibre12">before</kbd>, <kbd class="calibre12">after</kbd>, <kbd class="calibre12">throws</kbd>, and so on. </li>
<li class="calibre10"><strong class="calibre1">Point-cut:</strong> This is an expression that describes a pattern of applicable join-points. In other words, the AOP framework will apply the <strong class="calibre1">Advice</strong> (common functionality) on join-points (methods) that are described by a point-cut (for example, <kbd class="calibre12">set*</kbd> means all methods start with the word <em class="calibre28">set</em>). We can say a point-cut is a filter criterion to choose join-points in the system.</li>
</ul>
<p class="calibre60">In most cases, developers get confused between join-point and point-cut. Let's take a real-life example to understand the difference. Suppose you want to buy cooking oil and you go to the department store. You reach the grocery section and find various edible oils made from difference sources, such as sunflower, groundnut, cotton seed, rice brand, corn, and so on.</p>
<p class="calibre60">Your requirement is to choose light oil (in terms of low<span class="calibre11"> </span>cholesterol) for your daily needs, and hence you choose either sunflower oil or rice brand oil. In this case, all the available edible oils are the join-points, and your choice of sunflower/rice brand oil, based on your needs, is considered a point-cut. In short, all available options are considered as join-points, while the one you choose, based on your needs, is called a point-cut.</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Target object:</strong> That is the object in which the common functionalities are being implemented. In other words, this is the object on which the <strong class="calibre1">Advice</strong> is applied by a set of aspects.</li>
<li class="calibre10"><strong class="calibre1">AOP-Proxy:</strong> Proxy is a design pattern used to encapsulate the object and control access to it. The AOP framework creates a proxy/dynamic object to implement various aspects (in the form of <strong class="calibre1">Advice</strong>). In short, AOP creates a proxy object that looks like the object on which the proxy was created, but with a few additional features. In <strong class="calibre1">Spring Framework</strong>, AOP-proxy is supplied through the JDK or the CGLIB library.</li>
<li class="calibre10">
<p class="calibre2"><strong class="calibre4">Weaving: </strong>As we have seen, the main<span class="calibre11"> idea behind </span>AOP<span class="calibre11"> </span><span class="calibre11">is to plug common behaviors (or aspects) into business classes without modifying them. The process of linking such aspects with other classes to apply <strong class="calibre4">Advice</strong> is called weaving.</span></p>
</li>
</ul>
<p class="calibre60">Weaving can be done at <span class="calibre11">compile or run time. <strong class="calibre4">Spring AOP</strong> supports load-time weaving, while the <strong class="calibre4">AspectJ</strong> framework supports both compile-time and load-time weaving.</span></p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Compile-time weaving</strong>:<strong class="calibre1"> </strong>In this type of weaving, the process of linking aspects is performed at compile time. The AOP framework will apply the aspects to your Java source file and create a binary class file, which is woven with those aspects. AspectJ uses a special compiler to achieve compile-time weaving.</li>
<li class="calibre10"><strong class="calibre1">Post-compile-time (or binary) weaving</strong>:<strong class="calibre1"> </strong>This is similar to compile-time weaving. The process of linking aspects is performed on precompiled classes, or JAR files. The aspects that are woven may be in either source or binary form. This, again, can be done through a special compiler. Both compile-time and post-compile-time weaving can be achieved through AspectJ.</li>
<li class="calibre10"><strong class="calibre1">Runtime weaving</strong>:<strong class="calibre1"> </strong>Compile-time and post-compile-time weaving happens before the actual class file is loaded into memory, whereas runtime (or load-time) weaving happens once the target class is loaded into JVM by the class loader. Runtime weavers are supported by both the Spring AOP and AspectJ frameworks.</li>
</ul>
<p class="calibre60">The process of weaving can be expressed through the following diagram:</p>
<div class="mce-root"><img src="../images/00044.gif" class="calibre61"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Spring AOP</h1>
                
            
            <article>
                
<p class="calibre2"><strong class="calibre4">Spring AOP</strong> is purely developed in Java. It doesn't require us to alter or control the class loader hierarchy. Because of this adaptability, you can utilize Spring AOP for a servlet container or application server. At present, Spring AOP only supports applying Advice at method level. In other words, method-level join-points are supported in Spring AOP</p>
<p class="calibre2">Spring supports AOP in conjunction with its IoC capabilities. You can define aspects with normal bean definition, while weaving them with AOP specific configuration. In other words, IoC is used to define aspects, and AOP is used to weave them to other objects. Spring uses both of them to solve common problems. This is how Spring AOP differs from other AOP frameworks.</p>
<p class="calibre2">Spring AOP is a proxy-based framework, and supports runtime weaving of objects. It can be used through either XML-based or AspectJ annotation-based configuration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">XML(schema)-based Spring AOP</h1>
                
            
            <article>
                
<p class="calibre2">Just like a class is the unit of the object-oriented programming paradigm, aspect is the unit of AOP. Modularity is achieved through aspect in an aspect-oriented programming model. If you wish to choose XML-based configuration for AOP, Spring supports defining aspects using <kbd class="calibre12"><span><span>aop</span></span></kbd> namespace tags. You need to define <kbd class="calibre12">aop</kbd> namespace tags as follows:</p>
<pre class="calibre17">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="title-page-name"/>&lt;beans <br class="title-page-name"/>       <br class="title-page-name"/>       xsi:schemaLocation="http://www.springframework.org/schema/beans <br class="title-page-name"/>       http://www.springframework.org/schema/beans/spring-beans.xsd<br class="title-page-name"/>       http://www.springframework.org/schema/aop <br class="title-page-name"/>       http://www.springframework.org/schema/aop/spring-aop.xsd"<br class="title-page-name"/>       &gt;</pre>
<p class="calibre2">To differentiate AOP-specific configuration, you need to specify all AOP-related artifacts such as aspects, point-cut, Advice, and so on, within an <kbd class="calibre12">&lt;aop:config&gt;</kbd> element inside your Spring context (XML) file. Multiple <kbd class="calibre12">&lt;aop:config&gt;</kbd> elements are allowed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Declaring aspect</h1>
                
            
            <article>
                
<p class="calibre2">The first thing in Spring AOP is to decide on and define the aspects. In XML-based configuration, an aspect is conceptualized as a simple Java class that you need to declare as a bean definition in a Spring application context (XML) file. The <kbd class="calibre12">&lt;aop:aspect&gt;</kbd> element is used to define an aspect:</p>
<pre class="calibre17">    &lt;aop:config&gt;<br class="title-page-name"/>    &lt;aop:aspect id="myLoggin" ref="loggingAspect"&gt;&lt;/aop:aspect&gt; <br class="title-page-name"/>    &lt;/aop:config&gt;<br class="title-page-name"/>    &lt;bean id="loggingAspect"<br class="title-page-name"/>    class="com.packet.spring.aop.aspects.LogginAspect"&gt;<br class="title-page-name"/>    &lt;/bean&gt;</pre>
<p class="calibre2"><span class="calibre11">Since an aspect is a form of Java class, it can be defined as a normal Spring bean, and then can be configured with the <kbd class="calibre12">ref</kbd> attribute of the <kbd class="calibre12">&lt;aop:aspect&gt;</kbd> element. The state and behavior is associated with fields and methods of the aspect class, while the point-cut and advice information is configured in the XML. In the previous example, we define logging as an aspect.</span></p>
<p class="calibre2"><span class="calibre11">After defining an aspect, the next step is to define the join-point through the point-cut. Spring AOP supports method-level join-points only. </span></p>
<div class="packt_infobox">In XML schema based-AOP, Spring enables an auto-proxy mechanism with the <kbd class="calibre37">&lt;aop:config&gt;</kbd> declaration. You do not need to define anything for auto-proxy explicitly; however, if you are enabling auto-proxy with some other mechanism (such as AutoProxyCreator), you should choose either of these options to avoid any runtime issues.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Declaring a point-cut</h1>
                
            
            <article>
                
<p class="calibre2">Just to recall, a join-point is a place where we want to apply <strong class="calibre4">Advice</strong>, and a point-cut represents a pattern of matching join-points. A point-cut must be defined within the <kbd class="calibre12">&lt;aop:config&gt;</kbd> element. A point-cut can be declared within the <kbd class="calibre12">&lt;aop:aspect&gt;</kbd> element or outside of it. If it's defined outside of <kbd class="calibre12">&lt;aop:aspect&gt;</kbd>, it can be shared between multiple aspects and advisors.</p>
<p class="calibre2"><span class="calibre11">A point-cut allows Advice to be applied to the target object independently of the object-oriented hierarchy. Transaction management through AOP Advice in Spring is a real example of where transaction Advice is applied to specific methods (<kbd class="calibre12">add</kbd>/<kbd class="calibre12">update</kbd>/<kbd class="calibre12">delete</kbd> methods) that span multiple object hierarchies. This snippet is one of the possible ways of writing a point-cut:</span></p>
<pre class="calibre17">    &lt;aop:pointcut id="employeeServiceMethods"<br class="title-page-name"/>    expression="execution(* com.packet.spring.aop.service.*.*(..))" /&gt;</pre>
<p class="calibre2">A point-cut is uniquely identified by its <kbd class="calibre12">id</kbd> attribute. The <kbd class="calibre12">expression</kbd> attribute represents the pattern (or filter) of matching join-points. The value of the <kbd class="calibre12">expression</kbd> attribute consists of two components:</p>
<ul class="calibre9">
<li class="calibre10">Point-cut designator</li>
<li class="calibre10">Pattern</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Point-cut designator</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">A <strong class="calibre4">point-cut designator</strong> (<strong class="calibre4">PCD</strong>) is a keyword (initial word) that tells Spring AOP how to match the point-cut. Spring AOP supports various point-cut designators:</span></p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1"><kbd class="calibre12">execution</kbd>:</strong> This is used to match method execution (join-points). This is a primary designator, and is used most of the time while working with Spring AOP.</li>
<li class="calibre10"><strong class="calibre1"><kbd class="calibre12">within</kbd>:</strong> This designator has the limitation of matching of join-points within certain types only. It's not as flexible as execution. For example, it's not allowed to specify return types or method parameter mapping. If the patterns with <kbd class="calibre12">within</kbd> are up to the Java package, it matches all methods of all classes within that package. If the pattern is pointing to a specific class, then this designator will cover all the methods within that class.</li>
<li class="calibre10"><strong class="calibre1"><kbd class="calibre12">this</kbd>: </strong>This restricts the matching of join-points to the beans that are references of a given type in an expression. In other words, the <kbd class="calibre12">this</kbd> designator is one step narrower than the <kbd class="calibre12">within</kbd> designator, and expects you to specify a specific class type as a pattern. It will not be allowed to define any wildcard patterns.</li>
<li class="calibre10"><strong class="calibre1"><kbd class="calibre12">target</kbd>:</strong> This <span><span>limits the matching of join-points, where the target object is an instance of the given type in an expression. The target designator seems similar to the <kbd class="calibre12">this</kbd> designator, but there is a difference in their use. Let's understand this.</span></span></li>
</ul>
<p class="calibre60">As we have seen, Spring AOP creates <span class="calibre11">p</span><span class="calibre11">roxy</span><span class="calibre11"> objects through either the <strong class="calibre4">JDK</strong> or the <strong class="calibre4">CGLIB</strong> library. Spring AOP uses a JDK-based proxy if the target object implements an interface; otherwise, it selects CGLIB. </span>You should use the <kbd class="calibre12">this</kbd> designator when CGLIB provides the proxy (that is, your target object doesn't implement an interface), and the target designator when the JDK provides the proxy (the <kbd class="calibre12">target</kbd> object implements an interface).</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1"><kbd class="calibre12">args</kbd>:</strong> This designator is generally used for matching method arguments. It allows us to pass wildcards for matching packages, Java classes, return types, or method names.</li>
<li class="calibre10"><strong class="calibre1"><kbd class="calibre12">@target</kbd>:</strong> This PCD filters the join-points where the class of the object has an annotation of a given type. Although the names are equal, the <kbd class="calibre12">@target</kbd> designator is not similar to the <kbd class="calibre12">target</kbd> designator. They are different in terms of matching the join-points as follows:
<ul class="calibre62">
<li class="calibre10">The <kbd class="calibre12">target</kbd> designator: Matches the <span>target object if it is an instance of the given type in an expression</span></li>
<li class="calibre10">The <kbd class="calibre12">@target</kbd> designator: Matches the target object, if the class of target object has an annotation of given type</li>
</ul>
</li>
<li class="calibre10"><strong class="calibre1"><kbd class="calibre12">@within</kbd>:</strong> This designator restricts matching join-points to within the type that has a given annotation. It allows us to use wildcards to match point-cuts.</li>
<li class="calibre10"><strong class="calibre1"><kbd class="calibre12">@annotation</kbd>:</strong> This PCD is used to match a point-cut of a type that has a given annotation. It's useful to construct point-cuts on classes that have custom annotation.</li>
<li class="calibre10"><strong class="calibre1"><kbd class="calibre12">@args</kbd>:</strong> This designator restricts matching a join-point to where actual runtime objects passed as method arguments have an annotation of a given type. This is useful to narrow down the join-point selection to specific methods from the available overloaded methods in the target class.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Patterns</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">A pattern is a filter criteria to match possible join-points. It tells Spring AOP what to match. <strong class="calibre4">Patterns</strong> are generally written within brackets, just after the PCD. It's a kind of regular expression in AOP to select the desired join-point.</span></p>
<p class="calibre2"><span class="calibre11">Spring AOP supports only method-level join-points, and patterns are used to choose specific methods of the target object. A pattern consists of the following expressions in the same order:</span></p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Access modifier</strong>: For Spring AOP, the only possible value is <kbd class="calibre12">public</kbd>. T<span>his expression is optional.</span></li>
<li class="calibre10"><strong class="calibre1">Return type</strong>: This is the fully qualified name of the return type. Putting <kbd class="calibre12">*</kbd> for this expression means it allows any return type.</li>
<li class="calibre10"><strong class="calibre1">Java package</strong>: Java package name can be used.  </li>
<li class="calibre10"><strong class="calibre1">Java class name</strong>: Java class name can be used. Putting <kbd class="calibre12">*</kbd> for this expression means it applies to all Java classes under a given package.</li>
<li class="calibre10"><strong class="calibre1">Method name</strong>: Method name can be given. Putting <kbd class="calibre12">*</kbd> in this expression will include all methods of a given class.</li>
<li class="calibre10"><strong class="calibre1">Method parameters</strong>: Type of parameter can be given. Putting <kbd class="calibre12">..</kbd> (two dots) means any number of parameters for a given method will be considered.</li>
<li class="calibre10"><strong class="calibre1">Exception details</strong>: Throws a declaration.</li>
</ul>
<p class="calibre2">The format of a pattern is exactly similar to method signature. Let's understand the meaning of the previous expressions by seeing a few examples.</p>
<p class="calibre2"><strong class="calibre4">Example 1</strong> :<strong class="calibre4"> </strong>The following expression will match all public methods of the <kbd class="calibre12">EmployeeService</kbd> class with the following conditions:</p>
<ul class="calibre9">
<li class="calibre10">Method with any return value, including void</li>
<li class="calibre10">Method with any parameters, including empty parameter method:</li>
</ul>
<div class="mce-root"><img src="../images/00045.jpeg" class="calibre63"/></div>
<p class="calibre2"><strong class="calibre4">Example 2</strong>:<strong class="calibre4"> </strong><span class="calibre11">The following expression will match all public methods with the following conditions:</span></p>
<ul class="calibre9">
<li class="calibre10">Method with any return value, including void</li>
<li class="calibre10">Method with any parameters, including empty parameter method</li>
<li class="calibre10">Method of all classes that fall directly under the <kbd class="calibre12">com.packet.spring.aop.service</kbd> Java package:</li>
</ul>
<p class="mce-root2"><img src="../images/00046.jpeg" class="calibre64"/></p>
<p class="calibre2"><strong class="calibre4">Example 3</strong>: The f<span class="calibre11">ollowing expression will match all public methods with the following conditions:</span></p>
<ul class="calibre9">
<li class="calibre10">Method with any return value, including void</li>
<li class="calibre10">Method with any parameters, including empty parameter method</li>
<li class="calibre10">Method of all classes fall under the <kbd class="calibre12">com.packet.spring.aop.service</kbd> Java package <span>and its subpackage:</span></li>
</ul>
<p class="mce-root2"><img src="../images/00047.jpeg" class="calibre65"/></p>
<p class="calibre2"><strong class="calibre4">Example 4</strong>:<strong class="calibre4"> </strong><span class="calibre11">The following expression will match all public methods of the </span><kbd class="calibre12">EmployeeService</kbd> <span class="calibre11">class with the following conditions:</span></p>
<ul class="calibre9">
<li class="calibre10">Method with a return type of String only</li>
<li class="calibre10">Method with any parameters, including an empty parameter method:</li>
</ul>
<div class="mce-root"><img src="../images/00048.jpeg" class="calibre66"/></div>
<p class="calibre2"><strong class="calibre4">Example 5</strong>:<strong class="calibre4"> </strong><span class="calibre11">The following expression will match all public methods of the</span> <kbd class="calibre12">EmployeeService</kbd><span class="calibre11"> class with the following conditions:</span></p>
<ul class="calibre9">
<li class="calibre10">Method with any return value, including void</li>
<li class="calibre10">Method with two parameters, first a <kbd class="calibre12">String</kbd> and second a <kbd class="calibre12">Long</kbd>, in the same order of method parameter:</li>
</ul>
<div class="mce-root"><img src="../images/00049.jpeg" class="calibre67"/></div>
<p class="calibre2"><strong class="calibre4">Example 6</strong>:<strong class="calibre4"> </strong><span class="calibre11">The following expression will match all public methods of the </span><kbd class="calibre12">EmployeeService</kbd><span class="calibre11"> class with the following conditions:</span></p>
<ul class="calibre9">
<li class="calibre10">Method with any return value, including void</li>
<li class="calibre10">Method with one or more parameters, where the first parameter is <kbd class="calibre12">String</kbd> only:</li>
</ul>
<div class="mce-root"><img src="../images/00050.jpeg" class="calibre68"/></div>
<p class="calibre2"><strong class="calibre4">Example 7</strong>:<strong class="calibre4"> </strong><span class="calibre11">The following expression will match specific public methods with the following conditions:</span></p>
<ul class="calibre9">
<li class="calibre10">Method name starts with the <kbd class="calibre12">find</kbd> word</li>
<li class="calibre10">Method with any return value, including void</li>
<li class="calibre10">Method with just one parameter of type <kbd class="calibre12">String</kbd></li>
<li class="calibre10">Methods of all classes fall under the<span> </span><kbd class="calibre12">com.packet.spring.aop.service</kbd><span> J</span>ava package:</li>
</ul>
<div class="mce-root"><img src="../images/00051.jpeg" class="calibre69"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Declaring Advice (interceptor)</h1>
                
            
            <article>
                
<p class="calibre2">The next step is to define <strong class="calibre4">Advice</strong>. This is an action performed on a join-point. Advice is also referred as an <em class="calibre13">interceptor</em>. Spring AOP supports various types of Advice, as shown here:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Before Advice:</strong> This type of Advice is executed just before the execution starts at the join-point. In the case of an exception, Spring will stop further execution of this Advice.</li>
<li class="calibre10"><strong class="calibre1">After Advice: </strong>As its name suggests, this type of Advice is executed after completion of join-point execution (either a normal exit, or in the case of an exception, from the join-point).</li>
<li class="calibre10"><strong class="calibre1">Around Advice: </strong>This type of Advice is executed around the join-point (before and/or after the advised method). Because of this, you have the control to execute the join-point and return the original method value, or bypass the flow and return a custom value. In general, a<span>round Advice is used to</span> <span>execute some</span><span> </span><span>logic before and/or after a method's main logic. </span>Due to this, it's the most powerful type of Advice.</li>
<li class="calibre10"><strong class="calibre1">After returning Advice: </strong>This is similar to after Advice. The difference is that it's being executed on a normal exit from a join-point.</li>
<li class="calibre10"><strong class="calibre1">After throwing Advice: </strong>This is also similar to after Advice, but is executed when an exception occurred during execution of the Advice's method.</li>
</ul>
<div class="packt_infobox">In XML-based Spring AOP, <span class="calibre18">you need to be careful of the order of AOP elements w</span>hile defining them within <kbd class="calibre37">&lt;aop:config&gt;</kbd>. For example, <kbd class="calibre37">&lt;aop:pointcut&gt;</kbd> must be defined before or within the <kbd class="calibre37">&lt;aop:aspect&gt;</kbd> element or else Spring will show an error. Similarly, AOP Advice must be defined within the <kbd class="calibre37">&lt;aop:aspect&gt;</kbd> element.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing before advice</h1>
                
            
            <article>
                
<p class="calibre2">So far we have seen how to declare aspects, point-cuts, and Advice. Let's put them together and understand how they work together. Suppose we want to put a logger at the beginning of all methods of classes that fall under the <kbd class="calibre12">com.packet.spring.aop.service</kbd> package. The configuration would be as follows:</p>
<pre class="calibre17">&lt;aop:config&gt;<br class="title-page-name"/>      &lt;aop:pointcut id="employeeServiceMethods"<br class="title-page-name"/>        expression="execution(* com.packet.spring.aop.service.*.*(..))" /&gt;<br class="title-page-name"/>        <br class="title-page-name"/>       &lt;aop:aspect id="myLoggin" ref="loggingAspect"&gt;<br class="title-page-name"/>          &lt;aop:before pointcut-ref="employeeServiceMethods" <br class="title-page-name"/>              method="printStartLog"/&gt;<br class="title-page-name"/>       &lt;/aop:aspect&gt;<br class="title-page-name"/>&lt;/aop:config&gt;<br class="title-page-name"/>    <br class="title-page-name"/>&lt;bean id="loggingAspect" class="com.packet.spring.aop.aspects.LoggingAspect"&gt;<br class="title-page-name"/>&lt;/bean&gt;<br class="title-page-name"/>    <br class="title-page-name"/>&lt;bean id="employeeService" class="com.packet.spring.aop.service.EmployeeService"&gt;<br class="title-page-name"/>&lt;/bean&gt;</pre>
<p class="calibre2">We have defined a point-cut that matches all public methods of all classes under the <kbd class="calibre12">com.packet.spring.aop.service</kbd> package, with any parameter and any return value. Next, we have defined the logging aspect bean, and given its reference to <kbd class="calibre12">&lt;aop:aspect&gt;</kbd> with the <kbd class="calibre12">ref</kbd> attribute.</p>
<p class="calibre2">Inside the aspect, we have defined before advice (<kbd class="calibre12">&lt;aop:before&gt;</kbd>) and gave point-cut reference there. The  <kbd class="calibre12">printStartLog</kbd> <span class="calibre11">method </span><span class="calibre11">is defined in the aspect bean as follows:</span></p>
<pre class="calibre17">package com.packt.spring.aop.aspects;<br class="title-page-name"/><br class="title-page-name"/>import org.aspectj.lang.JoinPoint;<br class="title-page-name"/>public class LoggingAspect {<br class="title-page-name"/><br class="title-page-name"/>public void printStartLog(JoinPoint joinPoint) {<br class="title-page-name"/>    System.out.println(" ****** Starting Method '"+joinPoint.getSignature().getName()+"' of "+joinPoint.getTarget().getClass());<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">In this snippet, <kbd class="calibre12">printStartLog</kbd> is the advice method. It takes a parameter of type <kbd class="calibre12">JoinPoint</kbd>, which represents the join-points that we associated with the aspect. This class provides metadata about the target object, such as its method (on which this advice is woven), class, and other attributes.</p>
<p class="calibre2">It's not required to pass the <kbd class="calibre12">JoinPoint</kbd> parameter in the <kbd class="calibre12">printStartLog</kbd> method. It will work even if you don't pass the <kbd class="calibre12">JoinPoint</kbd> parameter. But, it gives you metadata about the target object. In this sense, it's useful. For example, in the previous case, we display the woven method's name and its class name.</p>
<p class="calibre2">The target class <kbd class="calibre12">EmployeeService</kbd> is defined in the <span class="calibre11"><kbd class="calibre12">com.packet.spring.aop.service</kbd> package</span> as follows:</p>
<pre class="calibre17">package com.packt.spring.aop.service;<br class="title-page-name"/><br class="title-page-name"/>public class EmployeeService {<br class="title-page-name"/><br class="title-page-name"/> public void generateSalarySlip() {<br class="title-page-name"/>    System.out.println("Generating payslip");<br class="title-page-name"/>  }<br class="title-page-name"/> public String showTotalEmployee(String test) {<br class="title-page-name"/>    System.out.println(" The string is --&gt;"+test);<br class="title-page-name"/>    return test;<br class="title-page-name"/>  }<br class="title-page-name"/> public void findEmployee(String employeeId) {<br class="title-page-name"/>    System.out.println(" finding employee based on employeeId ");<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">When we get the <kbd class="calibre12">EmployeeService</kbd> <span class="calibre11">object </span><span class="calibre11">from Spring's application context file and call these methods, AOP will intercept all these methods and insert the log (which we kept in the </span><kbd class="calibre12">printStartLog</kbd><span class="calibre11"> of <kbd class="calibre12">LoggingAspect</kbd>), before execution of each of the methods (because we have used before advice):</span></p>
<pre class="calibre17">package com.packt.spring.aop.aspects.main;<br class="title-page-name"/><br class="title-page-name"/>import org.springframework.context.ApplicationContext;<br class="title-page-name"/>import org.springframework.context.support.ClassPathXmlApplicationContext;<br class="title-page-name"/><br class="title-page-name"/>import com.packet.spring.aop.report.api.IExportPaySlip;<br class="title-page-name"/>import com.packet.spring.aop.service.EmployeeService;<br class="title-page-name"/>import com.packet.spring.aop.service.HRService;<br class="title-page-name"/><br class="title-page-name"/>public class SpringAOPInXMLCheck {<br class="title-page-name"/><br class="title-page-name"/>  public static void main(String[] args) {<br class="title-page-name"/>    ApplicationContext springContext = new ClassPathXmlApplicationContext("application-context.xml");<br class="title-page-name"/>    EmployeeService employeeService = (EmployeeService)springContext.getBean("employeeService");<br class="title-page-name"/>    employeeService.generateSalarySlip();<br class="title-page-name"/>    employeeService.showTotalEmployee("test");<br class="title-page-name"/>    employeeService.findEmployee("abc123");<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2"><br class="calibre5"/>
<span class="calibre11">And you will get output as follows:</span></p>
<pre class="calibre17"><span><br class="title-page-name"/></span><strong class="calibre1">-------------------------------------------</strong><br class="title-page-name"/><strong class="calibre1"> ****** Starting Method 'generateSalarySlip' of class com.packet.spring.aop.service.EmployeeService</strong><br class="title-page-name"/><strong class="calibre1">Generating payslip</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1"> ****** Starting Method 'showTotalEmployee' of class com.packet.spring.aop.service.EmployeeService</strong><br class="title-page-name"/><strong class="calibre1">The string is --&gt;test</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1"> ****** Starting Method 'findEmployee' of class com.packet.spring.aop.service.EmployeeService</strong><br class="title-page-name"/><strong class="calibre1"> finding employee based on employeeId</strong><br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">You can observe how Spring AOP traps each method of the <kbd class="calibre12">EmployeeService</kbd> class and adds the log at the beginning of each method. It prints the <kbd class="calibre12">method</kbd> name and <kbd class="calibre12">class</kbd> name dynamically.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing after advice</h1>
                
            
            <article>
                
<p class="calibre2">Just like before advice, we can also implement other advice types. Let's take an example of after advice and around advice. For after advice, just add one method in the <kbd class="calibre12">LoggingAspect</kbd> class as <span class="calibre11">follows:</span></p>
<pre class="calibre17"> //After advice method.<br class="title-page-name"/>  public void printEndLog(JoinPoint joinPoint) {<br class="title-page-name"/>    System.out.println(" ****** End of Method '"+joinPoint.getSignature().getName());<br class="title-page-name"/>  }</pre>
<p class="calibre2">In after advice, we are just printing the <kbd class="calibre12">method</kbd> name. We also need to update the aspect configuration in the application context file. Just add an after advice entry for our logging aspect, as <span class="calibre11">follows:</span></p>
<pre class="calibre17">&lt;aop:aspect id="myLoggin" ref="loggingAspect"&gt;<br class="title-page-name"/>      &lt;aop:before pointcut-ref="employeeServiceMethods" method="printStartLog"/&gt;<br class="title-page-name"/>      &lt;aop:after pointcut-ref="employeeServiceMethods" method="printEndLog"/&gt;<br class="title-page-name"/>&lt;/aop:aspect&gt;</pre>
<p class="calibre2"><br class="calibre5"/>
You will get the following output:</p>
<pre class="calibre17"> <br class="title-page-name"/><strong class="calibre1">-----------------------------------</strong><br class="title-page-name"/><strong class="calibre1"> ****** Starting Method 'generateSalarySlip' of class com.packet.spring.aop.service.EmployeeService</strong><br class="title-page-name"/><strong class="calibre1">Generating payslip</strong><br class="title-page-name"/><strong class="calibre1"> ****** End of Method 'generateSalarySlip</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1"> ****** Starting Method 'showTotalEmployee' of class com.packet.spring.aop.service.EmployeeService</strong><br class="title-page-name"/><strong class="calibre1"> The string is --&gt;test</strong><br class="title-page-name"/><strong class="calibre1"> ****** End of Method 'showTotalEmployee</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1"> ****** Starting Method 'findEmployee' of class com.packet.spring.aop.service.EmployeeService</strong><br class="title-page-name"/><strong class="calibre1"> finding employee based on employeeId </strong><br class="title-page-name"/><strong class="calibre1"> ****** End of Method 'findEmployee</strong></pre>
<p class="calibre2">This time, you can observe how AOP intercepts each method and implements after advice along with before advice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing around advice</h1>
                
            
            <article>
                
<p class="calibre2">Spring AOP also provides around advice, which is a combination of before and after in one go. If you need to process something before and after, you can simply implement around advice instead of before and after advice separately. To implement around advice, just add one more method in our <kbd class="calibre12">LoggingAspect</kbd> as <span class="calibre11">follows:</span></p>
<pre class="calibre17">//Around advice method.<br class="title-page-name"/>  public void printAroundLog(ProceedingJoinPoint proceedingJointPoint) throws Throwable {<br class="title-page-name"/>    System.out.println("----- Starting of Method "+proceedingJointPoint.getSignature().getName());<br class="title-page-name"/>    proceedingJointPoint.proceed();<br class="title-page-name"/>    System.out.println("----- ending of Method "+proceedingJointPoint.getSignature().getName());<br class="title-page-name"/>  }</pre>
<p class="calibre2">For <em class="calibre13">around</em> advice, Spring AOP supplies the <kbd class="calibre12">ProceedingJoinPoint</kbd> object instead of <kbd class="calibre12">JoinPoint</kbd> object.  <kbd class="calibre12">proceedingJoinPoint.proceed()</kbd> will simply call the method on the <kbd class="calibre12">target</kbd> object, and you can put the before logic just above the <kbd class="calibre12">proceedingJoinPoint.proceed()</kbd> <span class="calibre11">call and after the logic just next to it.</span></p>
<div class="packt_infobox"><span class="calibre18"><kbd class="calibre37">ProceedingJoinPoint</kbd> can be used for around advice only. If you try to use it for before or after advice, you will get an error. For them, you should use join-point only.</span></div>
<p class="calibre2">The last step is to update the configuration to plug around advice for the aspect as <span class="calibre11">follows:</span></p>
<pre class="calibre17">&lt;aop:aspect id="myLoggin" ref="loggingAspect"&gt;<br class="title-page-name"/>      &lt;aop:around pointcut-ref="employeeServiceMethods" method="printAroundLog"/&gt;<br class="title-page-name"/>&lt;/aop:aspect&gt;</pre>
<p class="calibre2"><br class="calibre5"/>
You will get output as follows:</p>
<pre class="calibre17"><br class="title-page-name"/><strong class="calibre1">----------------------------------</strong><br class="title-page-name"/><strong class="calibre1">----- Starting of Method generateSalarySlip</strong><br class="title-page-name"/><strong class="calibre1">Generating payslip</strong><br class="title-page-name"/><strong class="calibre1">----- ending of Method generateSalarySlip</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">----- Starting of Method showTotalEmployee</strong><br class="title-page-name"/><strong class="calibre1"> The string is --&gt;test</strong><br class="title-page-name"/><strong class="calibre1">----- ending of Method showTotalEmployee</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">----- Starting of Method findEmployee</strong><br class="title-page-name"/><strong class="calibre1"> finding employee based on employeeId </strong><br class="title-page-name"/><strong class="calibre1">----- ending of Method findEmployee</strong></pre>
<p class="calibre2"><span class="calibre11">This is how around advice is implemented and</span> does the work of <em class="calibre13">before</em> and <em class="calibre13">after</em> advice altogether.</p>
<div class="packt_tip"><span class="calibre18">Don't use <em class="calibre19">before</em>, <em class="calibre19">after</em>, and <em class="calibre19">around</em> advice all together. If you need to put some additional code at the beginning of the method, use <em class="calibre19">before</em> advice only, instead of <em class="calibre19">around</em>. Although using <em class="calibre19">around</em> advice can achieve what you implemented with <em class="calibre19">before</em> advice alone, it's not a good idea. Use <em class="calibre19">around</em> advice only when you want to add something before and after methods.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing after returning advice</h1>
                
            
            <article>
                
<p class="calibre2">The <strong class="calibre4">after returning</strong> advice works just like after advice. The only difference is that this advice will be executed on matching methods only on normal exit. If an exception occurs, this advice will not be applied.</p>
<p class="calibre2">We will look at a scenario to understand the need for this advice. Suppose you want to send a message (email) to a concerned person when a particular method is <span class="calibre11">executed successfully </span>on the <kbd class="calibre12">target</kbd> class. Since this is a new concern (sending a message on successful execution of the <kbd class="calibre12">target</kbd> method), w<span class="calibre11">e have created a new </span>aspect class as <span class="calibre11">follows:</span></p>
<pre class="calibre17">package com.packt.spring.aop.aspects;<br class="title-page-name"/>import org.aspectj.lang.JoinPoint;<br class="title-page-name"/>public class SendMessage {<br class="title-page-name"/><br class="title-page-name"/>    //Advice method after successful existing of target method.<br class="title-page-name"/>    public void sendMessageOnSuccessExit(JoinPoint joinPoint) {<br class="title-page-name"/>      System.out.println(" ****** Method '"+joinPoint.getSignature().getName()+"' of "+joinPoint.getTarget().getClass()+" is executed successfully...");<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre12">SendMessage</kbd> aspect has one method called <kbd class="calibre12">sendMessageOnSuccessExit</kbd>. We want this method to be called on a normal method exit (without an exception) from the <kbd class="calibre12">target</kbd> class. You can write the logic to send the message (email) in this method. The new aspect will be configured in the application context (XML) file as <span class="calibre11">follows:</span></p>
<pre class="calibre17">&lt;aop:pointcut id="hrServiceMethods"<br class="title-page-name"/>        expression="execution(* com.packet.spring.aop.service.HRService.*(..))" /&gt;<br class="title-page-name"/><br class="title-page-name"/>&lt;aop:aspect id="sendMsg" ref="sendMsgAspect"&gt;<br class="title-page-name"/>      &lt;aop:after-returning pointcut-ref="hrServiceMethods"<br class="title-page-name"/>       method="sendMessageOnSuccessExit"/&gt;<br class="title-page-name"/>&lt;/aop:aspect&gt;</pre>
<p class="calibre2">We have created a new point-cut that will match all the methods of the <kbd class="calibre12">HRService</kbd> class. This class will be as <span class="calibre11">follows:</span></p>
<pre class="calibre17">package com.packt.spring.aop.service;<br class="title-page-name"/><br class="title-page-name"/>public class HRService {<br class="title-page-name"/>  <br class="title-page-name"/>  public void showHolidayList() {<br class="title-page-name"/>    System.out.println("This is holiday list method...");<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public void showMyLeave() throws Exception {<br class="title-page-name"/>    System.out.println("Showing employee leaves...");<br class="title-page-name"/>    throw new Exception();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">When you get an object of <kbd class="calibre12">HRService</kbd> from Spring and call the <kbd class="calibre12">showHolidayList</kbd> method, you will get output as <span class="calibre11">follows:</span></p>
<pre class="calibre17"><strong class="calibre1">This is holiday list method...</strong><br class="title-page-name"/><strong class="calibre1"> ****** Method 'showHolidayList' of class com.packet.spring.aop.service.HRService is executed successfully...</strong></pre>
<p class="calibre2">If the <kbd class="calibre12">target</kbd> method returns a value and you want to modify it with AOP, you can do this  with after returning advice. For this, you need to specify the parameter name in the <kbd class="calibre12">&lt;aop:aspect&gt;</kbd> element as <span class="calibre11">follows:</span></p>
<pre class="calibre17">&lt;aop:aspect id="sendMsg" ref="sendMsgAspect"&gt;<br class="title-page-name"/>      &lt;aop:after-returning pointcut-ref="hrServiceMethods"<br class="title-page-name"/>       returning="retVal"<br class="title-page-name"/>       method="sendMessageOnSuccessExit"/&gt;<br class="title-page-name"/>&lt;/aop:aspect&gt;</pre>
<p class="calibre2">In this code, t<span class="calibre11">he value of the </span><kbd class="calibre12">returning</kbd><span class="calibre11"> attribute says that the </span><kbd class="calibre12">sendMessageOnSuccessExit</kbd> method must declare a parameter called <kbd class="calibre12">retVal</kbd>.  Spring AOP will pass the return value from the method of the <kbd class="calibre12">target</kbd> object to this parameter (<kbd class="calibre12">retVal</kbd>) while applying this advice. Therefore, the type of the return value from the method of the <kbd class="calibre12">target</kbd> object must be compatible with the type of the parameter (<kbd class="calibre12">retVal</kbd>, in our case) in the advice method. Let's update the <kbd class="calibre12">showHoliday</kbd> method of the <kbd class="calibre12">SendMessage</kbd> advice as <span class="calibre11">follows:</span></p>
<pre class="calibre17">  public String showHolidayList() {<br class="title-page-name"/>    System.out.println("This is holiday list method...");<br class="title-page-name"/>    return "holidayList";<br class="title-page-name"/>  }</pre>
<p class="calibre2">The return value type of this method is <kbd class="calibre12">String</kbd>. To update the return value, you need to change the advice method as <span class="calibre11">follows:</span></p>
<pre class="calibre17">//Advice method after successful existing of target method.<br class="title-page-name"/>    public String sendMessageOnSuccessExit(JoinPoint joinPoint,String retVal) {<br class="title-page-name"/>      System.out.println(" ****** Method '"+joinPoint.getSignature().getName()+"' of "+joinPoint.getTarget().getClass()+" is executed successfully...");<br class="title-page-name"/>      System.out.println(" The return value is --&gt;"+retVal);<br class="title-page-name"/>      return "Successfully exited with return val is --&gt;"+retVal;<br class="title-page-name"/>    }</pre>
<p class="calibre2">When you get the <kbd class="calibre12">HRService</kbd> object from Spring and call its <kbd class="calibre12">showHolidayList()</kbd> method, you will get the following updated return value:</p>
<pre class="calibre17"><strong class="calibre1">This is holiday list method...</strong><br class="title-page-name"/><strong class="calibre1"> ****** Method 'showHolidayList' of class com.packet.spring.aop.service.HRService is executed successfully...</strong><br class="title-page-name"/><strong class="calibre1"> The return value is --&gt;holidayList</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing AfterThrowing advice</h1>
                
            
            <article>
                
<p class="calibre2"><em class="calibre13">The AfterThrowing advice</em> will be executed when the matched methods of the target object exit with an exception. This is also useful when you want to take an action on an exception that occurred during execution of the method. Let's create AfterThrowing advice as <span class="calibre11">follows:</span></p>
<pre class="calibre17">    &lt;aop:aspect id="sendMsg" ref="sendMsgAspect"&gt;<br class="title-page-name"/>      &lt;aop:after-returning pointcut-ref="hrServiceMethods"<br class="title-page-name"/>           returning="retVal" method="sendMessageOnSuccessExit"/&gt;<br class="title-page-name"/>      &lt;aop:after-throwing pointcut-ref="hrServiceMethods"<br class="title-page-name"/>           method="sendMessageOnErrorExit"/&gt;<br class="title-page-name"/>    &lt;/aop:aspect&gt;</pre>
<p class="calibre2">The <kbd class="calibre12">sendMessageOnErrorExit</kbd><span class="calibre11"> </span><span class="calibre11">advice method</span><span class="calibre11"> will be defined in the <kbd class="calibre12">sendMessage</kbd> aspect as <span class="calibre11">follows:</span></span></p>
<pre class="calibre17">//Advice method on existing of target method with some error / exception<br class="title-page-name"/>public void sendMessageOnErrorExit(JoinPoint joinPoint) {<br class="title-page-name"/>      System.out.println(" ****** Method '"+joinPoint.getSignature().getName()+"'<br class="title-page-name"/>      of "+joinPoint.getTarget().getClass()+" has some error ...");<br class="title-page-name"/>}</pre>
<p class="calibre2">To make sure this advice is applied, the method in the <kbd class="calibre12">target</kbd> class must exist with an exception. So, let's add one method that throws an exception in the <kbd class="calibre12">target</kbd> class (HRService) as <span class="calibre11">follows:</span></p>
<pre class="calibre17">public void showMyLeave() throws Exception {<br class="title-page-name"/>    System.out.println("Showing employee leaves...");<br class="title-page-name"/>    throw new Exception();<br class="title-page-name"/>  }</pre>
<p class="calibre2">When you take the <span class="calibre11"><kbd class="calibre12">HRService</kbd> </span><span class="calibre11">object from Spring and call the <kbd class="calibre12">showMyLeave</kbd> method, you will get output as follows:</span></p>
<pre class="calibre17"><strong class="calibre1">Showing employee leaves...</strong><br class="title-page-name"/><strong class="calibre1"> ****** Method 'showMyLeave' of class com.packet.spring.aop.service.HRService has some error ...</strong><br class="title-page-name"/><strong class="calibre1">java.lang.Exception</strong><br class="title-page-name"/><strong class="calibre1">  at com.packet.spring.aop.service.HRService.showMyLeave(HRService.java:12)</strong><br class="title-page-name"/><strong class="calibre1">  at com.packet.spring.aop.service.HRService$$FastClassBySpringCGLIB$$a3eb49fe.invoke(&lt;generated&gt;)</strong><br class="title-page-name"/><strong class="calibre1">...</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">@AspectJ annotation-based Spring AOP</h1>
                
            
            <article>
                
<p class="calibre2">Spring allows another way to support AOP through the @AspectJ annotation. It's an alternative to XML-based configuration to define the aspect using regular Java classes with AOP-specific annotation. Spring introduced the @AspectJ style as a part of the AspectJ 5 release. Though with <span class="calibre11">@AspectJ,</span><span class="calibre11"> </span>Spring facilitates same annotation like AspectJ 5, the underlying framework is pure Spring AOP. Due to this arrangement, there is no dependency on AspectJ compiler or weaver.</p>
<p class="calibre2">To use @AspectJ annotation for Spring AOP, you need to enable its support in Spring through configuration and turn auto-proxy on. <strong class="calibre4">Autoproxying</strong> is a mechanism to create a proxy on the object of a Spring bean on which one or more aspects are woven. This allows Spring AOP to intercept the methods and apply advice on the matching point-cut.</p>
<p class="calibre2">As we have seen in <a href="part0066.html#1UU540-255b24dd0eb24162a557b7d0d84b0b16" class="calibre8">Chapter 3</a>, <em class="calibre13">Dependency Injection with Spring</em>, Spring supports configuration of annotation either in the application context (XML) file, or in the Java configuration. Similarly, @AspectJ configuration can be done with either of these options. With Java-based configuration, you can enable Spring AOP annotation with the following code:</p>
<pre class="calibre17">@Configuration<br class="title-page-name"/>@EnableAspectJAutoProxy<br class="title-page-name"/>public class SpringConfig {<br class="title-page-name"/><br class="title-page-name"/>}</pre>
<p class="calibre2">Alternatively, you can choose the application context (XML) file to enable <kbd class="calibre12">@Aspect</kbd> annotation. This can be achieved with the <kbd class="calibre12">&lt;aop:aspectj-autoproxy/&gt;</kbd> element.</p>
<div class="packt_infobox">Spring AOP creates a proxy object to embed customer code; however, when you define any class as an aspect with the @Aspect annotation (or XML configuration), Spring will not create the proxy of that class. In short, the aspect class can't be the target of advice from another aspect. Spring will omit all such aspect classes from auto-proxy.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Declaring aspect</h1>
                
            
            <article>
                
<p class="calibre2">The concept of declaring Aspect with the @AspectJ annotation style is somewhat similar to XML schema-based AOP declaration. Just to recall, a Java class can be an Aspect in the Spring AOP framework. In annotation-based Spring AOP, you can declare any bean as an Aspect with the <kbd class="calibre12">@Aspect</kbd> annotation as <span class="calibre11">follows:</span></p>
<pre class="calibre17">package com.packt.spring.aop.aspects;<br class="title-page-name"/>import org.aspectj.lang.annotation.Aspect;<br class="title-page-name"/>import org.aspectj.lang.annotation.Pointcut;<br class="title-page-name"/><br class="title-page-name"/>@Aspect<br class="title-page-name"/>public class SessionCheck {<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre12">SessionCheck</kbd> class is defined as a regular Spring bean in the application context (XML) file as <span class="calibre11">follows:</span></p>
<pre class="calibre17">&lt;aop:aspectj-autoproxy/&gt;<br class="title-page-name"/>&lt;bean id="sessionCheckAspect" class="com.packt.spring.aop.aspects.SessionCheck"&gt;<br class="title-page-name"/>&lt;/bean&gt;</pre>
<p class="calibre2">Aspect classes may have methods and fields like any other Java class. Spring doesn't impose any limits on defining aspects only with the bean defined in the application context (XML) file. If you have used <span class="calibre11">bean </span><span class="calibre11">autodetection through Java package scanning (with the <kbd class="calibre12">&lt;context:component-scan&gt;</kbd> element), Spring intelligently detects the <kbd class="calibre12">Aspect</kbd> class with the <kbd class="calibre12">@Aspect</kbd> annotation. Aspect classes may contain point-cuts and advice declaration.</span></p>
<div class="packt_infobox">The @Aspect annotation itself is not sufficient for Spring to autodetect the class. You still need to use @Component, or any other stereotype annotation. @Aspect will consider the class (which is autodetected by @Component or an equivalent annotation) as an aspect for Spring AOP.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Declaring point-cut</h1>
                
            
            <article>
                
<p class="calibre2">Point-cuts are regular expressions or patterns to filter join-points where we want to apply advice. Since Spring AOP only supports method-level join-points, you can consider a point-cut as a matching of method execution on <span class="calibre11">Spring beans. In the <kbd class="calibre12">@AspectJ</kbd> annotation style, a point-cut is declared by a method of an Aspect class (declared with the <kbd class="calibre12">@Aspect</kbd> annotation). Such methods are called <strong class="calibre4">point-cut signatures</strong>. The <kbd class="calibre12">@Pointcut</kbd> annotation is used to define such a method as follows:</span></p>
<pre class="calibre17">@Aspect<br class="title-page-name"/>public class SessionCheck {<br class="title-page-name"/>  @Pointcut("execution( * com.packt.spring.aop.service.*.*(..))") // Expression<br class="title-page-name"/>  private void validateSession() {// Point-cut signature<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">In this code, the <kbd class="calibre12">validateSession</kbd> method represents a point-cut signature, while the <kbd class="calibre12">@Pointcut</kbd> annotation is used to describe a point-cut expression. The preceding point-cut is applied to all public methods of all classes under the <kbd class="calibre12">com.packt.spring.aop.service</kbd> package that have any parameters and return values. A method that represents a point-cut signature must have <kbd class="calibre12">void</kbd> as a return type. The preceding annotation-based AOP is equivalent to XML-based AOP configuration, as <span class="calibre11">follows:</span></p>
<pre class="calibre17">&lt;aop:config&gt;<br class="title-page-name"/>    &lt;!-- point cut declaration  --&gt;    <br class="title-page-name"/>    &lt;aop:pointcut id="checkValidUser"<br class="title-page-name"/>        expression="execution(* com.packet.spring.aop.service.*.*(..))" /&gt;<br class="title-page-name"/><br class="title-page-name"/>    &lt;!-- aspect configuration  --&gt;        <br class="title-page-name"/>    &lt;aop:aspect id="mySessionCheck" ref="checkSessionAspect"&gt;<br class="title-page-name"/>        //Advice declaration goes here.<br class="title-page-name"/>    &lt;/aop:aspect&gt;<br class="title-page-name"/><br class="title-page-name"/>    &lt;!-- spring bean represents an aspect  --&gt;        <br class="title-page-name"/>    &lt;bean id="checkSessionAspect" <br class="title-page-name"/>            class="com.packet.spring.aop.aspects.SessionCheck"&gt;<br class="title-page-name"/>    &lt;/bean&gt;<br class="title-page-name"/>&lt;/aop:config&gt;</pre>
<p class="calibre2">Just like XML-based AOP, you can use various point-cut types (point-cut designators) such as <kbd class="calibre12">within</kbd>, <kbd class="calibre12">this</kbd>, <kbd class="calibre12">target</kbd>, <kbd class="calibre12">args</kbd>, <span class="calibre11"><kbd class="calibre12">@annotation</kbd>,</span> <kbd class="calibre12">@target</kbd>, <span class="calibre11"><kbd class="calibre12">@within</kbd>, </span>and <span class="calibre11"><kbd class="calibre12">@args</kbd> </span>with annotation-style AOP. On top of these, Spring supports an additional point-cut type (PCD) called <strong class="calibre4">bean</strong>, which matches the method execution on a particular bean or set of beans. It can be declared as <span class="calibre11">follows:</span></p>
<pre class="calibre17">@Pointcut("bean(batchOperation)")<br class="title-page-name"/>  private void captureBatchProcess() {<br class="title-page-name"/>    <br class="title-page-name"/>  }</pre>
<p class="calibre2">This point-cut is applied to the bean with an ID or name of <kbd class="calibre12">batchOperation</kbd> defined in the application context (XML) file. If a wildcard (only <kbd class="calibre12">*</kbd> is allowed) is used, this point-cut can be applied on multiple beans.</p>
<p class="calibre2">Just like XML-based configuration, annotation-based AOP also supports combining point-cut with <kbd class="calibre12">and</kbd>, <kbd class="calibre12">or</kbd>, and <kbd class="calibre12">negated</kbd> operations. In <kbd class="calibre12">@AspectJ</kbd>-style AOP, you can refer point-cut with its name (signature) while combining with other point-cut, or referring them in Aspect declaration in XML schema. Multiple point-cuts can be combined as <span class="calibre11">follows:</span></p>
<pre class="calibre17">@Pointcut("execution( * com.packt.spring.aop.report.*.*(..))")<br class="title-page-name"/>private void checkSession() {<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>@Pointcut("args(String)")<br class="title-page-name"/>private void printUserName() {<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>@Pointcut("checkSession() &amp;&amp; printUserName()")<br class="title-page-name"/>private void userSession() {<br class="title-page-name"/>}</pre>
<p class="calibre2">The first point-cut, <kbd class="calibre12">checkSession</kbd>, will be applied on all public methods of any class under the<kbd class="calibre12"> com.packt.spring.aop.report</kbd> package. The second point-cut, <kbd class="calibre12">printUserName</kbd>, will be applied on any public method with a single argument of type <kbd class="calibre12">String</kbd>, while the third point-cut, <kbd class="calibre12">userSession</kbd>, is applicable on all public methods that have a single argument of type <kbd class="calibre12">String</kbd> of any classes under the <kbd class="calibre12">com.packt.spring.aop.report</kbd> package. We have used the name (point-cut signature) of the first and second point-cuts to combine them in the third point-cut definition.</p>
<p class="calibre2">It's common practice to create smaller point-cuts with simple expressions, and build complex point-cuts by combining them with <kbd class="calibre12">and</kbd> , <kbd class="calibre12">or</kbd>, and <kbd class="calibre12">negated</kbd> operations. By referring to its name, point-cuts are so simple to define, and yet powerful when combining with other point-cuts.</p>
<p class="calibre2">Since point-cuts are referred by <kbd class="calibre12">method</kbd> name, the visibility of the Java method is applied to point-cuts. For example, <strong class="calibre4">private</strong> point-cuts are used in the same type, <strong class="calibre4">protected</strong> point-cuts in the same package, and <strong class="calibre4">public</strong> point-cuts can be applied anywhere (that is, can be referred to in other aspect classes in different hierarchies). This brings great flexibility when building an enterprise application with multiple modules, and when you want to share a set of operations between various aspects. You can make public point-cuts in common aspects that can be shared with other aspects in different modules.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Declaring Advice</h1>
                
            
            <article>
                
<p class="calibre2">Declaring Advice with <kbd class="calibre12">@AspectJ</kbd>-style annotation is similar to XML-based AOP configuration. The XML configuration will be replaced by an annotation declaration in the aspect class. Just to recall, Advice is an action to be performed on a point-cut configured with it. Advice can be declared in the Aspect class as <span class="calibre11">follows:</span></p>
<pre class="calibre17">@Before("execution(* com.packt.spring.aop.report.*.*(..))")<br class="title-page-name"/>public void displayUserName() {<br class="title-page-name"/>  System.out.println(" Displaying the user name of logged in user --");<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre12">@Before</kbd> annotation is used to declare before advice with the <kbd class="calibre12">displayUserName</kbd> method. The point-cut expression defined within the <kbd class="calibre12">@Before</kbd> annotation is called <em class="calibre13">in-lined</em>, because it's declared in the same place. You can also put a reference of the point-cut (declared separately with the <kbd class="calibre12">@Pointcut</kbd> annotation) within the <kbd class="calibre12">@Before</kbd> annotation as <span class="calibre11">follows:</span></p>
<pre class="calibre17">@Pointcut("execution( * com.packt.spring.aop.report.*.*(..))")<br class="title-page-name"/>private void checkSession() {<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>@Before("checkSession()")<br class="title-page-name"/>public void displayUserName() {<br class="title-page-name"/>   System.out.println(" Displaying the user name of logged in user --");<br class="title-page-name"/>}</pre>
<p class="calibre2">This is how a point-cut with the <kbd class="calibre12">method</kbd> signature <kbd class="calibre12">checkSession()</kbd> is being referred to in the <kbd class="calibre12">@Before</kbd> advice. The previous configuration is equivalent to the following XML-based configuration:</p>
<pre class="calibre17">&lt;aop:config&gt;<br class="title-page-name"/>    &lt;!-- point cut declaration  --&gt;    <br class="title-page-name"/>    &lt;aop:pointcut id="checkSessionPointcut"<br class="title-page-name"/>        expression="execution( * com.packt.spring.aop.report.*.*(..))" /&gt;<br class="title-page-name"/><br class="title-page-name"/>    &lt;!-- aspect and advice configuration  --&gt;        <br class="title-page-name"/>    &lt;aop:aspect id="mySessionCheck" ref="checkSessionAspect"&gt;<br class="title-page-name"/>        &lt;aop:before pointcut-ref="checkSessionPointcut" <br class="title-page-name"/>              method="displayUserName"/&gt;<br class="title-page-name"/>    &lt;/aop:aspect&gt;<br class="title-page-name"/><br class="title-page-name"/>    &lt;!-- spring bean represents an aspect  --&gt;        <br class="title-page-name"/>    &lt;bean id="checkSessionAspect" <br class="title-page-name"/>            class="com.packet.spring.aop.aspects.SessionCheck"&gt;<br class="title-page-name"/>    &lt;/bean&gt;<br class="title-page-name"/>&lt;/aop:config&gt;</pre>
<p class="calibre2">As we have seen, the access modifier of the point-cut signature will decide its visibility. You can refer any public point-cut to the advice on a different <kbd class="calibre12">Aspect</kbd> class as <span class="calibre11">follows:</span></p>
<pre class="calibre17">//New Aspect class.<br class="title-page-name"/>@Aspect<br class="title-page-name"/>public class PermissionCheck {<br class="title-page-name"/>  @Pointcut("within(com.packt.spring.aop.report.*)")<br class="title-page-name"/>  public void checkReportPermission() {<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>//Define After advice within SessionCheck aspect class.<br class="title-page-name"/>@After("com.packt.spring.aop.aspects.PermissionCheck.checkReportPermission()")<br class="title-page-name"/>public void checkResourcePermission() {<br class="title-page-name"/>  System.out.println("This is resource permission checker ..");<br class="title-page-name"/>}</pre>
<p class="calibre2">This is how you can refer to a public point-cut defined in some other aspect class. You need to use a fully-qualified class and put the <kbd class="calibre12">method</kbd> name with a dot in between. We have seen an example of before and after advice types. You can define other advice types, such as around advice, after returning advice and after throwing advice, similar to<span class="calibre11"> the schema-based AOP we have seen in previous topics. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Declaring an advisor</h1>
                
            
            <article>
                
<p class="calibre2">Spring provides another mechanism to define advice and aspect as a single unit. It's called an <strong class="calibre4">advisor</strong>. It's only available in Spring AOP and not in native AspectJ. In this model, you need to define advice as a class that implements one of the advice interfaces. An advisor can be defined with the <kbd class="calibre12">&lt;aop:advisor&gt;</kbd> element in the application context (XML) file as <span class="calibre11">follows:</span></p>
<pre class="calibre17">&lt;aop:config&gt;<br class="title-page-name"/>      &lt;aop:pointcut id="loggingPointcut" expression="execution(*<br class="title-page-name"/>               com.packt.spring.aop.dao.*.*(..))" /&gt;<br class="title-page-name"/>      &lt;aop:advisor advice-ref="loggingAdvice"<br class="title-page-name"/>           pointcut-ref="loggingPointcut" id="loggingInterceptorAdvisor" /&gt;<br class="title-page-name"/>&lt;/aop:config&gt;<br class="title-page-name"/><br class="title-page-name"/>&lt;bean id="loggingAdvice" class="com.packt.spring.aop.advisor.LoggingAdvisor" /&gt;</pre>
<p class="calibre2">You need to define an advisor with the <kbd class="calibre12">&lt;aop:advisor&gt;</kbd> element within <kbd class="calibre12">&lt;aop:config&gt;</kbd>. You can define a point-cut advisor with the <kbd class="calibre12">point-cut-ref</kbd> attribute. In the previous example, we have defined an in-lined point-cut. If you are following annotation-based AOP, you can refer to any public point-cut defined in the aspect class as <span class="calibre11">follows:</span></p>
<pre class="calibre17">&lt;aop:advisor advice-ref="loggingAdvice"<br class="title-page-name"/>        pointcut-ref= "com.packt.spring.aop.aspects.PermissionCheck.checkReportPermission()" id="loggingInterceptorAdvisor" /&gt;</pre>
<p class="calibre2">In this example, we are referring to the point-cut with its signature (<kbd class="calibre12">checkReportPermission()</kbd>) defined in the <kbd class="calibre12">PermissionCheck</kbd> aspect class. </p>
<p class="calibre2">We also defined a bean with the  <kbd class="calibre12">LoggingAdvisor</kbd> <span class="calibre11">class, </span><span class="calibre11">which is an <kbd class="calibre12">advisor</kbd> class, and referred in the </span><kbd class="calibre12">&lt;aop:advisor&gt;</kbd> <span class="calibre11">element with the </span><kbd class="calibre12">advice-ref</kbd> <span class="calibre11">attribute. The</span> <kbd class="calibre12">LogginAdvisor</kbd> <span class="calibre11">class is defined as <span class="calibre11">follows:</span></span></p>
<pre class="calibre17">public class LoggingAdvisor implements MethodBeforeAdvice {<br class="title-page-name"/>  @Override<br class="title-page-name"/>  public void before(Method method, Object[] args, Object target) throws<br class="title-page-name"/>    Throwable {<br class="title-page-name"/>    System.out.println("****************** Starting "+method.getName()+" method <br class="title-page-name"/>    *****************");<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">This <kbd class="calibre12">advisor</kbd> class is implementing the <kbd class="calibre12">before</kbd> method of the <kbd class="calibre12">MethodBeforeAdvise</kbd> interface. It's equivalent to implementing before advice. Spring AOP provides other sets of advice interfaces, such as <kbd class="calibre12">MethodInterceptor</kbd>, <kbd class="calibre12">ThrowsAdvice</kbd>, and <kbd class="calibre12">AfterReturningAdvice</kbd>, which are equivalent to implementing around advice, after throwing advice, and after returning advice respectively. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Choosing AOP frameworks and style of configuration</h1>
                
            
            <article>
                
<p class="calibre2">Once you conclude that you will go ahead with the Aspect programming model to achieve or implement your requirements, this question comes into the picture: should you choose Spring AOP or the full-fledged AspectJ framework ?</p>
<p class="calibre2">After choosing the framework, the question of selecting the style of configuration would come up next. For example, in the case of the AspectJ framework, will you choose AspectJ code style or <kbd class="calibre12">@AspectJ</kbd> annotation style? Similarly, in the case of Spring AOP, will you select a Spring XML file or an <kbd class="calibre12">@AspectJ</kbd>-based annotation style to define various artifacts such as aspects, point-cuts, advice, and advisors?</p>
<p class="calibre2">Choosing the right framework with the specific style for defining the configuration depends on many factors, such as project requirements, availability of development tools, team expertise, compatibility of your existing system code with the AOP framework, how quickly you want to implement AOP, and performance overhead.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Spring AOP versus AspectJ language</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we mainly looked at Spring AOP. AspectJ is another solution to implement AOP; however, Spring AOP is simpler than AspectJ because it doesn't require you to introduce an AspectJ compiler or weaver into your development and build process. </p>
<p class="calibre2">Spring AOP has been introduced to provide a simple AOP implementation throughout the IoC container to solve generic problems, while AspectJ is a full featured AOP framework. AspectJ is powerful in nature, but more complex than Spring AOP. AspectJ supports compile-time, post-compile-time, and runtime weaving, while Spring AOP only supports runtime weaving through a proxy. </p>
<p class="calibre2">If your business needs advice on the set of operations of the Spring bean project, Spring AOP is the right choice for you. If you come across a requirement where you need to intercept and implement advice on objects not managed by the Spring container, you should go with the AspectJ programming framework.</p>
<p class="calibre2">Spring AOP supports method-level join-points only. If you need any advice on join-points other than methods (such as field, setter, or getter methods), you should consider AspectJ. Another point you should consider while choosing from these frameworks is performance. Spring AOP uses a proxy, so there should be little runtime overhead. Compared to Spring AOP, there is less overhead while working with AspectJ.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">XML versus @AspectJ-style annotation for Spring AOP</h1>
                
            
            <article>
                
<p class="calibre2">When there is more than one option to choose from, it's always a dilemma, and that is the case here. Which option should you choose while using Spring AOP: XML-based or annotation-based? Each of these styles has benefits and limitations. You should consider them both before choosing the right one for your needs.</p>
<p class="calibre2">The XML style is very well-known and has been widely used since the evolution of the Spring Framework. Almost all Spring developers are handy with it. Choosing the XML style means all your configurations are in one central place. This will help to identify how many artifacts (aspects, point-cuts, and sets of advice) are defined in the system in a cleaner way. This will be a benefit in the alteration of the configuration (for example, changing the expression of a point-cut) independently.</p>
<p class="calibre2">On the other hand, with the XML style, a piece of information is split across different places. <span class="calibre11">The configuration is done in</span> XML, while the actual implementation is defined in the respective bean classes. While using @AspectJ-style annotation, there will be just a single module, Aspect, which declares that all the artifacts, such as point-cuts, advice, and so on, are well encapsulated.</p>
<p class="calibre2">There are other limitations to XML-based AOP, for example, a bean declared as an Aspect would be a singleton only. Also, you can't refer to the point-cut by its signature (name) while combining with other point-cuts. To take an example, a point-cut declaration with an annotation is as follows:</p>
<pre class="calibre17">@Pointcut("execution( * com.packt.spring.aop.report.*.*(..))")<br class="title-page-name"/>private void checkSession() {<br class="title-page-name"/>}<br class="title-page-name"/>@Pointcut("args(String)")<br class="title-page-name"/>private void printUserName() {<br class="title-page-name"/>}<br class="title-page-name"/>@Pointcut("checkSession() &amp;&amp; printUserName()")<br class="title-page-name"/>private void userSession() {<br class="title-page-name"/>}</pre>
<p class="calibre2">The point-cut signatures (names) of <kbd class="calibre12">checkSession</kbd> and <kbd class="calibre12">printUserName</kbd> are used to combine them and form a new expression, <kbd class="calibre12">userSession</kbd>. The downside of XML-based configuration is that you can't combine point-cut expressions like this. </p>
<p class="calibre2"><span class="calibre11">On top of these facts, Spring AOP allows you to mix XML schema-based configuration with @AspectJ-style annotation declaration. For example, you can define a point-cut and an aspect with annotation, and declare the set of advice (interceptors) in XML-based configuration. They all can coexist without any issues.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we learned one of the important ways to achieve separation of concerns called AOP. Conceptually, we are removing the dependency of cross-cutting concerns from business code and applying them with plug-and -play fashion and in a more controlled way with AOP. It solves the design problem that we never could resolve with the traditional AOP model. </p>
<p class="calibre2">We understood the need of AOP by taking an example where we need to keep changing business code when common functionality is changed. We have also seen various terminologies used in AOP, which is very crucial to understanding underlying concepts.</p>
<p class="calibre2">Soon after learning the theory of AOP, we started our journey with Spring AOP to understand the practical concepts. First, we learned to define AOP configuration in an XML file, followed by declaring various artifacts such as aspect, point-cut, and advice. Details about point-cut expressions and advice types were shown with various examples and code samples. </p>
<p class="calibre2">Next, we learned how to define Spring AOP configuration with the <kbd class="calibre12">@AspectJ</kbd> annotation style, followed by declaring aspects, advice, and point-cuts with annotation. We also learned how to define an advisor by implementing various interfaces. Lastly, we saw the benefits and limitations of Spring AOP and the AspectJ framework, followed by how to choose the configuration style for Spring AOP: XML or annotation. </p>
<p class="calibre2">We will move on to learn various design patterns that you can use to achieve IoC, and what the best practices, patterns, and anti-patterns are while working with dependency injection in the next chapter. </p>


            </article>

            
        </section>
    </body></html>