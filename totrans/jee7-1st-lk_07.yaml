- en: Chapter 7. Annotations and CDI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Right up to this moment, we had to use annotations and dependency injections
    without trying to understand how they work. This chapter therefore aims to present
    and highlight improvements in the relevant APIs. The APIs concerned are:'
  prefs: []
  type: TYPE_NORMAL
- en: Common annotations for the Java Platform 1.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contexts and Dependency Injection 1.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common annotations for the Java platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The common annotations for the Java platform 1.2 Specification was developed
    under JSR 250\. This section just gives you an overview of improvements in the
    API. The complete document specification (for more information) can be downloaded
    from [http://jcp.org/aboutJava/communityprocess/mrel/jsr250/index.html](http://jcp.org/aboutJava/communityprocess/mrel/jsr250/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Annotations are a form of metadata that are generally used to describe, configure,
    or mark elements (such as class, method, and attribute) of Java code. In the following
    code, we use the `@Stateless` annotation to configure `MySessionBean` class as
    a stateless session bean, we use the `@Deprecated` annotation to mark `oldMethod()`
    method as obsolete, and finally we set the `save()` method with the `@TransactionAttribute`
    annotation so that it will always use a dedicated transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The annotations have been integrated into the Java language since JDK 5 and
    they are now widely used in many APIs. To avoid redefining some annotations in
    several APIs, the JCP developed the common annotations for the Java platform specification
    with the goal of regrouping annotations that are common to different Java EE APIs,
    which avoids redundancy and facilitates the maintenance of regrouped annotations.
    In the following code, we have the example of the `@Resource` annotation from
    the common annotations for the Java platform API , which permits us to access
    an object of type `SessionContext` in a web container and in an EJB container.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Building your own annotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although there are already several annotations, Java offers the opportunity
    to create new custom annotations if you need. To do this, you should know that
    an annotation is declared as a Java interface. The only difference is that, in
    the case of the annotation the keyword `interface` must be preceded by the character
    `@`. The following code shows the declaration of the custom annotation `Unfinished`.
    This annotation contains a parameter named `message` whose default value is `Nothing
    has been done`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you declare your annotation, you must now define its characteristics.
    The basic characteristics of an annotation are defined through dedicated annotations
    contained in the `java.lang.annotation` package. These annotations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Target`: This is used to define the element types that can be annotated (such
    as class, method, and attribute), for example `@Target({ElementType.METHOD, ElementType.TYPE})`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Retention`: This is used to define the retention level (such as `RUNTIME`,
    `CLASS`, or `SOURCE`) of your annotation, for example `@Retention(RetentionPolicy.RUNTIME)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Inherited`: This is used to say that the annotation will be automatically
    applied to classes that inherit from the class that has the annotation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Documented`: This is used to make your annotation appear in the **Javadoc**
    of the code that contains it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to note that there are other characteristics such as the scope
    (set using the `@ScopeType`) in the case of custom CDI scope annotations.
  prefs: []
  type: TYPE_NORMAL
- en: After all changes, our annotation takes the form shown in the following code.
    According to the settings, this annotation can decorate methods, types of objects
    (such as `class`, `interface`, or `enum`) and attributes. It will be removed at
    the compile time (because the retention level is `SOURCE`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code demonstrates the usage of the `Unfinished` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Although our annotation already looks like a standard annotation, it is not
    yet operational. For this, a class called `processor` must be available to the
    compiler. This class will describe the action to take when an item is annotated
    with our custom annotation.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve a custom processor for Java 6 annotation, we mainly need to implement
    the `process()` method of the `javax.annotation.processing.Processor` interface
    and define the annotations supported by this processor with the `@SupportedAnnotationTypes`
    annotation. The following code shows the processor of our custom `Unfinished`
    annotation. As you can see, for the implementation of the `process()` method,
    we used the abstract class `AbstractProcessor` that implements the `Processor`
    interface. (This prevents us from having to implement all the methods defined
    in this interface.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the processor is realized, we must now declare it so that it can be found
    by the compiler. The simplest way to do this is to use the Java mechanism for
    services declarations using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Package your annotation in a `JAR` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include a `META-INF/services` directory in this `JAR` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include a file named `javax.annotation.processing.Processor` in the `META-INF/services`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify in this file the fully qualified names of the processors contained in
    the `JAR` file (one processor per line).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following screenshot shows the structure of the project that contains the
    `Unfinished` annotation. Failing to put the annotation and the processor in the
    same project as is the case of our example, you can use one project for annotations
    and another for processors. But whatever your option, do not forget to define
    the service in the `META-INF/services` project directory that contains the processor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building your own annotation](img/9235OT_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the contents of the file `javax.annotation.processing.Processor`.
    As the package contains only a single processor, then it is obvious that we will
    have a single line in this file as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building your own annotation](img/9235OT_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For those using **Maven v2.3.2**, to achieve the project that contains the processors,
    they must set the option `<compilerArgument>-proc:none</compilerArgument>` in
    the configuration of the plugin `maven-compiler-plugin` so that the code is properly
    compiled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can import the package that contains the annotation in another project
    and use it at your convenience. When compiling our preceding `App` class, we have
    the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Latest improvements in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Affected by maintenance release, the common annotation specification has not
    greatly changed. We have in all, the addition of a new annotation and update of
    some sections of the specification document.
  prefs: []
  type: TYPE_NORMAL
- en: The new annotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new annotation that was added to the specification concerns the management
    of priorities when using a series of classes in a given order. This is the `javax.annotation.priority`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: The exact role and the ranges of acceptable values for this annotation are defined
    by each specification that uses it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, this annotation could be used to manage the execution order of
    interceptors.
  prefs: []
  type: TYPE_NORMAL
- en: Contexts and Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Contexts and Dependency Injection(CDI) for Java EE 1.1 Specification was
    developed under JSR 346\. This section just gives you an overview of improvements
    in the API. The complete document specification (for more information) can be
    downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr346/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr346/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: What is CDI ?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Introduced in the Java EE platform from Version 6, Contexts and Dependency
    Injection for Java EE (CDI) is a specification that has brought to the platform
    a set of services that simplify the management of the lifecycle of objects, and
    standardize and encourage the use of dependency injection in the Java EE environment.
    In concrete terms, this specification gives us the ability to easily link in a
    loosely coupled and type-safe way the different layers (presentation, business
    and data access) of n-tier architectures. In order to do this, the CDI primarily
    relies on two services that are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Context**: This is used for the management of the lifecycle of the objects
    (the time of creation and destruction) based on their scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency Injection**: This includes a number of elements such as the injection
    of a component into another, the choice of implementation to be injected for a
    given interface and the type of object provided to access the injected dependence:
    a proxy or a reference that gives direct access to the instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get a better idea of the power of CDI, let us take some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 – instantiation of a POJO
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose we have a JSF managed bean that wants to access an instance of a POJO
    that implements an interface. The basic approach is to create an instance of the
    POJO in the managed bean by using the `new` keyword as is the case in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The drawback with this approach is that the instance of the `HelloWorld` class
    is created in hard code, which causes a very strong coupling between the managed
    bean and implementation of `IHeloWorld` interface. Therefore, to change `IHelloWorld`
    implementation, you must have an access to the managed bean and modify it.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the CDI, the managed bean will just declare a dependency on an `IHelloWorld`
    instance and inject it. This gives us the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The CDI will look for the implementation of the `IHelloWorld` interface, instantiate
    and inject it. Better still, the CDI will take care of managing the lifecycle
    of the bean that will be injected. Thus, to change the implementation of `IHelloWorld`
    interface, we just have to change the class `HelloWorld`. We will complete our
    code by specifying the scope of the POJO with `@RequestScoped` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Example 2 – accessing an EJB from a JSF page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose we have a JSF page where we want to access a method of an EJB component.
    The typical scenario requires you to first access an instance of the EJB from
    the managed bean associated with the JSF page and then call the EJB method in
    a managed bean method that will be called in the JSF page. In terms of code that
    can be translated as shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of an EJB component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is an example of a JSF-managed bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: From a JSF page, we can call the method `myEjbHelloWorld`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With CDI, we do not necessarily need to go through a managed bean to access
    the methods of an EJB. In fact, we only need to add the `@Named` annotation to
    our EJB component and it will be accessed from our JSF page like a simple JSF-managed
    bean. The difference between the two annotations (`@Named` and `@ManagedBean`)
    is visible in at least two points: the first point concerns the scope. Indeed,
    the `@ManagedBean` annotation is specific to the JSF Specification while the `@Named`
    annotation can create managed beans accessible to a greater number of specifications
    (including JSF) and provides more flexibility in the handling of JavaBean components.
    The second point relates to the features available to the component. The `@Named`
    annotation allows you to create CDI beans, which gives you the opportunity to
    use features that you will not have access to in a JSF bean, such as: interceptors,
    `Producer`, and `Disposer`. As a general rule, it is advisable to use CDI beans
    whenever possible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows an EJB component annotated with CDI `@Named` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows the access to an EJB from a JSF page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Example 3 – setting a bean with a specific scope for simple operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For one reason or another you may want to implement the singleton pattern. In
    the traditional approach, you will implement a singleton EJB type even if you
    do not necessarily need all of the services that such a component offers (scalability,
    roles-based security, concurrency management, transaction management, and others).
  prefs: []
  type: TYPE_NORMAL
- en: 'With CDI, you can create your bean with the desired scope without the obligation
    of implementing heavy components for marginal processing. In fact, CDI offers
    several types of scope that can be defined using annotations (`@ApplicationScoped`,
    `@RequestScoped`, and `@SessionScoped`). Thus, to implement the singleton pattern
    without cluttering the services offered by the EJB components, we can simply use
    the application scope annotation of the CDI as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Example 4 – use of objects usually created by a factory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You want to send an asynchronous message via JMS from EJB. The classical approach
    will require you to instantiate many objects as is the case in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With CDI, all this mass of code is reduced to a line, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Latest improvements in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having been introduced to the platform from Java EE 6, CDI has become an important
    solution for component oriented programming in the Java EE platform. Now it only
    has to spread its tentacles into almost all specifications of the platform so
    that it can link seamlessly more components and integrate more APIs. In the long
    list of improvements that have been made, we will present a few including: the
    possibility of avoiding a bean being processed by the CDI, access to the current
    CDI container, access to the non contexual instances of a bean, and finally the
    ability to explicitly destroy bean instances. The improvement of CDI relating
    to interceptors and decorators will be presented in the next chapter when we will
    discuss the relevant specification.'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding CDI processing on a bean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Version 1.1 of the CDI Specification came with the annotation `@vetoed` that
    prevents an object being considered as a CDI bean. However, a bean decorated with
    this annotation cannot have a lifecycle similar to the contextual instance. So,
    it cannot be injected.
  prefs: []
  type: TYPE_NORMAL
- en: 'By looking at this annotation, some might wonder about its usefulness. To preserve
    the integrity of some data, it may happen that you need to control the use of
    some components. But, by using CDI, your components can be manipulated from any
    other component. Hence the role of the `@vetoed` annotation. The following code
    shows us the use of the `@vetoed` annotation on the `Student` entity in order
    to avoid unknown manipulations that can lead to inconsistencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the non contexual instance of a bean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This version also added the ability to inject and execute lifecycle callbacks
    of unmanaged instances of beans. The following code demonstrates how to inject
    and execute lifecycle callbacks of non contexual instances of the bean `Student`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the current CDI container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The CDI Specification 1.1 has added the ability to access the current CDI container
    programmatically and perform some operations. The following code demonstrates
    how to access a CDI container to explicitly destroy a context object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Destroying CDI bean instances explicitly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To allow explicit destruction of bean instances in applications, CDI 1.1 has
    introduced the `AlterableContext` interface, which contains the `void destroy`(`Contextual<?>
    contextual`) method. Extensions should implement this interface instead of the
    `Context` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After several chapters focused on the realization of a complete system using
    the Java EE 7 platform, this chapter has allowed us to take a break and try to
    review some key concepts that we were using. Thus, we learned to make our own
    annotations and link layers of n-tier applications. In the next chapter, we will
    continue with the implementation of our application by integrating, this time,
    the validation of data exchanged between the different layers.
  prefs: []
  type: TYPE_NORMAL
