<html><head></head><body>
		<div id="_idContainer030">
			<h1 id="_idParaDest-111"><em class="italic"><a id="_idTextAnchor110"/>Chapter 7</em>: Types, Converters, and Bindings</h1>
			<p>Data types, converters, and bindings represent major aspects of working with a database via a Java-based <strong class="bold">Domain-Specific Language</strong> (<strong class="bold">DSL</strong>) <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>). Sooner or later, standard <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>)/<strong class="bold">Java Database Connectivity</strong> (<strong class="bold">JDBC</strong>) data types will not be enough, or the default mappings between Java types and JDBC types will raise some shortcomings in your specific scenarios. At that moment, you'll be interested in creating new data types, working with custom data types, type conversion, and type-binding capabilities of your DSL API. Fortunately, the <strong class="bold">jOOQ Object Oriented Querying</strong> (<strong class="bold">jOOQ</strong>) DSL provides versatile and easy-to-use APIs dedicated to the following agenda that represents the subject of this chapter:</p>
			<ul>
				<li>Default data type conversion</li>
				<li>Custom data types and type conversion</li>
				<li>Custom data types and type binding</li>
				<li>Manipulating enums</li>
				<li>Data type rewrites</li>
				<li>Handling embeddable types</li>
			</ul>
			<p>Let's get started!</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor111"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter07">https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter07</a>.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor112"/>Default data type conversion</h1>
			<p>One of the <a id="_idIndexMarker553"/>aspects of jOOQ that allows us to use it in a smooth manner is its <em class="italic">default data type conversion</em>. Most of the time, jOOQ hides from us the ceremony of converting between JDBC and Java types. For instance, have you wondered how the following explicit conversions work? Take a look:</p>
			<pre class="source-code">Record1&lt;Integer&gt; fiscalYear = ctx.select(field("fiscal_year", </pre>
			<pre class="source-code">  Integer.class)).from(table("sale")).fetchAny();</pre>
			<pre class="source-code">// Offtake is a POJO</pre>
			<pre class="source-code">Offtake offtake = ctx.select(field("fiscal_year"), </pre>
			<pre class="source-code">  field("sale"), field("employee_number")).from(table("sale"))            </pre>
			<pre class="source-code">  .fetchAnyInto(Offtake.class);</pre>
			<p>Both conversions are resolved via <em class="italic">default data type conversion</em> or <em class="italic">auto-conversions</em>. Behind the scenes, jOOQ relies on its own API that is capable of performing soft type-safe conversions for <strong class="source-inline">Object</strong> types, arrays, and collections. </p>
			<p>You can check out this example in the <em class="italic">ConvertUtil</em> application.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor113"/>Custom data types and type conversion</h1>
			<p>In jOOQ, the <a id="_idIndexMarker554"/>common interface for all dialect-specific data types is named <strong class="source-inline">org.jooq.DataType&lt;T&gt;</strong>, where <strong class="source-inline">T</strong> represents the Java type associated with an SQL data type. Each association of a <strong class="source-inline">T</strong> Java data type with an SQL data type (generic SQL types, called standard JDBC types) represented by <strong class="source-inline">java.sql.Types</strong> is present in jOOQ's <strong class="source-inline">org.jooq.impl.SQLDataType</strong> API. The jOOQ Code Generator automatically maps Java types to this <strong class="source-inline">SQLDataType</strong> API, which has an almost 1:1 matching to databases' data types for most dialects. Of course, we are not including here some of the vendor-specific data types, such as spatial data types, PostgreSQL's <strong class="source-inline">INET</strong>/<strong class="source-inline">HSTORE</strong>, nor other non-standard JDBC types (data types not explicitly supported by JDBC).</p>
			<p>Roughly, any data type that is not associated in the jOOQ API with a standard JDBC type is considered and treated as a <em class="italic">custom data type</em>. However, as Lukas Eder mentions: "<em class="italic">There are some data types that I think *should* be standard JDBC types, but are not. They're also listed in </em><strong class="source-inline">SQLDataType</strong><em class="italic">, including: </em><strong class="source-inline">JSON</strong><em class="italic">, </em><strong class="source-inline">JSONB</strong><em class="italic">, </em><strong class="source-inline">UUID</strong><em class="italic">, </em><strong class="source-inline">BigInteger</strong><em class="italic"> (!), unsigned numbers, intervals. These don't require custom data types.</em>"</p>
			<p>Whenever your custom data type needs to be mapped onto a standard JDBC type—that is, an <strong class="source-inline">org.jooq.impl.SQLDataType</strong> type—you need to provide and explicitly specify an <strong class="source-inline">org.jooq.Converter</strong> implementation. This converter does the hard work of performing a conversion between the involved types. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">When we want to map a type onto a non-standard JDBC type (a type that is not in <strong class="source-inline">org.jooq.impl.SQLDataType</strong>), we need to focus on the <strong class="source-inline">org.jooq.Binding</strong> API, which is covered later. So, if this is your case, don't try to shoehorn your conversion logic onto a <strong class="source-inline">Converter</strong>. Just use a <strong class="source-inline">Binding</strong> (we'll see this later in this chapter).</p>
			<p>Pay <a id="_idIndexMarker555"/>attention that attempting to insert values/data of a custom data type without passing through a converter may result in inserting <strong class="source-inline">null</strong> values in the database (as Lukas Eder shared: "<em class="italic">This null behavior is an old design flaw. A long time ago, I've not followed a fail-early strategy throwing exceptions</em>"), while trying to fetch data of custom data type without a converter may lead to <strong class="source-inline">org.jooq.exception.DataTypeException</strong>, <em class="italic">no converter found for types Foo and Buzz</em>.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/>Writing an org.jooq.Converter interface</h2>
			<p><strong class="source-inline">org.jooq.Converter</strong> is<a id="_idIndexMarker556"/> an interface that represents a conversion between two types that are generically denoted as <strong class="source-inline">&lt;T&gt;</strong> and <strong class="source-inline">&lt;U&gt;</strong>. By <strong class="source-inline">&lt;T&gt;</strong>, we represent the database type, and by <strong class="source-inline">&lt;U&gt;</strong>, we represent the <strong class="bold">User-Defined Type</strong> (<strong class="bold">UDT</strong>) or the type used in the application. Converting from <strong class="source-inline">&lt;T&gt;</strong> to <strong class="source-inline">&lt;U&gt;</strong> is accomplished in a method named <strong class="source-inline">U from(T)</strong>, and converting from <strong class="source-inline">&lt;U&gt;</strong> to <strong class="source-inline">&lt;T&gt;</strong> is accomplished in a method named <strong class="source-inline">T to(U)</strong>. </p>
			<p>If you find it hard to remember which direction is "<strong class="source-inline">from()</strong>" and which direction is "<strong class="source-inline">to()</strong>", then think that the former can be read as "<em class="italic">FROM the database to the client</em>" and the latter as "<em class="italic">from the client TO the database</em>". Also, pay attention to not confuse <strong class="source-inline">T</strong> and <strong class="source-inline">U</strong> because you risk spending hours staring at compilation errors in generated code.</p>
			<p>In other words, via <strong class="source-inline">U from(T)</strong>, we convert from a database type to a UDT (for example, this is useful in <strong class="source-inline">SELECT</strong> statements), and via <strong class="source-inline">T to(U)</strong>, we convert from a UDT to a database type (for example, this is useful in <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, and <strong class="source-inline">DELETE</strong> statements). Moreover, a <strong class="source-inline">T to(U)</strong> direction is used wherever bind variables are used, so also in <strong class="source-inline">SELECT</strong> when writing predicates—for instance, <strong class="source-inline">T.CONVERTED.eq(u)</strong>. The stub of <strong class="source-inline">org.jooq.Converter</strong> is listed here:</p>
			<pre class="source-code">public interface Converter&lt;T, U&gt; {</pre>
			<pre class="source-code">   U from(T databaseObject);  // convert to user-defined type</pre>
			<pre class="source-code">   T to(U userDefinedObject); // convert to database type</pre>
			<pre class="source-code">   // Class instances for each type</pre>
			<pre class="source-code">   Class&lt;T&gt; fromType();</pre>
			<pre class="source-code">   Class&lt;U&gt; toType();</pre>
			<pre class="source-code">}</pre>
			<p>jOOQ comes with an abstract <a id="_idIndexMarker557"/>implementation of this interface (<strong class="source-inline">AbstractConverter</strong>) and a few concrete extensions (converters) of this abstraction that you can explore here: <a href="https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/impl/AbstractConverter.html">https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/impl/AbstractConverter.html</a>. But as you'll see next, we can write our own converters.</p>
			<p>If, for instance, you want to use Java 8's <strong class="source-inline">java.time.YearMonth</strong> type in the application but store it as an SQL <strong class="source-inline">INTEGER</strong> type in the database, you write a converter like this:</p>
			<pre class="source-code">public class YearMonthConverter </pre>
			<pre class="source-code">             implements Converter&lt;Integer, YearMonth&gt; {</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">  @Override</pre>
			<pre class="source-code">  public YearMonth from(Integer t) {</pre>
			<pre class="source-code">    if (t != null) {</pre>
			<pre class="source-code">      return YearMonth.of(1970, 1)</pre>
			<pre class="source-code">               .with(ChronoField.PROLEPTIC_MONTH, t);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    return null;</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  @Override</pre>
			<pre class="source-code">  public Integer to(YearMonth u) {</pre>
			<pre class="source-code">    if (u != null) {</pre>
			<pre class="source-code">      return (int) u.getLong(ChronoField.PROLEPTIC_MONTH);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    return null;</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  @Override</pre>
			<pre class="source-code">  public Class&lt;Integer&gt; fromType() {</pre>
			<pre class="source-code">    return Integer.class;</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  @Override</pre>
			<pre class="source-code">  public Class&lt;YearMonth&gt; toType() {</pre>
			<pre class="source-code">    return YearMonth.class;</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>Use this <a id="_idIndexMarker558"/>converter via <strong class="source-inline">new YearMonthConverter()</strong> or define a handy <strong class="source-inline">static</strong> type, like so:</p>
			<pre class="source-code">public static final Converter&lt;Integer, YearMonth&gt; </pre>
			<pre class="source-code">  INTEGER_YEARMONTH_CONVERTER = new YearMonthConverter();</pre>
			<p>Moreover, using this converter for arrays can be done via the following <strong class="source-inline">static</strong> type, like so:</p>
			<pre class="source-code">public static final Converter&lt;Integer[], YearMonth[]&gt;    </pre>
			<pre class="source-code">  INTEGER_YEARMONTH_ARR_CONVERTER</pre>
			<pre class="source-code">    = INTEGER_YEARMONTH_CONVERTER.forArrays();</pre>
			<p>Once we have a converter, we can define a new data type. More precisely, we define our own <strong class="source-inline">DataType</strong> type programmatically by calling <strong class="source-inline">asConvertedDataType(Converter)</strong> or <strong class="source-inline">asConvertedDataType(Binding)</strong>. For example, here, we define a <strong class="source-inline">YEARMONTH</strong> data type that can be used as any other data type defined in <strong class="source-inline">SQLDataType</strong>:</p>
			<pre class="source-code">public static final DataType&lt;YearMonth&gt; YEARMONTH</pre>
			<pre class="source-code">  = INTEGER.asConvertedDataType(INTEGER_YEARMONTH_CONVERTER);</pre>
			<p>Here, <strong class="source-inline">INTEGER</strong> is the <strong class="source-inline">org.jooq.impl.SQLDataType.INTEGER</strong> data type.</p>
			<p>In the <strong class="source-inline">CUSTOMER</strong> table, we have a field named <strong class="source-inline">FIRST_BUY_DATE</strong> of type <strong class="source-inline">INT</strong>. When a customer makes their first purchase, we store the date (year-month) as an integer. For example, the date <em class="italic">2020-10</em> is stored as <em class="italic">24249</em> (we manually applied the <strong class="source-inline">Integer to(YearMonth u)</strong> method). Without a converter, we have to insert <em class="italic">24249 </em>explicitly; otherwise, the code will not compile (for example, a type-safe <strong class="source-inline">INSERT</strong> statement will not compile) or we'll get an invalid insert (for example, a non-type-safe <strong class="source-inline">INSERT</strong> statement may store <strong class="source-inline">null</strong>). Relying on our converter, we can write the following type-safe <strong class="source-inline">INSERT</strong> statement:</p>
			<pre class="source-code">ctx.insertInto(CUSTOMER, CUSTOMER.CUSTOMER_NAME, ... ,  </pre>
			<pre class="source-code">               CUSTOMER.FIRST_BUY_DATE)</pre>
			<pre class="source-code">   .values("Atelier One", ..., </pre>
			<pre class="source-code">       INTEGER_YEARMONTH_CONVERTER.to(YearMonth.of(2020, 10)))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Next, fetching all the <strong class="source-inline">FIRST_BUY_DATE</strong> values of <em class="italic">Atelier One</em> without using the converter will result in an array or list of integers. To fetch an array/list of <strong class="source-inline">YearMonth</strong>, we can use the converter, as follows:</p>
			<pre class="source-code">List&lt;YearMonth&gt; resultListYM </pre>
			<pre class="source-code">  = ctx.select(CUSTOMER.FIRST_BUY_DATE).from(CUSTOMER)</pre>
			<pre class="source-code">       .where(CUSTOMER.CUSTOMER_NAME.eq("Atelier One"))</pre>
			<pre class="source-code">       .fetch(CUSTOMER.FIRST_BUY_DATE, </pre>
			<pre class="source-code">              INTEGER_YEARMONTH_CONVERTER);</pre>
			<p>In the bundled code (<em class="italic">YearMonthConverter</em>, available for MySQL and PostgreSQL), you can see more examples, including the usage of the <strong class="source-inline">YEARMONTH</strong> data type for coercing and casting operations. </p>
			<p>Writing a<a id="_idIndexMarker559"/> converter having its own class is useful when the converter is used sporadically across different places/classes. If you know that the converter is used only in a single class, then you can define it locally in that class via <strong class="source-inline">Converter.of()/ofNullable()</strong>, as follows (the difference between them consists of the fact that <strong class="source-inline">Converter.ofNullable()</strong> always returns <strong class="source-inline">null</strong> for <strong class="source-inline">null</strong> inputs):</p>
			<pre class="source-code">Converter&lt;Integer, YearMonth&gt; converter = </pre>
			<pre class="source-code">  Converter.ofNullable(Integer.class, YearMonth.class,</pre>
			<pre class="source-code">    (Integer t) -&gt; {</pre>
			<pre class="source-code">      return YearMonth.of(1970, 1)</pre>
			<pre class="source-code">             .with(ChronoField.PROLEPTIC_MONTH, t);</pre>
			<pre class="source-code">    },</pre>
			<pre class="source-code">    (YearMonth u) -&gt; {</pre>
			<pre class="source-code">      return (int) u.getLong(ChronoField.PROLEPTIC_MONTH);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">);</pre>
			<p>Moreover, starting <a id="_idIndexMarker560"/>with jOOQ 3.15+, we can use a so-called <em class="italic">ad hoc converter</em>. This<a id="_idIndexMarker561"/> type of converter is very handy for attaching a converter to a certain column just for one query or a few local queries. For instance, having a converter (<strong class="source-inline">INTEGER_YEARMONTH_CONVERTER</strong>), we can use it for a single column, as follows:</p>
			<pre class="source-code">ctx.insertInto(CUSTOMER, CUSTOMER.CUSTOMER_NAME, ...,  </pre>
			<pre class="source-code"> CUSTOMER.FIRST_BUY_DATE.convert(INTEGER_YEARMONTH_CONVERTER))</pre>
			<pre class="source-code">   .values("Atelier One", ..., YearMonth.of(2020, 10))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>For convenience, jOOQ provides—next to the ad hoc <strong class="source-inline">convert()</strong> function (allows you to turn a <strong class="source-inline">Field&lt;T&gt;</strong> type into a <strong class="source-inline">Field&lt;U&gt;</strong> type and vice versa)—<strong class="source-inline">convertTo()</strong>(allows you to turn a <strong class="source-inline">Field&lt;U&gt;</strong> type into a <strong class="source-inline">Field&lt;T&gt;</strong> type) and <strong class="source-inline">convertFrom()</strong> (allows you to turn a <strong class="source-inline">Field&lt;T&gt;</strong> type into a <strong class="source-inline">Field&lt;U&gt;</strong> type) ad hoc flavors. Since our <strong class="source-inline">INSERT</strong> statement cannot take advantage of both directions of the converter, we can revert to <strong class="source-inline">convertTo()</strong>, as follows:</p>
			<pre class="source-code">ctx.insertInto(CUSTOMER, CUSTOMER.CUSTOMER_NAME, ...,</pre>
			<pre class="source-code"> CUSTOMER.FIRST_BUY_DATE.convertTo(YearMonth.class, </pre>
			<pre class="source-code">            u -&gt; INTEGER_YEARMONTH_CONVERTER.to(u)))</pre>
			<pre class="source-code">   .values("Atelier One", ..., YearMonth.of(2020, 10))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Or, in the case of a <strong class="source-inline">SELECT</strong> statement, you may wish to use <strong class="source-inline">converterFrom()</strong>, as follows:</p>
			<pre class="source-code">List&lt;YearMonth&gt; result = ctx.select(</pre>
			<pre class="source-code">  CUSTOMER.FIRST_BUY_DATE.convertFrom(</pre>
			<pre class="source-code">       t -&gt; INTEGER_YEARMONTH_CONVERTER.from(t)))</pre>
			<pre class="source-code">  .from(CUSTOMER)</pre>
			<pre class="source-code">  .where(CUSTOMER.CUSTOMER_NAME.eq("Atelier One"))</pre>
			<pre class="source-code">  .fetchInto(YearMonth.class);</pre>
			<p>Of course, you don't even need to define the converter's workload in a separate class. You can simply inline it, as we've done here:</p>
			<pre class="source-code">ctx.insertInto(CUSTOMER, ...,</pre>
			<pre class="source-code">    CUSTOMER.FIRST_BUY_DATE.convertTo(YearMonth.class, </pre>
			<pre class="source-code">      u -&gt; (int) u.getLong(ChronoField.PROLEPTIC_MONTH)))</pre>
			<pre class="source-code">   .values(..., YearMonth.of(2020, 10)) ...;</pre>
			<pre class="source-code">List&lt;YearMonth&gt; result = ctx.select(</pre>
			<pre class="source-code">    CUSTOMER.FIRST_BUY_DATE.convertFrom(</pre>
			<pre class="source-code">      t -&gt; YearMonth.of(1970, 1)</pre>
			<pre class="source-code">       .with(ChronoField.PROLEPTIC_MONTH, t)))</pre>
			<pre class="source-code">   .from(CUSTOMER) ...;</pre>
			<p>You can check the <a id="_idIndexMarker562"/>examples for ad hoc converters in <em class="italic">YearMonthAdHocConverter</em> for MySQL and PostgreSQL.</p>
			<p>Going further, converters can be nested by nesting the calls of the <strong class="source-inline">to()</strong>/<strong class="source-inline">from()</strong> methods and can be chained via the <strong class="source-inline">&lt;X&gt; Converter&lt;T,X&gt; andThen(Converter&lt;? super U, X&gt; converter)</strong> method. Both nesting and chaining are exemplified in the bundled code (<em class="italic">YearMonthConverter</em>) by using a second converter that converts between <strong class="source-inline">YearMonth</strong> and <strong class="source-inline">Date</strong>, named <strong class="source-inline">YEARMONTH_DATE_CONVERTER</strong>. </p>
			<p>Moreover, if you want to inverse a converter from <strong class="source-inline">&lt;T, U&gt;</strong> to <strong class="source-inline">&lt;U, T&gt;</strong>, then rely on the <strong class="source-inline">Converter.inverse()</strong> method. This can be useful when nesting/chaining converters that may require you to inverse <strong class="source-inline">T</strong> with <strong class="source-inline">U</strong> in order to obtain a proper match between data types. This is also exemplified in the bundled code. </p>
			<p>The new data type can be defined based on <strong class="source-inline">converter</strong>, as follows:</p>
			<pre class="source-code">DataType&lt;YearMonth&gt; YEARMONTH </pre>
			<pre class="source-code">   = INTEGER.asConvertedDataType(converter);</pre>
			<p>The new data type can be defined without an explicit <strong class="source-inline">Converter</strong> as well. Just use the <strong class="source-inline">public default &lt;U&gt; DataType&lt;U&gt; asConvertedDataType(Class&lt;U&gt; toType, Function&lt;? super T,? extends U&gt; from, Function&lt;? super U,? extends T&gt; to)</strong> flavor, as in the bundled code, and jOOQ will use behind the scenes <strong class="source-inline">Converter.of(Class, Class, Function, Function)</strong>. </p>
			<p>On the other hand, if <a id="_idIndexMarker563"/>a converter is heavily used, then it is better to allow jOOQ to apply it automatically without an explicit call, as in the previous examples. To accomplish this, we need to perform the proper configurations of the jOOQ Code Generator.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>Hooking forced types for converters</h2>
			<p>By<a id="_idIndexMarker564"/> using so-called <em class="italic">forced types</em> (<strong class="source-inline">&lt;forcedTypes/&gt;</strong>), we can<a id="_idIndexMarker565"/> instruct the jOOQ Code Generator to override the column data type. One way to accomplish this consists of mapping the column data type to a user-defined data type via <strong class="source-inline">org.jooq.Converter</strong>.</p>
			<p>This configuration step relies on using the <strong class="source-inline">&lt;forcedTypes/&gt;</strong> tag, which is a child of the <strong class="source-inline">&lt;database/&gt;</strong> tag. Under the <strong class="source-inline">&lt;forcedTypes/&gt;</strong> tag, we can have one or multiple <strong class="source-inline">&lt;forcedType/&gt;</strong> tags, and each of these tags wraps a specific case of overriding the column's data types. Each such case is defined via several tags. First, we have the <strong class="source-inline">&lt;userType/&gt;</strong> and <strong class="source-inline">&lt;converter/&gt;</strong> tags, used to link the UDT and the proper <strong class="source-inline">Converter</strong>. Second, we have several tags used for identifying a certain column (or multiple columns) by name and/or type. While you can find all these tags described in the jOOQ manual (<a href="https://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced/codegen-config-database/codegen-database-forced-types/">https://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced/codegen-config-database/codegen-database-forced-types/</a>), let's mention here two of the most used: <strong class="source-inline">&lt;includeExpression/&gt;</strong> and <strong class="source-inline">&lt;includeTypes/&gt;</strong>.  <strong class="source-inline">&lt;includeExpression/&gt;</strong> contains a Java <strong class="bold">regular expression</strong> (<strong class="bold">regex</strong>) matching the fully qualified columns (or attributes/parameters), while <strong class="source-inline">&lt;includeTypes/&gt;</strong> contains a Java regex matching the data types that should be forced to have this type (the <strong class="source-inline">&lt;userType/&gt;</strong> type). In case of multiple regexes, use the pipe operator (<strong class="source-inline">|</strong>) to separate them, and if <strong class="source-inline">&lt;includeExpression/&gt;</strong> and <strong class="source-inline">&lt;includeTypes/&gt;</strong> are present<a id="_idIndexMarker566"/> in the same <strong class="source-inline">&lt;forcedType/&gt;</strong> tag, then keep<a id="_idIndexMarker567"/> in mind that they must match.</p>
			<p>For instance, the <strong class="source-inline">&lt;forcedType/&gt;</strong> type for <strong class="source-inline">YearMonthConverter</strong> looks like this:</p>
			<pre class="source-code">&lt;forcedTypes&gt;</pre>
			<pre class="source-code">  &lt;forcedType&gt;</pre>
			<pre class="source-code">    &lt;!-- The Java type of the custom data type. </pre>
			<pre class="source-code">         This corresponds to the Converter's &lt;U&gt; type. --&gt;</pre>
			<pre class="source-code">    &lt;userType&gt;java.time.YearMonth&lt;/userType&gt;</pre>
			<pre class="source-code">    &lt;!-- Associate that custom type with our converter. --&gt;</pre>
			<pre class="source-code">    &lt;converter&gt;</pre>
			<pre class="source-code">      com.classicmodels.converter.YearMonthConverter</pre>
			<pre class="source-code">    &lt;/converter&gt;</pre>
			<pre class="source-code">    &lt;!-- Match the fully-qualified column. --&gt;</pre>
			<pre class="source-code">    &lt;includeExpression&gt;</pre>
			<pre class="source-code">      classicmodels\.customer\.first_buy_date</pre>
			<pre class="source-code">    &lt;/includeExpression&gt;</pre>
			<pre class="source-code">                                            </pre>
			<pre class="source-code">    &lt;!-- Match the data type to be forced. --&gt;</pre>
			<pre class="source-code">    &lt;includeTypes&gt;INT&lt;/includeTypes&gt;</pre>
			<pre class="source-code">  &lt;/forcedType&gt;</pre>
			<pre class="source-code">&lt;/forcedTypes&gt;</pre>
			<p>Notice how we identified the <strong class="source-inline">first_buy_date</strong> column via an expression containing the schema, table, and column name. In other cases, you may wish to use less restrictive expressions; therefore, here are<a id="_idIndexMarker568"/> some popular <a id="_idIndexMarker569"/>examples:</p>
			<pre class="source-code">&lt;!-- All 'first_buy_date' fields in any 'customer' table, </pre>
			<pre class="source-code">     no matter the schema --&gt;</pre>
			<pre class="source-code">.*\.customer\.first_buy_date</pre>
			<pre class="source-code">                                            </pre>
			<pre class="source-code">&lt;!-- All 'first_buy_date' fields, </pre>
			<pre class="source-code">     no matter the schema and the table --&gt;</pre>
			<pre class="source-code">.*\.first_buy_date</pre>
			<pre class="source-code">                                            </pre>
			<pre class="source-code">&lt;!-- All fields containing 'first_buy_' --&gt;</pre>
			<pre class="source-code">.*\.first_buy_.*</pre>
			<pre class="source-code">                                           </pre>
			<pre class="source-code">&lt;!-- Case-insensitive expressions --&gt;</pre>
			<pre class="source-code">(?i:.*\.customer\.first_buy_date)</pre>
			<pre class="source-code">(?i:classicmodels\.customer\.first_buy_date)</pre>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Notice that all regexes in the jOOQ Code Generator match any of the following:</p>
			<p class="callout">1) <strong class="bold">Fully qualified object names</strong> (<strong class="bold">FQONs</strong>)</p>
			<p class="callout">2) Partially qualified object names</p>
			<p class="callout">3) Unqualified object names </p>
			<p class="callout">So, instead of <strong class="source-inline">.*\.customer\.first_buy_date</strong>, you can also just write <strong class="source-inline">customer\.first_buy_date</strong>.</p>
			<p class="callout">Moreover, keep in mind that, by default, regexes are case-sensitive. This is important when you're using more than one dialect (for instance, Oracle <strong class="bold">identifiers</strong> (<strong class="bold">IDs</strong>) are <em class="italic">UPPER_CASE</em>, in PostgreSQL, they are <em class="italic">lower_case</em>, and in SQL Server, they are <em class="italic">PascalCase</em>).</p>
			<p>Furthermore, matching any type is done via <strong class="source-inline">&lt;includeTypes&gt;.*&lt;/includeTypes&gt;</strong>, while matching a certain type such as <strong class="source-inline">NVARCHAR(4000)</strong> is done via <strong class="source-inline">NVARCHAR\(4000\)</strong>, and a type such as <strong class="source-inline">NUMBER(1, 0)</strong> via <strong class="source-inline">NUMBER\(1,\s*0\)</strong>. A more verbose version of this example with detailed comments is available in the bundled code. </p>
			<p>This time, the <strong class="source-inline">FIRST_BUY_DATE</strong> field is not <a id="_idIndexMarker570"/>mapped to <strong class="source-inline">java.lang.Integer</strong>. If we check the <a id="_idIndexMarker571"/>generated table class that mirrors the <strong class="source-inline">CUSTOMER</strong> table (<strong class="source-inline">jooq.generated.tables.Customer</strong>), then we see the following declaration:</p>
			<pre class="source-code">public final TableField&lt;CustomerRecord, YearMonth&gt; </pre>
			<pre class="source-code"> FIRST_BUY_DATE = createField(DSL.name("first_buy_date"),   </pre>
			<pre class="source-code">  SQLDataType.INTEGER, this, "", new YearMonthConverter());</pre>
			<p>So, <strong class="source-inline">FIRST_BUY_DATE</strong> is mapped to <strong class="source-inline">YearMonth</strong>, therefore our previous <strong class="source-inline">INSERT</strong> and <strong class="source-inline">SELECT</strong> statements will now look like this:</p>
			<pre class="source-code">ctx.insertInto(CUSTOMER, CUSTOMER.CUSTOMER_NAME, ...,  </pre>
			<pre class="source-code">               CUSTOMER.FIRST_BUY_DATE)</pre>
			<pre class="source-code">   .values("Atelier One", ..., YearMonth.of(2020, 10))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>And the <strong class="source-inline">SELECT</strong> statement will then look like this:</p>
			<pre class="source-code">List&lt;YearMonth&gt; ymList = ctx.select(CUSTOMER.FIRST_BUY_DATE)</pre>
			<pre class="source-code">   .from(CUSTOMER)</pre>
			<pre class="source-code">   .where(CUSTOMER.CUSTOMER_NAME.eq("Atelier One"))</pre>
			<pre class="source-code">   .fetch(CUSTOMER.FIRST_BUY_DATE);</pre>
			<p>jOOQ applies our converter automatically, so there's no need to call it explicitly. It even works when we perform a coercing operation of <strong class="source-inline">ResultQuery&lt;R1&gt;</strong> to <strong class="source-inline">ResultQuery&lt;R2&gt;</strong>, like so:</p>
			<pre class="source-code">Result&lt;Record2&lt;String, YearMonth&gt;&gt; result = ctx.resultQuery(</pre>
			<pre class="source-code">  "SELECT customer_name, first_buy_date FROM customer")</pre>
			<pre class="source-code">  .coerce(CUSTOMER.CUSTOMER_NAME, CUSTOMER.FIRST_BUY_DATE)</pre>
			<pre class="source-code">.fetch();</pre>
			<p>In other words, jOOQ <a id="_idIndexMarker572"/>uses our converter automatically for binding variables<a id="_idIndexMarker573"/> and for fetching data from <strong class="source-inline">java.util.ResultSet</strong>. In queries, we just treat <strong class="source-inline">FIRST_BUY_DATE</strong> as of type <strong class="source-inline">YEARMONTH</strong>. The code is named <em class="italic">YearMonthConverterForcedTypes</em> and is available for MySQL.</p>
			<h3>Defining an inline converter via Converter.of() or Converter.ofNullable()</h3>
			<p>In the previous<a id="_idIndexMarker574"/> section, our converter was <a id="_idIndexMarker575"/>written as a Java class, and we <a id="_idIndexMarker576"/>referenced that class <a id="_idIndexMarker577"/>in the configuration of the jOOQ Code Generator. But instead of writing this class, we can associate the custom data type with an <em class="italic">inline converter</em>, which is a converter written directly into the configuration. For this, we use the <strong class="source-inline">&lt;converter/&gt;</strong> tag, as follows:</p>
			<pre class="source-code">&lt;forcedTypes&gt;</pre>
			<pre class="source-code"> &lt;forcedType&gt;    </pre>
			<pre class="source-code">  &lt;userType&gt;java.time.YearMonth&lt;/userType&gt;</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  &lt;converter&gt;</pre>
			<pre class="source-code">   &lt;![CDATA[</pre>
			<pre class="source-code">    org.jooq.Converter.ofNullable(</pre>
			<pre class="source-code">       Integer.class, YearMonth.class, </pre>
			<pre class="source-code">     (Integer t) -&gt; { return YearMonth.of(1970, 1).with(</pre>
			<pre class="source-code">      java.time.temporal.ChronoField.PROLEPTIC_MONTH, t); },</pre>
			<pre class="source-code">     (YearMonth u) -&gt; { return (int) u.getLong(</pre>
			<pre class="source-code">      java.time.temporal.ChronoField.PROLEPTIC_MONTH); }</pre>
			<pre class="source-code">    )</pre>
			<pre class="source-code">   ]]&gt;</pre>
			<pre class="source-code">  &lt;/converter&gt;    </pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code"> &lt;/forcedType&gt;</pre>
			<pre class="source-code">&lt;/forcedTypes&gt;</pre>
			<p>The <a id="_idIndexMarker578"/>usage part of this converter remains<a id="_idIndexMarker579"/> unchanged. The complete <a id="_idIndexMarker580"/>code is named <em class="italic">InlineYearMonthConverter</em>, and <a id="_idIndexMarker581"/>the programmatic version is named <em class="italic">ProgrammaticInlineYearMonthConverter</em>. Both applications are available for MySQL.</p>
			<h3>Defining an inline converter via lambda expressions</h3>
			<p>A <a id="_idIndexMarker582"/>more concise inline converter can be<a id="_idIndexMarker583"/> written via <strong class="source-inline">&lt;lambdaExpression/&gt;</strong>. This tag saves us from the explicit usage of <strong class="source-inline">Converter.of()</strong>/<strong class="source-inline">Converter.ofNullable()</strong> and allows us to simply specify a lambda expression that converts from the database type via the <strong class="source-inline">&lt;from/&gt;</strong> tag, and a lambda expression that converts to the database type via the <strong class="source-inline">&lt;to/&gt;</strong> tag. Let's exemplify this in our converter, as follows:</p>
			<pre class="source-code">&lt;forcedTypes&gt;</pre>
			<pre class="source-code"> &lt;forcedType&gt;                                         </pre>
			<pre class="source-code">  &lt;userType&gt;java.time.YearMonth&lt;/userType&gt;</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  &lt;lambdaConverter&gt;</pre>
			<pre class="source-code">   &lt;from&gt;</pre>
			<pre class="source-code">    &lt;![CDATA[(Integer t) -&gt; { return YearMonth.of(1970, 1)</pre>
			<pre class="source-code">    .with(java.time.temporal.ChronoField.PROLEPTIC_MONTH, t);    </pre>
			<pre class="source-code">    }]]&gt;</pre>
			<pre class="source-code">   &lt;/from&gt;</pre>
			<pre class="source-code">   &lt;to&gt;</pre>
			<pre class="source-code">    &lt;![CDATA[(YearMonth u) -&gt; { return (int) </pre>
			<pre class="source-code">    u.getLong(java.time.temporal.ChronoField.PROLEPTIC_MONTH);    </pre>
			<pre class="source-code">    }]]&gt;</pre>
			<pre class="source-code">   &lt;/to&gt;                                            </pre>
			<pre class="source-code">  &lt;/lambdaConverter&gt;</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  &lt;/forcedType&gt;</pre>
			<pre class="source-code">&lt;/forcedTypes&gt;</pre>
			<p>Again, the usage <a id="_idIndexMarker584"/>part of this converter remains unchanged. The<a id="_idIndexMarker585"/> complete code is named <em class="italic">LambdaYearMonthConverter</em>, and the programmatic version is named <em class="italic">ProgrammaticLambdaYearMonthConverter</em>. Both applications are available for MySQL.</p>
			<h3>Matching forced types via SQL</h3>
			<p>In the<a id="_idIndexMarker586"/> previous sections, we matched the column names by <a id="_idIndexMarker587"/>using regexes in <strong class="source-inline">&lt;includeExpression/&gt;</strong> and <strong class="source-inline">&lt;includeTypes/&gt;</strong> tags. Whenever we need more complex criteria for matching column names, we can rely on the <strong class="source-inline">&lt;sql/&gt;</strong> tag. The body of this tag is an SQL query that executes against the dictionary views of our database. For instance, matching all columns of type <strong class="source-inline">TIMESTAMP</strong> from our MySQL <strong class="source-inline">classicmodels</strong> database can be achieved like so:</p>
			<pre class="source-code">&lt;sql&gt;</pre>
			<pre class="source-code"> SELECT concat('classicmodels.', TABLE_NAME, '.', COLUMN_NAME)</pre>
			<pre class="source-code"> FROM INFORMATION_SCHEMA.COLUMNS</pre>
			<pre class="source-code"> WHERE TABLE_SCHEMA = 'classicmodels'</pre>
			<pre class="source-code">  AND TABLE_NAME != 'flyway_schema_history'</pre>
			<pre class="source-code">  AND DATA_TYPE = 'timestamp'</pre>
			<pre class="source-code">&lt;/sql&gt;</pre>
			<p>This should return several columns, among them being two from the <strong class="source-inline">PAYMENT</strong> table and one from the <strong class="source-inline">BANK_TRANSACTION</strong> table: <strong class="source-inline">PAYMENT.PAYMENT_DATE</strong>, <strong class="source-inline">PAYMENT.CACHING_DATE</strong>, and <strong class="source-inline">BANK_TRANSACTION.CACHING_DATE</strong>. For these columns, jOOQ will apply <strong class="source-inline">Converter&lt;LocalDateTime, JsonNode&gt;</strong> developed in the bundled code. But these are not the only columns returned by our query, and jOOQ will apply this converter to <strong class="source-inline">PAYMENT.MODIFIED</strong> and <strong class="source-inline">TOKEN.UPDATED_ON</strong>, which are also of type <strong class="source-inline">TIMESTAMP</strong>. Now, we have two options to avoid this—we can tune our query predicate accordingly or we can quickly add <strong class="source-inline">&lt;excludeExpression/&gt;</strong>, as follows:</p>
			<pre class="source-code">&lt;excludeExpression&gt;</pre>
			<pre class="source-code">    classicmodels\.payment\.modified</pre>
			<pre class="source-code">  | classicmodels\.token\.updated_on</pre>
			<pre class="source-code">&lt;/excludeExpression&gt;</pre>
			<p>You can find the <a id="_idIndexMarker588"/>example for<a id="_idIndexMarker589"/> MySQL under the name <em class="italic">SqlMatchForcedTypes</em>.</p>
			<p>I'm pretty sure that you got the idea, and you know how to write such queries for your favorite database.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>JSON converters</h2>
			<p>Whenever jOOQ<a id="_idIndexMarker590"/> detects that the database uses <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) data (for instance, a MySQL/PostgreSQL <strong class="source-inline">JSON</strong> type), it maps the database type to the <strong class="source-inline">org.jooq.JSON</strong> class. This is a very handy class that represents a neat JSON wrapper type for JSON data fetched from the database. Its API consists of the <strong class="source-inline">JSON.data()</strong> method that returns a <strong class="source-inline">String</strong> representation of <strong class="source-inline">org.jooq.JSON</strong> and a <strong class="source-inline">JSON.valueOf(String data)</strong> method that returns <strong class="source-inline">org.jooq.JSON</strong> from the <strong class="source-inline">String</strong> representation. Typically, <strong class="source-inline">org.jooq.JSON</strong> is all you need, but if<a id="_idIndexMarker591"/> you want to manipulate the fetched JSON via <a id="_idIndexMarker592"/>dedicated APIs (Jackson, Gson, <strong class="bold">JSON Binary</strong> (<strong class="bold">JSONB</strong>), and so on), then you need a converter.</p>
			<p>So, in order to practice more examples, the bundled code with this book comes with a JSON converter (<strong class="source-inline">JsonConverter</strong>), as explained in more detail next.</p>
			<p>For MySQL and PostgreSQL, which have the <strong class="source-inline">JSON</strong> data type. The converter converts between <strong class="source-inline">org.jooq.JSON</strong> and <strong class="source-inline">com.fasterxml.jackson.databind.JsonNode</strong>, therefore it implements <strong class="source-inline">Converter&lt;JSON, JsonNode&gt;</strong>. Of course, you can use this as an example, and replace Jackson's <strong class="source-inline">JsonNode</strong> with <strong class="source-inline">com.google.gson.Gson</strong>, <strong class="source-inline">javax/jakarta.json.bind.Jsonb</strong>, and so on. The code available for MySQL and PostgreSQL is named <em class="italic">JsonConverterForcedTypes</em>. A programmatic version of this application is available only for MySQL (but you can easily adapt it for any other dialect) and is named <em class="italic">ProgrammaticJsonConverter</em>.</p>
			<p>For Oracle 18c, which doesn't have a dedicated JSON type (however, this type is available starting with Oracle 21c; see <a href="https://oracle-base.com/articles/21c/json-data-type-21c">https://oracle-base.com/articles/21c/json-data-type-21c</a>), it's common to use <strong class="source-inline">VARCHAR2(4000)</strong> for relatively small JSON data and <strong class="source-inline">BLOB</strong> for large JSON data. In both cases, we can add a <strong class="source-inline">CHECK ISJSON()</strong> constraint to ensure the JSON data validity. Astonishingly, jOOQ detects that JSON data is present, and it maps such columns to the <strong class="source-inline">org.jooq.JSON</strong> type. Our converter converts between <strong class="source-inline">org.jooq.JSON</strong> and <strong class="source-inline">com.fasterxml.jackson.databind.JsonNode</strong>. Consider the applications named <em class="italic">ConverterJSONToJsonNodeForcedTypes</em>.</p>
			<p>For SQL Server, which doesn't have a dedicated JSON type, it's common to use <strong class="source-inline">NVARCHAR</strong> with a <strong class="source-inline">CHECK ISJSON()</strong> constraint. jOOQ doesn't have support to detect the usage of JSON data (as in the case of Oracle) and maps this type to <strong class="source-inline">String</strong>. In this context, we have <a id="_idIndexMarker593"/>a converter in <em class="italic">JsonConverterVarcharToJSONForcedTypes</em> that converts between <strong class="source-inline">NVARCHAR</strong> and <strong class="source-inline">org.jooq.JSON</strong>, and one between <strong class="source-inline">NVARCHAR</strong> and <strong class="source-inline">JsonNode</strong> in <em class="italic">JsonConverterVarcharToJsonNodeForcedTypes</em>. </p>
			<p>Take your time and practice these examples in order to get familiar with jOOQ converters. Next, let's tackle UDT converters.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/>UDT converters</h2>
			<p>As you know<a id="_idIndexMarker594"/> from <a href="B16833_03.xhtml#_idTextAnchor040"><em class="italic">Chapter 3</em></a>, <em class="italic">jOOQ Core Concepts</em>, Oracle and PostgreSQL support UDTs, and we have a UDT in our schema named <strong class="source-inline">EVALUATION_CRITERIA</strong>. This UDT is the data type of the <strong class="source-inline">MANAGER.MANAGER_EVALUATION</strong> field, and in Oracle, it looks like this:</p>
			<pre class="source-code">CREATE OR REPLACE TYPE "EVALUATION_CRITERIA" AS OBJECT (</pre>
			<pre class="source-code">  "communication_ability" NUMBER(7), </pre>
			<pre class="source-code">  "ethics" NUMBER(7), </pre>
			<pre class="source-code">  "performance" NUMBER(7), </pre>
			<pre class="source-code">  "employee_input" NUMBER(7),</pre>
			<pre class="source-code">   </pre>
			<pre class="source-code">  // the irrelevant part was skipped</pre>
			<pre class="source-code">);</pre>
			<p>We already know that the jOOQ Code Generator automatically maps the fields of the <strong class="source-inline">evaluation_criteria</strong> UDT via <strong class="source-inline">jooq.generated.udt.EvaluationCriteria</strong>, and the <strong class="source-inline">jooq...pojos.EvaluationCriteria</strong> <strong class="bold">P</strong><strong class="bold">lain Old Java Object</strong> (<strong class="bold">POJO</strong>), respectively, maps the <strong class="source-inline">jooq...udt.EvaluationCriteria.EvaluationCriteriaRecord</strong> record. </p>
			<p>But if we assume that <a id="_idIndexMarker595"/>our application needs to manipulate this type as JSON, then we need a converter that converts between <strong class="source-inline">EvaluationCriteriaRecord</strong> and JSON types (for instance, Jackson <strong class="source-inline">JsonNode</strong>). The <strong class="source-inline">JsonConverter</strong> stub looks like this:</p>
			<pre class="source-code">public class JsonConverter implements </pre>
			<pre class="source-code">        Converter&lt;EvaluationCriteriaRecord, JsonNode&gt; {</pre>
			<pre class="source-code">   @Override</pre>
			<pre class="source-code">   public JsonNode from(EvaluationCriteriaRecord t) { ... }</pre>
			<pre class="source-code">   @Override</pre>
			<pre class="source-code">   public EvaluationCriteriaRecord to(JsonNode u) { ... }</pre>
			<pre class="source-code">   ...</pre>
			<pre class="source-code">}</pre>
			<p>Next, we configure this converter, as follows:</p>
			<pre class="source-code">&lt;forcedTypes&gt;</pre>
			<pre class="source-code"> &lt;forcedType&gt;</pre>
			<pre class="source-code">  &lt;userType&gt;com.fasterxml.jackson.databind.JsonNode&lt;/userType&gt;</pre>
			<pre class="source-code">  &lt;converter&gt;com...converter.JsonConverter&lt;/converter&gt;</pre>
			<pre class="source-code">  &lt;includeExpression&gt;</pre>
			<pre class="source-code">   CLASSICMODELS\.MANAGER\.MANAGER_EVALUATION</pre>
			<pre class="source-code">  &lt;/includeExpression&gt;</pre>
			<pre class="source-code">  &lt;includeTypes&gt;EVALUATION_CRITERIA&lt;/includeTypes&gt;</pre>
			<pre class="source-code"> &lt;/forcedType&gt;</pre>
			<pre class="source-code">&lt;/forcedTypes&gt;  </pre>
			<p>Having this set, we can express an <strong class="source-inline">INSERT</strong> statement, as follows:</p>
			<pre class="source-code">JsonNode managerEvaluation = "{...}";</pre>
			<pre class="source-code">ctx.insertInto(MANAGER, </pre>
			<pre class="source-code">          MANAGER.MANAGER_NAME, MANAGER.MANAGER_EVALUATION)</pre>
			<pre class="source-code">   .values("Mark Joy", managerEvaluation)</pre>
			<pre class="source-code">   .execute();</pre>
			<p>And we can <a id="_idIndexMarker596"/>express a <strong class="source-inline">SELECT</strong> statement, as follows:</p>
			<pre class="source-code">List&lt;JsonNode&gt; managerEvaluation = ctx.select(</pre>
			<pre class="source-code">      MANAGER.MANAGER_EVALUATION)</pre>
			<pre class="source-code">   .from(MANAGER)</pre>
			<pre class="source-code">   .fetch(MANAGER.MANAGER_EVALUATION);</pre>
			<p>The bundled code is named <em class="italic">ConverterUDTToJsonNodeForcedTypes</em> and is available for Oracle and PostgreSQL.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor118"/>Custom data types and type binding</h1>
			<p>Roughly, when <a id="_idIndexMarker597"/>we want to map a type onto a non-standard JDBC type (a type that is not in <strong class="source-inline">org.jooq.impl.SQLDataType</strong>), we need to focus on the <strong class="source-inline">org.jooq.Binding</strong> API, as illustrated in the following code snippet:</p>
			<pre class="source-code">public interface Binding&lt;T, U&gt; extends Serializable { ... }</pre>
			<p>For instance, binding the non-standard vendor-specific PostgreSQL <strong class="source-inline">HSTORE</strong> data type to some Java data type (for instance, <strong class="source-inline">HSTORE</strong> can be mapped quite conveniently to Java <strong class="source-inline">Map&lt;String, String&gt;</strong>) needs to take advantage of the <strong class="source-inline">Binding</strong> API, which contains the following methods (please read the comments): </p>
			<pre class="source-code">// A converter that does the conversion between </pre>
			<pre class="source-code">// the database type T and the user type U</pre>
			<pre class="source-code">Converter&lt;T, U&gt; converter();</pre>
			<pre class="source-code">// A callback that generates the SQL string for bind values of // this binding type. Typically, just ?, but also ?::json, ...</pre>
			<pre class="source-code">void sql(BindingSQLContext&lt;U&gt; ctx) throws SQLException;</pre>
			<pre class="source-code">// Register a type for JDBC CallableStatement OUT parameters</pre>
			<pre class="source-code">ResultSet void register(BindingRegisterContext&lt;U&gt; ctx) </pre>
			<pre class="source-code">          throws SQLException;</pre>
			<pre class="source-code">// Convert U to a type and set in on a JDBC PreparedStatement</pre>
			<pre class="source-code">void set(BindingSetStatementContext&lt;U&gt; ctx) </pre>
			<pre class="source-code">          throws SQLException;</pre>
			<pre class="source-code">// Get a type from JDBC ResultSet and convert it to U</pre>
			<pre class="source-code">void get(BindingGetResultSetContext&lt;U&gt; ctx) </pre>
			<pre class="source-code">          throws SQLException;</pre>
			<pre class="source-code">// Get a type from JDBC CallableStatement and convert it to U</pre>
			<pre class="source-code">void get(BindingGetStatementContext&lt;U&gt; ctx) </pre>
			<pre class="source-code">          throws SQLException;</pre>
			<pre class="source-code">// Get a value from JDBC SQLInput (useful for Oracle OBJECT)</pre>
			<pre class="source-code">void get(BindingGetSQLInputContext&lt;U&gt; ctx) </pre>
			<pre class="source-code">          throws SQLException;</pre>
			<pre class="source-code">// Get a value from JDBC SQLOutput (useful for Oracle OBJECT)</pre>
			<pre class="source-code">void set(BindingSetSQLOutputContext&lt;U&gt; ctx) </pre>
			<pre class="source-code">          throws SQLException;</pre>
			<p>For instance, let's<a id="_idIndexMarker598"/> consider that we already have an <strong class="source-inline">org.jooq.Converter</strong> implementation between <strong class="source-inline">Map&lt;String, String&gt;</strong> and <strong class="source-inline">HSTORE</strong> named <strong class="source-inline">HstoreConverter</strong>, and we continue by adding an <strong class="source-inline">org.jooq.Binding</strong> implementation named <strong class="source-inline">HstoreBinding</strong> that starts like this:</p>
			<pre class="source-code">public class HstoreBinding implements </pre>
			<pre class="source-code">          Binding&lt;Object, Map&lt;String, String&gt;&gt; {</pre>
			<pre class="source-code">   private final HstoreConverter converter </pre>
			<pre class="source-code">      = new HstoreConverter();</pre>
			<pre class="source-code">   @Override</pre>
			<pre class="source-code">   public final Converter&lt;Object, Map&lt;String, String&gt;&gt; </pre>
			<pre class="source-code">                                              converter() {</pre>
			<pre class="source-code">      return converter;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   ...</pre>
			<pre class="source-code">}</pre>
			<p>On the other hand, for a MySQL vendor-specific <strong class="source-inline">POINT</strong> type, we may have a converter named <strong class="source-inline">PointConverter</strong>, and we need a <strong class="source-inline">PointBinding</strong> class as follows—the <strong class="source-inline">POINT</strong> type maps well to the Java <strong class="source-inline">Point2D.Double</strong> type:</p>
			<pre class="source-code">public class PointBinding implements Binding&lt;Object,Point2D&gt; {</pre>
			<pre class="source-code">   private final PointConverter converter </pre>
			<pre class="source-code">      = new PointConverter();</pre>
			<pre class="source-code">   @Override</pre>
			<pre class="source-code">   public final Converter&lt;Object, Point2D&gt; converter() {</pre>
			<pre class="source-code">      return converter;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   ...</pre>
			<pre class="source-code">}</pre>
			<p>Next, we focus on<a id="_idIndexMarker599"/> implementing the <strong class="source-inline">Binding</strong> SPI for PostgreSQL <strong class="source-inline">HSTORE</strong> and MySQL <strong class="source-inline">POINT</strong>. An important aspect of this is rendering a bind variable for the binding context's value and casting it to the <strong class="source-inline">HSTORE</strong> type. This is done in the <strong class="source-inline">sql()</strong> method, as follows:</p>
			<pre class="source-code">@Override    </pre>
			<pre class="source-code">public void sql(BindingSQLContext&lt;Map&lt;String, String&gt;&gt; ctx) </pre>
			<pre class="source-code">                                       throws SQLException {</pre>
			<pre class="source-code">       </pre>
			<pre class="source-code">   if (ctx.render().paramType() == ParamType.INLINED) {</pre>
			<pre class="source-code">      ctx.render().visit(inline(</pre>
			<pre class="source-code">         ctx.convert(converter()).value())).sql("::hstore");</pre>
			<pre class="source-code">   } else {</pre>
			<pre class="source-code">      ctx.render().sql("?::hstore");</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>Notice that for the<a id="_idIndexMarker600"/> jOOQ inlined parameters (for details, check <a href="B16833_03.xhtml#_idTextAnchor040"><em class="italic">Chapter 3</em></a>, <em class="italic">jOOQ Core Concepts</em>), we don't need to render a placeholder (<strong class="source-inline">?</strong>); therefore, we render only the PostgreSQL specific syntax, <strong class="source-inline">::hstore</strong>. Depending on the database-specific syntax, you have to render the expected SQL. For instance, for the PostgreSQL <strong class="source-inline">INET</strong> data type, you'll render <strong class="source-inline">?::inet</strong> (or, <strong class="source-inline">::inet</strong>), while for the MySQL <strong class="source-inline">POINT</strong> type, you'll render <strong class="source-inline">ST_PointFromText(?)</strong> as follows (<strong class="source-inline">Point2D</strong> is <strong class="source-inline">java.awt.geom.Point2D</strong>):</p>
			<pre class="source-code">@Override</pre>
			<pre class="source-code">public void sql(BindingSQLContext&lt;Point2D&gt; ctx) </pre>
			<pre class="source-code">        throws SQLException {</pre>
			<pre class="source-code">  if (ctx.render().paramType() == ParamType.INLINED) {</pre>
			<pre class="source-code">      ctx.render().sql("ST_PointFromText(")</pre>
			<pre class="source-code">         .visit(inline(ctx.convert(converter()).value()))</pre>
			<pre class="source-code">         .sql(")");</pre>
			<pre class="source-code">  } else {</pre>
			<pre class="source-code">      ctx.render().sql("ST_PointFromText(?)");</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>Next, we focus on registering a compatible/proper type for JDBC <strong class="source-inline">CallableStatement</strong> OUT parameters. Usually, <strong class="source-inline">VARCHAR</strong> is a proper choice (for instance, <strong class="source-inline">VARCHAR</strong> is a good choice for <strong class="source-inline">HSTORE</strong>, <strong class="source-inline">INET</strong>, or <strong class="source-inline">JSON</strong> types). The code is illustrated in the following snippet:</p>
			<pre class="source-code">@Override</pre>
			<pre class="source-code">public void register(BindingRegisterContext</pre>
			<pre class="source-code">          &lt;Map&lt;String, String&gt;&gt; ctx) throws SQLException {</pre>
			<pre class="source-code">   ctx.statement().registerOutParameter(</pre>
			<pre class="source-code">      ctx.index(), Types.VARCHAR);</pre>
			<pre class="source-code">}</pre>
			<p>But since by default <a id="_idIndexMarker601"/>MySQL returns a <strong class="source-inline">POINT</strong> as binary data (as long as we don't use any MySQL function such as <strong class="source-inline">ST_AsText(g)</strong> or <strong class="source-inline">ST_AsWKT(g)</strong> for converting <a id="_idIndexMarker602"/>geometry values from an internal geometry format to a <strong class="bold">Well-Known Text</strong> (<strong class="bold">WKT</strong>) format), we can use <strong class="source-inline">java.sql.Blob</strong>, as illustrated in the following code snippet:</p>
			<pre class="source-code">@Override</pre>
			<pre class="source-code">public void register(BindingRegisterContext&lt;Point2D&gt; ctx)  </pre>
			<pre class="source-code">                                       throws SQLException {</pre>
			<pre class="source-code">   ctx.statement().registerOutParameter(</pre>
			<pre class="source-code">      ctx.index(), Types.BLOB);</pre>
			<pre class="source-code">}</pre>
			<p>Next, we convert <strong class="source-inline">Map&lt;String, String&gt;</strong> to a <strong class="source-inline">String</strong> value and set it on a JDBC <strong class="source-inline">PreparedStatement</strong> (for the MySQL <strong class="source-inline">POINT</strong> type, we convert <strong class="source-inline">Point2D</strong> to <strong class="source-inline">String</strong>), like so:</p>
			<pre class="source-code">@Override</pre>
			<pre class="source-code">public void set(BindingSetStatementContext</pre>
			<pre class="source-code">            &lt;Map&lt;String, String&gt;&gt; ctx) throws SQLException {</pre>
			<pre class="source-code">   ctx.statement().setString(ctx.index(), Objects.toString(</pre>
			<pre class="source-code">     ctx.convert(converter()).value(), null));</pre>
			<pre class="source-code">}  </pre>
			<p>Further, for PostgreSQL <strong class="source-inline">HSTORE</strong>, we get a <strong class="source-inline">String</strong> value from JDBC <strong class="source-inline">ResultSet</strong> and convert it to <strong class="source-inline">Map&lt;String, String&gt;</strong>, like so:</p>
			<pre class="source-code">@Override</pre>
			<pre class="source-code">public void get(BindingGetResultSetContext</pre>
			<pre class="source-code">           &lt;Map&lt;String, String&gt;&gt; ctx) throws SQLException {</pre>
			<pre class="source-code">   ctx.convert(converter()).value(</pre>
			<pre class="source-code">     ctx.resultSet().getString(ctx.index()));</pre>
			<pre class="source-code">}</pre>
			<p>While for MySQL <strong class="source-inline">POINT</strong>, we get a <strong class="source-inline">Blob</strong> (or an <strong class="source-inline">InputStream</strong>) from JDBC <strong class="source-inline">ResultSet</strong> and convert it to <strong class="source-inline">Point2D</strong>, like so:</p>
			<pre class="source-code">@Override</pre>
			<pre class="source-code">public void get(BindingGetResultSetContext&lt;Point2D&gt; ctx) </pre>
			<pre class="source-code">                                      throws SQLException {</pre>
			<pre class="source-code">   ctx.convert(converter()).value(ctx.resultSet()</pre>
			<pre class="source-code">      .getBlob(ctx.index())); // or, getBinaryStream()</pre>
			<pre class="source-code">}</pre>
			<p>Next, we do the <a id="_idIndexMarker603"/>same thing for JDBC <strong class="source-inline">CallableStatement</strong>. For the <strong class="source-inline">HSTORE</strong> type, we have the following:</p>
			<pre class="source-code">@Override</pre>
			<pre class="source-code">public void get(BindingGetStatementContext</pre>
			<pre class="source-code">           &lt;Map&lt;String, String&gt;&gt; ctx) throws SQLException {</pre>
			<pre class="source-code">   ctx.convert(converter()).value(</pre>
			<pre class="source-code">      ctx.statement().getString(ctx.index()));</pre>
			<pre class="source-code">}</pre>
			<p>And for the <strong class="source-inline">POINT</strong> type, we have this:</p>
			<pre class="source-code">@Override</pre>
			<pre class="source-code">public void get(BindingGetStatementContext&lt;Point2D&gt; ctx) </pre>
			<pre class="source-code">                                       throws SQLException {</pre>
			<pre class="source-code">   ctx.convert(converter()).value(</pre>
			<pre class="source-code">      ctx.statement().getBlob(ctx.index()));</pre>
			<pre class="source-code">}</pre>
			<p>Finally, we override the <strong class="source-inline">get(BindingGetSQLInputContext&lt;?&gt; bgsqlc)</strong> and <strong class="source-inline">set(BindingSetSQLOutputContext&lt;?&gt; bsqlc)</strong> methods. Since, we don't need them for <strong class="source-inline">HSTORE</strong>/<strong class="source-inline">POINT</strong>, we just throw an <strong class="source-inline">SQLFeatureNotSupportedException</strong> exception. For brevity, we skipped this code.</p>
			<p>Once the <strong class="source-inline">Binding</strong> is ready, we <a id="_idIndexMarker604"/>have to configure it in the jOOQ Code Generator. This is quite similar to the configuration of a <strong class="source-inline">Converter</strong> only that, instead of using the <strong class="source-inline">&lt;converter/&gt;</strong> tag, we use the <strong class="source-inline">&lt;binding/&gt;</strong> tag as follows—here, we configure <strong class="source-inline">HstoreBinding</strong> (the configuration of <strong class="source-inline">PointBinding</strong> is available in the bundled code):</p>
			<pre class="source-code">&lt;forcedTypes&gt;</pre>
			<pre class="source-code">  &lt;forcedType&gt;</pre>
			<pre class="source-code">    &lt;userType&gt;java.util.Map&amp;lt;String, String&amp;gt;&lt;/userType&gt;   </pre>
			<pre class="source-code">    &lt;binding&gt;com.classicmodels.binding.HstoreBinding&lt;/binding&gt;</pre>
			<pre class="source-code">    &lt;includeExpression&gt;</pre>
			<pre class="source-code">      public\.product\.specs</pre>
			<pre class="source-code">    &lt;/includeExpression&gt;</pre>
			<pre class="source-code">    &lt;includeTypes&gt;HSTORE&lt;/includeTypes&gt;</pre>
			<pre class="source-code">  &lt;/forcedType&gt;</pre>
			<pre class="source-code">&lt;/forcedTypes&gt;</pre>
			<p>Now, we can test <strong class="source-inline">HstoreBinding</strong>. For instance, the <strong class="source-inline">PRODUCT</strong> table has a field named <strong class="source-inline">SPECS</strong> of type <strong class="source-inline">HSTORE</strong>. The following code inserts a new product with some specifications:</p>
			<pre class="source-code">ctx.insertInto(PRODUCT, PRODUCT.PRODUCT_NAME, </pre>
			<pre class="source-code">               PRODUCT.PRODUCT_LINE, PRODUCT.SPECS)</pre>
			<pre class="source-code">   .values("2002 Masserati Levante", "Classic Cars",</pre>
			<pre class="source-code">      Map.of("Length (in)", "197", "Width (in)", "77.5", </pre>
			<pre class="source-code">             "Height (in)", "66.1", "Engine", "Twin Turbo </pre>
			<pre class="source-code">             Premium Unleaded V-6"))</pre>
			<pre class="source-code">   .execute();  </pre>
			<p>Here's what the rendered SQL looks like:</p>
			<pre class="source-code">INSERT INTO "public"."product" (</pre>
			<pre class="source-code">            "product_name", "product_line", "specs")</pre>
			<pre class="source-code">VALUES (?, ?, ?::hstore)</pre>
			<p>After<a id="_idIndexMarker605"/> resolving the <strong class="source-inline">?</strong> placeholders, the SQL looks like this:</p>
			<pre class="source-code">INSERT INTO "public"."product" (</pre>
			<pre class="source-code">            "product_name", "product_line", "specs")</pre>
			<pre class="source-code">VALUES ('2002 Masserati Levante', 'Classic Cars', </pre>
			<pre class="source-code">        '"Width (in)"=&gt;"77.5", "Length (in)"=&gt;"197", </pre>
			<pre class="source-code">         "Height (in)"=&gt;"66.1", </pre>
			<pre class="source-code">         "Engine"=&gt;"Twin Turbo Premium Unleaded V-6"'::hstore)</pre>
			<p>At <strong class="source-inline">INSERT</strong> (<strong class="source-inline">UPDATE</strong>, <strong class="source-inline">DELETE</strong>, and so on), <strong class="source-inline">HstoreConverter</strong> converts from Java <strong class="source-inline">Map&lt;String, String&gt;</strong> to an <strong class="source-inline">HSTORE</strong> type. At <strong class="source-inline">SELECT</strong>, the same converter converts <strong class="source-inline">HSTORE</strong> to <strong class="source-inline">Map&lt;String, String&gt;</strong>. So, our <strong class="source-inline">SELECT</strong> statement could look like this: </p>
			<pre class="source-code">List&lt;Map&lt;String, String&gt;&gt; specs = ctx.select(PRODUCT.SPECS)</pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .where(PRODUCT.PRODUCT_NAME.eq("2002 Masserati Levante"))</pre>
			<pre class="source-code">   .fetch(PRODUCT.SPECS);</pre>
			<p>Notice that we don't use explicitly any <strong class="source-inline">Binding</strong> or <strong class="source-inline">Converter</strong> and we don't <em class="italic">touch</em> the <strong class="source-inline">HSTORE</strong> type. For us, in the application, <strong class="source-inline">SPECS</strong> is of the type <strong class="source-inline">Map&lt;String, String&gt;</strong>.</p>
			<p>Notice that, starting with jOOQ 3.15, we have access to the <em class="italic">jOOQ-postgres-extensions</em> module (<a href="https://github.com/jOOQ/jOOQ/issues/5507">https://github.com/jOOQ/jOOQ/issues/5507</a>), which supports <strong class="source-inline">HSTORE</strong> as well.</p>
			<p>Bindings and <a id="_idIndexMarker606"/>converters can be used to write different helper methods. For instance, the following method can be used to convert any <strong class="source-inline">Param</strong> to its database data type:</p>
			<pre class="source-code">static &lt;T&gt; Object convertToDatabaseType(Param&lt;T&gt; param) {</pre>
			<pre class="source-code">   return param.getBinding().converter().to(param.getValue());</pre>
			<pre class="source-code">}</pre>
			<p>But what's happening without <strong class="source-inline">Binding</strong>? Is everything lost?</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor119"/>Understanding what's happening without Binding</h2>
			<p>When jOOQ detects a non-standard JDBC type that doesn't have an associated <strong class="source-inline">Binding</strong>, it will mark the corresponding field with <em class="italic">@deprecated Unknown data type</em>, and with the message, <em class="italic">Please define an explicit {@link org.jooq.Binding} to specify how this type should be handled. Deprecation can be turned off using {@literal &lt;deprecationOnUnknownTypes/&gt;} in your Code Generator configuration.</em></p>
			<p>As a rule of thumb, relying on <strong class="source-inline">Binding</strong>s is the way to go, but as a workaround, we can also use explicit mapping for <strong class="source-inline">SELECT</strong> statements and <strong class="source-inline">public static &lt;T&gt; Field&lt;T&gt; field(String sql, Class&lt;T&gt; type, Object... bindings)</strong>, or another <strong class="source-inline">field()</strong> flavor that fits better, for <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, and so on. </p>
			<p>However, using a non-standard JDBC type in <strong class="source-inline">INSERT</strong> statements (<strong class="source-inline">UPDATE</strong> statements, and so on) just like that leads to jOOQ's <strong class="source-inline">SQLDialectNotSupportedException</strong> exception, <em class="italic">Type Foo is not supported in dialect Buzz, and in SELECT statements, to jOOQ's DataTypeException, No Converter found for types Foo and Buzz.</em></p>
			<p>You can check the <strong class="source-inline">HSTORE</strong> examples from this section in the application named <em class="italic">HstoreBinding</em>, and the <strong class="source-inline">POINT</strong> examples in the application named <em class="italic">PointGeometryBinding</em>.</p>
			<p>In addition, the bundled code contains <em class="italic">InetBinding</em> for the PostgreSQL <strong class="source-inline">INET</strong> type, <em class="italic">JsonBinding</em> for the PostgreSQL <strong class="source-inline">JSON</strong> type, and <em class="italic">ProgrammaticInetBinding </em>representing the programmatic configuration of <strong class="source-inline">Binding</strong> for the PostgreSQL <strong class="source-inline">INET</strong> type. Next, let's discuss enums and how to convert these.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor120"/>Manipulating enums</h1>
			<p>jOOQ <a id="_idIndexMarker607"/>represents an SQL enum type (for example, the MySQL <strong class="source-inline">enum</strong> or PostgreSQL <strong class="source-inline">enum</strong> data type created via <strong class="source-inline">CREATE TYPE</strong>) via an interface named <strong class="source-inline">org.jooq.EnumType</strong>. Whenever the jOOQ Java Code Generator detects the usage of an SQL enum type, it automatically generates a Java enum that implements <strong class="source-inline">EnumType</strong>. For instance, the MySQL schema of the <strong class="source-inline">SALE</strong> table contains the following <strong class="source-inline">enum</strong> data type:</p>
			<pre class="source-code">'vat' ENUM ('NONE', 'MIN', 'MAX') DEFAULT NULL</pre>
			<p>For <strong class="source-inline">vat</strong>, the jOOQ generator renders the <strong class="source-inline">jooq.generated.enums.VatType</strong> enum, as follows:</p>
			<pre class="source-code">public enum VatType implements EnumType {</pre>
			<pre class="source-code">    NONE("NONE"), MIN("MIN"), MAX("MAX");</pre>
			<pre class="source-code">    private final String literal;</pre>
			<pre class="source-code">    private VatType(String literal) {</pre>
			<pre class="source-code">        this.literal = literal;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public Catalog getCatalog() {</pre>
			<pre class="source-code">        return null;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public Schema getSchema() {</pre>
			<pre class="source-code">        return null;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public String getName() {</pre>
			<pre class="source-code">        return "sale_vat";</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public String getLiteral() {</pre>
			<pre class="source-code">        return literal;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public static VatType lookupLiteral(String literal) {</pre>
			<pre class="source-code">        return EnumType.lookupLiteral(VatType.class, literal);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>By default, the <a id="_idIndexMarker608"/>name of such a class is composed of the table name and the column name in <em class="italic">PascalCase</em>, which means that the name of the preceding class should be <strong class="source-inline">SaleVat</strong>. But whenever we want to modify the default name, we can rely on jOOQ <em class="italic">generator strategies</em> and regexes, as we did in <a href="B16833_02.xhtml#_idTextAnchor024"><em class="italic">Chapter 2</em></a>, <em class="italic">Customizing the jOOQ Level of Involvement</em>. For instance, we've customized the preceding class name as <strong class="source-inline">VatType</strong> via the following strategy:</p>
			<pre class="source-code">&lt;strategy&gt;</pre>
			<pre class="source-code">  &lt;matchers&gt;                                              </pre>
			<pre class="source-code">    &lt;enums&gt;                                           </pre>
			<pre class="source-code">      &lt;enum&gt;         </pre>
			<pre class="source-code">        &lt;expression&gt;sale_vat&lt;/expression&gt;                         </pre>
			<pre class="source-code">        &lt;enumClass&gt;                                                    </pre>
			<pre class="source-code">          &lt;expression&gt;VatType&lt;/expression&gt;</pre>
			<pre class="source-code">          &lt;transform&gt;AS_IS&lt;/transform&gt;                          </pre>
			<pre class="source-code">        &lt;/enumClass&gt;                             </pre>
			<pre class="source-code">      &lt;/enum&gt;</pre>
			<pre class="source-code">    &lt;/enums&gt;</pre>
			<pre class="source-code">  &lt;/matchers&gt;</pre>
			<pre class="source-code">&lt;/strategy&gt;</pre>
			<p>Having these pieces of knowledge is enough to start writing queries based on jOOQ-generated enums—for instance, an <strong class="source-inline">INSERT</strong> statement into the <strong class="source-inline">SALE</strong> table and a <strong class="source-inline">SELECT</strong> statement from it, as illustrated in the following code snippet:</p>
			<pre class="source-code">import jooq.generated.enums.VatType;</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">ctx.insertInto(SALE, SALE.FISCAL_YEAR, ..., SALE.VAT)</pre>
			<pre class="source-code">   .values(2005, ..., VatType.MAX)</pre>
			<pre class="source-code">   .execute();</pre>
			<pre class="source-code">List&lt;VatType&gt; vats = ctx.select(SALE.VAT).from(SALE)</pre>
			<pre class="source-code">   .where(SALE.VAT.isNotNull())</pre>
			<pre class="source-code">   .fetch(SALE.VAT);</pre>
			<p>Of course, the <strong class="source-inline">Sale</strong>-generated <a id="_idIndexMarker609"/>POJO (or user-defined POJOs) and <strong class="source-inline">SaleRecord</strong> take advantage of <strong class="source-inline">VatType</strong>, as with any other type.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/>Writing enum converters</h2>
			<p>Whenever<a id="_idIndexMarker610"/> jOOQ-generated jOOQ enums are not enough, we focus on enum converters. Here is a non-exhaustive list of scenarios that may require some kind of enum converting to be done:</p>
			<ul>
				<li>Using your own Java enum for a database enum type</li>
				<li>Using your own Java enum for a database non-enum type (or enum-like type)</li>
				<li>Using a Java non-enum type for a database enum </li>
				<li>Always converting to a Java enum and occasionally to another Java enum</li>
			</ul>
			<p>To simplify enum conversion tasks, jOOQ provides a built-in default converter named <strong class="source-inline">org.jooq.impl.EnumConverter</strong>. This converter can convert <strong class="source-inline">VARCHAR</strong> values to enum literals (and vice versa), or <strong class="source-inline">NUMBER</strong> values to enum ordinals (and vice versa). You can also instantiate it explicitly, as has been done here:</p>
			<pre class="source-code">enum Size { S, M, XL, XXL; }</pre>
			<pre class="source-code">Converter&lt;String, Size&gt; converter </pre>
			<pre class="source-code">   = new EnumConverter&lt;&gt;(String.class, Size.class);</pre>
			<p>Next, let's tackle the previous list of enum scenarios.</p>
			<h3>Using your own Java enum for a database enum type</h3>
			<p>Of our<a id="_idIndexMarker611"/> four databases, only MySQL and PostgreSQL <a id="_idIndexMarker612"/>have dedicated types for enums. MySQL has the <strong class="source-inline">enum</strong> type and PostgreSQL has the <strong class="source-inline">CREATE TYPE foo AS enum( ...)</strong> syntax. In both cases, jOOQ generates enum classes on our behalf, but let's suppose that we'd prefer to use our own Java enums. For instance, let's focus on the MySQL schema of the <strong class="source-inline">SALE</strong> table, which contains these two enums:</p>
			<pre class="source-code">`rate` ENUM ('SILVER', 'GOLD', 'PLATINUM') DEFAULT NULL</pre>
			<pre class="source-code">`vat` ENUM ('NONE', 'MIN', 'MAX') DEFAULT NULL</pre>
			<p>The same enums in PostgreSQL are declared like this:</p>
			<pre class="source-code">CREATE TYPE rate_type AS enum('SILVER', 'GOLD', 'PLATINUM');</pre>
			<pre class="source-code">CREATE TYPE vat_type AS enum('NONE', 'MIN', 'MAX');</pre>
			<pre class="source-code">…</pre>
			<pre class="source-code">rate rate_type DEFAULT NULL,</pre>
			<pre class="source-code">vat vat_type DEFAULT NULL,</pre>
			<p>And let's assume that for <strong class="source-inline">vat</strong>, we still rely on a jOOQ-generated Java enum-class (as in the previous section, <strong class="source-inline">VatType</strong>), while for <strong class="source-inline">rate</strong>, we have written the following Java enum:</p>
			<pre class="source-code">public enum RateType { SILVER, GOLD, PLATINUM }</pre>
			<p>In order to automatically map the <strong class="source-inline">rate</strong> column to the <strong class="source-inline">RateType</strong> enum, we rely on the <strong class="source-inline">&lt;forcedType/&gt;</strong> and <strong class="source-inline">&lt;enumConverter/&gt;</strong> flag tags, as illustrated here:</p>
			<pre class="source-code">&lt;forcedTypes&gt;</pre>
			<pre class="source-code">  &lt;forcedType&gt;</pre>
			<pre class="source-code">    &lt;userType&gt;com.classicmodels.enums.RateType&lt;/userType&gt;</pre>
			<pre class="source-code">    &lt;enumConverter&gt;true&lt;/enumConverter&gt;</pre>
			<pre class="source-code">    &lt;includeExpression&gt;</pre>
			<pre class="source-code">      classicmodels\.sale\.rate # MySQL</pre>
			<pre class="source-code">      public\.sale\.rate        # PostgreSQL</pre>
			<pre class="source-code">    &lt;/includeExpression&gt;</pre>
			<pre class="source-code">    &lt;includeTypes&gt;</pre>
			<pre class="source-code">       ENUM      # MySQL</pre>
			<pre class="source-code">       rate_type # PostgreSQL</pre>
			<pre class="source-code">    &lt;/includeTypes&gt;</pre>
			<pre class="source-code">  &lt;/forcedType&gt;</pre>
			<pre class="source-code">&lt;/forcedTypes&gt;</pre>
			<p>By enabling <strong class="source-inline">&lt;enumConverter/&gt;</strong>, we instruct jOOQ to automatically apply the built-in <strong class="source-inline">org.jooq.impl.EnumConverter</strong> converter whenever <strong class="source-inline">SALE.RATE</strong> is used. Done! From this point forward, we can treat the <strong class="source-inline">SALE.RATE</strong> field as of type <strong class="source-inline">RateType</strong>, and jOOQ will handle the conversion aspects of the mapped field (listed here for MySQL), as follows:</p>
			<pre class="source-code">public final TableField&lt;SaleRecord, RateType&gt; RATE </pre>
			<pre class="source-code">  = createField(DSL.name("rate"), SQLDataType.VARCHAR(8),    </pre>
			<pre class="source-code">    this, "", new EnumConverter&lt;String, RateType&gt;   </pre>
			<pre class="source-code">                             (String.class, RateType.class));</pre>
			<p>The application named <em class="italic">SimpleBuiltInEnumConverter</em> contains the complete example for MySQL and PostgreSQL.</p>
			<p>This is a very<a id="_idIndexMarker613"/> convenient approach and works the same<a id="_idIndexMarker614"/> in MySQL and PostgreSQL, but if we don't employ this automatic conversion, we still can use our <strong class="source-inline">RateType</strong> Java enum manually or explicitly. Let's see how! </p>
			<p>First, we configure the jOOQ Code Generator to exclude enum generation for the <strong class="source-inline">sale_rate</strong> (MySQL)/<strong class="source-inline">rate_type</strong> (PostgreSQL) types; otherwise, the <strong class="source-inline">SALE.RATE</strong> field will be automatically mapped to the generated Java enum. The code is illustrated in the following snippet:</p>
			<pre class="source-code">&lt;database&gt;</pre>
			<pre class="source-code">   &lt;excludes&gt;</pre>
			<pre class="source-code">     sale_rate (MySQL) / rate_type (PostgreSQL)</pre>
			<pre class="source-code">   &lt;/excludes&gt;</pre>
			<pre class="source-code">&lt;/database&gt;</pre>
			<p>In this context, jOOQ maps <strong class="source-inline">SALE.RATE</strong> to <strong class="source-inline">String</strong> in MySQL, and to <strong class="source-inline">Object</strong> in PostgreSQL. In PostgreSQL, the field is annotated as <em class="italic">@deprecated Unknown data type</em>, but we turn off this deprecation via the <strong class="source-inline">&lt;deprecationOnUnknownTypes/&gt;</strong> configuration, as follows:</p>
			<pre class="source-code">&lt;generate&gt;</pre>
			<pre class="source-code">  &lt;deprecationOnUnknownTypes&gt;false&lt;/deprecationOnUnknownTypes&gt;</pre>
			<pre class="source-code">&lt;/generate&gt;</pre>
			<p>Next, in MySQL, we can write an <strong class="source-inline">INSERT</strong> statement, as follows (<strong class="source-inline">SALE.RATE</strong> is of type <strong class="source-inline">String</strong>):</p>
			<pre class="source-code">ctx.insertInto(SALE, SALE.FISCAL_YEAR, ..., SALE.RATE)</pre>
			<pre class="source-code">   .values(2005, ..., RateType.PLATINUM.name())</pre>
			<pre class="source-code">   .execute();</pre>
			<p>And we can write a <strong class="source-inline">SELECT</strong> statement, as follows:</p>
			<pre class="source-code">List&lt;RateType&gt; rates = ctx.select(SALE.RATE)</pre>
			<pre class="source-code">   .from(SALE)</pre>
			<pre class="source-code">   .where(SALE.RATE.isNotNull())</pre>
			<pre class="source-code">   .fetch(SALE.RATE, RateType.class);</pre>
			<p>While for MySQL <a id="_idIndexMarker615"/>this is quite smooth, for PostgreSQL it's a<a id="_idIndexMarker616"/> little bit tricky. The PostgreSQL syntax requires us to render at <strong class="source-inline">INSERT</strong> something like <strong class="source-inline">?::"public"."rate_type"</strong>, as illustrated in the following code snippet:</p>
			<pre class="source-code">ctx.insertInto(SALE, SALE.FISCAL_YEAR, ..., SALE.RATE)</pre>
			<pre class="source-code">   .values(2005, ..., field("?::\"public\".\"rate_type\"", </pre>
			<pre class="source-code">           RateType.PLATINUM.name()))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>And at <strong class="source-inline">SELECT</strong>, we need an explicit coercing of <strong class="source-inline">Object</strong> to <strong class="source-inline">String</strong>, as illustrated in the following code snippet:</p>
			<pre class="source-code">List&lt;RateType&gt; rates = ctx.select(SALE.RATE)</pre>
			<pre class="source-code">   .from(SALE)</pre>
			<pre class="source-code">   .where(SALE.RATE.isNotNull())</pre>
			<pre class="source-code">   .fetch(SALE.RATE.coerce(String.class), RateType.class);</pre>
			<p>The application <a id="_idIndexMarker617"/>named <em class="italic">MyEnumBuiltInEnumConverter</em> contains complete examples for MySQL and PostgreSQL. If we <a id="_idIndexMarker618"/>don't suppress the jOOQ enum generation, then another approach consists of writing an explicit converter (by extending the jOOQ built-in <strong class="source-inline">org.jooq.impl.EnumConverter</strong> converter) between the jOOQ generated enum and our enum. Of course, this converter must be called explicitly in your queries. You can find such an example for the <strong class="source-inline">vat</strong> enum in the application mentioned earlier.</p>
			<h3>Using your own Java enum for a database non-enum type (or enum-like type)</h3>
			<p>Let's<a id="_idIndexMarker619"/> consider a legacy database containing <a id="_idIndexMarker620"/>a column that takes only certain values but was declared as <strong class="source-inline">VARCHAR</strong> (or <strong class="source-inline">NUMBER</strong>)—for instance, the <strong class="source-inline">SALE</strong> table has a <strong class="source-inline">TREND</strong> field of type <strong class="source-inline">VARCHAR</strong> that takes only the values <em class="italic">UP</em>, <em class="italic">DOWN</em>, and <em class="italic">CONSTANT</em>. In this context, it would be more practical to enforce the usage of this field via an enum, as shown here:</p>
			<pre class="source-code">public enum TrendType { UP, DOWN, CONSTANT }</pre>
			<p>But now, we have to handle the conversion between <strong class="source-inline">TrendType</strong> and <strong class="source-inline">VARCHAR</strong>. This can be done automatically by jOOQ if we add the following <strong class="source-inline">&lt;forcedType/&gt;</strong> tag (here, for Oracle):</p>
			<pre class="source-code">&lt;forcedType&gt;    </pre>
			<pre class="source-code">  &lt;userType&gt;com.classicmodels.enums.TrendType&lt;/userType&gt;     </pre>
			<pre class="source-code">  &lt;enumConverter&gt;true&lt;/enumConverter&gt;                                              </pre>
			<pre class="source-code">  &lt;includeExpression&gt;</pre>
			<pre class="source-code">    CLASSICMODELS\.SALE\.TREND</pre>
			<pre class="source-code">  &lt;/includeExpression&gt;                                            </pre>
			<pre class="source-code">  &lt;includeTypes&gt;VARCHAR2\(10\)&lt;/includeTypes&gt;</pre>
			<pre class="source-code">&lt;/forcedType&gt;</pre>
			<p>In the <em class="italic">SimpleBuiltInEnumConverter</em> application, you can see a complete example next to other examples for all four databases. </p>
			<p>Since <a id="_idIndexMarker621"/>SQL Server and Oracle don't have an<a id="_idIndexMarker622"/> enum type, we have used an alternative. Among others, a common alternative relies on a <strong class="source-inline">CHECK</strong> constraint to obtain an enum-like behavior. These enum-like types can take advantage of <strong class="source-inline">&lt;enumConverter/&gt;</strong> exactly as shown previously. Here, it is the <strong class="source-inline">SALE.VAT</strong> field in Oracle:</p>
			<pre class="source-code">vat VARCHAR2(10) DEFAULT NULL </pre>
			<pre class="source-code">  CHECK (vat IN('NONE', 'MIN', 'MAX'))</pre>
			<p>And here, it is the <strong class="source-inline">&lt;forcedType/&gt;</strong> tag:</p>
			<pre class="source-code">&lt;forcedType&gt;                                                                                                                                        </pre>
			<pre class="source-code">  &lt;userType&gt;com.classicmodels.enums.VatType&lt;/userType&gt;                                                                                                                                                                                 </pre>
			<pre class="source-code">  &lt;enumConverter&gt;true&lt;/enumConverter&gt;                                            </pre>
			<pre class="source-code">  &lt;includeExpression&gt;    </pre>
			<pre class="source-code">    CLASSICMODELS\.SALE\.VAT</pre>
			<pre class="source-code">  &lt;/includeExpression&gt;                                            </pre>
			<pre class="source-code">  &lt;includeTypes&gt;VARCHAR2\(10\)&lt;/includeTypes&gt;</pre>
			<pre class="source-code">&lt;/forcedType&gt;</pre>
			<p>If we don't want to rely on automatic conversion, then we can use an explicit converter, as follows:</p>
			<pre class="source-code">public class SaleStrTrendConverter </pre>
			<pre class="source-code">           extends EnumConverter&lt;String, TrendType&gt; {   </pre>
			<pre class="source-code">  public SaleStrTrendConverter() {</pre>
			<pre class="source-code">     super(String.class, TrendType.class);</pre>
			<pre class="source-code">  }        </pre>
			<pre class="source-code">}</pre>
			<p>In<a id="_idIndexMarker623"/> the <em class="italic">BuiltInEnumConverter</em> application, you<a id="_idIndexMarker624"/> can find a complete example next to other examples for all four databases. </p>
			<h3>Using a Java non-enum type for a database enum</h3>
			<p>Sometimes, we <a id="_idIndexMarker625"/>need a non-enum type for a database <a id="_idIndexMarker626"/>enum. For instance, let's assume that we want to use some integers in place of the <strong class="source-inline">VatType</strong> enum (<em class="italic">0</em> for <em class="italic">NONE</em>, <em class="italic">5</em> for <em class="italic">MIN</em>, and <em class="italic">19</em> for <em class="italic">MAX</em>) because we might need these integers in different computations.  Maybe the best idea is to write a converter that starts like this:</p>
			<pre class="source-code">public class SaleVatIntConverter </pre>
			<pre class="source-code">   extends EnumConverter&lt;VatType, Integer&gt; { … }</pre>
			<p>But this doesn't work, because the <strong class="source-inline">EnumConverter</strong> signature is actually of type <strong class="source-inline">EnumConverter&lt;T,</strong><strong class="source-inline">U extends Enum&lt;U&gt;&gt;</strong>. Obviously, <strong class="source-inline">Integer</strong> doesn't pass this signature since it doesn't extend <strong class="source-inline">java.lang.Enum</strong>, hence we can rely on a regular converter (as you saw in the previous section), as illustrated here:</p>
			<pre class="source-code">public class SaleVatIntConverter </pre>
			<pre class="source-code">   implements Converter&lt;VatType, Integer&gt; { … }</pre>
			<p>The <em class="italic">BuiltInEnumConverter</em> application <a id="_idIndexMarker627"/>contains this example <a id="_idIndexMarker628"/>next to other examples. Of course, you can try to write this converter as an inline converter via <strong class="source-inline">Converter.of()</strong>/<strong class="source-inline">ofNullable()</strong> or lambda expressions as well.</p>
			<h3>Always converting to a Java enum and occasionally to another Java enum</h3>
			<p>Always converting<a id="_idIndexMarker629"/> to a Java enum and occasionally to another Java enum is most probably not such a popular task, but let's use it as a pretext to condense what we've learned so far about<a id="_idIndexMarker630"/> enum conversions.</p>
			<p>Let's consider the well-known <strong class="source-inline">SALE.RATE</strong> enum field in MySQL. First, we want to always/automatically convert <strong class="source-inline">SALE.RATE</strong> to our <strong class="source-inline">RateType</strong> Java enum, shown here:</p>
			<pre class="source-code">public enum RateType { SILVER, GOLD, PLATINUM }</pre>
			<p>For this, we write the following <strong class="source-inline">&lt;forcedType/&gt;</strong> tag:</p>
			<pre class="source-code">&lt;forcedType&gt;</pre>
			<pre class="source-code">  &lt;userType&gt;com.classicmodels.enums.RateType&lt;/userType&gt;</pre>
			<pre class="source-code">  &lt;enumConverter&gt;true&lt;/enumConverter&gt;</pre>
			<pre class="source-code">  &lt;includeExpression&gt;</pre>
			<pre class="source-code">    classicmodels\.sale\.rate</pre>
			<pre class="source-code">  &lt;/includeExpression&gt;</pre>
			<pre class="source-code">  &lt;includeTypes&gt;ENUM&lt;/includeTypes&gt;</pre>
			<pre class="source-code">&lt;/forcedType&gt;</pre>
			<p>So far, we can refer in queries to <strong class="source-inline">SALE.RATE</strong> as a <strong class="source-inline">RateType</strong> enum, but let's assume that we also have the following <strong class="source-inline">StarType</strong> enum:</p>
			<pre class="source-code">public enum StarType { THREE_STARS, FOUR_STARS, FIVE_STARS }</pre>
			<p>Basically, <strong class="source-inline">StarType</strong> is an alternative to <strong class="source-inline">RateType</strong> (<em class="italic">THREE_STARS</em> corresponds to <em class="italic">SILVER</em>, <em class="italic">FOUR_STARS</em> to <em class="italic">GOLD</em>, and <em class="italic">FIVE_STARS</em> to <em class="italic">PLATINUM</em>). Now, we may occasionally want to use <strong class="source-inline">StarType</strong> in queries instead of <strong class="source-inline">RateType</strong>, therefore we need a converter, as follows:</p>
			<pre class="source-code">public class SaleRateStarConverter extends </pre>
			<pre class="source-code">                    EnumConverter&lt;RateType, StarType&gt; {</pre>
			<pre class="source-code">   public final static SaleRateStarConverter </pre>
			<pre class="source-code">      SALE_RATE_STAR_CONVERTER = new SaleRateStarConverter();</pre>
			<pre class="source-code">   public SaleRateStarConverter() {</pre>
			<pre class="source-code">      super(RateType.class, StarType.class);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   @Override</pre>
			<pre class="source-code">   public RateType to(StarType u) {</pre>
			<pre class="source-code">      if (u != null) {</pre>
			<pre class="source-code">         return switch (u) {</pre>
			<pre class="source-code">                case THREE_STARS -&gt; RateType.SILVER;</pre>
			<pre class="source-code">                case FOUR_STARS -&gt; RateType.GOLD;</pre>
			<pre class="source-code">                case FIVE_STARS -&gt; RateType.PLATINUM;</pre>
			<pre class="source-code">         };</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">      return null;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>Since <strong class="source-inline">RateType</strong> and <strong class="source-inline">StarType</strong> don't <a id="_idIndexMarker631"/>contain the same literals, we have to <a id="_idIndexMarker632"/>override the <strong class="source-inline">to()</strong> method and define the expected matches. Done!</p>
			<p>Expressing an <strong class="source-inline">INSERT</strong> statement that uses <strong class="source-inline">RateType</strong> looks like this:</p>
			<pre class="source-code">// rely on &lt;forcedType/&gt; </pre>
			<pre class="source-code">ctx.insertInto(SALE, SALE.FISCAL_YEAR, ,..., SALE.RATE)</pre>
			<pre class="source-code">   .values(2005, ..., RateType.PLATINUM)</pre>
			<pre class="source-code">   .execute();</pre>
			<p>And whenever we want to use <strong class="source-inline">StarType</strong> instead of <strong class="source-inline">RateType</strong>, we rely on the static <strong class="source-inline">SALE_RATE_STAR_CONVERTER</strong> converter, as shown here:</p>
			<pre class="source-code">// rely on SALE_RATE_STAR_CONVERTER</pre>
			<pre class="source-code">ctx.insertInto(SALE, SALE.FISCAL_YEAR, ..., SALE.RATE)</pre>
			<pre class="source-code">   .values(2005, ...,   </pre>
			<pre class="source-code">           SALE_RATE_STAR_CONVERTER.to(StarType.FIVE_STARS))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>The <em class="italic">BuiltInEnumConverter</em> application contains this example, along with other examples. </p>
			<p>Via <strong class="source-inline">classicmodels\.sale\.rate</strong>, we nominated a certain column (<strong class="source-inline">CLASSICMODELS.SALE.RATE</strong>), but we may want to pick up all columns of this enum type. In such cases, an SQL query is more proper than a regex. Here is such a query for Oracle:</p>
			<pre class="source-code">SELECT 'CLASSICMODELS.' || tab.table_name || '.' </pre>
			<pre class="source-code">                        || cols.column_name</pre>
			<pre class="source-code">FROM sys.all_tables tab</pre>
			<pre class="source-code">JOIN sys.all_constraints con ON tab.owner = con.owner</pre>
			<pre class="source-code">   AND tab.table_name = con.table_name</pre>
			<pre class="source-code">JOIN sys.all_cons_columns cols ON cols.owner = con.owner</pre>
			<pre class="source-code">   AND cols.constraint_name = con.constraint_name</pre>
			<pre class="source-code">   AND cols.table_name = con.table_name</pre>
			<pre class="source-code">WHERE constraint_type = 'C'</pre>
			<pre class="source-code">   AND tab.owner in ('CLASSICMODELS')</pre>
			<pre class="source-code">   AND search_condition_vc </pre>
			<pre class="source-code">      = q'[rate IN('SILVER', 'GOLD', 'PLATINUM')]'</pre>
			<p>You can find this example for MySQL and Oracle as <em class="italic">BuiltInEnumSqlConverter</em>.</p>
			<p>In the bundled<a id="_idIndexMarker633"/> code, there are more applications, such<a id="_idIndexMarker634"/> as <em class="italic">EnumConverter</em>, which has examples of plain <strong class="source-inline">org.jooq.Converter</strong> types for enums; <em class="italic">EnumConverterForceTypes</em>, which has <strong class="source-inline">&lt;forcedType/&gt;</strong> and enum examples; and <strong class="source-inline">I</strong><em class="italic">nsertEnumPlainSql</em>, which has <strong class="source-inline">INSERT</strong> and enum examples when the jOOQ Code Generator is not used.</p>
			<h3>Retrieving the DataType&lt;T&gt; tag for a given enum data type</h3>
			<p>Retrieving <a id="_idIndexMarker635"/>the <strong class="source-inline">DataType&lt;T&gt;</strong> tag for a given <a id="_idIndexMarker636"/>enum data type can be done as in the following three examples that speak for themselves:</p>
			<pre class="source-code">DataType&lt;RateType&gt; RATETYPE = SALE.RATE.getDataType();</pre>
			<pre class="source-code">DataType&lt;VatType&gt; VATTYPE </pre>
			<pre class="source-code">  = VARCHAR.asEnumDataType(VatType.class);</pre>
			<pre class="source-code">DataType&lt;com.classicmodels.enums.VatType&gt; VATTYPE</pre>
			<pre class="source-code">  = VARCHAR.asEnumDataType(jooq.generated.enums.VatType.class)</pre>
			<pre class="source-code">    .asConvertedDataType(VAT_CONVERTER);</pre>
			<p>Now, you can use this data type as any other data type. Next, let's tackle the topic of data type rewrites.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor122"/>Data type rewrites</h1>
			<p>Another <a id="_idIndexMarker637"/>utility of <strong class="source-inline">&lt;forcedTypes/&gt;</strong> is data type rewrites. This allows us to explicitly choose the SQL data type (supported by the database, or unsupported but present in <strong class="source-inline">org.jooq.impl.SQLDataType</strong>) that should be used in Java. </p>
			<p>For instance, in Oracle, a common use case is to map the missing <strong class="source-inline">BOOLEAN</strong> type as <strong class="source-inline">NUMBER(1,0)</strong> or <strong class="source-inline">CHAR(1)</strong>, as follows:</p>
			<pre class="source-code">CREATE TABLE sale (</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  hot NUMBER(1,0) DEFAULT 0</pre>
			<pre class="source-code">  hot CHAR(1) DEFAULT '1' CHECK (hot IN('1', '0'))</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">}</pre>
			<p>But this means that the jOOQ Code Generator will map fields of type <strong class="source-inline">NUMBER(1, 0)</strong> to the <strong class="source-inline">SQLDataType.TINYINT</strong> SQL data type and the <strong class="source-inline">java.lang.Byte</strong> type and, respectively, the fields of type <strong class="source-inline">CHAR(1)</strong> to the <strong class="source-inline">SQLDataType.CHAR</strong> SQL data type and the <strong class="source-inline">String</strong> Java type.</p>
			<p>But the Java <strong class="source-inline">String</strong> type is commonly associated with text data manipulation, while the <strong class="source-inline">Byte</strong> type is commonly associated with binary data manipulations (for example, reading/writing a binary file) and the Java <strong class="source-inline">Boolean</strong> type clearly communicates the intention of using flag-type data. Moreover, the Java <strong class="source-inline">Boolean</strong> type has an SQL type (standard JDBC type) homologous to <strong class="source-inline">SQLDataType.BOOLEAN</strong>. </p>
			<p>jOOQ allows us to force the type of columns, therefore we can force the type of <strong class="source-inline">SALE.HOT</strong> to <strong class="source-inline">BOOLEAN</strong>, as follows:</p>
			<pre class="source-code">&lt;forcedType&gt;</pre>
			<pre class="source-code">  &lt;name&gt;BOOLEAN&lt;/name&gt;</pre>
			<pre class="source-code">  &lt;includeExpression&gt;CLASSICMODELS\.SALE\.HOT&lt;/includeExpression&gt;</pre>
			<pre class="source-code">  &lt;includeTypes&gt;NUMBER\(1,\s*0\)&lt;/includeTypes&gt;</pre>
			<pre class="source-code">  &lt;includeTypes&gt;CHAR\(1\)&lt;/includeTypes&gt;</pre>
			<pre class="source-code">&lt;/forcedType&gt;</pre>
			<p>Done! Now, we can treat <strong class="source-inline">SALE.HOT</strong> as a Java <strong class="source-inline">Boolean</strong> type. Here is an <strong class="source-inline">INSERT</strong> example:</p>
			<pre class="source-code">ctx.insertInto(SALE, ..., SALE.HOT)</pre>
			<pre class="source-code">   .values(2005,..., Boolean.FALSE)</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Depending on <strong class="source-inline">NUMBER</strong> precision, jOOQ will map this data type to <strong class="source-inline">BigInteger</strong>, <strong class="source-inline">Short</strong>, or even <strong class="source-inline">Byte</strong> (as you just saw). If you find it cumbersome to use such Java types and you know that your data fits better for <strong class="source-inline">Long</strong> or <strong class="source-inline">Integer</strong> types, then you have two options: adjust the <strong class="source-inline">NUMBER</strong> precision accordingly, or rely on jOOQ type rewriting. Of course, you<a id="_idIndexMarker638"/> can apply this technique to any other type and dialect.</p>
			<p>A complete example can be found in <em class="italic">DataTypeRewriting</em>. The programmatic version of this example is called <em class="italic">ProgrammaticDataTypeRewriting</em>. Next, let's understand how you can handle jOOQ embeddable types.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor123"/>Handling embeddable types</h1>
			<p>Embeddable types <a id="_idIndexMarker639"/>represent a powerful feature introduced in jOOQ 3.14. Roughly, this feature gets materialized in synthetic UDTs that can be used with all databases supported by jOOQ. While PostgreSQL and Oracle support UDTs (we can use UDTs <a id="_idIndexMarker640"/>directly in <strong class="bold">Data Definition Language</strong> (<strong class="bold">DDL</strong>)), other databases including MySQL and SQL Server don't support UDTs. But via jOOQ embeddable types, we can work at the application level with synthetic UDTs for any database, and jOOQ will take care of the underlying aspects of mapping these types to the database. </p>
			<p>An embeddable type mimics a UDT by synthetically wrapping one (usually more) database column in a generated <strong class="source-inline">org.jooq.EmbeddableRecord</strong>. For instance, we can wrap <strong class="source-inline">OFFICE.CITY</strong>, <strong class="source-inline">OFFICE.STATE</strong>, <strong class="source-inline">OFFICE.COUNTRY</strong>, <strong class="source-inline">OFFICE.TERRITORY</strong>, and <strong class="source-inline">OFFICE.ADDRESS_LINE_FIRST</strong> under an embeddable type named <strong class="source-inline">OFFICE_FULL_ADDRESS</strong> via the following configuration in the jOOQ Code Generator (here, for MySQL):</p>
			<pre class="source-code">&lt;embeddable&gt;</pre>
			<pre class="source-code"> &lt;!-- The optional catalog of the embeddable type --&gt;</pre>
			<pre class="source-code"> &lt;catalog/&gt;</pre>
			<pre class="source-code">                                            </pre>
			<pre class="source-code"> &lt;!-- The optional schema of the embeddable type --&gt;</pre>
			<pre class="source-code"> &lt;schema&gt;classicmodels&lt;/schema&gt;</pre>
			<pre class="source-code">                                            </pre>
			<pre class="source-code"> &lt;!-- The name of the embeddable type --&gt;</pre>
			<pre class="source-code"> &lt;name&gt;OFFICE_FULL_ADDRESS&lt;/name&gt;</pre>
			<pre class="source-code">                                            </pre>
			<pre class="source-code"> &lt;!-- An optional, defining comment of an embeddable --&gt;</pre>
			<pre class="source-code"> &lt;comment&gt;The full address of an office&lt;/comment&gt;</pre>
			<pre class="source-code">                                            </pre>
			<pre class="source-code"> &lt;!-- The name of the reference to the embeddable type --&gt;</pre>
			<pre class="source-code"> &lt;referencingName/&gt;</pre>
			<pre class="source-code">                                            </pre>
			<pre class="source-code"> &lt;!-- An optional, referencing comment of an embeddable --&gt;</pre>
			<pre class="source-code"> &lt;referencingComment/&gt;</pre>
			<p>And we continue<a id="_idIndexMarker641"/> with the settings for matching tables and fields, as follows:</p>
			<pre class="source-code"> &lt;!-- A regular expression matching qualified/unqualified </pre>
			<pre class="source-code">      table names to which to apply this embeddable. If left </pre>
			<pre class="source-code">      blank, this will apply to all tables --&gt;</pre>
			<pre class="source-code"> &lt;tables&gt;.*\.office&lt;/tables&gt;</pre>
			<pre class="source-code">                                            </pre>
			<pre class="source-code"> &lt;!-- A list of fields to match to an embeddable. Each field   </pre>
			<pre class="source-code">      must match exactly one column in each matched table. A </pre>
			<pre class="source-code">      mandatory regular expression matches field names, and  </pre>
			<pre class="source-code">      an optional name can be provided to define the </pre>
			<pre class="source-code">      embeddable attribute name. If no name is provided, then </pre>
			<pre class="source-code">      the first matched field's name will be taken --&gt;</pre>
			<pre class="source-code"> &lt;fields&gt;</pre>
			<pre class="source-code">  &lt;field&gt;&lt;expression&gt;CITY&lt;/expression&gt;&lt;/field&gt;                                              </pre>
			<pre class="source-code">  &lt;field&gt;&lt;expression&gt;ADDRESS_LINE_FIRST&lt;/expression&gt;&lt;/field&gt;</pre>
			<pre class="source-code">  &lt;field&gt;&lt;expression&gt;STATE&lt;/expression&gt;&lt;/field&gt;</pre>
			<pre class="source-code">  &lt;field&gt;&lt;expression&gt;COUNTRY&lt;/expression&gt;&lt;/field&gt;                                                </pre>
			<pre class="source-code">  &lt;field&gt;&lt;expression&gt;TERRITORY&lt;/expression&gt;&lt;/field&gt;</pre>
			<pre class="source-code"> &lt;/fields&gt;                                                                             &lt;/embeddable&gt;                                        </pre>
			<p>Next, jOOQ<a id="_idIndexMarker642"/> generates <strong class="source-inline">jooq...records.OfficeFullAddressRecord</strong>, which extends <strong class="source-inline">EmbeddableRecordImpl</strong> and <strong class="source-inline">jooq...pojos.OfficeFullAddress</strong>. Moreover, in the generated <strong class="source-inline">Office</strong> table, we observe a new <strong class="source-inline">OFFICE_FULL_ADDRESS</strong> field that can be used as in the following <strong class="source-inline">INSERT</strong> statement:</p>
			<pre class="source-code">ctx.insertInto(OFFICE, ... ,</pre>
			<pre class="source-code">               OFFICE.ADDRESS_LINE_SECOND, ...)</pre>
			<pre class="source-code">   .values(...,</pre>
			<pre class="source-code">           new OfficeFullAddressRecord("Naples", "Giuseppe </pre>
			<pre class="source-code">              Mazzini", "Campania", "Italy", "N/A"),</pre>
			<pre class="source-code">           ...)</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Obviously, the <strong class="source-inline">OFFICE_FULL_ADDRESS</strong> column can be used in all types of statements, including <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, <strong class="source-inline">DELETE</strong>, and <strong class="source-inline">SELECT</strong>. Here, it is used in a <strong class="source-inline">SELECT</strong> statement:</p>
			<pre class="source-code">Result&lt;Record1&lt;OfficeFullAddressRecord&gt;&gt; result </pre>
			<pre class="source-code">       = ctx.select(OFFICE.OFFICE_FULL_ADDRESS).from(OFFICE)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Or it can be fetched into the <strong class="source-inline">OfficeFullAddress</strong> POJO, like this:</p>
			<pre class="source-code">List&lt;OfficeFullAddress&gt; result </pre>
			<pre class="source-code">   = ctx.select(OFFICE.OFFICE_FULL_ADDRESS).from(OFFICE)</pre>
			<pre class="source-code">        .fetchInto(OfficeFullAddress.class);</pre>
			<p>In the bundled<a id="_idIndexMarker643"/> code, for MySQL, we have <em class="italic">EmbeddableType</em>, which contains the previous example, and for PostgreSQL, we have <em class="italic">ProgrammaticEmbeddableType</em>, which is the programmatic version of the previous example.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/>Replacing fields</h2>
			<p>At this point, we have <a id="_idIndexMarker644"/>access to (we can use) the embeddable type, but we still have direct access to fields wrapped in this embeddable type. For instance, these fields can be used in <strong class="source-inline">INSERT</strong> statements, <strong class="source-inline">SELECT</strong> statements, and so on, and they appear in the <strong class="bold">Integrated Development Environment's</strong> (<strong class="bold">IDE's</strong>) autocompletion list.</p>
			<p>The <em class="italic">replacing fields</em> feature means to signal to jOOQ to disallow direct access to fields that are part of an embeddable type. These fields will not appear in the IDE's autocompletion list anymore, and the result set of <strong class="source-inline">SELECT</strong> statements will not contain these fields. Enabling this feature can be done via the <strong class="source-inline">&lt;replacesFields/&gt;</strong> flag, as follows:</p>
			<pre class="source-code">&lt;embeddable&gt;</pre>
			<pre class="source-code"> ...</pre>
			<pre class="source-code"> &lt;replacesFields&gt;true&lt;/replacesFields&gt;</pre>
			<pre class="source-code">&lt;/embeddable&gt;</pre>
			<p>The <em class="italic">EmbeddableTypeReplaceFields </em>application<a id="_idIndexMarker645"/> contains this example for Oracle, while <em class="italic">ProgrammaticEmbeddableTypeReplaceFields</em> contains a programmatic version of this example for SQL Server.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor125"/>Converting embeddable types</h2>
			<p>Converting an <a id="_idIndexMarker646"/>embeddable type can be done via <strong class="source-inline">org.jooq.Converter</strong>, as for any other type. For example, converting between <strong class="source-inline">JsonNode</strong> and <strong class="source-inline">OFFICE_FULL_ADDRESS</strong> can be done via a <strong class="source-inline">Converter</strong> that starts like this:</p>
			<pre class="source-code">public class JsonConverter implements   </pre>
			<pre class="source-code">           Converter&lt;OfficeFullAddressRecord, JsonNode&gt; {</pre>
			<pre class="source-code">   public static final JsonConverter JSON_CONVERTER </pre>
			<pre class="source-code">      = new JsonConverter();</pre>
			<pre class="source-code">   @Override</pre>
			<pre class="source-code">   public JsonNode from(OfficeFullAddressRecord t) { ... }</pre>
			<pre class="source-code">   @Override </pre>
			<pre class="source-code">   public OfficeFullAddressRecord to(JsonNode u) { ... }</pre>
			<pre class="source-code">   ...</pre>
			<pre class="source-code">}</pre>
			<p>And here, it is a <strong class="source-inline">SELECT</strong> statement that fetches <strong class="source-inline">OFFICE.OFFICE_FULL_ADDRESS</strong> as <strong class="source-inline">JsonNode</strong> via <strong class="source-inline">JSON_CONVERTER</strong>:</p>
			<pre class="source-code">List&lt;JsonNode&gt; result = ctx.select(OFFICE.OFFICE_FULL_ADDRESS)</pre>
			<pre class="source-code">   .from(OFFICE)</pre>
			<pre class="source-code">   .fetch(OFFICE.OFFICE_FULL_ADDRESS, JSON_CONVERTER);</pre>
			<p>The <em class="italic">ConvertEmbeddableType</em> application<a id="_idIndexMarker647"/> for MySQL contains this example.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor126"/>Embedded domains</h2>
			<p>Quite popular<a id="_idIndexMarker648"/> in PostgreSQL, <em class="italic">domain</em> types represent UDTs built on top of other types and containing optional constraints. For instance, in our PostgreSQL schema, we have the following domain:</p>
			<pre class="source-code">CREATE DOMAIN postal_code AS varchar(15)</pre>
			<pre class="source-code">CHECK(</pre>
			<pre class="source-code">   VALUE ~ '^\d{5}$'</pre>
			<pre class="source-code">OR VALUE ~ '^[A-Z]{2}[0-9]{3}[A-Z]{2}$'</pre>
			<pre class="source-code">);</pre>
			<p>And it is used in the <strong class="source-inline">office</strong> table, as shown here:</p>
			<pre class="source-code">CREATE TABLE office (</pre>
			<pre class="source-code">  ... </pre>
			<pre class="source-code">  "postal_code" postal_code NOT NULL,</pre>
			<pre class="source-code">  ... </pre>
			<pre class="source-code">);</pre>
			<p>jOOQ can generate a Java type for each domain type if we turn on this feature, as has been done here:</p>
			<pre class="source-code">// Maven and standalone</pre>
			<pre class="source-code">&lt;database&gt;                               </pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  &lt;embeddableDomains&gt;.*&lt;/embeddableDomains&gt;</pre>
			<pre class="source-code">&lt;/database&gt;</pre>
			<pre class="source-code">// Gradle</pre>
			<pre class="source-code">database {</pre>
			<pre class="source-code">  embeddableDomains = '.*'</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">// programmatic</pre>
			<pre class="source-code">withEmbeddableDomains(".*")</pre>
			<p>While <strong class="source-inline">.*</strong> matches all<a id="_idIndexMarker649"/> domain types, you can use more restrictive regexes to match exactly the domains that will be replaced by embeddable types. </p>
			<p>The jOOQ Code Generator generates an embeddable type named (by default) <strong class="source-inline">PostalCodeRecord</strong> (in <strong class="source-inline">jooq.generated.embeddables.records</strong>). We can use it for creating semantically type-safe queries, as in these examples:</p>
			<pre class="source-code">ctx.select(OFFICE.CITY, OFFICE.COUNTRY)</pre>
			<pre class="source-code">   .from(OFFICE)</pre>
			<pre class="source-code">   .where(OFFICE.POSTAL_CODE.in(</pre>
			<pre class="source-code">        new PostalCodeRecord("AZ934VB"),</pre>
			<pre class="source-code">        new PostalCodeRecord("DT975HH")))</pre>
			<pre class="source-code">   .fetch();</pre>
			<pre class="source-code">ctx.insertInto(OFFICE, ..., OFFICE.POSTAL_CODE, ...)</pre>
			<pre class="source-code">   .values(..., new PostalCodeRecord("OP909DD"), ...)</pre>
			<pre class="source-code">   .execute();</pre>
			<p>The complete code for <a id="_idIndexMarker650"/>PostgreSQL is named <em class="italic">Domain</em>.</p>
			<p>Well, we've reached the end of this section and the end of this chapter. Notice that we intentionally skipped the topic of embeddable types and embeddable keys (including composite keys) since this topic is covered later in <a href="B16833_11.xhtml#_idTextAnchor209"><em class="italic">Chapter 11</em></a>, <em class="italic">jOOQ Keys</em>. </p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor127"/>Summary</h1>
			<p>This chapter is a must-have in your jOOQ arsenal. Mastering the topics covered here—such as custom data types, converters, bindings, database vendor-specific data types, enums, embeddable types, and so on—will help you to shape the interaction between Java and database data types to fit your non-trivial scenarios. In the next chapter, we cover the topics of fetching and mapping.</p>
		</div>
	</body></html>