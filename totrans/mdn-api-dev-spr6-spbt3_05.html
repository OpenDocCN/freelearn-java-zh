<html><head></head><body>
<div id="_idContainer018">
<h1 class="chapter-number" id="_idParaDest-117"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-118"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.2.1">Asynchronous API Design</span></h1>
<p><span class="koboSpan" id="kobo.3.1">So far, we have developed RESTful web services based on the imperative model, where calls are synchronous. </span><span class="koboSpan" id="kobo.3.2">What if you want to make code async and non-blocking? </span><span class="koboSpan" id="kobo.3.3">This is what we are going to do in this chapter. </span><span class="koboSpan" id="kobo.3.4">You’ll learn about asynchronous API design in this chapter, where calls</span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.4.1"> are asynchronous</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.5.1"> and non-blocking. </span><span class="koboSpan" id="kobo.5.2">We’ll develop these APIs using Spring </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">WebFlux</span></strong><span class="koboSpan" id="kobo.7.1">, which is based on Project Reactor (</span><a href="https://projectreactor.io"><span class="koboSpan" id="kobo.8.1">https://projectreactor.io</span></a><span class="koboSpan" id="kobo.9.1">). </span><span class="koboSpan" id="kobo.9.2">Reactor is a library for building non-blocking apps on a </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">Java virtual </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.11.1">machine</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.12.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.13.1">JVM</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">First, we’ll walk through the reactive programming fundamentals, and then we’ll migrate the existing e-commerce REST API (which we learned about in </span><a href="B19349_04.xhtml#_idTextAnchor097"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.16.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.17.1">, </span><em class="italic"><span class="koboSpan" id="kobo.18.1">Writing Business Logic for APIs</span></em><span class="koboSpan" id="kobo.19.1">) to an asynchronous (reactive) API to make things easier by comparing the existing (imperative) way and reactive way of programming. </span><span class="koboSpan" id="kobo.19.2">The code will make use of R2DBC for database persistence, which supports </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">reactive programming.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">We’ll discuss the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.23.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">Reactive Streams</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Exploring </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">Spring WebFlux</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Understanding </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.28.1">DispatcherHandler</span></strong></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.29.1">Controllers</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.30.1">Functional endpoints</span></span></li>
<li><span class="koboSpan" id="kobo.31.1">Implementing reactive APIs for our </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">e-commerce app</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.33.1">By the end of this chapter, you will have learned how to develop and implement reactive APIs and explored async APIs. </span><span class="koboSpan" id="kobo.33.2">You will also be able to implement reactive controllers and functional endpoints and make use of R2DBC for </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">database persistence.</span></span></p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.35.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.36.1">The code for this chapter is available </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05"><span class="No-Break"><span class="koboSpan" id="kobo.38.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.39.1">.</span></span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.40.1">Understanding Reactive Streams</span></h1>
<p><span class="koboSpan" id="kobo.41.1">Normal Java code achieves asynchronicity by using</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.42.1"> thread pools. </span><span class="koboSpan" id="kobo.42.2">Your web server uses a thread pool to serve requests – it assigns a thread to each incoming request. </span><span class="koboSpan" id="kobo.42.3">The application uses the thread pool for database connections too. </span><span class="koboSpan" id="kobo.42.4">Each database call uses a separate thread and waits for the result. </span><span class="koboSpan" id="kobo.42.5">Therefore, each web request and database call uses its own thread. </span><span class="koboSpan" id="kobo.42.6">However, there is a wait associated with this and, therefore, these are blocking calls. </span><span class="koboSpan" id="kobo.42.7">The thread waits and utilizes the resources until a response is received back from the database or a response object is written. </span><span class="koboSpan" id="kobo.42.8">This is kind of a limitation when you scale as you can only use the resources available to the JVM. </span><span class="koboSpan" id="kobo.42.9">You overcome this limitation by using a load balancer with other instances of the service, which is a type of </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">horizontal scaling.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">In the last decade, there has been a rise in client-server architecture. </span><span class="koboSpan" id="kobo.44.2">Lots of IoT-enabled devices, smartphones that have native apps, first-class web apps, and traditional web applications have emerged. </span><span class="koboSpan" id="kobo.44.3">Applications not only have third-party services but also have various sources of data, which leads to higher-scale applications. </span><span class="koboSpan" id="kobo.44.4">On top of that, microservice-based architecture has increased communication among services themselves. </span><span class="koboSpan" id="kobo.44.5">You need lots of resources to serve this higher network communication demand. </span><span class="koboSpan" id="kobo.44.6">This makes scaling a necessity. </span><span class="koboSpan" id="kobo.44.7">Threads are expensive and not infinite. </span><span class="koboSpan" id="kobo.44.8">You don’t want to block them for effective utilization. </span><span class="koboSpan" id="kobo.44.9">For example, let’s say your code is calling the database for data. </span><span class="koboSpan" id="kobo.44.10">In this case, the call waits until you get the response in the blocking call. </span><span class="koboSpan" id="kobo.44.11">However, a non-blocking call doesn’t block anything. </span><span class="koboSpan" id="kobo.44.12">It responds only when a response is received from the dependent code (the database in this case). </span><span class="koboSpan" id="kobo.44.13">The system can serve other calls during this time. </span><span class="koboSpan" id="kobo.44.14">This is where asynchronicity helps. </span><span class="koboSpan" id="kobo.44.15">In asynchronous calls, threads become free as soon as a call is done and use a callback utility (common in JavaScript). </span><span class="koboSpan" id="kobo.44.16">When data is available</span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.45.1"> at the source, it pushes the data. </span><span class="koboSpan" id="kobo.45.2">Project Reactor is based on </span><strong class="bold"><span class="koboSpan" id="kobo.46.1">Reactive Streams</span></strong><span class="koboSpan" id="kobo.47.1">. </span><span class="koboSpan" id="kobo.47.2">Reactive Streams uses the </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">publisher-subscriber model</span></strong><span class="koboSpan" id="kobo.49.1">, where the source of data, the publisher, pushes the data to </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">the subscriber.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">You might be aware that, on the other hand, Node.js uses a single thread to make use of most resources. </span><span class="koboSpan" id="kobo.51.2">It is based</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.52.1"> on an asynchronous non-blocking design, known as an </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.53.1">event loop</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">Reactive APIs are also based </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.56.1">on an event loop design and use push-style notifications. </span><span class="koboSpan" id="kobo.56.2">If you look closely, Reactive Streams also supports Java stream (a sequence of objects pipelined to produce the desired results by performing various operations) operations, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">map</span></strong><span class="koboSpan" id="kobo.58.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">flatMap</span></strong><span class="koboSpan" id="kobo.60.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">filter</span></strong><span class="koboSpan" id="kobo.62.1">. </span><span class="koboSpan" id="kobo.62.2">Internally, Reactive Streams uses a push style, whereas Java streams work according to a pull model; that is, items are pulled from the source, such as a Java collection. </span><span class="koboSpan" id="kobo.62.3">In reactive programming, the source (publisher) pushes </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">the data.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">In Reactive Streams, streams of data are asynchronous and non-blocking and support backpressure. </span><span class="koboSpan" id="kobo.64.2">(Refer to the </span><em class="italic"><span class="koboSpan" id="kobo.65.1">Subscriber</span></em><span class="koboSpan" id="kobo.66.1"> subsection of this chapter for an explanation </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">of backpressure.)</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">There are four basic types of interfaces as per the Reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">Streams specification:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.70.1">Publisher</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.71.1">Subscriber</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.72.1">Subscription</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.73.1">Processor</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.74.1">Let’s have a look at each of </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">these types.</span></span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.76.1">Publisher</span></h2>
<p><span class="koboSpan" id="kobo.77.1">A publisher provides a stream of data</span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.78.1"> to one or more</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.79.1"> subscribers. </span><span class="koboSpan" id="kobo.79.2">A subscriber uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">subscribe()</span></strong><span class="koboSpan" id="kobo.81.1"> method to subscribe to a publisher. </span><span class="koboSpan" id="kobo.81.2">Each subscriber should only subscribe once to </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">a publisher.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">Most importantly, the publisher pushes data according to the demand received from subscribers. </span><span class="koboSpan" id="kobo.83.2">Reactive Streams are lazy; therefore, the publisher will only push an element if there is </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">a subscriber.</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">Publisher</span></strong><span class="koboSpan" id="kobo.87.1"> interface is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.89.1">
package </span><strong class="bold"><span class="koboSpan" id="kobo.90.1">org.reactivestreams</span></strong><span class="koboSpan" id="kobo.91.1">;// T – type of element Publisher sends
public interface </span><strong class="bold"><span class="koboSpan" id="kobo.92.1">Publisher</span></strong><span class="koboSpan" id="kobo.93.1">&lt;T&gt; {
  public void subscribe(Subscriber&lt;? </span><span class="koboSpan" id="kobo.93.2">super T&gt; s); }</span></pre>
<p><span class="koboSpan" id="kobo.94.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">Publisher</span></strong><span class="koboSpan" id="kobo.96.1"> interface contains</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.97.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">subscribe</span></strong><span class="koboSpan" id="kobo.99.1"> method. </span><span class="koboSpan" id="kobo.99.2">Let’s find out about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">Subscriber</span></strong><span class="koboSpan" id="kobo.101.1"> type</span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.102.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">next subsection.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.104.1">Subscriber</span></h2>
<p><span class="koboSpan" id="kobo.105.1">The subscriber </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.106.1">consumes the data pushed by the publisher. </span><span class="koboSpan" id="kobo.106.2">Publisher-subscriber</span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.107.1"> communication works </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.109.1">When a </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">Subscriber</span></strong><span class="koboSpan" id="kobo.111.1"> instance is passed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">Publisher.subscribe()</span></strong><span class="koboSpan" id="kobo.113.1"> method, it triggers the </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">onSubscribe()</span></strong><span class="koboSpan" id="kobo.115.1"> method. </span><span class="koboSpan" id="kobo.115.2">It contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">Subscription</span></strong><span class="koboSpan" id="kobo.117.1"> parameter, which controls the backpressure, that is, how much data a subscriber demands from </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">the publisher.</span></span></li>
<li><span class="koboSpan" id="kobo.119.1">After the first step, </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">Publisher</span></strong><span class="koboSpan" id="kobo.121.1"> waits for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">Subscription.request(long)</span></strong><span class="koboSpan" id="kobo.123.1"> call. </span><span class="koboSpan" id="kobo.123.2">It only pushes data to </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">Subscriber</span></strong><span class="koboSpan" id="kobo.125.1"> after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">Subscription.request()</span></strong><span class="koboSpan" id="kobo.127.1"> call is made. </span><span class="koboSpan" id="kobo.127.2">This method indicates to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">Publisher</span></strong><span class="koboSpan" id="kobo.129.1"> how many items the subscriber is ready to receive at </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">a time.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.131.1">Normally, the publisher pushes the data to the subscriber, irrespective of whether the subscriber can handle it safely or not. </span><span class="koboSpan" id="kobo.131.2">However, the subscriber knows best how much data it can handle safely; therefore, in Reactive Streams, </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">Subscriber</span></strong><span class="koboSpan" id="kobo.133.1"> uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">Subscription</span></strong><span class="koboSpan" id="kobo.135.1"> instance to communicate</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.136.1"> the demand</span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.137.1"> for the number of elements to </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">Publisher</span></strong><span class="koboSpan" id="kobo.139.1">. </span><span class="koboSpan" id="kobo.139.2">This is known as </span><strong class="bold"><span class="koboSpan" id="kobo.140.1">back-pressure</span></strong><span class="koboSpan" id="kobo.141.1"> or </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.142.1">flow control</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">You must be wondering, what if </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">Publisher</span></strong><span class="koboSpan" id="kobo.146.1"> asks </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">Subscriber</span></strong><span class="koboSpan" id="kobo.148.1"> to slow down but it can’t? </span><span class="koboSpan" id="kobo.148.2">In that case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">Publisher</span></strong><span class="koboSpan" id="kobo.150.1"> must decide whether to fail, drop, </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">or buffer.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.152.1">Once the demand is made in </span><em class="italic"><span class="koboSpan" id="kobo.153.1">step 2</span></em><span class="koboSpan" id="kobo.154.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">Publisher</span></strong><span class="koboSpan" id="kobo.156.1"> sends the data notifications and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">onNext()</span></strong><span class="koboSpan" id="kobo.158.1"> method is used to consume the data. </span><span class="koboSpan" id="kobo.158.2">This method will be triggered until the data notifications are pushed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">Publisher</span></strong><span class="koboSpan" id="kobo.160.1"> according to the demand communicated </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">Subscription.request()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.164.1">At the end, either </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">onError()</span></strong><span class="koboSpan" id="kobo.166.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">onCompletion()</span></strong><span class="koboSpan" id="kobo.168.1"> will be triggered as the terminal state. </span><span class="koboSpan" id="kobo.168.2">No notification will be sent after one of these invocations has been triggered even if you call </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">Subscription.request()</span></strong><span class="koboSpan" id="kobo.170.1">. </span><span class="koboSpan" id="kobo.170.2">The following are the </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">terminal methods:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">onError()</span></strong><span class="koboSpan" id="kobo.173.1"> will be invoked the moment any </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">error occurs</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">onCompletion()</span></strong><span class="koboSpan" id="kobo.176.1"> will be invoked when all elements </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">are pushed</span></span></li></ul></li>
</ol>
<p><span class="koboSpan" id="kobo.178.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">Subscriber</span></strong><span class="koboSpan" id="kobo.180.1"> interface</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.181.1"> is defined</span><a id="_idIndexMarker294"/> <span class="No-Break"><span class="koboSpan" id="kobo.182.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.183.1">
package org.reactivestreams;// T – type of element Publisher sends
public interface Subscriber&lt;T&gt; {
  public void onSubscribe(Subscription s);
  public void onNext(T t);
  public void onError(Throwable t);
  public void onComplete();
}</span></pre>
<h2 id="_idParaDest-123"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.184.1">Subscription</span></h2>
<p><span class="koboSpan" id="kobo.185.1">A subscription</span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.186.1"> is a mediator between the publisher</span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.187.1"> and subscriber. </span><span class="koboSpan" id="kobo.187.2">It is the subscriber’s responsibility to invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">Subscription.subscriber()</span></strong><span class="koboSpan" id="kobo.189.1"> method and let the publisher know of the demand. </span><span class="koboSpan" id="kobo.189.2">It can be invoked as and when required by </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">the subscriber.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">cancel()</span></strong><span class="koboSpan" id="kobo.193.1"> method asks the publisher to stop sending data notifications and to clean up </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">the resources.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">A subscription</span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.196.1"> is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.198.1">
package org.reactivestreams;public interface Subscription {
  public void request(long n);
  public void cancel();
}</span></pre>
<h2 id="_idParaDest-124"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.199.1">Processor</span></h2>
<p><span class="koboSpan" id="kobo.200.1">The processor</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.201.1"> is a bridge between the publisher and subscriber </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.202.1">and represents the processing stage. </span><span class="koboSpan" id="kobo.202.2">It works as both a publisher and subscriber and obeys the contract defined by both. </span><span class="koboSpan" id="kobo.202.3">It is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.204.1">
package org.reactivestreams;public interface Processor&lt;T, R&gt;
  extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; {
}</span></pre>
<p><span class="koboSpan" id="kobo.205.1">Let’s have a look at the following example. </span><span class="koboSpan" id="kobo.205.2">Here, we are creating </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">Flux</span></strong><span class="koboSpan" id="kobo.207.1"> by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">Flux.just()</span></strong><span class="koboSpan" id="kobo.209.1"> static factory method. </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">Flux</span></strong><span class="koboSpan" id="kobo.211.1"> is a type of publisher in Project Reactor. </span><span class="koboSpan" id="kobo.211.2">This publisher contains four integer elements. </span><span class="koboSpan" id="kobo.211.3">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">reduce</span></strong><span class="koboSpan" id="kobo.213.1"> operator (like we do in Java streams) to perform a </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">sum</span></strong><span class="koboSpan" id="kobo.215.1"> operation </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">on it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.217.1">
Flux&lt;Integer&gt; fluxInt = Flux.just(1, 10, 100, 1000).log();fluxInt.reduce(Integer::sum)
  .</span><strong class="bold"><span class="koboSpan" id="kobo.218.1">subscribe</span></strong><span class="koboSpan" id="kobo.219.1">(sum -&gt;
      System.out.printf("Sum is: %d", sum));</span></pre>
<p><span class="koboSpan" id="kobo.220.1">When you run the previous code, it prints the </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.222.1">
11:00:38.074 [main] INFO reactor.Flux.Array.1 - | onSubscribe([Synchronous Fuseable] FluxArray.ArraySubscription)11:00:38.074 [main] INFO reactor.Flux.Array.1 - |</span><strong class="bold"><span class="koboSpan" id="kobo.223.1">request(unbounded)</span></strong><span class="koboSpan" id="kobo.224.1">
11:00:38.084 [main] INFO reactor.Flux.Array.1 - | onNext(1)
11:00:38.084 [main] INFO reactor.Flux.Array.1 - | onNext(10)
11:00:38.084 [main] INFO reactor.Flux.Array.1 - | onNext(100)
11:00:38.084 [main] INFO reactor.Flux.Array.1 - | onNext(1000)
11:00:38.084 [main] INFO reactor.Flux.Array.1 - | </span><strong class="bold"><span class="koboSpan" id="kobo.225.1">onComplete() Sum is: 1111</span></strong><span class="koboSpan" id="kobo.226.1">
Process finished with exit code 0</span></pre>
<p><span class="koboSpan" id="kobo.227.1">Looking at the output, when </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">Publisher</span></strong><span class="koboSpan" id="kobo.229.1"> is subscribed, </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">Subscriber</span></strong><span class="koboSpan" id="kobo.231.1"> sends an unbounded </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">Subscription.request()</span></strong><span class="koboSpan" id="kobo.233.1">. </span><span class="koboSpan" id="kobo.233.2">When the first element is notified, </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">onNext()</span></strong><span class="koboSpan" id="kobo.235.1"> is called, and so on. </span><span class="koboSpan" id="kobo.235.2">At the end, when the publisher is done with the push elements, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">onComplete()</span></strong><span class="koboSpan" id="kobo.237.1"> event</span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.238.1"> is called. </span><span class="koboSpan" id="kobo.238.2">This is how Reactive</span><a id="_idIndexMarker301"/> <span class="No-Break"><span class="koboSpan" id="kobo.239.1">Streams works.</span></span></p>
<p><span class="koboSpan" id="kobo.240.1">Now that you have an idea of how Reactive Streams works, let’s see how and why Spring makes use of Reactive Streams in the Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">WebFlux module.</span></span></p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.242.1">Exploring Spring WebFlux</span></h1>
<p><span class="koboSpan" id="kobo.243.1">Existing Servlet APIs</span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.244.1"> are blocking APIs. </span><span class="koboSpan" id="kobo.244.2">They use input and output streams, which block APIs. </span><span class="koboSpan" id="kobo.244.3">Servlet 3.0 containers evolve and use the underlying event loop. </span><span class="koboSpan" id="kobo.244.4">Async requests are processed asynchronously but read and write operations still use blocking input/output streams. </span><span class="koboSpan" id="kobo.244.5">The </span><em class="italic"><span class="koboSpan" id="kobo.245.1">Servlet 3.1</span></em><span class="koboSpan" id="kobo.246.1"> container has evolved further, supporting asynchronicity and having the non-blocking I/O stream APIs. </span><span class="koboSpan" id="kobo.246.2">However, there are certain Servlet APIs, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">request.getParameters()</span></strong><span class="koboSpan" id="kobo.248.1">, which parse the blocking request body and provide synchronous contracts such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">Filter</span></strong><span class="koboSpan" id="kobo.250.1">. </span><span class="koboSpan" id="kobo.250.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.251.1">Spring MVC</span></strong><span class="koboSpan" id="kobo.252.1"> framework is based on the Servlet API and </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">Servlet</span></span><span class="No-Break"><a id="_idIndexMarker303"/></span><span class="No-Break"><span class="koboSpan" id="kobo.254.1"> containers.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">Therefore, Spring provides </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">Spring WebFlux</span></strong><span class="koboSpan" id="kobo.257.1">, which is fully non-blocking and provides backpressure functionality. </span><span class="koboSpan" id="kobo.257.2">It provides concurrency with a small number of threads and scales with fewer hardware resources. </span><span class="koboSpan" id="kobo.257.3">WebFlux provides fluent, functional, and continuation-style APIs to support the declarative composition of asynchronous logic. </span><span class="koboSpan" id="kobo.257.4">Writing asynchronous functional code is more complex than writing imperative-style code. </span><span class="koboSpan" id="kobo.257.5">However, once you get hands-on with it, you will love it because it allows you to write precise and </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">readable code.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">Both Spring WebFlux and Spring MVC can co-exist; however, to ensure the effective use of reactive programming, you should never mix a reactive flow with </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">blocking calls.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">Spring WebFlux supports</span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.262.1"> the following</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.263.1"> features </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">and archetypes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.265.1">The event loop </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">concurrency model</span></span></li>
<li><span class="koboSpan" id="kobo.267.1">Both annotated controllers and </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">functional endpoints</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.269.1">Reactive clients</span></span></li>
<li><span class="koboSpan" id="kobo.270.1">Netty and Servlet 3.1 container-based web servers, such as Tomcat, Undertow, </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">and Jetty</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.272.1">Now that you have some</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.273.1"> idea about WebFlux, you can deep dive into learning how WebFlux works by understanding reactive APIs and Reactor Core. </span><span class="koboSpan" id="kobo.273.2">Let’s first explore reactive APIs. </span><span class="koboSpan" id="kobo.273.3">You’ll explore Reactor Core in a </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">subsequent subsection.</span></span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.275.1">Understanding reactive APIs</span></h2>
<p><span class="koboSpan" id="kobo.276.1">Spring WebFlux APIs</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.277.1"> are reactive APIs</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.278.1"> and accept </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">Publisher</span></strong><span class="koboSpan" id="kobo.280.1"> as the plain input. </span><span class="koboSpan" id="kobo.280.2">WebFlux then adapts it to a type supported by a reactive library such as Reactor Core or RxJava. </span><span class="koboSpan" id="kobo.280.3">It then processes the input and returns the output in a format supported by the reactive library. </span><span class="koboSpan" id="kobo.280.4">This allows WebFlux APIs to be interoperable with other </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">reactive libraries.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">By default, Spring</span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.283.1"> WebFlux uses Reactor (</span><a href="https://projectreactor.io"><span class="koboSpan" id="kobo.284.1">https://projectreactor.io</span></a><span class="koboSpan" id="kobo.285.1">) as a core dependency. </span><span class="koboSpan" id="kobo.285.2">Project Reactor</span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.286.1"> provides the Reactive Streams library. </span><span class="koboSpan" id="kobo.286.2">As stated in the previous paragraph, WebFlux accepts the input as </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">Publisher</span></strong><span class="koboSpan" id="kobo.288.1">, then adapts it to a Reactor type, and then returns it as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">Mono</span></strong><span class="koboSpan" id="kobo.290.1"> or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">Flux</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.292.1"> output.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">You know that </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">Publisher</span></strong><span class="koboSpan" id="kobo.295.1"> in Reactive Streams pushes the data to its subscribers based on demand. </span><span class="koboSpan" id="kobo.295.2">It can push one or more (possibly infinite) elements. </span><span class="koboSpan" id="kobo.295.3">Project Reactor takes it further and provides two </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">Publisher</span></strong><span class="koboSpan" id="kobo.297.1"> implementations, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">Mono</span></strong><span class="koboSpan" id="kobo.299.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">Flux</span></strong><span class="koboSpan" id="kobo.301.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">Mono</span></strong><span class="koboSpan" id="kobo.303.1"> can return either </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">0</span></strong><span class="koboSpan" id="kobo.305.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">1</span></strong><span class="koboSpan" id="kobo.307.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">Subscriber</span></strong><span class="koboSpan" id="kobo.309.1">, whereas </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">Flux</span></strong><span class="koboSpan" id="kobo.311.1"> returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">0</span></strong><span class="koboSpan" id="kobo.313.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">N</span></strong><span class="koboSpan" id="kobo.315.1"> elements. </span><span class="koboSpan" id="kobo.315.2">Both are abstract classes that implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">CorePublisher</span></strong><span class="koboSpan" id="kobo.317.1"> interface. </span><span class="koboSpan" id="kobo.317.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">CorePublisher</span></strong><span class="koboSpan" id="kobo.319.1"> interface extends </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">the publisher.</span></span></p>
<p><span class="koboSpan" id="kobo.321.1">Normally, we have the following methods in </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">the repository:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.323.1">
public </span><strong class="bold"><span class="koboSpan" id="kobo.324.1">Product</span></strong><span class="koboSpan" id="kobo.325.1"> findById(UUID id);public </span><strong class="bold"><span class="koboSpan" id="kobo.326.1">List&lt;Product&gt;</span></strong><span class="koboSpan" id="kobo.327.1"> getAll();</span></pre>
<p><span class="koboSpan" id="kobo.328.1">These can be replaced with </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">Mono</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.330.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">Flux</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.333.1">
Public </span><strong class="bold"><span class="koboSpan" id="kobo.334.1">Mono&lt;Product&gt;</span></strong><span class="koboSpan" id="kobo.335.1"> findById(UUID id);public </span><strong class="bold"><span class="koboSpan" id="kobo.336.1">Flux&lt;Product&gt;</span></strong><span class="koboSpan" id="kobo.337.1"> getAll();</span></pre>
<p><span class="koboSpan" id="kobo.338.1">Streams can be either</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.339.1"> hot or cold based on whether the source</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.340.1"> can be restarted or not. </span><span class="koboSpan" id="kobo.340.2">The source is restarted if there are multiple subscribers for cold streams, while the same source is used for multiple subscribers in hot streams. </span><span class="koboSpan" id="kobo.340.3">Project Reactor streams are, by default, cold. </span><span class="koboSpan" id="kobo.340.4">Therefore, once you consume a stream, you can’t reuse it until it’s restarted. </span><span class="koboSpan" id="kobo.340.5">However, Project Reactor allows you to turn a cold stream into a hot one by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">cache()</span></strong><span class="koboSpan" id="kobo.342.1"> methods. </span><span class="koboSpan" id="kobo.342.2">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">Mono</span></strong><span class="koboSpan" id="kobo.344.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">Flux</span></strong><span class="koboSpan" id="kobo.346.1"> abstract classes support cold and </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">hot streams.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">Let’s understand the cold and hot stream concepts with </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">some examples:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.350.1">
Flux&lt;Integer&gt; fluxInt = Flux.just(1, 10, 100).log();fluxInt.reduce(Integer::sum).subscribe(sum -&gt;       System.out.printf("Sum is: %d\n", sum));
fluxInt.reduce(Integer::max).subscribe(max -&gt;   System.out.printf("Maximum is: %d", max));</span></pre>
<p><span class="koboSpan" id="kobo.351.1">Here, we have created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">Flux</span></strong><span class="koboSpan" id="kobo.353.1"> object, </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">fluxInt</span></strong><span class="koboSpan" id="kobo.355.1">, that contains three numbers. </span><span class="koboSpan" id="kobo.355.2">Then, we are performing two operations separately – </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">sum</span></strong><span class="koboSpan" id="kobo.357.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">max</span></strong><span class="koboSpan" id="kobo.359.1">. </span><span class="koboSpan" id="kobo.359.2">You can see that there are two subscribers. </span><span class="koboSpan" id="kobo.359.3">By default, Project Reactor streams are cold; therefore, when a second subscriber registers, it restarts, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.361.1">
11:23:35.060 [main] INFO reactor.Flux.Array.1 - | onSubscribe([Synchronous Fuseable] FluxArray.ArraySubscription)11:23:35.060 [main] INFO reactor.Flux.Array.1 - | request(unbounded)
11:23:35.060 [main] INFO reactor.Flux.Array.1 - | onNext(1)
11:23:35.060 [main] INFO reactor.Flux.Array.1 - | onNext(10)
11:23:35.060 [main] INFO reactor.Flux.Array.1 - | onNext(100)
11:23:35.060 [main] INFO reactor.Flux.Array.1 - | onComplete()
</span><strong class="bold"><span class="koboSpan" id="kobo.362.1">Sum is: 111</span></strong><span class="koboSpan" id="kobo.363.1">
11:23:35.076 [main] INFO reactor.Flux.Array.1 - | </span><strong class="bold"><span class="koboSpan" id="kobo.364.1">onSubscribe</span></strong><span class="koboSpan" id="kobo.365.1">([Synchronous Fuseable] FluxArray.ArraySubscription)
11:23:35.076 [main] INFO reactor.Flux.Array.1 - | request(unbounded)
11:23:35.076 [main] INFO reactor.Flux.Array.1 - | onNext(1)
11:23:35.076 [main] INFO reactor.Flux.Array.1 - | onNext(10)
11:23:35.076 [main] INFO reactor.Flux.Array.1 - | onNext(100)
11:23:35.076 [main] INFO reactor.Flux.Array.1 - | onComplete()
</span><strong class="bold"><span class="koboSpan" id="kobo.366.1">Maximum is: 100</span></strong></pre>
<p><span class="koboSpan" id="kobo.367.1">The source is created</span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.368.1"> in the same program, but what if the source is somewhere</span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.369.1"> else, such as in an HTTP request, or you don’t want to restart the source? </span><span class="koboSpan" id="kobo.369.2">In these cases, you can turn the cold stream into a hot stream by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">cache()</span></strong><span class="koboSpan" id="kobo.371.1">, as shown in the next code block. </span><span class="koboSpan" id="kobo.371.2">The only difference between the following code and the previous code is that we have added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">cache()</span></strong><span class="koboSpan" id="kobo.373.1"> call </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">Flux.just()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.377.1">
Flux&lt;Integer&gt; fluxInt = Flux.just  (1, 10, 100).log().cache();
fluxInt.reduce(Integer::sum).subscribe(sum -&gt;   System.out.printf("Sum is: %d\n", sum));
fluxInt.reduce(Integer::max).subscribe(max -&gt;   System.out.printf("Maximum is: %d", max));</span></pre>
<p><span class="koboSpan" id="kobo.378.1">Now, look at the output. </span><span class="koboSpan" id="kobo.378.2">The source</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.379.1"> has not restarted; instead, the same source</span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.380.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">used again:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.382.1">
11:29:25.665 [main] INFO reactor.Flux.Array.1 - | onSubscribe([Synchronous Fuseable] FluxArray.ArraySubscription)11:29:25.665 [main] INFO reactor.Flux.Array.1 - | request(unbounded)
11:29:25.665 [main] INFO reactor.Flux.Array.1 - | onNext(1)
11:29:25.665 [main] INFO reactor.Flux.Array.1 - | onNext(10)
11:29:25.665 [main] INFO reactor.Flux.Array.1 - | onNext(100)
11:29:25.665 [main] INFO reactor.Flux.Array.1 - | onComplete()
Sum is: 111
Maximum is: 100</span></pre>
<p><span class="koboSpan" id="kobo.383.1">Now that we have got to the crux</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.384.1"> of reactive APIs, let’s see what Spring WebFlux’s Reactive Core</span><a id="_idIndexMarker318"/> <span class="No-Break"><span class="koboSpan" id="kobo.385.1">consists of.</span></span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.386.1">Reactive Core</span></h2>
<p><span class="koboSpan" id="kobo.387.1">Reactive Core provides</span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.388.1"> a foundation for developing</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.389.1"> a reactive web application with Spring. </span><span class="koboSpan" id="kobo.389.2">A web application needs three levels of support for serving HTTP </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">web requests:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.391.1">Handling web requests by the server using </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">the following:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">HttpHandler</span></strong><span class="koboSpan" id="kobo.394.1">: An interface of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">reactor.core.publisher.Mono</span></strong><span class="koboSpan" id="kobo.396.1"> package that is an abstraction of a request/response handler over different HTTP server APIs, such as Netty </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">or Tomcat:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.398.1">
public interface HttpHandler {  Mono&lt;Void&gt; handle(ServerHttpRequest request,     ServerHttpResponse response);}</span></pre></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">WebHandler</span></strong><span class="koboSpan" id="kobo.400.1">: An interface of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">org.springframework.web.server</span></strong><span class="koboSpan" id="kobo.402.1"> package that provides support for user sessions, request and session attributes, a locale and principal for the request, form</span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.403.1"> data, and so on. </span><span class="koboSpan" id="kobo.403.2">You can find more information about </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">WebHandler</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.405.1">at </span></span><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-web-handler-api"><span class="No-Break"><span class="koboSpan" id="kobo.406.1">https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-web-handler-api</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.407.1">.</span></span></li></ul></li> <li><span class="koboSpan" id="kobo.408.1">Handling of a web request call by the client </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">WebClient</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.412.1">Codecs (</span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">Encoder</span></strong><span class="koboSpan" id="kobo.414.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">Decoder</span></strong><span class="koboSpan" id="kobo.416.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">HttpMessageWriter</span></strong><span class="koboSpan" id="kobo.418.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">HttpMessageReader</span></strong><span class="koboSpan" id="kobo.420.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">DataBuffer</span></strong><span class="koboSpan" id="kobo.422.1">) for the serialization and deserialization of content at both the server and client levels for the request </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">and response.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.424.1">These components are at the core of Spring WebFlux. </span><span class="koboSpan" id="kobo.424.2">WebFlux application configuration also contains the following beans – </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">webHandler</span></strong><span class="koboSpan" id="kobo.426.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">DispatcherHandler</span></strong><span class="koboSpan" id="kobo.428.1">), </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">WebFilter</span></strong><span class="koboSpan" id="kobo.430.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">WebExceptionHandler</span></strong><span class="koboSpan" id="kobo.432.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">HandlerMapping</span></strong><span class="koboSpan" id="kobo.434.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">HandlerAdapter</span></strong><span class="koboSpan" id="kobo.436.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">HandlerResultHandler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">For REST service</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.441.1"> implementation, there are specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">HandlerAdapter</span></strong><span class="koboSpan" id="kobo.443.1"> instances</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.444.1"> for the following web servers – Tomcat, Jetty, Netty, and Undertow. </span><span class="koboSpan" id="kobo.444.2">A web server such as Netty, which supports Reactive Streams, handles the subscriber’s demands. </span><span class="koboSpan" id="kobo.444.3">However, if the server handler does not support Reactive Streams, then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">org. </span><span class="koboSpan" id="kobo.445.2">springframework.http.server.reactive.ServletHttpHandlerAdapter</span></strong><span class="koboSpan" id="kobo.446.1"> HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">HandlerAdapter</span></strong><span class="koboSpan" id="kobo.448.1"> is used. </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">HandlerAdapter</span></strong><span class="koboSpan" id="kobo.450.1"> handles the adaptation between Reactive Streams and the Servlet 3.1 container async I/O and implements a </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">Subscriber</span></strong><span class="koboSpan" id="kobo.452.1"> class. </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">HandlerAdapter</span></strong><span class="koboSpan" id="kobo.454.1"> uses the OS TCP buffers. </span><span class="koboSpan" id="kobo.454.2">OS TCP uses its own backpressure (control flow); that is, when the buffer is full, the OS uses the TCP backpressure to stop </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">incoming elements.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">The browser, or any HTTP client, consumes REST APIs using the HTTP protocol. </span><span class="koboSpan" id="kobo.456.2">When a request is received by the web server, it forwards it to the Spring WebFlux application. </span><span class="koboSpan" id="kobo.456.3">Then, WebFlux builds the reactive pipeline that goes to the controller. </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">HttpHandler</span></strong><span class="koboSpan" id="kobo.458.1"> is an interface between WebFlux and the web server that communicates using the HTTP protocol. </span><span class="koboSpan" id="kobo.458.2">If the underlying server supports Reactive Streams, such as Netty, then the subscription is done by the server natively. </span><span class="koboSpan" id="kobo.458.3">Else, WebFlux uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">ServletHttpHandlerAdapter</span></strong><span class="koboSpan" id="kobo.460.1"> for Servlet 3.1 container-based servers. </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">ServletHttpHandlerAdapter</span></strong><span class="koboSpan" id="kobo.462.1"> then adapts the streams to async I/O Servlet APIs and vice versa. </span><span class="koboSpan" id="kobo.462.2">Then, the subscription of Reactive Streams happens </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">ServletHttpHandlerAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.466.1">Therefore, in summary, </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">Mono</span></strong><span class="koboSpan" id="kobo.468.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">Flux</span></strong><span class="koboSpan" id="kobo.470.1"> streams are subscribed by WebFlux internal classes, and when the controller sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">Mono</span></strong><span class="koboSpan" id="kobo.472.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">Flux</span></strong><span class="koboSpan" id="kobo.474.1"> stream, these classes convert it into HTTP packets. </span><span class="koboSpan" id="kobo.474.2">The HTTP protocol does support event streams. </span><span class="koboSpan" id="kobo.474.3">However, for other media types, such as JSON, Spring WebFlux subscribes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">Mono</span></strong><span class="koboSpan" id="kobo.476.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">Flux</span></strong><span class="koboSpan" id="kobo.478.1"> streams and waits until </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">onComplete()</span></strong><span class="koboSpan" id="kobo.480.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">onError()</span></strong><span class="koboSpan" id="kobo.482.1"> is triggered. </span><span class="koboSpan" id="kobo.482.2">Then, it serializes the whole list of elements, or a single element in the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">Mono</span></strong><span class="koboSpan" id="kobo.484.1">, in one </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">HTTP response.</span></span></p>
<p><span class="koboSpan" id="kobo.486.1">Spring WebFlux</span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.487.1"> needs a component</span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.488.1"> like </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">DispatcherServlet</span></strong><span class="koboSpan" id="kobo.490.1"> in Spring MVC – a front controller. </span><span class="koboSpan" id="kobo.490.2">Let’s discuss this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">next section.</span></span></p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.492.1">Understanding DispatcherHandler</span></h1>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">DispatcherHandler</span></strong><span class="koboSpan" id="kobo.494.1">, a front controller</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.495.1"> in Spring WebFlux, is the equivalent of </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">DispatcherServlet</span></strong><span class="koboSpan" id="kobo.497.1"> in the Spring MVC framework. </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">DispatcherHandler</span></strong><span class="koboSpan" id="kobo.499.1"> contains an algorithm that makes use of special components – </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">HandlerMapping</span></strong><span class="koboSpan" id="kobo.501.1"> (maps requests to the handler), </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">HandlerAdapter</span></strong><span class="koboSpan" id="kobo.503.1"> (a </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">DispatcherHandler</span></strong><span class="koboSpan" id="kobo.505.1"> helper to invoke a handler mapped to a request), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">HandlerResultHandler</span></strong><span class="koboSpan" id="kobo.507.1"> (a palindrome of words, for processing the result and forming results) – for processing requests. </span><span class="koboSpan" id="kobo.507.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">DispatcherHandler</span></strong><span class="koboSpan" id="kobo.509.1"> component is identified by a bean </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">webHandler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.513.1">It processes requests in the </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">following way:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.515.1">A web request is received </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">DispatcherHandler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">DispatcherHandler</span></strong><span class="koboSpan" id="kobo.520.1"> uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">HandlerMapping</span></strong><span class="koboSpan" id="kobo.522.1"> to find a matching handler for the request and uses the </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">first match.</span></span></li>
<li><span class="koboSpan" id="kobo.524.1">It then uses the respective </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">HandlerAdapter</span></strong><span class="koboSpan" id="kobo.526.1"> to process the request, which exposes </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">HandlerResult</span></strong><span class="koboSpan" id="kobo.528.1"> (the value returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">HandlerAdapter</span></strong><span class="koboSpan" id="kobo.530.1"> after processing). </span><span class="koboSpan" id="kobo.530.2">The return value could be one of the following – </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">ResponseEntity</span></strong><span class="koboSpan" id="kobo.532.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">ServerResponse</span></strong><span class="koboSpan" id="kobo.534.1">, values returned from </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">@RestController</span></strong><span class="koboSpan" id="kobo.536.1">, or values (</span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">CharSequence</span></strong><span class="koboSpan" id="kobo.538.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">view</span></strong><span class="koboSpan" id="kobo.540.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">map</span></strong><span class="koboSpan" id="kobo.542.1">, and so on) returned by a </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">view resolver.</span></span></li>
<li><span class="koboSpan" id="kobo.544.1">Then, it makes use of the respective </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">HandlerResultHandler</span></strong><span class="koboSpan" id="kobo.546.1"> to write the response or render a view based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">HandlerResult</span></strong><span class="koboSpan" id="kobo.548.1"> type received from </span><em class="italic"><span class="koboSpan" id="kobo.549.1">step 2</span></em><span class="koboSpan" id="kobo.550.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">ResponseEntityResultHandler</span></strong><span class="koboSpan" id="kobo.552.1"> is used for </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">ResponseEntity</span></strong><span class="koboSpan" id="kobo.554.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">ServerResponseResultHandler</span></strong><span class="koboSpan" id="kobo.556.1"> is used for </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">ServerResponse</span></strong><span class="koboSpan" id="kobo.558.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">ResponseBodyResultHandler</span></strong><span class="koboSpan" id="kobo.560.1"> is used for values returned by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">@RestController</span></strong><span class="koboSpan" id="kobo.562.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">@ResponseBody</span></strong><span class="koboSpan" id="kobo.564.1"> annotated method, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">ViewResolutionResultHandler</span></strong><span class="koboSpan" id="kobo.566.1"> is used for values returned by the </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">view resolver.</span></span></li>
<li><span class="koboSpan" id="kobo.568.1">The request </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">is completed.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.570.1">You can create REST endpoints in Spring WebFlux using either an annotated controller such as Spring MVC or functional</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.571.1"> endpoints. </span><span class="koboSpan" id="kobo.571.2">Let’s explore these in the </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">next sections.</span></span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.573.1">Controllers</span></h2>
<p><span class="koboSpan" id="kobo.574.1">The Spring team has kept the same annotations</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.575.1"> for both Spring MVC </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.576.1">and Spring WebFlux as these annotations are non-blocking. </span><span class="koboSpan" id="kobo.576.2">Therefore, you can use the same annotations we used in previous chapters to create REST controllers. </span><span class="koboSpan" id="kobo.576.3">In Spring WebFlux, the annotation runs on Reactive Core and provides a non-blocking flow. </span><span class="koboSpan" id="kobo.576.4">However, you, as the developer, have the responsibility of maintaining a fully non-blocking flow and the reactive chain (pipeline). </span><span class="koboSpan" id="kobo.576.5">Any blocking calls in a reactive chain will convert the reactive chain into a </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">blocking call.</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">Let’s create a simple REST controller that supports non-blocking and </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">reactive calls:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.580.1">@RestController</span></strong><span class="koboSpan" id="kobo.581.1">public class OrderController {
  </span><strong class="bold"><span class="koboSpan" id="kobo.582.1">@RequestMapping</span></strong><span class="koboSpan" id="kobo.583.1">(value = "/api/v1/orders",  method =
    RequestMethod.POST)
  public ResponseEntity&lt;Order&gt; addOrder(
           @RequestBody NewOrder newOrder){
    // …
  }
  </span><strong class="bold"><span class="koboSpan" id="kobo.584.1">@RequestMapping</span></strong><span class="koboSpan" id="kobo.585.1">(value = "/api/v1/orders/{id}", method =
     RequestMethod.GET)
  public ResponseEntity&lt;Order&gt;getOrderById(
    @PathVariable("id") String id){
    // …
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.586.1">You can see that it uses all the annotations</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.587.1"> that we have used in </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">Spring MVC:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">@RestController</span></strong><span class="koboSpan" id="kobo.590.1"> is used to mark a class as a REST controller. </span><span class="koboSpan" id="kobo.590.2">Without this, the endpoint won’t register, and the request will be returned as </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">NOT </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">FOUND 404</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">@RequestMapping</span></strong><span class="koboSpan" id="kobo.595.1"> is used to define the path and HTTP method. </span><span class="koboSpan" id="kobo.595.2">Here, you can also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">@PostMapping</span></strong><span class="koboSpan" id="kobo.597.1"> with just the path. </span><span class="koboSpan" id="kobo.597.2">Similarly, for each of the HTTP methods, there is a respective mapping, such </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">@GetMapping</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.601.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">@RequestBody</span></strong><span class="koboSpan" id="kobo.603.1"> annotation marks a parameter as a request body, and an appropriate codec will be used for conversion. </span><span class="koboSpan" id="kobo.603.2">Similarly, there are </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">@PathVariable</span></strong><span class="koboSpan" id="kobo.605.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">@RequestParam</span></strong><span class="koboSpan" id="kobo.607.1"> for the path parameter and query </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">parameter, respectively.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.609.1">We are going to use an annotation-based model</span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.610.1"> to write the REST endpoints. </span><span class="koboSpan" id="kobo.610.2">You’ll get a closer look when we implement the e-commerce app controllers using WebFlux. </span><span class="koboSpan" id="kobo.610.3">Spring WebFlux also provides a way to write a REST endpoint using a functional programming style, which you’ll explore in the </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">next section.</span></span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.612.1">Functional endpoints</span></h2>
<p><span class="koboSpan" id="kobo.613.1">The REST controllers </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.614.1">we coded using Spring MVC</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.615.1"> were written in imperative-style programming. </span><span class="koboSpan" id="kobo.615.2">Reactive programming, on the other hand, is functional-style programming. </span><span class="koboSpan" id="kobo.615.3">Therefore, Spring WebFlux also allows an alternative way to define REST endpoints, using functional endpoints. </span><span class="koboSpan" id="kobo.615.4">These also use the same Reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">Core foundation.</span></span></p>
<p><span class="koboSpan" id="kobo.617.1">Let’s see how we can write the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">Order</span></strong><span class="koboSpan" id="kobo.619.1"> REST endpoint of the sample e-commerce app, using a </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">functional endpoint:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.621.1">
import static org.springframework.http.MediaType.  APPLICATION_JSON;
import static org.springframework.web.reactive.
</span><span class="koboSpan" id="kobo.621.2">  function.server. </span><span class="koboSpan" id="kobo.621.3">RequestPredicates.*;
import staticorg.springframework.
</span><span class="koboSpan" id="kobo.621.4">web.reactive.function.server. </span><span class="koboSpan" id="kobo.621.5">RouterFunctions.route;
// ...
</span><span class="koboSpan" id="kobo.621.6">  OrderRepository repository = ...
</span><span class="koboSpan" id="kobo.621.7">  OrderHandler handler = new OrderHandler(repository);
  </span><strong class="bold"><span class="koboSpan" id="kobo.622.1">RouterFunction&lt;ServerResponse&gt; route = route()</span></strong><span class="koboSpan" id="kobo.623.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.624.1">.GET("/v1/api/orders/{id}",</span></strong><span class="koboSpan" id="kobo.625.1">
          </span><strong class="bold"><span class="koboSpan" id="kobo.626.1">accept(APPLICATION_JSON),</span></strong><span class="koboSpan" id="kobo.627.1">
          </span><strong class="bold"><span class="koboSpan" id="kobo.628.1">handler::getOrderById)</span></strong><span class="koboSpan" id="kobo.629.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.630.1">.POST("/v1/api/orders", handler::addOrder)</span></strong><span class="koboSpan" id="kobo.631.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.632.1">.build();</span></strong><span class="koboSpan" id="kobo.633.1">
  public class OrderHandler {
    public Mono&lt;ServerResponse&gt; addOrder
       (ServerRequest req){
      // ...
</span><span class="koboSpan" id="kobo.633.2">    }
    public Mono&lt;ServerResponse&gt; getOrderById(
       ServerRequest req) {
    // ...
</span><span class="koboSpan" id="kobo.633.3">    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.634.1">In the previous</span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.635.1"> code, you can see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">RouterFunctions.route()</span></strong><span class="koboSpan" id="kobo.637.1"> builder allows you to write</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.638.1"> all the REST routes in a single statement using the functional programming style. </span><span class="koboSpan" id="kobo.638.2">Then, it uses the method reference of the handler class to process the request, which is the same as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">@RequestMapping</span></strong><span class="koboSpan" id="kobo.640.1"> body of an </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">annotation-based model.</span></span></p>
<p><span class="koboSpan" id="kobo.642.1">Let’s add the following code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">OrderHandler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.644.1"> methods:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.645.1">
public class OrderHandler {  public Mono&lt;ServerResponse&gt; addOrder(
     ServerRequest req){
    Mono&lt;NewOrder&gt; order = req.bodyToMono(NewOrder.class);
    return ok()
      .build(repository.save(toEntity(order)));
  }
  public Mono&lt;ServerResponse&gt; getOrderById(
      ServerRequest req) {
    String orderId = req.pathVariable("id");
    return repository
      .getOrderById(UUID.fromString(orderId))
      .flatMap(order -&gt; ok()
          .contentType(APPLICATION_JSON)
          .bodyValue(toModel(order)))
      .switchIfEmpty(ServerResponse.notFound()
      .build());
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.646.1">Unlike the </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">@RequestMapping()</span></strong><span class="koboSpan" id="kobo.648.1"> mapping methods in the REST controller, handler methods don’t have multiple parameters, such as body, path, or query parameters. </span><span class="koboSpan" id="kobo.648.2">They just have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">ServerRequest</span></strong><span class="koboSpan" id="kobo.650.1"> parameter, which can be used to extract the body, path, and query parameters. </span><span class="koboSpan" id="kobo.650.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">addOrder</span></strong><span class="koboSpan" id="kobo.652.1"> method, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">Order</span></strong><span class="koboSpan" id="kobo.654.1"> object is extracted using </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">request.bodyToMono()</span></strong><span class="koboSpan" id="kobo.656.1">, which parses the request body and then converts it into an </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">Order</span></strong><span class="koboSpan" id="kobo.658.1"> object. </span><span class="koboSpan" id="kobo.658.2">Similarly, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">getOrderById()</span></strong><span class="koboSpan" id="kobo.660.1"> method retrieves the </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">order</span></strong><span class="koboSpan" id="kobo.662.1"> object identified by the given ID from a server request object by calling </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">request. </span><span class="koboSpan" id="kobo.663.2">pathVariable("id")</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.665.1">Now, let’s discuss the response. </span><span class="koboSpan" id="kobo.665.2">The handler method</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.666.1"> uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">ServerResponse</span></strong><span class="koboSpan" id="kobo.668.1"> object</span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.669.1"> in comparison to </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">ResponseEntity</span></strong><span class="koboSpan" id="kobo.671.1"> in Spring MVC. </span><span class="koboSpan" id="kobo.671.2">Therefore, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">ok()</span></strong><span class="koboSpan" id="kobo.673.1"> static method looks like it’s from </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">ResponseEntity</span></strong><span class="koboSpan" id="kobo.675.1">, but it is from </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">org.springframework. </span><span class="koboSpan" id="kobo.676.2">web.reactive.function.server.ServerResponse.ok</span></strong><span class="koboSpan" id="kobo.677.1">. </span><span class="koboSpan" id="kobo.677.2">The Spring team has tried to keep the API as similar as possible to Spring MVC; however, the underlying implementation differs and provides a non-blocking </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">reactive interface.</span></span></p>
<p><span class="koboSpan" id="kobo.679.1">The last point about these handler methods is the way a response is written. </span><span class="koboSpan" id="kobo.679.2">It uses a functional style instead of an imperative style and makes sure that the reactive chain does not break. </span><span class="koboSpan" id="kobo.679.3">The repository returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">Mono</span></strong><span class="koboSpan" id="kobo.681.1"> object (a publisher) in both cases as a response wrapped </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">inside </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">ServerResponse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.685.1">You can find interesting code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">getOrderById()</span></strong><span class="koboSpan" id="kobo.687.1"> handler method. </span><span class="koboSpan" id="kobo.687.2">It performs a </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">flatMap</span></strong><span class="koboSpan" id="kobo.689.1"> operation on the received </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">Mono</span></strong><span class="koboSpan" id="kobo.691.1"> object from the repository. </span><span class="koboSpan" id="kobo.691.2">It converts it from an entity into a model, then wraps it in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">ServerResponse</span></strong><span class="koboSpan" id="kobo.693.1"> object, and returns the response. </span><span class="koboSpan" id="kobo.693.2">You must be wondering what happens if the repository returns null. </span><span class="koboSpan" id="kobo.693.3">The repository returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">Mono</span></strong><span class="koboSpan" id="kobo.695.1"> as per the contract, which is similar in nature to the Java </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">Optional</span></strong><span class="koboSpan" id="kobo.697.1"> class. </span><span class="koboSpan" id="kobo.697.2">Therefore, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">Mono</span></strong><span class="koboSpan" id="kobo.699.1"> object can be empty but not null, as per the contract. </span><span class="koboSpan" id="kobo.699.2">If the repository returns an empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">Mono</span></strong><span class="koboSpan" id="kobo.701.1">, then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">switchIfEmpty()</span></strong><span class="koboSpan" id="kobo.703.1"> operator will be used and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">NOT FOUND 404</span></strong><span class="koboSpan" id="kobo.705.1"> response will </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">be sent.</span></span></p>
<p><span class="koboSpan" id="kobo.707.1">In the case of an error, there are different error operators that can be used, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">doOnError()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.709.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">onErrorReturn()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.712.1">We have discussed the logic flow using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">Mono</span></strong><span class="koboSpan" id="kobo.714.1"> type; the same explanation will apply if you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">Flux</span></strong><span class="koboSpan" id="kobo.716.1"> type in place of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">Mono</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.718.1"> type.</span></span></p>
<p><span class="koboSpan" id="kobo.719.1">We have discussed a lot of theory</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.720.1"> relating to reactive, asynchronous, and non-blocking programming</span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.721.1"> in a Spring context. </span><span class="koboSpan" id="kobo.721.2">Let’s jump into coding and migrate the e-commerce API developed in </span><a href="B19349_04.xhtml#_idTextAnchor097"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.722.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.723.1">, </span><em class="italic"><span class="koboSpan" id="kobo.724.1">Writing Business Logic for APIs</span></em><span class="koboSpan" id="kobo.725.1">, to a </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">reactive API.</span></span></p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.727.1">Implementing reactive APIs for our e-commerce app</span></h1>
<p><span class="koboSpan" id="kobo.728.1">Now that you have an idea</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.729.1"> of how Reactive Streams works, we can go ahead and implement REST APIs that are asynchronous </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">and non-blocking.</span></span></p>
<p><span class="koboSpan" id="kobo.731.1">You’ll recall that we are following the design-first approach, so we need the API design specification first. </span><span class="koboSpan" id="kobo.731.2">However, we can reuse the e-commerce API specification we created previously in </span><a href="B19349_03.xhtml#_idTextAnchor080"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.732.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.733.1">, </span><em class="italic"><span class="koboSpan" id="kobo.734.1">API Specifications </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.735.1">and Implementation</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.737.1">OpenAPI Codegen is used to generate the API interface/contract that creates the Spring MVC-compliant API Java interfaces. </span><span class="koboSpan" id="kobo.737.2">Let’s see what changes we need to do to generate the reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">API interfaces.</span></span></p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.739.1">Changing OpenAPI Codegen for reactive APIs</span></h2>
<p><span class="koboSpan" id="kobo.740.1">You need to tweak</span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.741.1"> a few OpenAPI Codegen configurations</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.742.1"> to generate Spring WebFlux-compliant Java interfaces, as </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.744.1">
{  </span><strong class="bold"><span class="koboSpan" id="kobo.745.1">"library": "spring-boot"</span></strong><span class="koboSpan" id="kobo.746.1">,
  "dateLibrary": "java8",
  "hideGenerationTimestamp": true,
  "modelPackage": "com.packt.modern.api.model",
  "apiPackage": "com.packt.modern.api",
  "invokerPackage": "com.packt.modern.api",
  "serializableModel": true,
  "useTags": true,
  "useGzipFeature" : true,
  </span><strong class="bold"><span class="koboSpan" id="kobo.747.1">"reactive": true</span></strong><span class="koboSpan" id="kobo.748.1">,
  "interfaceOnly": true,
  …
  …
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/resources/api/config.json"><span class="No-Break"><span class="koboSpan" id="kobo.749.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/resources/api/config.json</span></span></a></p>
<p><span class="koboSpan" id="kobo.750.1">Reactive API support is only there if you opt for </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">spring-boot</span></strong><span class="koboSpan" id="kobo.752.1"> as the library. </span><span class="koboSpan" id="kobo.752.2">Also, you need to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">reactive</span></strong><span class="koboSpan" id="kobo.754.1"> flag to </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">true</span></strong><span class="koboSpan" id="kobo.756.1">. </span><span class="koboSpan" id="kobo.756.2">By default, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">reactive</span></strong><span class="koboSpan" id="kobo.758.1"> flag </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.762.1">Now, you can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.764.1">
$ gradlew clean generateSwaggerCode</span></pre> <p><span class="koboSpan" id="kobo.765.1">This will generate Reactive Streams-compliant</span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.766.1"> Java interfaces, which</span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.767.1"> are annotation-based REST controller interfaces. </span><span class="koboSpan" id="kobo.767.2">When you open any API interface, you’ll find </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">Mono</span></strong><span class="koboSpan" id="kobo.769.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">Flux</span></strong><span class="koboSpan" id="kobo.771.1"> reactor types in it, as shown in the following code block for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">OrderAPI</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.773.1"> interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.774.1">
@Operation(  operationId = "addOrder",
  summary = "Creates a new order for the …",
  tags = { "order" },
  responses = {
    @ApiResponse(responseCode = "201",
      description = "Order added successfully",
      content = {
        @Content(mediaType = "application/xml",
          schema = @Schema(
            implementation = Order.class)),
        @Content(mediaType = "application/json",
          schema = @Schema(
            implementation = Order.class))
      }),
      @ApiResponse(responseCode = "406",
        description = "If payment not authorized")
  }
)
@RequestMapping(
  method = RequestMethod.POST,
  value = "/api/v1/orders",
  produces = { "application/xml",
               "application/json" },
  consumes = { "application/xml",
               "application/json" }
)
default </span><strong class="bold"><span class="koboSpan" id="kobo.775.1">Mono&lt;ResponseEntity&lt;Order&gt;&gt;</span></strong><span class="koboSpan" id="kobo.776.1"> addOrder(
 @Parameter(name = "NewOrder", description =
     "New Order Request object")
     @Valid @RequestBody(required = false)
          </span><strong class="bold"><span class="koboSpan" id="kobo.777.1">Mono&lt;NewOrder&gt;</span></strong><span class="koboSpan" id="kobo.778.1"> newOrder,
 @Parameter(hidden = true)
  final </span><strong class="bold"><span class="koboSpan" id="kobo.779.1">ServerWebExchange</span></strong><span class="koboSpan" id="kobo.780.1"> exg) throws Exception {</span></pre>
<p><span class="koboSpan" id="kobo.781.1">You will have observed another change: an additional parameter, </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">ServerWebExchange</span></strong><span class="koboSpan" id="kobo.783.1">, is also required for </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">reactive controllers.</span></span></p>
<p><span class="koboSpan" id="kobo.785.1">Now, when you compile your code, you may find</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.786.1"> compilation errors because we haven’t yet added the dependencies</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.787.1"> required for reactive support. </span><span class="koboSpan" id="kobo.787.2">Let’s learn how to add them in the </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">next section.</span></span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.789.1">Adding Reactive dependencies to build.xml</span></h2>
<p><span class="koboSpan" id="kobo.790.1">First, we’ll remove </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">spring-boot-starter-web</span></strong><span class="koboSpan" id="kobo.792.1"> as we don’t need</span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.793.1"> Spring MVC now. </span><span class="koboSpan" id="kobo.793.2">Second, we’ll add </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">spring-boot-starter-webflux</span></strong><span class="koboSpan" id="kobo.795.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">reactor-test</span></strong><span class="koboSpan" id="kobo.797.1"> for Spring WebFlux and Reactor support tests, respectively. </span><span class="koboSpan" id="kobo.797.2">Once these dependencies are added successfully, you should not see any compilation errors in the </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">OpenAPI-generated code.</span></span></p>
<p><span class="koboSpan" id="kobo.799.1">You can add the required reactive dependencies to </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">build.gradle</span></strong><span class="koboSpan" id="kobo.801.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.803.1">
implementation </span><strong class="bold"><span class="koboSpan" id="kobo.804.1">'org.springframework.boot:</span></strong><strong class="bold"><span class="koboSpan" id="kobo.805.1">  spring-boot-starter-webflux</span></strong><span class="koboSpan" id="kobo.806.1">'
testImplementation('org.springframework.boot:
  spring-boot-starter-test')
testImplementation </span><strong class="bold"><span class="koboSpan" id="kobo.807.1">'io.projectreactor:reactor-test</span></strong><span class="koboSpan" id="kobo.808.1">'</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/build.gradle"><span class="No-Break"><span class="koboSpan" id="kobo.809.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/build.gradle</span></span></a></p>
<p><span class="koboSpan" id="kobo.810.1">We need to have a complete reactive pipeline from the REST controller to the database. </span><span class="koboSpan" id="kobo.810.2">However, existing JDBC and Hibernate dependencies only support blocking calls. </span><span class="koboSpan" id="kobo.810.3">JDBC is a fully blocking API. </span><span class="koboSpan" id="kobo.810.4">Hibernate is also blocking. </span><span class="koboSpan" id="kobo.810.5">Therefore, we need to have reactive dependencies for </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.812.1">Hibernate Reactive (</span><a href="https://github.com/hibernate/hibernate-reactive"><span class="koboSpan" id="kobo.813.1">https://github.com/hibernate/hibernate-reactive</span></a><span class="koboSpan" id="kobo.814.1">) was released after the first edition of this book. </span><span class="koboSpan" id="kobo.814.2">Hibernate Reactive supports PostgreSQL, MySQL/MariaDB, Db2 11.5+, CockroachDB 22.1+, MS SQL Server 2019+, and Oracle Database 21+. </span><span class="koboSpan" id="kobo.814.3">Hibernate Reactive does not support H2 at the time of writing. </span><span class="koboSpan" id="kobo.814.4">Therefore, we will simply use Spring Data, a Spring framework that provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">spring-data-r2dbc</span></strong><span class="koboSpan" id="kobo.816.1"> library for working with </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">Reactive Streams.</span></span></p>
<p><span class="koboSpan" id="kobo.818.1">Many NoSQL databases, such as MongoDB, already provide a reactive database driver. </span><span class="koboSpan" id="kobo.818.2">An R2DBC-based driver should</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.819.1"> be used for relational databases in place of JDBC for fully non-blocking/reactive API calls. </span><strong class="bold"><span class="koboSpan" id="kobo.820.1">R2DBC</span></strong><span class="koboSpan" id="kobo.821.1"> stands for </span><strong class="bold"><span class="koboSpan" id="kobo.822.1">Reactive Relational Database Connectivity</span></strong><span class="koboSpan" id="kobo.823.1">. </span><span class="koboSpan" id="kobo.823.2">R2DBC is a reactive API open specification that establishes a </span><strong class="bold"><span class="koboSpan" id="kobo.824.1">Service Provider Interface</span></strong><span class="koboSpan" id="kobo.825.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.826.1">SPI</span></strong><span class="koboSpan" id="kobo.827.1">) for database drivers. </span><span class="koboSpan" id="kobo.827.2">Almost</span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.828.1"> all the popular relational databases support R2DBC drivers – H2, Oracle Database, MySQL, MariaDB, SQL Server, PostgreSQL, and </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">R2DBC Proxy.</span></span></p>
<p><span class="koboSpan" id="kobo.830.1">Let’s add the R2DBC dependencies for Spring Data and H2 to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">build.gradle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.832.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.833.1">
implementation </span><strong class="bold"><span class="koboSpan" id="kobo.834.1">'org.springframework.boot:spring-boot-starter-data-r2dbc'</span></strong><span class="koboSpan" id="kobo.835.1">implementation 'com.h2database:h2'
runtimeOnly 'io.r2dbc:r2dbc-h2'</span></pre>
<p><span class="koboSpan" id="kobo.836.1">Now, we can write end-to-end (from the controller to the repository) code without any compilation errors. </span><span class="koboSpan" id="kobo.836.2">Let’s add global exception</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.837.1"> handling before we jump into writing an implementation for API </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">Java interfaces.</span></span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.839.1">Handling exceptions</span></h2>
<p><span class="koboSpan" id="kobo.840.1">We’ll add the global exception</span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.841.1"> handler the way it was added</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.842.1"> in Spring MVC in </span><a href="B19349_03.xhtml#_idTextAnchor080"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.843.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.844.1">, </span><em class="italic"><span class="koboSpan" id="kobo.845.1">API Specifications and Implementation</span></em><span class="koboSpan" id="kobo.846.1">. </span><span class="koboSpan" id="kobo.846.2">Before that, you must be wondering how to handle exceptions in a reactive pipeline. </span><span class="koboSpan" id="kobo.846.3">Reactive pipelines are a flow of streams and you can’t add exception handling the way you do in imperative code. </span><span class="koboSpan" id="kobo.846.4">You need to raise the error in a pipeline </span><span class="No-Break"><span class="koboSpan" id="kobo.847.1">flow only.</span></span></p>
<p><span class="koboSpan" id="kobo.848.1">Check out the </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.850.1">
.flatMap(card -&gt; {  if (Objects.isNull(card.getId())) {
    return service.registerCard(mono)
      .map(ce -&gt; status(HttpStatus.CREATED)
        .body(assembler.entityToModel(
           ce, exchange)));
  } else {
    </span><strong class="bold"><span class="koboSpan" id="kobo.851.1">return Mono.error(() -&gt; new</span></strong><span class="koboSpan" id="kobo.852.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.853.1">CardAlreadyExistsException(</span></strong><span class="koboSpan" id="kobo.854.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.855.1">" for user with ID - " + d.getId()));</span></strong><span class="koboSpan" id="kobo.856.1">
  }
})</span></pre>
<p><span class="koboSpan" id="kobo.857.1">Here, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">flatMap</span></strong><span class="koboSpan" id="kobo.859.1"> operation is performed. </span><span class="koboSpan" id="kobo.859.2">An error should be thrown if </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">card</span></strong><span class="koboSpan" id="kobo.861.1"> is not valid, that is, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">card</span></strong><span class="koboSpan" id="kobo.863.1"> does not have the requested </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">ID</span></strong><span class="koboSpan" id="kobo.865.1">. </span><span class="koboSpan" id="kobo.865.2">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">Mono.error()</span></strong><span class="koboSpan" id="kobo.867.1"> is used because the pipeline expects </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">Mono</span></strong><span class="koboSpan" id="kobo.869.1"> as a returned object. </span><span class="koboSpan" id="kobo.869.2">Similarly, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">Flux.error()</span></strong><span class="koboSpan" id="kobo.871.1"> if </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">Flux</span></strong><span class="koboSpan" id="kobo.873.1"> is expected as the </span><span class="No-Break"><span class="koboSpan" id="kobo.874.1">returned type.</span></span></p>
<p><span class="koboSpan" id="kobo.875.1">Let’s assume you are expecting</span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.876.1"> an object from a service</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.877.1"> or repository call, but instead, you receive an empty object. </span><span class="koboSpan" id="kobo.877.2">Then, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">switchIfEmpty()</span></strong><span class="koboSpan" id="kobo.879.1"> operator, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.880.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.881.1">
Mono&lt;List&lt;String&gt;&gt; monoIds =  itemRepo.findByCustomerId( customerId)
    </span><strong class="bold"><span class="koboSpan" id="kobo.882.1">.switchIfEmpty(Mono.error(new</span></strong><span class="koboSpan" id="kobo.883.1">
       </span><strong class="bold"><span class="koboSpan" id="kobo.884.1">ResourceNotFoundException(". </span><span class="koboSpan" id="kobo.884.2">No items</span></strong><span class="koboSpan" id="kobo.885.1">
         </span><strong class="bold"><span class="koboSpan" id="kobo.886.1">found in Cart of customer with Id - " +</span></strong><span class="koboSpan" id="kobo.887.1">
           </span><strong class="bold"><span class="koboSpan" id="kobo.888.1">customerId)))</span></strong><span class="koboSpan" id="kobo.889.1">
    .map(i -&gt; i.getId().toString())
    .collectList().cache();</span></pre>
<p><span class="koboSpan" id="kobo.890.1">Here, the code expects a </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">Mono</span></strong><span class="koboSpan" id="kobo.892.1"> object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">List</span></strong><span class="koboSpan" id="kobo.894.1"> type from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">item</span></strong><span class="koboSpan" id="kobo.896.1"> repository. </span><span class="koboSpan" id="kobo.896.2">However, if the returned object is empty, then it simply throws the </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">ResourceNotFoundException.switchIfEmpty()</span></strong><span class="koboSpan" id="kobo.898.1"> exception and accepts the alternate </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">Mono</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.900.1"> instance.</span></span></p>
<p><span class="koboSpan" id="kobo.901.1">By now, you might have a question about the type of exception. </span><span class="koboSpan" id="kobo.901.2">It throws a runtime exception. </span><span class="koboSpan" id="kobo.901.3">See the </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">ResourceNotFoundException</span></strong><span class="koboSpan" id="kobo.903.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">declaration here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.905.1">
public class ResourceNotFoundException     extends </span><strong class="bold"><span class="koboSpan" id="kobo.906.1">RuntimeException</span></strong></pre>
<p><span class="koboSpan" id="kobo.907.1">Similarly, you can also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">onErrorReturn()</span></strong><span class="koboSpan" id="kobo.909.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">onErrorResume()</span></strong><span class="koboSpan" id="kobo.911.1">, or similar error operators from Reactive Streams. </span><span class="koboSpan" id="kobo.911.2">Look at the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">onErrorReturn()</span></strong><span class="koboSpan" id="kobo.913.1"> in the next </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.915.1">
return service.getCartByCustomerId(customerId)  .map(cart -&gt; assembler
    .itemfromEntities(cart.getItems().stream()
      .filter(i -&gt; i.getProductId().toString()
       .equals(itemId.trim())).collect(toList()))
      .get(0)).map(ResponseEntity::ok)
  </span><strong class="bold"><span class="koboSpan" id="kobo.916.1">.onErrorReturn(notFound().build())</span></strong></pre>
<p><span class="koboSpan" id="kobo.917.1">All exceptions should</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.918.1"> be handled, and an error</span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.919.1"> response should be sent to the user. </span><span class="koboSpan" id="kobo.919.2">We’ll have a look at the global exception handler first, in the </span><span class="No-Break"><span class="koboSpan" id="kobo.920.1">following section.</span></span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.921.1">Handling global exceptions for controllers</span></h2>
<p><span class="koboSpan" id="kobo.922.1">We created a global exception</span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.923.1"> handler using </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">@ControllerAdvice</span></strong><span class="koboSpan" id="kobo.925.1"> in Spring MVC. </span><span class="koboSpan" id="kobo.925.2">We’ll take a slightly</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.926.1"> different route for handling errors in Spring WebFlux. </span><span class="koboSpan" id="kobo.926.2">First, we’ll create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">ApiErrorAttributes</span></strong><span class="koboSpan" id="kobo.928.1"> class, which can also be used in Spring MVC. </span><span class="koboSpan" id="kobo.928.2">This class extends </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">DefaultErrorAttributes</span></strong><span class="koboSpan" id="kobo.930.1">, which is a default implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">ErrorAttributes</span></strong><span class="koboSpan" id="kobo.932.1"> interface. </span><span class="koboSpan" id="kobo.932.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">ErrorAttributes</span></strong><span class="koboSpan" id="kobo.934.1"> interface provides a way to handle maps, a map of error fields, and their values. </span><span class="koboSpan" id="kobo.934.2">These error attributes can then be used to display an error to the user or </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">for logging.</span></span></p>
<p><span class="koboSpan" id="kobo.936.1">The following attributes are provided by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">DefaultErrorAttributes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.938.1"> class:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">timestamp</span></strong><span class="koboSpan" id="kobo.940.1">: The time that the error </span><span class="No-Break"><span class="koboSpan" id="kobo.941.1">was captured</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">status</span></strong><span class="koboSpan" id="kobo.943.1">: The </span><span class="No-Break"><span class="koboSpan" id="kobo.944.1">status code</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">error</span></strong><span class="koboSpan" id="kobo.946.1">: An </span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">error description</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">exception</span></strong><span class="koboSpan" id="kobo.949.1">: The class name of the root exception (</span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">if configured)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">message</span></strong><span class="koboSpan" id="kobo.952.1">: The exception message (</span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">if configured)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">errors</span></strong><span class="koboSpan" id="kobo.955.1">: Any </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">ObjectError</span></strong><span class="koboSpan" id="kobo.957.1"> from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">BindingResult</span></strong><span class="koboSpan" id="kobo.959.1"> exception (</span><span class="No-Break"><span class="koboSpan" id="kobo.960.1">if configured)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.961.1">trace</span></strong><span class="koboSpan" id="kobo.962.1">: The exception stack trace (</span><span class="No-Break"><span class="koboSpan" id="kobo.963.1">if configured)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">path</span></strong><span class="koboSpan" id="kobo.965.1">: The URL path when the exception </span><span class="No-Break"><span class="koboSpan" id="kobo.966.1">was raised</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">requestId</span></strong><span class="koboSpan" id="kobo.968.1">: The unique ID associated with the </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">current request</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.970.1">We have added two default</span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.971.1"> values to the status</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.972.1"> and message – an internal server error and a generic error message (</span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">The system is unable to complete the request. </span><span class="koboSpan" id="kobo.973.2">Contact system support.</span></strong><span class="koboSpan" id="kobo.974.1">), respectively – to </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">ApiErrorAttributes</span></strong><span class="koboSpan" id="kobo.976.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.978.1">
@Componentpublic class ApiErrorAttributes
  extends DefaultErrorAttributes {
  private HttpStatus status =
      HttpStatus.INTERNAL_SERVER_ERROR;
  private String message =
     ErrorCode.GENERIC_ERROR.getErrMsgKey();
  @Override
  public Map&lt;String, Object&gt;
    getErrorAttributes( ServerRequest request,
       ErrorAttributeOptions options) {
    var attributes =
      super.getErrorAttributes(request, options);
    attributes.put("status", status);
    attributes.put("message", message);
    attributes.put("code", ErrorCode.
</span><span class="koboSpan" id="kobo.978.2">      GENERIC_ERROR.getErrCode());
    return attributes;
  }
  // Getters and setters
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorAttributes.java"><span class="No-Break"><span class="koboSpan" id="kobo.979.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorAttributes.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.980.1">Now, we</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.981.1"> can</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.982.1"> use this </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">ApiErrorAttributes</span></strong><span class="koboSpan" id="kobo.984.1"> class in a custom global exception handler</span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.985.1"> class. </span><span class="koboSpan" id="kobo.985.2">We’ll create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">ApiErrorWebExceptionHandler</span></strong><span class="koboSpan" id="kobo.987.1"> class, which</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.988.1"> extends the </span><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">AbstractErrorWebExceptionHandler</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.990.1">abstract class.</span></span></p>
<p><span class="koboSpan" id="kobo.991.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">AbstractErrorWebExceptionHandler</span></strong><span class="koboSpan" id="kobo.993.1"> class implements </span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">ErrorWebExcepti</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.996.1"> onHandler</span></strong><span class="koboSpan" id="kobo.997.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.998.1">InitializingBean</span></strong><span class="koboSpan" id="kobo.999.1"> interfaces. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">ErrorWebExceptionHandler</span></strong><span class="koboSpan" id="kobo.1001.1"> is a functional interface that extends the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">WebExceptionHandler</span></strong><span class="koboSpan" id="kobo.1003.1"> interface, which indicates that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1004.1">WebExceptionHandler</span></strong><span class="koboSpan" id="kobo.1005.1"> is used for rendering exceptions. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">WebExceptionHandler</span></strong><span class="koboSpan" id="kobo.1007.1"> is a contract for handling exceptions when server exchange processing </span><span class="No-Break"><span class="koboSpan" id="kobo.1008.1">takes place.</span></span></p>
<p><span class="koboSpan" id="kobo.1009.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1010.1">InitializingBean</span></strong><span class="koboSpan" id="kobo.1011.1"> interface is a part of the Spring core framework. </span><span class="koboSpan" id="kobo.1011.2">It is used by components that react when all properties are populated. </span><span class="koboSpan" id="kobo.1011.3">It can also be used to check whether all the mandatory properties </span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">are set.</span></span></p>
<p><span class="koboSpan" id="kobo.1013.1">Now that we have studied the basics, let’s jump into writing the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">ApiErrorAttributes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1015.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1016.1">
@Component</span><strong class="bold"><span class="koboSpan" id="kobo.1017.1">@Order(-2)</span></strong><span class="koboSpan" id="kobo.1018.1">
public class ApiErrorWebExceptionHandler extends
  AbstractErrorWebExceptionHandler {
 public ApiErrorWebExceptionHandler(
    ApiErrorAttributes errorAttributes,
    ApplicationContext appCon,
    ServerCodecConfigurer serverCodecConfigurer){
  </span><strong class="bold"><span class="koboSpan" id="kobo.1019.1">super(errorAttributes,</span></strong><span class="koboSpan" id="kobo.1020.1">
     </span><strong class="bold"><span class="koboSpan" id="kobo.1021.1">new WebProperties().getResources(),appCon);</span></strong><span class="koboSpan" id="kobo.1022.1">
  super.setMessageWriters(
     serverCodecConfigurer.getWriters());
  super.setMessageReaders(
     serverCodecConfigurer.getReaders());
 }
 </span><strong class="bold"><span class="koboSpan" id="kobo.1023.1">@Override</span></strong>
 <strong class="bold"><span class="koboSpan" id="kobo.1024.1">protected RouterFunction&lt;ServerResponse&gt;</span></strong><span class="koboSpan" id="kobo.1025.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.1026.1">getRoutingFunction(ErrorAttributes errA) {</span></strong><span class="koboSpan" id="kobo.1027.1">
   return RouterFunctions.route(
     RequestPredicates.all(),
       this::renderErrorResponse);
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorWebExceptionHandler.java"><span class="No-Break"><span class="koboSpan" id="kobo.1028.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorWebExceptionHandler.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1029.1">The first important observation about this code is that we have added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">@Order</span></strong><span class="koboSpan" id="kobo.1031.1"> annotation, which tells us the preference of execution. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">ResponseStatusExceptionHandler</span></strong><span class="koboSpan" id="kobo.1033.1"> is placed at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">0</span></strong><span class="koboSpan" id="kobo.1035.1"> index by the Spring Framework and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1036.1">DefaultErrorWebExceptionHandler</span></strong><span class="koboSpan" id="kobo.1037.1"> is ordered at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">-1</span></strong><span class="koboSpan" id="kobo.1039.1"> index. </span><span class="koboSpan" id="kobo.1039.2">Both are exception handlers like the one we have created. </span><span class="koboSpan" id="kobo.1039.3">If you don’t give an order of precedence to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">ApiErrorWebExceptionHandler</span></strong><span class="koboSpan" id="kobo.1041.1"> superseding both, then it won’t ever execute. </span><span class="koboSpan" id="kobo.1041.2">Therefore, the order of precedence is set </span><span class="No-Break"><span class="koboSpan" id="kobo.1042.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">-2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1045.1">Next, this class</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.1046.1"> overrides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">getRoutingFunction()</span></strong><span class="koboSpan" id="kobo.1048.1"> method, which calls</span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.1049.1"> the privately defined </span><strong class="source-inline"><span class="koboSpan" id="kobo.1050.1">renderErrorResponse()</span></strong><span class="koboSpan" id="kobo.1051.1"> method, where we have our own custom implementation for error handling, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1053.1">
private Mono&lt;ServerResponse&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1054.1">renderErrorResponse</span></strong><span class="koboSpan" id="kobo.1055.1">(    ServerRequest request) {
  Map&lt;String, Object&gt; errorPropertiesMap =
     </span><strong class="bold"><span class="koboSpan" id="kobo.1056.1">getErrorAttributes</span></strong><span class="koboSpan" id="kobo.1057.1">(request,
      ErrorAttributeOptions.defaults());
  Throwable </span><strong class="bold"><span class="koboSpan" id="kobo.1058.1">throwable = (Throwable) request</span></strong><span class="koboSpan" id="kobo.1059.1">
     </span><strong class="bold"><span class="koboSpan" id="kobo.1060.1">.attribute</span></strong><span class="koboSpan" id="kobo.1061.1">("org.springframework.boot.web
                .reactive.error
                .DefaultErrorAttributes.ERROR")
     .orElseThrow(() -&gt; new IllegalStateException
     ("Missing exception attribute in ServerWebExchange"));
  ErrorCode errorCode = ErrorCode.GENERIC_ERROR;
  if (throwable instanceof
      IllegalArgumentException || throwable
      instanceof DataIntegrityViolationException
      || throwable instanceof
      ServerWebInputException) {
     </span><strong class="bold"><span class="koboSpan" id="kobo.1062.1">errorCode = ILLEGAL_ARGUMENT_EXCEPTION;</span></strong><span class="koboSpan" id="kobo.1063.1">
  } else if (throwable instanceof
      CustomerNotFoundException) {
    errorCode = CUSTOMER_NOT_FOUND;
  } else if (throwable instanceof
      ResourceNotFoundException) {
    errorCode = RESOURCE_NOT_FOUND;
  } // other else-if
  // …
}</span></pre>
<p><span class="No-Break"><span class="koboSpan" id="kobo.1064.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorWebExceptionHandler.java</span></span></p>
<p><span class="koboSpan" id="kobo.1065.1">Here, first, we extract </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.1066.1">the error attributes in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1067.1">errorPropertiesMap</span></strong><span class="koboSpan" id="kobo.1068.1">. </span><span class="koboSpan" id="kobo.1068.2">This will be used when we form the error</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.1069.1"> response. </span><span class="koboSpan" id="kobo.1069.2">Next, we capture the occurred exception using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1070.1">throwable</span></strong><span class="koboSpan" id="kobo.1071.1">. </span><span class="koboSpan" id="kobo.1071.2">Then, we check the type of the exception and assign an appropriate code to it. </span><span class="koboSpan" id="kobo.1071.3">We keep the default as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1072.1">GenericError</span></strong><span class="koboSpan" id="kobo.1073.1">, which is nothing more </span><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">than </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1075.1">InternalServerError</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1076.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1077.1">Next, we use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">switch</span></strong><span class="koboSpan" id="kobo.1079.1"> statement</span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.1080.1"> to form an error response based on the raised exception, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1081.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1082.1">
switch (errorCode) {  case ILLEGAL_ARGUMENT_EXCEPTION -&gt;{errorPropertiesMap.put
    ("status", HttpStatus.BAD_REQUEST);
    errorPropertiesMap.put("code",
       ILLEGAL_ARGUMENT_EXCEPTION.getErrCode());
    errorPropertiesMap.put("error",
       ILLEGAL_ARGUMENT_EXCEPTION);
    errorPropertiesMap.put("message", String
      .format("%s %s",
       ILLEGAL_ARGUMENT_EXCEPTION.getErrMsgKey(),
       throwable.getMessage()));
    return ServerResponse.status(
          HttpStatus.BAD_REQUEST)
        .contentType(MediaType.APPLICATION_JSON)
        .body(BodyInserters.fromValue(
          errorPropertiesMap));
  }
  case CUSTOMER_NOT_FOUND -&gt; {
    errorPropertiesMap.put("status",
       HttpStatus.NOT_FOUND);
    errorPropertiesMap.put("code",
       CUSTOMER_NOT_FOUND.getErrCode());
    errorPropertiesMap.put("error",
       CUSTOMER_NOT_FOUND);
    errorPropertiesMap.put("message", String
       .format("%s %s",
        CUSTOMER_NOT_FOUND.getErrMsgKey(),
        throwable.getMessage()));
    return ServerResponse.status(
         HttpStatus.NOT_FOUND)
        .contentType(MediaType.APPLICATION_JSON)
        .body(BodyInserters.fromValue(
          errorPropertiesMap));
  }
  case RESOURCE_NOT_FOUND -&gt; {
    // rest of the code …
}</span></pre>
<p><span class="koboSpan" id="kobo.1083.1">Probably in the next version</span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.1084.1"> of Java, we will be able</span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.1085.1"> to combine the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1086.1">if-else</span></strong><span class="koboSpan" id="kobo.1087.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">switch</span></strong><span class="koboSpan" id="kobo.1089.1"> blocks to make the code more concise. </span><span class="koboSpan" id="kobo.1089.2">You can also create a separate method that takes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1090.1">errorPropertiesMap</span></strong><span class="koboSpan" id="kobo.1091.1"> as an argument and returns the formed server response based on it. </span><span class="koboSpan" id="kobo.1091.2">Then, you can </span><span class="No-Break"><span class="koboSpan" id="kobo.1092.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1093.1">switch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1094.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1095.1">Custom application exception</span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.1096.1"> classes, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">CustomerNotFoundException</span></strong><span class="koboSpan" id="kobo.1098.1">, and other exception-handling-supported classes, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">ErrorCode</span></strong><span class="koboSpan" id="kobo.1100.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">Error</span></strong><span class="koboSpan" id="kobo.1102.1">, are being used</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.1103.1"> from the existing code (from </span><a href="B19349_04.xhtml#_idTextAnchor097"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1104.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.1105.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1106.1">Writing Business Logic </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1107.1">for APIs</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1108.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1109.1">Now that we have studied exception handling, we can concentrate </span><span class="No-Break"><span class="koboSpan" id="kobo.1110.1">on HATEOAS.</span></span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.1111.1">Adding hypermedia links to an API response</span></h2>
<p><span class="koboSpan" id="kobo.1112.1">HATEOAS support for reactive APIs</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.1113.1"> exists and is a bit like</span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.1114.1"> what we did in the previous chapter using Spring MVC. </span><span class="koboSpan" id="kobo.1114.2">We create these assemblers again for HATEOAS support. </span><span class="koboSpan" id="kobo.1114.3">We also use the HATEOAS assembler classes to convert a model into an entity and </span><span class="No-Break"><span class="koboSpan" id="kobo.1115.1">vice versa.</span></span></p>
<p><span class="koboSpan" id="kobo.1116.1">Spring WebFlux provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">ReactiveRepresentationModelAssembler</span></strong><span class="koboSpan" id="kobo.1118.1"> interface for forming hypermedia links. </span><span class="koboSpan" id="kobo.1118.2">We would override its </span><strong class="source-inline"><span class="koboSpan" id="kobo.1119.1">toModel()</span></strong><span class="koboSpan" id="kobo.1120.1"> method to add the links to </span><span class="No-Break"><span class="koboSpan" id="kobo.1121.1">response models.</span></span></p>
<p><span class="koboSpan" id="kobo.1122.1">Here, we will do some groundwork for populating the links. </span><span class="koboSpan" id="kobo.1122.2">We will create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1123.1">HateoasSupport</span></strong><span class="koboSpan" id="kobo.1124.1"> interface with a single default method, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1125.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1126.1">
public interface HateoasSupport {  default UriComponentsBuilder
     getUriComponentBuilder(@Nullable
            ServerWebExchange exchange) {
    if (exchange == null) {
      return UriComponentsBuilder.fromPath("/");
    }
    ServerHttpRequest request = exchange.getRequest();
    PathContainer contextPath = request.getPath().
</span><span class="koboSpan" id="kobo.1126.2">      contextPath();
    return UriComponentsBuilder
          .fromHttpRequest(request)
          .replacePath(contextPath.toString())
          .replaceQuery("");
  }
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/hateoas/HateoasSupport.java"><span class="No-Break"><span class="koboSpan" id="kobo.1127.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/hateoas/HateoasSupport.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1128.1">Here, this class contains</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.1129.1"> a single default</span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.1130.1"> method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">getUriCompononentBuilder()</span></strong><span class="koboSpan" id="kobo.1132.1">, which accepts </span><strong class="source-inline"><span class="koboSpan" id="kobo.1133.1">ServerWebExchange</span></strong><span class="koboSpan" id="kobo.1134.1"> as an argument and returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1135.1">UriComponentsBuilder</span></strong><span class="koboSpan" id="kobo.1136.1"> instance. </span><span class="koboSpan" id="kobo.1136.2">This instance can then be used to extract the server URI that would be used to add the links with a protocol, host, and port. </span><span class="koboSpan" id="kobo.1136.3">If you remember, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1137.1">ServerWebExchange</span></strong><span class="koboSpan" id="kobo.1138.1"> argument was added to controller methods. </span><span class="koboSpan" id="kobo.1138.2">This interface is used to get the HTTP request, response, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1139.1">other attributes.</span></span></p>
<p><span class="koboSpan" id="kobo.1140.1">Now, we can use these two interfaces – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1141.1">HateoasSupport</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1142.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1143.1">ReactiveRepresentation</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.1144.1"> ModelAssembler</span></strong><span class="koboSpan" id="kobo.1145.1"> – to define the representation </span><span class="No-Break"><span class="koboSpan" id="kobo.1146.1">model assemblers.</span></span></p>
<p><span class="koboSpan" id="kobo.1147.1">Let’s define the address’s representational model assembler, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1148.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1149.1">
@Componentpublic class AddressRepresentationModelAssembler
  implements </span><strong class="bold"><span class="koboSpan" id="kobo.1150.1">ReactiveRepresentationModelAssembler</span></strong><span class="koboSpan" id="kobo.1151.1">
      &lt;AddressEntity, Address&gt;, HateoasSupport {
  private static String serverUri = null;
  private String getServerUri(
        @Nullable ServerWebExchange exch) {
    if (Strings.isBlank(serverUri)) {
      serverUri = getUriComponentBuilder
        (exch).toUriString();
    }
    return serverUri;
  }</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/hateoas/AddressRepresentationModelAssembler.java"><span class="No-Break"><span class="koboSpan" id="kobo.1152.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/hateoas/AddressRepresentationModelAssembler.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1153.1">Here, we have defined</span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.1154.1"> another private method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">getServerUri()</span></strong><span class="koboSpan" id="kobo.1156.1">, which extracts</span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.1157.1"> the server URI from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1158.1">UriComponentBuilder</span></strong><span class="koboSpan" id="kobo.1159.1">, which itself is returned from the default </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">getUriComponentBuilder()</span></strong><span class="koboSpan" id="kobo.1161.1"> method of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1162.1">HateoasSupport</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1163.1"> interface.</span></span></p>
<p><span class="koboSpan" id="kobo.1164.1">Now, we can override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1165.1">toModel()</span></strong><span class="koboSpan" id="kobo.1166.1"> method, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1167.1">code block:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1168.1">AddressRepresentationModelAssembler.java</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1169.1">
@Overridepublic Mono&lt;Address&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1170.1">toModel</span></strong><span class="koboSpan" id="kobo.1171.1">(AddressEntity entity,
  ServerWebExchange exch) {
  return Mono.just(entityToModel(entity, exch));
}
public Address </span><strong class="bold"><span class="koboSpan" id="kobo.1172.1">entityToModel</span></strong><span class="koboSpan" id="kobo.1173.1">(AddressEntity entity,
  ServerWebExchange exch) {
  Address resource = new Address();
  if(Objects.isNull(entity)) {
    return resource;
  }
  BeanUtils.copyProperties(entity, resource);
  resource.setId(entity.getId().toString());
  String serverUri = getServerUri(exchange);
  resource.add(Link.of(String.format(
      "%s/api/v1/addresses", serverUri))
      .withRel("addresses"));
  resource.add(Link.of(String.format(
      "%s/api/v1/addresses/%s",serverUri,
      entity.getId())).withSelfRel());
  return resource;
}</span></pre>
<p><span class="koboSpan" id="kobo.1174.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1175.1">toModel()</span></strong><span class="koboSpan" id="kobo.1176.1"> method returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1177.1">Mono&lt;Address&gt;</span></strong><span class="koboSpan" id="kobo.1178.1"> object with hypermedia links formed from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1179.1">AddressEntity</span></strong><span class="koboSpan" id="kobo.1180.1"> instance using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1181.1">entityToModel()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1182.1"> method.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1183.1">entityToModel()</span></strong><span class="koboSpan" id="kobo.1184.1"> copies the properties</span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.1185.1"> from the entity instance to the model instance. </span><span class="koboSpan" id="kobo.1185.2">Most importantly, it adds</span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.1186.1"> hypermedia links to the model using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1187.1">resource.add()</span></strong><span class="koboSpan" id="kobo.1188.1"> method. </span><span class="koboSpan" id="kobo.1188.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1189.1">add()</span></strong><span class="koboSpan" id="kobo.1190.1"> method takes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1191.1">org.springframework.hateoas.Link</span></strong><span class="koboSpan" id="kobo.1192.1"> instance as an argument. </span><span class="koboSpan" id="kobo.1192.2">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1193.1">Link</span></strong><span class="koboSpan" id="kobo.1194.1"> class’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1195.1">of()</span></strong><span class="koboSpan" id="kobo.1196.1"> static factory method to form the link. </span><span class="koboSpan" id="kobo.1196.2">You can see that a server URI is used here to add it to the link. </span><span class="koboSpan" id="kobo.1196.3">You can form as many links as you want and add these to the resource using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1197.1">add()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1198.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.1199.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1200.1">ReactiveRepresentationModelAssembler</span></strong><span class="koboSpan" id="kobo.1201.1"> interface provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1202.1">toCollectionModel()</span></strong><span class="koboSpan" id="kobo.1203.1"> method with a default implementation that returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1204.1">Mono&lt;CollectionModel&lt;D&gt;&gt;</span></strong><span class="koboSpan" id="kobo.1205.1"> collection model. </span><span class="koboSpan" id="kobo.1205.2">However, we can also add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1206.1">toListModel()</span></strong><span class="koboSpan" id="kobo.1207.1"> method, as shown here, which returns the list of addresses </span><span class="No-Break"><span class="koboSpan" id="kobo.1208.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1209.1">Flux</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1210.1">:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1211.1">AddressRepresentationModelAssembler.java</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1212.1">
public Flux&lt;Address&gt; toListModel(         Flux&lt;AddressEntity&gt; ent,
         ServerWebExchange exchange) {
  if (Objects.isNull(ent)) {
    return Flux.empty();
  }
  return Flux.from(ent.map(e -&gt;
            entityToModel(e, exchange)));
}</span></pre>
<p><span class="koboSpan" id="kobo.1213.1">This method internally uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">entityToModel()</span></strong><span class="koboSpan" id="kobo.1215.1"> method. </span><span class="koboSpan" id="kobo.1215.2">Similarly, you can create a representation model assembler for other API models. </span><span class="koboSpan" id="kobo.1215.3">You can find all these models </span><span class="No-Break"><span class="koboSpan" id="kobo.1216.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/hateoas"><span class="No-Break"><span class="koboSpan" id="kobo.1217.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/hateoas</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1218.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1219.1">Now that we are done</span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.1220.1"> with the basic code infrastructure, we can develop the API implementation</span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.1221.1"> based on the interfaces generated by OpenAPI Codegen. </span><span class="koboSpan" id="kobo.1221.2">Here, we’ll first develop the repositories that will be consumed by the services. </span><span class="koboSpan" id="kobo.1221.3">At the end, we’ll write the controller implementation. </span><span class="koboSpan" id="kobo.1221.4">Let’s start with </span><span class="No-Break"><span class="koboSpan" id="kobo.1222.1">the repositories.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.1223.1">Defining an entity</span></h2>
<p><span class="koboSpan" id="kobo.1224.1">Entities are defined</span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.1225.1"> in more or less the same way as we defined and used them in </span><a href="B19349_04.xhtml#_idTextAnchor097"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1226.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.1227.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1228.1">Writing Business Logic for APIs</span></em><span class="koboSpan" id="kobo.1229.1">. </span><span class="koboSpan" id="kobo.1229.2">However, instead of using Hibernate mappings</span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.1230.1"> and JPA, we’ll use Spring Data annotations, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1231.1">shown here:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1232.1">@Table("ecomm.orders")</span></strong><span class="koboSpan" id="kobo.1233.1">public class OrderEntity {
  </span><strong class="bold"><span class="koboSpan" id="kobo.1234.1">@Id</span></strong><span class="koboSpan" id="kobo.1235.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.1236.1">@Column("id")</span></strong><span class="koboSpan" id="kobo.1237.1">
  private UUID id;
  @Column("customer_id")
  private UUID customerId;
  @Column("address_id")
  private UUID addressId;
  @Column("card_id")
  private UUID cardId;
  @Column("order_date")
  private Timestamp orderDate;
  // other fields mapped to table columns
  private UUID cartId;
  private UserEntity userEntity;
  private AddressEntity addressEntity;
  private PaymentEntity paymentEntity;
  private List&lt;ShipmentEntity&gt; shipments = new ArrayList&lt;&gt;();
  // other entities fields and getters/setters</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/entity/OrderEntity.java"><span class="No-Break"><span class="koboSpan" id="kobo.1238.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/entity/OrderEntity.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1239.1">Here, because we are using Spring Data in place of Hibernate, we use Spring Data annotations, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.1240.1">@Table</span></strong><span class="koboSpan" id="kobo.1241.1">, to associate an entity class to a table name, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1242.1">@Column</span></strong><span class="koboSpan" id="kobo.1243.1"> for mapping a field to a column</span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.1244.1"> of the table. </span><span class="koboSpan" id="kobo.1244.2">As is obvious, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1245.1">@Id</span></strong><span class="koboSpan" id="kobo.1246.1"> is used as the identifier column. </span><span class="koboSpan" id="kobo.1246.2">Similarly, you can define</span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.1247.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.1248.1">other entities.</span></span></p>
<p><span class="koboSpan" id="kobo.1249.1">After defining the entities, let’s add repositories in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1250.1">next subsection.</span></span></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.1251.1">Adding repositories</span></h2>
<p><span class="koboSpan" id="kobo.1252.1">A repository</span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.1253.1"> is an interface between our application</span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.1254.1"> code and database. </span><span class="koboSpan" id="kobo.1254.2">It is the same as the respository you used in Spring MVC. </span><span class="koboSpan" id="kobo.1254.3">However, we are writing the code using the reactive paradigm. </span><span class="koboSpan" id="kobo.1254.4">Therefore, it is necessary to have repositories that use an R2DBC-/reactive-based driver and return instances of reactive types on top of Reactive Streams. </span><span class="koboSpan" id="kobo.1254.5">This is the reason why we can’t </span><span class="No-Break"><span class="koboSpan" id="kobo.1255.1">use JDBC.</span></span></p>
<p><span class="koboSpan" id="kobo.1256.1">Spring Data R2DBC provides different repositories for Reactor and RxJava, for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1257.1">ReactiveCrudRepository</span></strong><span class="koboSpan" id="kobo.1258.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1259.1">ReactiveSortingRepository</span></strong><span class="koboSpan" id="kobo.1260.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1261.1">RxJava2CrudRepository</span></strong><span class="koboSpan" id="kobo.1262.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1263.1">RxJava3CrudRepository</span></strong><span class="koboSpan" id="kobo.1264.1">. </span><span class="koboSpan" id="kobo.1264.2">Also, you can write your own </span><span class="No-Break"><span class="koboSpan" id="kobo.1265.1">custom implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.1266.1">We are going to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1267.1">ReactiveCrudRepository</span></strong><span class="koboSpan" id="kobo.1268.1"> and also write a </span><span class="No-Break"><span class="koboSpan" id="kobo.1269.1">custom implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.1270.1">We’ll write repositories for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1271.1">Order</span></strong><span class="koboSpan" id="kobo.1272.1"> entity. </span><span class="koboSpan" id="kobo.1272.2">For other entities, you can find the repositories </span><span class="No-Break"><span class="koboSpan" id="kobo.1273.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/repository"><span class="No-Break"><span class="koboSpan" id="kobo.1274.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/repository</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1275.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1276.1">First, let’s write the CRUD</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.1277.1"> repository</span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.1278.1"> for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1279.1">Order</span></strong><span class="koboSpan" id="kobo.1280.1"> entity, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1281.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1282.1">
@Repositorypublic interface OrderRepository extends
   </span><strong class="bold"><span class="koboSpan" id="kobo.1283.1">ReactiveCrudRepository</span></strong><span class="koboSpan" id="kobo.1284.1">&lt;OrderEntity, UUID&gt;,
      </span><strong class="bold"><span class="koboSpan" id="kobo.1285.1">OrderRepositoryExt</span></strong><span class="koboSpan" id="kobo.1286.1"> {
  @</span><strong class="bold"><span class="koboSpan" id="kobo.1287.1">Query</span></strong><span class="koboSpan" id="kobo.1288.1">("select o.* from ecomm.orders o join
           ecomm.\"user\" u on o.customer_id =
           u.id where u.id = :cusId")
  Flux&lt;OrderEntity&gt; findByCustomerId(UUID cusId);
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepository.java"><span class="No-Break"><span class="koboSpan" id="kobo.1289.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepository.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1290.1">This is as simple as shown. </span><span class="koboSpan" id="kobo.1290.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1291.1">OrderRepository</span></strong><span class="koboSpan" id="kobo.1292.1"> interface extends </span><strong class="source-inline"><span class="koboSpan" id="kobo.1293.1">ReactiveCrudRepository</span></strong><span class="koboSpan" id="kobo.1294.1"> and our own custom repository </span><span class="No-Break"><span class="koboSpan" id="kobo.1295.1">interface, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">OrderRepositoryExt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1297.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1298.1">We’ll discuss </span><strong class="source-inline"><span class="koboSpan" id="kobo.1299.1">OrderRepositoryExt</span></strong><span class="koboSpan" id="kobo.1300.1"> a bit later; let’s discuss </span><strong class="source-inline"><span class="koboSpan" id="kobo.1301.1">OrderRepository</span></strong><span class="koboSpan" id="kobo.1302.1"> first. </span><span class="koboSpan" id="kobo.1302.2">We have added one extra method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1303.1">findByCustomerId()</span></strong><span class="koboSpan" id="kobo.1304.1">, to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1305.1">OrderRepository</span></strong><span class="koboSpan" id="kobo.1306.1"> interface, which finds the order by the given customer ID. </span><span class="koboSpan" id="kobo.1306.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1307.1">ReactiveCrudRepository</span></strong><span class="koboSpan" id="kobo.1308.1"> interface and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1309.1">Query()</span></strong><span class="koboSpan" id="kobo.1310.1"> annotation are part of the Spring Data R2DBC library. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1311.1">Query()</span></strong><span class="koboSpan" id="kobo.1312.1"> consumes native SQL queries, unlike the repository we created in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1313.1">previous chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.1314.1">We can also write our own custom repository. </span><span class="koboSpan" id="kobo.1314.2">Let’s write a simple contract for it, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1315.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1316.1">
public interface OrderRepositoryExt {  Mono&lt;OrderEntity&gt; insert(Mono&lt;NewOrder&gt; m);
  Mono&lt;OrderEntity&gt; updateMapping(OrderEntity e);
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExt.java"><span class="No-Break"><span class="koboSpan" id="kobo.1317.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExt.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1318.1">Here, we have written</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.1319.1"> two method signatures – the first one inserts a new order record in the database and the second</span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.1320.1"> one updates the order item and cart item mapping. </span><span class="koboSpan" id="kobo.1320.2">The idea is that once an order is placed, items should be removed from the cart and added to the order. </span><span class="koboSpan" id="kobo.1320.3">If you want, you can also combine </span><span class="No-Break"><span class="koboSpan" id="kobo.1321.1">both operations.</span></span></p>
<p><span class="koboSpan" id="kobo.1322.1">Let’s first define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1323.1">OrderRepositoryExtImpl</span></strong><span class="koboSpan" id="kobo.1324.1"> class, which extends the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1325.1">OrderRepositoryExt</span></strong><span class="koboSpan" id="kobo.1326.1"> interface, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1327.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1328.1">
@</span><strong class="bold"><span class="koboSpan" id="kobo.1329.1">Repository</span></strong><span class="koboSpan" id="kobo.1330.1">public class OrderRepositoryExtImpl implements </span><strong class="bold"><span class="koboSpan" id="kobo.1331.1">OrderRepositoryExt</span></strong><span class="koboSpan" id="kobo.1332.1"> {
  private ConnectionFactory connectionFactory;
  private DatabaseClient dbClient;
  private ItemRepository itemRepo;
  private CartRepository cartRepo;
  private OrderItemRepository oiRepo;
  public OrderRepositoryExtImpl(ConnectionFactory
     connectionFactory, ItemRepository itemRepo,
     OrderItemRepository oiRepo, CartRepository
     cartRepo, DatabaseClient dbClient) {
    this.itemRepo = itemRepo;
    this.connectionFactory = connectionFactory;
    this.oiRepo = oiRepo;
    this.cartRepo = cartRepo;
    this.dbClient = dbClient;
  }</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExtImpl.java"><span class="No-Break"><span class="koboSpan" id="kobo.1333.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExtImpl.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1334.1">We have just defined a few</span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.1335.1"> class properties</span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.1336.1"> and added these properties in the constructor as an argument for constructor-based </span><span class="No-Break"><span class="koboSpan" id="kobo.1337.1">dependency injection.</span></span></p>
<p><span class="koboSpan" id="kobo.1338.1">As per the contract, it receives </span><strong class="source-inline"><span class="koboSpan" id="kobo.1339.1">Mono&lt;NewOrder&gt;</span></strong><span class="koboSpan" id="kobo.1340.1">. </span><span class="koboSpan" id="kobo.1340.2">Therefore, we need to add a method that converts a model into an entity to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1341.1">OrderRepositoryExtImpl</span></strong><span class="koboSpan" id="kobo.1342.1"> class. </span><span class="koboSpan" id="kobo.1342.2">We also need an extra argument as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1343.1">CartEntity</span></strong><span class="koboSpan" id="kobo.1344.1"> contains the cart items. </span><span class="koboSpan" id="kobo.1344.2">Here </span><span class="No-Break"><span class="koboSpan" id="kobo.1345.1">it is:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1346.1">OrderRepositoryExtImpl.java</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1347.1">
private OrderEntity toEntity(NewOrder order, CartEntity c) {  OrderEntity orderEntity = new OrderEntity();
  BeanUtils.copyProperties(order, orderEntity);
  orderEntity.setUserEntity(c.getUser());
  orderEntity.setCartId(c.getId());
  orderEntity.setItems(c.getItems())
     .setCustomerId(UUID.fromString(order.getCustomerId()))
     .setAddressId(UUID.fromString
       (order.getAddress().getId()))
     .setOrderDate(Timestamp.from(Instant.now()))
     .setTotal(c.getItems().stream()
     .collect(Collectors.toMap(k -&gt;
       k.getProductId(), v -&gt;
         BigDecimal.valueOf(v.getQuantity())
         .multiply(v.getPrice())))
     .values().stream().reduce(
      BigDecimal::add).orElse(BigDecimal.ZERO));
  return orderEntity;
}</span></pre>
<p><span class="koboSpan" id="kobo.1348.1">This method is straightforward</span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.1349.1"> except for the code where the total is set. </span><span class="koboSpan" id="kobo.1349.2">The total is calculated using the stream. </span><span class="koboSpan" id="kobo.1349.3">Let’s break</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.1350.1"> it down to </span><span class="No-Break"><span class="koboSpan" id="kobo.1351.1">understand it:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1352.1">First, it takes the items </span><span class="No-Break"><span class="koboSpan" id="kobo.1353.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1354.1">CartEntity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1355.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1356.1">Then, it creates streams </span><span class="No-Break"><span class="koboSpan" id="kobo.1357.1">from items.</span></span></li>
<li><span class="koboSpan" id="kobo.1358.1">It creates a map with the key as the product ID and the value as the product of the quantity </span><span class="No-Break"><span class="koboSpan" id="kobo.1359.1">and price.</span></span></li>
<li><span class="koboSpan" id="kobo.1360.1">It takes the value from the map and converts it into </span><span class="No-Break"><span class="koboSpan" id="kobo.1361.1">a stream.</span></span></li>
<li><span class="koboSpan" id="kobo.1362.1">It performs the reduce operation by adding a method to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1363.1">BigDecimal</span></strong><span class="koboSpan" id="kobo.1364.1">. </span><span class="koboSpan" id="kobo.1364.2">It then gives the </span><span class="No-Break"><span class="koboSpan" id="kobo.1365.1">total amount.</span></span></li>
<li><span class="koboSpan" id="kobo.1366.1">If values are not present, then it simply </span><span class="No-Break"><span class="koboSpan" id="kobo.1367.1">returns </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1368.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1369.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1370.1">After the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1371.1">toEntity()</span></strong><span class="koboSpan" id="kobo.1372.1"> method, we also need another mapper that reads rows from the database and converts</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.1373.1"> them into </span><strong class="source-inline"><span class="koboSpan" id="kobo.1374.1">OrderEntity</span></strong><span class="koboSpan" id="kobo.1375.1">. </span><span class="koboSpan" id="kobo.1375.2">For this purpose, we’ll write </span><strong class="source-inline"><span class="koboSpan" id="kobo.1376.1">BiFunction</span></strong><span class="koboSpan" id="kobo.1377.1">, which</span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.1378.1"> is a part of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1379.1">java.util.function</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1380.1"> package:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1381.1">OrderRepositoryExtImpl.java</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1382.1">
class OrderMapper implements </span><strong class="bold"><span class="koboSpan" id="kobo.1383.1">BiFunction</span></strong><span class="koboSpan" id="kobo.1384.1">&lt;Row,Object,  OrderEntity&gt; {
  @</span><strong class="bold"><span class="koboSpan" id="kobo.1385.1">Override</span></strong><span class="koboSpan" id="kobo.1386.1">
  public OrderEntity </span><strong class="bold"><span class="koboSpan" id="kobo.1387.1">apply</span></strong><span class="koboSpan" id="kobo.1388.1">(Row row, Object o) {
    OrderEntity oe = new OrderEntity();
    return oe.setId(row.get("id", UUID.class))
        .setCustomerId(
            row.get("customer_id", UUID.class))
        .setAddressId(
            row.get("address_id", UUID.class))
        .setCardId(
            row.get("card_id", UUID.class))
        .setOrderDate(Timestamp.from(
            ZonedDateTime.of(
           (LocalDateTime) row.get("order_date"),
            ZoneId.of("Z")).toInstant()))
        .setTotal(
            row.get("total", BigDecimal.class))
        .setPaymentId(
            row.get("payment_id", UUID.class))
        .setShipmentId(
            row.get("shipment_id", UUID.class))
        .setStatus(StatusEnum.fromValue(
            row.get("status", String.class)));
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1389.1">Here, we have overridden the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1390.1">apply()</span></strong><span class="koboSpan" id="kobo.1391.1"> method, which returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1392.1">OrderEntity</span></strong><span class="koboSpan" id="kobo.1393.1">, by mapping properties</span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.1394.1"> from the row to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1395.1">OrderEntity</span></strong><span class="koboSpan" id="kobo.1396.1">. </span><span class="koboSpan" id="kobo.1396.2">The second parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1397.1">apply()</span></strong><span class="koboSpan" id="kobo.1398.1"> method is not used</span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.1399.1"> because it contains metadata that we </span><span class="No-Break"><span class="koboSpan" id="kobo.1400.1">don’t need.</span></span></p>
<p><span class="koboSpan" id="kobo.1401.1">Let’s first implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">updateMapping()</span></strong><span class="koboSpan" id="kobo.1403.1"> method from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1404.1">OrderRepositoryExt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1405.1"> interface:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1406.1">OrderRepositoryExtImpl.java</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1407.1">
public Mono&lt;OrderEntity&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1408.1">updateMapping</span></strong><span class="koboSpan" id="kobo.1409.1">(OrderEntity  orderEntity) {
  return oiRepo.saveAll(orderEntity.getItems()
    .stream().map(i -&gt; new OrderItemEntity()
      .setOrderId(orderEntity.getId())
      .setItemId(i.getId())).collect(toList()))
      .then(
        itemRepo.deleteCartItemJoinById(
           orderEntity.getItems().stream()
             .map(i -&gt; i.getId())
             .collect(toList()),
           orderEntity.getCartId())
             .then(Mono.just(orderEntity))
      );
}</span></pre>
<p><span class="koboSpan" id="kobo.1410.1">Here, we have created a pipeline of Reactive Streams and performed two back-to-back database operations. </span><span class="koboSpan" id="kobo.1410.2">First, it creates the order item mapping using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1411.1">OrderItemRepository</span></strong><span class="koboSpan" id="kobo.1412.1">, and then it removes the cart item mapping </span><span class="No-Break"><span class="koboSpan" id="kobo.1413.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1414.1">ItemRepository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1415.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1416.1">Java streams are used</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.1417.1"> to create an input list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1418.1">OrderItemEntity</span></strong><span class="koboSpan" id="kobo.1419.1"> instances in the first operation, and a list of item IDs</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.1420.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1421.1">second operation.</span></span></p>
<p><span class="koboSpan" id="kobo.1422.1">So far, we have made use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1423.1">ReactiveCrudRepository</span></strong><span class="koboSpan" id="kobo.1424.1"> methods. </span><span class="koboSpan" id="kobo.1424.2">Let’s implement a custom method using an entity template, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1425.1">shown next:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1426.1">OrderRepositoryExtImpl.java</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1427.1">@Override</span></strong><span class="koboSpan" id="kobo.1428.1">public Mono&lt;OrderEntity&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1429.1">insert</span></strong><span class="koboSpan" id="kobo.1430.1">(Mono&lt;NewOrder&gt; mdl) {
  AtomicReference&lt;UUID&gt; orderId =new AtomicReference&lt;&gt;();
  Mono&lt;List&lt;ItemEntity&gt;&gt; itemEntities =
       mdl.flatMap(m -&gt;
          itemRepo.findByCustomerId(
            UUID.fromString(m.getCustomerId()))
          .collectList().cache());
  Mono&lt;CartEntity&gt; cartEntity =
       mdl.flatMap(m -&gt;
          cartRepo.findByCustomerId(
            UUID.fromString(m.getCustomerId())))
         .cache();
  cartEntity = </span><strong class="bold"><span class="koboSpan" id="kobo.1431.1">Mono.zip</span></strong><span class="koboSpan" id="kobo.1432.1">(cartEntity, itemEntities,
       (c, i) -&gt; {
         if (i.size() &lt; 1) {
          throw new ResourceNotFoundException(
          String.format("There is no item found
           in customer's (ID:%s) cart.",
             c.getUser().getId()));
       }
    return c.setItems(i);
  }).cache();</span></pre>
<p><span class="koboSpan" id="kobo.1433.1">Here, we override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1434.1">insert()</span></strong><span class="koboSpan" id="kobo.1435.1"> method from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1436.1">OrderRepositoryExt</span></strong><span class="koboSpan" id="kobo.1437.1"> interface. </span><span class="koboSpan" id="kobo.1437.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1438.1">insert()</span></strong><span class="koboSpan" id="kobo.1439.1"> method is filled with fluent, functional, and reactive APIs. </span><span class="koboSpan" id="kobo.1439.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1440.1">insert()</span></strong><span class="koboSpan" id="kobo.1441.1"> method receives a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1442.1">NewOrder</span></strong><span class="koboSpan" id="kobo.1443.1"> model </span><strong class="source-inline"><span class="koboSpan" id="kobo.1444.1">Mono</span></strong><span class="koboSpan" id="kobo.1445.1"> instance as an argument that contains the payload</span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.1446.1"> for creating</span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.1447.1"> a new order. </span><span class="koboSpan" id="kobo.1447.2">Spring Data R2DBC does not allow fetching nested entities. </span><span class="koboSpan" id="kobo.1447.3">However, you can write a custom repository for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1448.1">Cart</span></strong><span class="koboSpan" id="kobo.1449.1"> in the same way you have written for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1450.1">Order</span></strong><span class="koboSpan" id="kobo.1451.1"> that can fetch </span><strong class="source-inline"><span class="koboSpan" id="kobo.1452.1">Cart</span></strong><span class="koboSpan" id="kobo.1453.1"> and its </span><span class="No-Break"><span class="koboSpan" id="kobo.1454.1">items together.</span></span></p>
<p><span class="koboSpan" id="kobo.1455.1">We are using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1456.1">ReactiveCrudRepository</span></strong><span class="koboSpan" id="kobo.1457.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1458.1">Cart</span></strong><span class="koboSpan" id="kobo.1459.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1460.1">Item</span></strong><span class="koboSpan" id="kobo.1461.1"> entities. </span><span class="koboSpan" id="kobo.1461.2">Therefore, we are fetching them one by one. </span><span class="koboSpan" id="kobo.1461.3">First, we use the item repository to fetch the cart items based on the given customer ID. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1462.1">Customer</span></strong><span class="koboSpan" id="kobo.1463.1"> has a one-to-one mapping with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1464.1">Cart</span></strong><span class="koboSpan" id="kobo.1465.1">. </span><span class="koboSpan" id="kobo.1465.2">Then, we fetch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1466.1">Cart</span></strong><span class="koboSpan" id="kobo.1467.1"> entity using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1468.1">CartRepository</span></strong><span class="koboSpan" id="kobo.1469.1"> by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1470.1">customer ID.</span></span></p>
<p><span class="koboSpan" id="kobo.1471.1">We get the two separate Mono objects – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1472.1">Mono&lt;List&lt;ItemEntity&gt;&gt;</span></strong><span class="koboSpan" id="kobo.1473.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1474.1">Mono&lt;CartEntity&gt;</span></strong><span class="koboSpan" id="kobo.1475.1">. </span><span class="koboSpan" id="kobo.1475.2">Now, we need to combine them. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1476.1">Mono</span></strong><span class="koboSpan" id="kobo.1477.1"> has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1478.1">zip()</span></strong><span class="koboSpan" id="kobo.1479.1"> operator, which allows you to take two </span><strong class="source-inline"><span class="koboSpan" id="kobo.1480.1">Mono</span></strong><span class="koboSpan" id="kobo.1481.1"> objects and then use the Java </span><strong class="source-inline"><span class="koboSpan" id="kobo.1482.1">BiFunction</span></strong><span class="koboSpan" id="kobo.1483.1"> to merge them. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1484.1">zip()</span></strong><span class="koboSpan" id="kobo.1485.1"> returns a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1486.1">Mono</span></strong><span class="koboSpan" id="kobo.1487.1"> object only when both the given </span><strong class="source-inline"><span class="koboSpan" id="kobo.1488.1">Mono</span></strong><span class="koboSpan" id="kobo.1489.1"> objects produce the item. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1490.1">zip()</span></strong><span class="koboSpan" id="kobo.1491.1"> is polymorphic and therefore other forms are </span><span class="No-Break"><span class="koboSpan" id="kobo.1492.1">also available.</span></span></p>
<p><span class="koboSpan" id="kobo.1493.1">We have the cart and its items, plus the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1494.1">NewOrder</span></strong><span class="koboSpan" id="kobo.1495.1"> payload. </span><span class="koboSpan" id="kobo.1495.2">Let’s insert these items into a database, as shown in the next </span><span class="No-Break"><span class="koboSpan" id="kobo.1496.1">code block:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1497.1">OrderRepositoryExtImpl.java</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1498.1">R2dbcEntityTemplate template = new</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.1499.1">R2dbcEntityTemplate</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1500.1">  (connectionFactory);</span></strong><span class="koboSpan" id="kobo.1501.1">
Mono&lt;OrderEntity&gt; orderEntity = Mono.zip(mdl,
   cartEntity, (m, c) -&gt; toEntity(m, c)).cache();
return orderEntity.flatMap(oe -&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1502.1">dbClient.sql</span></strong><span class="koboSpan" id="kobo.1503.1">("""
    INSERT INTO ecomm.orders (address_id,
    card_id, customer_id, order_date, total,
    status) VALUES($1, $2, $3, $4, $5, $6)
    """)
    .bind("$1", Parameter.fromOrEmpty(
       oe.getAddressId(), UUID.class))
    .bind("$2", Parameter.fromOrEmpty(
       oe.getCardId(), UUID.class))
    .bind("$3", Parameter.fromOrEmpty(
       oe.getCustomerId(), UUID.class))
    .bind("$4",OffsetDateTime.ofInstant(
       oe.getOrderDate().toInstant(), ZoneId.of(
        "Z")).truncatedTo(ChronoUnit.MICROS))
    .bind("$5", oe.getTotal())
    .bind("$6", StatusEnum.CREATED.getValue())
      .map(new </span><strong class="bold"><span class="koboSpan" id="kobo.1504.1">OrderMapper()::apply</span></strong><span class="koboSpan" id="kobo.1505.1">).one())
    .then(orderEntity.flatMap(x -&gt;
       </span><strong class="bold"><span class="koboSpan" id="kobo.1506.1">template.selectOne</span></strong><span class="koboSpan" id="kobo.1507.1">(
        query(where("customer_id").is(
           x.getCustomerId()).and("order_date")
            .greaterThanOrEquals(OffsetDateTime.
</span><span class="koboSpan" id="kobo.1507.2">            ofInstant(x.getOrderDate().
</span><span class="koboSpan" id="kobo.1507.3">              toInstant(),ZoneId.of("Z"))
              .truncatedTo(ChronoUnit.MICROS))),
        OrderEntity.class).map(t -&gt; x.setId(
             t.getId()).setStatus(t.getStatus()))
    ));</span></pre>
<p><span class="koboSpan" id="kobo.1508.1">Here, we again use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1509.1">Mono.zip()</span></strong><span class="koboSpan" id="kobo.1510.1"> to create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1511.1">OrderEntity</span></strong><span class="koboSpan" id="kobo.1512.1"> instance. </span><span class="koboSpan" id="kobo.1512.2">Now, we can use values from this instance to insert into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1513.1">orders</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1514.1"> table.</span></span></p>
<p><span class="koboSpan" id="kobo.1515.1">There are two ways to interact with the database to run SQL queries – by using either </span><strong class="source-inline"><span class="koboSpan" id="kobo.1516.1">DatabaseClient</span></strong><span class="koboSpan" id="kobo.1517.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1518.1">R2dbcEntityTemplate</span></strong><span class="koboSpan" id="kobo.1519.1">. </span><span class="koboSpan" id="kobo.1519.2">Now, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1520.1">DatabaseClient</span></strong><span class="koboSpan" id="kobo.1521.1"> is a lightweight implementation that uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1522.1">sql()</span></strong><span class="koboSpan" id="kobo.1523.1"> method to deal with SQL directly, whereas </span><strong class="source-inline"><span class="koboSpan" id="kobo.1524.1">R2dbcEntityTemplate</span></strong><span class="koboSpan" id="kobo.1525.1"> provides a fluent API for CRUD operations. </span><span class="koboSpan" id="kobo.1525.2">We have used both classes to demonstrate </span><span class="No-Break"><span class="koboSpan" id="kobo.1526.1">their usage.</span></span></p>
<p><span class="koboSpan" id="kobo.1527.1">First, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1528.1">DatabaseClient.sql()</span></strong><span class="koboSpan" id="kobo.1529.1"> to insert the new order into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1530.1">orders</span></strong><span class="koboSpan" id="kobo.1531.1"> table. </span><span class="koboSpan" id="kobo.1531.2">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1532.1">OrderMapper</span></strong><span class="koboSpan" id="kobo.1533.1"> to map the row returned from the database to the entity. </span><span class="koboSpan" id="kobo.1533.2">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1534.1">then()</span></strong><span class="koboSpan" id="kobo.1535.1"> reactive operator to select the newly inserted record and then map it back to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1536.1">orderEntity</span></strong><span class="koboSpan" id="kobo.1537.1"> using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1538.1">R2dbcEntityTemplate.selectOne()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1539.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.1540.1">Similarly, you can create repositories</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.1541.1"> for other entities. </span><span class="koboSpan" id="kobo.1541.2">Now, we can use these repositories</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.1542.1"> in services. </span><span class="koboSpan" id="kobo.1542.2">Let’s define services in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1543.1">next subsection.</span></span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.1544.1">Adding services</span></h2>
<p><span class="koboSpan" id="kobo.1545.1">Let’s add a service</span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.1546.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1547.1">Order</span></strong><span class="koboSpan" id="kobo.1548.1">. </span><span class="koboSpan" id="kobo.1548.2">There is no change in </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.1549.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1550.1">OrderService</span></strong><span class="koboSpan" id="kobo.1551.1"> interface, as shown next. </span><span class="koboSpan" id="kobo.1551.2">You just need to make sure that interface method signatures have reactive types as returned types to keep the non-blocking flow </span><span class="No-Break"><span class="koboSpan" id="kobo.1552.1">in place:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1553.1">
public interface OrderService {  Mono&lt;OrderEntity&gt; addOrder(@Valid Mono&lt;NewOrder&gt;
    newOrder);
  Mono&lt;OrderEntity&gt; updateMapping(@Valid OrderEntity
    orderEntity);
  Flux&lt;OrderEntity&gt; getOrdersByCustomerId(@NotNull @Valid
    String customerId);
  Mono&lt;OrderEntity&gt; getByOrderId(String id);
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/OrderService.java"><span class="No-Break"><span class="koboSpan" id="kobo.1554.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/OrderService.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1555.1">Next, you are going to implement</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.1556.1"> each of these four</span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.1557.1"> methods described in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1558.1">OrderService</span></strong><span class="koboSpan" id="kobo.1559.1">. </span><span class="koboSpan" id="kobo.1559.2">Let’s first implement the first two methods of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1560.1">OrderService</span></strong><span class="koboSpan" id="kobo.1561.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1562.1">following way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1563.1">
@Overridepublic </span><strong class="bold"><span class="koboSpan" id="kobo.1564.1">Mono&lt;OrderEntity&gt;</span></strong><span class="koboSpan" id="kobo.1565.1"> addOrder(@Valid Mono&lt;NewOrder&gt;
  newOrder) {
  return repository.insert(newOrder);
}
@Override
public </span><strong class="bold"><span class="koboSpan" id="kobo.1566.1">Mono&lt;OrderEntity&gt;</span></strong><span class="koboSpan" id="kobo.1567.1"> updateMapping(
  @Valid OrderEntity orderEntity) {
  return repository.updateMapping(orderEntity);
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/OrderServiceImpl.java"><span class="No-Break"><span class="koboSpan" id="kobo.1568.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/OrderServiceImpl.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1569.1">The first two are straightforward; we just use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1570.1">OrderRepository</span></strong><span class="koboSpan" id="kobo.1571.1"> instance to call the respective methods. </span><span class="koboSpan" id="kobo.1571.2">In an idle scenario, the overridden </span><strong class="source-inline"><span class="koboSpan" id="kobo.1572.1">updateMapping</span></strong><span class="koboSpan" id="kobo.1573.1"> method will trigger the rest of the process after updating </span><span class="No-Break"><span class="koboSpan" id="kobo.1574.1">the mappings:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1575.1">Initiate </span><span class="No-Break"><span class="koboSpan" id="kobo.1576.1">the payment.</span></span></li>
<li><span class="koboSpan" id="kobo.1577.1">Once the payment is authorized, change the status </span><span class="No-Break"><span class="koboSpan" id="kobo.1578.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1579.1">paid</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1580.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1581.1">Initiate the shipment and changed the status to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1582.1">Shipment Initiated</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1583.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1584.1">Shipped</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1585.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1586.1">As our application is not a real-world app</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.1587.1"> and we are writing</span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.1588.1"> for learning purposes, we are not writing the code for executing all three steps. </span><span class="koboSpan" id="kobo.1588.2">For simplicity, we are just updating </span><span class="No-Break"><span class="koboSpan" id="kobo.1589.1">the mapping.</span></span></p>
<p><span class="koboSpan" id="kobo.1590.1">Let’s implement the third one (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1591.1">getOrdersByCustomerId</span></strong><span class="koboSpan" id="kobo.1592.1">). </span><span class="koboSpan" id="kobo.1592.2">This is a bit tricky, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1593.1">shown next:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1594.1">OrderServiceImpl.java</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1595.1">
private </span><strong class="bold"><span class="koboSpan" id="kobo.1596.1">BiFunction</span></strong><span class="koboSpan" id="kobo.1597.1">&lt;OrderEntity, List&lt;ItemEntity&gt;, OrderEntity&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1598.1">biOrderItems</span></strong><span class="koboSpan" id="kobo.1599.1"> = (o, fi) -&gt; o    .setItems(fi);
@Override
public Flux&lt;OrderEntity&gt; getOrdersByCustomerId(
   String customerId) {
 return repository.findByCustomerId(UUID
  .fromString(customerId)).flatMap(order -&gt;
   Mono.just(order)
    .</span><strong class="bold"><span class="koboSpan" id="kobo.1600.1">zipWith</span></strong><span class="koboSpan" id="kobo.1601.1">(userRepo.findById(order.getCustomerId()))
    .</span><strong class="bold"><span class="koboSpan" id="kobo.1602.1">map</span></strong><span class="koboSpan" id="kobo.1603.1">(t -&gt; t.getT1().setUserEntity(t.getT2()))
    .zipWith(addRepo.findById(order.getAddressId()))
    .map(t -&gt;
          t.getT1().setAddressEntity(t.getT2()))
    .zipWith(cardRepo.findById(
       order.getCardId() != null
       ? </span><span class="koboSpan" id="kobo.1603.2">order.getCardId() : UUID.fromString(
         "0a59ba9f-629e-4445-8129-b9bce1985d6a"))
              .defaultIfEmpty(new CardEntity()))
    .map(t -&gt; t.getT1().setCardEntity(t.getT2()))
    .</span><strong class="bold"><span class="koboSpan" id="kobo.1604.1">zipWith</span></strong><span class="koboSpan" id="kobo.1605.1">(itemRepo.findByCustomerId(
        order.getCustomerId()).collectList(),</span><strong class="bold"><span class="koboSpan" id="kobo.1606.1">biOrderItems</span></strong><span class="koboSpan" id="kobo.1607.1">)
  );
}</span></pre>
<p><span class="koboSpan" id="kobo.1608.1">The previous method looks</span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.1609.1"> complicated, but it’s not. </span><span class="koboSpan" id="kobo.1609.2">What you</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.1610.1"> are doing here is basically fetching data from multiple repositories and then populating the nested entities inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1611.1">OrderEntity</span></strong><span class="koboSpan" id="kobo.1612.1">. </span><span class="koboSpan" id="kobo.1612.2">This is done with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1613.1">zipWith()</span></strong><span class="koboSpan" id="kobo.1614.1"> operator by using either the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1615.1">map()</span></strong><span class="koboSpan" id="kobo.1616.1"> operator alongside it or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1617.1">BiFunction</span></strong><span class="koboSpan" id="kobo.1618.1"> as a </span><span class="No-Break"><span class="koboSpan" id="kobo.1619.1">separate argument.</span></span></p>
<p><span class="koboSpan" id="kobo.1620.1">The preceding method first fetches the orders by using the customer ID, then flat maps the orders to populate its nested entities such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1621.1">Customer</span></strong><span class="koboSpan" id="kobo.1622.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1623.1">Order</span></strong><span class="koboSpan" id="kobo.1624.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1625.1">Items</span></strong><span class="koboSpan" id="kobo.1626.1">. </span><span class="koboSpan" id="kobo.1626.2">Therefore, we are using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1627.1">zipWith()</span></strong><span class="koboSpan" id="kobo.1628.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1629.1">flatMap()</span></strong><span class="koboSpan" id="kobo.1630.1"> operator. </span><span class="koboSpan" id="kobo.1630.2">If you observe the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.1631.1">zipWith()</span></strong><span class="koboSpan" id="kobo.1632.1">, it fetches the user entity and then sets the nested user entity’s property using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1633.1">map()</span></strong><span class="koboSpan" id="kobo.1634.1"> operator. </span><span class="koboSpan" id="kobo.1634.2">Similarly, other nested entities </span><span class="No-Break"><span class="koboSpan" id="kobo.1635.1">are populated.</span></span></p>
<p><span class="koboSpan" id="kobo.1636.1">In the last </span><strong class="source-inline"><span class="koboSpan" id="kobo.1637.1">zipWith()</span></strong><span class="koboSpan" id="kobo.1638.1"> operator, we are using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1639.1">BiFunction</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1640.1">biOrderItems</span></strong><span class="koboSpan" id="kobo.1641.1"> to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1642.1">item</span></strong><span class="koboSpan" id="kobo.1643.1"> entities in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1644.1">OrderEntity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1645.1"> instance.</span></span></p>
<p><span class="koboSpan" id="kobo.1646.1">The same algorithm is used to implement the last method (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1647.1">getOrderById</span></strong><span class="koboSpan" id="kobo.1648.1">) of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1649.1">OrderService</span></strong><span class="koboSpan" id="kobo.1650.1"> interface, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1651.1">following code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1652.1">OrderServiceImpl.java</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1653.1">
@Overridepublic Mono&lt;OrderEntity&gt; getByOrderId(String id) {
  return repository.findById(UUID.fromString(id))
   .flatMap(order -&gt;
     Mono.just(order)
      .zipWith(userRepo.findById(order.getCustomerId()))
      .map(t -&gt; t.getT1().setUserEntity(t.getT2()))
      .zipWith(addRepo.findById(order.getAddressId()))
      .map(t -&gt; t.getT1().setAddressEntity(t.getT2()))
      .zipWith(cardRepo.findById(order.getCardId()))
      .map(t -&gt; t.getT1().setCardEntity(t.getT2()))
      .zipWith(itemRepo.findByCustomerId
         (order.getCustomerId()).collectList()
            ,biOrderItems)
  );
}</span></pre>
<p><span class="koboSpan" id="kobo.1654.1">So far, you have</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.1655.1"> used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1656.1">zipWith()</span></strong><span class="koboSpan" id="kobo.1657.1"> operator</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.1658.1"> to merge different objects. </span><span class="koboSpan" id="kobo.1658.2">You may find another way to merge two </span><strong class="source-inline"><span class="koboSpan" id="kobo.1659.1">Mono</span></strong><span class="koboSpan" id="kobo.1660.1"> instances using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1661.1">Mono.zip()</span></strong><span class="koboSpan" id="kobo.1662.1"> operator, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1663.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1664.1">
private </span><strong class="bold"><span class="koboSpan" id="kobo.1665.1">BiFunction</span></strong><span class="koboSpan" id="kobo.1666.1">&lt;CartEntity, List&lt;ItemEntity&gt;, CartEntity&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1667.1">cartItemBiFun</span></strong><span class="koboSpan" id="kobo.1668.1"> = (c, i) -&gt; c    .setItems(i);
@Override
public Mono&lt;CartEntity&gt; getCartByCustomerId(String
  customerId) {
  Mono&lt;CartEntity&gt; cart = repository.findByCustomerId(
     UUID.fromString(customerId))
      .subscribeOn(Schedulers.boundedElastic());
  Mono&lt;UserEntity&gt; user = userRepo.findById(
     UUID.fromString(customerId))
      .subscribeOn(Schedulers.boundedElastic());
  cart = Mono.zip(cart, user, cartUserBiFun);
  Flux&lt;ItemEntity&gt; items =
      itemRepo.findByCustomerId(
         UUID.fromString(customerId))
      .subscribeOn(Schedulers.boundedElastic());
  return </span><strong class="bold"><span class="koboSpan" id="kobo.1669.1">Mono.zip</span></strong><span class="koboSpan" id="kobo.1670.1">(cart, items.collectList(),
     cartItemBiFun);
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/CardServiceImpl.java"><span class="No-Break"><span class="koboSpan" id="kobo.1671.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/CardServiceImpl.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1672.1">This example is taken</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.1673.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1674.1">CartServiceImpl</span></strong><span class="koboSpan" id="kobo.1675.1"> class. </span><span class="koboSpan" id="kobo.1675.2">Here, we make two separate calls – one using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1676.1">cart</span></strong><span class="koboSpan" id="kobo.1677.1"> repository</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.1678.1"> and another one from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1679.1">item</span></strong><span class="koboSpan" id="kobo.1680.1"> repository. </span><span class="koboSpan" id="kobo.1680.2">As a result, these two calls produce two </span><strong class="source-inline"><span class="koboSpan" id="kobo.1681.1">Mono</span></strong><span class="koboSpan" id="kobo.1682.1"> instances and merge them using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1683.1">Mono.zip()</span></strong><span class="koboSpan" id="kobo.1684.1"> operator. </span><span class="koboSpan" id="kobo.1684.2">This we call directly using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1685.1">Mono</span></strong><span class="koboSpan" id="kobo.1686.1">; the previous example was used on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1687.1">Mono</span></strong><span class="koboSpan" id="kobo.1688.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.1689.1">Flux</span></strong><span class="koboSpan" id="kobo.1690.1"> instances with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1691.1">zipWith()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1692.1"> operator.</span></span></p>
<p><span class="koboSpan" id="kobo.1693.1">Using similar techniques, the remaining services have been created. </span><span class="koboSpan" id="kobo.1693.2">You can find them </span><span class="No-Break"><span class="koboSpan" id="kobo.1694.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/service"><span class="No-Break"><span class="koboSpan" id="kobo.1695.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/service</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1696.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1697.1">You have implemented</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.1698.1"> async services that allow</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.1699.1"> you to perform async operations, including database calls. </span><span class="koboSpan" id="kobo.1699.2">Now, you can consume these service classes in controllers. </span><span class="koboSpan" id="kobo.1699.3">Let’s move our focus on to the last development subsection (controllers) of our reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.1700.1">API implementation.</span></span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.1701.1">Adding controller implementations</span></h2>
<p><span class="koboSpan" id="kobo.1702.1">REST controller interfaces</span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.1703.1"> are already generated</span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.1704.1"> by the OpenAPI Codegen tool. </span><span class="koboSpan" id="kobo.1704.2">We can now create an implementation of those interfaces. </span><span class="koboSpan" id="kobo.1704.3">The only different thing while implementing the reactive controller is having the reactive pipelines to call the services and assemblers. </span><span class="koboSpan" id="kobo.1704.4">You should also only return </span><strong class="source-inline"><span class="koboSpan" id="kobo.1705.1">ResponseEntity</span></strong><span class="koboSpan" id="kobo.1706.1"> objects wrapped in either </span><strong class="source-inline"><span class="koboSpan" id="kobo.1707.1">Mono</span></strong><span class="koboSpan" id="kobo.1708.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1709.1">Flux</span></strong><span class="koboSpan" id="kobo.1710.1"> based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1711.1">generated contract.</span></span></p>
<p><span class="koboSpan" id="kobo.1712.1">Let’s implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.1713.1">OrderApi</span></strong><span class="koboSpan" id="kobo.1714.1">, which is the controller interface for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1715.1">Orders</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1716.1">REST API:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1717.1">
@</span><strong class="bold"><span class="koboSpan" id="kobo.1718.1">RestController</span></strong><span class="koboSpan" id="kobo.1719.1">public class OrderController implements </span><strong class="bold"><span class="koboSpan" id="kobo.1720.1">OrderApi</span></strong><span class="koboSpan" id="kobo.1721.1"> {
  private final OrderRepresentationModelAssembler
    assembler;
  private OrderService service;
  public OrderController(OrderService service,
   OrderRepresentationModelAssembler assembler) {
     this.service = service;
     this.assembler = assembler;
  }</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/controller/OrderController.java"><span class="No-Break"><span class="koboSpan" id="kobo.1722.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/controller/OrderController.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1723.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1724.1">@RestController</span></strong><span class="koboSpan" id="kobo.1725.1"> is a trick that combines </span><strong class="source-inline"><span class="koboSpan" id="kobo.1726.1">@Controller</span></strong><span class="koboSpan" id="kobo.1727.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1728.1">@ResponseBody</span></strong><span class="koboSpan" id="kobo.1729.1">. </span><span class="koboSpan" id="kobo.1729.2">These are the same annotations we used in </span><a href="B19349_04.xhtml#_idTextAnchor097"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1730.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.1731.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1732.1">Writing Business Logic for APIs</span></em><span class="koboSpan" id="kobo.1733.1">, to create the REST controller. </span><span class="koboSpan" id="kobo.1733.2">However, the methods have different signatures now to apply the reactive pipelines. </span><span class="koboSpan" id="kobo.1733.3">Make sure you don’t break the reactive chain of calls or add any blocking calls. </span><span class="koboSpan" id="kobo.1733.4">If you do, either the REST call will not be fully non-blocking or you may see </span><span class="No-Break"><span class="koboSpan" id="kobo.1734.1">undesired results.</span></span></p>
<p><span class="koboSpan" id="kobo.1735.1">We use constructor-based dependency</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.1736.1"> injection to inject the order service</span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.1737.1"> and assembler. </span><span class="koboSpan" id="kobo.1737.2">Let’s add the </span><span class="No-Break"><span class="koboSpan" id="kobo.1738.1">method implementations:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1739.1">OrderController.java</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1740.1">
@Overridepublic </span><strong class="bold"><span class="koboSpan" id="kobo.1741.1">Mono</span></strong><span class="koboSpan" id="kobo.1742.1">&lt;ResponseEntity&lt;Order&gt;&gt;
   addOrder(@Valid </span><strong class="bold"><span class="koboSpan" id="kobo.1743.1">Mono</span></strong><span class="koboSpan" id="kobo.1744.1">&lt;NewOrder&gt; newOrder,
      </span><strong class="bold"><span class="koboSpan" id="kobo.1745.1">ServerWebExchange</span></strong><span class="koboSpan" id="kobo.1746.1"> exchange) {
  return service.addOrder(newOrder.cache())
    .zipWhen(x -&gt; service.updateMapping(x))
    .map(t -&gt; status(HttpStatus.CREATED)
      .body(assembler.entityToModel(
         t.getT2(), exchange)))
    .defaultIfEmpty(notFound().build());
}</span></pre>
<p><span class="koboSpan" id="kobo.1747.1">Both the method argument</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.1748.1"> and return type are reactive types (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1749.1">Mono</span></strong><span class="koboSpan" id="kobo.1750.1">), used as a wrapper. </span><span class="koboSpan" id="kobo.1750.2">Reactive controllers also have an extra parameter, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1751.1">ServerWebExchange</span></strong><span class="koboSpan" id="kobo.1752.1">, which we </span><span class="No-Break"><span class="koboSpan" id="kobo.1753.1">discussed earlier.</span></span></p>
<p><span class="koboSpan" id="kobo.1754.1">In this method, we simply pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1755.1">newOrder</span></strong><span class="koboSpan" id="kobo.1756.1"> instance to the service. </span><span class="koboSpan" id="kobo.1756.2">We have used </span><strong class="source-inline"><span class="koboSpan" id="kobo.1757.1">cache()</span></strong><span class="koboSpan" id="kobo.1758.1"> because we need to subscribe to it more than once. </span><span class="koboSpan" id="kobo.1758.2">We get the newly created </span><strong class="source-inline"><span class="koboSpan" id="kobo.1759.1">EntityOrder</span></strong><span class="koboSpan" id="kobo.1760.1"> through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1761.1">addOrder()</span></strong><span class="koboSpan" id="kobo.1762.1"> call. </span><span class="koboSpan" id="kobo.1762.2">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1763.1">zipWhen()</span></strong><span class="koboSpan" id="kobo.1764.1"> operator, which performs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1765.1">updateMapping</span></strong><span class="koboSpan" id="kobo.1766.1"> operation using the newly created order entity. </span><span class="koboSpan" id="kobo.1766.2">At the end, we send the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1767.1">Order</span></strong><span class="koboSpan" id="kobo.1768.1"> object by wrapping it inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1769.1">ResponseEntity</span></strong><span class="koboSpan" id="kobo.1770.1">. </span><span class="koboSpan" id="kobo.1770.2">Also, it returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1771.1">NOT FOUND 404</span></strong><span class="koboSpan" id="kobo.1772.1"> when an empty instance </span><span class="No-Break"><span class="koboSpan" id="kobo.1773.1">is returned.</span></span></p>
<p><span class="koboSpan" id="kobo.1774.1">Let’s have a look at other method</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.1775.1"> implementations</span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.1776.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1777.1">order</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1778.1">API interface:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1779.1">OrderController.java</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1780.1">
@Overridepublic </span><strong class="bold"><span class="koboSpan" id="kobo.1781.1">Mono</span></strong><span class="koboSpan" id="kobo.1782.1">&lt;ResponseEntity&lt;Flux&lt;Order&gt;&gt;&gt;
   getOrdersByCustomerId(@NotNull
     @Valid String customerId, </span><strong class="bold"><span class="koboSpan" id="kobo.1783.1">ServerWebExchange</span></strong><span class="koboSpan" id="kobo.1784.1">
       exchange) {
  return Mono
     .just(ok(assembler.toListModel(service
       .getOrdersByCustomerId(customerId),
         exchange)));
}
@Override
public </span><strong class="bold"><span class="koboSpan" id="kobo.1785.1">Mono</span></strong><span class="koboSpan" id="kobo.1786.1">&lt;ResponseEntity&lt;Order&gt;&gt;
   getByOrderId(String id, </span><strong class="bold"><span class="koboSpan" id="kobo.1787.1">ServerWebExchange</span></strong><span class="koboSpan" id="kobo.1788.1">
     exchange) {
  return service.getByOrderId(id).map(o -&gt;
     assembler.entityToModel(o, exchange))
      .map(ResponseEntity::ok)
      .defaultIfEmpty(notFound().build());
}</span></pre>
<p><span class="koboSpan" id="kobo.1789.1">In the previous code, both methods are kind of similar in nature; the service returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1790.1">OrderEntity</span></strong><span class="koboSpan" id="kobo.1791.1"> based on the given customer ID and order ID, respectively. </span><span class="koboSpan" id="kobo.1791.2">It then gets converted into a model and is wrapped inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1792.1">ResponseEntity</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1793.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1794.1">Mono</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1795.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1796.1">Similarly, other REST controllers are implemented using the same approach. </span><span class="koboSpan" id="kobo.1796.2">You can find the rest of them </span><span class="No-Break"><span class="koboSpan" id="kobo.1797.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/controller"><span class="No-Break"><span class="koboSpan" id="kobo.1798.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter05/src/main/java/com/packt/modern/api/controller</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1799.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1800.1">We are almost done</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.1801.1"> with the reactive</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.1802.1"> API implementation. </span><span class="koboSpan" id="kobo.1802.2">Let’s look into some of the other </span><span class="No-Break"><span class="koboSpan" id="kobo.1803.1">minor changes.</span></span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.1804.1">Adding H2 Console to an application</span></h2>
<p><span class="koboSpan" id="kobo.1805.1">The H2 Console app</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.1806.1"> is not available by default</span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.1807.1"> in Spring WebFlux the way it is available in Spring MVC. </span><span class="koboSpan" id="kobo.1807.2">However, you can add it by defining the bean on your own, </span><span class="No-Break"><span class="koboSpan" id="kobo.1808.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1809.1">
@Componentpublic class H2ConsoleComponent {
    private Server webServer;
    @Value("${modern.api.h2.console.port:8081}")
    Integer h2ConsolePort;
    @EventListener(ContextRefreshedEvent.class)
    public void start()
       throws java.sql.SQLException {
      this.webServer = org.h2.tools.Server
         .createWebServer("-webPort",
           h2ConsolePort.toString(), "-
             tcpAllowOthers").start();
    }
    @EventListener(ContextClosedEvent.class)
    public void stop() {
      this.webServer.stop();
    }
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/H2ConsoleComponent.java"><span class="No-Break"><span class="koboSpan" id="kobo.1810.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/java/com/packt/modern/api/H2ConsoleComponent.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1811.1">The previous code (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1812.1">H2ConsoleComponent</span></strong><span class="koboSpan" id="kobo.1813.1">) is</span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.1814.1"> straightforward; we have added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1815.1">start()</span></strong><span class="koboSpan" id="kobo.1816.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1817.1">stop()</span></strong><span class="koboSpan" id="kobo.1818.1"> methods, which are executed</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.1819.1"> on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1820.1">ContextRefreshEvent</span></strong><span class="koboSpan" id="kobo.1821.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1822.1">ContextStopEvent</span></strong><span class="koboSpan" id="kobo.1823.1">, respectively. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1824.1">ContextRefreshEvent</span></strong><span class="koboSpan" id="kobo.1825.1"> is an application event that gets fired when </span><strong class="source-inline"><span class="koboSpan" id="kobo.1826.1">ApplicationContext</span></strong><span class="koboSpan" id="kobo.1827.1"> is refreshed or initialized. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1828.1">ContextStopEvent</span></strong><span class="koboSpan" id="kobo.1829.1"> is also an application event that gets fired when </span><strong class="source-inline"><span class="koboSpan" id="kobo.1830.1">ApplicationContext</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1831.1">is closed.</span></span></p>
<p><span class="koboSpan" id="kobo.1832.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1833.1">start()</span></strong><span class="koboSpan" id="kobo.1834.1"> method creates the web server using the H2 library and starts it on a given port. </span><span class="koboSpan" id="kobo.1834.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1835.1">stop()</span></strong><span class="koboSpan" id="kobo.1836.1"> method stops the H2 web server, that is, the H2 </span><span class="No-Break"><span class="koboSpan" id="kobo.1837.1">Console app.</span></span></p>
<p><span class="koboSpan" id="kobo.1838.1">You need a different port to execute H2 Console, which can be configured by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1839.1">modern.api.h2.console.port=8081</span></strong><span class="koboSpan" id="kobo.1840.1"> property to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1841.1">application.properties</span></strong><span class="koboSpan" id="kobo.1842.1"> file. </span><span class="koboSpan" id="kobo.1842.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1843.1">h2ConsolePort</span></strong><span class="koboSpan" id="kobo.1844.1"> property is annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1845.1">@Value("${modern.api.h2.console.port:8081}")</span></strong><span class="koboSpan" id="kobo.1846.1">; therefore, the value configured in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1847.1">application.properties</span></strong><span class="koboSpan" id="kobo.1848.1"> will be picked and assigned to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1849.1">h2ConsolePort</span></strong><span class="koboSpan" id="kobo.1850.1"> when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1851.1">H2ConsoleComponent</span></strong><span class="koboSpan" id="kobo.1852.1"> bean is initialized by the Spring Framework. </span><span class="koboSpan" id="kobo.1852.2">The value </span><strong class="source-inline"><span class="koboSpan" id="kobo.1853.1">8081</span></strong><span class="koboSpan" id="kobo.1854.1"> will be assigned if the property is not defined in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1855.1">application.properties</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1856.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.1857.1">Since we are discussing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1858.1">application.properties</span></strong><span class="koboSpan" id="kobo.1859.1">, let’s have a look at some of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1860.1">other changes.</span></span></p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.1861.1">Adding application configuration</span></h2>
<p><span class="koboSpan" id="kobo.1862.1">We are going to use Flyway</span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.1863.1"> for database</span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.1864.1"> migration. </span><span class="koboSpan" id="kobo.1864.2">Let’s add the configuration required </span><span class="No-Break"><span class="koboSpan" id="kobo.1865.1">for it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1866.1">
spring.flyway.url=</span><strong class="bold"><span class="koboSpan" id="kobo.1867.1">jdbc:h2:file:./data/ecomm;AUTO_SERVER=TRUE;DB_CLOSE_DELAY=-1;IGNORECASE=TRUE;DATABASE_TO_UPPER=FALSE</span></strong><span class="koboSpan" id="kobo.1868.1">spring.flyway.schemas=</span><strong class="bold"><span class="koboSpan" id="kobo.1869.1">ecomm</span></strong><span class="koboSpan" id="kobo.1870.1">
spring.flyway.user=
spring.flyway.password=</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/resources/application.properties"><span class="No-Break"><span class="koboSpan" id="kobo.1871.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/src/main/resources/application.properties</span></span></a></p>
<p><span class="koboSpan" id="kobo.1872.1">You must be wondering why we are using JDBC here, instead of R2DBC. </span><span class="koboSpan" id="kobo.1872.2">This is because Flyway hasn’t yet started supporting R2DBC (at the time of writing). </span><span class="koboSpan" id="kobo.1872.3">You can change it to R2DBC once support </span><span class="No-Break"><span class="koboSpan" id="kobo.1873.1">is added.</span></span></p>
<p><span class="koboSpan" id="kobo.1874.1">We have specified the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1875.1">ecomm</span></strong><span class="koboSpan" id="kobo.1876.1"> schema</span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.1877.1"> and set a blank username </span><span class="No-Break"><span class="koboSpan" id="kobo.1878.1">and password.</span></span></p>
<p><span class="koboSpan" id="kobo.1879.1">Similarly, you can add the Spring Data configuration in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1880.1">application.properties</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1881.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1882.1">
spring.r2dbc.url=</span><strong class="bold"><span class="koboSpan" id="kobo.1883.1">r2dbc:h2:file://././data/ecomm?options=AUTO_SERVER=TRUE;DB_CLOSE_DELAY=-1;IGNORECASE=TRUE;DATABASE_TO_UPPER=FALSE;;TRUNCATE_LARGE_LENGTH=TRUE;DB_CLOSE_ON_EXIT=FALSE</span></strong><span class="koboSpan" id="kobo.1884.1">spring.r2dbc.driver=</span><strong class="bold"><span class="koboSpan" id="kobo.1885.1">io.r2dbc:r2dbc-h2</span></strong><span class="koboSpan" id="kobo.1886.1">
spring.r2dbc.name=
spring.r2dbc.password=</span></pre>
<p><span class="koboSpan" id="kobo.1887.1">Spring Data supports R2DBC; therefore, we are using an R2DBC-based URL. </span><span class="koboSpan" id="kobo.1887.2">We have set </span><strong class="source-inline"><span class="koboSpan" id="kobo.1888.1">io.r2dbc:r2dbc-h2</span></strong><span class="koboSpan" id="kobo.1889.1"> for the driver to H2 and set a blank username </span><span class="No-Break"><span class="koboSpan" id="kobo.1890.1">and password.</span></span></p>
<p><span class="koboSpan" id="kobo.1891.1">Similarly, we have added the following logging properties to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1892.1">logback-spring.xml</span></strong><span class="koboSpan" id="kobo.1893.1"> to add debug statements to the console for Spring R2DBC </span><span class="No-Break"><span class="koboSpan" id="kobo.1894.1">and H2:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1895.1">
&lt;logger name="</span><strong class="bold"><span class="koboSpan" id="kobo.1896.1">org.springframework.r2dbc</span></strong><span class="koboSpan" id="kobo.1897.1">"      level="debug" additivity="false"&gt;
   &lt;appender-ref ref="</span><strong class="bold"><span class="koboSpan" id="kobo.1898.1">STDOUT</span></strong><span class="koboSpan" id="kobo.1899.1">"/&gt;
&lt;/logger&gt;
&lt;logger name="</span><strong class="bold"><span class="koboSpan" id="kobo.1900.1">reactor.core</span></strong><span class="koboSpan" id="kobo.1901.1">" level="debug"
   additivity="false"&gt;
   &lt;appender-ref ref="</span><strong class="bold"><span class="koboSpan" id="kobo.1902.1">STDOUT</span></strong><span class="koboSpan" id="kobo.1903.1">"/&gt;
&lt;/logger&gt;
&lt;logger name="</span><strong class="bold"><span class="koboSpan" id="kobo.1904.1">io.r2dbc.h2</span></strong><span class="koboSpan" id="kobo.1905.1">" level="</span><strong class="bold"><span class="koboSpan" id="kobo.1906.1">debug</span></strong><span class="koboSpan" id="kobo.1907.1">"
    additivity="false"&gt;
   &lt;appender-ref ref="</span><strong class="bold"><span class="koboSpan" id="kobo.1908.1">STDOUT</span></strong><span class="koboSpan" id="kobo.1909.1">"/&gt;
&lt;/logger&gt;</span></pre>
<p><span class="koboSpan" id="kobo.1910.1">This concludes our implementation</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.1911.1"> of reactive RESTful</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.1912.1"> APIs. </span><span class="koboSpan" id="kobo.1912.2">Now, you can </span><span class="No-Break"><span class="koboSpan" id="kobo.1913.1">test them.</span></span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.1914.1">Testing reactive APIs</span></h2>
<p><span class="koboSpan" id="kobo.1915.1">Now, you must be looking</span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.1916.1"> forward to testing. </span><span class="koboSpan" id="kobo.1916.2">You can find the API client collection at the following location. </span><span class="koboSpan" id="kobo.1916.3">You can import it and then test the APIs using any API client that supports the HAR-type </span><span class="No-Break"><span class="koboSpan" id="kobo.1917.1">file import:</span></span></p>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/Chapter05-API-Collection.har"><span class="No-Break"><span class="koboSpan" id="kobo.1918.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter05/Chapter05-API-Collection.har</span></span></a></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1919.1">Building and running the Chapter 05 code</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1920.1">You can build the code by running </span><strong class="source-inline"><span class="koboSpan" id="kobo.1921.1">gradlew clean build</span></strong><span class="koboSpan" id="kobo.1922.1"> from the root of the project and run the service using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1923.1">java -jar build/libs/Chapter05-0.0.1-SNAPSHOT.jar</span></strong><span class="koboSpan" id="kobo.1924.1">. </span><span class="koboSpan" id="kobo.1924.2">Make sure to use Java 17 in </span><span class="No-Break"><span class="koboSpan" id="kobo.1925.1">the path.</span></span></p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.1926.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1927.1">I hope you enjoyed learning about reactive API development with an asynchronous, non-blocking, and functional paradigm. </span><span class="koboSpan" id="kobo.1927.2">At first glance, you may find it complicated if you are not very familiar with the fluent and functional paradigm, but with practice, you’ll start writing only functional-style code. </span><span class="koboSpan" id="kobo.1927.3">Definitely, familiarity with Java streams and functions will help you to grasp the </span><span class="No-Break"><span class="koboSpan" id="kobo.1928.1">concepts easily.</span></span></p>
<p><span class="koboSpan" id="kobo.1929.1">Now that you have reached the end of this chapter, you have the skills to write functional and reactive code. </span><span class="koboSpan" id="kobo.1929.2">You can write reactive, asynchronous, and non-blocking code and REST APIs. </span><span class="koboSpan" id="kobo.1929.3">You also learned about R2DBC, which will become more solid and enhanced in the future as long as reactive programming continues to </span><span class="No-Break"><span class="koboSpan" id="kobo.1930.1">be used.</span></span></p>
<p><span class="koboSpan" id="kobo.1931.1">In the next chapter, we’ll explore the security aspect of RESTful </span><span class="No-Break"><span class="koboSpan" id="kobo.1932.1">service development.</span></span></p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.1933.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.1934.1">Do you really need the reactive paradigm for </span><span class="No-Break"><span class="koboSpan" id="kobo.1935.1">application development?</span></span></li>
<li><span class="koboSpan" id="kobo.1936.1">Are there any disadvantages to using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1937.1">reactive paradigm?</span></span></li>
<li><span class="koboSpan" id="kobo.1938.1">Who plays the role of the subscriber in the case of an HTTP request in </span><span class="No-Break"><span class="koboSpan" id="kobo.1939.1">Spring WebFlux?</span></span></li>
</ol>
<h1 id="_idParaDest-146"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.1940.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1941.1">Yes, it is required only if you need vertical scaling. </span><span class="koboSpan" id="kobo.1941.2">In the cloud, you pay to use the resources, and reactive applications help you to use resources optimally. </span><span class="koboSpan" id="kobo.1941.3">This is a new way of achieving scale. </span><span class="koboSpan" id="kobo.1941.4">You need a small number of threads compared to non-reactive applications. </span><span class="koboSpan" id="kobo.1941.5">The cost of connection to a database, I/O, or any external source is a callback; therefore, reactive-based applications do not require much memory. </span><span class="koboSpan" id="kobo.1941.6">However, while reactive programming is superior in terms of vertical scaling, you should continue using your existing or non-reactive applications. </span><span class="koboSpan" id="kobo.1941.7">Even Spring recommends that. </span><span class="koboSpan" id="kobo.1941.8">There is no new or old style; both can co-exist. </span><span class="koboSpan" id="kobo.1941.9">However, when you need scaling for any special component or application, you can go the reactive way. </span><span class="koboSpan" id="kobo.1941.10">A few years back, Netflix replaced the Zuul API gateway with the reactive Zuul2 API gateway. </span><span class="koboSpan" id="kobo.1941.11">This helped them to achieve scale. </span><span class="koboSpan" id="kobo.1941.12">However, they still have/use </span><span class="No-Break"><span class="koboSpan" id="kobo.1942.1">non-reactive applications.</span></span></li>
<li><span class="koboSpan" id="kobo.1943.1">There are pros and cons to everything. </span><span class="koboSpan" id="kobo.1943.2">Reactive is no exception. </span><span class="koboSpan" id="kobo.1943.3">Reactive code is not easy to write compared to the imperative style. </span><span class="koboSpan" id="kobo.1943.4">It is very difficult to debug because it does not use a single thread. </span><span class="koboSpan" id="kobo.1943.5">However, if you have developers who are proficient in the reactive paradigm, this isn’t </span><span class="No-Break"><span class="koboSpan" id="kobo.1944.1">an issue.</span></span></li>
<li><span class="koboSpan" id="kobo.1945.1">WebFlux internal classes subscribe to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1946.1">Mono</span></strong><span class="koboSpan" id="kobo.1947.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.1948.1">Flux</span></strong><span class="koboSpan" id="kobo.1949.1"> streams sent by the controller and convert them into HTTP packets. </span><span class="koboSpan" id="kobo.1949.2">The HTTP protocol does support event streams. </span><span class="koboSpan" id="kobo.1949.3">However, for other media types, such as JSON, Spring WebFlux subscribes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1950.1">Mono</span></strong><span class="koboSpan" id="kobo.1951.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.1952.1">Flux</span></strong><span class="koboSpan" id="kobo.1953.1"> streams and waits till </span><strong class="source-inline"><span class="koboSpan" id="kobo.1954.1">onComplete()</span></strong><span class="koboSpan" id="kobo.1955.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1956.1">onError()</span></strong><span class="koboSpan" id="kobo.1957.1"> is triggered. </span><span class="koboSpan" id="kobo.1957.2">Then, it serializes the whole list of elements, or a single element in the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1958.1">Mono</span></strong><span class="koboSpan" id="kobo.1959.1">, in one HTTP response. </span><span class="koboSpan" id="kobo.1959.2">You can learn more about it in the </span><em class="italic"><span class="koboSpan" id="kobo.1960.1">Reactive </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1961.1">Core</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1962.1"> section.</span></span></li>
</ol>
<h1 id="_idParaDest-147"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.1963.1">Further reading</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.1964.1">Project </span><span class="No-Break"><span class="koboSpan" id="kobo.1965.1">Reactor: </span></span><a href="https://projectreactor.io"><span class="No-Break"><span class="koboSpan" id="kobo.1966.1">https://projectreactor.io</span></span></a></li>
<li><span class="koboSpan" id="kobo.1967.1">Spring Reactive </span><span class="No-Break"><span class="koboSpan" id="kobo.1968.1">documentation: </span></span><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html"><span class="No-Break"><span class="koboSpan" id="kobo.1969.1">https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html</span></span></a></li>
<li><span class="koboSpan" id="kobo.1970.1">Spring Data R2DBC – reference </span><span class="No-Break"><span class="koboSpan" id="kobo.1971.1">documentation: </span></span><a href="https://docs.spring.io/spring-data/r2dbc/docs/current/reference/html/"><span class="No-Break"><span class="koboSpan" id="kobo.1972.1">https://docs.spring.io/spring-data/r2dbc/docs/current/reference/html/</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1973.1">Hands-On Reactive Programming in Spring </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1974.1">5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1975.1">: </span></span><a href="https://www.packtpub.com/product/hands-on-reactive-programming-in-spring-5/9781787284951"><span class="No-Break"><span class="koboSpan" id="kobo.1976.1">https://www.packtpub.com/product/hands-on-reactive-programming-in-spring-5/9781787284951</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1977.1">Learn Java 17 Programming – Second </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1978.1">Edition</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1979.1">: </span></span><a href="https://www.packtpub.com/product/learn-java-17-programming-second-edition/9781803241432"><span class="No-Break"><span class="koboSpan" id="kobo.1980.1">https://www.packtpub.com/product/learn-java-17-programming-second-edition/9781803241432</span></span></a></li>
</ul>
</div>


<div class="Content" id="_idContainer019">
<h1 id="_idParaDest-148" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.1.1">Part 2 – Security, UI, Testing, and Deployment</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, you will learn how to secure REST APIs with JWTs and Spring Security. </span><span class="koboSpan" id="kobo.2.2">After completing this part, you will also be able to authorize REST endpoints based on user roles. </span><span class="koboSpan" id="kobo.2.3">You will learn how APIs are consumed by the UI app, and you will learn how to automate the unit testing and integration testing of APIs. </span><span class="koboSpan" id="kobo.2.4">By the end of this part, you will be able to containerize the built app and then deploy it in a </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">Kubernetes cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B19349_06.xhtml#_idTextAnchor148"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Securing REST Endpoints Using Authorization and Authentication</span></em></li>
<li><a href="B19349_07.xhtml#_idTextAnchor169"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Designing a User Interface</span></em></li>
<li><a href="B19349_08.xhtml#_idTextAnchor201"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Testing APIs</span></em></li>
<li><a href="B19349_09.xhtml#_idTextAnchor215"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.16.1">, </span><em class="italic"><span class="koboSpan" id="kobo.17.1">Deployment of Web Services</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer020">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer021">
</div>
</div>
</body></html>