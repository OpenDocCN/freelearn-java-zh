<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Mastering Character Animations"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Mastering Character Animations</h1></div></div></div><p>In this chapter, we'll cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Previewing animations in SDK</li><li class="listitem" style="list-style-type: disc">Creating an animation manager control</li><li class="listitem" style="list-style-type: disc">Extending the animation control</li><li class="listitem" style="list-style-type: disc">Handling jump animations</li><li class="listitem" style="list-style-type: disc">Creating a custom animation – leaning</li><li class="listitem" style="list-style-type: disc">Creating a subanimation</li><li class="listitem" style="list-style-type: disc">Lip syncing and facial expressions</li><li class="listitem" style="list-style-type: disc">Eye movement</li><li class="listitem" style="list-style-type: disc">Location-dependent animation – edge check</li><li class="listitem" style="list-style-type: disc">Inverse kinematics – aligning feet with ground</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Introduction</h1></div></div></div><p>In this chapter, we'll take a closer look at skeleton-based animations. These are central features in many games, and having a good framework can save a lot of time (and money) in a project.</p><p>For those who are completely new to the subject of animations, it's recommended that you have a <a id="id292" class="indexterm"/>look at the jMonkeyEngine tutorials and<a id="id293" class="indexterm"/> Hello Animation in particular at <a class="ulink" href="http://hub.jmonkeyengine.org/wiki/doku.php/jme3:beginner:hello_animation">http://hub.jmonkeyengine.org/wiki/doku.php/jme3:beginner:hello_animation</a>.</p></div></div>
<div class="section" title="Previewing animations in SDK"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Previewing animations in SDK</h1></div></div></div><p>Before <a id="id294" class="indexterm"/>digging into the code, let's just briefly see how we <a id="id295" class="indexterm"/>can use SDK to see the animations that are supplied with a model.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec100"/>How to do it...</h2></div></div></div><p>Perform the following steps to see the animations that are supplied with the model:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Find the model in the <span class="strong"><strong>Projects</strong></span> window. Right-click on it and select <span class="strong"><strong>Edit</strong></span> in <span class="strong"><strong>SceneComposer</strong></span> and you will get the following screenshot:<div class="mediaobject"><img src="graphics/6478OS_04_06.jpg" alt="How to do it..."/></div></li><li class="listitem">Find the <span class="strong"><strong>SceneExplorer</strong></span> window and open the model's node. Look for <span class="strong"><strong>AnimControl</strong></span> as seen in the preceding screenshot.</li><li class="listitem">Open the <span class="strong"><strong>AnimControl</strong></span> window and you will see the list of animations that are available. Then, navigate to the <span class="strong"><strong>Properties</strong></span> window to select any of the animations and play them in the model, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/6478OS_04_07.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec101"/>How it works...</h2></div></div></div><p>The <span class="strong"><strong>SceneExplorer</strong></span> window not only shows all the spatials that belong to a node, but also the controls that are attached to any spatial. Apart from adding new controls, it's also possible <a id="id296" class="indexterm"/>to change them. In the case of <code class="literal">AnimControl</code>, it's<a id="id297" class="indexterm"/> possible to set the current animation so it is played instantly. To stop playing it, we can select <code class="literal">null</code>.</p></div></div>
<div class="section" title="Creating an animation manager control"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Creating an animation manager control</h1></div></div></div><p>We will<a id="id298" class="indexterm"/> create a control that will handle the animations of a character. It will follow jMonkeyEngine's control pattern and extend <code class="literal">AbstractControl</code>. We won't actually use most of the functions of <code class="literal">AbstractControl</code> right away, but it's a neat way to offset some of the code from a possible <code class="literal">Character</code> class. It will also be easy to add functionalities later on.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec102"/>How to do it...</h2></div></div></div><p>To create a control that will handle the animations of a character, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a class called <code class="literal">CharacterAnimationManager</code> and have it extend <code class="literal">AbstractControl</code>. This class should also implement <code class="literal">AnimEventListener</code>, which <code class="literal">AnimControl</code> uses to tell our class when animations have finished playing.</li><li class="listitem">We're going to map Jaime's animations into an enum. This is so we don't have to do a lot of string comparisons. While we're at it, we'll add some basic logic to the enum as well. The name of the animation, whether the animation should loop or not, and the time <code class="literal">AnimControl</code> should take to blend to a new animation using the following code:<div class="informalexample"><pre class="programlisting">public enum Animation{
  Idle(LoopMode.Loop, 0.2f),
  Walk(LoopMode.Loop, 0.2f),
  Run(LoopMode.Loop, 0.2f),
  ...
  SideKick(LoopMode.DontLoop, 0.1f);

  Animation(LoopMode loopMode, float blendTime){
    this.loopMode = loopMode;
    this.blendTime = blendTime;
  }
  LoopMode loopMode;
  float blendTime;
}</pre></div><p>We need two fields as well: an <code class="literal">AnimControl</code> field called <code class="literal">animControl</code> and an <code class="literal">AnimChannel</code> called <code class="literal">mainChannel</code>.</p></li><li class="listitem">We set <a id="id299" class="indexterm"/>these in the <code class="literal">setSpatial</code> method, as shown in the following code. Don't forget to add the class to the <code class="literal">AnimControl</code> field as a listener, or we won't receive any calls when animations are finished:<div class="informalexample"><pre class="programlisting">public void setSpatial(Spatial spatial) {
  super.setSpatial(spatial);
  animControl = spatial.getControl(AnimControl.class);
  mainChannel = animControl.createChannel();
  animControl.addListener(this);
}</pre></div></li><li class="listitem">We define a new method called <code class="literal">setAnimation</code> in the following code. Inside this, we set the supplied animation to be <code class="literal">mainChannel</code> as the current one if it's not the same as the one playing now. We also set <code class="literal">loopMode</code> according to how it's defined in the enum:<div class="informalexample"><pre class="programlisting">public void setAnimation(Animation animation) {
  if(mainChannel.getAnimationName() == null || !mainChannel.getAnimationName().equals(animation.name())){
    mainChannel.setAnim(animation.name(), animation.blendTime);
    mainChannel.setLoopMode(animation.loopMode);
  }
}</pre></div></li><li class="listitem">In the <code class="literal">onAnimCycleDone</code> method, we create a control so that all animations that don't loop return to the idle animation, with the exception of <code class="literal">JumpStart</code>, which should switch to <code class="literal">Jumping</code> (as in midair) as shown in the following code:<div class="informalexample"><pre class="programlisting">public void onAnimCycleDone(AnimControl control, AnimChannel channel, String animName) {
  if(channel.getLoopMode() == LoopMode.DontLoop){
    Animation newAnim = Animation.Idle;
    Animation anim = Animation.valueOf(animName);
    switch(anim){
      case JumpStart:
        newAnim = Animation.Jumping;
        break;
    }
    setAnimation(newAnim);
  }
}</pre></div></li><li class="listitem">That's all that's needed to create a class that manages animations! To set this up from an application, we just need to load a model in the application and add the following line:<div class="informalexample"><pre class="programlisting">jaime.addControl(new AnimationManagerControl());</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec103"/>How it works…</h2></div></div></div><p>The <code class="literal">AnimControl</code> class is responsible for playing and keeping track of the animations. <code class="literal">AnimChannel</code> has a list of <code class="literal">Bones</code> that the animation should affect.</p><p>Since <a id="id300" class="indexterm"/>we let the enum decide the animation parameters for us, we don't need much code in the <code class="literal">setAnimation</code> method. We do however need to make sure we don't set the same animation if it is already playing or it could get stuck, repeating the first frame in a loop.</p><p>The <code class="literal">onAnimCycleDone</code> method is called from <code class="literal">AnimControl</code> whenever an animation reaches the end. Here, we decide what will happen when this occurs. If the animation is not looping, we must tell it what to do next. Playing the idle animation is a good choice.</p><p>We also have one special case. If you look at the animation list, you will notice that Jaime's jump animation is split into three parts. This is to make it easier to handle jumps of different lengths or the falling animation.</p><p>We will tell <code class="literal">AnimControl</code> to change the animation to a jumping action once <code class="literal">JumpStart</code> is done. We never change to <code class="literal">JumpEnd</code> once the jumping action has taken place however. Instead, this should be called from elsewhere when Jaime hits the ground after he jumps. How this is measured is dependent on the game logic, but since we're using the <code class="literal">Control</code> pattern, we could use <code class="literal">controlUpdate</code> to check Jaime's whereabouts.</p></div></div>
<div class="section" title="Extending the animation control"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec44"/>Extending the animation control</h1></div></div></div><p>In the <a id="id301" class="indexterm"/>previous recipe, we built the basics for an animation by managing the <code class="literal">Control</code> class. This would be fine for many types of games, but for a game where a character is in focus, let's say an FPS, we would want a more detailed control. This is where the concept of <code class="literal">AnimChannel</code> comes in handy. <code class="literal">AnimChannel</code> is a way of dividing a skeleton into different groups of bones and applying an animation only to them. As we will find out in this recipe, this means we can have different animations playing on different parts of the body at the same time.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>Applying animations only to certain channels can help reduce the workload tremendously for a character-focused game. Let's say we're making an FPS or RPG where the character can wield a number of different items and weapons, both one– and two–handed. Making full-body animations for all the combinations, including standing, walking, running, and more, is not feasible. If instead, you are able to apply the weapon animation only to the upper body and a walk animation to the lower body, you get a lot more freedom.</p></div></div><p>This recipe will also describe some other tricks that might help in developing the game.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec104"/>How to do it...</h2></div></div></div><p>We can have different animations playing on different parts of the body at the same time by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, we'll implement the <code class="literal">ActionListener</code> and <code class="literal">AnalogListener</code> interfaces in our animation's <code class="literal">manager</code> class. This will allow us to receive input directly from an input-handling class and decide which animations to play.</li><li class="listitem">Next, we define two <code class="literal">AnimChannels</code>: one for the upper body called <code class="literal">upperChannel</code> and one for the lower called <code class="literal">lowerChannel</code>. We also create a <code class="literal">Channel</code> enum to easily choose whether to play an animation in a separate channel or the whole body, as shown in the following code:<div class="informalexample"><pre class="programlisting">public enum Channel{
  Upper, Lower, All,
}</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The SceneExplorer can be used to find suitable bones as shown in the following screenshot:</li></ul></div><div class="mediaobject"><img src="graphics/6478OS_04_01.jpg" alt="How to do it..."/></div></li><li class="listitem">In <a id="id302" class="indexterm"/>the <code class="literal">setSpatial</code> method, we create the upper and lower channels in <code class="literal">AnimControl</code>. We let <code class="literal">AnimChannel</code> add all the bones recursively using the <code class="literal">addFromRootBone</code> method, as shown in the following code:<div class="informalexample"><pre class="programlisting">public void setSpatial(Spatial spatial) {
super.setSpatial(spatial);
  animControl = spatial.getControl(AnimControl.class);
  upperChannel = animControl.createChannel();
  lowerChannel = animControl.createChannel();
  upperChannel.addFromRootBone("spine");
  lowerChannel.addBone("Root");
  lowerChannel.addFromRootBone("pelvis");</pre></div></li><li class="listitem">In the same method, add this instance as <code class="literal">AnimEventListener</code> to <code class="literal">AnimControl</code> to receive events when animations change or cycle, as shown in the following code:<div class="informalexample"><pre class="programlisting">animControl.addListener(this);</pre></div></li><li class="listitem">To be able to set specific animations from other classes, we add a method called <code class="literal">setAnimation</code>, which takes an animation and <code class="literal">Channel</code> (enum) as the input, as shown in the following code:<div class="informalexample"><pre class="programlisting">public void setAnimation(Animation animation, Channel channel){
  switch(channel){
    case Upper:
      setAnimation(animation, upperChannel);
      break;
    ...
  }
}</pre></div></li><li class="listitem">In the <code class="literal">onAction</code> method, the control can receive input directly from <code class="literal">InputListener</code> and apply the logic on its own before setting the animation, as shown<a id="id303" class="indexterm"/> in the following code:<div class="informalexample"><pre class="programlisting">public void onAction(String name, boolean isPressed, float tpf) {
  if (name.equals("StrafeLeft")) {
    leftStrafe = isPressed;
  }
  ...
  } else if (name.equals("Jump") &amp;&amp; isPressed) {
    jumpStarted = true;
    setAnimation(Animation.JumpStart);
  }
  if(jumpStarted || firing){
    // Do nothing
  } else if(forward || backward || rightStrafe || leftStrafe)  {
    setAnimation(Animation.Walk);
  } else {
    setAnimation(Animation.Idle);
  }
}</pre></div></li><li class="listitem">Finally, to test the concept of <code class="literal">AnimChannels</code>, we can implement <code class="literal">ActionListener</code> in our <code class="literal">SimpleApplication</code> instance and bind some keys to it, as shown in the following code:<div class="informalexample"><pre class="programlisting">public void onAction(String name, boolean isPressed, float tpf) {
  if (name.equals("Anim1") &amp;&amp; isPressed) {
    jaime.getControl(AnimationChannelsControl.class)
.setAnimation(Animation.Walk, Channel.All);
  }
...
}</pre></div></li><li class="listitem">As an example of how the concept of <code class="literal">AnimChannels</code> can be used to create new animations out of combined ones, create a new application and set the walk animation on Jaime's <code class="literal">lowerChannel</code> while applying the jumping animation on <code class="literal">upperChannel</code>. Jaime will now commence a zombie walk impression.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec105"/>How it works...</h2></div></div></div><p>We can see that the <code class="literal">Animation</code> enum has had a field called <code class="literal">key</code> added. This is not necessary but is part of a way to not have to hard-code animation names.</p><p>By<a id="id304" class="indexterm"/> using the <code class="literal">addFromRootBone</code> method, the channel will <a id="id305" class="indexterm"/>automatically add all the bones recursively, starting with the bone that is supplied first. After adding spine to <code class="literal">upperChannel</code>, it will continue down the chain, adding shoulders, neck, arms, and hands, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6478OS_04_02.jpg" alt="How it works..."/><div class="caption"><p>Different animations applied to the upper and lower parts of the body</p></div></div><p>Since we implemented <code class="literal">ActionListener</code>, there's also an <code class="literal">onAction</code> method in the class, which can receive an input from a number of external sources, such as <code class="literal">InputListener</code>. This also means it can apply logic by itself before deciding on what to play and not simply being an animation-playing control. We can recognize the pattern used here from the <code class="literal">GameCharacterControl</code> class from <a class="link" href="ch02.html" title="Chapter 2. Cameras and Game Controls">Chapter 2</a>, <span class="emphasis"><em>Cameras and Game Controls</em></span>.</p><p>By supplying a <code class="literal">Properties</code> file that maps the animation names, it's possible to use models with different naming conventions. It's also easier for a designer or artist to try out a number of different animations without consulting a programmer to make changes.</p></div></div>
<div class="section" title="Handling jump animations"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Handling jump animations</h1></div></div></div><p>In this recipe, we'll show how the jumping animation can be handled in the animation manager<a id="id306" class="indexterm"/> control from previous recipes. Why does this require its own recipe? Animation-wise, jumping is usually a set of sequenced animations. If we look at Jaime, for example, there's <code class="literal">JumpStart</code>, <code class="literal">Jumping</code>, and <code class="literal">JumpEnd</code>. Normally, sequenced animations can be handled in the <code class="literal">onAnimCycleDone</code> method; when one animation ends, it can trigger the next. Jumping is different though since the middle jumping animation is indefinite and is on a loop. How long it plays depends on how long the character is in the air, which is driven by the gameplay or its physics.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec106"/>How to do it...</h2></div></div></div><p>You can handle jumping animations by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">For this, we'll need to add two more Booleans to our animation control: <code class="literal">jumpStarted</code> and <code class="literal">inAir</code>.</li><li class="listitem">We trigger the first part of the animation in the <code class="literal">onAction</code> method, as shown in the following code. The <code class="literal">jumpStarted</code> Boolean is used to let the class know that other animations should not start while the character is the jumping state:<div class="informalexample"><pre class="programlisting">public void onAction(String binding, boolean value, float tpf) {
  if (binding.equals("Jump") &amp;&amp; value) {
    jumpStarted = true;
    setAnimation(Animation.JumpStart);
  }
}</pre></div></li><li class="listitem">The <code class="literal">onAnimCycleDone</code> method should switch animations back to the jumping<a id="id307" class="indexterm"/> action once <code class="literal">JumpStart</code> has finished playing. We also set <code class="literal">inAir</code> to <code class="literal">true</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">public void onAnimCycleDone(AnimControl control, AnimChannel channel, String animName) {
  if(channel.getLoopMode() == LoopMode.DontLoop){
    Animation newAnim = Animation.Idle;
    Animation anim = Animation.valueOf(animName);
    switch(anim){
      case JumpStart:
        newAnim = Animation.Jumping;
        inAir = true;
        break;
    }
    setAnimation(newAnim, channel);
  }
}</pre></div></li><li class="listitem">The <code class="literal">controlUpdate</code> method is suitable to check whether the character has landed <a id="id308" class="indexterm"/>after jumping (or falling). We check this<a id="id309" class="indexterm"/> directly in <code class="literal">BetterCharacterControl</code> and change the animation if it is back on the ground, as shown in the following code:<div class="informalexample"><pre class="programlisting">protected void controlUpdate(float tpf) {
  if(inAir){
    BetterCharacterControl charControl =spatial.getControl(BetterCharacterControl.class);
    if(charControl != null &amp;&amp; charControl.isOnGround()){
      setAnimation(Animation.Idle);
      jumpStarted = false;
      inAir = false;
    }
  }
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec107"/>How it works...</h2></div></div></div><p>The implementation relies on the listener pattern where this control receives a notification of user actions from an external input class. In this project, we have a separate class that controls the character.</p><p>This <code class="literal">onAnimCycleDone</code> method is called by the <code class="literal">AnimControl</code> method when an animation has finished with one cycle (both looping and non-looping animations). Normally, when an animation ends, we'll want to switch to the idle animation to stop it from freezing. When <code class="literal">JumpStart</code> is finished, however, the character is most likely in midair and thus switches to a suitable looping animation. The <code class="literal">inAir</code> Boolean is used so the class knows it should start checking for when the character lands again.</p><p>Depending on the size of a project, the control class for the character and this animation-managing class might be merged into one. This should make some things easier, while the class itself might get bulky as more functions are implemented.</p><p>The <code class="literal">controlUpdate</code> class is called automatically with every tick, and here we can see whether the character is still airborne. In this implementation, <code class="literal">BetterCharacterControl</code> is used, and it has a method to see whether it is on ground. Jaime has<a id="id310" class="indexterm"/> a <code class="literal">JumpEnd</code> animation, but idle seems to work better with some blending.</p></div></div>
<div class="section" title="Creating a custom animation - leaning"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec46"/>Creating a custom animation - leaning</h1></div></div></div><p>Custom <a id="id311" class="indexterm"/>animation is the concept of directly manipulating the bones of a character's skeleton to create animations. We will explore this by making a control that can be used together with <a class="link" href="ch02.html" title="Chapter 2. Cameras and Game Controls">Chapter 2</a>, <span class="emphasis"><em>Cameras and Game Controls</em></span>. Together with this recipe, leaning can be used on characters other than the player and in networked games.</p><div class="mediaobject"><img src="graphics/6478OS_04_03.jpg" alt="Creating a custom animation - leaning"/><div class="caption"><p>Jaime leaning to the left</p></div></div><p>As in <a class="link" href="ch02.html" title="Chapter 2. Cameras and Game Controls">Chapter 2</a>, <span class="emphasis"><em>Cameras and Game Controls</em></span>, we have two ways to handle leaning: one is by using a key to lean toward the left and another to lean toward the right. The second one is to press a button and lean in any direction using the mouse, which is more common in computer games.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec108"/>Getting ready</h2></div></div></div><p>The control we are going to build will share some code with the recipe from <a class="link" href="ch02.html" title="Chapter 2. Cameras and Game Controls">Chapter 2</a>, <span class="emphasis"><em>Cameras and Game Controls</em></span>. The shared code will be explained there to save space, and it will most likely be used in tandem with this recipe, so being familiar with it is helpful.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec109"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We start by creating a new class that extends <code class="literal">AbstractControl</code> and implements <code class="literal">Action-</code> and <code class="literal">AnalogListener</code>.</li><li class="listitem">Next, we define some values that will help us control the leaning. The <code class="literal">leanValue</code> is the current amount of leaning that is applied. There needs to be a limit on how much the character can lean, which is set in <code class="literal">maxLean</code>. For this <a id="id312" class="indexterm"/>example, it's 45 degrees in either direction. The two Booleans <code class="literal">leanLeft</code> and <code class="literal">leanRight</code> define whether we're currently leaning in either direction using keys, and <code class="literal">leanFree</code> defines whether the mouse is used. The <code class="literal">leaningBone</code> is the bone that we'll modify, and we'll also store the bone's original rotation in <code class="literal">boneRotation</code> and use it as a base when leaning.</li><li class="listitem">When the control is added to a spatial, we need to look for a bone to apply the leaning to. We select spine as <code class="literal">leaningBone</code>, and clone its current rotation, as shown in the following code:<div class="informalexample"><pre class="programlisting">public void setSpatial(Spatial spatial) {
  super.setSpatial(spatial);
  Bone spine = spatial.getControl(SkeletonControl.class).getSkeleton().getBone("spine");
  if(spine != null){
    leaningBone = spine;
    boneRotation = leaningBone.getLocalRotation().clone();
  }
}</pre></div></li><li class="listitem">The <code class="literal">onAction</code> method will receive the input and should set the controlling Booleans, namely, <code class="literal">leanLeft</code>, <code class="literal">leanRight</code>, and <code class="literal">leanFree</code>. The <code class="literal">onAnalog</code> option receives the mouse input when <code class="literal">leanFree</code> is active.</li><li class="listitem">In the <code class="literal">controlUpdate</code> method, we check to see whether any leaning is to be applied, first to the left and then similarly to the right. If <code class="literal">leanValue</code> is near <code class="literal">0f</code>, we will round it off to <code class="literal">0</code>. If this happens, we give the control back to <code class="literal">AnimControl</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">protected void controlUpdate(float tpf) {
  if(leanLeft &amp;&amp; leanValue &lt; maxLean){
    leanValue += 0.5f * tpf;
  } else if(!leanFree &amp;&amp; leanValue &gt; 0f){
    leanValue -= 0.5f * tpf;
  }
  [mirror for right]
  if(leanValue &lt; 0.005f &amp;&amp; leanValue &gt; -0.005f){
    leanValue = 0f;
  }
  if(leanValue != 0f){
    lean(leanValue);
  } else {
    leaningBone.setUserControl(false);
  }
}</pre></div></li><li class="listitem">In the <code class="literal">lean</code> method, which applies the leaning to the bone, the first thing we do is<a id="id313" class="indexterm"/> clamp the value to be inside the allowed threshold. Next, we call <code class="literal">setUserControl</code> on the bone to let it know that it shouldn't apply animations before creating a new <code class="literal">Quaternion</code> class based on the original rotation, as shown in the following code:<div class="informalexample"><pre class="programlisting">private void lean(float value){
  FastMath.clamp(value, -maxLean, maxLean);
        
  leaningBone.setUserControl(true);
  Quaternion newQuat = boneRotation.add(new   Quaternion().fromAngles(-FastMath.QUARTER_PI * 0.35f, 0, -value));
  newQuat.normalizeLocal();
  leaningBone.setLocalRotation(newQuat);
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec110"/>How it works...</h2></div></div></div><p>When selecting a bone to apply the leaning to, it should be close to the base of the upper body of the character. On Jaime, the spine is a suitable bone.</p><p>When <code class="literal">Bone.setUserControl(true)</code> is called, we tell the bone that no animations should be applied and that we will handle any rotation or translation manually. This has to be called before we set the rotation, or an exception will be thrown. Likewise, when we're done, we need to call <code class="literal">setUserControl(false)</code> to give the control back to the user (or no animation would be played).</p><p>Manually controlling bones is powerful and can be useful for many different applications, such as precision aiming and head tracking. Getting everything right can be tricky, however, and most likely it's not something that you will do frequently.</p><p>This class can be used separately from <a class="link" href="ch02.html" title="Chapter 2. Cameras and Game Controls">Chapter 2</a>, <span class="emphasis"><em>Cameras and Game Controls</em></span>, or they can be merged together. The benefit of having them separate is that we can also apply them separately. For example, the player's own character in a FPS won't need this control since you would never see it lean anyway. In this case, it's all about the camera. However, other players in the same (networked) FPS will need it, as would AI enemies who might use the same character control class.</p><p>To learn <a id="id314" class="indexterm"/>more about how <code class="literal">leanValue</code> is used and applied, have a look at the <span class="emphasis"><em>Leaning around corners</em></span> recipe of <a class="link" href="ch02.html" title="Chapter 2. Cameras and Game Controls">Chapter 2</a>, <span class="emphasis"><em>Cameras and Game Controls</em></span>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec111"/>There's more...</h2></div></div></div><p>If we're using an imported model and don't have access to a list of the bones, how do we know which bone to use? One simple way is to open the model in <span class="strong"><strong>Scene Explorer</strong></span>. In <span class="strong"><strong>SkeletonControl</strong></span>, we can see all the bones the character has but not their relative position on the model. By right-clicking and selecting <span class="strong"><strong>Get attachment node</strong></span>, a new node will be created; also, by selecting it, we can see where it's located on the model. For more information on attachment nodes, have a look at the <span class="emphasis"><em>Retrieving an attachment node</em></span> recipe of <a class="link" href="ch01.html" title="Chapter 1. SDK Game Development Hub">Chapter 1</a>, <span class="emphasis"><em>SDK Game Development Hub</em></span>.</p></div></div>
<div class="section" title="Creating a subanimation"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec47"/>Creating a subanimation</h1></div></div></div><p>In this <a id="id315" class="indexterm"/>recipe, we're going to use SceneComposer to create subanimations. As the name implies, they're derived from an animation. Subanimations can be a good way to squeeze some extra out of stock models that don't have the exact animations you want, or if the modeler has gone home for the day. In this particular application, we'll prepare for the next recipe, which is about lip syncing. The <span class="strong"><strong>Extract sub animation</strong></span> window in SDK looks, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6478OS_04_04.jpg" alt="Creating a subanimation"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec112"/>Getting ready</h2></div></div></div><p>The biggest <a id="id316" class="indexterm"/>caveat when creating subanimations is that the jMonkeyEngine API uses relative time when interacting with models, while subanimations are created on a frame basis. So, the easiest way to find out which frames to extract is to open the model in an external editor and look at it in parallel.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec113"/>How to do it...</h2></div></div></div><p>Extracting<a id="id317" class="indexterm"/> a subanimation can be done by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">With the model opened in the Scene Composer, we expand <span class="strong"><strong>AnimControl</strong></span>.</li><li class="listitem">Now, we can see all the animations that are currently available. We right-click on an animation we would like to create a subanimation out of and choose the option, <span class="strong"><strong>Extract Sub-animation</strong></span>.</li><li class="listitem">Enter a start and end frame and it's done. The new animation is now available in the <span class="strong"><strong>AnimControl</strong></span> option.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec114"/>How it works...</h2></div></div></div><p>An animation in jMonkeyEngine consists of a number of <code class="literal">BoneTracks</code>. Each of these has an array of floats with the times for the animations, an array of <code class="literal">Vector3f</code> with the positions of the bones, array of Quaternions with rotations, and another array of <code class="literal">Vector3f's</code> with scales. Each instance of the arrays contains information about a frame.</p><p>A<a id="id318" class="indexterm"/> subanimation is a copy of an excerpt from all the <code class="literal">BoneTracks</code> in the parent animation.</p></div></div>
<div class="section" title="Lip syncing and facial expressions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec48"/>Lip syncing and facial expressions</h1></div></div></div><p>This recipe handles two important parts of making characters seem alive and sentient. Technically, they can be handled using <code class="literal">AnimChannel</code>, but they still deserve their own mention <a id="id319" class="indexterm"/>as they have some special requirements.</p><p>Lip syncing<a id="id320" class="indexterm"/> revolves around something called <span class="strong"><strong>Phoneme</strong></span>, which is<a id="id321" class="indexterm"/> the distinct shape the mouth takes when making certain sounds. The number of phonemes a character has varies according to different needs, but there is a basic set that is used to create believable mouth movements.</p><p>Finally, we'll use jMonkeyEngine's <span class="strong"><strong>Cinematics</strong></span> system to apply them in sequence and have the <a id="id322" class="indexterm"/>character speak (mime) a word. Cinematics is jMonkeyEngine's scripting system, and it can be used both to create in-game-scripted events and cutscenes. It is covered in more depth in <a class="link" href="ch09.html" title="Chapter 9. Taking Our Game to the Next Level">Chapter 9</a>, <span class="emphasis"><em>Taking Our Game to the Next Level</em></span>.</p><p>We'll follow the control pattern in this recipe, and control can be merged into another animation controller or be kept alone.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec115"/>Getting ready</h2></div></div></div><p>Having a model with phoneme animations ready or creating them in an external modeling program is preferred. It's perfectly all right if the animations are one-frame static expressions.</p><p>If the previous options are not available, one method is to use the SDK's functionality to create subanimations. A version of Jaime with phoneme animations is supplied with the project for the sake of this recipe. For those interested in going through the process of creating subanimations themselves, there is a list of the ones used in the <span class="emphasis"><em>Enabling nightly builds</em></span> section in <a class="link" href="apa.html" title="Appendix A. Information Fragments">Appendix</a>, <span class="emphasis"><em>Information Fragments</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec116"/>How to do it...</h2></div></div></div><p>All the required functionalities can be implemented in a single class by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To start off, we <a id="id323" class="indexterm"/>create a new class called <code class="literal">ExpressionsControl</code> that extends <code class="literal">AbstractControl</code>.</li><li class="listitem">Inside <a id="id324" class="indexterm"/>this, we add <code class="literal">AnimControl</code> named <code class="literal">animControl</code>, one <code class="literal">AnimChannel</code> called <code class="literal">mouthChannel</code>, and another <code class="literal">AnimChannel</code> called <code class="literal">eyeBrowChannel</code>.</li><li class="listitem">We define an enum to keep track of the phonemes that the controller supports. These are some of the most common ones, plus a <code class="literal">RESET</code> option for a neutral mouth expression, as shown in the following code:<div class="informalexample"><pre class="programlisting">public enum PhonemeMouth{
  AAAH, EEE, I, OH, OOOH, FUH, MMM, LUH, ESS, RESET;
};</pre></div></li><li class="listitem">We create another enum to set the expressions of the eyes, which is a simple way of adding emotions to what the character says, as shown in the following code:<div class="informalexample"><pre class="programlisting">public enum ExpressionEyes{
  NEUTRAL, HAPPY, ANGRY;
};</pre></div></li><li class="listitem">In the <code class="literal">setSpatial</code> method, we create <code class="literal">AnimChannel</code> for mouth animations and one for the eyes, then we add suitable bones to each of these, as shown in the following code. The list of bones available can be seen in <code class="literal">SkeletonControl</code> in <code class="literal">SceneComposer</code>.<div class="informalexample"><pre class="programlisting">mouthChannel = animControl.createChannel();
mouthChannel.addBone("LipSide.L");
...</pre></div></li><li class="listitem">Since the animations we'll use might just be one or a few frames each, we can set <code class="literal">LoopMode</code> to <code class="literal">Loop</code> or <code class="literal">Cycle</code>. The speed has to be higher than <code class="literal">0</code> or blending won't work. Set these for both <code class="literal">AnimChannels</code>.</li><li class="listitem">Then, we have two setter methods to directly set an expression or phoneme in the control. The naming convention might differ depending on the assets, and it's good to have a small blending value:<div class="informalexample"><pre class="programlisting">public void setPhoneme(PhonemeMouth p){
  mouthChannel.setAnim("Phoneme_" + p.name(), 0.2f);
}
public void setExpression(ExpressionEyes e){
  eyeBrowChannel.setAnim("Expression_" + e.name(), 0.2f);
}</pre></div></li><li class="listitem">We can reuse any test class we might have from other recipes and just apply some new code to it as seen in the following code snippet. We set up a simple<a id="id325" class="indexterm"/> cinematic sequence that makes Jaime say (or mime) <span class="emphasis"><em>Hello</em></span> and look happy.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>When this <a id="id326" class="indexterm"/>recipe was written, the following <code class="literal">AnimationEvent</code> constructor did not exist and <code class="literal">AnimChannels</code> were not applied properly. A patch has been submitted but may not have made it into a stable build. If required, the patch can be found in the <span class="emphasis"><em>The AnimationEvent patch</em></span> section in <a class="link" href="apa.html" title="Appendix A. Information Fragments">Appendix</a>, <span class="emphasis"><em>Information Gathering</em></span>. It can also be acquired by turning on nightly builds in the SDK.</p></div></div></li></ol></div><div class="informalexample"><pre class="programlisting">public void setupHelloCinematic() {
  cinematicHello = new Cinematic((Node)jaime, 1f);
  stateManager.attach(cinematicHello);
  cinematicHello.addCinematicEvent(0.0f, new AnimationEvent(jaime, "Expression_HAPPY", LoopMode.Cycle, 2, 0.2f));
  cinematicHello.addCinematicEvent(0.1f, new AnimationEvent(jaime, "Phoneme_EEE", LoopMode.Cycle, 1, 0.1f));
  cinematicHello.addCinematicEvent(0.2f, new AnimationEvent(jaime, "Phoneme_LUH", LoopMode.Cycle, 1, 0.1f));
  cinematicHello.addCinematicEvent(0.3f, new AnimationEvent(jaime, "Phoneme_OOOH", LoopMode.Cycle, 1, 0.1f));
  cinematicHello.addCinematicEvent(0.7f, new AnimationEvent(jaime, "Phoneme_RESET", LoopMode.Cycle, 1, 0.2f));

  cinematicHello.setSpeed(1.0f);
  cinematicHello.setLoopMode(LoopMode.DontLoop);
  cinematicHello.play();
}</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec117"/>How it works...</h2></div></div></div><p>The technical principles behind the phonemes are not that different from animating other parts of the character. We create <code class="literal">AnimChannels</code>, which handles different sets of bones. The first tricky bit is to organize the channels if you want to be able to control different parts of the body at the same time.</p><p>The pipeline for how to apply the phonemes can also be difficult. The first step will be to not set them directly in the code. It's not implausible that changing the expression of the character could be called directly from the code on certain events. Doing so for each phoneme in <a id="id327" class="indexterm"/>a sentence would be very cumbersome. Using the cinematics system is a good start as it would be relatively simple to write a piece of code that parses<a id="id328" class="indexterm"/> a text file and creates a cinematic sequence from it. Timing is really crucial, and it can take a lot of time to get the movements synced with sound. Doing it in a format that allows you to have a quick iteration is important.</p><p>Another more complex way would be to build up a database that maps words and phonemes and automatically applies them in a sequence.</p><p>The absolutely simplest approach is to not really care about lip syncing and just apply a moving mouth animation whenever the character speaks.</p></div></div>
<div class="section" title="Eye movement"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec49"/>Eye movement</h1></div></div></div><p>Eye contact is <a id="id329" class="indexterm"/>an important factor to make characters feel alive and aware of yours and other things' presence. In this chapter, we'll make a control that will follow a spatial with its eyes, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6478OS_04_05.jpg" alt="Eye movement"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec118"/>How to do it...</h2></div></div></div><p>Eye tracking can be implemented in a single control using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We begin by creating a new class called <code class="literal">EyeTrackingControl</code> that extends <code class="literal">AbstractControl</code>.</li><li class="listitem">It <a id="id330" class="indexterm"/>needs two <code class="literal">Bone</code> fields: one called <code class="literal">leftEye</code> and another called <code class="literal">rightEye</code>. Furthermore, we should add a spatial called <code class="literal">lookAtObject</code> and a related <code class="literal">Vector3f</code> called <code class="literal">focusPoint</code>.</li><li class="listitem">In the <code class="literal">setSpatial</code> method, we find and store the bones for <code class="literal">leftEye</code> and <code class="literal">rightEye</code>.</li><li class="listitem">We also need a method to set <code class="literal">lookAtObject</code>.</li><li class="listitem">With this done, we add most of the other functionalities to the <code class="literal">controlUpdate</code> method. First of all, we need to take control of the bones or we won't be able to modify their rotation, as shown in the following code:<div class="informalexample"><pre class="programlisting">if(enabled &amp;&amp; lookAtObject != null){
  leftEye.setUserControl(true);
  rightEye.setUserControl(true);</pre></div></li><li class="listitem">Next, we need to establish the <code class="literal">lookAtObject</code> position that is relative to the eyes. We do this by converting the position to model space and storing it in <code class="literal">focusPoint</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">focusPoint.set(lookAtObject.getWorldTranslation().subtract(getSpatial().getWorldTranslation()));</pre></div></li><li class="listitem">Subtracting the eye position from <code class="literal">Vector3f</code> gives us the relative direction:<div class="informalexample"><pre class="programlisting">Vector3f eyePos = leftEye.getModelSpacePosition();
Vector3f direction = eyePos.subtract(focusPoint).negateLocal();</pre></div></li><li class="listitem">We create a new Quaternion and have it look in the direction of the <code class="literal">direction</code> vector. We can apply this on our eyes after modifying it a bit as its 0-rotation is up:<div class="informalexample"><pre class="programlisting">Quaternion q = new Quaternion();
q.lookAt(direction, Vector3f.UNIT_Y);
q.addLocal(offsetQuat);
q.normalizeLocal();</pre></div></li><li class="listitem">Then, we apply it by using <code class="literal">setUserTransformsWorld</code>. Finally, we give the control of the bones back to the system using the following code:<div class="informalexample"><pre class="programlisting">leftEye.setUserTransformsWorld(leftEye.getModelSpacePosition(), q);
rightEye.setUserTransformsWorld(rightEye.getModelSpacePosition(), q);
leftEye.setUserControl(false);
rightEye.setUserControl(false);</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec119"/>How it works...</h2></div></div></div><p>The actual code is a fairly straightforward trigonometry, but knowing what values to use and the flow of doing it can be tricky.</p><p>Once<a id="id331" class="indexterm"/> the class receives an object to look at, it subtracts the model's <code class="literal">worldTranslation</code> from <code class="literal">lookAtObjects</code> so they end up in a coordinate<a id="id332" class="indexterm"/> system that is relative to the model's origo point also called <span class="strong"><strong>modelspace</strong></span>.</p><p>Using <code class="literal">setUserTransformsWorld</code> also sets the position, but since we supply its current <code class="literal">modelSpacePosition</code>, no change will be applied.</p><p>Actually, the direction of each eye should be calculated separately for the result to be entirely correct.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec120"/>There's more...</h2></div></div></div><p>By now, the character has a very intent stare at the camera. This is an improvement, but it can be made more lifelike. Something that may not be so obvious is that we rarely look at the same point all the time even if we look at the same object. We can emulate this behavior by adding a random bit of flickering to the control:</p><div class="informalexample"><pre class="programlisting">private float flickerTime = 0f;
private float flickerAmount = 0.2f;
private Vector3f flickerDirection = new Vector3f();</pre></div><p>By introducing these three fields, we have a base for what we want to do:</p><div class="informalexample"><pre class="programlisting">flickerTime += tpf * FastMath.nextRandomFloat();
if(flickerTime &gt; 0.5f){
  flickerTime = 0;
  flickerDirection.set(FastMath.nextRandomFloat() * flickerAmount, FastMath.nextRandomFloat() * flickerAmount, 0);
}
direction.addLocal(flickerDirection);</pre></div><p>This piece of code goes in the middle of the <code class="literal">controlUpdate</code> method, right after calculating the direction. What we do is we increase <code class="literal">flickerTime</code> until it reaches 0.5f (note that this is not in seconds since we apply a random number). Once this happens, we randomize <code class="literal">flickerDirection</code> based on <code class="literal">flickerAmount</code> and reset <code class="literal">flickerTime</code>.</p><p>With each consecutive update, we will apply this to the calculated direction and slightly offset the <a id="id333" class="indexterm"/>focus point.</p></div></div>
<div class="section" title="Location-dependent animation &#x2013; edge check"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec50"/>Location-dependent animation – edge check</h1></div></div></div><p>In certain <a id="id334" class="indexterm"/>games, players traverse dangerous areas where a fall off from a ledge could lead to their deaths. Sometimes, in these games, the player is not meant to fall off and their movement is restricted when they are close, or the player gets an extra warning before they plummet.</p><p>The control we'll develop can be used for any of those things, but since this chapter is about animations, we'll use it to play a special animation when the player gets too close to the edge.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec121"/>Getting ready</h2></div></div></div><p>The recipe will use similar patterns that have been used before in this chapter and we'll also use the animation manager control from earlier in the chapter. Any animation control will be fine to use, but it should have separate channels for the upper and lower parts of the body.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec122"/>How to do it...</h2></div></div></div><p>We can implement almost everything we need in a single class as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We begin by creating a class called <code class="literal">EdgeCheckControl</code>, which extends <code class="literal">AbstractControl</code> and contains the following fields, as shown in the following code:<div class="informalexample"><pre class="programlisting">private Ray[] rays = new Ray[9];
private float okDistance = 0.3f;
private Spatial world;
private boolean nearEdge;</pre></div></li><li class="listitem">We define the nine rays that will be used for collision detection. In the <code class="literal">setSpatial</code> method, we instantiate them and aim them downwards, as shown in the following code:<div class="informalexample"><pre class="programlisting">for(int i = 0; i &lt; 9; i++){
  rays[i] = new Ray();
  rays[i].setDirection(Vector3f.UNIT_Y.negate());
}</pre></div></li><li class="listitem">In the <code class="literal">controlUpdate</code> method, we begin by placing one of the rays at the center of the character, as shown in the following code:<div class="informalexample"><pre class="programlisting">Vector3f origo = getSpatial().getWorldTranslation();
rays[0].setOrigin(origo);</pre></div></li><li class="listitem">We step <a id="id335" class="indexterm"/>around the character, placing the remaining rays in a circular shape. For each, we see whether it collides with something using the <code class="literal">checkCollision</code> method. If it doesn't, we don't need to check the rest and can exit the loop using the following code:<div class="informalexample"><pre class="programlisting">float angle;
for(int i = 1; i &lt; 9; i++){
  float x = FastMath.cos(angle);
  float z = FastMath.sin(angle);
  rays[i].setOrigin(origo.add(x * 0.5f, 0, z * 0.5f));
            
  collision = checkCollision(rays[i]);
  if(!collision){
    break;
  }
  angle += FastMath.QUARTER_PI;
}
private boolean checkCollision(Ray r){
  CollisionResults collResuls = new CollisionResults();
  world.collideWith(r, collResuls);
  if(collResuls.size() &gt; 0 &amp;&amp; r.getOrigin().distance(collResuls.getClosestCollision().getContactPoint()) &gt; okDistance){
    return true;
  }
  return false;
}</pre></div></li><li class="listitem">In the last step in this method, we call the animation manager and tell it to play or stop playing the near-edge animation, as shown in the following code. We do this based on whether all the collisions have been detected or not, making sure we only send any change in state:<div class="informalexample"><pre class="programlisting">if(!collision &amp;&amp; !nearEdge){
  nearEdge = true; spatial.getControl(AnimationManagerControl.class).onAction("NearEdge", true, 0);
} else if(collision &amp;&amp; nearEdge){
  nearEdge = false;  spatial.getControl(AnimationManagerControl.class).onAction("NearEdge", false, 0);
}</pre></div></li><li class="listitem">Switching to our animation manager class, we modify it accordingly. The state is stored here so it can be used to see what other animations are allowed to be played, as follows:<div class="informalexample"><pre class="programlisting">if (binding.equals("NearEdge")) {
  nearEdge = value;
  if(nearEdge){
    setAnimation(Animation.Jumping, Channel.Upper);
  }
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec123"/>How it works...</h2></div></div></div><p>With each<a id="id336" class="indexterm"/> update, the nine rays we create are placed in a circle around the character, with one in the center.</p><p>They will check for collisions with a surface below them. If any of them (this might be changed to two or three) does not hit something within <code class="literal">okDistance</code>, it will be reported as the character being close to a dangerous edge.</p><p>The <code class="literal">okDistance</code> has to be set to something suitable, higher than a step on a stair, probably at a height where the player could take damage.</p><p>When this happens, the animation manager will be called with the <code class="literal">NearEdge</code> action set to <code class="literal">true</code>. This will apply the jumping animation (wild flaying of the arms) to the upper body of the character while still allowing other animations to be played on the lower part.</p><p>The <code class="literal">NearEdge</code> Boolean is used to make sure that we only send the call to the animation manager once.</p><p>When doing collision checks, one should be careful about the amount and shape of the objects that are being collided. If the world is large or constructed from complex shapes (or even worse, if it has <code class="literal">MeshCollisionShape</code>), we should try to find optimized ways of applying the method. One way could be to separate the world into parts and have an auxiliary method to select which part to collide against. This method might use <code class="literal">contains</code> on <code class="literal">BoundingVolume</code> to see the part the player is located in.</p></div></div>
<div class="section" title="Aligning feet with ground &#x2013; inverse kinematics"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec51"/>Aligning feet with ground – inverse kinematics</h1></div></div></div><p>Inverse kinematics is now a common part of animation systems in games and is a topic that might cover a chapter on its own. In this recipe, we'll look at placing a character's feet in <a id="id337" class="indexterm"/>accordance to the ground below. This is useful where an animation would otherwise place them in the air or on sloped ground.</p><p>Normally, animations work according to forward kinematics; that is, when a bone near the root of the skeleton rotates, it affects the bones further down the chain. As the name implies, Inverse Kinematics starts at the other end.</p><p>Here, we strive toward a desired position for the tip of a chain of bones, and bones further up the chain try to align themselves to suit this.</p><p>The most straightforward implementation of this rotates the bones by a small amount on all the axes. It then checks which of the rotations brings the tip closest to the desired position. This is repeated for all the bones in the chain and iterated until it has come close enough.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec124"/>Getting ready</h2></div></div></div><p>A <a id="id338" class="indexterm"/>model with <code class="literal">SkeletonControl</code> is needed for this recipe, and it's recommended that you be familiar with its setup. At the time of writing this recipe, the resident monkey, Jaime, is used.</p><p>This recipe uses an experimental feature that at the time of writing this is not part of a core build. To use it, you can build jMonkeyEngine yourself from the sources. You can also get it by enabling nightly builds. Refer to <a class="link" href="apa.html" title="Appendix A. Information Fragments">Appendix</a>, <span class="emphasis"><em>Information Fragments,</em></span> to find out how to change this setting.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec125"/>How to do it...</h2></div></div></div><p>Perform the following steps to get the basic IK functionality:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's begin by creating a new class that extends <code class="literal">AbstractControl</code>, and define a list that will contain the bones we want to use as tip bones.</li><li class="listitem">In the <code class="literal">setSpatial</code> method, we add both the feet and toe bones to the list. We also supply some values that <code class="literal">KinematicRagdollControl</code> should work with when applying the IK and tell it which bones to work with, as shown in the following code:<div class="informalexample"><pre class="programlisting">setupJaime(spatial.getControl(KinematicRagdollControl.class));    spatial.getControl(KinematicRagdollControl.class).setIKThreshold(0.01f); spatial.getControl(KinematicRagdollControl.class).setLimbDampening(0.9f); spatial.getControl(KinematicRagdollControl.class).setIkRotSpeed(18);</pre></div></li><li class="listitem">We create <a id="id339" class="indexterm"/>a method called <code class="literal">sampleTargetPositions</code> that goes through each of our targets and finds a position the control should try to reach, as shown in the following code:<div class="informalexample"><pre class="programlisting">public void sampleTargetPositions(){
  float offset = -1.9f;
  for(Bone bone: targets){
    Vector3f targetPosition = bone.getModelSpacePosition().add(spatial.getWorldTranslation());
    CollisionResult closestResult = contactPointForBone(targetPosition, offset);
    if(closestResult != null){
                spatial.getControl(KinematicRagdollControl.class).setIKTarget(bone, closestResult.getContactPoint().addLocal(0, 0.05f, 0), 2);
    }
  }</pre></div></li><li class="listitem">Finally, in the created method, we call <code class="literal">KinematicRagdollControl</code> and tell it to switch to the Inverse Kinematics mode:<div class="informalexample"><pre class="programlisting">spatial.getControl(KinematicRagdollControl.class).setIKMode();</pre></div></li><li class="listitem">To make it reusable, we use the <code class="literal">setEnabled</code> method to clear things up when the control is not in use; we make it apply IK when it's enabled again:<div class="informalexample"><pre class="programlisting">if(enabled){
  sampleTargetPositions();
} else {
            spatial.getControl(KinematicRagdollControl.class).removeAllIKTargets();
            spatial.getControl(KinematicRagdollControl.class).setKinematicMode();
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec126"/>How it works...</h2></div></div></div><p>The list we defined contains the bones that we want to have at the end of the chain. These are the bones that the control will try to get as close to the target position as possible. To get the feet at a suitable angle, we not only need the feet but also the toe bones. By trying to align both the feet and the toe bones, we get a better approximation of the ground below.</p><p>Unlike <a id="id340" class="indexterm"/>most of our controls, we don't actually do anything in the <code class="literal">controlUpdate</code> method. This is because the actual alignment is passed on to <code class="literal">KinematicRagdollControl</code>. Instead, we do a check each time the control is enabled and see what positions it should try to reach.</p><p>For each of the tip bones, we shoot a ray straight up, using an offset to start some way below the ground. The reason we don't just use the bones' position and check below it is because we can't be sure that the model is completely above the ground. Animations might very well push body parts inside the ground, and if we then shot a ray downwards, we wouldn't hit what we want.</p><p>Once a target position is found, we supply the bone to <code class="literal">KinematicRagdollControl</code>. Along with this is also an integer that defines how long the chain of bones should be that it can modify when trying to reach the target.</p><p>There are some more values we supply to <code class="literal">KinematicRagdollControl</code>. The <code class="literal">IKThreshold</code> value is <a id="id341" class="indexterm"/>the distance from the target point where it is okay for it to stop trying.</p><p>
<code class="literal">LimbDampening</code> can <a id="id342" class="indexterm"/>be used to effect how much a bone should move in relation to others. Imagine we're stretching out for something on our desk. Our forearms are most likely to perform bigger movements (rotation-wise) than our upper arms. If <code class="literal">limbDampening</code> is lower than 1.0, the bones higher up in the chain (and likely bigger) will move less with each update than those closer to the tip bone.</p><p>
<code class="literal">IKRotSpeed</code> defines<a id="id343" class="indexterm"/> the rotation steps the control should apply with each turn. A higher value means it'll get closer quicker, but it also means the margin of error becomes higher.</p><p>All these values require tweaking to get them right for the application. Implementation is just the first step. The <code class="literal">KinematicRagdollControl</code> method also needs some setting up, most importantly, it needs to know the bones it should be able to control.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec127"/>There's more...</h2></div></div></div><p>If we've implemented the recipe thus far, we can see that the result is not what we expected. On wobbly legs, resembling rubber or cooked spaghetti, our character slowly adjusts to the ground below it.</p><p>The most<a id="id344" class="indexterm"/> disturbing thing is probably that the legs seem to go in any direction. Fortunately, this can be remedied with some tweaking. The <code class="literal">KinematicRagdollControl</code> function has <a id="id345" class="indexterm"/>a method called <code class="literal">setJointLimit</code>, which does what it says. It can set the limits to how much rotation can be applied on each axis of a bone. Getting it right for all the bones will take some time though.</p></div></div></body></html>