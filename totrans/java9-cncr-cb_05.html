<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Fork/Join Framework</h1>
            

            <article>
                
<p class="calibre4">In this chapter, we will cover:</p>
<ul class="calibre17">
<li class="calibre18">Creating a fork/join pool</li>
<li class="calibre18">Joining the results of the tasks</li>
<li class="calibre18">Running tasks asynchronously</li>
<li class="calibre18">Throwing exceptions in the tasks</li>
<li class="calibre18">Canceling a task</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Introduction</h1>
            

            <article>
                
<p class="calibre4">Normally, when you implement a simple, concurrent Java application, you implement some <kbd class="calibre15">Runnable</kbd> objects and then the corresponding <kbd class="calibre15">Thread</kbd> objects. You control the creation, execution, and status of those threads in your program. Java 5 introduced an improvement with the <kbd class="calibre15">Executor</kbd> and <kbd class="calibre15">ExecutorService</kbd> interfaces and the classes that implement them (for example, the <kbd class="calibre15">ThreadPoolExecutor</kbd> class).</p>
<p class="calibre4">The <strong class="calibre1">Executor</strong> framework separates the task creation and its execution. With it, you only have to implement the <kbd class="calibre15">Runnable</kbd> objects and use an <kbd class="calibre15">Executor</kbd> object. You send the <kbd class="calibre15">Runnable</kbd> tasks to the executor and it creates, manages, and finalizes the necessary threads to execute those tasks.</p>
<p class="calibre4">Java 7 goes a step further and includes an additional implementation of the <kbd class="calibre15">ExecutorService</kbd> interface oriented to a specific kind of problem. It's the <strong class="calibre1">fork/join framework</strong>.</p>
<p class="calibre4">This framework is designed to solve problems that can be broken into smaller tasks using the divide and conquer technique. Inside a task, you check the size of the problem you want to resolve, and if it's bigger than an established size, you divide it into smaller tasks that are executed using the framework. If the size of the problem is smaller than the established size, you solve the problem directly in the task, and then, optionally, it returns a result. The following diagram summarizes this concept:</p>
<div class="cdpaligncenter"><img class="image-border6" src="../images/00033.jpeg"/></div>
<p class="calibre4">There is no formula to determine the reference size of a problem that determines if a task is to be subdivided or not, depending on its characteristics. You can use the number of elements to process in the task and an estimation of the execution time to determine the reference size. Test different reference sizes to choose the best one for your problem. You can consider <kbd class="calibre15">ForkJoinPool</kbd> as a special kind of <kbd class="calibre15">Executor</kbd>.</p>
<p class="calibre4">The framework is based on the following two operations:</p>
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">Fork operation</strong>: When you divide a task into smaller tasks and execute them using the framework.</li>
<li class="calibre18"><strong class="calibre1">Join operation</strong>: When a task waits for the finalization of the tasks it has created. It's used to combine the results of those tasks.</li>
</ul>
<p class="calibre4">The main difference between the fork/join and the <a class="calibre9">Executor</a> frameworks is the <a class="calibre9"><strong class="calibre1">work-stealing</strong></a> algorithm. Unlike the <a class="calibre9">Executor framework</a>, when a task is waiting for the finalization of the subtasks it has created using the join operation, the thread that is executing that task (called <strong class="calibre1">worker thread</strong>) looks for other tasks that have not been executed yet and begins their execution. In this way, the threads take full advantage of their running time, thereby improving the performance of the application.</p>
<p class="calibre4">To achieve this goal, the tasks executed by the fork/join framework have the following limitations:</p>
<ul class="calibre17">
<li class="calibre18">Tasks can only use the <kbd class="calibre15">fork()</kbd> and <kbd class="calibre15">join()</kbd> operations as synchronization mechanisms. If they use other synchronization mechanisms, the worker threads can't execute other tasks when they are in the synchronization operation. For example, if you put a task to sleep in the fork/join framework, the worker thread that is executing that task won't execute another one during the sleeping time.</li>
<li class="calibre18">Tasks should not perform I/O operations such as read or write data in a file.</li>
<li class="calibre18">Tasks can't throw checked exceptions. They have to include the code necessary to process them.</li>
</ul>
<p class="calibre4">The core of the fork/join framework is formed by the following two classes:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">ForkJoinPool</kbd>: This class implements the <kbd class="calibre15">ExecutorService</kbd> interface and the work-stealing algorithm. It manages the worker threads and offers information about the status of the tasks and their execution.</li>
<li class="calibre18"><kbd class="calibre15">ForkJoinTask</kbd>: This is the base class of the tasks that will execute in theÂ <kbd class="calibre15">ForkJoinPool</kbd>. It provides the mechanisms to execute the <kbd class="calibre15">fork()</kbd> and <kbd class="calibre15">join()</kbd> operations inside a task and the methods to control the status of the tasks. Usually, to implement your fork/join tasks, you will implement a subclass of three subclasses of this class: <kbd class="calibre15">RecursiveAction</kbd> for tasks with no return result, <kbd class="calibre15">RecursiveTask</kbd> for tasks that return one result, and <kbd class="calibre15">CountedCompleter</kbd> for tasks that launch a completion action when all the subtasks have finished.</li>
</ul>
<p class="calibre4">Most of the features provided by this framework were included in Java 7, but Java 8 included minor features in it. It included a default <kbd class="calibre15">ForkJoinPool</kbd> object. You can obtain it using the static method, <kbd class="calibre15">commonPool()</kbd>, of the <kbd class="calibre15">ForkJoinPool</kbd> class. This default fork/join executor will by default use the number of threads determined by the available processors of your computer. You can change this default behavior by changing the value of the system property, <kbd class="calibre15">java.util.concurrent.ForkJoinPool.common.parallelism</kbd>. This default pool is used internally by other classes of the Concurrency API. For example, <strong class="calibre1">Parallel Streams</strong> use it. Java 8 also included the <kbd class="calibre15">CountedCompleter</kbd> class mentioned earlier.</p>
<p class="calibre4">This chapter presents five recipes that show you how to work efficiently with the fork/join framework.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Creating a fork/join pool</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you will learn how to use the basic elements of the fork/join framework. This includes the following:</p>
<ul class="calibre17">
<li class="calibre18">Creating a <kbd class="calibre15">ForkJoinPool</kbd> object to execute the tasks</li>
<li class="calibre18">Creating a subclass of <kbd class="calibre15">ForkJoinTask</kbd> to be executed in the pool</li>
</ul>
<p class="calibre4">The main characteristics of the fork/join framework you're going to use in this example are as follows:</p>
<ul class="calibre17">
<li class="calibre18">You will create <kbd class="calibre15">ForkJoinPool</kbd> using the default constructor.</li>
<li class="calibre18">Inside the task, you will use the structure recommended by the Java API documentation:</li>
</ul>
<pre class="calibre23">
        if (problem size &gt; default size){ <br class="title-page-name"/>          tasks=divide(task); <br class="title-page-name"/>          execute(tasks); <br class="title-page-name"/>        } else { <br class="title-page-name"/>          resolve problem using another algorithm; <br class="title-page-name"/>        } 
</pre>
<ul class="calibre17">
<li class="calibre18">You will execute the tasks in a synchronized way. When a task executes two or more subtasks, it waits for their finalizations. In this way, the thread that was executing that task (called <a class="calibre9">worker thread</a>) will look for other tasks to execute, taking full advantage of their execution time.</li>
<li class="calibre18">The tasks you're going to implement won't return any result, so you'll take the <kbd class="calibre15">RecursiveAction</kbd> class as the base class for their implementation.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example in this recipe has been implemented using the Eclipse IDE. If you use Eclipse or other IDEs, such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">In this recipe, you are going to implement a task to update the price of a list of products. The initial task will be responsible for updating all the elements in a list. You will use a size 10 as the reference size, so if a task has to update more than 10 elements, it divides the part of the list assigned to it in two parts and creates two tasks to update the prices of the products in the respective parts.</p>
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Product</kbd> that will store the name and price of a product:</li>
</ol>
<pre class="calibre23">
        public class Product { 
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> attribute named <kbd class="calibre15">name</kbd> and a <kbd class="calibre15">private</kbd> double attribute named <kbd class="calibre15">price</kbd>:</li>
</ol>
<pre class="calibre23">
        private String name; <br class="title-page-name"/>        private double price; 
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement getter and setter methods for those fields. They are very simple to implement, so its source code is not included.</li>
<li value="4" class="calibre18">Create a class named <kbd class="calibre15">ProductListGenerator</kbd> to generate a list of random products:</li>
</ol>
<pre class="calibre23">
        public class ProductListGenerator { 
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the <kbd class="calibre15">generate()</kbd> method. It receives an <kbd class="calibre15">int</kbd> parameter with the size of the list and returns a <kbd class="calibre15">List&lt;Product&gt;</kbd> object with the list of generated products:</li>
</ol>
<pre class="calibre23">
        public List&lt;Product&gt; generate (int size) { 
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Create the object to return the list of products:</li>
</ol>
<pre class="calibre23">
        List&lt;Product&gt; ret=new ArrayList&lt;Product&gt;(); 
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Generate the list of products. Assign the same price to all of the products, for example, <kbd class="calibre15">10</kbd>, to check that the program works well:</li>
</ol>
<pre class="calibre23">
          for (int i=0; i&lt;size; i++){ <br class="title-page-name"/>            Product product=new Product(); <br class="title-page-name"/>            product.setName("Product "+i); <br class="title-page-name"/>            product.setPrice(10); <br class="title-page-name"/>            ret.add(product); <br class="title-page-name"/>          } <br class="title-page-name"/>          return ret; <br class="title-page-name"/>        } 
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd>. Specify that it extends the <kbd class="calibre15">RecursiveAction</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class Task extends RecursiveAction { 
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Declare a <kbd class="calibre15">private List&lt;Product&gt;</kbd> attribute named products:</li>
</ol>
<pre class="calibre23">
        private List&lt;Product&gt; products; 
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Declare two private <kbd class="calibre15">int</kbd> attributes named <kbd class="calibre15">first</kbd> and <kbd class="calibre15">last</kbd>. These attributes will determine the block of products this task has to process:</li>
</ol>
<pre class="calibre23">
        private int first; <br class="title-page-name"/>        private int last; 
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Declare a private <kbd class="calibre15">double</kbd> attribute named <kbd class="calibre15">increment</kbd> to store the increment of the price of the products:</li>
</ol>
<pre class="calibre23">
        private double increment; 
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Implement the constructor of the class that will initialize all the attributes of the class:</li>
</ol>
<pre class="calibre23">
        public Task (List&lt;Product&gt; products, int first, int last,<br class="title-page-name"/>                     double increment) { <br class="title-page-name"/>          this.products=products; <br class="title-page-name"/>          this.first=first; <br class="title-page-name"/>          this.last=last; <br class="title-page-name"/>          this.increment=increment; <br class="title-page-name"/>        } 
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Implement the <kbd class="calibre15">compute()</kbd> method, which will implement the logic of the task:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        protected void compute() { 
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">If the difference of the <kbd class="calibre15">last</kbd> and <kbd class="calibre15">first</kbd> attributes is less than <kbd class="calibre15">10</kbd> (the task has to update the price of less than <kbd class="calibre15">10</kbd> products), increment the price of that set of products using the <kbd class="calibre15">updatePrices()</kbd> method:</li>
</ol>
<pre class="calibre23">
        if (last - first&lt;10) { <br class="title-page-name"/>          updatePrices(); 
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">If the difference between the <kbd class="calibre15">last</kbd> and <kbd class="calibre15">first</kbd> attributes is greater than or equal to <kbd class="calibre15">10</kbd>, create two new <kbd class="calibre15">Task</kbd> objects, one to process the first half of the products and the other to process the second half, and execute them in <kbd class="calibre15">ForkJoinPool</kbd> using the <kbd class="calibre15">invokeAll()</kbd> method:</li>
</ol>
<pre class="calibre23">
        } else { <br class="title-page-name"/>          int middle=(last+first)/2; <br class="title-page-name"/>          System.out.printf("Task: Pending tasks:%s\n",<br class="title-page-name"/>                            getQueuedTaskCount()); <br class="title-page-name"/>          Task t1=new Task(products, first,middle+1, increment); <br class="title-page-name"/>          Task t2=new Task(products, middle+1,last, increment); <br class="title-page-name"/>          invokeAll(t1, t2);   <br class="title-page-name"/>        } 
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Implement the <kbd class="calibre15">updatePrices()</kbd> method. This method updates the products that occupy the positions between the values of the <kbd class="calibre15">first</kbd> and <kbd class="calibre15">last</kbd> attributes in the list of products:</li>
</ol>
<pre class="calibre23">
        private void updatePrices() { <br class="title-page-name"/>          for (int i=first; i&lt;last; i++){ <br class="title-page-name"/>            Product product=products.get(i); <br class="title-page-name"/>            product.setPrice(product.getPrice()*(1+increment)); <br class="title-page-name"/>          } <br class="title-page-name"/>        } 
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> and add the <kbd class="calibre15">main()</kbd> method to it:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) { 
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Create a list of <kbd class="calibre15">10000</kbd> products using the <kbd class="calibre15">ProductListGenerator</kbd> class:</li>
</ol>
<pre class="calibre23">
        ProductListGenerator generator=new ProductListGenerator(); <br class="title-page-name"/>        List&lt;Product&gt; products=generator.generate(10000); 
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Create a new <kbd class="calibre15">Task</kbd> object to update the <kbd class="calibre15">prices</kbd> of all the products in the list. The parameter <kbd class="calibre15">first</kbd> takes the value <kbd class="calibre15">0</kbd> and the <kbd class="calibre15">last</kbd> parameter takes the value <kbd class="calibre15">10000</kbd> (the size of the product list):</li>
</ol>
<pre class="calibre23">
        Task task=new Task(products, 0, products.size(), 0.20); 
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Create a <kbd class="calibre15">ForkJoinPool</kbd> object using the constructor without parameters:</li>
</ol>
<pre class="calibre23">
        ForkJoinPool pool=new ForkJoinPool(); 
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Execute the task in the pool using the <kbd class="calibre15">execute()</kbd> method:</li>
</ol>
<pre class="calibre23">
        pool.execute(task); 
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Implement a block of code that shows information about the evolution of the pool every five milliseconds, writing to the console the value of some parameters of the pool until the task finishes its execution:</li>
</ol>
<pre class="calibre23">
        do { <br class="title-page-name"/>          System.out.printf("Main: Thread Count:%d\n",<br class="title-page-name"/>                            pool.getActiveThreadCount()); <br class="title-page-name"/>          System.out.printf("Main: Thread Steal:%d\n",<br class="title-page-name"/>                            pool.getStealCount()); <br class="title-page-name"/>          System.out.printf("Main: Parallelism:%d\n",<br class="title-page-name"/>                            pool.getParallelism()); <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.MILLISECONDS.sleep(5); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        } while (!task.isDone()); 
</pre>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">Shut down the pool using the <kbd class="calibre15">shutdown()</kbd> method:</li>
</ol>
<pre class="calibre23">
        pool.shutdown(); 
</pre>
<ol start="23" class="calibre19">
<li value="23" class="calibre18">Check if the task has finished without errors with the <kbd class="calibre15">isCompletedNormally()</kbd> method and in that case, write a message to the console:</li>
</ol>
<pre class="calibre23">
        if (task.isCompletedNormally()){ <br class="title-page-name"/>          System.out.printf("Main: The process has completed<br class="title-page-name"/>                             normally.\n"); <br class="title-page-name"/>        } 
</pre>
<ol start="24" class="calibre19">
<li value="24" class="calibre18">The expected price of all the products, after the increment, is <kbd class="calibre15">12</kbd>. Write the name and price of all the products that have a price difference of <kbd class="calibre15">12</kbd> to check that all of them have increased their price correctly:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;products.size(); i++){ <br class="title-page-name"/>          Product product=products.get(i); <br class="title-page-name"/>          if (product.getPrice()!=12) { <br class="title-page-name"/>            System.out.printf("Product %s: %f\n",<br class="title-page-name"/>                              product.getName(),product.getPrice()); <br class="title-page-name"/>          } <br class="title-page-name"/>        } 
</pre>
<ol start="25" class="calibre19">
<li value="25" class="calibre18">Write a message to indicate the finalization of the program:</li>
</ol>
<pre class="calibre23">
        System.out.println("Main: End of the program.\n"); 
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this example, you created a <kbd class="calibre15">ForkJoinPool</kbd> object and a subclass of the <kbd class="calibre15">ForkJoinTask</kbd> class that you executed in the pool. To create the <kbd class="calibre15">ForkJoinPool</kbd> object, you used the constructor without arguments, so it will be executed with its default configuration. It creates a pool with a number of threads equal to the number of processors of the computer. When the <kbd class="calibre15">ForkJoinPool</kbd> object is created, those threads are created and they wait in the pool until some tasks arrive for their execution.</p>
<p class="calibre4">Since the <kbd class="calibre15">Task</kbd> class doesn't return a result, it extends the <kbd class="calibre15">RecursiveAction</kbd> class. In the recipe, you used the recommended structure for the implementation of the task. If the task has to update more than <kbd class="calibre15">10</kbd> products, it divides that set of elements into two blocks, creates two tasks, and assigns a block to each task. You used the <kbd class="calibre15">first</kbd> and <kbd class="calibre15">last</kbd> attributes in the <kbd class="calibre15">Task</kbd> class to know the range of positions that this task has to update in the list of products. You used the <kbd class="calibre15">first</kbd> and <kbd class="calibre15">last</kbd> attributes to use only one copy of the product list and not create different lists for each task.</p>
<p class="calibre4">To execute the subtasks that a task creates, it calls the <kbd class="calibre15">invokeAll()</kbd> method. This is a synchronous call, and the task waits for the finalization of the subtasks before continuing (potentially finishing) its execution. While the task is waiting for its subtasks, the worker thread that was executing it takes another task waiting for execution and executes it. With this behavior, the fork/join framework offers more efficient task management than the <kbd class="calibre15">Runnable</kbd> and <kbd class="calibre15">Callable</kbd> objects themselves.</p>
<p class="calibre4">The <kbd class="calibre15">invokeAll()</kbd> method of the <kbd class="calibre15">ForkJoinTask</kbd> class is one of the main differences between the Executor and the fork/join framework. In the Executor framework, all the tasks have to be sent to the executor while in this case, the tasks include methods to execute and control the tasks inside the pool. You used the <kbd class="calibre15">invokeAll()</kbd> method in the <kbd class="calibre15">Task</kbd> class, which extends the <kbd class="calibre15">RecursiveAction</kbd> class, which in turn extends the <kbd class="calibre15">ForkJoinTask</kbd> class.</p>
<p class="calibre4">You sent a unique task to the pool to update all the lists of products using the <kbd class="calibre15">execute()</kbd> method. In this case, it's an asynchronous call, and the main thread continues its execution.</p>
<p class="calibre4">You used some methods of the <kbd class="calibre15">ForkJoinPool</kbd> class to check the status and the evolution of the tasks that are running. The class includes more methods that can be useful for this purpose. See the <em class="calibre14">Monitoring a fork/join pool</em> recipe in <a href="part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 9</span></a>, <em class="calibre14">Testing Concurrent Applications</em> for a complete list of those methods.</p>
<p class="calibre4">Finally, like with the Executor framework, you should finish <kbd class="calibre15">ForkJoinPool</kbd> using the <kbd class="calibre15">shutdown()</kbd> method.</p>
<p class="calibre4">The following screenshot shows part of an execution of this example:</p>
<div class="cdpaligncenter"><img class="image-border7" src="../images/00034.jpeg"/></div>
<p class="calibre4">You can see the tasks finishing their work and the price of the products updated.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">ForkJoinPool</kbd> class provides other methods to execute a task. These methods are as follows:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">execute (Runnable task)</kbd>: This is another version of the <kbd class="calibre15">execute()</kbd> method used in the example. In this case, you send a <kbd class="calibre15">Runnable</kbd> task to the <kbd class="calibre15">ForkJoinPool</kbd> class. Note that the <kbd class="calibre15">ForkJoinPool</kbd> class doesn't use the work-stealing algorithm with <kbd class="calibre15">Runnable</kbd> objects. It's only used with <kbd class="calibre15">ForkJoinTask</kbd> objects.</li>
<li class="calibre18"><kbd class="calibre15">invoke(ForkJoinTask&lt;T&gt; task)</kbd>: While the <kbd class="calibre15">execute()</kbd> method makes an asynchronous call to the <kbd class="calibre15">ForkJoinPool</kbd> class, as you learned in the example, the <kbd class="calibre15">invoke()</kbd> method makes a synchronous call to the <kbd class="calibre15">ForkJoinPool</kbd> class. This call doesn't return until the task passed as a parameter finishes its execution.</li>
<li class="calibre18">You can also use the <kbd class="calibre15">invokeAll()</kbd> and <kbd class="calibre15">invokeAny()</kbd> methods declared in the <kbd class="calibre15">ExecutorService</kbd> interface. These methods receive <kbd class="calibre15">Callable</kbd> objects as parameters. The <kbd class="calibre15">ForkJoinPool</kbd> class doesn't use the work-stealing algorithm with the <kbd class="calibre15">Callable</kbd> objects, so you'd be better off executing them using a <kbd class="calibre15">ThreadPoolExecutor</kbd>.</li>
</ul>
<p class="calibre4">The <kbd class="calibre15">ForkJoinTask</kbd> class also includes other versions of the <kbd class="calibre15">invokeAll()</kbd> method used in the example. These versions are as follows:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">invokeAll(ForkJoinTask&lt;?&gt;... tasks)</kbd>: This version of the method uses a variable list of arguments. You can pass to it as parameters as many <kbd class="calibre15">ForkJoinTask</kbd> objects as you want.</li>
<li class="calibre18"><kbd class="calibre15">invokeAll(Collection&lt;T&gt; tasks)</kbd>: This version of the method accepts a collection (for example, an <kbd class="calibre15">ArrayList</kbd> object, a <kbd class="calibre15">LinkedList</kbd> object, or a <kbd class="calibre15">TreeSet</kbd> object) of objects of a generic type <kbd class="calibre15">T</kbd>. This generic type <kbd class="calibre15">T</kbd> must be the <kbd class="calibre15">ForkJoinTask</kbd> class or a subclass of it.</li>
</ul>
<p class="calibre4">Although the <kbd class="calibre15">ForkJoinPool</kbd> class is designed to execute an object of <kbd class="calibre15">ForkJoinTask</kbd>, you can also execute the <kbd class="calibre15">Runnable</kbd> and <kbd class="calibre15">Callable</kbd> objects directly. You may also use the <kbd class="calibre15">adapt()</kbd> method of the <kbd class="calibre15">ForkJoinTask</kbd> class that accepts a <kbd class="calibre15">Callable</kbd> object or a <kbd class="calibre15">Runnable</kbd> object and returns a <kbd class="calibre15">ForkJoinTask</kbd> object to execute that task.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Monitoring a fork/join pool</em> recipe in <a href="part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 9</span></a>, <em class="calibre14">Testing Concurrent Applications</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Joining the results of the tasks</h1>
            

            <article>
                
<p class="calibre4">The fork/join framework provides the ability to execute tasks that return a result. This kind of tasks is implemented by the <kbd class="calibre15">RecursiveTask</kbd> class. This class extends the <kbd class="calibre15">ForkJoinTask</kbd> class and implements the <kbd class="calibre15">Future</kbd> interface provided by the Executor framework.</p>
<p class="calibre4">Inside the task, you have to use the structure recommended by the Java API documentation:</p>
<pre class="calibre23">
    if (problem size &gt; size){ <br class="title-page-name"/>      tasks=Divide(task); <br class="title-page-name"/>      execute(tasks); <br class="title-page-name"/>      joinResults() <br class="title-page-name"/>      return result; <br class="title-page-name"/>    } else { <br class="title-page-name"/>      resolve problem; <br class="title-page-name"/>      return result; <br class="title-page-name"/>    } 
</pre>
<p class="calibre4">If the task has to resolve a problem bigger than a predefined size, you divide the problem into more subtasks and execute those subtasks using the fork/join framework. When they finish their execution, the initiating task obtains the results generated by all the subtasks, groups them, and returns the final result. Ultimately, when the initiating task executed in the pool finishes its execution, you obtain its result, whichÂ is effectively the final result of the entire problem.</p>
<p class="calibre4">In this recipe, you will learn how to use this kind of problem solving with fork/join framework by developing an application that looks for a word in a document. You will implement the following two kinds of tasks:</p>
<ul class="calibre17">
<li class="calibre18">A document task, which is going to search for a word in a set of lines of a document</li>
<li class="calibre18">A line task, which is going to search a word in a part of the document</li>
</ul>
<p class="calibre4">All the tasks will return the number of appearances of the word in the part of the document or line they process. In this recipe we will use the default fork/join pool provided by the Java Concurrency API.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">DocumentMock</kbd>. It will generate a string matrix that will simulate a document:</li>
</ol>
<pre class="calibre23">
        public class DocumentMock { 
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Create an array of strings with some words. This array will be used in the generation of the strings matrix:</li>
</ol>
<pre class="calibre23">
        private String words[]={"the","hello","goodbye","packt",<br class="title-page-name"/>                                "java","thread","pool","random",<br class="title-page-name"/>                                "class","main"}; 
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Implement the <kbd class="calibre15">generateDocument()</kbd> method. It receives as parameters the number of lines, the number of words per line, and the word the example is going to look for. It returns a matrix of strings:</li>
</ol>
<pre class="calibre23">
        public String[][] generateDocument(int numLines, int numWords,<br class="title-page-name"/>                                           String word){ 
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">First, create the necessary objects to generate the document-the <kbd class="calibre15">String</kbd> matrix and a <kbd class="calibre15">Random</kbd> object to generate random numbers:</li>
</ol>
<pre class="calibre23">
        int counter=0; <br class="title-page-name"/>        String document[][]=new String[numLines][numWords]; <br class="title-page-name"/>        Random random=new Random(); 
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Fill the array with strings. Store in each position the string that is at a random position in the array of words and count the number of appearances of the word the program will look for in the generated array. You can use this value to check whether the program does its job properly:</li>
</ol>
<pre class="calibre23">
        for (int i=0; i&lt;numLines; i++){ <br class="title-page-name"/>          for (int j=0; j&lt;numWords; j++) { <br class="title-page-name"/>            int index=random.nextInt(words.length); <br class="title-page-name"/>            document[i][j]=words[index]; <br class="title-page-name"/>            if (document[i][j].equals(word)){ <br class="title-page-name"/>              counter++; <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        } 
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Write a message with the number of appearances of the word and return the matrix generated:</li>
</ol>
<pre class="calibre23">
        System.out.println("DocumentMock: The word appears "+ counter+"<br class="title-page-name"/>                            times in the document"); <br class="title-page-name"/>        return document; 
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Create a class named <kbd class="calibre15">DocumentTask</kbd> and specify that it extends the <kbd class="calibre15">RecursiveTask</kbd> class parameterized with the <kbd class="calibre15">Integer</kbd> class. This class will implement the task that will calculate the number of appearances of the word in a set of lines:</li>
</ol>
<pre class="calibre23">
        public class DocumentTask extends RecursiveTask&lt;Integer&gt; { 
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> matrix named document and two private <kbd class="calibre15">int</kbd> attributes named <kbd class="calibre15">start</kbd> and <kbd class="calibre15">end</kbd>. Also, declare a private <kbd class="calibre15">String</kbd> attribute named <kbd class="calibre15">word</kbd>:</li>
</ol>
<pre class="calibre23">
        private String document[][]; <br class="title-page-name"/>        private int start, end; <br class="title-page-name"/>        private String word; 
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Implement the constructor of the class to initialize all its attributes:</li>
</ol>
<pre class="calibre23">
        public DocumentTask (String document[][], int start, int end,<br class="title-page-name"/>                             String word){ <br class="title-page-name"/>          this.document=document; <br class="title-page-name"/>          this.start=start; <br class="title-page-name"/>          this.end=end; <br class="title-page-name"/>          this.word=word; <br class="title-page-name"/>        } 
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the <kbd class="calibre15">compute()</kbd> method. If the difference between the <kbd class="calibre15">end</kbd> and <kbd class="calibre15">start</kbd> attributes is smaller than <kbd class="calibre15">10</kbd>, the task calculates the number of appearances of a word in the lines between those positions by calling the <kbd class="calibre15">processLines()</kbd> method:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        protected Integer compute() { <br class="title-page-name"/>          Integer result=null; <br class="title-page-name"/>          if (end-start&lt;10){ <br class="title-page-name"/>            result=processLines(document, start, end, word); 
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Otherwise, divide the group of lines into two objects, create two new <kbd class="calibre15">DocumentTask</kbd> objects to process those two groups, and execute them in the pool using the <kbd class="calibre15">invokeAll()</kbd> method:</li>
</ol>
<pre class="calibre23">
        } else { <br class="title-page-name"/>          int mid=(start+end)/2; <br class="title-page-name"/>          DocumentTask task1=new DocumentTask(document,start,mid,word); <br class="title-page-name"/>          DocumentTask task2=new DocumentTask(document,mid,end,word); <br class="title-page-name"/>          invokeAll(task1,task2); 
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Then, add the values returned by both the tasks using the <kbd class="calibre15">groupResults()</kbd> method. Finally, return the result calculated by the task:</li>
</ol>
<pre class="calibre23">
          try { <br class="title-page-name"/>            result=groupResults(task1.get(),task2.get()); <br class="title-page-name"/>          } catch (InterruptedException | ExecutionException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        } <br class="title-page-name"/>        return result; 
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Implement the <kbd class="calibre15">processLines()</kbd> method. It receives the string matrix, the <kbd class="calibre15">start</kbd> attribute, the <kbd class="calibre15">end</kbd> attribute, and the <kbd class="calibre15">word</kbd> attribute the task is searching for as parameters:</li>
</ol>
<pre class="calibre23">
        private Integer processLines(String[][] document, int start,<br class="title-page-name"/>                                     int end,String word) { 
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">For every line the task has to process, create a <kbd class="calibre15">LineTask</kbd> object to process the complete line and store them in a list of tasks:</li>
</ol>
<pre class="calibre23">
        List&lt;LineTask&gt; tasks=new ArrayList&lt;LineTask&gt;(); <br class="title-page-name"/>        for (int i=start; i&lt;end; i++){ <br class="title-page-name"/>          LineTask task=new LineTask(document[i], 0,<br class="title-page-name"/>                                     document[i].length, word); <br class="title-page-name"/>          tasks.add(task); <br class="title-page-name"/>        } 
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Execute all the tasks in that list using the <kbd class="calibre15">invokeAll()</kbd> method:</li>
</ol>
<pre class="calibre23">
        invokeAll(tasks); 
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Sum the value returned by all these tasks and return the result:</li>
</ol>
<pre class="calibre23">
        int result=0; <br class="title-page-name"/>        for (int i=0; i&lt;tasks.size(); i++) { <br class="title-page-name"/>          LineTask task=tasks.get(i); <br class="title-page-name"/>          try { <br class="title-page-name"/>            result=result+task.get(); <br class="title-page-name"/>          } catch (InterruptedException | ExecutionException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        } <br class="title-page-name"/>        return result; 
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Implement the <kbd class="calibre15">groupResults()</kbd> method. It adds two numbers and returns the result:</li>
</ol>
<pre class="calibre23">
        private Integer groupResults(Integer number1,Integer number2) { <br class="title-page-name"/>          Integer result; <br class="title-page-name"/>          result=number1+number2; <br class="title-page-name"/>          return result; <br class="title-page-name"/>        } 
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Create a class named <kbd class="calibre15">LineTask</kbd> and specify that it extends the <kbd class="calibre15">RecursiveTask</kbd> class parameterized with the <kbd class="calibre15">Integer</kbd> class. This class will implement the task that will calculate the number of appearances of the word in a line:</li>
</ol>
<pre class="calibre23">
        public class LineTask extends RecursiveTask&lt;Integer&gt;{ 
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> array attribute named <kbd class="calibre15">line</kbd> and two private <kbd class="calibre15">int</kbd> attributes named <kbd class="calibre15">start</kbd> and <kbd class="calibre15">end</kbd>. Finally, declare a private <kbd class="calibre15">String</kbd> attribute named <kbd class="calibre15">word</kbd>:</li>
</ol>
<pre class="calibre23">
        private String line[]; <br class="title-page-name"/>        private int start, end; <br class="title-page-name"/>        private String word; 
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Implement the constructor of the class to initialize all its attributes:</li>
</ol>
<pre class="calibre23">
        public LineTask(String line[],int start,int end,String word) { <br class="title-page-name"/>          this.line=line; <br class="title-page-name"/>          this.start=start; <br class="title-page-name"/>          this.end=end; <br class="title-page-name"/>          this.word=word; <br class="title-page-name"/>        } 
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Implement the <kbd class="calibre15">compute()</kbd> method of the class. If the difference between the <kbd class="calibre15">end</kbd> and <kbd class="calibre15">start</kbd> attributes is smaller than <kbd class="calibre15">100</kbd>, the task searches for the word in the fragment of the line determined by the <kbd class="calibre15">start</kbd> and <kbd class="calibre15">end</kbd> attributes using the <kbd class="calibre15">count()</kbd> method:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        protected Integer compute() { <br class="title-page-name"/>          Integer result=null; <br class="title-page-name"/>          if (end-start&lt;100) { <br class="title-page-name"/>            result=count(line, start, end, word); 
</pre>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">Otherwise, divide the group of words in the line in two, create two new <kbd class="calibre15">LineTask</kbd> objects to process those two groups, and execute them in the pool using the <kbd class="calibre15">invokeAll()</kbd> method:</li>
</ol>
<pre class="calibre23">
        } else { <br class="title-page-name"/>          int mid=(start+end)/2; <br class="title-page-name"/>          LineTask task1=new LineTask(line, start, mid, word); <br class="title-page-name"/>          LineTask task2=new LineTask(line, mid, end, word); <br class="title-page-name"/>          invokeAll(task1, task2); 
</pre>
<ol start="23" class="calibre19">
<li value="23" class="calibre18">Then, add the values returned by both the tasks using the <kbd class="calibre15">groupResults()</kbd> method. Finally, return the result calculated by the task:</li>
</ol>
<pre class="calibre23">
          try { <br class="title-page-name"/>            result=groupResults(task1.get(),task2.get()); <br class="title-page-name"/>          } catch (InterruptedException | ExecutionException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        } <br class="title-page-name"/>        return result; 
</pre>
<ol start="24" class="calibre19">
<li value="24" class="calibre18">Implement the <kbd class="calibre15">count()</kbd> method. It receives the string array with the complete line, the <kbd class="calibre15">start</kbd> attribute, the <kbd class="calibre15">end</kbd> attribute, and the <kbd class="calibre15">word</kbd> attribute the task is searching for as parameters:</li>
</ol>
<pre class="calibre23">
        private Integer count(String[] line, int start, int end,<br class="title-page-name"/>                              String word) { 
</pre>
<ol start="25" class="calibre19">
<li value="25" class="calibre18">Compare the words stored in the positions between the <kbd class="calibre15">start</kbd> and <kbd class="calibre15">end</kbd> attributes with the <kbd class="calibre15">word</kbd> attribute the task is searching for, and if they are equal, increment the <kbd class="calibre15">counter</kbd> variable:</li>
</ol>
<pre class="calibre23">
        int counter; <br class="title-page-name"/>        counter=0; <br class="title-page-name"/>        for (int i=start; i&lt;end; i++){ <br class="title-page-name"/>          if (line[i].equals(word)){ <br class="title-page-name"/>            counter++; <br class="title-page-name"/>          } <br class="title-page-name"/>        } 
</pre>
<ol start="26" class="calibre19">
<li value="26" class="calibre18">To slow the execution of the example, put the task to sleep for <kbd class="calibre15">10</kbd> milliseconds:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          Thread.sleep(10); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } 
</pre>
<ol start="27" class="calibre19">
<li value="27" class="calibre18">Return the value of the <kbd class="calibre15">counter</kbd> variable:</li>
</ol>
<pre class="calibre23">
        return counter; 
</pre>
<ol start="28" class="calibre19">
<li value="28" class="calibre18">Implement the <kbd class="calibre15">groupResults()</kbd> method. It sums two numbers and returns the <kbd class="calibre15">result</kbd>:</li>
</ol>
<pre class="calibre23">
        private Integer groupResults(Integer number1,Integer number2) { <br class="title-page-name"/>          Integer result; <br class="title-page-name"/>          result=number1+number2; <br class="title-page-name"/>          return result; <br class="title-page-name"/>        } 
</pre>
<ol start="29" class="calibre19">
<li value="29" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main{ <br class="title-page-name"/>          public static void main(String[] args) { 
</pre>
<ol start="30" class="calibre19">
<li value="30" class="calibre18">Create <kbd class="calibre15">Document</kbd> with <kbd class="calibre15">100</kbd> lines and <kbd class="calibre15">1000</kbd> words per line using the <kbd class="calibre15">DocumentMock</kbd> class:</li>
</ol>
<pre class="calibre23">
        DocumentMock mock=new DocumentMock(); <br class="title-page-name"/>        String[][] document=mock.generateDocument(100, 1000, "the"); 
</pre>
<ol start="31" class="calibre19">
<li value="31" class="calibre18">Create a new <kbd class="calibre15">DocumentTask</kbd> object to update the products of the entire document. The <kbd class="calibre15">start</kbd> parameter takes the value <kbd class="calibre15">0</kbd> and the <kbd class="calibre15">end</kbd> parameter takes the value <kbd class="calibre15">100</kbd>:</li>
</ol>
<pre class="calibre23">
        DocumentTask task=new DocumentTask(document, 0, 100, "the"); 
</pre>
<ol start="32" class="calibre19">
<li value="32" class="calibre18">Get the default <kbd class="calibre15">ForkJoinPool</kbd> executor using the <kbd class="calibre15">commmonPool()</kbd> method and execute the task on it using the <kbd class="calibre15">execute()</kbd> method:</li>
</ol>
<pre class="calibre23">
        ForkJoinPool commonPool=ForkJoinPool.commonPool(); <br class="title-page-name"/>        commonPool.execute(task); 
</pre>
<ol start="33" class="calibre19">
<li value="33" class="calibre18">Implement a block of code that shows information about the progress of the pool, writing every second to the console the value of some parameters of the pool until the task finishes its execution:</li>
</ol>
<pre class="calibre23">
        do { <br class="title-page-name"/>          System.out.printf("*************************<br class="title-page-name"/>                             *****************\n"); <br class="title-page-name"/>          System.out.printf("Main: Active Threads: %d\n",<br class="title-page-name"/>                            commonPool.getActiveThreadCount()); <br class="title-page-name"/>          System.out.printf("Main: Task Count: %d\n",<br class="title-page-name"/>                            commonPool.getQueuedTaskCount()); <br class="title-page-name"/>          System.out.printf("Main: Steal Count: %d\n",<br class="title-page-name"/>                            commonPool.getStealCount()); <br class="title-page-name"/>          System.out.printf("***********************************<br class="title-page-name"/>                             *******\n"); <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        } while (!task.isDone()); 
</pre>
<ol start="34" class="calibre19">
<li value="34" class="calibre18">Shut down the pool using the <kbd class="calibre15">shutdown()</kbd> method:</li>
</ol>
<pre class="calibre23">
        pool.shutdown(); 
</pre>
<ol start="35" class="calibre19">
<li value="35" class="calibre18">Wait for the finalization of the tasks using the <kbd class="calibre15">awaitTermination()</kbd> method:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          pool.awaitTermination(1, TimeUnit.DAYS); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } 
</pre>
<ol start="36" class="calibre19">
<li value="36" class="calibre18">Write the number of the appearances of the word in the document. Check that this number is the same as the number written by the <kbd class="calibre15">DocumentMock</kbd> class:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          System.out.printf("Main: The word appears %d in the<br class="title-page-name"/>                             document",task.get()); <br class="title-page-name"/>        } catch (InterruptedException | ExecutionException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } 
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">In this example, you implemented two different tasks:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">DocumentTask</kbd>: A task of this class has to process a set of lines of the document determined by the <kbd class="calibre15">start</kbd> and <kbd class="calibre15">end</kbd> attributes. If this set of lines has a size smaller than <kbd class="calibre15">10</kbd>, it creates <kbd class="calibre15">LineTask</kbd> per line, and when they finish their execution, it sums the results of those tasks and returns the <kbd class="calibre15">result</kbd> of the sum. If the set of lines the task has to process has a size of <kbd class="calibre15">10</kbd> or bigger, it divides the set in two and creates two <kbd class="calibre15">DocumentTask</kbd> objects to process those new sets. When those tasks finish their execution, the tasks sum their results and return that sum as a <kbd class="calibre15">result</kbd>.</li>
<li class="calibre18"><kbd class="calibre15">LineTask</kbd>: A task of this class has to process a set of words of a line of the document. If this set of words is smaller than <kbd class="calibre15">100</kbd>, the task searches the word directly in that set of words and returns the number of appearances of the word. Otherwise, it divides the set of words into two and creates two <kbd class="calibre15">LineTask</kbd> objects to process those sets. When those tasks finish their execution, the task sums the results of both the tasks and returns that sum as a <kbd class="calibre15">result</kbd>.</li>
</ul>
<p class="calibre4">In the <kbd class="calibre15">Main</kbd> class, you used the default <kbd class="calibre15">ForkJoinPool</kbd> (obtained from the static method, <kbd class="calibre15">commonPool()</kbd>) and executed in it a <kbd class="calibre15">DocumentTask</kbd> class that has to process a document of <kbd class="calibre15">100</kbd> lines and <kbd class="calibre15">1000</kbd> words per line. This task will divide the problem using other <kbd class="calibre15">DocumentTask</kbd> objects and <kbd class="calibre15">LineTask</kbd> objects, and when all the tasks finish their execution, you can use the original task to get the total number of appearances of the word in the whole document. Since the tasks return a result, they extend the <kbd class="calibre15">RecursiveTask</kbd> class.</p>
<p class="calibre4">To obtain the result returned by <kbd class="calibre15">Task</kbd>, you used the <kbd class="calibre15">get()</kbd> method. This method is declared in the <kbd class="calibre15">Future</kbd> interface implemented by the <kbd class="calibre15">RecursiveTask</kbd> class.</p>
<p class="calibre4">When you execute the program, you can compare the first and the last lines written in the console. The first line is the number of appearances of the word calculated when the document is generated and the last is the same number calculated by the fork/join tasks.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">ForkJoinTask</kbd> class provides another method to finish the execution of a task and return a result, that is, the <kbd class="calibre15">complete()</kbd> method. This method accepts an object of the type used in the parameterization of the <kbd class="calibre15">RecursiveTask</kbd> class and returns that object as a result of the task when the <kbd class="calibre15">join()</kbd> method is called. It's use is recommended to provide results for asynchronous tasks.</p>
<p class="calibre4">Since the <kbd class="calibre15">RecursiveTask</kbd> class implements the <kbd class="calibre15">Future</kbd> interface, there's another version of the <kbd class="calibre15">get()</kbd> method:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">get(long timeout, TimeUnit unit)</kbd>: This version of the <kbd class="calibre15">get()</kbd> method, if the result of the task isn't available, waits the specified time for it. If the specified period of time passes and the result isn't yet available, the method returns a <kbd class="calibre15">null</kbd> value. The <kbd class="calibre15">TimeUnit</kbd> class is an enumeration with these constants: <kbd class="calibre15">DAYS</kbd>, <kbd class="calibre15">HOURS</kbd>, <kbd class="calibre15">MICROSECONDS</kbd>, <kbd class="calibre15">MILLISECONDS</kbd>, <kbd class="calibre15">MINUTES</kbd>, <kbd class="calibre15">NANOSECONDS</kbd>, and <kbd class="calibre15">SECONDS</kbd>.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating a fork/join pool</em> recipe in this chapter</li>
<li class="calibre18">The <em class="calibre14">Monitoring a fork/join pool</em> recipe in <a href="part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 9</span></a>, <em class="calibre14">Testing Concurrent Applications</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Running tasks asynchronously</h1>
            

            <article>
                
<p class="calibre4">When you execute <kbd class="calibre15">ForkJoinTask</kbd> in <kbd class="calibre15">ForkJoinPool</kbd>, you can do it in a synchronous or an asynchronous way. When you do it in a synchronous way, the method that sends the task to the pool doesn't return until the task sent finishes its execution. When you do it in an asynchronous way, the method that sends the task to the executor returns immediately, so the task can continue with its execution.</p>
<p class="calibre4">You should be aware of a big difference between the two methods. When you use the synchronous methods, the task that calls one of these methods (for example, the <kbd class="calibre15">invokeAll()</kbd> method) is suspended until the tasks it sent to the pool finish their execution. This allows the <kbd class="calibre15">ForkJoinPool</kbd> class to use the work-stealing algorithm to assign a new task to the worker thread that executed the sleeping task. On the contrary, when you use the asynchronous methods (for example, the <kbd class="calibre15">fork()</kbd> method), the task continues with its execution, so the <kbd class="calibre15">ForkJoinPool</kbd> class can't use the work-stealing algorithm to increase the performance of the application. In this case, only when you call the <kbd class="calibre15">join()</kbd> or <kbd class="calibre15">get()</kbd> methods to wait for the finalization of a task, the <kbd class="calibre15">ForkJoinPool</kbd> class can use that algorithm.</p>
<p class="calibre4">In addition to the <kbd class="calibre15">RecursiveAction</kbd> and <kbd class="calibre15">RecursiveTask</kbd> classes, Java 8 introduced a new <kbd class="calibre15">ForkJoinTask</kbd> class with the <kbd class="calibre15">CountedCompleter</kbd> class. With this kind of tasks, you can include a completion action that will be executed when it is launched and there is no pending child task. This mechanism is based on a method included in the class (the <kbd class="calibre15">onCompletion()</kbd> method) and a counter of pending tasks.</p>
<p class="calibre4">This counter is initialized to zero by default and you can increment it when you need in an atomic way. Normally, you will increment this counter one by one as and when you launch a child task. Finally, when a task has finished its execution, you can try to complete the execution of the task and consequently execute the <kbd class="calibre15">onCompletion()</kbd> method. If the pending count is greater than zero, it is decremented by one. If it's zero, the <kbd class="calibre15">onCompletion()</kbd> method is executed and then the parent task is tried to be completed.</p>
<p class="calibre4">In this recipe, you will learn how to use the asynchronous methods provided by the <kbd class="calibre15">ForkJoinPool</kbd> and <kbd class="calibre15">CountedCompleter</kbd> classes for the management of tasks. You are going to implement a program that will search for files with a determined extension inside a folder and its subfolders. The <kbd class="calibre15">CountedCompleter</kbd> class you're going to implement will process the contents of a folder. For each subfolder inside that folder, it will send a new task to the <kbd class="calibre15">ForkJoinPool</kbd> class in an asynchronous way. For each file inside that folder, the task will check the extension of the file and add it to the result list if it proceeds. When a task is completed, it will insert the result lists of all its child tasks in its result task.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">FolderProcessor</kbd> and specify that it extends the <kbd class="calibre15">CountedCompleter</kbd> class parameterized with the <kbd class="calibre15">List&lt;String&gt;</kbd> type:</li>
</ol>
<pre class="calibre23">
        public class FolderProcessor extends<br class="title-page-name"/>                                CountedCompleter&lt;List&lt;String&gt;&gt; { 
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> attribute named <kbd class="calibre15">path</kbd>. This attribute will store the full path of the folder the task is going to process:</li>
</ol>
<pre class="calibre23">
        private String path; 
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Declare a private <kbd class="calibre15">String</kbd> attribute named <kbd class="calibre15">extension</kbd>. This attribute will store the name of the extension of the files the task is going to look for:</li>
</ol>
<pre class="calibre23">
        private String extension; 
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Declare two <kbd class="calibre15">List</kbd> private attributes named <kbd class="calibre15">tasks</kbd> and <kbd class="calibre15">resultList</kbd>. We will use the first one to store all the child tasks launched from this task and the other one to store the list of results of this task:</li>
</ol>
<pre class="calibre23">
        private List&lt;FolderProcessor&gt; tasks; <br class="title-page-name"/>        private List&lt;String&gt; resultList;      
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement one constructor for the class to initialize its attributes and its parent class. We declare this constructor as <kbd class="calibre15">protected</kbd> as it will only be used internally:</li>
</ol>
<pre class="calibre23">
        protected FolderProcessor (CountedCompleter&lt;?&gt; completer,<br class="title-page-name"/>                                   String path, String extension) { <br class="title-page-name"/>          super(completer); <br class="title-page-name"/>          this.path=path; <br class="title-page-name"/>          this.extension=extension; <br class="title-page-name"/>        } 
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">We implement the other public constructor to be used externally. As the task created by this constructor won't have a parent task, we don't include this object as a parameter:</li>
</ol>
<pre class="calibre23">
        public FolderProcessor (String path, String extension) { <br class="title-page-name"/>          this.path=path; <br class="title-page-name"/>          this.extension=extension; <br class="title-page-name"/>        } 
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the <kbd class="calibre15">compute()</kbd> method. As the base class of our task is the <kbd class="calibre15">CountedCompleter</kbd> class, the return type of this method is <kbd class="calibre15">void</kbd>:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void compute() { 
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">First, initialize the two list attributes:</li>
</ol>
<pre class="calibre23">
        resultList=new ArrayList&lt;&gt;(); <br class="title-page-name"/>        tasks=new ArrayList&lt;&gt;(); 
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Get the contents of the folder:</li>
</ol>
<pre class="calibre23">
        File file=new File(path); <br class="title-page-name"/>        File content[] = file.listFiles(); 
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">For each element in the folder, if there is a subfolder, create a new <kbd class="calibre15">FolderProcessor</kbd> object and execute it asynchronously using the <kbd class="calibre15">fork()</kbd> method. We use the first constructor of the class and pass the current task as the completer task of the new one. We also increment the counter of pending tasks using the <kbd class="calibre15">addToPendingCount()</kbd> method:</li>
</ol>
<pre class="calibre23">
        if (content != null) { <br class="title-page-name"/>          for (int i = 0; i &lt; content.length; i++) { <br class="title-page-name"/>            if (content[i].isDirectory()) { <br class="title-page-name"/>              FolderProcessor task=new FolderProcessor(this,<br class="title-page-name"/>                              content[i].getAbsolutePath(), extension); <br class="title-page-name"/>              task.fork(); <br class="title-page-name"/>              addToPendingCount(1); <br class="title-page-name"/>              tasks.add(task); 
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Otherwise, compare the extension of the file with the extension you are looking for, using the <kbd class="calibre15">checkFile()</kbd> method, and if they are equal, store the full path of the file in the list of strings declared earlier:</li>
</ol>
<pre class="calibre23">
          } else { <br class="title-page-name"/>            if (checkFile(content[i].getName())){ <br class="title-page-name"/>              resultList.add(content[i].getAbsolutePath()); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        } 
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">If the list of the <kbd class="calibre15">FolderProcessor</kbd> subtasks has more than <kbd class="calibre15">50</kbd> elements, write a message to the console to indicate this circumstance:</li>
</ol>
<pre class="calibre23">
          if (tasks.size()&gt;50) { <br class="title-page-name"/>            System.out.printf("%s: %d tasks ran.\n",<br class="title-page-name"/>                              file.getAbsolutePath(),tasks.size()); <br class="title-page-name"/>          } <br class="title-page-name"/>        } 
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Finally, try to complete the current task using the <kbd class="calibre15">tryComplete()</kbd> method:</li>
</ol>
<pre class="calibre23">
          tryComplete(); <br class="title-page-name"/>        } 
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Implement the <kbd class="calibre15">onCompletion()</kbd> method. This method will be executed when all the child tasks (all the tasks that have been forked from the current task) have finished their execution. We add the result list of all the child tasks to the result list of the current task:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        public void onCompletion(CountedCompleter&lt;?&gt; completer) { <br class="title-page-name"/>          for (FolderProcessor childTask : tasks) { <br class="title-page-name"/>            resultList.addAll(childTask.getResultList()); <br class="title-page-name"/>          } <br class="title-page-name"/>        } 
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Implement the <kbd class="calibre15">checkFile()</kbd> method. This method compares if the name of a file passed as a parameter ends with the <kbd class="calibre15">extension</kbd> you are looking for. If so, the method returns the <kbd class="calibre15">true</kbd> value, otherwise it returns the <kbd class="calibre15">false</kbd> value:</li>
</ol>
<pre class="calibre23">
        private boolean checkFile(String name) { <br class="title-page-name"/>          return name.endsWith(extension); <br class="title-page-name"/>        } 
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Finally, implement the <kbd class="calibre15">getResultList()</kbd> method to return the result list of a task. The code of this method is very simple so it won't be included.</li>
<li value="17" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) { 
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Create <kbd class="calibre15">ForkJoinPool</kbd> using the default constructor:</li>
</ol>
<pre class="calibre23">
        ForkJoinPool pool=new ForkJoinPool(); 
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">Create three <kbd class="calibre15">FolderProcessor</kbd> tasks. Initialize each with a different folder path:</li>
</ol>
<pre class="calibre23">
        FolderProcessor system=new FolderProcessor("C:\\Windows",<br class="title-page-name"/>                                                   "log"); <br class="title-page-name"/>        FolderProcessor apps=new FolderProcessor("C:\\Program Files",<br class="title-page-name"/>                                                 "log"); <br class="title-page-name"/>        FolderProcessor documents=new FolderProcessor("C:\\Documents<br class="title-page-name"/>                                                 And Settings","log"); 
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Execute the three tasks in the pool using the <kbd class="calibre15">execute()</kbd> method:</li>
</ol>
<pre class="calibre23">
        pool.execute(system); <br class="title-page-name"/>        pool.execute(apps); <br class="title-page-name"/>        pool.execute(documents); 
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Write to the console information about the status of the pool every second until the three tasks have finished their execution:</li>
</ol>
<pre class="calibre23">
        do { <br class="title-page-name"/>          System.out.printf("**********************************<br class="title-page-name"/>                             ********\n"); <br class="title-page-name"/>          System.out.printf("Main: Active Threads: %d\n",<br class="title-page-name"/>                            pool.getActiveThreadCount()); <br class="title-page-name"/>          System.out.printf("Main: Task Count: %d\n",<br class="title-page-name"/>                            pool.getQueuedTaskCount()); <br class="title-page-name"/>          System.out.printf("Main: Steal Count: %d\n",<br class="title-page-name"/>                            pool.getStealCount()); <br class="title-page-name"/>          System.out.printf("**********************************<br class="title-page-name"/>                             ********\n"); <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        } while ((!system.isDone())||(!apps.isDone())||<br class="title-page-name"/>                 (!documents.isDone())); 
</pre>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">Shut down <kbd class="calibre15">ForkJoinPool</kbd> using the <kbd class="calibre15">shutdown()</kbd> method:</li>
</ol>
<pre class="calibre23">
        pool.shutdown(); 
</pre>
<ol start="23" class="calibre19">
<li value="23" class="calibre18">Write the number of results generated by each task to the console:</li>
</ol>
<pre class="calibre23">
        List&lt;String&gt; results; <br class="title-page-name"/> <br class="title-page-name"/>        results=system.join(); <br class="title-page-name"/>        System.out.printf("System: %d files found.\n",results.size()); <br class="title-page-name"/> <br class="title-page-name"/>        results=apps.join(); <br class="title-page-name"/>        System.out.printf("Apps: %d files found.\n",results.size()); <br class="title-page-name"/> <br class="title-page-name"/>        results=documents.join(); <br class="title-page-name"/>        System.out.printf("Documents: %d files found.\n",<br class="title-page-name"/>                           results.size()); 
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The following screenshot shows part of an execution of the preceding example:</p>
<div class="cdpaligncenter"><img class="image-border8" src="../images/00035.jpeg"/></div>
<p class="calibre4">The key to this example is in the <kbd class="calibre15">FolderProcessor</kbd> class. Each task processes the contents of a folder. As you know, this content has the following two kinds of elements:</p>
<ul class="calibre17">
<li class="calibre18">Files</li>
<li class="calibre18">Other folders</li>
</ul>
<p class="calibre4">If the task finds a folder, it creates another <kbd class="calibre15">FolderProcessor</kbd> object to process that folder and sends it to the pool using the <kbd class="calibre15">fork()</kbd> method. This method sends the task to the pool that will execute it if it has a free worker thread, or it can create a new one. The method returns immediately, so the task can continue processing the contents of the folder. For every file, a task compares its extension with the one it's looking for and, if they are equal, adds the name of the file to the list of <kbd class="calibre15">results</kbd>.</p>
<p class="calibre4">Once the task has processed all the contents of the assigned folder, we try to complete the current task. As we explained in the introduction of this recipe, when we try to complete a task, the code of the <kbd class="calibre15">CountedCompleter</kbd> looks for the value of the pending task counter. If this value is greater than <kbd class="calibre15">0</kbd>, it decreases the value of that counter. On the contrary, if the value is <kbd class="calibre15">0</kbd>, the task executes the <kbd class="calibre15">onCompletion()</kbd> method and then tries to complete its parent task. In our case, when a task is processing a folder and it finds a subfolder, it creates a new child task, launches that task using the <kbd class="calibre15">fork()</kbd> method, and increments the counter of the pending tasks. So, when a task has processed its entire content, the counter of pending tasks of the task will be equal to the number of child tasks we have launched. When we call the <kbd class="calibre15">tryComplete()</kbd> method, if the folder of the current task has subfolders, this call will decrease the number of pending tasks. Only when all its child tasks have been completed, its <kbd class="calibre15">onCompletion()</kbd> method is executed. If the folder of the current task hasn't got any subfolders, the counter of pending tasks will be zero; the <kbd class="calibre15">onComplete()</kbd> method will be called immediately, and then it will try to complete its parent task. In this way, we create a tree of tasks from top to bottom that are completed from bottom to top. In the <kbd class="calibre15">onComplete()</kbd> method, we process all the result lists of the child tasks and add their elements in the result list of the current task.</p>
<p class="calibre4">The <kbd class="calibre15">ForkJoinPool</kbd> class also allows the execution of tasks in an asynchronous way. You used the <kbd class="calibre15">execute()</kbd> method to send the three initial tasks to the pool. In the <kbd class="calibre15">Main</kbd> class, you also finished the pool using the <kbd class="calibre15">shutdown()</kbd> method and wrote information about the status and the evolution of the tasks that are running in it. The <kbd class="calibre15">ForkJoinPool</kbd> class includes more methods that can be useful for this purpose. See the <em class="calibre14">Monitoring a fork/join pool</em> recipe in <a href="part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 9</span></a>, <em class="calibre14">Testing Concurrent Applications</em> to see a complete list of those methods.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">In this example we used the <kbd class="calibre15">addToPendingCount()</kbd> method to increment the counter of pending tasks, but we have other methods we can use to change the value of this counter:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">setPendingCount()</kbd>: This method establishes the value of the counter of pending tasks.</li>
<li class="calibre18"><kbd class="calibre15">compareAndSetPendingCount()</kbd>: This method receives two parameters. The first one is the expected value and the second one is the new value. If the value of the counter of pending tasks is equal to the expected value, establish its value to the new one.</li>
<li class="calibre18"><kbd class="calibre15">decrementPendingCountUnlessZero()</kbd>: This method decrements the value of the counter of pending tasks unless it's equal to zero.</li>
</ul>
<p class="calibre4">The <kbd class="calibre15">CountedCompleter</kbd> class also includes other methods to manage the completion of the tasks. The following are the most significant ones:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">complete()</kbd>: This method executes the <kbd class="calibre15">onCompletion()</kbd> method independently of the value of the counter of pending tasks and tries to complete its completer (parent) task.</li>
<li class="calibre18"><kbd class="calibre15">onExceptionalCompletion()</kbd>: This method is executed when the <kbd class="calibre15">completeExceptionally()</kbd> method has been called or the <kbd class="calibre15">compute()</kbd> method has thrown an <kbd class="calibre15">Exception</kbd>. Override this method to include your code to process such exceptions.</li>
</ul>
<p class="calibre4">In this example, you used the <kbd class="calibre15">join()</kbd> method to wait for the finalization of tasks and get their results. You can also use one of the following two versions of the <kbd class="calibre15">get()</kbd> method with this purpose:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">get(long timeout, TimeUnit unit)</kbd>: This version of the <kbd class="calibre15">get()</kbd> method, if the result of the task isn't available, waits the specified time for it. If the specified period of time passes and the result isn't yet available, the method returns a <kbd class="calibre15">null</kbd> value. The <kbd class="calibre15">TimeUnit</kbd> class is an enumeration with the following constants: <kbd class="calibre15">DAYS</kbd>, <kbd class="calibre15">HOURS</kbd>, <kbd class="calibre15">MICROSECONDS</kbd>, <kbd class="calibre15">MILLISECONDS</kbd>, <kbd class="calibre15">MINUTES</kbd>, <kbd class="calibre15">NANOSECONDS</kbd>, and <kbd class="calibre15">SECONDS</kbd></li>
<li class="calibre18">The <kbd class="calibre15">join()</kbd> method can't be interrupted. If you interrupt the thread that called the <kbd class="calibre15">join()</kbd> method, the method throws an <kbd class="calibre15">InterruptedException</kbd> exception.</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating a fork/join pool</em> recipe in this chapter</li>
<li class="calibre18">The <em class="calibre14">Monitoring a fork/join pool</em> recipe in <a href="part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736" class="calibre9"><span>Chapter 9</span></a>, <em class="calibre14">Testing Concurrent Applications</em></li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Throwing exceptions in the tasks</h1>
            

            <article>
                
<p class="calibre4">There are two kinds of exceptions in Java:</p>
<ul class="calibre17">
<li class="calibre18"><strong class="calibre1">Checked exceptions</strong>: These exceptions must be specified in the <kbd class="calibre15">throws</kbd> clause of a method or caught inside them. For example, <kbd class="calibre15">IOException</kbd> or <kbd class="calibre15">ClassNotFoundException</kbd>.</li>
<li class="calibre18"><strong class="calibre1">Unchecked exceptions</strong>: These exceptions don't have to be specified or caught. For example, <kbd class="calibre15">NumberFormatException</kbd>.</li>
</ul>
<p class="calibre4">You can't throw any checked exception in the <kbd class="calibre15">compute()</kbd> method of the <kbd class="calibre15">ForkJoinTask</kbd> class because this method doesn't include any <kbd class="calibre15">throws</kbd> declaration in its implementation. You have to include the necessary code to handle the checked exceptions. On the other hand, you can throw (or it can be thrown by any method or object used inside the method) an unchecked exception. The behavior of the <kbd class="calibre15">ForkJoinTask</kbd> and <kbd class="calibre15">ForkJoinPool</kbd> classes is different from what you may expect. The program doesn't finish execution and you won't see any information about the exception in the console. It's simply swallowed as if it weren't thrown. Only when you call the <kbd class="calibre15">get()</kbd> method of the initial task, the exception will be thrown. You can, however, use some methods of the <kbd class="calibre15">ForkJoinTask</kbd> class to know if a task has thrown an exception and if so, what kind of exception it was. In this recipe, you will learn how to get that information.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">Task</kbd>. Specify that it implements the <kbd class="calibre15">RecursiveTask</kbd> class, parameterized with the <kbd class="calibre15">Integer</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class Task extends RecursiveTask&lt;Integer&gt; { 
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Declare a private <kbd class="calibre15">int</kbd> array named <kbd class="calibre15">array</kbd>. It will simulate the array of data you are going to process in this example:</li>
</ol>
<pre class="calibre23">
        private int array[]; 
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Declare two private <kbd class="calibre15">int</kbd> attributes named <kbd class="calibre15">start</kbd> and <kbd class="calibre15">end</kbd>. These attributes will determine the elements of the array this task has to process:</li>
</ol>
<pre class="calibre23">
        private int start, end; 
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the constructor of the class that initializes its attributes:</li>
</ol>
<pre class="calibre23">
        public Task(int array[], int start, int end){ <br class="title-page-name"/>          this.array=array; <br class="title-page-name"/>          this.start=start; <br class="title-page-name"/>          this.end=end; <br class="title-page-name"/>        } 
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the <kbd class="calibre15">compute()</kbd> method of the task. As you have parameterized the <kbd class="calibre15">RecursiveTask</kbd> class with the <kbd class="calibre15">Integer</kbd> class, this method has to return an <kbd class="calibre15">Integer</kbd> object. First, write a message to the console with the value of the <kbd class="calibre15">start</kbd> and <kbd class="calibre15">end</kbd> attributes:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        protected Integer compute() { <br class="title-page-name"/>          System.out.printf("Task: Start from %d to %d\n",start,end);  
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">If the block of elements that this task has to process, determined by the <kbd class="calibre15">start</kbd> and <kbd class="calibre15">end</kbd> attributes, has a size smaller than <kbd class="calibre15">10</kbd>, check if the element in the fourth position in the array (index number three) is in that block. If that is the case, throw <kbd class="calibre15">RuntimeException</kbd>. Then, put the task to sleep for a second:</li>
</ol>
<pre class="calibre23">
        if (end-start&lt;10) { <br class="title-page-name"/>          if ((3&gt;start)&amp;&amp;(3&lt;end)){ <br class="title-page-name"/>            throw new RuntimeException("This task throws an"+<br class="title-page-name"/>                            "Exception: Task from  "+start+" to "+end); <br class="title-page-name"/>          } <br class="title-page-name"/>          try { <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } 
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Otherwise (the block of elements that this task has to process has a size of 10 or bigger), divide the block of elements in two, create two <kbd class="calibre15">Task</kbd> objects to process those blocks, and execute them in the pool using the <kbd class="calibre15">invokeAll()</kbd> method. Then, we write the results of these tasks to the console:</li>
</ol>
<pre class="calibre23">
        } else { <br class="title-page-name"/>          int mid=(end+start)/2; <br class="title-page-name"/>          Task task1=new Task(array,start,mid); <br class="title-page-name"/>          Task task2=new Task(array,mid,end); <br class="title-page-name"/>          invokeAll(task1, task2); <br class="title-page-name"/>          System.out.printf("Task: Result form %d to %d: %d\n",<br class="title-page-name"/>                            start,mid,task1.join()); <br class="title-page-name"/>          System.out.printf("Task: Result form %d to %d: %d\n",<br class="title-page-name"/>                            mid,end,task2.join()); <br class="title-page-name"/>        } 
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Write a message to the console indicating the end of the task, writing the value of the <kbd class="calibre15">start</kbd> and <kbd class="calibre15">end</kbd> attributes:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Task: End form %d to %d\n",start,end); 
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Return the number <kbd class="calibre15">0</kbd> as the result of the task:</li>
</ol>
<pre class="calibre23">
        return 0; 
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) { 
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Create an array of <kbd class="calibre15">100</kbd> integer numbers:</li>
</ol>
<pre class="calibre23">
        int array[]=new int[100]; 
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Create a <kbd class="calibre15">Task</kbd> object to process that <kbd class="calibre15">array</kbd>:</li>
</ol>
<pre class="calibre23">
        Task task=new Task(array,0,100); 
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Create a <kbd class="calibre15">ForkJoinPool</kbd> object using the default constructor:</li>
</ol>
<pre class="calibre23">
        ForkJoinPool pool=new ForkJoinPool(); 
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Execute the task in the pool using the <kbd class="calibre15">execute()</kbd> method:</li>
</ol>
<pre class="calibre23">
        pool.execute(task); 
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">Shut down the <kbd class="calibre15">ForkJoinPool</kbd> class using the <kbd class="calibre15">shutdown()</kbd> method:</li>
</ol>
<pre class="calibre23">
        pool.shutdown(); 
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Wait for the finalization of the task using the <kbd class="calibre15">awaitTermination()</kbd> method. As you want to wait for the finalization of the task however long it takes to complete, pass the values <kbd class="calibre15">1</kbd> and <kbd class="calibre15">TimeUnit.DAYS</kbd> as parameters to this method:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          pool.awaitTermination(1, TimeUnit.DAYS); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } 
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Check if the task, or one of its subtasks, has thrown an exception using the <kbd class="calibre15">isCompletedAbnormally()</kbd> method. In such a case, write a message to the console with the exception that was thrown. Get that exception with the <kbd class="calibre15">getException()</kbd> method of the <kbd class="calibre15">ForkJoinTask</kbd> class:</li>
</ol>
<pre class="calibre23">
        if (task.isCompletedAbnormally()) { <br class="title-page-name"/>          System.out.printf("Main: An exception has ocurred\n"); <br class="title-page-name"/>          System.out.printf("Main: %s\n",task.getException()); <br class="title-page-name"/>        } <br class="title-page-name"/>        System.out.printf("Main: Result: %d",task.join()); 
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">Task</kbd> class you implemented in this recipe processes an array of numbers. It checks if the block of numbers it has to process has <kbd class="calibre15">10</kbd> or more elements. In that case, it splits the block in two and creates two new <kbd class="calibre15">Task</kbd> objects to process those blocks. Otherwise, it looks for the element in the fourth position of the array (index number three). If that element is in the block the task has to process, it throws <kbd class="calibre15">RuntimeException</kbd>.</p>
<p class="calibre4">When you execute the program, the exception is thrown, but the program doesn't stop. In the <kbd class="calibre15">Main</kbd> class you have included a call to the <kbd class="calibre15">isCompletedAbnormally()</kbd> method of the <kbd class="calibre15">ForkJoinTask</kbd> class using the original task. This method returns <kbd class="calibre15">true</kbd> if that task, or one of its subtasks, has thrown an exception. You also used the <kbd class="calibre15">getException()</kbd> method of the same object to get the <kbd class="calibre15">Exception</kbd> object that it has thrown.</p>
<p class="calibre4">When you throw an unchecked exception in a task, it also affects its parent task (the task that sent it to the <kbd class="calibre15">ForkJoinPool</kbd> class) and the parent task of its parent task, and so on. If you revise the entire output of the program, you'll see that there aren't output messages for the finalization of some tasks. The starting messages of those tasks are as follows:</p>
<pre class="calibre23">
    Task: Starting form 0 to 100 <br class="title-page-name"/>    Task: Starting form 0 to 50 <br class="title-page-name"/>    Task: Starting form 0 to 25 <br class="title-page-name"/>    Task: Starting form 0 to 12 <br class="title-page-name"/>    Task: Starting form 0 to 6 
</pre>
<p class="calibre4">These tasks are the ones that threw the exception and its parent tasks. All of them have finished abnormally. Take this into account when you develop a program with the <kbd class="calibre15">ForkJoinPool</kbd> and <kbd class="calibre15">ForkJoinTask</kbd> objects that can throw exceptions if you don't want this behavior.</p>
<p class="calibre4">The following screenshot shows part of an execution of this example:</p>
<div class="cdpaligncenter"><img class="image-border9" src="../images/00036.jpeg"/></div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
            

            <article>
                
<p class="calibre4">In this example, you used the <kbd class="calibre15">join()</kbd> method to wait for the finalization of tasks and get their results. You can also use one of the following two versions of the <kbd class="calibre15">get()</kbd> method with this purpose:</p>
<ul class="calibre17">
<li class="calibre18"><kbd class="calibre15">get()</kbd>: This version of the <kbd class="calibre15">get()</kbd> method returns the value returned by the <kbd class="calibre15">compute()</kbd> method if <kbd class="calibre15">ForkJoinTask</kbd> has finished its execution, or it waits until its finalization.</li>
<li class="calibre18"><kbd class="calibre15">get(long timeout, TimeUnit unit)</kbd>: This version of the <kbd class="calibre15">get()</kbd> method, if the result of the task isn't available, waits the specified time for it. If the specified period of time passes and the result isn't yet available, the method returns a <kbd class="calibre15">null</kbd> value. The <kbd class="calibre15">TimeUnit</kbd> class is an enumeration with the following constants: <kbd class="calibre15">DAYS</kbd>, <kbd class="calibre15">HOURS</kbd>, <kbd class="calibre15">MICROSECONDS</kbd>, <kbd class="calibre15">MILLISECONDS</kbd>, <kbd class="calibre15">MINUTES</kbd>, <kbd class="calibre15">NANOSECONDS</kbd>, and <kbd class="calibre15">SECONDS</kbd>.</li>
</ul>
<p class="calibre4">There are two main differences between the <kbd class="calibre15">get()</kbd> and <kbd class="calibre15">join()</kbd> methods:</p>
<ul class="calibre17">
<li class="calibre18">The <kbd class="calibre15">join()</kbd> method can't be interrupted. If you interrupt the thread that called the <kbd class="calibre15">join()</kbd> method, the method throws <kbd class="calibre15">InterruptedException</kbd>.</li>
<li class="calibre18">While the <kbd class="calibre15">get()</kbd> method will return <kbd class="calibre15">ExecutionException</kbd> if the tasks throw any unchecked exception, the <kbd class="calibre15">join()</kbd> method will return <kbd class="calibre15">RuntimeException</kbd>.</li>
</ul>
<p class="calibre4">You can obtain the same result obtained in the example if, instead of throwing an exception, you use the <kbd class="calibre15">completeExceptionally()</kbd> method of the <kbd class="calibre15">ForkJoinTask</kbd> class. The code would be as follows:</p>
<pre class="calibre23">
    Exception e=new Exception("This task throws an Exception: "+<br class="title-page-name"/>                              "Task from  "+start+" to "+end); <br class="title-page-name"/>    completeExceptionally(e); 
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating a fork/join pool</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Canceling a task</h1>
            

            <article>
                
<p class="calibre4">When you execute the <kbd class="calibre15">ForkJoinTask</kbd> objects in a <kbd class="calibre15">ForkJoinPool</kbd> class, you can cancel them before they start their execution. The <kbd class="calibre15">ForkJoinTask</kbd> class provides the <kbd class="calibre15">cancel()</kbd> method for this purpose. There are some points you have to take into account when you want to cancel a task, which are as follows:</p>
<ul class="calibre17">
<li class="calibre18">The <kbd class="calibre15">ForkJoinPool</kbd> class doesn't provide any method to cancel all the tasks it has running or waiting in the pool</li>
<li class="calibre18">When you cancel a task, you don't cancel the tasks this task has executed</li>
</ul>
<p class="calibre4">In this recipe, you will implement an example of the cancellation of <kbd class="calibre15">ForkJoinTask</kbd> objects. You will look for the position of a number in an array. The first task that finds the number will cancel the remaining tasks. As that functionality is not provided by the fork/join framework, you will implement an auxiliary class to do this cancellation.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Getting ready...</h1>
            

            <article>
                
<p class="calibre4">The example of this recipe has been implemented using the Eclipse IDE. If you use Eclipse or other IDE such as NetBeans, open it and create a new Java project.</p>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
            

            <article>
                
<p class="calibre4">Follow these steps to implement the example:</p>
<ol class="calibre19">
<li value="1" class="calibre18">Create a class named <kbd class="calibre15">ArrayGenerator</kbd>. This class will generate an array of random integer numbers with the specified size. Implement a method named <kbd class="calibre15">generateArray()</kbd>. It will generate the array of numbers. It receives the size of the array as a parameter:</li>
</ol>
<pre class="calibre23">
        public class ArrayGenerator { <br class="title-page-name"/>          public int[] generateArray(int size) { <br class="title-page-name"/>            int array[]=new int[size]; <br class="title-page-name"/>            Random random=new Random(); <br class="title-page-name"/>            for (int i=0; i&lt;size; i++){ <br class="title-page-name"/>              array[i]=random.nextInt(10); <br class="title-page-name"/>            } <br class="title-page-name"/>            return array; <br class="title-page-name"/>          } 
</pre>
<ol start="2" class="calibre19">
<li value="2" class="calibre18">Create a class named <kbd class="calibre15">TaskManager</kbd>. We will use this class to store all the tasks executed in <kbd class="calibre15">ForkJoinPool</kbd> used in the example. Due to the limitations of the <kbd class="calibre15">ForkJoinPool</kbd> and <kbd class="calibre15">ForkJoinTask</kbd> classes, you will use this class to cancel all the tasks of the <kbd class="calibre15">ForkJoinPool</kbd> class:</li>
</ol>
<pre class="calibre23">
        public class TaskManager { 
</pre>
<ol start="3" class="calibre19">
<li value="3" class="calibre18">Declare a list of objects parameterized with the <kbd class="calibre15">ForkJoinTask</kbd> class, parameterized with the <kbd class="calibre15">Integer</kbd> class named <kbd class="calibre15">List</kbd>:</li>
</ol>
<pre class="calibre23">
        private final ConcurrentLinkedDeque&lt;SearchNumberTask&gt; tasks; 
</pre>
<ol start="4" class="calibre19">
<li value="4" class="calibre18">Implement the constructor of the class. It initializes the list of tasks:</li>
</ol>
<pre class="calibre23">
        public TaskManager(){ <br class="title-page-name"/>          tasks=new ConcurrentLinkedDeque&lt;&gt;(); <br class="title-page-name"/>        } 
</pre>
<ol start="5" class="calibre19">
<li value="5" class="calibre18">Implement the <kbd class="calibre15">addTask()</kbd> method. It adds a <kbd class="calibre15">ForkJoinTask</kbd> object to the lists of tasks:</li>
</ol>
<pre class="calibre23">
        public void addTask(ForkJoinTask&lt;Integer&gt; task){ <br class="title-page-name"/>          tasks.add(task); <br class="title-page-name"/>        } 
</pre>
<ol start="6" class="calibre19">
<li value="6" class="calibre18">Implement the <kbd class="calibre15">cancelTasks()</kbd> method. It will cancel all the <kbd class="calibre15">ForkJoinTask</kbd> objects stored in the list using the <kbd class="calibre15">cancel()</kbd> method. It receives as a parameter the <kbd class="calibre15">ForkJoinTask</kbd> object that wants to cancel the rest of the tasks. The method cancels all the tasks:</li>
</ol>
<pre class="calibre23">
        public void cancelTasks(SearchNumberTask cancelTask){ <br class="title-page-name"/>          for (SearchNumberTask task  :tasks) { <br class="title-page-name"/>            if (task!=cancelTask) { <br class="title-page-name"/>              task.cancel(true); <br class="title-page-name"/>              task.logCancelMessage(); <br class="title-page-name"/>            } <br class="title-page-name"/>          } <br class="title-page-name"/>        } 
</pre>
<ol start="7" class="calibre19">
<li value="7" class="calibre18">Implement the <kbd class="calibre15">SearchNumberTask</kbd> class. Specify that it extends the <kbd class="calibre15">RecursiveTask</kbd> class parameterized with the <kbd class="calibre15">Integer</kbd> class. This class will look for a number in a block of elements of an integer array:</li>
</ol>
<pre class="calibre23">
        public class SearchNumberTask extends RecursiveTask&lt;Integer&gt; { 
</pre>
<ol start="8" class="calibre19">
<li value="8" class="calibre18">Declare a private array of <kbd class="calibre15">int</kbd> numbers named <kbd class="calibre15">numbers</kbd>:</li>
</ol>
<pre class="calibre23">
        private int numbers[]; 
</pre>
<ol start="9" class="calibre19">
<li value="9" class="calibre18">Declare two private <kbd class="calibre15">int</kbd> attributes named <kbd class="calibre15">start</kbd> and <kbd class="calibre15">end</kbd>. These attributes will determine the elements of the array this task has to process:</li>
</ol>
<pre class="calibre23">
        private int start, end; 
</pre>
<ol start="10" class="calibre19">
<li value="10" class="calibre18">Declare a private <kbd class="calibre15">int</kbd> attribute named <kbd class="calibre15">number</kbd> to store the number you are going to look for:</li>
</ol>
<pre class="calibre23">
        private int number; 
</pre>
<ol start="11" class="calibre19">
<li value="11" class="calibre18">Declare a private <kbd class="calibre15">TaskManager</kbd> attribute named <kbd class="calibre15">manager</kbd>. You will use this object to cancel all the tasks:</li>
</ol>
<pre class="calibre23">
        private TaskManager manager; 
</pre>
<ol start="12" class="calibre19">
<li value="12" class="calibre18">Declare a private <kbd class="calibre15">int</kbd> constant and initialize it to <kbd class="calibre15">-1</kbd>. It will be the returned value by the task when it doesn't find the number:</li>
</ol>
<pre class="calibre23">
        private final static int NOT_FOUND=-1; 
</pre>
<ol start="13" class="calibre19">
<li value="13" class="calibre18">Implement the constructor of the class to initialize its attributes:</li>
</ol>
<pre class="calibre23">
        public SearchNumberTask(int numbers[], int start, int end,<br class="title-page-name"/>                                int number, TaskManager manager){ <br class="title-page-name"/>          this.numbers=numbers; <br class="title-page-name"/>          this.start=start; <br class="title-page-name"/>          this.end=end; <br class="title-page-name"/>          this.number=number; <br class="title-page-name"/>          this.manager=manager; <br class="title-page-name"/>        } 
</pre>
<ol start="14" class="calibre19">
<li value="14" class="calibre18">Implement the <kbd class="calibre15">compute()</kbd> method. Start the method by writing a message to the console indicating the values of the <kbd class="calibre15">start</kbd> and <kbd class="calibre15">end</kbd> attributes:</li>
</ol>
<pre class="calibre23">
        @Override <br class="title-page-name"/>        protected Integer compute() { <br class="title-page-name"/>          System.out.println("Task: "+start+":"+end); 
</pre>
<ol start="15" class="calibre19">
<li value="15" class="calibre18">If the difference between the <kbd class="calibre15">start</kbd> and <kbd class="calibre15">end</kbd> attributes is greater than <kbd class="calibre15">10</kbd> (the task has to process more than <kbd class="calibre15">10</kbd> elements of the array), call the <kbd class="calibre15">launchTasks()</kbd> method to divide the work of this task into two subtasks:</li>
</ol>
<pre class="calibre23">
        int ret; <br class="title-page-name"/>        if (end-start&gt;10) { <br class="title-page-name"/>          ret=launchTasks(); 
</pre>
<ol start="16" class="calibre19">
<li value="16" class="calibre18">Otherwise, look for the number in the block of the array that the task calling the <kbd class="calibre15">lookForNumber()</kbd> method has to process:</li>
</ol>
<pre class="calibre23">
        } else { <br class="title-page-name"/>          ret=lookForNumber(); <br class="title-page-name"/>        } 
</pre>
<ol start="17" class="calibre19">
<li value="17" class="calibre18">Return the result of the task:</li>
</ol>
<pre class="calibre23">
        return ret; 
</pre>
<ol start="18" class="calibre19">
<li value="18" class="calibre18">Implement the <kbd class="calibre15">lookForNumber()</kbd> method:</li>
</ol>
<pre class="calibre23">
        private int lookForNumber() { 
</pre>
<ol start="19" class="calibre19">
<li value="19" class="calibre18">For all the elements in the block of elements this task has to process, compare the value stored in that element with the number you are looking for. If they are equal, write a message to the console indicating, in such a circumstance, to use the <kbd class="calibre15">cancelTasks()</kbd> method of the <kbd class="calibre15">TaskManager</kbd> object to cancel all the tasks, and return the position of the element where you found the number:</li>
</ol>
<pre class="calibre23">
        for (int i=start; i&lt;end; i++){ <br class="title-page-name"/>          if (numbers[i]==number) { <br class="title-page-name"/>            System.out.printf("Task: Number %d found in position %d\n",<br class="title-page-name"/>                              number,i); <br class="title-page-name"/>            manager.cancelTasks(this); <br class="title-page-name"/>            return i; <br class="title-page-name"/>          } 
</pre>
<ol start="20" class="calibre19">
<li value="20" class="calibre18">Inside the loop, put the task to sleep for one second:</li>
</ol>
<pre class="calibre23">
          try { <br class="title-page-name"/>            TimeUnit.SECONDS.sleep(1); <br class="title-page-name"/>          } catch (InterruptedException e) { <br class="title-page-name"/>            e.printStackTrace(); <br class="title-page-name"/>          } <br class="title-page-name"/>        } 
</pre>
<ol start="21" class="calibre19">
<li value="21" class="calibre18">Finally, return the <kbd class="calibre15">-1</kbd> value:</li>
</ol>
<pre class="calibre23">
          return NOT_FOUND; <br class="title-page-name"/>        } 
</pre>
<ol start="22" class="calibre19">
<li value="22" class="calibre18">Implement the <kbd class="calibre15">launchTasks()</kbd> method. First, divide the block of numbers this task has to process into two, and then create two <kbd class="calibre15">Task</kbd> objects to process them:</li>
</ol>
<pre class="calibre23">
        private int launchTasks() { <br class="title-page-name"/>          int mid=(start+end)/2; <br class="title-page-name"/> <br class="title-page-name"/>          Task task1=new Task(numbers,start,mid,number,manager); <br class="title-page-name"/>          Task task2=new Task(numbers,mid,end,number,manager); 
</pre>
<ol start="23" class="calibre19">
<li value="23" class="calibre18">Add the tasks to the <kbd class="calibre15">TaskManager</kbd> object:</li>
</ol>
<pre class="calibre23">
        manager.addTask(task1); <br class="title-page-name"/>        manager.addTask(task2); 
</pre>
<ol start="24" class="calibre19">
<li value="24" class="calibre18">Execute the two tasks asynchronously using the <kbd class="calibre15">fork()</kbd> method:</li>
</ol>
<pre class="calibre23">
        task1.fork(); <br class="title-page-name"/>        task2.fork(); 
</pre>
<ol start="25" class="calibre19">
<li value="25" class="calibre18">Wait for the finalization of the tasks, and return the result of the first task if it is not equal to <kbd class="calibre15">-1</kbd> or the result of the second task, otherwise:</li>
</ol>
<pre class="calibre23">
        int returnValue; <br class="title-page-name"/>        returnValue=task1.join(); <br class="title-page-name"/>        if (returnValue!=-1) { <br class="title-page-name"/>          return returnValue; <br class="title-page-name"/>        } <br class="title-page-name"/> <br class="title-page-name"/>        returnValue=task2.join(); <br class="title-page-name"/>        return returnValue; 
</pre>
<ol start="26" class="calibre19">
<li value="26" class="calibre18">Implement the <kbd class="calibre15">writeCancelMessage()</kbd> method to write a message when the task is canceled:</li>
</ol>
<pre class="calibre23">
        public void logCancelMessage(){ <br class="title-page-name"/>          System.out.printf("Task: Canceled task from %d to %d",<br class="title-page-name"/>                            start,end); <br class="title-page-name"/>        } 
</pre>
<ol start="27" class="calibre19">
<li value="27" class="calibre18">Implement the main class of the example by creating a class named <kbd class="calibre15">Main</kbd> with a <kbd class="calibre15">main()</kbd> method:</li>
</ol>
<pre class="calibre23">
        public class Main { <br class="title-page-name"/>          public static void main(String[] args) { 
</pre>
<ol start="28" class="calibre19">
<li value="28" class="calibre18">Create an array of <kbd class="calibre15">1000</kbd> numbers using the <kbd class="calibre15">ArrayGenerator</kbd> class:</li>
</ol>
<pre class="calibre23">
        ArrayGenerator generator=new ArrayGenerator(); <br class="title-page-name"/>        int array[]=generator.generateArray(1000); 
</pre>
<ol start="29" class="calibre19">
<li value="29" class="calibre18">Create a <kbd class="calibre15">TaskManager</kbd> object:</li>
</ol>
<pre class="calibre23">
        TaskManager manager=new TaskManager(); 
</pre>
<ol start="30" class="calibre19">
<li value="30" class="calibre18">Create a <kbd class="calibre15">ForkJoinPool</kbd> object using the default constructor:</li>
</ol>
<pre class="calibre23">
        ForkJoinPool pool=new ForkJoinPool(); 
</pre>
<ol start="31" class="calibre19">
<li value="31" class="calibre18">Create a <kbd class="calibre15">Task</kbd> object to process the array generated before:</li>
</ol>
<pre class="calibre23">
        SearchNumberTask task=new SearchNumberTask (array,0,1000,<br class="title-page-name"/>                                                    5,manager); 
</pre>
<ol start="32" class="calibre19">
<li value="32" class="calibre18">Execute the task in the pool asynchronously using the <kbd class="calibre15">execute()</kbd> method:</li>
</ol>
<pre class="calibre23">
        pool.execute(task); 
</pre>
<ol start="33" class="calibre19">
<li value="33" class="calibre18">Shut down the pool using the <kbd class="calibre15">shutdown()</kbd> method:</li>
</ol>
<pre class="calibre23">
        pool.shutdown(); 
</pre>
<ol start="34" class="calibre19">
<li value="34" class="calibre18">Wait for the finalization of the tasks using the <kbd class="calibre15">awaitTermination()</kbd> method of the <kbd class="calibre15">ForkJoinPool</kbd> class:</li>
</ol>
<pre class="calibre23">
        try { <br class="title-page-name"/>          pool.awaitTermination(1, TimeUnit.DAYS); <br class="title-page-name"/>        } catch (InterruptedException e) { <br class="title-page-name"/>          e.printStackTrace(); <br class="title-page-name"/>        } 
</pre>
<ol start="35" class="calibre19">
<li value="35" class="calibre18">Write a message to the console indicating the end of the program:</li>
</ol>
<pre class="calibre23">
        System.out.printf("Main: The program has finished\n"); 
</pre>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
            

            <article>
                
<p class="calibre4">The <kbd class="calibre15">ForkJoinTask</kbd> class provides the <kbd class="calibre15">cancel()</kbd> method that allows you to cancel a task if it hasn't been executed yet. This is a very important point. If the task has begun its execution, a call to the <kbd class="calibre15">cancel()</kbd> method has no effect. The method receives a parameter as a <kbd class="calibre15">Boolean</kbd> value called <kbd class="calibre15">mayInterruptIfRunning</kbd>. This name may make you think that, if you pass the true value to the method, the task will be canceled even if it is running. The Java API documentation specifies that, in the default implementation of the <kbd class="calibre15">ForkJoinTask</kbd> class, this attribute has no effect. The tasks are only canceled if they haven't started their execution. The cancellation of a task has no effect over the tasks that the cancelled task sent to the pool. They continue with their execution.</p>
<p class="calibre4">A limitation of the fork/join framework is that it doesn't allow the cancellation of all the tasks that are in <kbd class="calibre15">ForkJoinPool</kbd>. To overcome that limitation, you implemented the <kbd class="calibre15">TaskManager</kbd> class. It stores all the tasks that have been sent to the pool. It has a method that cancels all the tasks it has stored. If a task can't be canceled because it's running or has finished, the <kbd class="calibre15">cancel()</kbd> method returns the <kbd class="calibre15">false</kbd> value, so you can try to cancel all the tasks without being afraid of the possible collateral effects.</p>
<p class="calibre4">In the example, you have implemented a task that looks for a number in an array of numbers. You divided the problem into smaller subproblems as the fork/join framework recommends. You are only interested in one occurrence of the number, so when you find it, you cancel the other tasks.</p>
<p class="calibre4">The following screenshot shows part of an execution of this example:</p>
<div class="cdpaligncenter"><img class="image-border10" src="../images/00037.jpeg"/></div>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
            

            <article>
                
<ul class="calibre17">
<li class="calibre18">The <em class="calibre14">Creating a fork/join pool</em> recipe in this chapter</li>
</ul>


            </article>

            <footer class="calibre6">
                
            </footer>

        </section>
    </body></html>