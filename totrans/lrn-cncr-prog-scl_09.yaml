- en: Chapter 9. Concurrency in Practice
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章. 实践中的并发
- en: '|   | *"The best theory is inspired by practice."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"最好的理论是受实践启发的。" |   |'
- en: '|   | --*Donald Knuth* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*唐纳德·克努特* |'
- en: We have studied a plethora of different concurrency facilities in this book.
    By now, you will have learned about dozens of different ways of starting concurrent
    computations and accessing shared data. Knowing how to use different styles of
    concurrency is useful, but it might not yet be obvious when to use which.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书我们研究了大量的不同并发设施。到目前为止，你已经了解了数十种启动并发计算和访问共享数据的不同方法。了解如何使用不同的并发风格是有用的，但可能还不明显何时使用哪种。
- en: 'The goal of this final chapter is to introduce the big picture of concurrent
    programming. We will study the use cases for various concurrency abstractions,
    see how to debug concurrent programs, and how to integrate different concurrency
    libraries in larger applications. In this chapter, we will perform the following
    tasks:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是介绍并发编程的总体情况。我们将研究各种并发抽象的使用案例，了解如何调试并发程序，以及如何将不同的并发库集成到更大的应用程序中。在本章中，我们将执行以下任务：
- en: Summarize the characteristics and typical uses of different concurrency frameworks
    introduced in the earlier chapters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结前面章节中介绍的不同并发框架的特点和典型用途
- en: Investigate how to deal with various kinds of bugs appearing in concurrent applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查如何处理并发应用程序中出现的各种类型的错误
- en: Learn how to identify and resolve performance bottlenecks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何识别和解决性能瓶颈
- en: Apply the previous knowledge about concurrency to implement a larger concurrent
    application, namely, a remote file browser
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将之前关于并发的知识应用于实现一个更大的并发应用程序，即远程文件浏览器
- en: We start with an overview of the important concurrency frameworks we have learned
    about in this book, and a summary of when to use each of them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先概述了本书中我们学习的重要并发框架，以及何时使用它们的总结。
- en: Choosing the right tools for the job
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择适合工作的正确工具
- en: In this section, we present an overview of the different concurrency libraries
    that we learned about. We take a step back and look at the differences between
    these libraries, and what they have in common. This summary will give us an insight
    into what different concurrency abstractions are useful for.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们概述了我们所了解的不同并发库。我们退后一步，看看这些库之间的差异以及它们的共同点。这个总结将使我们深入了解不同的并发抽象对什么是有用的。
- en: 'A concurrency framework usually needs to address several concerns:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 并发框架通常需要解决以下几个问题：
- en: It must provide a way to declare data that is shared between concurrent executions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须提供一种声明在并发执行之间共享的数据的方式
- en: It must provide constructs for reading and modifying program data
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须提供读取和修改程序数据的构造
- en: It must be able to express conditional execution, triggered when a certain set
    of conditions are fulfilled
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须能够表达条件执行，当满足一定条件集时触发
- en: It must define a way to start concurrent executions
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须定义一种启动并发执行的方式
- en: Some of the frameworks from this book address all these concerns; others address
    only a subset, and transfer part of the responsibility to another framework.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的一些框架解决了所有这些问题；其他框架只解决了一部分，并将部分责任转移给了另一个框架。
- en: 'Typically, in a concurrent programming model, we express concurrently shared
    data differently from data intended to be accessed only from a single thread.
    This allows the JVM runtime to optimize sequential parts of the program more effectively.
    So far, we''ve seen a lot of different ways to express concurrently shared data,
    ranging from the low-level facilities to advanced high-level abstractions. We
    summarize different data abstractions in the following table:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在并发编程模型中，我们以不同的方式表达并发共享数据，与仅从单个线程访问的数据。这使得JVM运行时能够更有效地优化程序的顺序部分。到目前为止，我们已经看到了许多表达并发共享数据的不同方法，从低级设施到高级抽象。以下表格总结了不同的数据抽象：
- en: '| **Data abstraction** | **Datatype or annotation** | **Description** |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **数据抽象** | **数据类型或注解** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Volatile variables(JDK) | @volatile | Ensures visibility and the happens-before
    relationship on class fields and local variables that are captured in closures.
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| Volatile变量（JDK） | @volatile | 确保类字段和局部变量（在闭包中捕获）的可见性和happens-before关系。 |'
- en: '| Atomic variables(JDK) | AtomicReference[T]AtomicIntegerAtomicLong | Provide
    basic composite atomic operations, such as **`compareAndSet`** and **`incrementAndGet`**
    . |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: '| Futures and promises( **`scala.concurrent`** ) | Future[T]Promise[T] | Sometimes
    called single-assignment variables, these express values that might not be computed
    yet but will eventually become available. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
- en: '| Observables and subjects(Rx) | Observable[T]Subject[T] | Also known as first-class
    event streams, these describe many different values that arrive one after another
    in time. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
- en: '| Transactional references(ScalaSTM) | Ref[T] | These describe memory locations
    that can only be accessed from within memory transactions. Their modifications
    only become visible after the transaction successfully commits. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
- en: 'The next important concern is providing access to shared data, which includes
    reading and modifying shared memory locations. Usually, a concurrent program uses
    special constructs to express such accesses. We summarize the different data access
    constructs in the following table:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data abstraction** | **Data access constructs** | **Description** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
- en: '| Arbitrary data(JDK) | synchronized | Uses intrinsic object locks to exclude
    access to arbitrary shared data. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
- en: '| Atomic variables and classes(JDK) | compareAndSet | Atomically exchanges
    the value of a single memory location. It allows implementing lock-free programs.
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: '| Futures and promises( **`scala.concurrent`** ) | valuetryComplete | Used
    to assign a value to a promise, or to check the value of the corresponding future.
    The **`value`** method is not a preferred way to interact with a future. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: '| Transactional references and classes(Scala STM) | atomicorAtomicsingle |
    Atomically modifies the values of a set of memory locations. Reduces the risk
    of deadlocks, but disallows side effects inside the transactional block. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: 'Concurrent data access is not the only concern of a concurrency framework.
    As we have learned in previous chapters, concurrent computations sometimes need
    to proceed only after a certain condition is met. In the following table, we summarize
    different constructs that enable this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '| **Concurrency framework** | **Conditional execution constructs** | **Description**
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| JVM concurrency | waitnotifynotifyAll | Used to suspend the execution of
    a thread until some other thread notifies that the conditions are met. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| Futures and promises | onCompleteAwait.ready | Conditionally schedules an
    asynchronous computation. The **`Await.ready`** method suspends the thread until
    the future completes. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| Reactive extensions | subscribe | Asynchronously or synchronously executes
    a computation when an event arrives. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| Software transactional memory | retryretryForwithRetryTimeout | Retries the
    current memory transaction when some of the relevant memory locations change.
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| Actors | receive | Executes the actor''s **`receive`** block when a message
    arrives. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: 'Finally, a concurrency model must define a way to start a concurrent execution.
    We summarize different concurrency constructs in the following table:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，并发模型必须定义一种启动并发执行的方法。以下表格总结了不同的并发构造：
- en: '| **Concurrency framework** | **Concurrency constructs** | **Description**
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **并发框架** | **并发构造** | **描述** |'
- en: '| JVM concurrency | Thread.start | Starts a new thread of execution. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| JVM并发 | Thread.start | 启动一个新的执行线程。 |'
- en: '| Execution contexts | execute | Schedules a block of code for execution on
    a thread pool. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 执行上下文 | execute | 在线程池上为执行调度一段代码。 |'
- en: '| Futures and promises | Future.apply | Schedules a block of code for execution,
    and returns the future value with the result of the execution. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 期货和承诺 | Future.apply | 为执行调度一段代码，并返回执行结果的未来值。 |'
- en: '| Parallel collections | par | Allows invoking data-parallel versions of collection
    methods. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 并行集合 | par | 允许调用集合方法的数据并行版本。 |'
- en: '| Reactive extensions | Observable.createobserveOn | The **`create`** method
    defines an event source. The **`observeOn`** method schedules the handling of
    events on different threads. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 反应式扩展 | Observable.createObserveOn | **`create`** 方法定义了一个事件源。**`observeOn`**
    方法在不同的线程上调度事件的处理。 |'
- en: '| Actors | actorOf | Schedules a new actor object for execution. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 演员 | actorOf | 为执行调度一个新的演员对象。 |'
- en: This breakdown shows us that different concurrency libraries focus on different
    tasks. For example, parallel collections do not have conditional waiting constructs,
    because a data-parallel operation proceeds on separate elements independently.
    Similarly, software transactional memory does not come with a construct to express
    concurrent computations, and focuses only on protecting access to shared data.
    Actors do not have special constructs for modeling shared data and protecting
    access to it, because data is encapsulated within separate actors and accessed
    serially only by the actor that owns it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分解显示，不同的并发库专注于不同的任务。例如，并行集合没有条件等待构造，因为数据并行操作是在独立元素上进行的。同样，软件事务内存没有用于表达并发计算的构造，它只关注保护对共享数据的访问。演员没有用于建模共享数据和保护其访问的特殊构造，因为数据封装在单独的演员中，并且只能由拥有它的演员按顺序访问。
- en: 'Having classified concurrency libraries according to how they model shared
    data and express concurrency, we present a summary of what different concurrency
    libraries are good for:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们如何建模共享数据和表达并发，我们对并发库进行了分类，现在我们总结一下不同的并发库适合做什么：
- en: The classical JVM concurrency model uses threads, the `synchronized` statement,
    volatile variables, and atomic primitives for low-level tasks. Uses include implementing
    a custom concurrency utility, a concurrent data structure, or a concurrency framework
    optimized for specific tasks.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经典的JVM并发模型使用线程、`synchronized`语句、volatile变量和原子原语进行低级任务。用途包括实现自定义并发实用程序、并发数据结构或针对特定任务优化的并发框架。
- en: Futures and promises are best suited for referring to concurrent computations
    that produce a single result value. Futures model latency in the program, and
    allow composing values that become available later during the execution of the
    program. Uses include performing remote network requests and waiting for replies,
    referring to the result of an asynchronous long-running computation, or reacting
    to the completion of an I/O operation. Futures are usually the glue of a concurrent
    application, binding the different parts of a concurrent program together. We
    often use futures to convert single-event callback APIs into a standardized representation
    based on the `Future` type.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 期货和承诺最适合引用产生单个结果值的并发计算。期货模型程序中的延迟，并允许在程序执行过程中将可用的值组合起来。用途包括执行远程网络请求并等待回复，引用异步长时间运行计算的结果，或对I/O操作的完成做出反应。期货通常是并发应用程序的粘合剂，将并发程序的不同部分绑定在一起。我们经常使用期货将单事件回调API转换为基于`Future`类型的标准化表示。
- en: Parallel collections are best suited for efficiently executing data-parallel
    operations on large datasets. Uses include file searching, text processing, linear
    algebra applications, numerical computations, and simulations. Long-running Scala
    collection operations are usually good candidates for parallelization.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行集合最适合在大型数据集上高效执行数据并行操作。用途包括文件搜索、文本处理、线性代数应用、数值计算和模拟。长时间运行的Scala集合操作通常是并行化的良好候选。
- en: Reactive extensions are used to express asynchronous event-based programs. Unlike
    parallel collections, in reactive extensions, data elements are not available
    when the operation starts, but arrive while the application is running. Uses include
    converting callback-based APIs, modeling events in user interfaces, modeling events
    external to the application, manipulating program events with collection-style
    combinators, streaming data from input devices or remote locations, or incrementally
    propagating changes in the data model throughout the program.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式扩展用于表达基于异步事件驱动的程序。与并行集合不同，在反应式扩展中，数据元素在操作开始时不可用，而是在应用程序运行时到达。应用包括将基于回调的API转换为反应式API，在用户界面中建模事件，建模应用程序外部的事件，使用集合样式组合子操作程序事件，从输入设备或远程位置流式传输数据，或在程序中增量传播数据模型的变化。
- en: Use STM to protect program data from getting corrupted by concurrent accesses.
    An STM allows building complex data models and accessing them with the reduced
    risk of deadlocks and race conditions. A typical use is to protect concurrently
    accessible data while retaining good scalability between threads whose accesses
    to data do not overlap.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用STM（软件事务内存）来保护程序数据免受并发访问的损坏。STM允许构建复杂的数据模型，并以降低死锁和竞态条件风险的方式访问它们。典型用途是在保护并发可访问数据的同时，保持线程之间数据访问不重叠时的良好可伸缩性。
- en: Actors are suitable for encapsulating concurrently accessible data, and seamlessly
    building distributed systems. Actor frameworks provide a natural way to express
    concurrent tasks that communicate by explicitly sending messages. Uses include
    serializing concurrent access to data to prevent corruption, expressing stateful
    concurrency units in the system, and building distributed applications such as
    trading systems, P2P networks, communication hubs, or data-mining frameworks.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员（Actors）适合封装可并发访问的数据，并无缝构建分布式系统。演员框架提供了一种自然的方式来表达通过显式发送消息进行通信的并发任务。应用包括将并发访问数据序列化以防止损坏，在系统中表达有状态的并发单元，以及构建如交易系统、P2P网络、通信中心或数据挖掘框架等分布式应用程序。
- en: Advocates of specific programming languages, libraries, or frameworks might
    try to convince you that their technology is the best for any task and any situation,
    often with the intent of selling it. Richard Stallman once said that "computer
    science is the only industry more fashion-driven than women's fashion." As engineers,
    we need to know better than to succumb to programming fashion and marketing propaganda.
    Different frameworks are tailored towards specific use cases, and the correct
    way to choose a technology is to carefully weigh its advantages and disadvantages
    when applied to a specific situation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 某些编程语言、库或框架的倡导者可能会试图说服你，他们的技术适用于任何任务和任何情况，通常带有销售的目的。理查德·斯托尔曼曾经说过：“计算机科学是唯一比女性时尚更受时尚驱动的行业。”作为工程师，我们需要比屈服于编程时尚和营销宣传更有见识。不同的框架针对特定的用例定制，选择技术的正确方式是在特定情况下仔细权衡其优缺点。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There is no one-size-fits-all technology. Use your own best judgment when deciding
    which concurrency framework to use for a specific programming task.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种技术可以适用于所有情况。在决定为特定的编程任务使用哪个并发框架时，请使用自己的最佳判断。
- en: Sometimes, choosing the best-suited concurrency utility is easier said than
    done. It takes a great deal of experience to choose the correct technology. In
    many cases, we do not even know enough about the requirements of the system to
    make an informed decision. Regardless, a good rule of thumb is to apply several
    concurrency frameworks to different parts of the same application, each best suited
    for a specific task. Often, the real power of different concurrency frameworks
    becomes apparent when they are used together. This is the topic we will cover
    in the following section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，选择最适合的并发工具比说起来容易做起来难。选择正确的技术需要大量的经验。在许多情况下，我们甚至对系统的需求了解不足，无法做出明智的决定。无论如何，一个很好的经验法则是将几个并发框架应用于同一应用程序的不同部分，每个框架最适合特定任务。通常，不同并发框架的真实力量在它们一起使用时才会显现。这是我们将在下一节中讨论的主题。
- en: Putting it all together - a remote file browser
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起 - 远程文件浏览器
- en: In this section, we use our knowledge about different concurrency frameworks
    to build a remote file browser. This larger application example illustrates how
    different concurrency libraries work together, and how to apply them to different
    situations. We will name our remote file browser ScalaFTP.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们利用我们对不同并发框架的了解来构建一个远程文件浏览器。这个更大的应用程序示例说明了不同的并发库如何协同工作，以及如何将它们应用于不同的场景。我们将我们的远程文件浏览器命名为
    ScalaFTP。
- en: 'The ScalaFTP browser is divided into two main components: the server and the
    client process. The server process will run on the machine whose filesystem we
    want to manipulate. The client will run on our own computer, and comprise of a
    graphical user interface used to navigate the remote filesystem. To keep things
    simple, the protocol that the client and the server will use to communicate will
    not really be FTP, but a custom communication protocol. By choosing the correct
    concurrency libraries to implement different parts of ScalaFTP, we will ensure
    that the complete ScalaFTP implementation fits inside just 500 lines of code.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ScalaFTP 浏览器分为两个主要组件：服务器和客户端进程。服务器进程将在我们想要操作的文件系统所在的机器上运行。客户端将在我们的计算机上运行，包括一个用于导航远程文件系统的图形用户界面。为了简化问题，客户端和服务器之间将使用的通信协议实际上不是
    FTP，而是一个自定义通信协议。通过选择正确的并发库来实现 ScalaFTP 的不同部分，我们将确保完整的 ScalaFTP 实现仅占用 500 行代码。
- en: 'Specifically, the ScalaFTP browser will implement the following features:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，ScalaFTP 浏览器将实现以下功能：
- en: Displaying the names of the files and the directories in a remote filesystem,
    and allowing navigation through the directory structure
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示远程文件系统中文件和目录的名称，并允许通过目录结构进行导航
- en: Copying files between directories in a remote filesystem
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在远程文件系统中在不同目录之间复制文件
- en: Deleting files in a remote filesystem
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在远程文件系统中删除文件
- en: 'To implement separate pieces of this functionality, we will divide the ScalaFTP
    server and client programs into layers. The task of the server program is to answer
    to incoming copy and delete requests, and to answer queries about the contents
    of specific directories. To make sure that its view of the filesystem is consistent,
    the server will cache the directory structure of the filesystem. We divide the
    server program into two layers: the filesystem API and the server interface. The
    filesystem API will expose the data model of the server program, and define useful
    utility methods to manipulate the filesystem. The server interface will receive
    requests and send responses back to the client.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一功能的各个部分，我们将 ScalaFTP 服务器和客户端程序划分为多个层次。服务器程序的任务是响应传入的复制和删除请求，以及响应关于特定目录内容的查询。为了确保其对文件系统的视图保持一致，服务器将缓存文件系统的目录结构。我们将服务器程序划分为两个层次：文件系统
    API 和服务器接口。文件系统 API 将暴露服务器程序的数据模型，并定义用于操作文件系统的有用实用方法。服务器接口将接收请求并向客户端发送响应。
- en: Since the server interface will require communicating with the remote client,
    we decide to use the Akka actor framework. Akka comes with remote communication
    facilities, as we learned in [Chapter 8](ch08.html "Chapter 8.  Actors"), *Actors*.
    The contents of the filesystem, that is, its state, will change over time. We
    are therefore interested in choosing proper constructs for data access.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器接口将需要与远程客户端通信，我们决定使用 Akka actor 框架。Akka 内置远程通信功能，正如我们在第 8 章[Actors](ch08.html
    "第 8 章。演员")中学习的那样。文件系统的内容，即其状态，会随时间变化。因此，我们对选择合适的数据访问结构很感兴趣。
- en: 'In the filesystem API, we can use object monitors and locking to synchronize
    access to shared state, but we will avoid these due to the risk of deadlocks.
    We similarly avoid using atomic variables, because they are prone to race conditions.
    We could encapsulate the filesystem state within an actor, but note that this
    can lead to a scalability bottleneck: an actor would serialize all accesses to
    the filesystem state. Therefore, we decide to use the ScalaSTM framework to model
    the filesystem contents. An STM avoids the risk of deadlocks and race conditions,
    and ensures good horizontal scalability, as we learned in [Chapter 7](ch07.html
    "Chapter 7. Software Transactional Memory"), *Software Transactional Memory*.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The task of the client program will be to graphically present the contents of
    the remote filesystem, and communicate with the server. We divide the client program
    into three layers of functionality. The GUI layer will render the contents of
    the remote filesystem and register user requests, such as button clicks. We will
    implement the GUI using the Swing and Rx frameworks, similarly to how we implemented
    the web browser in [Chapter 6](ch06.html "Chapter 6. Concurrent Programming with
    Reactive Extensions"), *Concurrent Programming with Reactive Extensions*. The
    client API will replicate the server interface on the client side and communicate
    with the server. We will use Akka to communicate with the server, but expose the
    results of remote operations as futures. Finally, the client logic will be a gluing
    layer, which binds the GUI and the client API together.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture of the ScalaFTP browser is illustrated in the following diagram,
    in which we indicate which concurrency libraries will be used by separate layers.
    The dashed line represents the communication path between the client and the server:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting it all together - a remote file browser](img/image_09_001.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: We now start by implementing the ScalaFTP server, relying on the bottom-up design
    approach. In the following section, we will describe the internals of the filesystem
    API.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Modeling the filesystem
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Traditional Building Blocks of Concurrency"),
    *Traditional Building Blocks of Concurrency*, we used atomic variables and concurrent
    collections to implement a non-blocking, thread-safe filesystem API, which allowed
    copying files and retrieving snapshots of the filesystem. In this section, we
    repeat this task using STM. We will see that it is much intuitive and less error-prone
    to use STM.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining the different states that a file can be in. As in [Chapter
    3](ch03.html "Chapter 3. Traditional Building Blocks of Concurrency"), *Traditional
    Building Blocks of Concurrency*, the file can be currently created, in the idle
    state, being copied, or being deleted. We model this with a sealed `State` trait,
    and its four cases:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A file can only be deleted if it is in the idle state, and it can only be copied
    if it is in the idle state or in the copied state. Since a file can be copied
    to multiple destinations at a time, the `Copying` state encodes how many copies
    are currently under way. We add the methods `inc` and `dec` to the `State` trait,
    which return a new state with one more or one fewer copy, respectively. For example,
    the implementation of `inc` and `dec` for the `Copying` state is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在文件处于空闲状态时才能删除它，只有当它处于空闲状态或已复制状态时才能复制它。由于文件可以同时复制到多个目的地，`Copying` 状态编码了当前正在进行多少次复制。我们向
    `State` 特质添加了 `inc` 和 `dec` 方法，分别返回一个状态增加或减少一个复制的新的状态。例如，`Copying` 状态的 `inc` 和
    `dec` 的实现如下：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Similar to the `File` class in the `java.io` package, we represent both the
    files and directories with the same entity, and refer to them more generally as
    files. Each file is represented by the `FileInfo` class that encodes the path,
    its name, its parent directory and the date of the last modification to the file,
    a Boolean value denoting if the file is a directory, the size of the file, and
    its `State` object. The `FileInfo` class is immutable, and updating the state
    of the file will require creating a fresh `FileInfo` object:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `java.io` 包中的 `File` 类类似，我们使用相同的实体来表示文件和目录，并更一般地称它们为文件。每个文件由 `FileInfo` 类表示，该类编码了路径、其名称、其父目录以及文件最后修改的日期、一个表示文件是否为目录的布尔值、文件的大小以及其
    `State` 对象。`FileInfo` 类是不可变的，更新文件的状态将需要创建一个新的 `FileInfo` 对象：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We separately define the factory methods `apply` and `creating` that take a
    `File` object and return a `FileInfo` object in the `Idle` or `Created` state,
    respectively.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分别定义了 `apply` 和 `creating` 工厂方法，它们分别接受一个 `File` 对象并返回一个处于 `Idle` 或 `Created`
    状态的 `FileInfo` 对象。
- en: 'Depending on where the server is started, the root of the ScalaFTP directory
    structure is a different subdirectory in the actual filesystem. A `FileSystem`
    object tracks the files in the given `rootpath` directory, using a transactional
    map called `files`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器启动的位置不同，ScalaFTP 目录结构的根在实际的文件系统中是不同的子目录。`FileSystem` 对象跟踪给定 `rootpath` 目录中的文件，使用一个名为
    `files` 的事务性映射：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We introduce a separate `init` method to initialize the `FileSystem` object.
    The `init` method starts a transaction, clears the contents of the `files` map,
    and traverses the files and directories under `rootpath` using the Apache Commons
    IO library. For each file and directory, the `init` method creates a `FileInfo`
    object and adds it to the `files` map, using its path as the key:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个单独的 `init` 方法来初始化 `FileSystem` 对象。`init` 方法启动一个事务，清除 `files` 映射的内容，并使用
    Apache Commons IO 库遍历 `rootpath` 下的文件和目录。对于每个文件和目录，`init` 方法创建一个 `FileInfo` 对象并将其添加到
    `files` 映射中，使用其路径作为键：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Recall that the ScalaFTP browser must display the contents of the remote filesystem.
    To enable directory queries, we first add the `getFileList` method to the `FileSystem`
    class, which retrieves the files in the specified `dir` directory. The `getFileList`
    method starts a transaction and filters the files whose direct parent is equal
    to `dir`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，ScalaFTP 浏览器必须显示远程文件系统的内容。为了启用目录查询，我们首先将 `getFileList` 方法添加到 `FileSystem`
    类中，该方法检索指定 `dir` 目录中的文件。`getFileList` 方法启动一个事务并过滤出直接父级等于 `dir` 的文件：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We implement the copying logic in the filesystem API with the `copyFile` method.
    This method takes a path to the `src` source file and the `dest` destination file,
    and starts a transaction. After checking whether the `dest` destination file exists
    or not, the `copyFile` method inspects the state of the source file entry, and
    fails unless the state is `Idle` or `Copying`. It then calls `inc` to create a
    new state with the increased copy count, and updates the source file entry in
    the `files` map with the new state. Similarly, the `copyFile` method creates a
    new entry for the destination file in the `files` map. Finally, the `copyFile`
    method calls the `afterCommit` handler to physically copy the file to disk after
    the transaction completes. Recall that it is not legal to execute side-effecting
    operations from within the transaction body, so the private `copyOnDisk` method
    is called only after the transaction commits:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `copyOnDisk` method calls the `copyFile` method on the `FileUtils` class
    from the Apache Commons IO library. After the file transfer completes, the `copyOnDisk`
    method starts another transaction, in which it decreases the copy count of the
    source file and sets the state of the destination file to `Idle`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `deleteFile` method deletes a file in a similar way. It changes the file
    state to `Deleted`, deletes the file, and starts another transaction to remove
    the file entry:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Modeling the server data model with the STM allows for the seamless addition
    of different concurrent computations to the server program. In the following section,
    we will implement a server actor that uses the server API to execute filesystem
    operations.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use STM to model concurrently accessible data, as an STM works transparently
    with most concurrency frameworks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Having completed the filesystem API, we now proceed to the server interface
    layer of the ScalaFTP browser.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The server interface
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The server interface comprises of a single actor called `FTPServerActor`. This
    actor will receive client requests and respond to them serially. If it turns out
    that the server actor is the sequential bottleneck of the system, we can simply
    add additional server interface actors to improve horizontal scalability.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining the different types of messages that the server actor
    can receive. We follow the convention of defining them inside the companion object
    of the `FTPServerActor` class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The actor template of the server actor takes a `FileSystem` object as a parameter.
    It reacts to the `GetFileList`, `CopyFile`, and `DeleteFile` messages by calling
    the appropriate methods from the filesystem API:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When the server receives a `GetFileList` message, it calls the `getFileList`
    method with the specified `dir` directory, and sends a sequence collection with
    the `FileInfo` objects back to the client. Since `FileInfo` is a case class, it
    extends the `Serializable` interface, and its instances can be sent over the network.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: When the server receives a `CopyFile` or `DeleteFile` message, it calls the
    appropriate filesystem method asynchronously. The methods in the filesystem API
    throw exceptions when something goes wrong, so we need to wrap calls to them in
    `Try` objects. After the asynchronous file operations complete, the resulting
    `Try` objects are piped back as messages to the sender actor, using the Akka `pipeTo`
    method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the ScalaFTP server, we need to instantiate and initialize a `FileSystem`
    object and start the server actor. We parse the network port command-line argument,
    and use it to create an actor system that is capable of remote communication.
    For this, we use the `remotingSystem` factory method that we introduced in [Chapter
    8](ch08.html "Chapter 8.  Actors"), *Actors*. The remoting actor system then creates
    an instance of the `FTPServerActor`. This is shown in the following program:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The ScalaFTP server actor can run inside the same process as the client application,
    in another process in the same machine, or on a different machine connected with
    a network. The advantage of the actor model is that we usually need not worry
    about where the actor runs until we integrate it into the entire application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you need to implement a distributed application that runs on different
    machines, use an actor framework.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Our server program is now complete, and we can run it with the `run` command
    from SBT. We set the actor system to use the port `12345`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the following section, we will implement the file navigation API for the
    ScalaFTP client, which will communicate with the server interface over the network.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Client navigation API
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The client API exposes the server interfaces to the client program through asynchronous
    methods that return future objects. Unlike the server's filesystem API, which
    runs locally, the client API methods execute remote network requests. Futures
    are a natural way to model latency in the client API methods, and to avoid blocking
    during network requests.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally, the client API maintains an actor instance that communicates with
    the server actor. The client actor does not know the actor reference of the server
    actor when it is created. For this reason, the client actor starts in an **unconnected**
    state. When it receives the `Start` message with the URL of the server actor system,
    the client constructs an actor path to the server actor, sends out an `Identify`
    message, and switches to the **connecting** state. If the actor system is able
    to find the server actor, the client actor eventually receives the `ActorIdentity`
    message with the server actor reference. In this case, the client actor switches
    to the **connected** state, and is able to forward commands to the server. Otherwise,
    the connection fails and the client actor reverts to the unconnected state. The
    state diagram of the client actor is shown in the following figure:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Client navigation API](img/image_09_002.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: 'We define the `Start` message in the client actor''s companion object:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We then define the `FTPClientActor` class and give it an implicit `Timeout`
    parameter. The `Timeout` parameter will be used later in the Akka ask pattern,
    when forwarding client requests to the server actor. The stub of the `FTPClientActor`
    class is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Before defining the `receive` method, we define behaviors corresponding to
    different actor states. Once the client actor in the unconnected state receives
    the `Start` message with the host string, it constructs an actor path to the server
    and creates an actor selection object. The client actor then sends the `Identify`
    message to the actor selection, and switches its behavior to `connecting`. This
    is shown in the following behavior method, named `unconnected`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `connecting` method creates a behavior given an actor reference to the
    sender of the `Start` message. We call this actor reference `clientApp`, because
    the ScalaFTP client application will send the `Start` message to the client actor.
    Once the client actor receives an `ActorIdentity` message with the `ref` reference
    to the server actor, it can send `true` back to the `clientApp` reference, indicating
    that the connection was successful. In this case, the client actor switches to
    the `connected` behavior. Otherwise, if the client actor receives an `ActorIdentity`
    message without the server reference, the client actor sends `false` back to the
    application and reverts to the `unconnected` state:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `connected` state uses the `serverActor` server actor reference to forward
    the `Command` messages. To do so, the client actor uses the Akka ask pattern,
    which returns a future object with the server''s response. The contents of the
    future are piped back to the original sender of the `Command` message. In this
    way, the client actor serves as an intermediary between the application, which
    is the sender, and the server actor. The `connected` method is shown in the following
    code snippet:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, the `receive` method returns the `unconnected` behavior, in which
    the client actor is created:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Having implemented the client actor, we can proceed to the client API layer.
    We model it as a trait with a `connected` value, the concrete methods `getFileList`,
    `copyFile`, and `deleteFile`, and an abstract `host` method. The client API creates
    a private remoting actor system and a client actor. It then instantiates the `connected`
    future that computes the connection status by sending a `Start` message to the
    client actor. The methods `getFileList`, `copyFile`, and `deleteFile` are similar.
    They use the ask pattern on the client actor to obtain a future with the response.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that the actor messages are not typed, and the ask pattern returns a
    `Future[Any]` object. For this reason, each method in the client API uses the
    `mapTo` future combinator to restore the type of the message:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that the client API does not expose the fact that it uses actors for remote
    communication. Moreover, the client API is similar to the server API, but the
    return types of the methods are futures instead of normal values. Futures encode
    the latency of a method without exposing the cause for the latency, so we often
    find them at the boundaries between different APIs. We can internally replace
    the actor communication between the client and the server with the remote `Observable`
    objects, but that would not change the client API.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a concurrent application, use futures at the boundaries of the layers to
    express latency.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can programmatically communicate with the remote ScalaFTP server,
    we turn our attention to the user interface of the client program.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The client user interface
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we create the static user interface for the ScalaFTP client
    program. This graphical frontend will make our ScalaFTP application easy and intuitive
    to use. We will rely on the Scala Swing library to implement the UI.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'We will implement the client interface in an abstract `FTPClientFrame` class:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the remainder of this section, we augment the `FTPClientFrame` class with
    different UI components. These UI components will enable the end user to interact
    with the client application, and ultimately with the remote server. Therefore,
    we will implement the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: A menu bar with common application options
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A status bar that displays various user notifications, such as the connection
    state, status of the last requested operation, and various error messages
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of file panes that display the path to a specific directory in the filesystem,
    along with its contents, and buttons that start a copy or delete operation
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After we are done, the ScalaFTP client program will look like the following
    screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![The client user interface](img/image_09_003.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: We start by implementing the menu bar. When creating Swing components in our
    UI, we can instantiate an anonymous class that extends a `Menu` or `MenuBar` class,
    and assign it to a local variable. However, using an anonymous class does not
    allow access to its custom members. If the anonymous UI component class contains
    nested components, we are not able to refer to them. Therefore, we will use nested
    singleton objects to instantiate UI components, as doing this allows us to refer
    to the object's nested components.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we create the `menu` singleton object that extends
    the `MenuBar` class. We create the `file` and the `help` menu, with the `exit`
    and `about` menu items, respectively, and take care to add each `Menu` component
    to the `contents` collection of the enclosing component:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Similarly, we implement the `status` object by extending the `BorderPanel`
    class. The `BorderPanel` components are used to hold other nested components:
    in our case, two nested `Label` objects. The anonymous `Label` object always contains
    the static `Status:` text, while the named `Label` object contains arbitrary status
    messages. We place the anonymous `Label` object to the left, and the `Label` object
    with the status messages in the center. This is shown in the following code snippet:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we implement a custom `FilePane` component that displays the contents
    of a directory in the remote filesystem. We will have two `FilePane` instances
    in the client program, so we declare a custom `FilePane` class, which itself extends
    the `BorderPanel` component type:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We hierarchically decompose the `FilePane` class into three parts: the `pathBar`
    component that displays the path to the current directory, the `scrollPane` component
    that allows scrolling through the contents of the current directory, and the `buttons`
    component that contains the copy and delete buttons. In the following code snippet,
    we add a non-editable text field with the current path, and an `upButton` component
    that is used to navigate up the file hierarchy:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `scrollPane` component contains a `Table` object named `fileTable`. The
    `fileTable` object will contain the columns named `Filename`, `Size`, and `Date
    modified`, and each table row will contain a file or a subdirectory within the
    current working directory. To prevent the user from modifying filenames, sizes,
    or modification dates, we install a custom `TableModel` object that disallows
    editing in every row and column. The complete implementation of the `scrollPane`
    component is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `buttons` singleton object is a `GridPanel` component with one row and
    two columns. Each column contains a single button, as shown in the following code
    snippet:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We then place these custom components inside the `FilePane` component:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we add the `parent` directory field and the list of the files in the
    current directory, named `dirFiles`, into the `FilePane` class, as well as a few
    convenience methods to more easily access deeply nested UI components:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Recall that we need one `FilePane` instance on the left-hand side of the client
    program, and another one on the right. We declare the `files` singleton object
    inside the `FTPClientFrame` class to hold the two `FilePane` instances, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we need to place the `menu`, `files`, and `status` components at the
    top, center, and bottom of the client program:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can already run the client program at this point, and try to interact with
    it. Unfortunately, the client program does not do anything yet. Clicking on the
    `FilePane` component, the buttons, or the menu items currently does not have any
    effect, as we have not yet defined callbacks for various UI actions. In the following
    section, we will use Rx to complete the functionality of the client application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the client logic
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now ready to add some life to the ScalaFTP client program. We will define
    the logic layer in the `FTPClientLogic` trait. We only want to allow mixing in
    the `FTPClientLogic` trait with classes that extend both the `FTPClientFrame`
    class and the `FTPClientApi` trait, as this allows the logic layer to refer to
    both UI components and use the client API. Therefore, we give this trait the self-type
    `FTPClientFrame` class with `FTPClientApi`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Before we begin, recall that the Swing components can only be modified from
    the event-dispatching thread. Similar to how we ensured this using the `swingScheduler`
    object in [Chapter 6](ch06.html "Chapter 6. Concurrent Programming with Reactive
    Extensions"), *Concurrent Programming with Reactive Extensions*, we now introduce
    the `swing` method, which takes a block of code and schedules it for execution
    on the Swing library''s event-dispatching thread:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Throughout this section, we will rely on the `swing` method in order to ensure
    that the effect of asynchronous computations occur only on the Swing event-dispatching
    thread.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Swing toolkit permits modifying UI components only from the event-dispatching
    thread, but does not ensure this restriction at compile time, and can unexpectedly
    fail during runtime.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by relating the connection status to the user interface. Recall that
    we introduced the `connected` future as part of the client API. Depending on the
    result of the `connected` future, we either modify the `text` value of the status
    label to display an error message, or report that the client program has successfully
    connected to the server. In the latter case, we call the `refreshPane` method
    to update the contents of the `FilePane` components that we will look at shortly.
    The following code snippet shows the `onComplete` callback:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There are two steps involved in updating the `FilePane` component. First, we
    need to get the contents of the remote directory from the server. Second, once
    these contents arrive, we need to refresh the `Table` object in the `FilePane`
    component. In the following code, we call the `getFileList` method from the client
    API, and refresh the `Table` object with the `updatePane` method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `updatePane` method takes the `dir` directory name and the `files` list,
    and uses them to update the `FilePane` component `p`. It extracts the `DefaultTableModel`
    object, and clears its previous contents by setting the row count to `0`. It then
    updates the `parent` field in the `FilePane` object to the parent of the `dir`
    directory.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it stores the `files` list into the `dirFiles` field, and adds a row
    for each entry:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding method, we relied on the `toRow` method to convert the `FileInfo`
    object into an array of `String` objects, which the `Table` component works with:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So far, so good! Our client program is able to connect to the server and show
    the contents of the root directory. Next, we need to implement the UI logic that
    allows navigating through the remote filesystem.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'When dealing with UI events in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Programming with Reactive Extensions"), *Concurrent Programming with Reactive
    Extensions*, we augmented our UI components with `Observable` objects. Recall
    that we added the `clicks` and `texts` methods in order to process events from
    the `Button` and `TextField` components. In the following code, we augment the
    `Table` component with the `rowDoubleClicks` method, which returns an `Observable`
    object with the indices of the rows that have been double-clicked on:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To navigate through the remote filesystem, users need to click on the `FilePane`
    and `upButton` objects. We need to set up this functionality once for each pane,
    so we define the `setupPane` method for this purpose:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The first step when reacting to the clicks on the `FilePane` component is mapping
    each user double-click to the name of the file or directory that has been clicked
    on. Then, if the double-clicked file is a directory, we update the current `filePath`
    method, and call the `refreshPane` method:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Similarly, when the user clicks on the `upButton` component, we call the `refreshPane`
    method to navigate to the parent directory:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Navigating through the remote filesystem is informative, but we also want to
    be able to copy and delete the remote files. This requires reacting to UI button
    clicks, each of which needs to be mapped to the correct, currently selected file.
    The `rowActions` method produces an event stream with the files that were selected
    at the time, at the point when a button was clicked:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Clicking on the copy button will copy the selected file to the directory selected
    in the opposite pane. We use the `rowActions` method to map the directory on the
    opposite pane, and call the `copyFile` method from the client API. Recall that
    the `copyFile` method returns a future, so we need to call the `onComplete` method
    to process its result asynchronously:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We use the `rowActions` method in a similar way, in order to react to clicks
    on the delete button. Finally, we call the `setupPane` method once for each pane:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Our remote file browser is now fully functional. To test it, we open two separate
    instances of the terminal, and run SBT in our project directory from both the
    terminals. We first run the server program:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'By making sure that the server is running on port `12345`, we can run the client
    from the second terminal as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, try copying some of our project files between different directories. If
    you've also implemented the delete functionality, make sure that you back up the
    project files before deleting anything, just in case. It's not always a good idea
    to test experimental file-handling utilities on our source code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Improving the remote file browser
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you successfully ran both the ScalaFTP server, client programs, and copied
    files around, you might have noticed that, if you delete a file on the disk from
    an external application, such as your source-code editor, the changes will not
    be reflected in the ScalaFTP server program. The reason for this is that the server
    actor does not monitor the filesystem for changes, and the server filesystem layer
    is not updated when we delete the file.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'To account for filesystem changes external to the ScalaFTP server program,
    we need to monitor the filesystem for changes. This sounds like an ideal case
    for event streams. Recall that we already did this in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Programming with Reactive Extensions"), *Concurrent Programming with Reactive
    Extensions*, when we defined the `modified` method to track file modifications.
    This time, we define the `FileCreated`, `FileDeleted`, and `FileModified` types
    to denote three different kinds of filesystem events:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'By implementing the additional methods in the `FileAlterationListener` interface,
    we ensure that the resulting `Observable` object produces any one of the three
    event types. In the following code snippet, we show the relevant part of the `fileSystemEvents`
    method that produces an `Observable[FileEvent]` object with the filesystem events:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now that we have an event stream of file events, we can easily modify the filesystem
    model. We subscribe to the file event stream, and start single-operation transactions
    to update the `fileSystem` transactional map:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now, you can run the server and the client again, and experiment with either
    deleting or copying files in your editor after the server has started. You will
    notice that the filesystem changes are detected on the server, and eventually
    shown when the client is refreshed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Note that this example was chosen to illustrate how all the different concurrency
    libraries described in this book work together. However, there is no need to use
    all of these concurrency libraries in every program. In many situations, we only
    need a few different concurrency abstractions. Depending on your programming task,
    you should decide which ones are the best fit.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Never over-engineer your concurrent program. Only use those concurrency libraries
    that help you solve your specific programming task.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Having studied how to combine different concurrency libraries in a larger application,
    and having caught a glimpse of how to pick the correct concurrency library, we
    turn our attention to another aspect of dealing with concurrency, namely, debugging
    concurrent programs.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Debugging concurrent programs
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrent programming is much harder than sequential programming. There are
    multiple reasons for this. First, the details of the memory model are much more
    important in concurrent programming, resulting in increased programming complexity.
    Even on a platform with a well-defined memory model, such as the JVM, the programmer
    must take care to use proper memory access primitives in order to avoid data races.
    Then, it is harder to track the execution of a multithreaded program, simply because
    there are multiple executions proceeding simultaneously. Language debuggers are
    still focused on tracking the execution of a single thread at a time. Deadlocks
    and inherent nondeterminism are another source of bugs, neither of which is common
    in sequential programs. To make things worse, all these issues only have to do
    with ensuring the correctness of a concurrent program. Ensuring improved throughput
    and performance opens a separate set of problems, and is often harder than it
    sounds. Generally, a lot of effort is required to ensure that a concurrent program
    really runs faster, and performance debugging is an art of its own.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we survey some of the typical causes of errors in concurrent
    programs, and inspect different methods of dealing with them. We start with the
    simplest form of concurrency bugs, which are revealed by a lack of progress in
    the system.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Deadlocks and lack of progress
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite the scariness typically associated with the term deadlock, when it comes
    to debugging concurrent programs, deadlocks are one of the more benevolent forms
    of concurrency bugs you will encounter. The reason for this is that deadlocks
    are easy to track down and analyze. In this section, we study how to identify
    and resolve a deadlock in a concurrent program.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin, we will make sure that SBT starts the example programs in
    a separate JVM process. To do this, we enter the following command into the SBT
    interactive shell:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In [Chapter 2](ch02.html "Chapter 2. Concurrency on the JVM and the Java Memory
    Model"), *Concurrency on the JVM and the Java Memory Model*, we discussed at length
    what deadlocks are and why they occur. Here, we recall the bank account example
    introduced in that chapter, which is a canonical example of a deadlock. The bank
    account example consisted of an `Account` class and the `send` method, which locks
    two `Account` objects, and transfers a certain amount of money between them:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A deadlock nondeterministically occurs when we simultaneously make an attempt
    to transfer money from account `a` to account `b`, and vice versa, as shown in
    the following code snippet:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding snippet, we are using the `thread` method for the thread creation
    from [Chapter 2](ch02.html "Chapter 2. Concurrency on the JVM and the Java Memory
    Model"), *Concurrency on the JVM and the Java Memory Model*. This program never
    completes, as the `t1` and `t2` threads get suspended in the deadlock state. In
    a larger program, this effect manifests itself as a lack of response. When a concurrent
    program fails to produce a result or an end, this is a good indication that part
    of it is in the deadlock state.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the most difficult part in debugging a deadlock is localizing it. While
    this is easy to determine in our simple example, it is much harder in a larger
    application. However, a defining feature of a deadlock is the lack of any progress,
    and we can use this to our advantage to determine its cause; we simply need to
    find the threads that are in a blocked state, and determine their stack-traces.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java VisualVM tool, which comes bundled with newer JDK distributions, is
    the simplest way to determine the state of the running Scala and Java applications.
    Without exiting our deadlocked program, we run the `jvisualvm` program from another
    terminal instance as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Once run, the Java VisualVM application shows all the active JVM processes
    on the current machine. In the following screenshot, the Java VisualVM application
    shows us the SBT process, our deadlock example program, and VisualVM itself, as
    the running instances:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![Deadlocks and lack of progress](img/image_09_004.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: 'After clicking on the example process, we get the report shown in the following
    screenshot:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![Deadlocks and lack of progress](img/image_09_005.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows that there are multiple threads running inside
    the example process. Most of these threads are part of the virtual machine runtime,
    and not under the direct control of the programmer. Other threads, such as **main**,
    **Thread-0**, and **Thread-1** are created by our program.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: To determine the cause of the deadlock, we need to inspect the threads in the
    `BLOCKED` state. By examining their stack-traces, we can determine the cycle that
    is causing the deadlock. In this case, Java VisualVM was smart enough to automatically
    determine the cause of the deadlock, and displays the deadlocked threads with
    the red bar.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking on the **Thread Dump** button, Java VisualVM displays the stack
    traces of all the threads, as shown in the following screenshot:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![Deadlocks and lack of progress](img/image_09_006.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: The stack traces in the preceding screenshot tell us exactly where in the program
    the threads are blocked, and why. Both **Thread-0** and **Thread-1** threads are
    suspended in line 15 of the `Debugging.scala` file. Inspecting these lines of
    code in our editor reveals that both the threads are blocked on the nested `synchronized`
    statement. We now know that the cause of the deadlock is the inverted locking
    order in the `send` method.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: We've already discussed how to deal with this type of a deadlock in [Chapter
    2](ch02.html "Chapter 2. Concurrency on the JVM and the Java Memory Model"), *Concurrency
    on the JVM and the Java Memory Model*. Enforcing a locking order in the `send`
    method is a textbook example of dealing with deadlocks, and is easy to ensure
    by assigning unique identifiers to different locks.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, we are not able to enforce the locking order to avoid deadlocks.
    For example, in [Chapter 3](ch03.html "Chapter 3. Traditional Building Blocks
    of Concurrency"), *Traditional Building Blocks of Concurrency*, we learned that
    the lazy values initialization implicitly calls the `synchronized` statement without
    our control. There, we eluded deadlocks by avoiding the explicit `synchronized`
    statements on the object enclosing the lazy value. Another way of preventing deadlocks
    is to avoid blocking when a resource is not available. In [Chapter 3](ch03.html
    "Chapter 3. Traditional Building Blocks of Concurrency"), *Traditional Building
    Blocks of Concurrency*, we learned that custom locks can return an error value,
    letting the rest of the program decide how to proceed if a lock is not available.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Besides deadlocks, there are other kinds of concurrency bugs that are associated
    with a lack of progress. We've already seen examples of **starvation**, in which
    a concurrent computation is denied access to the required resources. In [Chapter
    4](ch04.html "Chapter 4.  Asynchronous Programming with Futures and Promises"),
    *Asynchronous Programming with Futures and Promises*, we started many futures
    simultaneously, and suspended them by calling the `sleep` method. As a result,
    the thread-pool underlying the `ExecutionContext` object became exhausted, and
    no additional futures could execute until the `sleep` method returned.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: In a **livelock**, different concurrent computations are not suspended, and
    constantly change their state, but are unable to make progress. A livelock is
    akin to the situation in which two people approach each other on the street, and
    constantly try to move to the opposite side in order to allow the other person
    to pass. As a result, neither person moves on, and they constantly move from one
    side to the other. What is common to these kinds of errors is that the system
    makes no or very little progress, making them easy to identify.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Looking for a deadlock is like hunting for a dead animal. Since it implies no
    progress, a deadlock is tracked down more easily than other kinds of concurrency
    bugs. In the following section, we will study a more malevolent class of concurrency
    errors that manifest themselves through incorrect program outputs.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Debugging incorrect program outputs
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we study a broader range of concurrency bugs that manifest
    themselves as incorrect outputs of the program. Generally, these kinds of errors
    are harder to track, because their effects become apparent long after the actual
    error took place. A real-world example of such an error is a piece of broken glass
    lying on the road. You don't see the glass when you drive your car, and accidentally
    run over it. By the time your tire runs flat and you realize what happened, it
    is difficult to figure out where exactly along the road the glass was.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: There are two main ways in which an error can appear. First, the concurrent
    program can consistently produce the same erroneous outputs. When this happens,
    we can consider ourselves lucky, as we are able to consistently reproduce the
    error to study it. Conversely, the incorrect output might appear only occasionally,
    in some executions of the program. This is a much less desired situation. A buggy
    concurrent program might exhibit incorrect behavior only occasionally due to its
    inherent nondeterminism. We will look at both deterministic and nondeterministic
    errors in the rest of the section.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this section will be to implement the `fold` method on futures.
    Given a sequence of future objects, a zero value, and the `folding` operator,
    the `fold` method will return a future object with the `folding` operator that
    is applied between all the values. We will require the `folding` operator to be
    commutative, associative, and without side effects. The `fold` method will closely
    correspond to the `foldLeft` method on collections. The signature of the `fold`
    method on futures will be as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'One use case for the `fold` method is to compute the sum of the values in many
    different future objects, which cannot be done directly with the `foldLeft` method
    on collections. This is illustrated in the following code snippet:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We will implement the `fold` method in two steps. First, we will accumulate
    the values from all the values in the `fs` sequence by applying the `op` operator
    on them. Accumulating the values will give us the accumulation value of the resulting
    future. Then, after all the futures complete, we will complete the resulting future
    with the accumulation value.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by implementing several basic concurrency abstractions that will help
    us implement the `fold` method. A **concurrent accumulator** is a concurrency
    facility that allows you to keep track of an accumulation of values. Here, the
    values can be integers, and the accumulation can be their sum. A concurrent accumulator
    comes with the `add` method that is used to add new values, and the `apply` method
    that is used to obtain the current state of the accumulation. We present the simplest
    possible lock-free implementation of a concurrent accumulator, which uses atomic
    variables from [Chapter 3](ch03.html "Chapter 3. Traditional Building Blocks of
    Concurrency"), *Traditional Building Blocks of Concurrency*. The `Accumulator`
    class takes the type `T` of the accumulation, a `z` initial value, and an `op`
    reduction operator, and is shown in the following code snippet:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `Accumulator` implementation has a private atomic variable, named `value`,
    initialized with the `z` value, and is used to track the value of the accumulation.
    The `apply` method is easy to implement; we simply call the linearizable `get`
    method to obtain the current accumulation value. The `add` method must use the
    `compareAndSet` operation to atomically update the accumulation. Here, we read
    the `ov` current value of the atomic variable, call the `op` operator to compute
    the new `nv` accumulation value, and, finally, call the `compareAndSet` operation
    to replace the old `ov` accumulation value with the new `nv` value. If the `compareAndSet`
    operation returns `false`, then the accumulation was modified, as it was previously
    read, and the tail-recursive `add` operation must be retried. We studied this
    technique at length in [Chapter 3](ch03.html "Chapter 3. Traditional Building
    Blocks of Concurrency"), *Traditional Building Blocks of Concurrency*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Note that, because of the retries, the `op` operator can be invoked multiple
    times with the same `v` argument. Therefore, our lock-free concurrent accumulator
    implementation only works correctly with a reduction operator that is free from
    side effects.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need a facility that allows different futures to synchronize.
    A **countdown latch** is a synchronization primitive that performs a specific
    action once a specified number of threads agree that the action can be performed.
    Our `CountDownLatch` class takes the number of threads `n`, and an `action` block.
    The latch keeps an atomic integer variable, named `left`, with the current countdown
    value, and defines a `count` method, which decreases the value of the `left` atomic
    variable. After `n` calls of the `count` method, the `action` block is invoked
    once. This is shown in the following code snippet:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We now have all the prerequisites for implementing the `fold` method. This
    method needs to return a future object, so we start by instantiating a promise
    object. The promise will enable us to return the future object corresponding to
    the promise. We have seen this pattern many times in [Chapter 4](ch04.html "Chapter 4. 
    Asynchronous Programming with Futures and Promises"), *Asynchronous Programming
    with Futures and Promises*. Next, we need some way of combining the values from
    the different futures, so we instantiate an `Accumulator` object with the initial
    `z` value and the `op` reduction operator. We can complete the promise with the
    value of the accumulator only after all the futures complete, so we create a countdown
    latch with the countdown value set to the number of the futures. The action associated
    with the countdown latch completes the promise with the value of the accumulator,
    and we decide to use the `trySuccess` method for this purpose. Finally, we need
    to install callbacks on all the futures, which update the accumulator, and then
    call the `count` method on the latch. The complete implementation of the `fold`
    method is shown in the following code snippet:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you paid close attention, you might have noticed that we deliberately introduced
    an error somewhere in the `fold` implementation. Don''t worry if you did not notice
    this error yet, as we will now analyze how the error manifests itself, and how
    to identify it. To test the `fold` method, we run the following example program:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: On our machine, running this program prints the correct value `10`. We already
    feel confident that we implemented the program correctly, but we run the program
    again, just to be sure. This time, however, the program outputs the value `7`.
    It turns out that we have a bug in our implementation of the `fold` method. Even
    worse, the bug manifests itself nondeterministically!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: In sequential programming, the normal response would be to use the debugger,
    and proceed stepwise through the program, until we reach the buggy behavior. In
    concurrent programming, this approach often does not help. By tracking the progress
    of one thread in the debugger, we are arbitrarily delaying it, and changing the
    execution schedule of the program. The bug appears nondeterministically, so it
    might not appear when we run the program in the debugger.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of going forward through the program, to find the culprit, we work
    our way backwards through the code. The future is completed with the incorrect
    value, meaning that some thread must have inserted the incorrect value into the
    corresponding promise. We should insert a breakpoint at the promise completion
    point and observe what happens. To keep things simple, we avoid using the debugger,
    and insert a simple `println` statement to track the value with which the promise
    is completed:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Running the program again gives the following output:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This reveals a surprising fact: the promise is, in fact, completed twice. The
    first time, some thread uses the value `8` of the accumulator, and the second
    time, another thread uses the value `10`. This also means that the `action` block
    of the countdown latch was called twice, so we need to find out why. We therefore
    modify the `count` method in order to track when the `action` block is called:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The program output now shows the following content:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It appears that the `action` block is called not only on the last decrement,
    but also on one before the last. This is because the `decrementAndGet` method
    first decrements the atomic integer, and then returns its value, rather than the
    other way around. The way to fix this is to either call the `getAndDecrement`
    method, or change the `if` statement. We reimplement the `count` method as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Note that, if we had used the `success` method in place of `trySuccess`, we
    would have learned about the error much earlier. Let''s change the implementation
    of the `action` block in the `fold` method to use the `success` method:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Running the program with this change, and the previously incorrect `count`
    method, results in the following exception:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This is much better. The output of the program is incorrect, but the exception
    consistently occurs each time that the program is run. Along with the cause of
    the error, we consistently get a full stack-trace to quickly determine where the
    error has occurred. We say that the error occurs deterministically.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Recall that, in [Chapter 4](ch04.html "Chapter 4.  Asynchronous Programming
    with Futures and Promises"), *Asynchronous Programming with Futures and Promises*,
    we used the `tryComplete` method to implement the `or` combinator on futures.
    This combinator was inherently nondeterministic, so we were forced to use the
    `tryComplete` method. However, there is no need to use any of the `tryXYZ` methods
    in the `fold` implementation, as the `fold` method should always return a future
    with the same result. Wherever possible, you should use the `complete`, `success`,
    and `failure` methods in place of the `tryComplete`, `trySuccess`, and `tryFailure`
    methods. More generally, always strive for deterministic semantics, unless the
    program itself is inherently nondeterministic.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Program defensively: check for consistency violations often, prefer determinism,
    and fail at an early stage. This simplifies the debugging process when program
    errors arise.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we turn to a different correctness aspect in concurrent
    programs, namely, testing their performance.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Performance debugging
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to performance debugging, the field is virtually endless. A separate
    book on the subject would barely scratch the surface. The goal of this section
    is to show you two basic examples that will teach you the basics of analyzing
    and resolving performance problems in concurrent Scala programs.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, processor clock rates have reached a limit, and processor vendors
    have struggled to improve single processor performance. As a consequence, multicore
    processors have overwhelmed the consumer market. Their main goal is to offer increased
    performance by increasing parallelism. Ultimately, the goal of concurrent and
    parallel computing is to increase the program performance.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways in which program performance can be improved. The first is
    through optimizing the program, so that its sequential instance runs as fast as
    possible. The second approach is to run parts of the program in parallel. In concurrent
    and parallel computing, both approaches are key to achieving optimal performance.
    It does not make sense to parallelize a program that is much slower than the optimal
    sequential program.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we will study both, how to optimize, and how to parallelize a concurrent
    program. We will start with a single-threaded version of the program that uses
    a concurrent accumulator, and ensure that it runs efficiently. Then, we will ensure
    that the program is also scalable, that is, adding additional processors makes
    it faster.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: The first step in debugging the performance of a parallel program is to measure
    its running time. As stated in [Chapter 5](ch05.html "Chapter 5. Data-Parallel
    Collections"), *Data-Parallel Collections*, benchmarking the program performance
    is the only principled way of knowing how fast the program is and finding its
    bottlenecks. This task can be complicated on the JVM, due to effects such as garbage
    collection, JIT compilation, and adaptive optimizations.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the Scala ecosystem comes with a tool called ScalaMeter, which
    is designed to easily test the performance of both Scala and Java programs. The
    ScalaMeter tool can be used in two ways. First, ScalaMeter allows defining performance
    regression tests, which are essentially unit tests for performance. Second, ScalaMeter
    allows inline benchmarking that is used to benchmark parts of the running application.
    In this section, we will keep things simple, and only use ScalaMeter''s inline
    benchmarking feature. We add the following line to our `build.sbt` file:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To use ScalaMeter inside our programs, we need to import the following package:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This package gives us access to the `measure` statement that is used to measure
    various performance metrics. By default, this method measures the running time
    of a snippet of code. Let''s use it to measure how long it takes to add one million
    integers to the `Accumulator` object defined in the preceding section:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Printing the `time` value gives us the following output:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: From this, we might conclude that adding one million integers takes approximately
    34 milliseconds. However, this conclusion is wrong. As discussed in [Chapter 5](ch05.html
    "Chapter 5. Data-Parallel Collections"), *Data-Parallel Collections*, after a
    JVM program is run, it goes through a warm-up phase. The program usually achieves
    the best possible performance only after the warm-up phase is completed. To measure
    the relevant running time more accurately, we need to first ensure that the JVM
    reached stable performance.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that ScalaMeter can do this automatically. In the following
    code, we configure the `measure` call to use the default warmer implementation,
    called `Warmer.Default`. We set several configuration parameters, such as the
    minimum number of warm-up runs, the maximum number of warm-up runs, and the number
    of benchmark runs that are used to compute the average running time. Finally,
    we set the `verbose` key to `true` in order to get more logging output about ScalaMeter''s
    execution. This is shown in the following code snippet:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'When running this, make sure that there are no active applications running
    in the background on your computer. Running this snippet of code gives us the
    following output:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We can now see how the running time changes during the warm-up runs. Eventually,
    ScalaMeter detects a steady state and outputs the running time. We now have a
    value of `17.24` milliseconds, which is a good estimate.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: A closer inspection of the ScalaMeter output reveals that, occasionally, a **Garbage
    Collection** (**GC**) cycle occurs. These GC cycles appear periodically during
    the execution of our code snippet, so we conclude that something in the `add`
    method allocates heap objects. However, the `add` implementation does not contain
    any `new` statements. The object allocation must be happening implicitly somehow.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `Accumulator` class is generic. It takes a `T` type parameter,
    which denotes the type of the accumulation. Scala allows using both the reference
    types, such as `String` or `Option`, and primitive types, such as `Int` or `Long`,
    as class-type parameters. Although this conveniently allows treating both the
    primitive and reference types in the same way, it has the unfortunate side effect
    that the primitive values passed to generic classes are converted into heap objects.
    This process is known as auto-boxing, and it hurts the performance in various
    ways. First, it is much slower than just passing a primitive value. Second, it
    causes GC cycles more frequently. Third, it affects cache-locality and might cause
    memory contention. In the case of the `Accumulator` class, each time we call the
    `add` method with a `Long` value, a `java.lang.Long` object is created on the
    heap.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, boxing is sometimes problematic, and sometimes not. Generally,
    it should be avoided in high-performance code. In our case, we can avoid boxing
    by creating an accumulator specialized for the `Long` values. We show it in the
    following code snippet:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Re-running the program reveals that the new accumulator is almost twice as
    fast:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Boxing can slow down the program by a factor of anywhere between one and several
    dozen. This depends on the specific ratio of object allocations and other work,
    and it needs to be measured on a per-program basis.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: An unfortunate side effect is that we can only use the new accumulator implementation
    for `Long` values. However, Scala allows us to retain the generic nature of the
    previous `Accumulator` implementation. The Scala specialization feature allows
    the annotation of class type parameters with the `@specialized` annotation, instructing
    the Scala compiler to automatically generate versions of the generic class for
    primitive types, such as `Long`, and avoid boxing. We will not dive any further
    into this topic, and instead let interested readers find out more on their own.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to identify performance issues and optimize sequential
    programs, we study how to improve the performance by increasing the parallelism
    level. Let''s parallelize the previous program by adding one million integers
    from four separate threads. This is shown in the following code snippet:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the preceding example, we distribute the work of adding 1 million integers
    across four different threads, so we expect the running time of the program to
    increase four times. Sadly, running the program reveals that our expectations
    were wrong:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As pointed out in [Chapter 5](ch05.html "Chapter 5. Data-Parallel Collections"),
    *Data-Parallel Collections*, perpetually writing to the same memory location from
    multiple threads results in memory contention issues. In most computer architectures,
    cache-lines need to be exchanged between the processors writing to the same memory
    location, and this slows down the program. In our case, the contention point is
    the `AtomicLong` object in the `LongAccumulator` class. Simultaneously invoking
    the `compareAndSet` operation on the same memory location does not scale.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: To address the issue of memory contention, we need to somehow disperse the writes
    throughout different cache-lines. Instead of adding the accumulated value to a
    single memory location, we will maintain many memory locations with partial accumulation
    values. When some processor calls the `add` method, it will pick one of these
    memory locations and update the partial accumulation. When a processor calls the
    `apply` method, it will scan all the partial accumulations and add them together.
    In this implementation, we trade the performance of the `apply` method for the
    improved scalability of the `add` method. This trade-off is acceptable in many
    cases, including our `fold` method, where we call the `add` method many times,
    but the `apply` method only once.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, note that the new `apply` implementation is not linearizable, as
    explained in [Chapter 7](ch07.html "Chapter 7. Software Transactional Memory"),
    *Software Transactional Memory*. If some processor calls the `apply` method when
    multiple processors are calling the `add` method, the resulting accumulation value
    can be slightly incorrect. However, if no other processor calls the `add` method
    when the `apply` method is called, the resulting accumulation value will be correct.
    We say that the new `apply` implementation is **quiescently consistent** with
    respect to the `add` method.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Note that this property is sufficient for ensuring the correctness of the preceding
    `fold` implementation, because the `fold` method only calls the `apply` method
    after all the `add` calls are completed.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: We now show the implementation of the `ParLongAccumulator` class, which uses
    an `AtomicLongArray` object, named `values`, to keep the partial accumulation
    values. Atomic arrays are arrays on which we can call operations such as the `compareAndSet`
    method. Conceptually, an `AtomicLongArray` is equivalent to an array of `AtomicLong`
    objects, but is more memory-efficient.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: The `ParLongAccumulator` class must choose a proper size for the `AtomicLongArray`
    object. Setting the size of the array to the number of processors will not make
    the memory contention problems go away. Recall from [Chapter 3](ch03.html "Chapter 3. Traditional
    Building Blocks of Concurrency"), *Traditional Building Blocks of Concurrency*,
    that a processor needs to own a cache-line in exclusive mode before writing to
    it. A cache-line size is typically 64 bytes. This means that on a 32-bit JVM,
    eight consecutive entries in an `AtomicLongArray` object fit inside a single cache-line.
    Even when different processors write to separate `AtomicLongArray` entries, memory
    contention occurs if these entries lie in the same cache-line. This effect is
    known as **false-sharing**. A necessary precondition in avoiding false-sharing
    is to make the array size at least eight times larger than the number of processors.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'A `ParLongAccumulator` object is used by many different threads simultaneously.
    In most programs, there are many more threads than processors. To reduce false-sharing,
    as much as possible, we set the size of the `values` array to 128 times the number
    of processors:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The new `add` implementation is similar to the previous one. The main difference
    is that the new implementation needs to pick the `pos` memory location for the
    partial accumulation value. Different processors should pick different memory
    locations based on their index. Unfortunately, standard APIs on the JVM do not
    provide the index of the current processor. An adequate approximation is to compute
    the `pos` partial accumulation location from the current thread ID. We additionally
    use the `byteswap32` hashing function to effectively randomize the location in
    the array. This decreases the likelihood that two threads with adjacent IDs end
    up writing to adjacent entries in the array, and reduces the possibility of false-sharing.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the program demonstrates that we reached our goal, and improved the
    program performance by a factor of almost three:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: There are additional ways to improve our `ParLongAccumulator` class. One is
    to further reduce false sharing by choosing the entries in the `values` array
    more randomly. Another is to ensure that the `apply` method is not only quiescently
    consistent, but also linearizable. In the interest of keeping this section simple
    and clear, we do not dive further into these topics, but let interested readers
    explore them on their own.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: In this and the preceding sections, we summarized the different styles of concurrency
    and studied the basics of dealing with concurrency bugs. This gave us a useful
    insight into the big picture, but the theory that we learned is only valuable
    if it can be applied in practice. We designed and implemented a remote file browser
    application, a practical example of a large concurrent application. This gave
    us insight into both the theoretical and practical side of concurrent programming.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having seen the technical details of a variety of different concurrency libraries
    in the preceding chapters, we took a couple of steps back and presented a more
    cohesive view of Scala concurrency. After presenting a taxonomy of different styles
    of concurrency, we outlined the use cases for different concurrency frameworks.
    We then studied how to debug concurrent programs and analyze their performance.
    Finally, we combined the different concurrency frameworks together to implement
    a real-world distributed application: a remote file browser.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'The best theory is inspired by practice, and the best practice is inspired
    by theory. This book has given you a fair amount of both. To deepen your understanding
    of concurrent computing, consider studying the references listed at the end of
    each chapter: you should already be able to grasp most of them. Importantly, to
    improve your practical concurrent programming skills, try to solve the exercises
    from this book. Finally, start building your own concurrent applications. By now,
    you must have understood both how high-level concurrency abstractions work and
    how to use them together, and are on the path to becoming a true concurrency expert.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following exercises will improve your skills in building practical concurrent
    applications. Some of them require extending the ScalaFTP program from this chapter,
    while others require implementing concurrent applications from scratch. Finally,
    several exercises are dedicated to testing the performance and scalability of
    concurrent programs:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Extend the ScalaFTP application to allow the addition of directories to the
    remote filesystem.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend the ScalaFTP application so that the changes in the server filesystem
    are automatically reflected in the client program.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend the ScalaFTP application so that it allows parallel regex searches over
    filenames in the remote filesystem.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend the ScalaFTP server so that it allows recursively copying directories.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the download and upload functionality, and use `Observable` objects
    to display the file transfer progress in a Swing `ProgressBar` component.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend the ScalaFTP client implementation so that a `FilePane` can display either
    a remote or a local filesystem's contents.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design and implement a distributed chat application.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design and implement a Paint program with collaborative editing.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compare the duration of creating and starting a new thread, and waiting for
    its termination, against the duration of starting a computation using `Future.apply`
    and waiting for the completion of the corresponding `Future` object.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A pool is one of the simplest collection abstractions, which allows the addition
    and extraction of elements. The `remove` operation returns any element that was
    previously added to the pool. A concurrent pool is represented by the `ConcurrentPool`
    class:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Implement the concurrent pool and make sure that its operations are linearizable.
    Measure and ensure high performance and scalability of your implementation.
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compare the performance and scalability of the Treiber stack from the exercise
    in [Chapter 2](ch02.html "Chapter 2. Concurrency on the JVM and the Java Memory
    Model"), *Concurrency on the JVM and the Java Memory Model*, against the transactional
    sorted list from [Chapter 7](ch07.html "Chapter 7. Software Transactional Memory"),
    *Software Transactional Memory*. How are they compared to the concurrent pool
    from the previous exercise?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `getUniqueId` method from [Chapter 2](ch02.html "Chapter 2. Concurrency
    on the JVM and the Java Memory Model"), *Concurrency on the JVM and the Java Memory
    Model*. Measure and ensure high performance and scalability of your implementation.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a lock-free concurrent linked list and a lock-based concurrent linked
    list that support linearizable prepend and append operations. Both implementations
    must be singly linked lists. Measure the performance of inserting many elements.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A barrier is a concurrent object that allows *N* threads to synchronize at some
    point in the program. A barrier exposes a single method, `await`, which effectively
    blocks the thread until all *N* threads call `await`. After all *N* threads call
    `await`, the `await` invocations of all the threads immediately return. Blocking
    can be done, for example, by busy-waiting. Use atomic integers to implement a
    barrier. Measure the performance of your implementation for one, two, four, and
    eight threads, and some large number of calls to `await`.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
