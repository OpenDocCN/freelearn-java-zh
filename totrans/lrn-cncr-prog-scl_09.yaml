- en: Chapter 9. Concurrency in Practice
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章. 实践中的并发
- en: '|   | *"The best theory is inspired by practice."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"最好的理论是受实践启发的。" |   |'
- en: '|   | --*Donald Knuth* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*唐纳德·克努特* |'
- en: We have studied a plethora of different concurrency facilities in this book.
    By now, you will have learned about dozens of different ways of starting concurrent
    computations and accessing shared data. Knowing how to use different styles of
    concurrency is useful, but it might not yet be obvious when to use which.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书我们研究了大量的不同并发设施。到目前为止，你已经了解了数十种启动并发计算和访问共享数据的不同方法。了解如何使用不同的并发风格是有用的，但可能还不明显何时使用哪种。
- en: 'The goal of this final chapter is to introduce the big picture of concurrent
    programming. We will study the use cases for various concurrency abstractions,
    see how to debug concurrent programs, and how to integrate different concurrency
    libraries in larger applications. In this chapter, we will perform the following
    tasks:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是介绍并发编程的总体情况。我们将研究各种并发抽象的使用案例，了解如何调试并发程序，以及如何将不同的并发库集成到更大的应用程序中。在本章中，我们将执行以下任务：
- en: Summarize the characteristics and typical uses of different concurrency frameworks
    introduced in the earlier chapters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结前面章节中介绍的不同并发框架的特点和典型用途
- en: Investigate how to deal with various kinds of bugs appearing in concurrent applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查如何处理并发应用程序中出现的各种类型的错误
- en: Learn how to identify and resolve performance bottlenecks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何识别和解决性能瓶颈
- en: Apply the previous knowledge about concurrency to implement a larger concurrent
    application, namely, a remote file browser
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将之前关于并发的知识应用于实现一个更大的并发应用程序，即远程文件浏览器
- en: We start with an overview of the important concurrency frameworks we have learned
    about in this book, and a summary of when to use each of them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先概述了本书中我们学习的重要并发框架，以及何时使用它们的总结。
- en: Choosing the right tools for the job
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择适合工作的正确工具
- en: In this section, we present an overview of the different concurrency libraries
    that we learned about. We take a step back and look at the differences between
    these libraries, and what they have in common. This summary will give us an insight
    into what different concurrency abstractions are useful for.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们概述了我们所了解的不同并发库。我们退后一步，看看这些库之间的差异以及它们的共同点。这个总结将使我们深入了解不同的并发抽象对什么是有用的。
- en: 'A concurrency framework usually needs to address several concerns:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 并发框架通常需要解决以下几个问题：
- en: It must provide a way to declare data that is shared between concurrent executions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须提供一种声明在并发执行之间共享的数据的方式
- en: It must provide constructs for reading and modifying program data
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须提供读取和修改程序数据的构造
- en: It must be able to express conditional execution, triggered when a certain set
    of conditions are fulfilled
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须能够表达条件执行，当满足一定条件集时触发
- en: It must define a way to start concurrent executions
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须定义一种启动并发执行的方式
- en: Some of the frameworks from this book address all these concerns; others address
    only a subset, and transfer part of the responsibility to another framework.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的一些框架解决了所有这些问题；其他框架只解决了一部分，并将部分责任转移给了另一个框架。
- en: 'Typically, in a concurrent programming model, we express concurrently shared
    data differently from data intended to be accessed only from a single thread.
    This allows the JVM runtime to optimize sequential parts of the program more effectively.
    So far, we''ve seen a lot of different ways to express concurrently shared data,
    ranging from the low-level facilities to advanced high-level abstractions. We
    summarize different data abstractions in the following table:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在并发编程模型中，我们以不同的方式表达并发共享数据，与仅从单个线程访问的数据。这使得JVM运行时能够更有效地优化程序的顺序部分。到目前为止，我们已经看到了许多表达并发共享数据的不同方法，从低级设施到高级抽象。以下表格总结了不同的数据抽象：
- en: '| **Data abstraction** | **Datatype or annotation** | **Description** |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **数据抽象** | **数据类型或注解** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Volatile variables(JDK) | @volatile | Ensures visibility and the happens-before
    relationship on class fields and local variables that are captured in closures.
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| Volatile变量（JDK） | @volatile | 确保类字段和局部变量（在闭包中捕获）的可见性和happens-before关系。 |'
- en: '| Atomic variables(JDK) | AtomicReference[T]AtomicIntegerAtomicLong | Provide
    basic composite atomic operations, such as **`compareAndSet`** and **`incrementAndGet`**
    . |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 原子变量（JDK） | AtomicReference[T]AtomicIntegerAtomicLong | 提供基本的复合原子操作，例如 **`compareAndSet`**
    和 **`incrementAndGet`** . |'
- en: '| Futures and promises( **`scala.concurrent`** ) | Future[T]Promise[T] | Sometimes
    called single-assignment variables, these express values that might not be computed
    yet but will eventually become available. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 期货和承诺（ **`scala.concurrent`** ） | Future[T]Promise[T] | 有时称为单赋值变量，这些表达可能尚未计算但最终将变得可用的值。
    |'
- en: '| Observables and subjects(Rx) | Observable[T]Subject[T] | Also known as first-class
    event streams, these describe many different values that arrive one after another
    in time. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 可观察的和主题（Rx） | Observable[T]Subject[T] | 也称为一等事件流，这些描述了许多不同值，它们按时间顺序一个接一个地到达。
    |'
- en: '| Transactional references(ScalaSTM) | Ref[T] | These describe memory locations
    that can only be accessed from within memory transactions. Their modifications
    only become visible after the transaction successfully commits. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 事务性引用（ScalaSTM） | Ref[T] | 这些描述了只能从内存事务内部访问的内存位置。它们的修改只有在事务成功提交后才会变得可见。 |'
- en: 'The next important concern is providing access to shared data, which includes
    reading and modifying shared memory locations. Usually, a concurrent program uses
    special constructs to express such accesses. We summarize the different data access
    constructs in the following table:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的问题是提供对共享数据的访问，这包括读取和修改共享内存位置。通常，并发程序使用特殊的结构来表示此类访问。我们将在下表中总结不同的数据访问结构：
- en: '| **Data abstraction** | **Data access constructs** | **Description** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **数据抽象** | **数据访问结构** | **描述** |'
- en: '| Arbitrary data(JDK) | synchronized | Uses intrinsic object locks to exclude
    access to arbitrary shared data. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 任意数据（JDK） | synchronized | 使用内建对象锁来排除对任意共享数据的访问。 |'
- en: '| Atomic variables and classes(JDK) | compareAndSet | Atomically exchanges
    the value of a single memory location. It allows implementing lock-free programs.
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 原子变量和类（JDK） | compareAndSet | 原子地交换单个内存位置的价值。它允许实现无锁程序。 |'
- en: '| Futures and promises( **`scala.concurrent`** ) | valuetryComplete | Used
    to assign a value to a promise, or to check the value of the corresponding future.
    The **`value`** method is not a preferred way to interact with a future. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 期货和承诺（ **`scala.concurrent`** ） | valuetryComplete | 用于将值分配给承诺，或检查相应期货的值。**`value`**
    方法不是与期货交互的首选方式。 |'
- en: '| Transactional references and classes(Scala STM) | atomicorAtomicsingle |
    Atomically modifies the values of a set of memory locations. Reduces the risk
    of deadlocks, but disallows side effects inside the transactional block. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 事务性引用和类（Scala STM） | atomicorAtomicsingle | 原子地修改一组内存位置的价值。减少了死锁的风险，但禁止在事务块内部有副作用。
    |'
- en: 'Concurrent data access is not the only concern of a concurrency framework.
    As we have learned in previous chapters, concurrent computations sometimes need
    to proceed only after a certain condition is met. In the following table, we summarize
    different constructs that enable this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 并发数据访问并不是并发框架的唯一关注点。正如我们在前面的章节中学到的，并发计算有时只有在满足某些条件后才能进行。在下表中，我们总结了不同的结构，这些结构可以启用此功能：
- en: '| **Concurrency framework** | **Conditional execution constructs** | **Description**
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **并发框架** | **条件执行结构** | **描述** |'
- en: '| JVM concurrency | waitnotifynotifyAll | Used to suspend the execution of
    a thread until some other thread notifies that the conditions are met. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| JVM 并发 | waitnotifynotifyAll | 用于挂起线程的执行，直到其他线程通知条件已满足。 |'
- en: '| Futures and promises | onCompleteAwait.ready | Conditionally schedules an
    asynchronous computation. The **`Await.ready`** method suspends the thread until
    the future completes. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 期货和承诺 | onCompleteAwait.ready | 条件性地安排异步计算。**`Await.ready`** 方法使线程挂起，直到期货完成。
    |'
- en: '| Reactive extensions | subscribe | Asynchronously or synchronously executes
    a computation when an event arrives. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 反应式扩展 | subscribe | 当事件到达时异步或同步执行计算。 |'
- en: '| Software transactional memory | retryretryForwithRetryTimeout | Retries the
    current memory transaction when some of the relevant memory locations change.
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 软件事务内存 | retryretryForwithRetryTimeout | 当一些相关内存位置发生变化时，重试当前内存事务。 |'
- en: '| Actors | receive | Executes the actor''s **`receive`** block when a message
    arrives. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 演员 | receive | 当消息到达时执行演员的 **`receive`** 块。 |'
- en: 'Finally, a concurrency model must define a way to start a concurrent execution.
    We summarize different concurrency constructs in the following table:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，并发模型必须定义一种启动并发执行的方法。以下表格总结了不同的并发构造：
- en: '| **Concurrency framework** | **Concurrency constructs** | **Description**
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **并发框架** | **并发构造** | **描述** |'
- en: '| JVM concurrency | Thread.start | Starts a new thread of execution. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| JVM并发 | Thread.start | 启动一个新的执行线程。 |'
- en: '| Execution contexts | execute | Schedules a block of code for execution on
    a thread pool. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 执行上下文 | execute | 在线程池上为执行调度一段代码。 |'
- en: '| Futures and promises | Future.apply | Schedules a block of code for execution,
    and returns the future value with the result of the execution. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 期货和承诺 | Future.apply | 为执行调度一段代码，并返回执行结果的未来值。 |'
- en: '| Parallel collections | par | Allows invoking data-parallel versions of collection
    methods. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 并行集合 | par | 允许调用集合方法的数据并行版本。 |'
- en: '| Reactive extensions | Observable.createobserveOn | The **`create`** method
    defines an event source. The **`observeOn`** method schedules the handling of
    events on different threads. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 反应式扩展 | Observable.createObserveOn | **`create`** 方法定义了一个事件源。**`observeOn`**
    方法在不同的线程上调度事件的处理。 |'
- en: '| Actors | actorOf | Schedules a new actor object for execution. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 演员 | actorOf | 为执行调度一个新的演员对象。 |'
- en: This breakdown shows us that different concurrency libraries focus on different
    tasks. For example, parallel collections do not have conditional waiting constructs,
    because a data-parallel operation proceeds on separate elements independently.
    Similarly, software transactional memory does not come with a construct to express
    concurrent computations, and focuses only on protecting access to shared data.
    Actors do not have special constructs for modeling shared data and protecting
    access to it, because data is encapsulated within separate actors and accessed
    serially only by the actor that owns it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分解显示，不同的并发库专注于不同的任务。例如，并行集合没有条件等待构造，因为数据并行操作是在独立元素上进行的。同样，软件事务内存没有用于表达并发计算的构造，它只关注保护对共享数据的访问。演员没有用于建模共享数据和保护其访问的特殊构造，因为数据封装在单独的演员中，并且只能由拥有它的演员按顺序访问。
- en: 'Having classified concurrency libraries according to how they model shared
    data and express concurrency, we present a summary of what different concurrency
    libraries are good for:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们如何建模共享数据和表达并发，我们对并发库进行了分类，现在我们总结一下不同的并发库适合做什么：
- en: The classical JVM concurrency model uses threads, the `synchronized` statement,
    volatile variables, and atomic primitives for low-level tasks. Uses include implementing
    a custom concurrency utility, a concurrent data structure, or a concurrency framework
    optimized for specific tasks.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经典的JVM并发模型使用线程、`synchronized`语句、volatile变量和原子原语进行低级任务。用途包括实现自定义并发实用程序、并发数据结构或针对特定任务优化的并发框架。
- en: Futures and promises are best suited for referring to concurrent computations
    that produce a single result value. Futures model latency in the program, and
    allow composing values that become available later during the execution of the
    program. Uses include performing remote network requests and waiting for replies,
    referring to the result of an asynchronous long-running computation, or reacting
    to the completion of an I/O operation. Futures are usually the glue of a concurrent
    application, binding the different parts of a concurrent program together. We
    often use futures to convert single-event callback APIs into a standardized representation
    based on the `Future` type.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 期货和承诺最适合引用产生单个结果值的并发计算。期货模型程序中的延迟，并允许在程序执行过程中将可用的值组合起来。用途包括执行远程网络请求并等待回复，引用异步长时间运行计算的结果，或对I/O操作的完成做出反应。期货通常是并发应用程序的粘合剂，将并发程序的不同部分绑定在一起。我们经常使用期货将单事件回调API转换为基于`Future`类型的标准化表示。
- en: Parallel collections are best suited for efficiently executing data-parallel
    operations on large datasets. Uses include file searching, text processing, linear
    algebra applications, numerical computations, and simulations. Long-running Scala
    collection operations are usually good candidates for parallelization.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行集合最适合在大型数据集上高效执行数据并行操作。用途包括文件搜索、文本处理、线性代数应用、数值计算和模拟。长时间运行的Scala集合操作通常是并行化的良好候选。
- en: Reactive extensions are used to express asynchronous event-based programs. Unlike
    parallel collections, in reactive extensions, data elements are not available
    when the operation starts, but arrive while the application is running. Uses include
    converting callback-based APIs, modeling events in user interfaces, modeling events
    external to the application, manipulating program events with collection-style
    combinators, streaming data from input devices or remote locations, or incrementally
    propagating changes in the data model throughout the program.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式扩展用于表达基于异步事件驱动的程序。与并行集合不同，在反应式扩展中，数据元素在操作开始时不可用，而是在应用程序运行时到达。应用包括将基于回调的API转换为反应式API，在用户界面中建模事件，建模应用程序外部的事件，使用集合样式组合子操作程序事件，从输入设备或远程位置流式传输数据，或在程序中增量传播数据模型的变化。
- en: Use STM to protect program data from getting corrupted by concurrent accesses.
    An STM allows building complex data models and accessing them with the reduced
    risk of deadlocks and race conditions. A typical use is to protect concurrently
    accessible data while retaining good scalability between threads whose accesses
    to data do not overlap.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用STM（软件事务内存）来保护程序数据免受并发访问的损坏。STM允许构建复杂的数据模型，并以降低死锁和竞态条件风险的方式访问它们。典型用途是在保护并发可访问数据的同时，保持线程之间数据访问不重叠时的良好可伸缩性。
- en: Actors are suitable for encapsulating concurrently accessible data, and seamlessly
    building distributed systems. Actor frameworks provide a natural way to express
    concurrent tasks that communicate by explicitly sending messages. Uses include
    serializing concurrent access to data to prevent corruption, expressing stateful
    concurrency units in the system, and building distributed applications such as
    trading systems, P2P networks, communication hubs, or data-mining frameworks.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员（Actors）适合封装可并发访问的数据，并无缝构建分布式系统。演员框架提供了一种自然的方式来表达通过显式发送消息进行通信的并发任务。应用包括将并发访问数据序列化以防止损坏，在系统中表达有状态的并发单元，以及构建如交易系统、P2P网络、通信中心或数据挖掘框架等分布式应用程序。
- en: Advocates of specific programming languages, libraries, or frameworks might
    try to convince you that their technology is the best for any task and any situation,
    often with the intent of selling it. Richard Stallman once said that "computer
    science is the only industry more fashion-driven than women's fashion." As engineers,
    we need to know better than to succumb to programming fashion and marketing propaganda.
    Different frameworks are tailored towards specific use cases, and the correct
    way to choose a technology is to carefully weigh its advantages and disadvantages
    when applied to a specific situation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 某些编程语言、库或框架的倡导者可能会试图说服你，他们的技术适用于任何任务和任何情况，通常带有销售的目的。理查德·斯托尔曼曾经说过：“计算机科学是唯一比女性时尚更受时尚驱动的行业。”作为工程师，我们需要比屈服于编程时尚和营销宣传更有见识。不同的框架针对特定的用例定制，选择技术的正确方式是在特定情况下仔细权衡其优缺点。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There is no one-size-fits-all technology. Use your own best judgment when deciding
    which concurrency framework to use for a specific programming task.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种技术可以适用于所有情况。在决定为特定的编程任务使用哪个并发框架时，请使用自己的最佳判断。
- en: Sometimes, choosing the best-suited concurrency utility is easier said than
    done. It takes a great deal of experience to choose the correct technology. In
    many cases, we do not even know enough about the requirements of the system to
    make an informed decision. Regardless, a good rule of thumb is to apply several
    concurrency frameworks to different parts of the same application, each best suited
    for a specific task. Often, the real power of different concurrency frameworks
    becomes apparent when they are used together. This is the topic we will cover
    in the following section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，选择最适合的并发工具比说起来容易做起来难。选择正确的技术需要大量的经验。在许多情况下，我们甚至对系统的需求了解不足，无法做出明智的决定。无论如何，一个很好的经验法则是将几个并发框架应用于同一应用程序的不同部分，每个框架最适合特定任务。通常，不同并发框架的真实力量在它们一起使用时才会显现。这是我们将在下一节中讨论的主题。
- en: Putting it all together - a remote file browser
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起 - 远程文件浏览器
- en: In this section, we use our knowledge about different concurrency frameworks
    to build a remote file browser. This larger application example illustrates how
    different concurrency libraries work together, and how to apply them to different
    situations. We will name our remote file browser ScalaFTP.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们利用我们对不同并发框架的了解来构建一个远程文件浏览器。这个更大的应用程序示例说明了不同的并发库如何协同工作，以及如何将它们应用于不同的场景。我们将我们的远程文件浏览器命名为
    ScalaFTP。
- en: 'The ScalaFTP browser is divided into two main components: the server and the
    client process. The server process will run on the machine whose filesystem we
    want to manipulate. The client will run on our own computer, and comprise of a
    graphical user interface used to navigate the remote filesystem. To keep things
    simple, the protocol that the client and the server will use to communicate will
    not really be FTP, but a custom communication protocol. By choosing the correct
    concurrency libraries to implement different parts of ScalaFTP, we will ensure
    that the complete ScalaFTP implementation fits inside just 500 lines of code.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ScalaFTP 浏览器分为两个主要组件：服务器和客户端进程。服务器进程将在我们想要操作的文件系统所在的机器上运行。客户端将在我们的计算机上运行，包括一个用于导航远程文件系统的图形用户界面。为了简化问题，客户端和服务器之间将使用的通信协议实际上不是
    FTP，而是一个自定义通信协议。通过选择正确的并发库来实现 ScalaFTP 的不同部分，我们将确保完整的 ScalaFTP 实现仅占用 500 行代码。
- en: 'Specifically, the ScalaFTP browser will implement the following features:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，ScalaFTP 浏览器将实现以下功能：
- en: Displaying the names of the files and the directories in a remote filesystem,
    and allowing navigation through the directory structure
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示远程文件系统中文件和目录的名称，并允许通过目录结构进行导航
- en: Copying files between directories in a remote filesystem
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在远程文件系统中在不同目录之间复制文件
- en: Deleting files in a remote filesystem
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在远程文件系统中删除文件
- en: 'To implement separate pieces of this functionality, we will divide the ScalaFTP
    server and client programs into layers. The task of the server program is to answer
    to incoming copy and delete requests, and to answer queries about the contents
    of specific directories. To make sure that its view of the filesystem is consistent,
    the server will cache the directory structure of the filesystem. We divide the
    server program into two layers: the filesystem API and the server interface. The
    filesystem API will expose the data model of the server program, and define useful
    utility methods to manipulate the filesystem. The server interface will receive
    requests and send responses back to the client.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一功能的各个部分，我们将 ScalaFTP 服务器和客户端程序划分为多个层次。服务器程序的任务是响应传入的复制和删除请求，以及响应关于特定目录内容的查询。为了确保其对文件系统的视图保持一致，服务器将缓存文件系统的目录结构。我们将服务器程序划分为两个层次：文件系统
    API 和服务器接口。文件系统 API 将暴露服务器程序的数据模型，并定义用于操作文件系统的有用实用方法。服务器接口将接收请求并向客户端发送响应。
- en: Since the server interface will require communicating with the remote client,
    we decide to use the Akka actor framework. Akka comes with remote communication
    facilities, as we learned in [Chapter 8](ch08.html "Chapter 8.  Actors"), *Actors*.
    The contents of the filesystem, that is, its state, will change over time. We
    are therefore interested in choosing proper constructs for data access.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器接口将需要与远程客户端通信，我们决定使用 Akka actor 框架。Akka 内置远程通信功能，正如我们在第 8 章[Actors](ch08.html
    "第 8 章。演员")中学习的那样。文件系统的内容，即其状态，会随时间变化。因此，我们对选择合适的数据访问结构很感兴趣。
- en: 'In the filesystem API, we can use object monitors and locking to synchronize
    access to shared state, but we will avoid these due to the risk of deadlocks.
    We similarly avoid using atomic variables, because they are prone to race conditions.
    We could encapsulate the filesystem state within an actor, but note that this
    can lead to a scalability bottleneck: an actor would serialize all accesses to
    the filesystem state. Therefore, we decide to use the ScalaSTM framework to model
    the filesystem contents. An STM avoids the risk of deadlocks and race conditions,
    and ensures good horizontal scalability, as we learned in [Chapter 7](ch07.html
    "Chapter 7. Software Transactional Memory"), *Software Transactional Memory*.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件系统API中，我们可以使用对象监视器和锁定来同步对共享状态的访问，但我们将避免使用这些方法，因为它们可能导致死锁。我们同样避免使用原子变量，因为它们容易发生竞态条件。我们可以在actor中封装文件系统状态，但请注意，这可能导致可扩展性瓶颈：actor将序列化对文件系统状态的所有访问。因此，我们决定使用ScalaSTM框架来建模文件系统内容。STM可以避免死锁和竞态条件的风险，并确保良好的横向可扩展性，正如我们在[第7章](ch07.html
    "第7章。软件事务内存")，“软件事务内存”中所学到的。
- en: The task of the client program will be to graphically present the contents of
    the remote filesystem, and communicate with the server. We divide the client program
    into three layers of functionality. The GUI layer will render the contents of
    the remote filesystem and register user requests, such as button clicks. We will
    implement the GUI using the Swing and Rx frameworks, similarly to how we implemented
    the web browser in [Chapter 6](ch06.html "Chapter 6. Concurrent Programming with
    Reactive Extensions"), *Concurrent Programming with Reactive Extensions*. The
    client API will replicate the server interface on the client side and communicate
    with the server. We will use Akka to communicate with the server, but expose the
    results of remote operations as futures. Finally, the client logic will be a gluing
    layer, which binds the GUI and the client API together.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端程序的任务是图形化展示远程文件系统的内容，并与服务器进行通信。我们将客户端程序划分为三个功能层。GUI层将渲染远程文件系统的内容并注册用户请求，如按钮点击。我们将使用Swing和Rx框架来实现GUI，类似于我们在[第6章](ch06.html
    "第6章。使用响应式扩展的并发编程")，“使用响应式扩展的并发编程”中实现网页浏览器的方式。客户端API将在客户端复制服务器接口并与服务器通信。我们将使用Akka与服务器通信，但暴露远程操作的结果作为futures。最后，客户端逻辑将是一个粘合层，它将GUI和客户端API绑定在一起。
- en: 'The architecture of the ScalaFTP browser is illustrated in the following diagram,
    in which we indicate which concurrency libraries will be used by separate layers.
    The dashed line represents the communication path between the client and the server:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ScalaFTP浏览器的架构在以下图中得到展示，图中我们指出了各个层将使用哪些并发库。虚线代表客户端和服务器之间的通信路径：
- en: '![Putting it all together - a remote file browser](img/image_09_001.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![将所有内容整合 - 远程文件浏览器](img/image_09_001.jpg)'
- en: We now start by implementing the ScalaFTP server, relying on the bottom-up design
    approach. In the following section, we will describe the internals of the filesystem
    API.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在开始实现ScalaFTP服务器，采用自底向上的设计方法。在下一节中，我们将描述文件系统API的内部结构。
- en: Modeling the filesystem
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统的建模
- en: In [Chapter 3](ch03.html "Chapter 3. Traditional Building Blocks of Concurrency"),
    *Traditional Building Blocks of Concurrency*, we used atomic variables and concurrent
    collections to implement a non-blocking, thread-safe filesystem API, which allowed
    copying files and retrieving snapshots of the filesystem. In this section, we
    repeat this task using STM. We will see that it is much intuitive and less error-prone
    to use STM.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。并发传统的构建块")，“并发的传统构建块”中，我们使用了原子变量和并发集合来实现一个无阻塞、线程安全的文件系统API，这允许复制文件和检索文件系统的快照。在本节中，我们将使用STM重复这项任务。我们将看到使用STM更加直观且错误率更低。
- en: 'We start by defining the different states that a file can be in. As in [Chapter
    3](ch03.html "Chapter 3. Traditional Building Blocks of Concurrency"), *Traditional
    Building Blocks of Concurrency*, the file can be currently created, in the idle
    state, being copied, or being deleted. We model this with a sealed `State` trait,
    and its four cases:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义文件可能处于的不同状态。与[第3章](ch03.html "第3章。并发的传统构建块")，“并发的传统构建块”一样，文件可以是当前创建中、空闲状态、正在复制或正在删除。我们使用一个密封的`State`特质及其四个情况来建模这一点：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A file can only be deleted if it is in the idle state, and it can only be copied
    if it is in the idle state or in the copied state. Since a file can be copied
    to multiple destinations at a time, the `Copying` state encodes how many copies
    are currently under way. We add the methods `inc` and `dec` to the `State` trait,
    which return a new state with one more or one fewer copy, respectively. For example,
    the implementation of `inc` and `dec` for the `Copying` state is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在文件处于空闲状态时才能删除它，只有当它处于空闲状态或已复制状态时才能复制它。由于文件可以同时复制到多个目的地，`Copying` 状态编码了当前正在进行多少次复制。我们向
    `State` 特质添加了 `inc` 和 `dec` 方法，分别返回一个状态增加或减少一个复制的新的状态。例如，`Copying` 状态的 `inc` 和
    `dec` 的实现如下：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Similar to the `File` class in the `java.io` package, we represent both the
    files and directories with the same entity, and refer to them more generally as
    files. Each file is represented by the `FileInfo` class that encodes the path,
    its name, its parent directory and the date of the last modification to the file,
    a Boolean value denoting if the file is a directory, the size of the file, and
    its `State` object. The `FileInfo` class is immutable, and updating the state
    of the file will require creating a fresh `FileInfo` object:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `java.io` 包中的 `File` 类类似，我们使用相同的实体来表示文件和目录，并更一般地称它们为文件。每个文件由 `FileInfo` 类表示，该类编码了路径、其名称、其父目录以及文件最后修改的日期、一个表示文件是否为目录的布尔值、文件的大小以及其
    `State` 对象。`FileInfo` 类是不可变的，更新文件的状态将需要创建一个新的 `FileInfo` 对象：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We separately define the factory methods `apply` and `creating` that take a
    `File` object and return a `FileInfo` object in the `Idle` or `Created` state,
    respectively.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分别定义了 `apply` 和 `creating` 工厂方法，它们分别接受一个 `File` 对象并返回一个处于 `Idle` 或 `Created`
    状态的 `FileInfo` 对象。
- en: 'Depending on where the server is started, the root of the ScalaFTP directory
    structure is a different subdirectory in the actual filesystem. A `FileSystem`
    object tracks the files in the given `rootpath` directory, using a transactional
    map called `files`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器启动的位置不同，ScalaFTP 目录结构的根在实际的文件系统中是不同的子目录。`FileSystem` 对象跟踪给定 `rootpath` 目录中的文件，使用一个名为
    `files` 的事务性映射：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We introduce a separate `init` method to initialize the `FileSystem` object.
    The `init` method starts a transaction, clears the contents of the `files` map,
    and traverses the files and directories under `rootpath` using the Apache Commons
    IO library. For each file and directory, the `init` method creates a `FileInfo`
    object and adds it to the `files` map, using its path as the key:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个单独的 `init` 方法来初始化 `FileSystem` 对象。`init` 方法启动一个事务，清除 `files` 映射的内容，并使用
    Apache Commons IO 库遍历 `rootpath` 下的文件和目录。对于每个文件和目录，`init` 方法创建一个 `FileInfo` 对象并将其添加到
    `files` 映射中，使用其路径作为键：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Recall that the ScalaFTP browser must display the contents of the remote filesystem.
    To enable directory queries, we first add the `getFileList` method to the `FileSystem`
    class, which retrieves the files in the specified `dir` directory. The `getFileList`
    method starts a transaction and filters the files whose direct parent is equal
    to `dir`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，ScalaFTP 浏览器必须显示远程文件系统的内容。为了启用目录查询，我们首先将 `getFileList` 方法添加到 `FileSystem`
    类中，该方法检索指定 `dir` 目录中的文件。`getFileList` 方法启动一个事务并过滤出直接父级等于 `dir` 的文件：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We implement the copying logic in the filesystem API with the `copyFile` method.
    This method takes a path to the `src` source file and the `dest` destination file,
    and starts a transaction. After checking whether the `dest` destination file exists
    or not, the `copyFile` method inspects the state of the source file entry, and
    fails unless the state is `Idle` or `Copying`. It then calls `inc` to create a
    new state with the increased copy count, and updates the source file entry in
    the `files` map with the new state. Similarly, the `copyFile` method creates a
    new entry for the destination file in the `files` map. Finally, the `copyFile`
    method calls the `afterCommit` handler to physically copy the file to disk after
    the transaction completes. Recall that it is not legal to execute side-effecting
    operations from within the transaction body, so the private `copyOnDisk` method
    is called only after the transaction commits:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在文件系统API中使用`copyFile`方法实现复制逻辑。此方法接受`src`源文件的路径和`dest`目标文件的路径，并启动一个事务。在检查`dest`目标文件是否存在之后，`copyFile`方法检查源文件条目的状态，除非状态是`Idle`或`Copying`，否则会失败。然后它调用`inc`来创建一个新的状态，复制计数增加，并使用新状态更新`files`映射中的源文件条目。同样，`copyFile`方法在`files`映射中为目标文件创建一个新的条目。最后，`copyFile`方法在事务完成后调用`afterCommit`处理程序，将文件物理复制到磁盘。回想一下，在事务体中执行副作用操作是不合法的，因此仅在事务提交后调用私有的`copyOnDisk`方法：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `copyOnDisk` method calls the `copyFile` method on the `FileUtils` class
    from the Apache Commons IO library. After the file transfer completes, the `copyOnDisk`
    method starts another transaction, in which it decreases the copy count of the
    source file and sets the state of the destination file to `Idle`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyOnDisk`方法在Apache Commons IO库的`FileUtils`类上调用`copyFile`方法。在文件传输完成后，`copyOnDisk`方法启动另一个事务，在此事务中，它减少源文件的复制计数并将目标文件的状态设置为`Idle`：'
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `deleteFile` method deletes a file in a similar way. It changes the file
    state to `Deleted`, deletes the file, and starts another transaction to remove
    the file entry:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteFile`方法以类似的方式删除文件。它将文件状态更改为`Deleted`，删除文件，并启动另一个事务以删除文件条目：'
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Modeling the server data model with the STM allows for the seamless addition
    of different concurrent computations to the server program. In the following section,
    we will implement a server actor that uses the server API to execute filesystem
    operations.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用STM（软件事务内存）对服务器数据模型进行建模，允许无缝地将不同的并发计算添加到服务器程序中。在下一节中，我们将实现一个使用服务器API执行文件系统操作的服务器actor。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use STM to model concurrently accessible data, as an STM works transparently
    with most concurrency frameworks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用STM来建模可并发访问的数据，因为STM与大多数并发框架透明地工作。
- en: Having completed the filesystem API, we now proceed to the server interface
    layer of the ScalaFTP browser.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 完成文件系统API后，我们现在继续处理ScalaFTP浏览器的服务器接口层。
- en: The server interface
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器接口
- en: The server interface comprises of a single actor called `FTPServerActor`. This
    actor will receive client requests and respond to them serially. If it turns out
    that the server actor is the sequential bottleneck of the system, we can simply
    add additional server interface actors to improve horizontal scalability.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器接口由一个名为`FTPServerActor`的单个actor组成。这个actor将接收客户端请求并依次响应它们。如果服务器actor是系统的顺序瓶颈，我们可以简单地添加额外的服务器接口actor来提高水平可伸缩性。
- en: 'We start by defining the different types of messages that the server actor
    can receive. We follow the convention of defining them inside the companion object
    of the `FTPServerActor` class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义服务器actor可以接收的不同类型的消息。我们遵循在`FTPServerActor`类的伴生对象中定义它们的惯例：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The actor template of the server actor takes a `FileSystem` object as a parameter.
    It reacts to the `GetFileList`, `CopyFile`, and `DeleteFile` messages by calling
    the appropriate methods from the filesystem API:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器actor的actor模板接受一个`FileSystem`对象作为参数。它通过调用文件系统API中的适当方法来响应`GetFileList`、`CopyFile`和`DeleteFile`消息：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When the server receives a `GetFileList` message, it calls the `getFileList`
    method with the specified `dir` directory, and sends a sequence collection with
    the `FileInfo` objects back to the client. Since `FileInfo` is a case class, it
    extends the `Serializable` interface, and its instances can be sent over the network.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器接收到`GetFileList`消息时，它使用指定的`dir`目录调用`getFileList`方法，并将包含`FileInfo`对象的序列集合发送回客户端。由于`FileInfo`是一个case类，它扩展了`Serializable`接口，因此其实例可以通过网络发送。
- en: When the server receives a `CopyFile` or `DeleteFile` message, it calls the
    appropriate filesystem method asynchronously. The methods in the filesystem API
    throw exceptions when something goes wrong, so we need to wrap calls to them in
    `Try` objects. After the asynchronous file operations complete, the resulting
    `Try` objects are piped back as messages to the sender actor, using the Akka `pipeTo`
    method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器接收到 `CopyFile` 或 `DeleteFile` 消息时，它会异步调用相应的文件系统方法。当文件系统 API 中的方法出错时，会抛出异常，因此我们需要在调用它们时使用
    `Try` 对象进行包装。异步文件操作完成后，结果 `Try` 对象会通过 Akka 的 `pipeTo` 方法作为消息管道回传给发送者演员。
- en: 'To start the ScalaFTP server, we need to instantiate and initialize a `FileSystem`
    object and start the server actor. We parse the network port command-line argument,
    and use it to create an actor system that is capable of remote communication.
    For this, we use the `remotingSystem` factory method that we introduced in [Chapter
    8](ch08.html "Chapter 8.  Actors"), *Actors*. The remoting actor system then creates
    an instance of the `FTPServerActor`. This is shown in the following program:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 ScalaFTP 服务器，我们需要实例化和初始化一个 `FileSystem` 对象，并启动服务器演员。我们解析网络端口命令行参数，并使用它创建一个能够进行远程通信的演员系统。为此，我们使用我们在第
    8 章[“Actors”]中介绍的 `remotingSystem` 工厂方法。然后，远程演员系统创建一个 `FTPServerActor` 实例。这在上面的程序中显示：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The ScalaFTP server actor can run inside the same process as the client application,
    in another process in the same machine, or on a different machine connected with
    a network. The advantage of the actor model is that we usually need not worry
    about where the actor runs until we integrate it into the entire application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ScalaFTP 服务器演员可以在与客户端应用程序相同的进程中运行，在同一台机器的另一个进程中运行，或者在网络连接的不同机器上运行。演员模型的优势在于，我们通常不需要担心演员在哪里运行，直到我们将它集成到整个应用程序中。
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When you need to implement a distributed application that runs on different
    machines, use an actor framework.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要实现运行在不同机器上的分布式应用程序时，使用演员框架。
- en: 'Our server program is now complete, and we can run it with the `run` command
    from SBT. We set the actor system to use the port `12345`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器程序现在已完成，我们可以使用 SBT 的 `run` 命令来运行它。我们将演员系统设置为使用端口 `12345`：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the following section, we will implement the file navigation API for the
    ScalaFTP client, which will communicate with the server interface over the network.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现 ScalaFTP 客户端的文件导航 API，该 API 将通过网络与服务器接口通信。
- en: Client navigation API
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端导航 API
- en: The client API exposes the server interfaces to the client program through asynchronous
    methods that return future objects. Unlike the server's filesystem API, which
    runs locally, the client API methods execute remote network requests. Futures
    are a natural way to model latency in the client API methods, and to avoid blocking
    during network requests.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端 API 通过返回未来对象的异步方法将服务器接口暴露给客户端程序。与在本地运行的服务器文件系统 API 不同，客户端 API 方法执行远程网络请求。未来对象是客户端
    API 方法中建模延迟和避免网络请求阻塞的自然方式。
- en: 'Internally, the client API maintains an actor instance that communicates with
    the server actor. The client actor does not know the actor reference of the server
    actor when it is created. For this reason, the client actor starts in an **unconnected**
    state. When it receives the `Start` message with the URL of the server actor system,
    the client constructs an actor path to the server actor, sends out an `Identify`
    message, and switches to the **connecting** state. If the actor system is able
    to find the server actor, the client actor eventually receives the `ActorIdentity`
    message with the server actor reference. In this case, the client actor switches
    to the **connected** state, and is able to forward commands to the server. Otherwise,
    the connection fails and the client actor reverts to the unconnected state. The
    state diagram of the client actor is shown in the following figure:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，客户端 API 维护一个与服务器演员通信的演员实例。当客户端演员被创建时，它并不知道服务器演员的演员引用。因此，客户端演员以 **未连接** 的状态开始。当它接收到包含服务器演员系统
    URL 的 `Start` 消息时，客户端构建一个指向服务器演员的演员路径，发送一个 `Identify` 消息，并切换到 **连接中** 的状态。如果演员系统能够找到服务器演员，客户端演员最终会收到包含服务器演员引用的
    `ActorIdentity` 消息。在这种情况下，客户端演员切换到 **已连接** 的状态，并能够将命令转发给服务器。否则，连接失败，客户端演员将恢复到未连接状态。客户端演员的状态图如下所示：
- en: '![Client navigation API](img/image_09_002.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![客户端导航 API](img/image_09_002.jpg)'
- en: 'We define the `Start` message in the client actor''s companion object:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在客户端actor的伴生对象中定义了`Start`消息：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We then define the `FTPClientActor` class and give it an implicit `Timeout`
    parameter. The `Timeout` parameter will be used later in the Akka ask pattern,
    when forwarding client requests to the server actor. The stub of the `FTPClientActor`
    class is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后定义了`FTPClientActor`类，并给它一个隐式的`Timeout`参数。这个`Timeout`参数将在Akka的ask模式中稍后使用，当将客户端请求转发到服务器actor时。`FTPClientActor`类的stub如下：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Before defining the `receive` method, we define behaviors corresponding to
    different actor states. Once the client actor in the unconnected state receives
    the `Start` message with the host string, it constructs an actor path to the server
    and creates an actor selection object. The client actor then sends the `Identify`
    message to the actor selection, and switches its behavior to `connecting`. This
    is shown in the following behavior method, named `unconnected`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义`receive`方法之前，我们定义了对应不同actor状态的行为。一旦未连接状态的客户端actor收到带有主机字符串的`Start`消息，它构建了一个指向服务器的actor路径并创建了一个actor选择对象。然后客户端actor向actor选择发送`Identify`消息，并将行为切换到`connecting`。这在上面的`unconnected`行为方法中展示：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `connecting` method creates a behavior given an actor reference to the
    sender of the `Start` message. We call this actor reference `clientApp`, because
    the ScalaFTP client application will send the `Start` message to the client actor.
    Once the client actor receives an `ActorIdentity` message with the `ref` reference
    to the server actor, it can send `true` back to the `clientApp` reference, indicating
    that the connection was successful. In this case, the client actor switches to
    the `connected` behavior. Otherwise, if the client actor receives an `ActorIdentity`
    message without the server reference, the client actor sends `false` back to the
    application and reverts to the `unconnected` state:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`connecting`方法根据`Start`消息的发送者的actor引用创建一个行为。我们称这个actor引用为`clientApp`，因为ScalaFTP客户端应用程序会将`Start`消息发送到客户端actor。一旦客户端actor收到带有`ref`引用的服务器actor的`ActorIdentity`消息，它可以向`clientApp`引用发送`true`，表示连接成功。在这种情况下，客户端actor切换到`connected`行为。否则，如果客户端actor收到没有服务器引用的`ActorIdentity`消息，客户端actor向应用程序发送`false`并恢复到`unconnected`状态：'
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `connected` state uses the `serverActor` server actor reference to forward
    the `Command` messages. To do so, the client actor uses the Akka ask pattern,
    which returns a future object with the server''s response. The contents of the
    future are piped back to the original sender of the `Command` message. In this
    way, the client actor serves as an intermediary between the application, which
    is the sender, and the server actor. The `connected` method is shown in the following
    code snippet:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`connected`状态使用`serverActor`服务器actor引用来转发`Command`消息。为此，客户端actor使用Akka的ask模式，它返回一个带有服务器响应的future对象。future的内容被管道回`Command`消息的原始发送者。这样，客户端actor充当了应用程序（发送者）和服务器actor之间的中介。下面的代码片段展示了`connected`方法：'
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, the `receive` method returns the `unconnected` behavior, in which
    the client actor is created:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`receive`方法返回`unconnected`行为，其中创建了客户端actor：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Having implemented the client actor, we can proceed to the client API layer.
    We model it as a trait with a `connected` value, the concrete methods `getFileList`,
    `copyFile`, and `deleteFile`, and an abstract `host` method. The client API creates
    a private remoting actor system and a client actor. It then instantiates the `connected`
    future that computes the connection status by sending a `Start` message to the
    client actor. The methods `getFileList`, `copyFile`, and `deleteFile` are similar.
    They use the ask pattern on the client actor to obtain a future with the response.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了客户端actor之后，我们可以继续到客户端API层。我们将其建模为一个带有`connected`值的特质，具体的方法有`getFileList`、`copyFile`和`deleteFile`，以及一个抽象的`host`方法。客户端API创建了一个私有的远程actor系统和一个客户端actor。然后它实例化了一个计算连接状态的`connected`future，通过向客户端actor发送一个`Start`消息来实现。`getFileList`、`copyFile`和`deleteFile`方法类似。它们在客户端actor上使用ask模式来获取带有响应的future。
- en: 'Recall that the actor messages are not typed, and the ask pattern returns a
    `Future[Any]` object. For this reason, each method in the client API uses the
    `mapTo` future combinator to restore the type of the message:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，actor消息是无类型的，ask模式返回一个`Future[Any]`对象。因此，客户端API中的每个方法都使用`mapTo` future组合器来恢复消息的类型：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that the client API does not expose the fact that it uses actors for remote
    communication. Moreover, the client API is similar to the server API, but the
    return types of the methods are futures instead of normal values. Futures encode
    the latency of a method without exposing the cause for the latency, so we often
    find them at the boundaries between different APIs. We can internally replace
    the actor communication between the client and the server with the remote `Observable`
    objects, but that would not change the client API.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，客户端API没有暴露它使用actor进行远程通信的事实。此外，客户端API与服务器API相似，但方法的返回类型是futures而不是正常值。Futures编码了方法的延迟，但没有暴露延迟的原因，所以我们经常在不同API的边界处找到它们。我们可以用远程`Observable`对象替换客户端和服务器之间的actor通信，但这不会改变客户端API。
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In a concurrent application, use futures at the boundaries of the layers to
    express latency.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发应用程序中，在层的边界处使用futures来表示延迟。
- en: Now that we can programmatically communicate with the remote ScalaFTP server,
    we turn our attention to the user interface of the client program.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够以编程方式与远程ScalaFTP服务器通信，我们将注意力转向客户端程序的界面。
- en: The client user interface
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端用户界面
- en: In this section, we create the static user interface for the ScalaFTP client
    program. This graphical frontend will make our ScalaFTP application easy and intuitive
    to use. We will rely on the Scala Swing library to implement the UI.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们为ScalaFTP客户端程序创建静态用户界面。这个图形前端将使我们的ScalaFTP应用程序易于使用且直观。我们将依赖Scala Swing库来实现UI。
- en: 'We will implement the client interface in an abstract `FTPClientFrame` class:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个抽象的`FTPClientFrame`类中实现客户端接口：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the remainder of this section, we augment the `FTPClientFrame` class with
    different UI components. These UI components will enable the end user to interact
    with the client application, and ultimately with the remote server. Therefore,
    we will implement the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的剩余部分，我们将向`FTPClientFrame`类添加不同的UI组件。这些UI组件将使用户能够与客户端应用程序以及远程服务器进行交互。因此，我们将实现以下内容：
- en: A menu bar with common application options
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有常用应用程序选项的菜单栏
- en: A status bar that displays various user notifications, such as the connection
    state, status of the last requested operation, and various error messages
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个状态栏，显示各种用户通知，如连接状态、最后请求的操作状态以及各种错误消息
- en: A pair of file panes that display the path to a specific directory in the filesystem,
    along with its contents, and buttons that start a copy or delete operation
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对文件窗格，显示文件系统中特定目录的路径及其内容，以及启动复制或删除操作的按钮
- en: 'After we are done, the ScalaFTP client program will look like the following
    screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，ScalaFTP客户端程序将类似于以下截图：
- en: '![The client user interface](img/image_09_003.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![客户端用户界面](img/image_09_003.jpg)'
- en: We start by implementing the menu bar. When creating Swing components in our
    UI, we can instantiate an anonymous class that extends a `Menu` or `MenuBar` class,
    and assign it to a local variable. However, using an anonymous class does not
    allow access to its custom members. If the anonymous UI component class contains
    nested components, we are not able to refer to them. Therefore, we will use nested
    singleton objects to instantiate UI components, as doing this allows us to refer
    to the object's nested components.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先实现菜单栏。在创建我们的UI中的Swing组件时，我们可以实例化一个扩展`Menu`或`MenuBar`类的匿名类，并将其分配给局部变量。然而，使用匿名类不允许访问其自定义成员。如果匿名UI组件类包含嵌套组件，我们无法引用它们。因此，我们将使用嵌套单例对象来实例化UI组件，这样做可以让我们引用对象的嵌套组件。
- en: 'In the following code snippet, we create the `menu` singleton object that extends
    the `MenuBar` class. We create the `file` and the `help` menu, with the `exit`
    and `about` menu items, respectively, and take care to add each `Menu` component
    to the `contents` collection of the enclosing component:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们创建了一个扩展`MenuBar`类的`menu`单例对象。我们创建了`file`和`help`菜单，分别带有`exit`和`about`菜单项，并注意将每个`Menu`组件添加到封装组件的`contents`集合中：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Similarly, we implement the `status` object by extending the `BorderPanel`
    class. The `BorderPanel` components are used to hold other nested components:
    in our case, two nested `Label` objects. The anonymous `Label` object always contains
    the static `Status:` text, while the named `Label` object contains arbitrary status
    messages. We place the anonymous `Label` object to the left, and the `Label` object
    with the status messages in the center. This is shown in the following code snippet:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们通过扩展`BorderPanel`类来实现`status`对象。`BorderPanel`组件用于包含其他嵌套组件：在我们的例子中，两个嵌套的`Label`对象。匿名`Label`对象始终包含静态的`Status:`文本，而命名的`Label`对象包含任意状态消息。我们将匿名`Label`对象放置在左侧，将带有状态消息的`Label`对象放置在中间。如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we implement a custom `FilePane` component that displays the contents
    of a directory in the remote filesystem. We will have two `FilePane` instances
    in the client program, so we declare a custom `FilePane` class, which itself extends
    the `BorderPanel` component type:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了一个自定义的`FilePane`组件，用于显示远程文件系统中目录的内容。客户端程序中将有两个`FilePane`实例，因此我们声明一个自定义的`FilePane`类，它本身扩展了`BorderPanel`组件类型：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We hierarchically decompose the `FilePane` class into three parts: the `pathBar`
    component that displays the path to the current directory, the `scrollPane` component
    that allows scrolling through the contents of the current directory, and the `buttons`
    component that contains the copy and delete buttons. In the following code snippet,
    we add a non-editable text field with the current path, and an `upButton` component
    that is used to navigate up the file hierarchy:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`FilePane`类分层分解为三个部分：显示当前目录路径的`pathBar`组件，允许滚动查看当前目录内容的`scrollPane`组件，以及包含复制和删除按钮的`buttons`组件。在下面的代码片段中，我们添加了一个不可编辑的文本字段，用于显示当前路径，以及一个用于在文件层次结构中向上导航的`upButton`组件：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `scrollPane` component contains a `Table` object named `fileTable`. The
    `fileTable` object will contain the columns named `Filename`, `Size`, and `Date
    modified`, and each table row will contain a file or a subdirectory within the
    current working directory. To prevent the user from modifying filenames, sizes,
    or modification dates, we install a custom `TableModel` object that disallows
    editing in every row and column. The complete implementation of the `scrollPane`
    component is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`scrollPane`组件包含一个名为`fileTable`的`Table`对象。`fileTable`对象将包含名为`Filename`、`Size`和`Date
    modified`的列，并且每个表格行将包含当前工作目录中的一个文件或子目录。为了防止用户修改文件名、大小或修改日期，我们安装了一个自定义的`TableModel`对象，该对象禁止在每一行和每一列中进行编辑。`scrollPane`组件的完整实现如下：'
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `buttons` singleton object is a `GridPanel` component with one row and
    two columns. Each column contains a single button, as shown in the following code
    snippet:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`buttons`单例对象是一个具有一行两列的`GridPanel`组件。每个列包含一个单独的按钮，如下面的代码片段所示：'
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We then place these custom components inside the `FilePane` component:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这些自定义组件放置在`FilePane`组件内部：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we add the `parent` directory field and the list of the files in the
    current directory, named `dirFiles`, into the `FilePane` class, as well as a few
    convenience methods to more easily access deeply nested UI components:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`parent`目录字段和当前目录中的文件列表，命名为`dirFiles`，添加到`FilePane`类中，以及一些方便的方法来更容易地访问深层嵌套的UI组件：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Recall that we need one `FilePane` instance on the left-hand side of the client
    program, and another one on the right. We declare the `files` singleton object
    inside the `FTPClientFrame` class to hold the two `FilePane` instances, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们需要在客户端程序的左侧放置一个`FilePane`实例，并在右侧放置另一个。我们在`FTPClientFrame`类内部声明`files`单例对象，以包含两个`FilePane`实例，如下所示：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we need to place the `menu`, `files`, and `status` components at the
    top, center, and bottom of the client program:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将`menu`、`files`和`status`组件放置在客户端程序的上部、中心和底部：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can already run the client program at this point, and try to interact with
    it. Unfortunately, the client program does not do anything yet. Clicking on the
    `FilePane` component, the buttons, or the menu items currently does not have any
    effect, as we have not yet defined callbacks for various UI actions. In the following
    section, we will use Rx to complete the functionality of the client application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经开始运行客户端程序，并尝试与之交互。不幸的是，客户端程序目前还没有任何动作。点击`FilePane`组件、按钮或菜单项目前没有任何效果，因为我们还没有为各种UI动作定义回调函数。在下一节中，我们将使用Rx来完成客户端应用程序的功能。
- en: Implementing the client logic
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现客户端逻辑
- en: 'We are now ready to add some life to the ScalaFTP client program. We will define
    the logic layer in the `FTPClientLogic` trait. We only want to allow mixing in
    the `FTPClientLogic` trait with classes that extend both the `FTPClientFrame`
    class and the `FTPClientApi` trait, as this allows the logic layer to refer to
    both UI components and use the client API. Therefore, we give this trait the self-type
    `FTPClientFrame` class with `FTPClientApi`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备为 ScalaFTP 客户端程序添加一些活力。我们将在 `FTPClientLogic` 特质中定义逻辑层。我们只想允许将 `FTPClientLogic`
    特质与扩展 `FTPClientFrame` 类和 `FTPClientApi` 特质的类混合，因为这允许逻辑层引用 UI 组件并使用客户端 API。因此，我们给这个特质赋予
    `FTPClientFrame` 类和 `FTPClientApi` 的自类型：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Before we begin, recall that the Swing components can only be modified from
    the event-dispatching thread. Similar to how we ensured this using the `swingScheduler`
    object in [Chapter 6](ch06.html "Chapter 6. Concurrent Programming with Reactive
    Extensions"), *Concurrent Programming with Reactive Extensions*, we now introduce
    the `swing` method, which takes a block of code and schedules it for execution
    on the Swing library''s event-dispatching thread:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，回想一下 Swing 组件只能从事件分派线程进行修改。类似于我们在第 6 章 [并发编程与响应式扩展](ch06.html "第 6 章。并发编程与响应式扩展")
    中使用 `swingScheduler` 对象确保这一点的方式，我们现在引入了 `swing` 方法，它接受一段代码并将其调度到 Swing 库的事件分派线程上：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Throughout this section, we will rely on the `swing` method in order to ensure
    that the effect of asynchronous computations occur only on the Swing event-dispatching
    thread.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将依赖 `swing` 方法以确保异步计算的效果仅发生在 Swing 事件分派线程上。
- en: Tip
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The Swing toolkit permits modifying UI components only from the event-dispatching
    thread, but does not ensure this restriction at compile time, and can unexpectedly
    fail during runtime.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Swing 工具包允许仅从事件分派线程修改 UI 组件，但编译时并不确保此限制，并且可能在运行时意外失败。
- en: 'We begin by relating the connection status to the user interface. Recall that
    we introduced the `connected` future as part of the client API. Depending on the
    result of the `connected` future, we either modify the `text` value of the status
    label to display an error message, or report that the client program has successfully
    connected to the server. In the latter case, we call the `refreshPane` method
    to update the contents of the `FilePane` components that we will look at shortly.
    The following code snippet shows the `onComplete` callback:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将连接状态与用户界面相关联。回想一下，我们将 `connected` 未来作为客户端 API 的一部分引入。根据 `connected` 未来的结果，我们要么修改状态标签的
    `text` 值以显示错误消息，要么报告客户端程序已成功连接到服务器。在后一种情况下，我们调用 `refreshPane` 方法来更新我们即将查看的 `FilePane`
    组件的内容。以下代码片段显示了 `onComplete` 回调：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There are two steps involved in updating the `FilePane` component. First, we
    need to get the contents of the remote directory from the server. Second, once
    these contents arrive, we need to refresh the `Table` object in the `FilePane`
    component. In the following code, we call the `getFileList` method from the client
    API, and refresh the `Table` object with the `updatePane` method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `FilePane` 组件涉及两个步骤。首先，我们需要从服务器获取远程目录的内容。其次，一旦这些内容到达，我们需要刷新 `FilePane` 组件中的
    `Table` 对象。在以下代码中，我们调用客户端 API 中的 `getFileList` 方法，并使用 `updatePane` 方法刷新 `Table`
    对象：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `updatePane` method takes the `dir` directory name and the `files` list,
    and uses them to update the `FilePane` component `p`. It extracts the `DefaultTableModel`
    object, and clears its previous contents by setting the row count to `0`. It then
    updates the `parent` field in the `FilePane` object to the parent of the `dir`
    directory.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`updatePane` 方法接收 `dir` 目录名称和 `files` 列表，并使用它们来更新 `FilePane` 组件 `p`。它提取 `DefaultTableModel`
    对象，并通过将行数设置为 `0` 来清除其先前内容。然后，它将 `FilePane` 对象中的 `parent` 字段更新为 `dir` 目录的父目录。'
- en: 'Finally, it stores the `files` list into the `dirFiles` field, and adds a row
    for each entry:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它将 `files` 列表存储到 `dirFiles` 字段中，并为每个条目添加一行：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding method, we relied on the `toRow` method to convert the `FileInfo`
    object into an array of `String` objects, which the `Table` component works with:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们依赖于 `toRow` 方法将 `FileInfo` 对象转换为 `String` 对象数组，这是 `Table` 组件所处理的：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So far, so good! Our client program is able to connect to the server and show
    the contents of the root directory. Next, we need to implement the UI logic that
    allows navigating through the remote filesystem.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利！我们的客户端程序能够连接到服务器并显示根目录的内容。接下来，我们需要实现允许在远程文件系统中导航的 UI 逻辑。
- en: 'When dealing with UI events in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Programming with Reactive Extensions"), *Concurrent Programming with Reactive
    Extensions*, we augmented our UI components with `Observable` objects. Recall
    that we added the `clicks` and `texts` methods in order to process events from
    the `Button` and `TextField` components. In the following code, we augment the
    `Table` component with the `rowDoubleClicks` method, which returns an `Observable`
    object with the indices of the rows that have been double-clicked on:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6 章](ch06.html "第 6 章。使用响应式扩展进行并发编程") 中处理 UI 事件时，我们在 *使用响应式扩展进行并发编程* 中增强了我们的
    UI 组件，添加了 `Observable` 对象。回想一下，我们添加了 `clicks` 和 `texts` 方法来处理来自 `Button` 和 `TextField`
    组件的事件。在下面的代码中，我们通过 `rowDoubleClicks` 方法增强了 `Table` 组件，该方法返回一个包含被双击的行索引的 `Observable`
    对象：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To navigate through the remote filesystem, users need to click on the `FilePane`
    and `upButton` objects. We need to set up this functionality once for each pane,
    so we define the `setupPane` method for this purpose:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在远程文件系统中导航，用户需要点击 `FilePane` 和 `upButton` 对象。我们需要为每个面板设置此功能，因此我们定义 `setupPane`
    方法来达到这个目的：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The first step when reacting to the clicks on the `FilePane` component is mapping
    each user double-click to the name of the file or directory that has been clicked
    on. Then, if the double-clicked file is a directory, we update the current `filePath`
    method, and call the `refreshPane` method:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当对 `FilePane` 组件的点击做出反应时，第一步是将每个用户的双击映射到被点击的文件或目录的名称。然后，如果双击的文件是目录，我们更新当前的 `filePath`
    方法，并调用 `refreshPane` 方法：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Similarly, when the user clicks on the `upButton` component, we call the `refreshPane`
    method to navigate to the parent directory:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当用户点击 `upButton` 组件时，我们调用 `refreshPane` 方法导航到父目录：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Navigating through the remote filesystem is informative, but we also want to
    be able to copy and delete the remote files. This requires reacting to UI button
    clicks, each of which needs to be mapped to the correct, currently selected file.
    The `rowActions` method produces an event stream with the files that were selected
    at the time, at the point when a button was clicked:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程文件系统中导航是有信息的，但我们还希望能够复制和删除远程文件。这需要对 UI 按钮点击做出反应，每个点击都需要映射到正确的当前选定的文件。`rowActions`
    方法生成一个事件流，其中包含在按钮点击时选定的文件：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Clicking on the copy button will copy the selected file to the directory selected
    in the opposite pane. We use the `rowActions` method to map the directory on the
    opposite pane, and call the `copyFile` method from the client API. Recall that
    the `copyFile` method returns a future, so we need to call the `onComplete` method
    to process its result asynchronously:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 点击复制按钮将选定的文件复制到对面面板中选定的目录。我们使用 `rowActions` 方法映射对面面板上的目录，并从客户端 API 调用 `copyFile`
    方法。回想一下，`copyFile` 方法返回一个 future，因此我们需要调用 `onComplete` 方法来异步处理其结果：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We use the `rowActions` method in a similar way, in order to react to clicks
    on the delete button. Finally, we call the `setupPane` method once for each pane:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以类似的方式使用 `rowActions` 方法，以便对删除按钮的点击做出反应。最后，我们为每个面板调用一次 `setupPane` 方法：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Our remote file browser is now fully functional. To test it, we open two separate
    instances of the terminal, and run SBT in our project directory from both the
    terminals. We first run the server program:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们远程文件浏览器现在完全可用。为了测试它，我们打开两个独立的终端实例，并从两个终端在我们的项目目录中运行 SBT。我们首先运行服务器程序：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'By making sure that the server is running on port `12345`, we can run the client
    from the second terminal as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过确保服务器在端口 `12345` 上运行，我们可以从第二个终端运行客户端，如下所示：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, try copying some of our project files between different directories. If
    you've also implemented the delete functionality, make sure that you back up the
    project files before deleting anything, just in case. It's not always a good idea
    to test experimental file-handling utilities on our source code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试在不同目录之间复制一些我们的项目文件。如果你也实现了删除功能，确保在删除任何内容之前备份项目文件，以防万一。在源代码上测试实验性的文件处理工具并不总是好主意。
- en: Improving the remote file browser
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进远程文件浏览器
- en: If you successfully ran both the ScalaFTP server, client programs, and copied
    files around, you might have noticed that, if you delete a file on the disk from
    an external application, such as your source-code editor, the changes will not
    be reflected in the ScalaFTP server program. The reason for this is that the server
    actor does not monitor the filesystem for changes, and the server filesystem layer
    is not updated when we delete the file.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你成功运行了ScalaFTP服务器、客户端程序并复制了文件，你可能已经注意到，如果你从外部应用程序（如你的源代码编辑器）在磁盘上删除文件，这些更改将不会反映在ScalaFTP服务器程序中。原因是服务器actor没有监控文件系统更改，当我们删除文件时，服务器文件系统层没有更新。
- en: 'To account for filesystem changes external to the ScalaFTP server program,
    we need to monitor the filesystem for changes. This sounds like an ideal case
    for event streams. Recall that we already did this in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Programming with Reactive Extensions"), *Concurrent Programming with Reactive
    Extensions*, when we defined the `modified` method to track file modifications.
    This time, we define the `FileCreated`, `FileDeleted`, and `FileModified` types
    to denote three different kinds of filesystem events:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理ScalaFTP服务器程序外部文件系统的更改，我们需要监控文件系统以检测更改。这似乎是一个事件流的理想用例。回想一下，我们在[第6章](ch06.html
    "第6章。使用响应式扩展进行并发编程")中已经做了这件事，即定义了`modified`方法来跟踪文件修改。这次，我们定义了`FileCreated`、`FileDeleted`和`FileModified`类型来表示三种不同的文件系统事件：
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'By implementing the additional methods in the `FileAlterationListener` interface,
    we ensure that the resulting `Observable` object produces any one of the three
    event types. In the following code snippet, we show the relevant part of the `fileSystemEvents`
    method that produces an `Observable[FileEvent]` object with the filesystem events:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现`FileAlterationListener`接口中的额外方法，我们确保生成的`Observable`对象产生三种事件类型中的任何一种。在下面的代码片段中，我们展示了`fileSystemEvents`方法的相关部分，该方法生成一个带有文件系统事件的`Observable[FileEvent]`对象：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now that we have an event stream of file events, we can easily modify the filesystem
    model. We subscribe to the file event stream, and start single-operation transactions
    to update the `fileSystem` transactional map:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了文件事件的流，我们可以轻松地修改文件系统模型。我们订阅文件事件流，并开始单操作事务来更新`fileSystem`事务映射：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now, you can run the server and the client again, and experiment with either
    deleting or copying files in your editor after the server has started. You will
    notice that the filesystem changes are detected on the server, and eventually
    shown when the client is refreshed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以再次运行服务器和客户端，并在服务器启动后，在你的编辑器中尝试删除或复制文件。你会注意到，文件系统更改在服务器上被检测到，并在客户端刷新时最终显示出来。
- en: Note that this example was chosen to illustrate how all the different concurrency
    libraries described in this book work together. However, there is no need to use
    all of these concurrency libraries in every program. In many situations, we only
    need a few different concurrency abstractions. Depending on your programming task,
    you should decide which ones are the best fit.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个例子被选出来是为了说明本书中描述的所有不同并发库是如何协同工作的。然而，在每一个程序中并不需要使用所有这些并发库。在许多情况下，我们只需要几个不同的并发抽象。根据你的编程任务，你应该决定哪些是最合适的。
- en: Tip
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Never over-engineer your concurrent program. Only use those concurrency libraries
    that help you solve your specific programming task.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要过度设计你的并发程序。只使用那些帮助你解决特定编程任务的并发库。
- en: Having studied how to combine different concurrency libraries in a larger application,
    and having caught a glimpse of how to pick the correct concurrency library, we
    turn our attention to another aspect of dealing with concurrency, namely, debugging
    concurrent programs.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究了如何在大型应用程序中组合不同的并发库，并瞥见了如何选择正确的并发库之后，我们将注意力转向处理并发的另一个方面，即调试并发程序。
- en: Debugging concurrent programs
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试并发程序
- en: Concurrent programming is much harder than sequential programming. There are
    multiple reasons for this. First, the details of the memory model are much more
    important in concurrent programming, resulting in increased programming complexity.
    Even on a platform with a well-defined memory model, such as the JVM, the programmer
    must take care to use proper memory access primitives in order to avoid data races.
    Then, it is harder to track the execution of a multithreaded program, simply because
    there are multiple executions proceeding simultaneously. Language debuggers are
    still focused on tracking the execution of a single thread at a time. Deadlocks
    and inherent nondeterminism are another source of bugs, neither of which is common
    in sequential programs. To make things worse, all these issues only have to do
    with ensuring the correctness of a concurrent program. Ensuring improved throughput
    and performance opens a separate set of problems, and is often harder than it
    sounds. Generally, a lot of effort is required to ensure that a concurrent program
    really runs faster, and performance debugging is an art of its own.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程比顺序编程要困难得多。这有多种原因。首先，内存模型的细节在并发编程中更为重要，导致编程复杂性增加。即使在具有明确定义内存模型的平台（如JVM）上，程序员也必须小心使用适当的内存访问原语，以避免数据竞争。然后，跟踪多线程程序的执行更困难，因为存在多个同时进行的执行。语言调试器仍然专注于一次跟踪一个线程的执行。死锁和固有的非确定性是另一个错误来源，这些在顺序程序中并不常见。更糟糕的是，所有这些问题都只与确保并发程序的正确性有关。确保提高吞吐量和性能又打开了一组新的问题，这通常比听起来更难。一般来说，需要付出很多努力才能确保并发程序真正运行得更快，性能调试也是一门艺术。
- en: In this section, we survey some of the typical causes of errors in concurrent
    programs, and inspect different methods of dealing with them. We start with the
    simplest form of concurrency bugs, which are revealed by a lack of progress in
    the system.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们概述了一些并发程序中错误典型原因，并检查了处理它们的不同方法。我们从最简单的并发错误形式开始，这些错误是由系统中缺乏进展而暴露出来的。
- en: Deadlocks and lack of progress
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 死锁和缺乏进展
- en: Despite the scariness typically associated with the term deadlock, when it comes
    to debugging concurrent programs, deadlocks are one of the more benevolent forms
    of concurrency bugs you will encounter. The reason for this is that deadlocks
    are easy to track down and analyze. In this section, we study how to identify
    and resolve a deadlock in a concurrent program.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通常与死锁一词相关的恐怖感，但在调试并发程序时，死锁是你将遇到的一种更为温和的并发错误形式。原因在于死锁易于追踪和分析。在本节中，我们研究如何在并发程序中识别和解决死锁。
- en: 'Before we begin, we will make sure that SBT starts the example programs in
    a separate JVM process. To do this, we enter the following command into the SBT
    interactive shell:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们将确保SBT在单独的JVM进程中启动示例程序。为此，我们将以下命令输入到SBT交互式shell中：
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In [Chapter 2](ch02.html "Chapter 2. Concurrency on the JVM and the Java Memory
    Model"), *Concurrency on the JVM and the Java Memory Model*, we discussed at length
    what deadlocks are and why they occur. Here, we recall the bank account example
    introduced in that chapter, which is a canonical example of a deadlock. The bank
    account example consisted of an `Account` class and the `send` method, which locks
    two `Account` objects, and transfers a certain amount of money between them:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。JVM和Java内存模型中的并发")《JVM和Java内存模型中的并发》中，我们详细讨论了死锁是什么以及为什么会出现。在这里，我们回顾了该章节中引入的银行账户示例，这是一个死锁的典型示例。银行账户示例包括一个`Account`类和`send`方法，该方法锁定两个`Account`对象，并在它们之间转移一定数量的金额：
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A deadlock nondeterministically occurs when we simultaneously make an attempt
    to transfer money from account `a` to account `b`, and vice versa, as shown in
    the following code snippet:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们同时尝试从账户`a`向账户`b`转账，反之亦然时，死锁非确定性地发生，如下面的代码片段所示：
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding snippet, we are using the `thread` method for the thread creation
    from [Chapter 2](ch02.html "Chapter 2. Concurrency on the JVM and the Java Memory
    Model"), *Concurrency on the JVM and the Java Memory Model*. This program never
    completes, as the `t1` and `t2` threads get suspended in the deadlock state. In
    a larger program, this effect manifests itself as a lack of response. When a concurrent
    program fails to produce a result or an end, this is a good indication that part
    of it is in the deadlock state.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用`thread`方法创建线程，来自[第2章](ch02.html "第2章。JVM和Java内存模型上的并发")，*JVM和Java内存模型上的并发*。这个程序永远不会完成，因为`t1`和`t2`线程在死锁状态下被挂起。在一个更大的程序中，这种效果表现为缺乏响应。当一个并发程序无法产生结果或结束，这是一个很好的迹象，表明其中一部分处于死锁状态。
- en: Usually, the most difficult part in debugging a deadlock is localizing it. While
    this is easy to determine in our simple example, it is much harder in a larger
    application. However, a defining feature of a deadlock is the lack of any progress,
    and we can use this to our advantage to determine its cause; we simply need to
    find the threads that are in a blocked state, and determine their stack-traces.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，调试死锁中最困难的部分是定位它。虽然在我们简单的例子中这很容易确定，但在更大的应用程序中则要困难得多。然而，死锁的一个定义特征是没有任何进展，我们可以利用这一点来找到其原因；我们只需要找到处于阻塞状态的线程，并确定它们的堆栈跟踪。
- en: 'The Java VisualVM tool, which comes bundled with newer JDK distributions, is
    the simplest way to determine the state of the running Scala and Java applications.
    Without exiting our deadlocked program, we run the `jvisualvm` program from another
    terminal instance as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Java VisualVM工具，它是随新JDK发行版捆绑的，是确定运行中的Scala和Java应用程序状态的最简单方法。在不退出死锁程序的情况下，我们可以在另一个终端实例中运行`jvisualvm`程序，如下所示：
- en: '[PRE52]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Once run, the Java VisualVM application shows all the active JVM processes
    on the current machine. In the following screenshot, the Java VisualVM application
    shows us the SBT process, our deadlock example program, and VisualVM itself, as
    the running instances:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后，Java VisualVM应用程序显示当前机器上所有活动的JVM进程。在下面的截图中，Java VisualVM应用程序显示了SBT进程、我们的死锁示例程序以及VisualVM本身，作为运行实例：
- en: '![Deadlocks and lack of progress](img/image_09_004.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![死锁和缺乏进展](img/image_09_004.jpg)'
- en: 'After clicking on the example process, we get the report shown in the following
    screenshot:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 点击示例进程后，我们得到以下截图所示的报告：
- en: '![Deadlocks and lack of progress](img/image_09_005.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![死锁和缺乏进展](img/image_09_005.jpg)'
- en: The preceding screenshot shows that there are multiple threads running inside
    the example process. Most of these threads are part of the virtual machine runtime,
    and not under the direct control of the programmer. Other threads, such as **main**,
    **Thread-0**, and **Thread-1** are created by our program.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示，示例进程中运行着多个线程。其中大部分线程是虚拟机运行时的一部分，并不在程序员的直接控制之下。其他线程，如**main**、**Thread-0**和**Thread-1**，是由我们的程序创建的。
- en: To determine the cause of the deadlock, we need to inspect the threads in the
    `BLOCKED` state. By examining their stack-traces, we can determine the cycle that
    is causing the deadlock. In this case, Java VisualVM was smart enough to automatically
    determine the cause of the deadlock, and displays the deadlocked threads with
    the red bar.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定死锁的原因，我们需要检查处于`BLOCKED`状态的线程。通过检查它们的堆栈跟踪，我们可以确定导致死锁的循环。在这种情况下，Java VisualVM足够智能，可以自动确定死锁的原因，并用红色条显示死锁的线程。
- en: 'After clicking on the **Thread Dump** button, Java VisualVM displays the stack
    traces of all the threads, as shown in the following screenshot:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**线程转储**按钮后，Java VisualVM显示所有线程的堆栈跟踪，如下面的截图所示：
- en: '![Deadlocks and lack of progress](img/image_09_006.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![死锁和缺乏进展](img/image_09_006.jpg)'
- en: The stack traces in the preceding screenshot tell us exactly where in the program
    the threads are blocked, and why. Both **Thread-0** and **Thread-1** threads are
    suspended in line 15 of the `Debugging.scala` file. Inspecting these lines of
    code in our editor reveals that both the threads are blocked on the nested `synchronized`
    statement. We now know that the cause of the deadlock is the inverted locking
    order in the `send` method.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图中的堆栈跟踪告诉我们线程在程序中的阻塞位置以及原因。**Thread-0**和**Thread-1**线程都在`Debugging.scala`文件的第15行挂起。在我们的编辑器中检查这些代码行揭示，两个线程都阻塞在嵌套的`synchronized`语句上。我们现在知道死锁的原因是`send`方法中的锁定顺序颠倒。
- en: We've already discussed how to deal with this type of a deadlock in [Chapter
    2](ch02.html "Chapter 2. Concurrency on the JVM and the Java Memory Model"), *Concurrency
    on the JVM and the Java Memory Model*. Enforcing a locking order in the `send`
    method is a textbook example of dealing with deadlocks, and is easy to ensure
    by assigning unique identifiers to different locks.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第2章](ch02.html "第2章。JVM和Java内存模型上的并发")中讨论了如何处理这种类型的死锁，*JVM和Java内存模型上的并发*。在`send`方法中强制执行锁定顺序是处理死锁的教科书式例子，通过为不同的锁分配唯一标识符可以轻松确保。
- en: In some cases, we are not able to enforce the locking order to avoid deadlocks.
    For example, in [Chapter 3](ch03.html "Chapter 3. Traditional Building Blocks
    of Concurrency"), *Traditional Building Blocks of Concurrency*, we learned that
    the lazy values initialization implicitly calls the `synchronized` statement without
    our control. There, we eluded deadlocks by avoiding the explicit `synchronized`
    statements on the object enclosing the lazy value. Another way of preventing deadlocks
    is to avoid blocking when a resource is not available. In [Chapter 3](ch03.html
    "Chapter 3. Traditional Building Blocks of Concurrency"), *Traditional Building
    Blocks of Concurrency*, we learned that custom locks can return an error value,
    letting the rest of the program decide how to proceed if a lock is not available.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们无法强制执行锁定顺序以避免死锁。例如，在[第3章](ch03.html "第3章。并发传统的构建块")中，*并发传统的构建块*，我们了解到懒值初始化隐式调用`synchronized`语句，而未经我们的控制。在那里，我们通过在包含懒值的对象上避免显式`synchronized`语句来规避死锁。防止死锁的另一种方法是当资源不可用时避免阻塞。在[第3章](ch03.html
    "第3章。并发传统的构建块")中，*并发传统的构建块*，我们了解到自定义锁可以返回一个错误值，如果锁不可用，程序的其他部分可以决定如何继续。
- en: Besides deadlocks, there are other kinds of concurrency bugs that are associated
    with a lack of progress. We've already seen examples of **starvation**, in which
    a concurrent computation is denied access to the required resources. In [Chapter
    4](ch04.html "Chapter 4.  Asynchronous Programming with Futures and Promises"),
    *Asynchronous Programming with Futures and Promises*, we started many futures
    simultaneously, and suspended them by calling the `sleep` method. As a result,
    the thread-pool underlying the `ExecutionContext` object became exhausted, and
    no additional futures could execute until the `sleep` method returned.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 除了死锁之外，还存在其他类型的并发错误，这些错误与缺乏进展有关。我们已经看到了**饥饿**的例子，其中并发计算被拒绝访问所需的资源。在[第4章](ch04.html
    "第4章。使用Future和Promise进行异步编程")中，*使用Future和Promise进行异步编程*，我们同时启动了许多future，并通过调用`sleep`方法挂起它们。结果，`ExecutionContext`对象背后的线程池耗尽了，直到`sleep`方法返回，没有更多的future可以执行。
- en: In a **livelock**, different concurrent computations are not suspended, and
    constantly change their state, but are unable to make progress. A livelock is
    akin to the situation in which two people approach each other on the street, and
    constantly try to move to the opposite side in order to allow the other person
    to pass. As a result, neither person moves on, and they constantly move from one
    side to the other. What is common to these kinds of errors is that the system
    makes no or very little progress, making them easy to identify.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在**活锁**中，不同的并发计算没有被挂起，并且不断改变它们的状态，但无法取得进展。活锁类似于两个人在街上相遇，并不断试图移动到对面以允许对方通过的情况。结果，两个人都没有移动，他们不断地从一个方向移动到另一个方向。这些错误类型的共同之处在于系统几乎没有或几乎没有进展，这使得它们很容易识别。
- en: Looking for a deadlock is like hunting for a dead animal. Since it implies no
    progress, a deadlock is tracked down more easily than other kinds of concurrency
    bugs. In the following section, we will study a more malevolent class of concurrency
    errors that manifest themselves through incorrect program outputs.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找死锁就像寻找一只死动物。因为它意味着没有进展，所以死锁比其他类型的并发错误更容易追踪。在下一节中，我们将研究一类更恶意的并发错误，这些错误通过错误的程序输出表现出来。
- en: Debugging incorrect program outputs
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试程序输出错误
- en: In this section, we study a broader range of concurrency bugs that manifest
    themselves as incorrect outputs of the program. Generally, these kinds of errors
    are harder to track, because their effects become apparent long after the actual
    error took place. A real-world example of such an error is a piece of broken glass
    lying on the road. You don't see the glass when you drive your car, and accidentally
    run over it. By the time your tire runs flat and you realize what happened, it
    is difficult to figure out where exactly along the road the glass was.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们研究了一类更广泛的并发错误，这些错误表现为程序的不正确输出。通常，这类错误更难追踪，因为它们的影响在错误实际发生很久之后才会显现。一个现实世界的例子是在路上的一块破碎的玻璃。当你开车时，你看不到玻璃，不小心就会压到它。等到你的轮胎瘪了，你意识到发生了什么，这时很难确定玻璃在路上的确切位置。
- en: There are two main ways in which an error can appear. First, the concurrent
    program can consistently produce the same erroneous outputs. When this happens,
    we can consider ourselves lucky, as we are able to consistently reproduce the
    error to study it. Conversely, the incorrect output might appear only occasionally,
    in some executions of the program. This is a much less desired situation. A buggy
    concurrent program might exhibit incorrect behavior only occasionally due to its
    inherent nondeterminism. We will look at both deterministic and nondeterministic
    errors in the rest of the section.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 出错的方式主要有两种。首先，并发程序可以持续产生相同的错误输出。当这种情况发生时，我们可以认为自己很幸运，因为我们能够持续地重现错误以便研究。相反，错误输出可能只偶尔出现，在某些程序的执行中。这是一个不太理想的情况。一个有缺陷的并发程序可能由于其固有的非确定性，偶尔才会表现出错误行为。在本节的剩余部分，我们将探讨确定性和非确定性错误。
- en: 'The goal of this section will be to implement the `fold` method on futures.
    Given a sequence of future objects, a zero value, and the `folding` operator,
    the `fold` method will return a future object with the `folding` operator that
    is applied between all the values. We will require the `folding` operator to be
    commutative, associative, and without side effects. The `fold` method will closely
    correspond to the `foldLeft` method on collections. The signature of the `fold`
    method on futures will be as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是实现未来的`fold`方法。给定一个未来对象的序列、一个零值和`folding`操作符，`fold`方法将返回一个应用了`folding`操作符之间的所有值的未来对象。我们将要求`folding`操作符是交换律、结合律和无副作用的。`fold`方法将与集合上的`foldLeft`方法紧密对应。未来上的`fold`方法的签名如下：
- en: '[PRE53]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'One use case for the `fold` method is to compute the sum of the values in many
    different future objects, which cannot be done directly with the `foldLeft` method
    on collections. This is illustrated in the following code snippet:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`fold`方法的一个用例是计算许多不同未来对象中的值的总和，这不能直接通过集合上的`foldLeft`方法完成。以下代码片段展示了这一点：'
- en: '[PRE54]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We will implement the `fold` method in two steps. First, we will accumulate
    the values from all the values in the `fs` sequence by applying the `op` operator
    on them. Accumulating the values will give us the accumulation value of the resulting
    future. Then, after all the futures complete, we will complete the resulting future
    with the accumulation value.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两步实现`fold`方法。首先，我们将通过应用`op`操作符对所有`fs`序列中的值进行累积，从而从所有值中累积值。累积值将给出结果的未来的累积值。然后，在所有未来完成之后，我们将使用累积值完成结果未来。
- en: 'We start by implementing several basic concurrency abstractions that will help
    us implement the `fold` method. A **concurrent accumulator** is a concurrency
    facility that allows you to keep track of an accumulation of values. Here, the
    values can be integers, and the accumulation can be their sum. A concurrent accumulator
    comes with the `add` method that is used to add new values, and the `apply` method
    that is used to obtain the current state of the accumulation. We present the simplest
    possible lock-free implementation of a concurrent accumulator, which uses atomic
    variables from [Chapter 3](ch03.html "Chapter 3. Traditional Building Blocks of
    Concurrency"), *Traditional Building Blocks of Concurrency*. The `Accumulator`
    class takes the type `T` of the accumulation, a `z` initial value, and an `op`
    reduction operator, and is shown in the following code snippet:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先实现几个基本的并发抽象，这将帮助我们实现`fold`方法。**并发累加器**是一种并发设施，允许你跟踪值的累积。在这里，值可以是整数，累积可以是它们的和。并发累加器包含一个`add`方法，用于添加新值，以及一个`apply`方法，用于获取累积的当前状态。我们展示了并发累加器的最简单可能的无锁实现，它使用了来自[第3章](ch03.html
    "第3章。并发传统的构建块")，*并发传统的构建块*中的原子变量。`Accumulator`类接受累积的类型`T`，一个初始值`z`，以及一个`op`归约操作符，并在以下代码片段中展示：
- en: '[PRE55]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `Accumulator` implementation has a private atomic variable, named `value`,
    initialized with the `z` value, and is used to track the value of the accumulation.
    The `apply` method is easy to implement; we simply call the linearizable `get`
    method to obtain the current accumulation value. The `add` method must use the
    `compareAndSet` operation to atomically update the accumulation. Here, we read
    the `ov` current value of the atomic variable, call the `op` operator to compute
    the new `nv` accumulation value, and, finally, call the `compareAndSet` operation
    to replace the old `ov` accumulation value with the new `nv` value. If the `compareAndSet`
    operation returns `false`, then the accumulation was modified, as it was previously
    read, and the tail-recursive `add` operation must be retried. We studied this
    technique at length in [Chapter 3](ch03.html "Chapter 3. Traditional Building
    Blocks of Concurrency"), *Traditional Building Blocks of Concurrency*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`Accumulator`实现有一个名为`value`的私有原子变量，初始化为`z`值，用于跟踪累积的值。`apply`方法易于实现；我们只需调用可线性化的`get`方法来获取当前的累积值。`add`方法必须使用`compareAndSet`操作来原子地更新累积。在这里，我们读取原子变量的当前值`ov`，调用`op`操作符来计算新的累积值`nv`，最后调用`compareAndSet`操作来用新的`nv`值替换旧的累积值`ov`。如果`compareAndSet`操作返回`false`，则累积已被修改，因为它之前已被读取，并且尾递归的`add`操作必须重试。我们在[第3章](ch03.html
    "第3章。并发传统的构建块")，*并发传统的构建块*中详细研究了这项技术。'
- en: Note that, because of the retries, the `op` operator can be invoked multiple
    times with the same `v` argument. Therefore, our lock-free concurrent accumulator
    implementation only works correctly with a reduction operator that is free from
    side effects.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于重试，`op`操作符可以多次用相同的`v`参数调用。因此，我们的无锁并发累加器实现仅适用于没有副作用的重减操作符。
- en: 'Next, we will need a facility that allows different futures to synchronize.
    A **countdown latch** is a synchronization primitive that performs a specific
    action once a specified number of threads agree that the action can be performed.
    Our `CountDownLatch` class takes the number of threads `n`, and an `action` block.
    The latch keeps an atomic integer variable, named `left`, with the current countdown
    value, and defines a `count` method, which decreases the value of the `left` atomic
    variable. After `n` calls of the `count` method, the `action` block is invoked
    once. This is shown in the following code snippet:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个允许不同未来同步的设施。**倒计时闩锁**是一种同步原语，当指定数量的线程同意可以执行该操作时，它执行特定的动作。我们的`CountDownLatch`类接受线程数`n`和一个`action`块。闩锁保持一个名为`left`的原子整数变量，具有当前的倒计时值，并定义了一个`count`方法，它减少`left`原子变量的值。在调用`count`方法`n`次之后，`action`块被调用一次。这在上面的代码片段中展示：
- en: '[PRE56]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We now have all the prerequisites for implementing the `fold` method. This
    method needs to return a future object, so we start by instantiating a promise
    object. The promise will enable us to return the future object corresponding to
    the promise. We have seen this pattern many times in [Chapter 4](ch04.html "Chapter 4. 
    Asynchronous Programming with Futures and Promises"), *Asynchronous Programming
    with Futures and Promises*. Next, we need some way of combining the values from
    the different futures, so we instantiate an `Accumulator` object with the initial
    `z` value and the `op` reduction operator. We can complete the promise with the
    value of the accumulator only after all the futures complete, so we create a countdown
    latch with the countdown value set to the number of the futures. The action associated
    with the countdown latch completes the promise with the value of the accumulator,
    and we decide to use the `trySuccess` method for this purpose. Finally, we need
    to install callbacks on all the futures, which update the accumulator, and then
    call the `count` method on the latch. The complete implementation of the `fold`
    method is shown in the following code snippet:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经具备了实现`fold`方法的先决条件。这个方法需要返回一个future对象，因此我们首先实例化一个promise对象。这个promise将使我们能够返回与promise对应的future对象。我们在[第4章](ch04.html
    "第4章。使用Future和Promise进行异步编程")中多次看到了这种模式，*使用Future和Promise进行异步编程*。接下来，我们需要一种方法来组合来自不同future的值，因此我们实例化了一个带有初始`z`值和`op`累加操作符的`Accumulator`对象。只有当所有future都完成时，我们才能用累加器的值来完成promise，因此我们创建了一个倒计时闩锁，其倒计时值设置为future的数量。与倒计时闩锁关联的操作将使用累加器的值来完成promise，我们决定为此使用`trySuccess`方法。最后，我们需要在所有future上安装回调，这些回调会更新累加器，然后调用闩锁的`count`方法。`fold`方法的完整实现如以下代码片段所示：
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you paid close attention, you might have noticed that we deliberately introduced
    an error somewhere in the `fold` implementation. Don''t worry if you did not notice
    this error yet, as we will now analyze how the error manifests itself, and how
    to identify it. To test the `fold` method, we run the following example program:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你可能会注意到我们在`fold`实现中故意引入了一个错误。如果你还没有注意到这个错误，请不要担心，因为我们现在将分析错误是如何表现出来的，以及如何识别它。为了测试`fold`方法，我们运行以下示例程序：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: On our machine, running this program prints the correct value `10`. We already
    feel confident that we implemented the program correctly, but we run the program
    again, just to be sure. This time, however, the program outputs the value `7`.
    It turns out that we have a bug in our implementation of the `fold` method. Even
    worse, the bug manifests itself nondeterministically!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的机器上，运行此程序会打印出正确的值`10`。我们已经有信心认为我们正确实现了程序，但我们再次运行程序，只是为了确保。然而，这次程序输出的值是`7`。结果证明我们在`fold`方法的实现中有一个错误。更糟糕的是，这个错误是非确定性地表现出来的！
- en: In sequential programming, the normal response would be to use the debugger,
    and proceed stepwise through the program, until we reach the buggy behavior. In
    concurrent programming, this approach often does not help. By tracking the progress
    of one thread in the debugger, we are arbitrarily delaying it, and changing the
    execution schedule of the program. The bug appears nondeterministically, so it
    might not appear when we run the program in the debugger.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在顺序编程中，正常的反应是使用调试器，逐步通过程序，直到我们达到有问题的行为。在并发编程中，这种方法通常没有帮助。通过在调试器中跟踪一个线程的进度，我们任意地延迟了它，并改变了程序的执行计划。错误是非确定性地出现的，所以我们可能不会在调试器中运行程序时看到它。
- en: 'Instead of going forward through the program, to find the culprit, we work
    our way backwards through the code. The future is completed with the incorrect
    value, meaning that some thread must have inserted the incorrect value into the
    corresponding promise. We should insert a breakpoint at the promise completion
    point and observe what happens. To keep things simple, we avoid using the debugger,
    and insert a simple `println` statement to track the value with which the promise
    is completed:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是通过程序向前查找问题所在，而是通过代码向后工作。future以错误的值完成，这意味着某个线程一定在相应的promise中插入了错误的值。我们应该在promise完成点设置断点，并观察发生了什么。为了保持简单，我们避免使用调试器，并插入一个简单的`println`语句来跟踪promise完成的值：
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Running the program again gives the following output:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行程序会得到以下输出：
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This reveals a surprising fact: the promise is, in fact, completed twice. The
    first time, some thread uses the value `8` of the accumulator, and the second
    time, another thread uses the value `10`. This also means that the `action` block
    of the countdown latch was called twice, so we need to find out why. We therefore
    modify the `count` method in order to track when the `action` block is called:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这揭示了令人惊讶的事实：实际上，承诺被完成了两次。第一次，某个线程使用了累加器的值`8`，第二次，另一个线程使用了值`10`。这也意味着倒计时闩锁的`action`块被调用了两次，因此我们需要找出原因。因此，我们修改了`count`方法以跟踪何时调用`action`块：
- en: '[PRE61]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The program output now shows the following content:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 程序输出现在显示以下内容：
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It appears that the `action` block is called not only on the last decrement,
    but also on one before the last. This is because the `decrementAndGet` method
    first decrements the atomic integer, and then returns its value, rather than the
    other way around. The way to fix this is to either call the `getAndDecrement`
    method, or change the `if` statement. We reimplement the `count` method as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来`action`块不仅在最后一次递减时被调用，还在最后一次之前被调用。这是因为`decrementAndGet`方法首先递减原子整数，然后返回其值，而不是相反。修复这个问题的方法是调用`getAndDecrement`方法，或者更改`if`语句。我们重新实现了`count`方法如下：
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Note that, if we had used the `success` method in place of `trySuccess`, we
    would have learned about the error much earlier. Let''s change the implementation
    of the `action` block in the `fold` method to use the `success` method:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们用`success`方法代替`trySuccess`，我们就会更早地了解到错误。让我们将`fold`方法中`action`块的实现更改为使用`success`方法：
- en: '[PRE64]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Running the program with this change, and the previously incorrect `count`
    method, results in the following exception:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个更改和之前不正确的`count`方法运行程序，导致以下异常：
- en: '[PRE65]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This is much better. The output of the program is incorrect, but the exception
    consistently occurs each time that the program is run. Along with the cause of
    the error, we consistently get a full stack-trace to quickly determine where the
    error has occurred. We say that the error occurs deterministically.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这要好得多。程序的输出是不正确的，但异常在每次程序运行时都会一致发生。除了错误的原因外，我们还会得到完整的堆栈跟踪，以便快速确定错误发生的位置。我们说错误是确定性发生的。
- en: Recall that, in [Chapter 4](ch04.html "Chapter 4.  Asynchronous Programming
    with Futures and Promises"), *Asynchronous Programming with Futures and Promises*,
    we used the `tryComplete` method to implement the `or` combinator on futures.
    This combinator was inherently nondeterministic, so we were forced to use the
    `tryComplete` method. However, there is no need to use any of the `tryXYZ` methods
    in the `fold` implementation, as the `fold` method should always return a future
    with the same result. Wherever possible, you should use the `complete`, `success`,
    and `failure` methods in place of the `tryComplete`, `trySuccess`, and `tryFailure`
    methods. More generally, always strive for deterministic semantics, unless the
    program itself is inherently nondeterministic.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在[第4章](ch04.html "第4章。使用未来和承诺进行异步编程")中，*使用未来和承诺进行异步编程*，我们使用了`tryComplete`方法来实现未来的`or`组合器。这个组合器本质上是非确定性的，因此我们被迫使用`tryComplete`方法。然而，在`fold`实现中不需要使用任何`tryXYZ`方法，因为`fold`方法应该始终返回相同结果的未来。在可能的情况下，你应该使用`complete`、`success`和`failure`方法来代替`tryComplete`、`trySuccess`和`tryFailure`方法。更普遍地说，总是努力追求确定性语义，除非程序本身本质上是非确定性的。
- en: Tip
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Program defensively: check for consistency violations often, prefer determinism,
    and fail at an early stage. This simplifies the debugging process when program
    errors arise.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 防御性编程：经常检查一致性违规，优先考虑确定性，并在早期阶段失败。这样当程序出现错误时，可以简化调试过程。
- en: In the following section, we turn to a different correctness aspect in concurrent
    programs, namely, testing their performance.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将转向并发程序中不同的正确性方面，即测试其性能。
- en: Performance debugging
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能调试
- en: When it comes to performance debugging, the field is virtually endless. A separate
    book on the subject would barely scratch the surface. The goal of this section
    is to show you two basic examples that will teach you the basics of analyzing
    and resolving performance problems in concurrent Scala programs.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到性能调试时，这个领域几乎是无限的。关于这个主题的单独一本书也几乎触及不到表面。本节的目标是展示两个基本示例，这些示例将教会你分析并解决并发Scala程序中性能问题的基本知识。
- en: In recent years, processor clock rates have reached a limit, and processor vendors
    have struggled to improve single processor performance. As a consequence, multicore
    processors have overwhelmed the consumer market. Their main goal is to offer increased
    performance by increasing parallelism. Ultimately, the goal of concurrent and
    parallel computing is to increase the program performance.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，处理器时钟频率已达到极限，处理器供应商一直在努力提高单处理器性能。因此，多核处理器已经占据了消费市场。它们的主要目标是通过增加并行性来提高性能。最终，并发和并行计算的目标是提高程序性能。
- en: There are two ways in which program performance can be improved. The first is
    through optimizing the program, so that its sequential instance runs as fast as
    possible. The second approach is to run parts of the program in parallel. In concurrent
    and parallel computing, both approaches are key to achieving optimal performance.
    It does not make sense to parallelize a program that is much slower than the optimal
    sequential program.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 提高程序性能有两种方式。第一种是通过优化程序，使其顺序实例尽可能快地运行。第二种方法是在程序的部分并行运行。在并发和并行计算中，这两种方法都是实现最佳性能的关键。将一个比最佳顺序程序慢得多的程序并行化是没有意义的。
- en: Thus, we will study both, how to optimize, and how to parallelize a concurrent
    program. We will start with a single-threaded version of the program that uses
    a concurrent accumulator, and ensure that it runs efficiently. Then, we will ensure
    that the program is also scalable, that is, adding additional processors makes
    it faster.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将研究如何优化和并行化一个并发程序。我们将从一个使用并发累加器的单线程程序版本开始，并确保它运行得高效。然后，我们将确保程序也是可扩展的，也就是说，添加额外的处理器可以使它更快。
- en: The first step in debugging the performance of a parallel program is to measure
    its running time. As stated in [Chapter 5](ch05.html "Chapter 5. Data-Parallel
    Collections"), *Data-Parallel Collections*, benchmarking the program performance
    is the only principled way of knowing how fast the program is and finding its
    bottlenecks. This task can be complicated on the JVM, due to effects such as garbage
    collection, JIT compilation, and adaptive optimizations.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 调试并行程序性能的第一步是测量其运行时间。如[第5章](ch05.html "第5章。数据并行集合")所述，*数据并行集合*，基准测试程序性能是唯一的原则方法，可以了解程序有多快，并找到其瓶颈。由于垃圾收集、JIT编译和自适应优化等影响，此任务在JVM上可能很复杂。
- en: 'Fortunately, the Scala ecosystem comes with a tool called ScalaMeter, which
    is designed to easily test the performance of both Scala and Java programs. The
    ScalaMeter tool can be used in two ways. First, ScalaMeter allows defining performance
    regression tests, which are essentially unit tests for performance. Second, ScalaMeter
    allows inline benchmarking that is used to benchmark parts of the running application.
    In this section, we will keep things simple, and only use ScalaMeter''s inline
    benchmarking feature. We add the following line to our `build.sbt` file:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Scala生态系统自带一个名为ScalaMeter的工具，该工具旨在轻松测试Scala和Java程序的性能。ScalaMeter工具可以有两种使用方式。首先，ScalaMeter允许定义性能回归测试，这本质上是对性能的单元测试。其次，ScalaMeter允许内联基准测试，用于基准测试运行中的应用程序的部分。在本节中，我们将保持简单，仅使用ScalaMeter的内联基准测试功能。我们在`build.sbt`文件中添加以下行：
- en: '[PRE66]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To use ScalaMeter inside our programs, we need to import the following package:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要在程序中使用ScalaMeter，我们需要导入以下包：
- en: '[PRE67]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This package gives us access to the `measure` statement that is used to measure
    various performance metrics. By default, this method measures the running time
    of a snippet of code. Let''s use it to measure how long it takes to add one million
    integers to the `Accumulator` object defined in the preceding section:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此包为我们提供了访问`measure`语句的权限，该语句用于测量各种性能指标。默认情况下，此方法测量代码片段的运行时间。让我们用它来测量将一百万个整数添加到上一节中定义的`Accumulator`对象所需的时间：
- en: '[PRE68]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Printing the `time` value gives us the following output:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 打印`time`值会给出以下输出：
- en: '[PRE69]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: From this, we might conclude that adding one million integers takes approximately
    34 milliseconds. However, this conclusion is wrong. As discussed in [Chapter 5](ch05.html
    "Chapter 5. Data-Parallel Collections"), *Data-Parallel Collections*, after a
    JVM program is run, it goes through a warm-up phase. The program usually achieves
    the best possible performance only after the warm-up phase is completed. To measure
    the relevant running time more accurately, we need to first ensure that the JVM
    reached stable performance.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点，我们可能会得出结论，添加一百万个整数大约需要34毫秒。然而，这个结论是错误的。如[第5章](ch05.html "第5章。数据并行集合")中所述，在JVM程序运行后，它会经过一个预热阶段。程序通常只有在预热阶段完成后才能达到最佳性能。为了更准确地测量相关运行时间，我们首先需要确保JVM达到了稳定性能。
- en: 'The good news is that ScalaMeter can do this automatically. In the following
    code, we configure the `measure` call to use the default warmer implementation,
    called `Warmer.Default`. We set several configuration parameters, such as the
    minimum number of warm-up runs, the maximum number of warm-up runs, and the number
    of benchmark runs that are used to compute the average running time. Finally,
    we set the `verbose` key to `true` in order to get more logging output about ScalaMeter''s
    execution. This is shown in the following code snippet:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是ScalaMeter可以自动完成这项操作。在下面的代码中，我们配置了`measure`调用以使用默认的预热实现，称为`Warmer.Default`。我们设置了几个配置参数，例如预热运行的最小次数、最大次数以及用于计算平均运行时间的基准运行次数。最后，我们将`verbose`键设置为`true`，以便获取更多关于ScalaMeter执行的日志输出。这在上面的代码片段中显示：
- en: '[PRE70]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'When running this, make sure that there are no active applications running
    in the background on your computer. Running this snippet of code gives us the
    following output:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码时，请确保您的计算机上没有运行任何后台应用程序。运行此代码片段给我们以下输出：
- en: '[PRE71]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We can now see how the running time changes during the warm-up runs. Eventually,
    ScalaMeter detects a steady state and outputs the running time. We now have a
    value of `17.24` milliseconds, which is a good estimate.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到预热运行期间运行时间的变化。最终，ScalaMeter检测到一个稳定状态并输出了运行时间。我们现在有一个`17.24`毫秒的值，这是一个很好的估计。
- en: A closer inspection of the ScalaMeter output reveals that, occasionally, a **Garbage
    Collection** (**GC**) cycle occurs. These GC cycles appear periodically during
    the execution of our code snippet, so we conclude that something in the `add`
    method allocates heap objects. However, the `add` implementation does not contain
    any `new` statements. The object allocation must be happening implicitly somehow.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查ScalaMeter的输出，我们发现偶尔会发生**垃圾回收**（**GC**）周期。这些GC周期在我们的代码片段执行期间定期出现，因此我们得出结论，`add`方法中某个地方分配了堆对象。然而，`add`实现中不包含任何`new`语句。对象分配必须以某种方式隐式发生。
- en: Note that the `Accumulator` class is generic. It takes a `T` type parameter,
    which denotes the type of the accumulation. Scala allows using both the reference
    types, such as `String` or `Option`, and primitive types, such as `Int` or `Long`,
    as class-type parameters. Although this conveniently allows treating both the
    primitive and reference types in the same way, it has the unfortunate side effect
    that the primitive values passed to generic classes are converted into heap objects.
    This process is known as auto-boxing, and it hurts the performance in various
    ways. First, it is much slower than just passing a primitive value. Second, it
    causes GC cycles more frequently. Third, it affects cache-locality and might cause
    memory contention. In the case of the `Accumulator` class, each time we call the
    `add` method with a `Long` value, a `java.lang.Long` object is created on the
    heap.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Accumulator`类是泛型的。它接受一个`T`类型参数，表示累加的类型。Scala允许使用引用类型，如`String`或`Option`，以及原始类型，如`Int`或`Long`，作为类类型参数。虽然这方便地将原始类型和引用类型以相同的方式处理，但它有一个不幸的副作用，即传递给泛型类的原始值会被转换为堆对象。这个过程被称为自动装箱，它会以各种方式影响性能。首先，它比仅仅传递一个原始值要慢得多。其次，它会导致GC周期更频繁。第三，它会影响缓存局部性，并可能导致内存竞争。在`Accumulator`类的情况下，每次我们用`Long`值调用`add`方法时，都会在堆上创建一个`java.lang.Long`对象。
- en: 'In practice, boxing is sometimes problematic, and sometimes not. Generally,
    it should be avoided in high-performance code. In our case, we can avoid boxing
    by creating an accumulator specialized for the `Long` values. We show it in the
    following code snippet:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，装箱有时可能有问题，有时则没有。通常，在高性能代码中应该避免装箱。在我们的例子中，我们可以通过创建一个专门针对`Long`值的累加器来避免装箱。我们将在下面的代码片段中展示它：
- en: '[PRE72]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Re-running the program reveals that the new accumulator is almost twice as
    fast:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行程序揭示，新的累加器几乎快了两倍：
- en: '[PRE73]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Boxing can slow down the program by a factor of anywhere between one and several
    dozen. This depends on the specific ratio of object allocations and other work,
    and it needs to be measured on a per-program basis.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 装箱可能会使程序速度降低一个到几十个因素。这取决于对象分配和其他工作的具体比率，并且需要在每个程序的基础上进行测量。
- en: An unfortunate side effect is that we can only use the new accumulator implementation
    for `Long` values. However, Scala allows us to retain the generic nature of the
    previous `Accumulator` implementation. The Scala specialization feature allows
    the annotation of class type parameters with the `@specialized` annotation, instructing
    the Scala compiler to automatically generate versions of the generic class for
    primitive types, such as `Long`, and avoid boxing. We will not dive any further
    into this topic, and instead let interested readers find out more on their own.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们只能为`Long`值使用新的累加器实现。然而，Scala 允许我们保留之前`Accumulator`实现的泛型特性。Scala 的特殊化功能允许使用`@specialized`注解来注解类类型参数，指示
    Scala 编译器自动为原始类型（如`Long`）生成泛型类的版本，并避免装箱。我们不会进一步深入这个话题，而是让感兴趣的读者自行了解更多。
- en: 'Now that we know how to identify performance issues and optimize sequential
    programs, we study how to improve the performance by increasing the parallelism
    level. Let''s parallelize the previous program by adding one million integers
    from four separate threads. This is shown in the following code snippet:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何识别性能问题并优化顺序程序，我们接下来研究如何通过提高并行级别来提升性能。让我们通过从四个不同的线程添加一百万个整数来并行化之前的程序。这在上面的代码片段中有所展示：
- en: '[PRE74]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the preceding example, we distribute the work of adding 1 million integers
    across four different threads, so we expect the running time of the program to
    increase four times. Sadly, running the program reveals that our expectations
    were wrong:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将添加一百万个整数的任务分配到四个不同的线程中，因此我们预计程序的运行时间会增加四倍。遗憾的是，运行程序揭示我们的预期是错误的：
- en: '[PRE75]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As pointed out in [Chapter 5](ch05.html "Chapter 5. Data-Parallel Collections"),
    *Data-Parallel Collections*, perpetually writing to the same memory location from
    multiple threads results in memory contention issues. In most computer architectures,
    cache-lines need to be exchanged between the processors writing to the same memory
    location, and this slows down the program. In our case, the contention point is
    the `AtomicLong` object in the `LongAccumulator` class. Simultaneously invoking
    the `compareAndSet` operation on the same memory location does not scale.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第5章](ch05.html "第5章。数据并行集合")中所述，*数据并行集合*，从多个线程持续写入相同的内存位置会导致内存竞争问题。在大多数计算机架构中，需要在不同处理器之间交换写入相同内存位置的缓存行，这会减慢程序运行速度。在我们的例子中，竞争点是`LongAccumulator`类中的`AtomicLong`对象。同时在该内存位置上调用`compareAndSet`操作不会扩展。
- en: To address the issue of memory contention, we need to somehow disperse the writes
    throughout different cache-lines. Instead of adding the accumulated value to a
    single memory location, we will maintain many memory locations with partial accumulation
    values. When some processor calls the `add` method, it will pick one of these
    memory locations and update the partial accumulation. When a processor calls the
    `apply` method, it will scan all the partial accumulations and add them together.
    In this implementation, we trade the performance of the `apply` method for the
    improved scalability of the `add` method. This trade-off is acceptable in many
    cases, including our `fold` method, where we call the `add` method many times,
    but the `apply` method only once.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决内存竞争问题，我们需要以某种方式分散写入到不同的缓存行中。我们不会将累积值添加到单个内存位置，而是将维护许多具有部分累积值的内存位置。当某个处理器调用
    `add` 方法时，它将选择这些内存位置之一并更新部分累积值。当一个处理器调用 `apply` 方法时，它将扫描所有部分累积值并将它们相加。在这个实现中，我们以
    `apply` 方法的性能为代价，换取了 `add` 方法的改进可伸缩性。在很多情况下，这种权衡是可以接受的，包括我们的 `fold` 方法，其中我们多次调用
    `add` 方法，但只调用一次 `apply` 方法。
- en: Furthermore, note that the new `apply` implementation is not linearizable, as
    explained in [Chapter 7](ch07.html "Chapter 7. Software Transactional Memory"),
    *Software Transactional Memory*. If some processor calls the `apply` method when
    multiple processors are calling the `add` method, the resulting accumulation value
    can be slightly incorrect. However, if no other processor calls the `add` method
    when the `apply` method is called, the resulting accumulation value will be correct.
    We say that the new `apply` implementation is **quiescently consistent** with
    respect to the `add` method.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，新的 `apply` 实现不是可线性化的，正如在[第7章](ch07.html "第7章。软件事务内存")中所述，*软件事务内存*。如果有多个处理器正在调用
    `add` 方法时某个处理器调用 `apply` 方法，则累积的结果值可能会略微不正确。然而，如果没有其他处理器在调用 `apply` 方法时调用 `add`
    方法，则累积的结果值将是正确的。我们说新的 `apply` 实现与 `add` 方法是**静默一致的**。
- en: Note that this property is sufficient for ensuring the correctness of the preceding
    `fold` implementation, because the `fold` method only calls the `apply` method
    after all the `add` calls are completed.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个属性足以确保前面 `fold` 实现的正确性，因为 `fold` 方法仅在所有 `add` 调用完成后才调用 `apply` 方法。
- en: We now show the implementation of the `ParLongAccumulator` class, which uses
    an `AtomicLongArray` object, named `values`, to keep the partial accumulation
    values. Atomic arrays are arrays on which we can call operations such as the `compareAndSet`
    method. Conceptually, an `AtomicLongArray` is equivalent to an array of `AtomicLong`
    objects, but is more memory-efficient.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们展示 `ParLongAccumulator` 类的实现，它使用一个名为 `values` 的 `AtomicLongArray` 对象来保持部分累积值。原子数组是在其上可以调用诸如
    `compareAndSet` 方法等操作的数组。从概念上讲，`AtomicLongArray` 等同于 `AtomicLong` 对象的数组，但更节省内存。
- en: The `ParLongAccumulator` class must choose a proper size for the `AtomicLongArray`
    object. Setting the size of the array to the number of processors will not make
    the memory contention problems go away. Recall from [Chapter 3](ch03.html "Chapter 3. Traditional
    Building Blocks of Concurrency"), *Traditional Building Blocks of Concurrency*,
    that a processor needs to own a cache-line in exclusive mode before writing to
    it. A cache-line size is typically 64 bytes. This means that on a 32-bit JVM,
    eight consecutive entries in an `AtomicLongArray` object fit inside a single cache-line.
    Even when different processors write to separate `AtomicLongArray` entries, memory
    contention occurs if these entries lie in the same cache-line. This effect is
    known as **false-sharing**. A necessary precondition in avoiding false-sharing
    is to make the array size at least eight times larger than the number of processors.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParLongAccumulator` 类必须为 `AtomicLongArray` 对象选择一个合适的大小。将数组的大小设置为处理器数量并不能消除内存竞争问题。回想一下[第3章](ch03.html
    "第3章。并发传统构建块")，*并发的传统构建块*，处理器在写入之前需要以独占模式拥有一个缓存行。缓存行的大小通常是64字节。这意味着在一个32位JVM上，`AtomicLongArray`
    对象中的八个连续条目可以放入一个单独的缓存行中。即使不同的处理器写入不同的 `AtomicLongArray` 条目，如果这些条目位于同一缓存行中，也会发生内存竞争。这种现象被称为**伪共享**。避免伪共享的必要前提是使数组大小至少是处理器数量的八倍。'
- en: 'A `ParLongAccumulator` object is used by many different threads simultaneously.
    In most programs, there are many more threads than processors. To reduce false-sharing,
    as much as possible, we set the size of the `values` array to 128 times the number
    of processors:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParLongAccumulator`对象被许多不同的线程同时使用。在大多数程序中，线程的数量远多于处理器。为了尽可能减少假共享，我们将`values`数组的大小设置为处理器数量的128倍：'
- en: '[PRE76]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The new `add` implementation is similar to the previous one. The main difference
    is that the new implementation needs to pick the `pos` memory location for the
    partial accumulation value. Different processors should pick different memory
    locations based on their index. Unfortunately, standard APIs on the JVM do not
    provide the index of the current processor. An adequate approximation is to compute
    the `pos` partial accumulation location from the current thread ID. We additionally
    use the `byteswap32` hashing function to effectively randomize the location in
    the array. This decreases the likelihood that two threads with adjacent IDs end
    up writing to adjacent entries in the array, and reduces the possibility of false-sharing.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`add`实现与之前类似。主要区别在于新的实现需要选择部分累积值的`pos`内存位置。不同的处理器应根据它们的索引选择不同的内存位置。不幸的是，JVM上的标准API没有提供当前处理器的索引。一个充分的近似是从当前线程ID计算`pos`部分累积位置。我们此外还使用`byteswap32`哈希函数来有效地随机化数组中的位置。这降低了两个具有相邻ID的线程最终写入数组相邻条目的可能性，并减少了假共享的可能性。
- en: 'Running the program demonstrates that we reached our goal, and improved the
    program performance by a factor of almost three:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序表明我们达到了目标，并将程序性能提高了近三倍：
- en: '[PRE77]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: There are additional ways to improve our `ParLongAccumulator` class. One is
    to further reduce false sharing by choosing the entries in the `values` array
    more randomly. Another is to ensure that the `apply` method is not only quiescently
    consistent, but also linearizable. In the interest of keeping this section simple
    and clear, we do not dive further into these topics, but let interested readers
    explore them on their own.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他方法可以改进我们的`ParLongAccumulator`类。一种是通过在`values`数组中选择条目更加随机来进一步减少假共享。另一种是确保`apply`方法不仅是一致的，而且是可线性化的。为了保持本节简单明了，我们没有进一步深入探讨这些主题，但让感兴趣的读者自行探索。
- en: In this and the preceding sections, we summarized the different styles of concurrency
    and studied the basics of dealing with concurrency bugs. This gave us a useful
    insight into the big picture, but the theory that we learned is only valuable
    if it can be applied in practice. We designed and implemented a remote file browser
    application, a practical example of a large concurrent application. This gave
    us insight into both the theoretical and practical side of concurrent programming.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节和前几节中，我们总结了不同的并发风格，并研究了处理并发错误的基础知识。这让我们对整体情况有了有用的洞察，但我们学到的理论只有在实践中应用才有价值。我们设计和实现了远程文件浏览器应用程序，这是一个大型并发应用程序的实用示例。这让我们对并发编程的理论和实践方面都有了深入的了解。
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Having seen the technical details of a variety of different concurrency libraries
    in the preceding chapters, we took a couple of steps back and presented a more
    cohesive view of Scala concurrency. After presenting a taxonomy of different styles
    of concurrency, we outlined the use cases for different concurrency frameworks.
    We then studied how to debug concurrent programs and analyze their performance.
    Finally, we combined the different concurrency frameworks together to implement
    a real-world distributed application: a remote file browser.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们看到了各种不同并发库的技术细节后，我们退后几步，提出了一个更一致的Scala并发视图。在介绍不同并发风格的分类之后，我们概述了不同并发框架的使用案例。然后我们研究了如何调试并发程序并分析它们的性能。最后，我们将不同的并发框架结合起来，实现了一个现实世界的分布式应用程序：远程文件浏览器。
- en: 'The best theory is inspired by practice, and the best practice is inspired
    by theory. This book has given you a fair amount of both. To deepen your understanding
    of concurrent computing, consider studying the references listed at the end of
    each chapter: you should already be able to grasp most of them. Importantly, to
    improve your practical concurrent programming skills, try to solve the exercises
    from this book. Finally, start building your own concurrent applications. By now,
    you must have understood both how high-level concurrency abstractions work and
    how to use them together, and are on the path to becoming a true concurrency expert.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的理论源于实践，最好的实践源于理论。本书已经给了你相当多的两者。为了加深你对并发计算的理解，考虑研究每章末尾列出的参考文献：你应该已经能够理解大部分。重要的是，为了提高你的实际并发编程技能，尝试解决本书中的练习。最后，开始构建你自己的并发应用程序。到现在为止，你必须已经理解了高级并发抽象是如何工作的，以及如何一起使用它们，并且正在成为真正的并发专家的道路上。
- en: Exercises
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'The following exercises will improve your skills in building practical concurrent
    applications. Some of them require extending the ScalaFTP program from this chapter,
    while others require implementing concurrent applications from scratch. Finally,
    several exercises are dedicated to testing the performance and scalability of
    concurrent programs:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习将提高你在构建实际并发应用程序方面的技能。其中一些需要扩展本章中的ScalaFTP程序，而其他一些则需要从头开始实现并发应用程序。最后，几个练习专门用于测试并发程序的性能和可伸缩性：
- en: Extend the ScalaFTP application to allow the addition of directories to the
    remote filesystem.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展ScalaFTP应用程序，允许将目录添加到远程文件系统中。
- en: Extend the ScalaFTP application so that the changes in the server filesystem
    are automatically reflected in the client program.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展ScalaFTP应用程序，以便服务器文件系统的更改自动反映在客户端程序中。
- en: Extend the ScalaFTP application so that it allows parallel regex searches over
    filenames in the remote filesystem.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展ScalaFTP应用程序，以便它允许在远程文件系统中的文件名上并行进行正则表达式搜索。
- en: Extend the ScalaFTP server so that it allows recursively copying directories.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展ScalaFTP服务器，以便它允许递归复制目录。
- en: Implement the download and upload functionality, and use `Observable` objects
    to display the file transfer progress in a Swing `ProgressBar` component.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现下载和上传功能，并使用`Observable`对象在Swing `ProgressBar`组件中显示文件传输进度。
- en: Extend the ScalaFTP client implementation so that a `FilePane` can display either
    a remote or a local filesystem's contents.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展ScalaFTP客户端实现，以便`FilePane`可以显示远程或本地文件系统的内容。
- en: Design and implement a distributed chat application.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计和实现一个分布式聊天应用程序。
- en: Design and implement a Paint program with collaborative editing.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计和实现一个具有协作编辑功能的Paint程序。
- en: Compare the duration of creating and starting a new thread, and waiting for
    its termination, against the duration of starting a computation using `Future.apply`
    and waiting for the completion of the corresponding `Future` object.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较创建和启动新线程以及等待其终止的时间与使用`Future.apply`启动计算并等待相应`Future`对象完成的时间。
- en: 'A pool is one of the simplest collection abstractions, which allows the addition
    and extraction of elements. The `remove` operation returns any element that was
    previously added to the pool. A concurrent pool is represented by the `ConcurrentPool`
    class:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 池是集合抽象中最简单的一种，它允许添加和提取元素。`remove`操作返回之前添加到池中的任何元素。并发池由`ConcurrentPool`类表示：
- en: '[PRE78]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Implement the concurrent pool and make sure that its operations are linearizable.
    Measure and ensure high performance and scalability of your implementation.
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现并发池，并确保其操作是可线性化的。测量并确保你实现的性能和可伸缩性。
- en: Compare the performance and scalability of the Treiber stack from the exercise
    in [Chapter 2](ch02.html "Chapter 2. Concurrency on the JVM and the Java Memory
    Model"), *Concurrency on the JVM and the Java Memory Model*, against the transactional
    sorted list from [Chapter 7](ch07.html "Chapter 7. Software Transactional Memory"),
    *Software Transactional Memory*. How are they compared to the concurrent pool
    from the previous exercise?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将[第2章](ch02.html "第2章. JVM和Java内存模型中的并发")中的练习中Treiber栈的性能和可伸缩性与[第7章](ch07.html
    "第7章. 软件事务内存")中的事务排序列表进行比较，*JVM和Java内存模型中的并发*。它们与之前练习中的并发池相比如何？
- en: Implement the `getUniqueId` method from [Chapter 2](ch02.html "Chapter 2. Concurrency
    on the JVM and the Java Memory Model"), *Concurrency on the JVM and the Java Memory
    Model*. Measure and ensure high performance and scalability of your implementation.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现[第2章](ch02.html "第2章。JVM和Java内存模型上的并发")中的 `getUniqueId` 方法，*JVM和Java内存模型上的并发*。测量并确保你实现的性能和可扩展性高。
- en: Implement a lock-free concurrent linked list and a lock-based concurrent linked
    list that support linearizable prepend and append operations. Both implementations
    must be singly linked lists. Measure the performance of inserting many elements.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个无锁的并发链表和一个基于锁的并发链表，这两个链表都支持可线性化的 prepend 和 append 操作。两种实现都必须是单链表。测量插入大量元素的性能。
- en: A barrier is a concurrent object that allows *N* threads to synchronize at some
    point in the program. A barrier exposes a single method, `await`, which effectively
    blocks the thread until all *N* threads call `await`. After all *N* threads call
    `await`, the `await` invocations of all the threads immediately return. Blocking
    can be done, for example, by busy-waiting. Use atomic integers to implement a
    barrier. Measure the performance of your implementation for one, two, four, and
    eight threads, and some large number of calls to `await`.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 障碍是一个并发对象，它允许 *N* 个线程在程序的某个点上同步。障碍暴露一个单一的方法，`await`，它有效地阻塞线程，直到所有 *N* 个线程调用
    `await`。在所有 *N* 个线程调用 `await` 之后，所有线程的 `await` 调用立即返回。阻塞可以通过例如忙等待来实现。使用原子整数来实现一个障碍。测量你实现的一个、两个、四个和八个线程的性能，以及一些大量的
    `await` 调用。
