- en: Chapter 5. JSF Configurations Using XML Files and Annotations – Part 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 使用XML文件和注解的JSF配置 – 第2部分
- en: 'In this chapter, we will continue to explore more situations where the `faces-config.xml`
    file will help us to accomplish different configuration tasks (of course, for
    some of them we have the alternative of annotations, while for others, we need
    to switch to the XML configuration level). Besides the examples presented in the
    previous chapter, this chapter will go deeper and cover the further list of tasks,
    which are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续探讨更多情况下`faces-config.xml`文件将帮助我们完成不同的配置任务（当然，对于其中的一些，我们有注解的替代方案，而对于其他一些，我们需要切换到XML配置级别）。除了上一章中提供的示例之外，本章将进一步深入，涵盖以下更详细的任务列表：
- en: Configuring resource handlers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置资源处理器
- en: Configuring the View handler
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置视图处理器
- en: Overriding JSF renders
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖JSF渲染
- en: Working with client behavior functionality
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与客户端行为功能一起工作
- en: Configuring the Global Exception handler
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置全局异常处理器
- en: Configuring render kit factory
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置渲染工厂
- en: Configuring partial view context
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置部分视图上下文
- en: Configuring visit context
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置访问上下文
- en: Configuring external context
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置外部上下文
- en: Configuring Flash
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Flash
- en: JSF 2.2 Window ID API
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSF 2.2 Window ID API
- en: Configuring lifecycle
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置生命周期
- en: Configuring application
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置应用程序
- en: Configuring VDL
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置VDL
- en: Combining multiple factory's powers
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合多个工厂的权力
- en: Configuring resource handlers
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置资源处理器
- en: 'Starting with JSF 2.0, all the web resources, such as CSS, JavaScript, and
    images are loaded from a folder named `resources`, present under the root of your
    web application or from `/META-INF/resources` in JAR files. A folder under the
    `resources` folder is known as a `library` or `theme`, which is like a collection
    of client artifacts. We can also create a special folder matching the regex `\d+(_\d+)*`
    under the `library` folder for providing versioning. In this case, the default
    JSF resource handler will always retrieve the newest version to display. The various
    approaches that can be followed for structuring the `resources` folder are as
    shown in the following figure:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从JSF 2.0开始，所有网络资源，如CSS、JavaScript和图像，都从名为`resources`的文件夹加载，该文件夹位于您的Web应用程序的根目录下，或在JAR文件中的`/META-INF/resources`下。`resources`文件夹下的一个文件夹被称为`library`或`theme`，它类似于客户端资源的集合。我们还可以在`library`文件夹下创建一个特殊文件夹，匹配正则表达式`\d+(_\d+)*`，以提供版本控制。在这种情况下，默认的JSF资源处理器将始终检索最新版本以显示。以下图显示了可以遵循的`resources`文件夹结构化方法：
- en: '![Configuring resource handlers](img/6466EN_05_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![配置资源处理器](img/6466EN_05_01.jpg)'
- en: In the preceding figure, part **A** depicts a common structure of the `resources`
    folder without versioning, and in part **B**, you have the versioning approach.
    The folders `css`, `js`, `img`, and others usually denote the content type of
    files inside them; however, this is not mandatory.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，部分**A**描述了没有版本控制的`resources`文件夹的常见结构，而在部分**B**中，你有版本控制方法。文件夹`css`、`js`、`img`等通常表示其中文件的类型；然而，这并非强制性的。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the library name shouldn't denote the content type.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，库的名称不应表示内容类型。
- en: 'Part **C**, represents the complete structure of the subfolders supported under
    the `resources` folder. In this case, we entirely exploit the automatic localization
    and version management, which works if we respect the following structure under
    the `resources` folder and is known as *resourceIdentifier* (the `[]` demarcate
    optional parts):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 部分**C**表示`resources`文件夹下支持的子文件夹的完整结构。在这种情况下，我们完全利用自动本地化和版本管理，这要求我们在`resources`文件夹下遵守以下结构，并被称为*资源标识符*（方括号`[]`表示可选部分）：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the case of face flows packaged within JAR files, resources packaged in `CLASSPATH`
    must reside under the JAR entry name `META-INF/flows/resourceIdentifier`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在JAR文件中打包的face flows的情况下，打包在`CLASSPATH`中的资源必须位于JAR条目名称`META-INF/flows/resourceIdentifier`下。
- en: We will also discuss the case referred to in part **A**, since this is the most
    used case. But for the sake of completeness, you can check the complete application
    named `ch5_12`, which represents an implementation case from part **C** (that
    includes part **B** as well).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论部分**A**中提到的案例，因为这是最常用的案例。但为了完整性，您可以检查名为`ch5_12`的完整应用程序，它代表来自部分**C**（包括部分**B**）的实现案例。
- en: 'So, having the structure from the preceding figure, we can easily load a CSS
    file (`rafa.css`) using the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有了前面图中的结构，我们可以轻松地使用以下代码加载CSS文件（`rafa.css`）：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you can load a JavaScript file (`rafa.js`) using the following
    code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用以下代码加载一个 JavaScript 文件（`rafa.js`）：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, you can load an image file (`rafa.png`) using the following
    code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用以下代码加载一个图像文件（`rafa.png`）：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, this is how the JSF default resource handler deals with resources. But
    what can we do if we don''t respect this inflexible structure of folders? For
    example, if we have the CSS files under the application web root in `/players/css/`,
    or we want to place resources in a protected folder, such as `WEB-INF` (probably
    the biggest disadvantage of the `resources` folder is that everything in it is
    accessible from outside by default). In this case, there is no directly accessible
    `resources` folder and we have no idea what a library is. If we write something
    like the following code, it will not work:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是 JSF 默认资源处理器处理资源的方式。但如果我们不遵守这种文件夹的僵化结构，我们该怎么办？例如，如果我们有 CSS 文件位于应用程序的 web
    根目录下的 `/players/css/`，或者我们想在受保护的文件夹中放置资源，例如 `WEB-INF`（`resources` 文件夹的最大缺点可能是默认情况下它里面的所有内容都可以从外部访问）。在这种情况下，没有直接可访问的
    `resources` 文件夹，我们也不知道库是什么。如果我们编写如下代码，它将不会工作：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Among the possible solutions, we have the facility to write a custom resource
    handler. It is much simpler than it sounds, because JSF provides several wrappers
    (implements `FacesWrapper`) that help us to write custom handlers and factories
    by overriding only the methods that we want to affect. In case of a custom resource
    handler, we need to perform the following steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的解决方案中，我们有编写自定义资源处理器的功能。这比听起来要简单得多，因为 JSF 提供了几个包装器（实现 `FacesWrapper`），通过仅重写我们想要影响的方法，帮助我们编写自定义处理程序和工厂。对于自定义资源处理器，我们需要执行以下步骤：
- en: Extend the `ResourceHandlerWrapper` class.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展 `ResourceHandlerWrapper` 类。
- en: Write a delegating constructor. JSF will call this constructor for passing the
    standard resource handler, which we will wrap in a `ResourceHandler` instance.
    We can also obtain this instance by overriding the `getWrapped` method.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个委托构造函数。JSF 会调用这个构造函数来传递标准资源处理器，我们将它包装在一个 `ResourceHandler` 实例中。我们也可以通过重写
    `getWrapped` 方法来获取这个实例。
- en: Override the `createResource` method. Here, we can sort the resources and decide
    which of them go to the default resource handler and which of them go to our custom
    resource handler.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `createResource` 方法。在这里，我们可以对资源进行排序，并决定哪些资源应该发送到默认资源处理器，哪些资源应该发送到我们的自定义资源处理器。
- en: 'The following implementation is based on the preceding three steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实现基于前面的三个步骤：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `PlayerResource` class is our custom resource. The main aim of `PlayerResource`
    is to indicate the correct path `/players/css/`, which is not recognized by default.
    For this, we extend another wrapper named `ResourceWrapper` and override the method
    `getRequestPath`, as follows, where we delegate all calls to `ResourceWrapper`
    except one call, `getRequestPath`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerResource` 类是我们自定义的资源。`PlayerResource` 的主要目的是指明正确的路径 `/players/css/`，这个路径默认情况下是不被识别的。为此，我们扩展了另一个名为
    `ResourceWrapper` 的包装器，并重写了 `getRequestPath` 方法，如下所示，其中除了一个调用 `getRequestPath`
    之外，我们将所有调用委托给 `ResourceWrapper`：'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, you have to configure the custom resource handler in `faces-config.xml`
    as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要在 `faces-config.xml` 中按照以下方式配置自定义资源处理器：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, if you try to load the `rafa.css` (or `roger.css`) file, you can add the
    following lines of code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你尝试加载 `rafa.css`（或 `roger.css`）文件，你可以添加以下代码行：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The complete application is named `ch5_1_1` and is available in the code bundle
    of this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序名为 `ch5_1_1`，并可在本章的代码包中找到。
- en: 'However, remember that I said "Among the possible solutions ..."? Well, starting
    with JSF 2.2, we can indicate the folder of resources through a context parameter
    in the `web.xml` descriptor, as follows (mapped by the `ResourceHandler.WEBAPP_RESOURCES_DIRECTORY_PARAM_NAME`
    field):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住我之前说的“在可能的解决方案中...”？嗯，从 JSF 2.2 版本开始，我们可以在 `web.xml` 描述符中通过上下文参数来指定资源文件夹，如下所示（由
    `ResourceHandler.WEBAPP_RESOURCES_DIRECTORY_PARAM_NAME` 字段映射）：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Or, we can place the `resources` folder under `WEB-INF`, which can be accessed
    by JSF from inside `WEB-INF` but never from outside:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将 `resources` 文件夹放在 `WEB-INF` 下，这样 JSF 就可以从 `WEB-INF` 内部访问它，但永远不能从外部访问：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A complete example named `ch5_1_2` is available in the code bundle of this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码包中提供了一个名为 `ch5_1_2` 的完整示例。
- en: A custom resource handler can be useful to pass extra parameters to the linking
    file (for example CSS, JS, images, and so on). We can use this approach to reset
    the browser cache. Browsers cache static resources such as CSS, JS, and images;
    therefore they are not requested from the server each time the web page loads.
    We can force this by adding a parameter to the linking file in the query string,
    representing a version number or something that makes the browser to understand
    that it should load the resource from the server, not from the cache.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义资源处理器可以用来向链接文件（例如 CSS、JS、图片等）传递额外参数。我们可以使用这种方法来重置浏览器缓存。浏览器缓存静态资源，如 CSS、JS
    和图片；因此，每次网页加载时都不会从服务器请求。我们可以通过在查询字符串中添加参数来强制这样做，表示版本号或使浏览器理解它应该从服务器而不是从缓存中加载资源。
- en: 'In this case, we assume that the `rafa.css` file is under the `/resources/default/css/`
    folder and it is loaded using the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们假设 `rafa.css` 文件位于 `/resources/default/css/` 文件夹下，并且使用以下代码加载：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At this moment, the generated HTML is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，生成的 HTML 如下所示：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Also, we want to obtain something like the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们希望获得以下类似代码：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For this, we need to override the `createResource` method as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要按照以下方式覆盖 `createResource` 方法：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Also, `PlayerResource` is responsible to add the version parameter in the `getRequestPath`
    method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`PlayerResource` 负责在 `getRequestPath` 方法中添加版本参数：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The complete application is available in the code bundle named `ch5_1_3`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序包含在名为 `ch5_1_3` 的代码包中。
- en: 'Of course, in real cases, unlike in the preceding code, the version number
    is not hardcoded. Knowing that JSF 2.2 allows us to use dependency injection in
    custom resource handlers, we can inject the parameter values from a bean that
    can play the role of a version tracking system using the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在实际情况下，与前面的代码不同，版本号不是硬编码的。知道 JSF 2.2 允许我们在自定义资源处理器中使用依赖注入，我们可以使用以下代码从可以充当版本跟踪系统角色的
    bean 中注入参数值：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The complete example is named `ch5_1_4`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例命名为 `ch5_1_4`。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can also use the versioning system of JSF for invalidate browser cache,
    but you need to create the right folder under the library folder. - JSF will automatically
    load the last version. Passing parameters as we have seen earlier can be useful
    for many other things, such as generating customized JS and CSS response. Servers
    can access such parameters and JS as well.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 JSF 的版本控制系统来使浏览器缓存失效，但您需要在库文件夹下创建正确的文件夹。 - JSF 将自动加载最新版本。像我们之前看到的那样传递参数对于许多其他事情都很有用，例如生成定制的
    JS 和 CSS 响应。服务器可以访问此类参数和 JS。
- en: 'Browser caching can also be controlled with two context parameters in the `web.xml`
    descriptor (specific to Mojarra) as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器缓存也可以通过 `web.xml` 描述符中的两个上下文参数（特定于 Mojarra）进行控制，如下所示：
- en: '`com.sun.faces.defaultResourceMaxAge`: This parameter can be used to set the
    expiry time in milliseconds.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.sun.faces.defaultResourceMaxAge`：此参数可用于设置以毫秒为单位的过期时间。'
- en: '`com.sun.faces.resourceUpdateCheckPeriod`: This parameter gives frequency in
    minutes to check for changes in web application artifacts that contain resources.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.sun.faces.resourceUpdateCheckPeriod`：此参数指定检查包含资源的 Web 应用程序工件更改的频率（以分钟为单位）。'
- en: 'JSF resource handling provides solid advantages such as caching and loading
    resources within a JAR or writing custom UI components that contain CSS or JS,
    but it also has some disadvantages. For example, web designers use the static
    approach to add images in CSS, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 资源处理提供了诸如缓存和加载 JAR 内的资源以及编写包含 CSS 或 JS 的自定义 UI 组件等稳固的优势，但它也有一些缺点。例如，网页设计师使用静态方法在
    CSS 中添加图片，如下所示：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, when importing CSS style sheets using `<h:outputStyleSheet>`, the
    style sheet is imported and processed by FacesServlet through the `/javax.faces.resource/*`
    folder, which makes the picture relative path unavailable (in this case, the CSS
    file becomes a JSF resource). One of the solutions is to force the image URL to
    become a JSF resource, using the resource mapper in EL, `#{resource}`, as `#{resource[''`*library*`:`*location*`'']}`.
    For example, in `rafa.css` (loaded in the page via `<h:outputStylesheet>`), we
    can load the `rafa.png` image using the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当使用`<h:outputStyleSheet>`导入CSS样式表时，样式表是通过`/javax.faces.resource/*`文件夹由FacesServlet导入和处理的，这使得图片的相对路径不可用（在这种情况下，CSS文件变成了JSF资源）。一种解决方案是使用EL中的资源映射器强制将图像URL转换为JSF资源，即`#{resource}`，作为`#{resource['`*library*`:`*location*`']}`。例如，在通过`<h:outputStylesheet>`加载的`rafa.css`中，我们可以使用以下代码加载`rafa.png`图像：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Based on this, `<h:graphicImage>` can load `rafa.png` as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，`<h:graphicImage>`可以按如下方式加载`rafa.png`：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can check these examples in the application named `ch5_13`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在名为`ch5_13`的应用程序中检查这些示例。
- en: As an alternative, you can use OmniFaces library's `UnmappedResourceHandler`,
    which spares us from modifying the CSS files ([http://showcase.omnifaces.org/resourcehandlers/UnmappedResourceHandler](http://showcase.omnifaces.org/resourcehandlers/UnmappedResourceHandler)).
    Moreover, another approach consists in writing a custom `ResourceHandler` that
    can fix this issue.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，你可以使用OmniFaces库的`UnmappedResourceHandler`，这可以避免我们修改CSS文件([http://showcase.omnifaces.org/resourcehandlers/UnmappedResourceHandler](http://showcase.omnifaces.org/resourcehandlers/UnmappedResourceHandler))。此外，另一种方法是通过编写自定义的`ResourceHandler`来解决这个问题。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: From JSF 2.2 onwards, `ResourceResolver` has been merged into `ResourceHandler`,
    and `ResourceResolver` itself has been deprecated. These two are detailed in [Chapter
    12](ch12.html "Chapter 12. Facelets Templating"), *Facelets Templating*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从JSF 2.2版本开始，`ResourceResolver`已被合并到`ResourceHandler`中，并且`ResourceResolver`本身已被弃用。这两个组件在[第12章](ch12.html
    "第12章。Facelets模板")中详细描述，*Facelets模板*。
- en: Adding CSS and JS resources programmatically
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以编程方式添加CSS和JS资源
- en: 'Sometimes, you may need to load the CSS and JS resources by specifying them
    in a managed bean method. For example, the following method loads `rafa.css` and
    `rafa.js` in a programmatic fashion:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要通过在管理Bean方法中指定它们来加载CSS和JS资源。例如，以下方法以编程方式加载`rafa.css`和`rafa.js`：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The complete application is named `ch5_14`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为`ch5_14`。
- en: Configuring the view handler
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置视图处理器
- en: JSF provides a view handler that can be used for working with views. It can
    be a very handy tool when you want to interact with a view or create/restore/extend/modify
    a view. It is also good practice to deal with URLs here, which is exactly what
    you will see next.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: JSF提供了一个视图处理器，可以用于处理视图。当你想要与视图交互或创建/恢复/扩展/修改视图时，它是一个非常实用的工具。在这里处理URL也是一个好的实践，这正是你接下来将要看到的。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A view handler is not a good choice when you need to work with components! Even
    if this is possible, view handlers were not created for such tasks.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要与组件一起工作时，视图处理器不是一个好的选择！即使这是可能的，视图处理器也不是为这些任务而创建的。
- en: Sometimes you may need to convert absolute URLs into relative URLs. For example,
    if you run an application behind a reverse proxy, you may need to provide relative
    URLs. By default, the browser appends each absolute URL to the host, which is
    obviously a big issue.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能需要将绝对URL转换为相对URL。例如，如果你在一个反向代理后面运行应用程序，你可能需要提供相对URL。默认情况下，浏览器将每个绝对URL附加到主机上，这显然是一个大问题。
- en: 'In order to convert absolute URLs into relative URLs, we need to perform the
    following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将绝对URL转换为相对URL，我们需要执行以下步骤：
- en: Create a new view handler by extending the `ViewHandlerWrapper` class. Extending
    this wrapper allows us to override only the required methods.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过扩展`ViewHandlerWrapper`类来创建一个新的视图处理器。扩展这个包装器允许我们仅覆盖所需的方法。
- en: Override the `getActionURL` and `getResourceURL` methods.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖`getActionURL`和`getResourceURL`方法。
- en: Configure the view handler in `faces-config.xml`.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`faces-config.xml`中配置视图处理器。
- en: 'Although it may sound pompous, the following code is self-explanatory:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能听起来有些夸张，但以下代码是自我解释的：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The required configuration in `faces-config.xml` is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`faces-config.xml`中所需的配置如下：'
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The complete application is available in the code bundle named `ch5_2_1`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序可在名为`ch5_2_1`的代码包中找到。
- en: 'If you check the source code of the `index.xhtml` page, you will notice that
    instead of an absolute URL for the CSS resource, there is a relative one, of the
    following type:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查 `index.xhtml` 页面的源代码，你会注意到，对于 CSS 资源，不是使用绝对 URL，而是使用以下类型的相对 URL：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Done! Now you can run the application behind a reverse proxy.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在你可以运行位于反向代理后面的应用程序。
- en: Another useful view handler is the one that "swallows" the `ViewExpiredException`
    exception. This exception is thrown when a user session expires. Through a view
    handler, we can treat this exception by recreating the user view. Redirect the
    flow to a special page (let's name it `expired.xhtml`).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的视图处理器是能够“吞噬”`ViewExpiredException` 异常的处理器。当用户会话过期时，会抛出此异常。通过视图处理器，我们可以通过重新创建用户视图来处理此异常。将流程重定向到特殊页面（让我们称其为
    `expired.xhtml`）。
- en: 'When the user session expires, `UIViewRoot` of the application is set to `null`.
    We can use this check in the `restoreView` method, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户会话过期时，应用程序的 `UIViewRoot` 被设置为 `null`。我们可以在 `restoreView` 方法中使用这个检查，如下所示：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The configuration in `faces-config.xml` is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`faces-config.xml` 中的配置如下：'
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The complete application is available in the code bundle and is named `ch5_2_2`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序包含在代码包中，名称为 `ch5_2_2`。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting with JSF 2.2, we can use dependency injection with the view handler
    (`@Inject` and `@EJB`).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JSF 2.2 版本开始，我们可以使用视图处理器进行依赖注入（`@Inject` 和 `@EJB`）。
- en: Overriding JSF renders
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖 JSF 渲染器
- en: The main responsibilities of a `Renderer` consists of generating the appropriate
    client-side markup, such as HTML, WML, and XUL, and converting information coming
    from the client to the proper type for the component.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Renderer` 的主要职责包括生成适当的客户端标记，例如 HTML、WML 和 XUL，以及将来自客户端的信息转换为组件的正确类型。'
- en: 'JSF provides a set of built-in renders and has the capability to extend them
    with custom behavior. If you consider a proper workaround to override a built-in
    render, then perform the following steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 提供了一套内置的渲染器，并且具有通过自定义行为扩展它们的能力。如果你考虑一个适当的解决方案来覆盖内置的渲染器，那么请执行以下步骤：
- en: Extend the desired built-in renderer (for example, `Renderer`, `TextRenderer`,
    `LabelRenderer`, `MessagesRenderer`, and so on).
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展所需的内置渲染器（例如，`Renderer`、`TextRenderer`、`LabelRenderer`、`MessagesRenderer` 等）。
- en: Override the built-in renderer methods.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖内置的渲染器方法。
- en: Configure the new renderer in `faces-config.xml` or using the `@FacesRenderer`
    annotation.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `faces-config.xml` 中配置新的渲染器或使用 `@FacesRenderer` 注解。
- en: 'Well, let''s see some examples of writing a custom render. For example, let''s
    suppose that we have three attributes (`player-nickname`, `player-mother-name`,
    and `player-father-name`) that we want to use inside the `<h:inputText>` tag.
    If you try to write the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们看看一些编写自定义渲染器的示例。例如，假设我们有三个属性（`player-nickname`、`player-mother-name` 和
    `player-father-name`），我们想在 `<h:inputText>` 标签内使用它们。如果你尝试编写以下代码：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, the built-in renderer will give the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，内置的渲染器将给出以下输出：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Obviously, our three attributes were ignored. We can fix this by extending
    `TextRenderer` as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们的三个属性被忽略了。我们可以通过以下方式扩展 `TextRenderer` 来修复这个问题：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Done! Configure the new renderer in `faces-config.xml` as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！按照以下方式在 `faces-config.xml` 中配置新的渲染器：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, the renderer input field will be as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，渲染器输入字段将如下所示：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Instead of configuring the custom renderer in `faces-config.xml`, we could
    use the `@FacesRenderer` annotation, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在 `faces-config.xml` 中配置自定义渲染器，我们可以使用 `@FacesRenderer` 注解，如下所示：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: But, unfortunately this isn't working. There seems to be a bug here!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但，不幸的是，这不起作用。这里似乎有一个错误！
- en: The complete example is named `ch5_4_1`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例名称为 `ch5_4_1`。
- en: 'Let''s look at another example in order to fortify the knowledge about writing
    custom renderers. The next example will modify the built-in `LabelRenderer` class
    by adding an image in front of each `<h:outputText>` tag, as shown in the following
    code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看另一个示例，以加强编写自定义渲染器的知识。下一个示例将修改内置的 `LabelRenderer` 类，在每一个 `<h:outputText>`
    标签前添加一个图片，如下所示：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Don''t forget to configure the renderer in `faces-config.xml` as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记按照以下方式在 `faces-config.xml` 中配置渲染器：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting with JSF 2.2, we can use dependency injection in renderers (`@Inject`
    and `@EJB`). The complete example of the preceding renderer is named `ch5_4_2`
    (the image name was provided by another bean through injection dependency).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JSF 2.2 版本开始，我们可以在渲染器中使用依赖注入（`@Inject` 和 `@EJB`）。前面提到的渲染器的完整示例名称为 `ch5_4_2`（图片名称由另一个通过注入依赖提供的
    Bean 提供）。
- en: The upcoming example in this section is a little bit tricky.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本节接下来的示例有点棘手。
- en: If you have used PrimeFaces, especially the `<p:messages>` tag, then you know
    that this tag accepts an attribute named `escape`. The attribute's value can be
    `true` or `false`, and it defines whether HTML would be escaped or not (defaults
    to `true`).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用过 PrimeFaces，特别是 `<p:messages>` 标签，那么你知道这个标签接受一个名为 `escape` 的属性。属性的值可以是
    `true` 或 `false`，它定义了 HTML 是否会被转义（默认为 `true`）。
- en: Unfortunately, JSF 2.2 still doesn't provide such attributes for the `<h:messages>`
    tag, but there is at least a workaround to solve this. You can implement a custom
    renderer that is capable of understanding the `escape` attribute.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，JSF 2.2 仍然没有为 `<h:messages>` 标签提供这样的属性，但至少有一个解决方案可以解决这个问题。你可以实现一个能够理解 `escape`
    属性的自定义渲染器。
- en: JSF provides a class named `ResponseWriter`, which is useful in this case because
    it provides methods capable of producing elements and attributes for markup languages
    such as HTML and XML. Moreover, JSF provides a wrapper for this class named `ResponseWriterWrapper`.
    We can easily extend this class, and override the method `writeText`, which is
    useful for writing escaped strings obtained from objects by conversions. Un-escaped
    strings are written by the `write` method.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 提供了一个名为 `ResponseWriter` 的类，在这个情况下非常有用，因为它提供了能够生成 HTML 和 XML 等标记语言元素和属性的方法。此外，JSF
    还提供了一个名为 `ResponseWriterWrapper` 的这个类的包装器。我们可以轻松地扩展这个类，并重写 `writeText` 方法，这对于从对象通过转换获得的转义字符串非常有用。未转义的字符串通过
    `write` 方法写入。
- en: 'So, based on this information, we can easily write our response writer, as
    follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据这些信息，我们可以轻松地编写我们的响应写入器，如下所示：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So far, so good! Now we need to write the custom renderer, as shown in the following
    code, by extending the `MessagesRenderer` class, which is the default renderer
    for JSF messages. The only method we need to affect is the `encodeEnd` method,
    by placing our response writer instead of the default one. In the end, we restore
    it to default.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利！现在我们需要编写自定义渲染器，如以下代码所示，通过扩展 `MessagesRenderer` 类，这是 JSF 消息的默认渲染器。我们唯一需要影响的方法是
    `encodeEnd` 方法，通过放置我们的响应写入器代替默认的写入器。最后，我们将它恢复到默认设置。
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, configure the new renderer in `faces-config.xml` as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按照以下方式在 `faces-config.xml` 中配置新的渲染器：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, you can add HTML content in your messages by setting the `escape` attribute
    as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过以下方式设置 `escape` 属性，在你的消息中添加 HTML 内容：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The complete example is named `ch5_4_3`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例命名为 `ch5_4_3`。
- en: In the preceding examples, we saw a few use cases of extending an existing renderer.
    The last example of this section will go a little bit further, and will represent
    a use case for writing a custom `RenderKit` and a custom renderer by extending
    the abstract class `Renderer`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到了扩展现有渲染器的一些用例。本节的最后一个示例将更进一步，将展示通过扩展抽象类 `Renderer` 来编写自定义 `RenderKit`
    和自定义渲染器的用例。
- en: 'While the `Renderer` class converts the internal representation of UI components
    into the output stream, `RenderKit` represents a collection of `Renderer` instances
    capable to render JSF UI component''s instances for a specific client (for example,
    a specific device). Each time JSF needs to render a UI component, it will call
    the `RenderKit.getRenderer` method which is capable of returning an instance of
    the corresponding renderer based on two arguments that uniquely identifies it:
    the **component family** and the **renderer type**.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Renderer` 类将 UI 组件的内部表示转换为输出流时，`RenderKit` 代表了一组能够为特定客户端（例如，特定设备）渲染 JSF UI
    组件实例的 `Renderer` 实例。每次 JSF 需要渲染 UI 组件时，它将调用 `RenderKit.getRenderer` 方法，该方法能够根据两个唯一标识它的参数返回相应渲染器的实例：**组件家族**和**渲染器类型**。
- en: Let's suppose that we want to alter the default behavior of the renderer used
    for all UI components grouped under the `javax.faces.Input` family, by adding
    a custom style using some CSS. This can be easily accomplished by writing a custom
    `RenderKit` and overriding the `getRenderer` method. Starting with JSF 2.2, we
    can do this pretty fast, because we can extend the new wrapper class that represents
    a simple implementation of the abstract class, `RenderKit`. This is named `RenderKitWrapper`
    and allows us to override only the desired methods.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要改变用于所有属于`javax.faces.Input`家族的UI组件的默认渲染器的行为，通过添加一些CSS中的自定义样式。这可以通过编写自定义`RenderKit`并重写`getRenderer`方法轻松实现。从JSF
    2.2开始，我们可以非常快速地做到这一点，因为我们可以扩展代表抽象类`RenderKit`的简单实现的新的包装类。这个类命名为`RenderKitWrapper`，它允许我们仅重写所需的方法。
- en: 'For example, we override the `getRenderer` method as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们如下重写`getRenderer`方法：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So, when JSF needs to render a UI component that belongs to `javax.faces.Input`
    family, we take the original renderer used for this task and wrap it into a custom
    renderer named `RafaRenderer`. This custom renderer will extend the JSF 2.2 `RendererWrapper`
    (a simple implementation of `Renderer`) and will override the `encodeBegin` method,
    as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当JSF需要渲染属于`javax.faces.Input`家族的UI组件时，我们使用用于此任务的原始渲染器，并将其包装到名为`RafaRenderer`的自定义渲染器中。这个自定义渲染器将扩展JSF
    2.2的`RendererWrapper`（`Renderer`的一个简单实现）并重写`encodeBegin`方法，如下所示：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is good to know that we can specify external resources (such as CSS and JS)
    for a JSF renderer using the `@ResourceDependency` and `@ResourceDependecies`
    annotations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 好知道我们可以使用`@ResourceDependency`和`@ResourceDependecies`注解为JSF渲染器指定外部资源（例如CSS和JS）。
- en: 'Finally, you need to configure the custom `RenderKit` in `faces-config.xml`,
    as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要按照如下方式在`faces-config.xml`中配置自定义的`RenderKit`：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The complete application is named `ch5_15`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为`ch5_15`。
- en: Working with client behavior functionality
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与客户端行为功能一起工作
- en: JSF 2 comes with the ability to define specific client-side behavior to a component
    in a reusable approach. The client-side behavior is actually a piece of JavaScript
    code that can be executed in a browser.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2提供了以可重用方式为组件定义特定客户端行为的能力。客户端行为实际上是一段可以在浏览器中执行的JavaScript代码。
- en: For example, when the user has access to buttons that perform irreversible changes;
    for example, deletion, copy, and move is a good practice to inform the user about
    consequences and ask for a confirmation before the action is performed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当用户可以访问执行不可逆更改的按钮时；例如，删除、复制和移动，在执行操作之前通知用户后果并请求确认是一个好的做法。
- en: 'For implementing a client behavior functionality, we perform the following
    steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现客户端行为功能，我们执行以下步骤：
- en: Extend the `ClientBehaviorBase` class.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展`ClientBehaviorBase`类。
- en: Override the `getScript` method.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`getScript`方法。
- en: Annotate the created class with the `@FacesBehavior (value="`*developer_id*`")`
    annotation where *developer_id* is used to refer to our custom client behavior.
    This is needed when we define a tag for the behavior.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`@FacesBehavior (value="`*developer_id*`")`注解标注创建的类，其中*developer_id*用于引用我们的自定义客户端行为。当我们为行为定义一个标签时，这是必需的。
- en: Define a custom tag for the behavior—a tag is needed for specifying in the JSF
    pages, which components receive our client behavior (the JS code).
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个用于行为的自定义标签——在JSF页面中需要一个标签来指定哪些组件接收我们的客户端行为（JS代码）。
- en: Register the custom tag in the descriptor of the `web.xml` file.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`web.xml`文件的描述符中注册自定义标签。
- en: 'The following code shows you how to write a client behavior for displaying
    a JavaScript confirmation dialog when the user clicks on a button that emulates
    a deletion action, which covers the first three steps mentioned earlier:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何编写一个客户端行为，用于在用户点击模拟删除操作的按钮时显示JavaScript确认对话框，这涵盖了前面提到的前三个步骤：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The fourth step consists of writing a custom tag for the behavior. Create a
    file named `delete.taglib.xml` under the `WEB-INF` folder as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第四步是编写一个用于行为的自定义标签。在`WEB-INF`文件夹下创建一个名为`delete.taglib.xml`的文件，如下所示：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `<behavior-id>` tag value must match the `value` member of the `FacesBehavior`
    annotation (*developer_id*). The tag name can be freely chosen.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`<behavior-id>`标签的值必须与`FacesBehavior`注解的`value`成员匹配（*developer_id*）。标签名可以自由选择。'
- en: 'The final step consists of registering the tag in `web.xml`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在`web.xml`中注册标签：
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can attach a client behavior to every component that implements the `ClientBehaviourHolder`
    interface. Fortunately, almost all components implement this interface, such as
    buttons, links, input fields, and so on.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将客户端行为附加到实现`ClientBehaviourHolder`接口的每个组件上。幸运的是，几乎所有组件都实现了这个接口，例如按钮、链接、输入字段等等。
- en: 'Done! Now, we can pick up the fruits in a JSF page as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，我们可以在JSF页面上捡起水果，如下所示：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If the user doesn't confirm deletion, the action is aborted.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户没有确认删除，则操作将被中止。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting with JSF 2.2, we can use dependency injection with client behavior
    (`@Inject` and `@EJB`). For example, instead of hardcoding the confirmation question,
    "Are you sure?", we can pass it through injection of a CDI bean or an EJB session
    bean. A complete example can be found in the code bundle of this chapter. It is
    named `ch5_5_1`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从JSF 2.2版本开始，我们可以使用依赖注入与客户端行为（`@Inject`和`@EJB`）。例如，我们不是硬编码确认问题“你确定吗？”，而是可以通过CDI豆或EJB会话豆的注入来传递它。一个完整的示例可以在本章的代码包中找到。它被命名为`ch5_5_1`。
- en: Notice that the example works fine even if we do not specify any event that
    starts the client behavior JS code. This is happening because the JS code is attached
    to the `onclick` event of the button, which is the default event for `<h:commandButton>`.
    Now, we will write another example that will attach the client behavior to two
    other events simultaneously.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使我们没有指定启动客户端行为JS代码的事件，示例也能正常工作。这是因为JS代码被附加到按钮的`onclick`事件上，这是`<h:commandButton>`的默认事件。现在，我们将编写另一个示例，将客户端行为同时附加到两个其他事件上。
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can attach the client behavior code to some other event by specifying the
    event name with the `event` attribute of the tag.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过指定标签的`event`属性来将客户端行为代码附加到其他事件上。
- en: 'In the next example, we assume the following scenario: an input field that
    is colored in green when it gains focus (`onfocus` JS event) and turns back to
    blank when it loses focus (`onblur` JS event). Now, we have to subscribe to two
    events.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们假设以下场景：一个输入字段在获得焦点时变为绿色（`onfocus` JS事件），在失去焦点时恢复为空白（`onblur` JS事件）。现在，我们必须订阅两个事件。
- en: In the previous example, we explicitly link the client behavior functionality
    to the `<confirmDelete>` tag. Even if this is still possible for this scenario,
    we choose to come with another approach. Instead of a direct link, we will use
    a tag handler (`TagHandler`).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们明确地将客户端行为功能链接到`<confirmDelete>`标签。即使在这种情况下仍然可行，我们选择采用另一种方法。而不是直接链接，我们将使用标签处理器（`TagHandler`）。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A custom tag handler allows us to manipulate the created DOM tree (add/remove
    nodes from the tree).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义标签处理器允许我们操作创建的DOM树（从树中添加/删除节点）。
- en: 'When we write a custom tag handler, we need to focus on the apply method, especially
    on the second argument of this method that is named parent and represents the
    parent of the tag, which in our case will be `<h:inputText>`. We can add both
    the events to `<h:inputText>`, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写自定义标签处理器时，我们需要关注`apply`方法，特别是这个方法的第二个参数，它被命名为`parent`，代表标签的父级，在我们的情况下将是`<h:inputText>`。我们可以将这两个事件都添加到`<h:inputText>`中，如下所示：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Remember that in the preceding section, we saw how to override a few JSF renderers.
    Well, here is one more! Instead of overriding the `getScript` method of the `ClientBehaviorBase`,
    as in the previous example, we will write a custom renderer, which is easy to
    achieve because JSF provides a dedicated renderer for client behavior, named `ClientBehaviorRenderer`.
    This renderer contains its own `getScript` method as shown in the following code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在前面的章节中，我们看到了如何覆盖一些JSF渲染器。嗯，这里还有一个！与上一个示例中覆盖`ClientBehaviorBase`的`getScript`方法不同，我们将编写一个自定义渲染器，这很容易实现，因为JSF提供了一个专门用于客户端行为的渲染器，名为`ClientBehaviorRenderer`。此渲染器包含自己的`getScript`方法，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `@ResourceDependency` annotation can be used for loading resources such
    as CSS and JS in custom `UIComponent` and `Renderer` components. In several versions
    of JSF, `@ResourceDependency` is not working as expected for `Renderer`s (seems
    to be a bug). In case you have such issues, you have to hardcode the CSS for testing.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ResourceDependency`注解可用于在自定义`UIComponent`和`Renderer`组件中加载资源，如CSS和JS。在JSF的几个版本中，`@ResourceDependency`对于`Renderer`没有按预期工作（似乎是一个bug）。如果你遇到这样的问题，你必须为测试硬编码CSS。'
- en: 'Finally, the client behavior will point out the above renderer as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，客户端行为将如下指出上述渲染器：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The complete example containing the CSS source, the tag definition, and specific
    configurations is available in the code bundle and is named `ch5_5_2`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: JSF factories
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following note is a good point to start for the last part of this chapter,
    which is dedicated to JSF factories. In JSF, the factories are initialized by
    `FactoryFinder`, which recognizes if a custom factory has a delegating constructor—a
    one argument constructor for the type of the factory.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is useful when we want to wrap standard factory from JSF, because `FactoryFinder`
    will pass in the previously known factory, usually the built-in one. Factory instances
    are obtained as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For example, `RenderKitFactory` can be found using the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Next to `FaceletFactory`, another new factory obtainable via `FactoryFinder`
    in JSF 2.2 is the new `FlashFactory`. We will discuss about `FaceletFactory` in
    the last chapter of this book, [Chapter 12](ch12.html "Chapter 12. Facelets Templating"),
    *Facelets Templating*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the global exception handler
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the JSF lifecycle, we need to treat different kinds of exceptions in
    different points of the application. Starting with JSF 2, we have a generic API
    that allows us to write a global exception handler. This can be very handy, especially
    when we need to avoid "silent" exceptions that are not caught by the application.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to write a global exception handler, we need to do the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Extend `ExceptionHandlerFactory`, which is a factory object that is capable
    of creating and returning a new `ExceptionHandler` instance—the central point
    for handling unexpected `Exception`s that are thrown during the JSF lifecycle.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend `ExceptionHandlerWrapper`, which is a simple implementation of `ExceptionHandler`.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the custom exception handler in `faces-config.xml`.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, we can write a custom exception handler factory as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Our implementation for dealing with the exception is to send each error to
    a log and navigate to an error page, as shown in the following code (notice that
    `ViewExpiredException` can be caught here as well):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, we need to configure the exception handler in `faces-config.xml` as
    follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The complete example is named `ch5_3`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use dependency injection with exception handler
    (`@Inject` and `@EJB`).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Notice that a special case exists in treating AJAX exceptions. By default, most
    of them are invisible to the client. AJAX errors are returned to the client, but
    unfortunately JSF AJAX clients aren't prepared to deal with arbitrary error messages,
    so they simply ignore them. But a custom exception handler is specially created
    for this task by OmniFaces (it works for AJAX and non-AJAX exceptions). The handler
    is named `FullAjaxExceptionHandler`, and the factory is named `FullAjaxExceptionHandlerFactory`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you install OmniFaces, you can exploit the AJAX exception handler with
    a simple configuration in `faces-config.xml`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The behavior of the OmniFaces exception handler is configured in `web.xml`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: OmniFaces异常处理器的行为在`web.xml`中配置：
- en: '[PRE54]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Error pages for OmniFaces exception handler should be JSF 2.0 (or more) pages.
    A comprehensive demo can be found in OmniFaces showcase at [http://showcase.omnifaces.org/exceptionhandlers/FullAjaxExceptionHandler](http://showcase.omnifaces.org/exceptionhandlers/FullAjaxExceptionHandler).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: OmniFaces异常处理器的错误页面应该是JSF 2.0（或更高版本）页面。一个全面的演示可以在OmniFaces展示区[http://showcase.omnifaces.org/exceptionhandlers/FullAjaxExceptionHandler](http://showcase.omnifaces.org/exceptionhandlers/FullAjaxExceptionHandler)找到。
- en: Configuring RenderKit factory
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置RenderKit工厂
- en: 'Earlier in this chapter, we have written a custom `RenderKit`, which was loaded
    by JSF because we have configured it in `faces-config.xml` using the `<render-kit>`
    tag. But, behind the scene, JSF uses `RenderKitFactory`, which is capable of registering
    and returning `RenderKit` instances. Therefore, we can write custom `RenderKitFactory`
    for returning our custom `RenderKit`. For writing such a factory, you need to
    do the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我们已经编写了一个自定义的`RenderKit`，由于我们在`faces-config.xml`中使用`<render-kit>`标签进行了配置，因此JSF加载了它。但是，在幕后，JSF使用`RenderKitFactory`，它能够注册和返回`RenderKit`实例。因此，我们可以编写自定义的`RenderKitFactory`以返回我们的自定义`RenderKit`。为了编写这样的工厂，你需要执行以下操作：
- en: Extend the `RenderKitFactory` class that is responsible for registering and
    returning `RenderKit` instances.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展负责注册和返回`RenderKit`实例的`RenderKitFactory`类。
- en: Override the `addRenderKit` method that registers the specified `RenderKit`
    instance using the specified ID.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`addRenderKit`方法，使用指定的ID注册指定的`RenderKit`实例。
- en: Override the `getRenderKit` method that returns `RenderKit` with the specified
    ID.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`getRenderKit`方法，返回具有指定ID的`RenderKit`。
- en: Override the `getRenderKitIds` method and return an `Iterator` over the set
    of render kit identifiers registered with this factory.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`getRenderKitIds`方法，并返回由该工厂注册的渲染套件标识符集合的`Iterator`。
- en: 'Based on these steps, we can register our custom `RenderKit` as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些步骤，我们可以如下注册我们的自定义`RenderKit`：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, instead of configuring the custom `RenderKit` using the `<render-kit>`
    tag, we can configure the custom `RenderKitFactory`, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再使用`<render-kit>`标签来配置自定义的`RenderKit`，而是可以配置自定义的`RenderKitFactory`，如下所示：
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The complete application is named `ch5_16`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为`ch5_16`。
- en: Configuring PartialViewContext
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置PartialViewContext
- en: 'The `PartialViewContext` class is responsible for processing partial requests
    and rendering partial responses on a view. In other words, JSF processes execution,
    rendering, and so on, of AJAX requests and responses using `PartialViewContext`.
    We refer to it as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`PartialViewContext`类负责处理部分请求并在视图中渲染部分响应。换句话说，JSF使用`PartialViewContext`来处理AJAX请求和响应的执行、渲染等。我们如下引用它：'
- en: '[PRE57]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Writing a custom `PartialViewContext` implementation implies the following
    steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 编写自定义`PartialViewContext`实现意味着以下步骤：
- en: Extending `PartialViewContextFactory`, will result in a factory object capable
    of creating and returning a new `PartialViewContext` instance, the central point
    for handling partial request-responses.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展`PartialViewContextFactory`将产生一个能够创建和返回新的`PartialViewContext`实例的工厂对象，这是处理部分请求-响应的中心点。
- en: Extending `PartialViewContextWrapper`, which is a simple implementation of `PartialViewContext`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展`PartialViewContextWrapper`，它是`PartialViewContext`的一个简单实现。
- en: Configuring the custom `PartialViewContext` implementation in `faces-config.xml`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`faces-config.xml`中配置自定义的`PartialViewContext`实现。
- en: Now, let's suppose that we have multiple forms that are submitted through AJAX.
    Each `<f:ajax>` tag will contain the `execute` attribute and the one that we are
    especially interested in, the `render` attribute. This attribute should contain
    client IDs for the components to re-render. When multiple partial requests re-render
    the same component, the ID of that component is present in each partial request
    (in each `render` attribute).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有多份表单通过AJAX提交。每个`<f:ajax>`标签将包含`execute`属性以及我们特别感兴趣的`render`属性。此属性应包含要重新渲染的组件的客户ID。当多个部分请求重新渲染相同的组件时，该组件的ID存在于每个部分请求中（每个`render`属性中）。
- en: 'A common case is the global `<h:messages>` tag. The ID of this tag should be
    added to each partial request that needs to re-render it. Instead of re-typing
    the client IDs in the `render` attribute, we can write a custom `PartialViewContext`
    implementation to do that. First, we create the factory instance as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, we write our custom `PartialViewContext` and override the `getRenderIds`
    method. Basically, we locate the ID of the `<h:messages>` tag, check if this ID
    is already in the render IDs list, and add it to the list if it has not yet been
    added, as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, we need to configure `PartialViewContext` in `faces-config.xml` as
    follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The complete example is named `ch5_6_1`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use dependency injection with partial view context
    (`@Inject` and `@EJB`). A complete example can be found in the code bundle of
    this chapter, under the name `ch5_6_2`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Configuring visitContext
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to the documentation, `VisitContext` is an object used to hold the
    state relating to performing a component tree visit.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need such an object? Well, imagine that you want to programmatically
    find a certain component. You will probably think of `findComponent` or `invokeOnComponent`
    built-in methods. When you need to find several components, you can apply the
    process recursively (as you saw in a few examples earlier). The recursive process
    performs a clean traversal of the component's tree (or subtree) by visiting each
    node in a hierarchical approach.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'However, JSF 2 also provides an out-of-the-box method to accomplish a component''s
    tree traversal named `UIComponent.visitTree`, declared as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The first argument is an instance of `VisitContext`, and the second one is an
    instance of the `VisitCallback` interface that provides a method, named `visit`,
    which is called for each node that is visited. If the tree was successfully traversed,
    then `visitTree` returns `true`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Based on this knowledge, we can write a custom `VisitContext` implementation
    for resetting the editable components of a form. Such a component implements the
    `EditableValueHolder` interface and provides a method `resetValue`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for writing a custom `VisitContext` implementation are as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Extending `VisitContextFactory`, which is a factory object capable of creating
    and returning a new `VisitContext` instance.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extending `VisitContextWrapper`, which is a simple implementation of `VisitContext`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the custom `VisitContext` implementation in `faces-config.xml`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, first we need to extend the built-in factory as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we can also specify a collection of client IDs to be visited. We can
    also specify some visit hints. When all components should be visited with the
    default visit hints, these arguments can be `null`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'The custom visit context is represented programmatically as follows—the method
    `invokeVisitCallback` is called by `visitTree` to visit a single component:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'So, our custom `VisitContext` implementation doesn''t do much; it just fires
    some log messages and delegates the control to the original `VisitContext` class.
    Our aim is to write a custom `VisitCallback` implementation for resetting editable
    values of a form using the following code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的自定义`VisitContext`实现并没有做太多；它只是触发一些日志消息并将控制权委托给原始的`VisitContext`类。我们的目标是编写一个自定义的`VisitCallback`实现，用于重置表单的可编辑值，如下所示：
- en: '[PRE64]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Well, we are almost done! Just configure the custom `VisitContext` implementation
    in `faces-config.xml` form using the following code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们几乎完成了！只需使用以下代码在`faces-config.xml`中配置自定义的`VisitContext`实现：
- en: '[PRE65]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let''s start the process of visiting nodes using the following code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下代码开始访问节点的过程：
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Note that the starting point in the traversal process is the view root. This
    is not mandatory; you can pass any other subtree.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，遍历过程的起点是视图根。这并不是强制的；你可以传递任何其他的子树。
- en: An obvious question arises here! Since this custom `VisitContext` doesn't do
    something important (only fires some log messages), why don't we skip it?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这里出现了一个明显的问题！既然这个自定义的`VisitContext`并没有做重要的事情（只是触发一些日志消息），为什么我们不跳过它？
- en: Yes, it is true that we can skip this custom `VisitContext`, since all we need
    is the custom `VisitCallback` implementation, but it was a good opportunity to
    see how it can be done. Maybe you can modify `invokeVisitCallback` to implement
    some kind of client ID filtration before getting the action into the `VisitCallback.visit`
    method.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，确实我们可以跳过这个自定义的`VisitContext`，因为我们只需要自定义的`VisitCallback`实现，但这是一个很好的机会来了解它是如何实现的。也许你可以修改`invokeVisitCallback`来在将动作传递到`VisitCallback.visit`方法之前实现某种客户端ID过滤。
- en: A complete example can be found in the code bundle of this chapter, which is
    named `ch5_7`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的示例可以在本章的代码包中找到，命名为`ch5_7`。
- en: Note
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting with JSF 2.2, we can use dependency injection with visit context (`@Inject`
    and `@EJB`).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 从JSF 2.2开始，我们可以使用依赖注入与访问上下文（`@Inject`和`@EJB`）。
- en: Configuring ExternalContext
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置外部上下文
- en: The `FacesContext` and `ExternalContext` objects are two of the most important
    objects in JSF. Each of them provides powerful capabilities and each of them covers
    an important area of artifacts provided by JSF (in case of `FacesContext`) and
    Servlet/Portlet (in case of `ExternalContext`).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`FacesContext`和`ExternalContext`对象是JSF中最重要的两个对象。它们各自提供了强大的功能，并且各自覆盖了JSF（在`FacesContext`的情况下）和Servlet/Portlet（在`ExternalContext`的情况下）提供的重要的工件领域。'
- en: 'Furthermore, both of them can be extended or modified by the developers. For
    example, in this section we will write a custom `ExternalContext` implementation
    for downloading a file. Sometimes, you may need to download a file by programmatically
    sending its content to the user. The default `ExternalContext` can do that, as
    shown in the following code—of course, you can easily adapt this code for other
    files:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它们都可以被开发者扩展或修改。例如，在本节中，我们将编写一个用于下载文件的自定义`ExternalContext`实现。有时，你可能需要通过将文件内容程序化地发送给用户来下载文件。默认的`ExternalContext`可以做到这一点，如下所示——当然，你可以轻松地适应这段代码来处理其他文件：
- en: '[PRE67]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Normally, this approach uses the default response output stream. But let''s
    suppose that we have written our "dummy" response output stream which, obviously,
    does a dummy action: for each chunk of bytes, replace the ''`a`'' character with
    the ''`A`'' character as shown in the following code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这种方法使用默认的响应输出流。但假设我们已经编写了我们的“虚拟”响应输出流，显然，它执行一个虚拟操作：对于每个字节数组块，将字符`'a'`替换为字符`'A'`，如下所示：
- en: '[PRE68]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we want to use this response output stream instead of the default one,
    but there is no `externalContext.setResponseOutputStream(OutputStream os)` method.
    Instead, we can write a custom `ExternalContext`, by performing the following
    steps:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要使用这个响应输出流而不是默认的输出流，但是没有`externalContext.setResponseOutputStream(OutputStream
    os)`方法。相反，我们可以通过以下步骤编写一个自定义的`ExternalContext`：
- en: Extending `ExternalContextFactory`, which is a factory object capable of creating
    and returning a new `ExternalContext`.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展`ExternalContextFactory`，这是一个能够创建和返回一个新的`ExternalContext`的工厂对象。
- en: Extending `ExternalContextWrapper`, which is a simple implementation of `ExternalContext`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展`ExternalContextWrapper`，它是对`ExternalContext`的一个简单实现。
- en: Configuring the custom `ExternalContext` implementation in `faces-config.xml`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`faces-config.xml`中配置自定义的`ExternalContext`实现。
- en: 'The custom external context factory code is as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义外部上下文工厂的代码如下：
- en: '[PRE69]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The custom external context is given as follows. Here, we override the `getResponseOutputStream`
    method to return our custom response output stream.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Finally, do not forget to configure the custom external context in `faces-config.xml`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The complete example can be downloaded from the code bundle of this chapter
    named `ch5_8`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use dependency injection with external context
    and faces context (`@Inject` and `@EJB`).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: JSF also provides factory (`FacesContextFactory`) and wrapper (`FacesContextWrapper`)
    classes for extending the default `FacesContext` class. This can be extended when
    you need to adapt JSF to Portlet environment, or use JSF to run inside another
    environment.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Flash
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting with JSF 2.2, we have a hook for overriding and/or wrapping the default
    implementation of Flash. Usually, we refer a Flash instance using the following
    code:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'When advanced topics require a custom implementation, you can perform the following
    steps:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Extend `FlashFactory`, which is a factory object capable of creating and returning
    a new `Flash` instance.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend `FlashWrapper`, which is a simple implementation of `Flash` that allows
    us to selectively override methods.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the custom `Flash` implementation in `faces-config.xml`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, a custom Flash factory can be written using the following code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `CustomFlash` instance returned by the `getFlash` method is as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the `CustomFlash` class, you can override the methods of `javax.faces.context.Flash`
    that need to have a custom behavior. For example, you can override the `setKeepMessages`
    method to output some logs using the following code:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'A custom flash factory is configured in `faces-config.xml` using the following
    code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The complete example is named `ch5_9`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use dependency injection with Flash (`@Inject`
    and `@EJB`).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: JSF 2.2 Window ID API
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The origin of the Window ID mechanism relies on an HTML gap—this protocol is
    stateless, which means that it doesn't associate clients with requests. JSF solves
    this issue using a cookie for tracking user sessions, but sometimes this is not
    enough, and a fine-grained tracking mechanism is needed. For example, if a user
    opens several tabs/windows, then the same session is used in all of them, meaning
    that the same cookie is sent to the server and the same login account is used
    (when login exists). This can be a real issue if the user operates modifications
    in these tabs/windows.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: In order to provide a workaround for this problem, JSF 2.2 has introduced the
    Window ID API, which allows developers to identify separate tabs/windows of the
    same session.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Under certain circumstances, you can track users' window IDs using view scope
    and flash scope. But Window ID is easier to use and is dedicated to this purpose.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers can choose the method used for tracking window IDs by setting the
    context parameter `javax.faces.CLIENT_WINDOW_MODE` in `web.xml` as follows—in
    JSF 2.2, the supported values are `url` (tracking activated) and `none` (tracking
    deactivated):'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'When `url` is specified, the user''s window IDs are tracked using a hidden
    field or a request parameter named `jfwid`. In the following screenshot, you can
    see both of them, the request parameter and hidden field:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '![JSF 2.2 Window ID API](img/6466EN_05_02.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the hidden field (available after a postback) and request parameter are
    available, the hidden field has a bigger precedence.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily get the Window ID using the following code:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ClientWindow` instance can be obtained using `ExternalContext.getClientWindow`
    and can be provided as `ExternalContext.setClientWindow`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'You can enable/disable user window tracking in at least two ways which are
    as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'In `<h:button>` and `<h:link>`, you can use the `disableClientWindow` attribute
    whose value can be `true` or `false`, as shown in the following code:'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Alternatively, we can use the `disableClientWindowRenderMode` and `enableClientWindowRenderMode`
    methods as shown in the following code:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: A complete application is available in the code bundle of this chapter which
    is named `ch5_10_1`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers can write custom `ClientWindow` implementations by extending the
    `ClientWindowWrapper` class, which is a simple and convenient implementation that
    allows us to override only the necessary methods. One way to tell JSF to use your
    custom `ClientWindow` is based on the following steps:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Extend `ClientWindowFactory`, which is a factory that is capable of creating
    `ClientWindow` instances based on the incoming request.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override `ClientWindowFactory.getClientWindow` to create an instance of the
    custom `ClientWindow` implementation for the current request.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the value of the context parameter `ClientWindow.CLIENT_WINDOW_MODE_PARAM_NAME`,
    before creating an instance of the custom `ClientWindow` implementation. The value
    of the context parameter should be equal to `url`.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Based on these three steps, we can write a custom `ClientWindowFactory` implementation
    using the following code:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `CustomClientWindow` implementation is an extension of `ClientWindowWrapper`,
    which allows us to override only the needed methods. In our case, we are interested
    in two methods. The first one is named `getId`, which returns a `String` value
    that uniquely identifies `ClientWindow` within the scope of the current session.
    The other one is named `decode`, which is responsible for providing the value
    returned by `getId`. In order to provide this value, the `decode` method should
    follow the given checks:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Request a parameter under the name given by the value of `ResponseStateManager.CLIENT_WINDOW_PARAM`.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this check doesn't return a favorable ID, look for a request parameter under
    the name given by the value of `ResponseStateManager.CLIENT_WINDOW_URL_PARAM`.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an ID value is not found, then fabricate an ID that uniquely identifies this
    `ClientWindow` within the scope of the current session.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Furthermore, we can write a custom `ClientWindow` implementation that will
    generate a custom ID, of type `CUSTOM`—current date in milliseconds. The code
    is listed as follows–pay attention to see how the `decode` method is implemented:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Finally, configure the custom `ClientWindowFactory` implementation in `faces-config.xml`
    using the following code:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Done! The complete application is named `ch5_10_3`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to create an ID of type `UUID-uuid::counter` then, you can write
    the `decode` method, as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In this case, the complete application is named `ch5_10_4`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a counter may be very useful when you decide to use an ID of type `SESSION_ID::counter`.
    Since the session ID will be the same over multiple windows/tabs, you need the
    counter to differentiate between the IDs. This kind of ID can be easily obtained
    thanks to the `ExternalContext.getSessionId` method of JSF 2.2, which is as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Configuring lifecycle
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you know, JSF lifecycle contains six phases. In order to be processed, each
    JSF request will go through all these phases, or only through a part of them.
    The abstraction of lifecycle model is represented by the `javax.faces.lifecycle.Lifecycle`
    class, which is responsible for executing JSF phases in two methods:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: The `execute` method will execute all the phases except the sixth phase, that
    is, the *Render Response* phase.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `render` method will execute the sixth phase.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The custom `Lifecycle` can be written by implementing the following steps:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Extend `LifecycleFactory`, which is a factory object capable of creating and
    returning a new `Lifecycle` instance.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend `LifecycleWrapper`, which is a simple implementation of `LifecycleLifecycle`
    that allows us to selectively override methods.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the custom `Lifecycle` implementation in `faces-config.xml`.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the custom `Lifecycle` implementation in `web.xml`.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s begin with a generic custom `Lifecycle`, by extending `LifecycleFactory`
    as follows—notice how we register a custom `Lifecycle` implementation using a
    unique identifier:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Furthermore, `CustomLifecycle` extends `LifecycleWrapper` and overrides the
    required methods. In order to have access to the instance of the class being wrapped,
    we need to override the `getWrapped` method as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Next, we need to configure our custom lifecycle factory in `faces-config.xml`
    as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Finally, we need to register the custom lifecycle in `web.xml` using its identifier
    (see the highlighted code):'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: At this moment, we have a functional dummy custom lifecycle. Next, we will add
    some real functionality, and for this we focus on the `Lifecycle.attachWindow`
    method. This method was introduced in JSF 2.2 and is used for attaching a `ClientWindow`
    instance to the current request. The `ClientWindow` instance is associated with
    the incoming request during the `Lifecycle.attachWindow` method. This method will
    cause a new instance of `ClientWindow` to be created, to be assigned an ID, and
    then to be passed to `ExternalContext.setClientWindow(ClientWindow)`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *JSF 2.2 Window ID API* section, you saw how to explore the default
    mechanism for identifying different windows/tabs of users. Based on this knowledge,
    we have written a custom `ClientWindow` implementation to provide a custom ID
    for the `jfwid` request parameter of type `CUSTOM—current date in milliseconds`—and
    of type`UUID::counter`. The custom client window was set via a custom `ClientWindowFactory`
    implementation. Further, we set the same custom client window by overriding the
    `attachWindow` method as shown in the following code:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Done! The complete application is named `ch5_10_2`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the application
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The application represents a per-web-application singleton object, which is
    the heart of the JSF runtime. Through this object we can accomplish many tasks,
    such as adding components, converters, validators, subscribing to events, setting
    listeners, locales, and messaging bundles. It represents the entry point for many
    JSF artifacts. We refer to it using the following code:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The application can be extended and customized by following these steps:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Extend `ApplicationFactory`, which is a factory object capable of creating and
    returning a new `Application` instance.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend `ApplicationWrapper`, which is a simple implementation of `Application`
    that allows us to selectively override methods.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the custom `Application` implementation in `faces-config.xml`.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, we can use a custom `Application` implementation for adding a
    list of validators to an application. We start by writing a custom application
    factory as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now, the job is accomplished by `CustomApplication` as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Finally, configure the new custom application in `faces-config.xml` as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Note
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use dependency injection with application objects
    (`@Inject` and `@EJB`). The preceding example, with the list of validators provided
    by a CDI bean as a `Map`, is available in the code bundle of this chapter under
    the name `ch5_11`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Configuring VDL
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The abbreviation VDL stands for **View Declaration Language**, which represents
    the contract that a view declaration language must implement in order to interact
    with the JSF runtime. The `ViewDeclarationLanguageFactory` class is used to create
    and return instances of the `ViewDeclarationLanguage` class.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to alter how the runtime transforms an input file into a tree of components,
    you need to write a custom `ViewDeclarationLanguageFactory` implementation, which
    can be accomplished by extending the original class and overriding the `getViewDeclarationLanguage`
    method, as shown in the following code:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The `CustomViewDeclarationLanguage` implementation can be written by extending
    `ViewDeclarationLanguage` and overriding all methods, or extending the new JSF
    2.2 `ViewDeclarationLanguageWrapper` class and overriding only the needed method.
    Our `CustomViewDeclarationLanguage` implementation represents a simple skeleton
    based on the wrapper class as shown in the following code:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'This factory can be configured in `faces-config.xml` as follows:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Done! The complete application is named `ch5_17`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: At [https://code.google.com/p/javavdl/](https://code.google.com/p/javavdl/),
    you can see an implementation of a JSF VDL that allows pages or complete JSF applications
    to be authored in pure Java, without the need for any XML or other declarative
    markup (for example, Facelets).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Combined power of multiple factories
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last several sections, you saw how to customize and configure the most
    used JSF factories. In the final section of this chapter, you will see how to
    exploit a few factories in the same application. For example, a convenient scenario
    will assume that we want to fire a non-JSF request and get as response a JSF view.
    An approach of this scenario consists in writing a Java Servlet capable of converting
    a non-JSF request into a JSF view.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to write such a Servlet, we need to obtain access to `FacesContext`.
    For this, we can combine the power of the default `LifecycleFactory` class with
    the power of the default `FacesContextFactory` class. Further, we can access `Application`
    via `FacesContext`, which means that we can obtain the `ViewHandler` that is responsible
    for creating JSF views via the `createView` method. Once the view is created,
    all we need to do is to set `UIViewRoot` and tell `Lifecycle` to render the response
    (execute the *Render Response* phase). In lines of code, the Servlet looks like
    the following:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now, you can test very easily using the `<h:outputLink>` tag as follows:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The complete application is named `ch5_18`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, this was a pretty heavy chapter, but JSF's important aspects were touched
    upon here. You learned how to create, extend, and configure several of the main
    JSF 2.x artifacts, and how they have been improved by JSF 2.2, especially with
    the dependency injection mechanism. There are still a lot of things that were
    not discussed in this chapter, such as state management, facelet factory, and
    so on, but keep on reading.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: See you in the next chapter, where we will discuss about working with tabular
    data in JSF.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
