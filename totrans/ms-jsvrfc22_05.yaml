- en: Chapter 5. JSF Configurations Using XML Files and Annotations – Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will continue to explore more situations where the `faces-config.xml`
    file will help us to accomplish different configuration tasks (of course, for
    some of them we have the alternative of annotations, while for others, we need
    to switch to the XML configuration level). Besides the examples presented in the
    previous chapter, this chapter will go deeper and cover the further list of tasks,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring resource handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the View handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding JSF renders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with client behavior functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the Global Exception handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring render kit factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring partial view context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring visit context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring external context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Flash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSF 2.2 Window ID API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring VDL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining multiple factory's powers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring resource handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting with JSF 2.0, all the web resources, such as CSS, JavaScript, and
    images are loaded from a folder named `resources`, present under the root of your
    web application or from `/META-INF/resources` in JAR files. A folder under the
    `resources` folder is known as a `library` or `theme`, which is like a collection
    of client artifacts. We can also create a special folder matching the regex `\d+(_\d+)*`
    under the `library` folder for providing versioning. In this case, the default
    JSF resource handler will always retrieve the newest version to display. The various
    approaches that can be followed for structuring the `resources` folder are as
    shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring resource handlers](img/6466EN_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding figure, part **A** depicts a common structure of the `resources`
    folder without versioning, and in part **B**, you have the versioning approach.
    The folders `css`, `js`, `img`, and others usually denote the content type of
    files inside them; however, this is not mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the library name shouldn't denote the content type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part **C**, represents the complete structure of the subfolders supported under
    the `resources` folder. In this case, we entirely exploit the automatic localization
    and version management, which works if we respect the following structure under
    the `resources` folder and is known as *resourceIdentifier* (the `[]` demarcate
    optional parts):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the case of face flows packaged within JAR files, resources packaged in `CLASSPATH`
    must reside under the JAR entry name `META-INF/flows/resourceIdentifier`.
  prefs: []
  type: TYPE_NORMAL
- en: We will also discuss the case referred to in part **A**, since this is the most
    used case. But for the sake of completeness, you can check the complete application
    named `ch5_12`, which represents an implementation case from part **C** (that
    includes part **B** as well).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, having the structure from the preceding figure, we can easily load a CSS
    file (`rafa.css`) using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can load a JavaScript file (`rafa.js`) using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can load an image file (`rafa.png`) using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So, this is how the JSF default resource handler deals with resources. But
    what can we do if we don''t respect this inflexible structure of folders? For
    example, if we have the CSS files under the application web root in `/players/css/`,
    or we want to place resources in a protected folder, such as `WEB-INF` (probably
    the biggest disadvantage of the `resources` folder is that everything in it is
    accessible from outside by default). In this case, there is no directly accessible
    `resources` folder and we have no idea what a library is. If we write something
    like the following code, it will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Among the possible solutions, we have the facility to write a custom resource
    handler. It is much simpler than it sounds, because JSF provides several wrappers
    (implements `FacesWrapper`) that help us to write custom handlers and factories
    by overriding only the methods that we want to affect. In case of a custom resource
    handler, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend the `ResourceHandlerWrapper` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a delegating constructor. JSF will call this constructor for passing the
    standard resource handler, which we will wrap in a `ResourceHandler` instance.
    We can also obtain this instance by overriding the `getWrapped` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `createResource` method. Here, we can sort the resources and decide
    which of them go to the default resource handler and which of them go to our custom
    resource handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following implementation is based on the preceding three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PlayerResource` class is our custom resource. The main aim of `PlayerResource`
    is to indicate the correct path `/players/css/`, which is not recognized by default.
    For this, we extend another wrapper named `ResourceWrapper` and override the method
    `getRequestPath`, as follows, where we delegate all calls to `ResourceWrapper`
    except one call, `getRequestPath`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you have to configure the custom resource handler in `faces-config.xml`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you try to load the `rafa.css` (or `roger.css`) file, you can add the
    following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch5_1_1` and is available in the code bundle
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, remember that I said "Among the possible solutions ..."? Well, starting
    with JSF 2.2, we can indicate the folder of resources through a context parameter
    in the `web.xml` descriptor, as follows (mapped by the `ResourceHandler.WEBAPP_RESOURCES_DIRECTORY_PARAM_NAME`
    field):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can place the `resources` folder under `WEB-INF`, which can be accessed
    by JSF from inside `WEB-INF` but never from outside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A complete example named `ch5_1_2` is available in the code bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A custom resource handler can be useful to pass extra parameters to the linking
    file (for example CSS, JS, images, and so on). We can use this approach to reset
    the browser cache. Browsers cache static resources such as CSS, JS, and images;
    therefore they are not requested from the server each time the web page loads.
    We can force this by adding a parameter to the linking file in the query string,
    representing a version number or something that makes the browser to understand
    that it should load the resource from the server, not from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we assume that the `rafa.css` file is under the `/resources/default/css/`
    folder and it is loaded using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'At this moment, the generated HTML is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we want to obtain something like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For this, we need to override the `createResource` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, `PlayerResource` is responsible to add the version parameter in the `getRequestPath`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is available in the code bundle named `ch5_1_3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, in real cases, unlike in the preceding code, the version number
    is not hardcoded. Knowing that JSF 2.2 allows us to use dependency injection in
    custom resource handlers, we can inject the parameter values from a bean that
    can play the role of a version tracking system using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The complete example is named `ch5_1_4`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use the versioning system of JSF for invalidate browser cache,
    but you need to create the right folder under the library folder. - JSF will automatically
    load the last version. Passing parameters as we have seen earlier can be useful
    for many other things, such as generating customized JS and CSS response. Servers
    can access such parameters and JS as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browser caching can also be controlled with two context parameters in the `web.xml`
    descriptor (specific to Mojarra) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`com.sun.faces.defaultResourceMaxAge`: This parameter can be used to set the
    expiry time in milliseconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.sun.faces.resourceUpdateCheckPeriod`: This parameter gives frequency in
    minutes to check for changes in web application artifacts that contain resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JSF resource handling provides solid advantages such as caching and loading
    resources within a JAR or writing custom UI components that contain CSS or JS,
    but it also has some disadvantages. For example, web designers use the static
    approach to add images in CSS, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when importing CSS style sheets using `<h:outputStyleSheet>`, the
    style sheet is imported and processed by FacesServlet through the `/javax.faces.resource/*`
    folder, which makes the picture relative path unavailable (in this case, the CSS
    file becomes a JSF resource). One of the solutions is to force the image URL to
    become a JSF resource, using the resource mapper in EL, `#{resource}`, as `#{resource[''`*library*`:`*location*`'']}`.
    For example, in `rafa.css` (loaded in the page via `<h:outputStylesheet>`), we
    can load the `rafa.png` image using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this, `<h:graphicImage>` can load `rafa.png` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can check these examples in the application named `ch5_13`.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative, you can use OmniFaces library's `UnmappedResourceHandler`,
    which spares us from modifying the CSS files ([http://showcase.omnifaces.org/resourcehandlers/UnmappedResourceHandler](http://showcase.omnifaces.org/resourcehandlers/UnmappedResourceHandler)).
    Moreover, another approach consists in writing a custom `ResourceHandler` that
    can fix this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From JSF 2.2 onwards, `ResourceResolver` has been merged into `ResourceHandler`,
    and `ResourceResolver` itself has been deprecated. These two are detailed in [Chapter
    12](ch12.html "Chapter 12. Facelets Templating"), *Facelets Templating*.
  prefs: []
  type: TYPE_NORMAL
- en: Adding CSS and JS resources programmatically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you may need to load the CSS and JS resources by specifying them
    in a managed bean method. For example, the following method loads `rafa.css` and
    `rafa.js` in a programmatic fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch5_14`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the view handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSF provides a view handler that can be used for working with views. It can
    be a very handy tool when you want to interact with a view or create/restore/extend/modify
    a view. It is also good practice to deal with URLs here, which is exactly what
    you will see next.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A view handler is not a good choice when you need to work with components! Even
    if this is possible, view handlers were not created for such tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you may need to convert absolute URLs into relative URLs. For example,
    if you run an application behind a reverse proxy, you may need to provide relative
    URLs. By default, the browser appends each absolute URL to the host, which is
    obviously a big issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to convert absolute URLs into relative URLs, we need to perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new view handler by extending the `ViewHandlerWrapper` class. Extending
    this wrapper allows us to override only the required methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Override the `getActionURL` and `getResourceURL` methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the view handler in `faces-config.xml`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although it may sound pompous, the following code is self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The required configuration in `faces-config.xml` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is available in the code bundle named `ch5_2_1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you check the source code of the `index.xhtml` page, you will notice that
    instead of an absolute URL for the CSS resource, there is a relative one, of the
    following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Done! Now you can run the application behind a reverse proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful view handler is the one that "swallows" the `ViewExpiredException`
    exception. This exception is thrown when a user session expires. Through a view
    handler, we can treat this exception by recreating the user view. Redirect the
    flow to a special page (let's name it `expired.xhtml`).
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user session expires, `UIViewRoot` of the application is set to `null`.
    We can use this check in the `restoreView` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration in `faces-config.xml` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is available in the code bundle and is named `ch5_2_2`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use dependency injection with the view handler
    (`@Inject` and `@EJB`).
  prefs: []
  type: TYPE_NORMAL
- en: Overriding JSF renders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main responsibilities of a `Renderer` consists of generating the appropriate
    client-side markup, such as HTML, WML, and XUL, and converting information coming
    from the client to the proper type for the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSF provides a set of built-in renders and has the capability to extend them
    with custom behavior. If you consider a proper workaround to override a built-in
    render, then perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend the desired built-in renderer (for example, `Renderer`, `TextRenderer`,
    `LabelRenderer`, `MessagesRenderer`, and so on).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the built-in renderer methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the new renderer in `faces-config.xml` or using the `@FacesRenderer`
    annotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Well, let''s see some examples of writing a custom render. For example, let''s
    suppose that we have three attributes (`player-nickname`, `player-mother-name`,
    and `player-father-name`) that we want to use inside the `<h:inputText>` tag.
    If you try to write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the built-in renderer will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, our three attributes were ignored. We can fix this by extending
    `TextRenderer` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Done! Configure the new renderer in `faces-config.xml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the renderer input field will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of configuring the custom renderer in `faces-config.xml`, we could
    use the `@FacesRenderer` annotation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: But, unfortunately this isn't working. There seems to be a bug here!
  prefs: []
  type: TYPE_NORMAL
- en: The complete example is named `ch5_4_1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another example in order to fortify the knowledge about writing
    custom renderers. The next example will modify the built-in `LabelRenderer` class
    by adding an image in front of each `<h:outputText>` tag, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to configure the renderer in `faces-config.xml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use dependency injection in renderers (`@Inject`
    and `@EJB`). The complete example of the preceding renderer is named `ch5_4_2`
    (the image name was provided by another bean through injection dependency).
  prefs: []
  type: TYPE_NORMAL
- en: The upcoming example in this section is a little bit tricky.
  prefs: []
  type: TYPE_NORMAL
- en: If you have used PrimeFaces, especially the `<p:messages>` tag, then you know
    that this tag accepts an attribute named `escape`. The attribute's value can be
    `true` or `false`, and it defines whether HTML would be escaped or not (defaults
    to `true`).
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, JSF 2.2 still doesn't provide such attributes for the `<h:messages>`
    tag, but there is at least a workaround to solve this. You can implement a custom
    renderer that is capable of understanding the `escape` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: JSF provides a class named `ResponseWriter`, which is useful in this case because
    it provides methods capable of producing elements and attributes for markup languages
    such as HTML and XML. Moreover, JSF provides a wrapper for this class named `ResponseWriterWrapper`.
    We can easily extend this class, and override the method `writeText`, which is
    useful for writing escaped strings obtained from objects by conversions. Un-escaped
    strings are written by the `write` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, based on this information, we can easily write our response writer, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So far, so good! Now we need to write the custom renderer, as shown in the following
    code, by extending the `MessagesRenderer` class, which is the default renderer
    for JSF messages. The only method we need to affect is the `encodeEnd` method,
    by placing our response writer instead of the default one. In the end, we restore
    it to default.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, configure the new renderer in `faces-config.xml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can add HTML content in your messages by setting the `escape` attribute
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The complete example is named `ch5_4_3`.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding examples, we saw a few use cases of extending an existing renderer.
    The last example of this section will go a little bit further, and will represent
    a use case for writing a custom `RenderKit` and a custom renderer by extending
    the abstract class `Renderer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the `Renderer` class converts the internal representation of UI components
    into the output stream, `RenderKit` represents a collection of `Renderer` instances
    capable to render JSF UI component''s instances for a specific client (for example,
    a specific device). Each time JSF needs to render a UI component, it will call
    the `RenderKit.getRenderer` method which is capable of returning an instance of
    the corresponding renderer based on two arguments that uniquely identifies it:
    the **component family** and the **renderer type**.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose that we want to alter the default behavior of the renderer used
    for all UI components grouped under the `javax.faces.Input` family, by adding
    a custom style using some CSS. This can be easily accomplished by writing a custom
    `RenderKit` and overriding the `getRenderer` method. Starting with JSF 2.2, we
    can do this pretty fast, because we can extend the new wrapper class that represents
    a simple implementation of the abstract class, `RenderKit`. This is named `RenderKitWrapper`
    and allows us to override only the desired methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we override the `getRenderer` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'So, when JSF needs to render a UI component that belongs to `javax.faces.Input`
    family, we take the original renderer used for this task and wrap it into a custom
    renderer named `RafaRenderer`. This custom renderer will extend the JSF 2.2 `RendererWrapper`
    (a simple implementation of `Renderer`) and will override the `encodeBegin` method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is good to know that we can specify external resources (such as CSS and JS)
    for a JSF renderer using the `@ResourceDependency` and `@ResourceDependecies`
    annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to configure the custom `RenderKit` in `faces-config.xml`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch5_15`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with client behavior functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSF 2 comes with the ability to define specific client-side behavior to a component
    in a reusable approach. The client-side behavior is actually a piece of JavaScript
    code that can be executed in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when the user has access to buttons that perform irreversible changes;
    for example, deletion, copy, and move is a good practice to inform the user about
    consequences and ask for a confirmation before the action is performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For implementing a client behavior functionality, we perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend the `ClientBehaviorBase` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `getScript` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Annotate the created class with the `@FacesBehavior (value="`*developer_id*`")`
    annotation where *developer_id* is used to refer to our custom client behavior.
    This is needed when we define a tag for the behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a custom tag for the behavior—a tag is needed for specifying in the JSF
    pages, which components receive our client behavior (the JS code).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the custom tag in the descriptor of the `web.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code shows you how to write a client behavior for displaying
    a JavaScript confirmation dialog when the user clicks on a button that emulates
    a deletion action, which covers the first three steps mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The fourth step consists of writing a custom tag for the behavior. Create a
    file named `delete.taglib.xml` under the `WEB-INF` folder as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `<behavior-id>` tag value must match the `value` member of the `FacesBehavior`
    annotation (*developer_id*). The tag name can be freely chosen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step consists of registering the tag in `web.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can attach a client behavior to every component that implements the `ClientBehaviourHolder`
    interface. Fortunately, almost all components implement this interface, such as
    buttons, links, input fields, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Done! Now, we can pick up the fruits in a JSF page as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If the user doesn't confirm deletion, the action is aborted.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use dependency injection with client behavior
    (`@Inject` and `@EJB`). For example, instead of hardcoding the confirmation question,
    "Are you sure?", we can pass it through injection of a CDI bean or an EJB session
    bean. A complete example can be found in the code bundle of this chapter. It is
    named `ch5_5_1`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the example works fine even if we do not specify any event that
    starts the client behavior JS code. This is happening because the JS code is attached
    to the `onclick` event of the button, which is the default event for `<h:commandButton>`.
    Now, we will write another example that will attach the client behavior to two
    other events simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can attach the client behavior code to some other event by specifying the
    event name with the `event` attribute of the tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, we assume the following scenario: an input field that
    is colored in green when it gains focus (`onfocus` JS event) and turns back to
    blank when it loses focus (`onblur` JS event). Now, we have to subscribe to two
    events.'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we explicitly link the client behavior functionality
    to the `<confirmDelete>` tag. Even if this is still possible for this scenario,
    we choose to come with another approach. Instead of a direct link, we will use
    a tag handler (`TagHandler`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A custom tag handler allows us to manipulate the created DOM tree (add/remove
    nodes from the tree).
  prefs: []
  type: TYPE_NORMAL
- en: 'When we write a custom tag handler, we need to focus on the apply method, especially
    on the second argument of this method that is named parent and represents the
    parent of the tag, which in our case will be `<h:inputText>`. We can add both
    the events to `<h:inputText>`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that in the preceding section, we saw how to override a few JSF renderers.
    Well, here is one more! Instead of overriding the `getScript` method of the `ClientBehaviorBase`,
    as in the previous example, we will write a custom renderer, which is easy to
    achieve because JSF provides a dedicated renderer for client behavior, named `ClientBehaviorRenderer`.
    This renderer contains its own `getScript` method as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@ResourceDependency` annotation can be used for loading resources such
    as CSS and JS in custom `UIComponent` and `Renderer` components. In several versions
    of JSF, `@ResourceDependency` is not working as expected for `Renderer`s (seems
    to be a bug). In case you have such issues, you have to hardcode the CSS for testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the client behavior will point out the above renderer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The complete example containing the CSS source, the tag definition, and specific
    configurations is available in the code bundle and is named `ch5_5_2`.
  prefs: []
  type: TYPE_NORMAL
- en: JSF factories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following note is a good point to start for the last part of this chapter,
    which is dedicated to JSF factories. In JSF, the factories are initialized by
    `FactoryFinder`, which recognizes if a custom factory has a delegating constructor—a
    one argument constructor for the type of the factory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is useful when we want to wrap standard factory from JSF, because `FactoryFinder`
    will pass in the previously known factory, usually the built-in one. Factory instances
    are obtained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, `RenderKitFactory` can be found using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Next to `FaceletFactory`, another new factory obtainable via `FactoryFinder`
    in JSF 2.2 is the new `FlashFactory`. We will discuss about `FaceletFactory` in
    the last chapter of this book, [Chapter 12](ch12.html "Chapter 12. Facelets Templating"),
    *Facelets Templating*.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the global exception handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the JSF lifecycle, we need to treat different kinds of exceptions in
    different points of the application. Starting with JSF 2, we have a generic API
    that allows us to write a global exception handler. This can be very handy, especially
    when we need to avoid "silent" exceptions that are not caught by the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to write a global exception handler, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend `ExceptionHandlerFactory`, which is a factory object that is capable
    of creating and returning a new `ExceptionHandler` instance—the central point
    for handling unexpected `Exception`s that are thrown during the JSF lifecycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend `ExceptionHandlerWrapper`, which is a simple implementation of `ExceptionHandler`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the custom exception handler in `faces-config.xml`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, we can write a custom exception handler factory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Our implementation for dealing with the exception is to send each error to
    a log and navigate to an error page, as shown in the following code (notice that
    `ViewExpiredException` can be caught here as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to configure the exception handler in `faces-config.xml` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The complete example is named `ch5_3`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use dependency injection with exception handler
    (`@Inject` and `@EJB`).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that a special case exists in treating AJAX exceptions. By default, most
    of them are invisible to the client. AJAX errors are returned to the client, but
    unfortunately JSF AJAX clients aren't prepared to deal with arbitrary error messages,
    so they simply ignore them. But a custom exception handler is specially created
    for this task by OmniFaces (it works for AJAX and non-AJAX exceptions). The handler
    is named `FullAjaxExceptionHandler`, and the factory is named `FullAjaxExceptionHandlerFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you install OmniFaces, you can exploit the AJAX exception handler with
    a simple configuration in `faces-config.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The behavior of the OmniFaces exception handler is configured in `web.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Error pages for OmniFaces exception handler should be JSF 2.0 (or more) pages.
    A comprehensive demo can be found in OmniFaces showcase at [http://showcase.omnifaces.org/exceptionhandlers/FullAjaxExceptionHandler](http://showcase.omnifaces.org/exceptionhandlers/FullAjaxExceptionHandler).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring RenderKit factory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we have written a custom `RenderKit`, which was loaded
    by JSF because we have configured it in `faces-config.xml` using the `<render-kit>`
    tag. But, behind the scene, JSF uses `RenderKitFactory`, which is capable of registering
    and returning `RenderKit` instances. Therefore, we can write custom `RenderKitFactory`
    for returning our custom `RenderKit`. For writing such a factory, you need to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend the `RenderKitFactory` class that is responsible for registering and
    returning `RenderKit` instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `addRenderKit` method that registers the specified `RenderKit`
    instance using the specified ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `getRenderKit` method that returns `RenderKit` with the specified
    ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `getRenderKitIds` method and return an `Iterator` over the set
    of render kit identifiers registered with this factory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Based on these steps, we can register our custom `RenderKit` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, instead of configuring the custom `RenderKit` using the `<render-kit>`
    tag, we can configure the custom `RenderKitFactory`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch5_16`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring PartialViewContext
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `PartialViewContext` class is responsible for processing partial requests
    and rendering partial responses on a view. In other words, JSF processes execution,
    rendering, and so on, of AJAX requests and responses using `PartialViewContext`.
    We refer to it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing a custom `PartialViewContext` implementation implies the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Extending `PartialViewContextFactory`, will result in a factory object capable
    of creating and returning a new `PartialViewContext` instance, the central point
    for handling partial request-responses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extending `PartialViewContextWrapper`, which is a simple implementation of `PartialViewContext`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the custom `PartialViewContext` implementation in `faces-config.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's suppose that we have multiple forms that are submitted through AJAX.
    Each `<f:ajax>` tag will contain the `execute` attribute and the one that we are
    especially interested in, the `render` attribute. This attribute should contain
    client IDs for the components to re-render. When multiple partial requests re-render
    the same component, the ID of that component is present in each partial request
    (in each `render` attribute).
  prefs: []
  type: TYPE_NORMAL
- en: 'A common case is the global `<h:messages>` tag. The ID of this tag should be
    added to each partial request that needs to re-render it. Instead of re-typing
    the client IDs in the `render` attribute, we can write a custom `PartialViewContext`
    implementation to do that. First, we create the factory instance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we write our custom `PartialViewContext` and override the `getRenderIds`
    method. Basically, we locate the ID of the `<h:messages>` tag, check if this ID
    is already in the render IDs list, and add it to the list if it has not yet been
    added, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to configure `PartialViewContext` in `faces-config.xml` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The complete example is named `ch5_6_1`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use dependency injection with partial view context
    (`@Inject` and `@EJB`). A complete example can be found in the code bundle of
    this chapter, under the name `ch5_6_2`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring visitContext
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to the documentation, `VisitContext` is an object used to hold the
    state relating to performing a component tree visit.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need such an object? Well, imagine that you want to programmatically
    find a certain component. You will probably think of `findComponent` or `invokeOnComponent`
    built-in methods. When you need to find several components, you can apply the
    process recursively (as you saw in a few examples earlier). The recursive process
    performs a clean traversal of the component's tree (or subtree) by visiting each
    node in a hierarchical approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, JSF 2 also provides an out-of-the-box method to accomplish a component''s
    tree traversal named `UIComponent.visitTree`, declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is an instance of `VisitContext`, and the second one is an
    instance of the `VisitCallback` interface that provides a method, named `visit`,
    which is called for each node that is visited. If the tree was successfully traversed,
    then `visitTree` returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Based on this knowledge, we can write a custom `VisitContext` implementation
    for resetting the editable components of a form. Such a component implements the
    `EditableValueHolder` interface and provides a method `resetValue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for writing a custom `VisitContext` implementation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Extending `VisitContextFactory`, which is a factory object capable of creating
    and returning a new `VisitContext` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extending `VisitContextWrapper`, which is a simple implementation of `VisitContext`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the custom `VisitContext` implementation in `faces-config.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, first we need to extend the built-in factory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we can also specify a collection of client IDs to be visited. We can
    also specify some visit hints. When all components should be visited with the
    default visit hints, these arguments can be `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The custom visit context is represented programmatically as follows—the method
    `invokeVisitCallback` is called by `visitTree` to visit a single component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'So, our custom `VisitContext` implementation doesn''t do much; it just fires
    some log messages and delegates the control to the original `VisitContext` class.
    Our aim is to write a custom `VisitCallback` implementation for resetting editable
    values of a form using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, we are almost done! Just configure the custom `VisitContext` implementation
    in `faces-config.xml` form using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start the process of visiting nodes using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Note that the starting point in the traversal process is the view root. This
    is not mandatory; you can pass any other subtree.
  prefs: []
  type: TYPE_NORMAL
- en: An obvious question arises here! Since this custom `VisitContext` doesn't do
    something important (only fires some log messages), why don't we skip it?
  prefs: []
  type: TYPE_NORMAL
- en: Yes, it is true that we can skip this custom `VisitContext`, since all we need
    is the custom `VisitCallback` implementation, but it was a good opportunity to
    see how it can be done. Maybe you can modify `invokeVisitCallback` to implement
    some kind of client ID filtration before getting the action into the `VisitCallback.visit`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: A complete example can be found in the code bundle of this chapter, which is
    named `ch5_7`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use dependency injection with visit context (`@Inject`
    and `@EJB`).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring ExternalContext
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `FacesContext` and `ExternalContext` objects are two of the most important
    objects in JSF. Each of them provides powerful capabilities and each of them covers
    an important area of artifacts provided by JSF (in case of `FacesContext`) and
    Servlet/Portlet (in case of `ExternalContext`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, both of them can be extended or modified by the developers. For
    example, in this section we will write a custom `ExternalContext` implementation
    for downloading a file. Sometimes, you may need to download a file by programmatically
    sending its content to the user. The default `ExternalContext` can do that, as
    shown in the following code—of course, you can easily adapt this code for other
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, this approach uses the default response output stream. But let''s
    suppose that we have written our "dummy" response output stream which, obviously,
    does a dummy action: for each chunk of bytes, replace the ''`a`'' character with
    the ''`A`'' character as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to use this response output stream instead of the default one,
    but there is no `externalContext.setResponseOutputStream(OutputStream os)` method.
    Instead, we can write a custom `ExternalContext`, by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Extending `ExternalContextFactory`, which is a factory object capable of creating
    and returning a new `ExternalContext`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extending `ExternalContextWrapper`, which is a simple implementation of `ExternalContext`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the custom `ExternalContext` implementation in `faces-config.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The custom external context factory code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The custom external context is given as follows. Here, we override the `getResponseOutputStream`
    method to return our custom response output stream.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, do not forget to configure the custom external context in `faces-config.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The complete example can be downloaded from the code bundle of this chapter
    named `ch5_8`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use dependency injection with external context
    and faces context (`@Inject` and `@EJB`).
  prefs: []
  type: TYPE_NORMAL
- en: JSF also provides factory (`FacesContextFactory`) and wrapper (`FacesContextWrapper`)
    classes for extending the default `FacesContext` class. This can be extended when
    you need to adapt JSF to Portlet environment, or use JSF to run inside another
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Flash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting with JSF 2.2, we have a hook for overriding and/or wrapping the default
    implementation of Flash. Usually, we refer a Flash instance using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'When advanced topics require a custom implementation, you can perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend `FlashFactory`, which is a factory object capable of creating and returning
    a new `Flash` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend `FlashWrapper`, which is a simple implementation of `Flash` that allows
    us to selectively override methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the custom `Flash` implementation in `faces-config.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, a custom Flash factory can be written using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CustomFlash` instance returned by the `getFlash` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `CustomFlash` class, you can override the methods of `javax.faces.context.Flash`
    that need to have a custom behavior. For example, you can override the `setKeepMessages`
    method to output some logs using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'A custom flash factory is configured in `faces-config.xml` using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The complete example is named `ch5_9`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use dependency injection with Flash (`@Inject`
    and `@EJB`).
  prefs: []
  type: TYPE_NORMAL
- en: JSF 2.2 Window ID API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The origin of the Window ID mechanism relies on an HTML gap—this protocol is
    stateless, which means that it doesn't associate clients with requests. JSF solves
    this issue using a cookie for tracking user sessions, but sometimes this is not
    enough, and a fine-grained tracking mechanism is needed. For example, if a user
    opens several tabs/windows, then the same session is used in all of them, meaning
    that the same cookie is sent to the server and the same login account is used
    (when login exists). This can be a real issue if the user operates modifications
    in these tabs/windows.
  prefs: []
  type: TYPE_NORMAL
- en: In order to provide a workaround for this problem, JSF 2.2 has introduced the
    Window ID API, which allows developers to identify separate tabs/windows of the
    same session.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Under certain circumstances, you can track users' window IDs using view scope
    and flash scope. But Window ID is easier to use and is dedicated to this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers can choose the method used for tracking window IDs by setting the
    context parameter `javax.faces.CLIENT_WINDOW_MODE` in `web.xml` as follows—in
    JSF 2.2, the supported values are `url` (tracking activated) and `none` (tracking
    deactivated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'When `url` is specified, the user''s window IDs are tracked using a hidden
    field or a request parameter named `jfwid`. In the following screenshot, you can
    see both of them, the request parameter and hidden field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSF 2.2 Window ID API](img/6466EN_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the hidden field (available after a postback) and request parameter are
    available, the hidden field has a bigger precedence.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily get the Window ID using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ClientWindow` instance can be obtained using `ExternalContext.getClientWindow`
    and can be provided as `ExternalContext.setClientWindow`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can enable/disable user window tracking in at least two ways which are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `<h:button>` and `<h:link>`, you can use the `disableClientWindow` attribute
    whose value can be `true` or `false`, as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, we can use the `disableClientWindowRenderMode` and `enableClientWindowRenderMode`
    methods as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A complete application is available in the code bundle of this chapter which
    is named `ch5_10_1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers can write custom `ClientWindow` implementations by extending the
    `ClientWindowWrapper` class, which is a simple and convenient implementation that
    allows us to override only the necessary methods. One way to tell JSF to use your
    custom `ClientWindow` is based on the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend `ClientWindowFactory`, which is a factory that is capable of creating
    `ClientWindow` instances based on the incoming request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override `ClientWindowFactory.getClientWindow` to create an instance of the
    custom `ClientWindow` implementation for the current request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the value of the context parameter `ClientWindow.CLIENT_WINDOW_MODE_PARAM_NAME`,
    before creating an instance of the custom `ClientWindow` implementation. The value
    of the context parameter should be equal to `url`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Based on these three steps, we can write a custom `ClientWindowFactory` implementation
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CustomClientWindow` implementation is an extension of `ClientWindowWrapper`,
    which allows us to override only the needed methods. In our case, we are interested
    in two methods. The first one is named `getId`, which returns a `String` value
    that uniquely identifies `ClientWindow` within the scope of the current session.
    The other one is named `decode`, which is responsible for providing the value
    returned by `getId`. In order to provide this value, the `decode` method should
    follow the given checks:'
  prefs: []
  type: TYPE_NORMAL
- en: Request a parameter under the name given by the value of `ResponseStateManager.CLIENT_WINDOW_PARAM`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this check doesn't return a favorable ID, look for a request parameter under
    the name given by the value of `ResponseStateManager.CLIENT_WINDOW_URL_PARAM`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an ID value is not found, then fabricate an ID that uniquely identifies this
    `ClientWindow` within the scope of the current session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Furthermore, we can write a custom `ClientWindow` implementation that will
    generate a custom ID, of type `CUSTOM`—current date in milliseconds. The code
    is listed as follows–pay attention to see how the `decode` method is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, configure the custom `ClientWindowFactory` implementation in `faces-config.xml`
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Done! The complete application is named `ch5_10_3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to create an ID of type `UUID-uuid::counter` then, you can write
    the `decode` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the complete application is named `ch5_10_4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a counter may be very useful when you decide to use an ID of type `SESSION_ID::counter`.
    Since the session ID will be the same over multiple windows/tabs, you need the
    counter to differentiate between the IDs. This kind of ID can be easily obtained
    thanks to the `ExternalContext.getSessionId` method of JSF 2.2, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Configuring lifecycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you know, JSF lifecycle contains six phases. In order to be processed, each
    JSF request will go through all these phases, or only through a part of them.
    The abstraction of lifecycle model is represented by the `javax.faces.lifecycle.Lifecycle`
    class, which is responsible for executing JSF phases in two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The `execute` method will execute all the phases except the sixth phase, that
    is, the *Render Response* phase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `render` method will execute the sixth phase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The custom `Lifecycle` can be written by implementing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend `LifecycleFactory`, which is a factory object capable of creating and
    returning a new `Lifecycle` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend `LifecycleWrapper`, which is a simple implementation of `LifecycleLifecycle`
    that allows us to selectively override methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the custom `Lifecycle` implementation in `faces-config.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the custom `Lifecycle` implementation in `web.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s begin with a generic custom `Lifecycle`, by extending `LifecycleFactory`
    as follows—notice how we register a custom `Lifecycle` implementation using a
    unique identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, `CustomLifecycle` extends `LifecycleWrapper` and overrides the
    required methods. In order to have access to the instance of the class being wrapped,
    we need to override the `getWrapped` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to configure our custom lifecycle factory in `faces-config.xml`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to register the custom lifecycle in `web.xml` using its identifier
    (see the highlighted code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: At this moment, we have a functional dummy custom lifecycle. Next, we will add
    some real functionality, and for this we focus on the `Lifecycle.attachWindow`
    method. This method was introduced in JSF 2.2 and is used for attaching a `ClientWindow`
    instance to the current request. The `ClientWindow` instance is associated with
    the incoming request during the `Lifecycle.attachWindow` method. This method will
    cause a new instance of `ClientWindow` to be created, to be assigned an ID, and
    then to be passed to `ExternalContext.setClientWindow(ClientWindow)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *JSF 2.2 Window ID API* section, you saw how to explore the default
    mechanism for identifying different windows/tabs of users. Based on this knowledge,
    we have written a custom `ClientWindow` implementation to provide a custom ID
    for the `jfwid` request parameter of type `CUSTOM—current date in milliseconds`—and
    of type`UUID::counter`. The custom client window was set via a custom `ClientWindowFactory`
    implementation. Further, we set the same custom client window by overriding the
    `attachWindow` method as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Done! The complete application is named `ch5_10_2`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The application represents a per-web-application singleton object, which is
    the heart of the JSF runtime. Through this object we can accomplish many tasks,
    such as adding components, converters, validators, subscribing to events, setting
    listeners, locales, and messaging bundles. It represents the entry point for many
    JSF artifacts. We refer to it using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The application can be extended and customized by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend `ApplicationFactory`, which is a factory object capable of creating and
    returning a new `Application` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend `ApplicationWrapper`, which is a simple implementation of `Application`
    that allows us to selectively override methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the custom `Application` implementation in `faces-config.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, we can use a custom `Application` implementation for adding a
    list of validators to an application. We start by writing a custom application
    factory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the job is accomplished by `CustomApplication` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, configure the new custom application in `faces-config.xml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use dependency injection with application objects
    (`@Inject` and `@EJB`). The preceding example, with the list of validators provided
    by a CDI bean as a `Map`, is available in the code bundle of this chapter under
    the name `ch5_11`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring VDL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The abbreviation VDL stands for **View Declaration Language**, which represents
    the contract that a view declaration language must implement in order to interact
    with the JSF runtime. The `ViewDeclarationLanguageFactory` class is used to create
    and return instances of the `ViewDeclarationLanguage` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to alter how the runtime transforms an input file into a tree of components,
    you need to write a custom `ViewDeclarationLanguageFactory` implementation, which
    can be accomplished by extending the original class and overriding the `getViewDeclarationLanguage`
    method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CustomViewDeclarationLanguage` implementation can be written by extending
    `ViewDeclarationLanguage` and overriding all methods, or extending the new JSF
    2.2 `ViewDeclarationLanguageWrapper` class and overriding only the needed method.
    Our `CustomViewDeclarationLanguage` implementation represents a simple skeleton
    based on the wrapper class as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'This factory can be configured in `faces-config.xml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Done! The complete application is named `ch5_17`.
  prefs: []
  type: TYPE_NORMAL
- en: At [https://code.google.com/p/javavdl/](https://code.google.com/p/javavdl/),
    you can see an implementation of a JSF VDL that allows pages or complete JSF applications
    to be authored in pure Java, without the need for any XML or other declarative
    markup (for example, Facelets).
  prefs: []
  type: TYPE_NORMAL
- en: Combined power of multiple factories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last several sections, you saw how to customize and configure the most
    used JSF factories. In the final section of this chapter, you will see how to
    exploit a few factories in the same application. For example, a convenient scenario
    will assume that we want to fire a non-JSF request and get as response a JSF view.
    An approach of this scenario consists in writing a Java Servlet capable of converting
    a non-JSF request into a JSF view.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to write such a Servlet, we need to obtain access to `FacesContext`.
    For this, we can combine the power of the default `LifecycleFactory` class with
    the power of the default `FacesContextFactory` class. Further, we can access `Application`
    via `FacesContext`, which means that we can obtain the `ViewHandler` that is responsible
    for creating JSF views via the `createView` method. Once the view is created,
    all we need to do is to set `UIViewRoot` and tell `Lifecycle` to render the response
    (execute the *Render Response* phase). In lines of code, the Servlet looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can test very easily using the `<h:outputLink>` tag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch5_18`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, this was a pretty heavy chapter, but JSF's important aspects were touched
    upon here. You learned how to create, extend, and configure several of the main
    JSF 2.x artifacts, and how they have been improved by JSF 2.2, especially with
    the dependency injection mechanism. There are still a lot of things that were
    not discussed in this chapter, such as state management, facelet factory, and
    so on, but keep on reading.
  prefs: []
  type: TYPE_NORMAL
- en: See you in the next chapter, where we will discuss about working with tabular
    data in JSF.
  prefs: []
  type: TYPE_NORMAL
