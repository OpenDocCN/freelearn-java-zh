<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Application Testing</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Creating tests for MVC controllers</li>
<li>Configuring a database schema and populating it </li>
<li>Creating tests using an in-memory database</li>
<li>Creating tests using mock objects</li>
<li>Creating a JPA component test</li>
<li>Creating a WebMvc component test</li>
<li>Writing tests using Cucumber</li>
<li>Writing tests using Spock</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>In the previous chapters, we did a lot of coding. We created a new Spring Boot application from scratch, added an MVC component and some database services to it, made a few tweaks to the application behavior, and even wrote our very own Spring Boot starter. It is now time to take the next step and learn what kind of tools and capabilities Spring Boot offers when it comes to testing all this code, and how well it integrates with the other popular testing frameworks.</p>
<p>We will see how to use Spring JUnit integration to create unit tests. Next, we will explore the options of setting up the database with test data to test against it. We will then look to the <strong>behavior-driven development</strong> (<strong>BDD</strong>) tools Cucumber and Spock and see how they integrate with Spring Boot.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating tests for MVC controllers</h1>
                </header>
            
            <article>
                
<p>In the previous chapters, we made a lot of progress in gradually creating our application, but how do we know that it actually does what we want it to do? More importantly, how do we know for sure that after six months, or even a year from now, it will still continue to do what we expected it to do at the very beginning? This question is best answered by creating a set of tests, preferably automated, that run a suite of assertions against our code. This ensures that we constantly get the same and expected output given the specific input. Tests give us the much-needed peace of mind that our application not only elegantly is coded and looks beautiful, but that it also performs reliably and is as error-free as possible.</p>
<p>In <a href="6139967b-794e-479a-8461-d3197eb0322e.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Writing Custom Spring Boot Starters</em>, we left off with our web application fitted with a custom-written Spring Boot starter. We will now create some basic tests to test our web application and to ensure that all the controllers expose the expected RESTful URLs, which we can rely on as the service API. This type of testing is a bit beyond what is commonly known as <strong>unit testing</strong> as it tests the entire web application, it requires the application context to be fully initialized, and all the beans should be wired together in order to work. This kind of testing is sometimes referred to as <strong>integration</strong> or <strong>service testing</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Spring Boot gets us going by creating a placeholder test file, <kbd>BookPubApplicationTests.java</kbd>, in the <kbd>src/test/java/com/example/bookpub</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">@RunWith(SpringRunner.class) 
@SpringApplicationConfiguration(classes = <br/>   BookPubApplication.class) 
public class BookPubApplicationTests { 
  @Test 
  public void contextLoads() { 
  } 
} </pre>
<ol start="2">
<li>In <kbd>build.gradle</kbd>, we also get a test dependency on <kbd>spring-boot-starter-test</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px">testCompile("org.springframework.boot:spring-boot-starter-test") </pre>
<ol start="3">
<li>We will go ahead and extend the basic template test to contain the following code:</li>
</ol>
<pre style="padding-left: 60px">import static org.hamcrest.Matchers.containsString;<br/>import static org.junit.Assert.assertEquals;<br/>import static org.junit.Assert.assertNotNull;<br/>import static org.springframework.test.web.servlet.setup.MockMvcBuilders.webAppContextSetup;<br/>import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;<br/>import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;<br/>import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;<br/>import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;<br/><br/>@RunWith(SpringRunner.class)<br/>@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)<br/>public class BookPubApplicationTests {<br/>   @Autowired<br/>   private WebApplicationContext context; 
   @Autowired<br/>   private TestRestTemplate restTemplate;<br/>   @Autowired<br/>   private BookRepository repository;<br/><br/>   @LocalServerPort<br/>   private int port;<br/><br/>   private MockMvc mockMvc; 
 
   @Before<br/>   public void setupMockMvc() {<br/>       mockMvc = webAppContextSetup(context).build();<br/>   }<br/><br/>   @Test<br/>   public void contextLoads() {<br/>       assertEquals(1, repository.count());<br/>   }<br/><br/>   @Test<br/>   public void webappBookIsbnApi() {<br/>       Book book =<br/>         restTemplate.getForObject("http://localhost:" +<br/>           port + "/books/978-1-78528-415-1", Book.class);<br/>       assertNotNull(book);<br/>       assertEquals("Packt", book.getPublisher().getName());<br/>   }<br/><br/>   @Test<br/>   public void webappPublisherApi() throws Exception {<br/>       mockMvc.perform(get("/publishers/1")).<br/>               andExpect(status().isOk()).andExpect(content().<br/>                  contentType(MediaType.parseMediaType<br/>                    ("application/hal+json;charset=UTF-8"))).
               andExpect(content().<br/>                            string(containsString("Packt"))).<br/>               andExpect(jsonPath("$.name").value("Packt"));<br/>   }<br/>} </pre>
<ol start="4">
<li>Execute the tests by running <kbd>./gradlew clean test</kbd>.</li>
<li>By looking at the console output, we can tell that our tests have succeeded and are running, but we don't really see much information besides the following lines (truncated for brevity):</li>
</ol>
<pre style="padding-left: 60px"><strong>:compileJava</strong>
<strong>:compileTestJava</strong>
<strong>:testClasses</strong>
<strong>:test</strong>
<strong>2016-10-13 21:40:44.694  INFO 25739 --- [       Thread-4] ationConfigEmbeddedWebApplicationContext : Closing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@206f4aa6: startup date [Mon Apr 13 21:40:36 CDT 2015]; root of context hierarchy</strong>
<strong>2016-10-13 21:40:44.704  INFO 25739 --- [       Thread-4] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default'</strong>
<strong>2016-10-13 21:40:44.705  INFO 25739 --- [       Thread-4] org.hibernate.tool.hbm2ddl.SchemaExport  : HHH000227: Running hbm2ddl schema export</strong>
<strong>2016-10-13 21:40:44.780  INFO 25739 --- [       Thread-4] org.hibernate.tool.hbm2ddl.SchemaExport  : HHH000230: Schema export complete</strong>
    
<strong>BUILD SUCCESSFUL</strong>
<strong>Total time: 24.635 secs</strong></pre>
<ol start="6">
<li>Better insight can be gathered by viewing the HTML reports that are generated by Gradle, which can be opened in the browser and reside in <kbd>build/reports/tests/index.html</kbd>, as shown in the following screenshot:
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="193" src="assets/a8e039b4-e823-4444-844c-b06e415813e1.png" width="703"/></div>
</li>
<li>Clicking on <kbd>com.example.bookpub.BookPubApplicationTests</kbd> will take us to the individual test case breakdown, which shows the status of each test and how long it took to get executed, as follows:
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="283" src="assets/5eb6b09a-d98f-485a-b232-0fb40bfcc16d.png" width="483"/></div>
</li>
<li>The more curious minds can also click on the <span class="packt_screen">Standard output</span> button in order to see the runtime application logs that are produced during the execution of the test.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Now that we have created our first test, let's examine the code in detail.</p>
<p>We will first look at the following annotations that have been declared for the <kbd>BookPubApplicationTests</kbd> class:</p>
<ul>
<li><kbd>@RunWith(SpringRunner.class)</kbd>: This is a standard JUnit annotation that we can configure so as to use the <kbd>SpringRunner</kbd>, providing functionality to bootstrap the Spring Boot framework to the standard JUnit tests.</li>
<li><kbd>@SpringBootTest(webEnvironment=SpringBootTest.WebEnvironment.RANDOM_PORT)</kbd>: This is an annotation that marks the class as a Spring Boot test. It will use the Spring Boot framework to configure the test class instance, provide appropriate configuration, autowiring, and so on. The <kbd>webEnvironment=SpringBootTest.WebEnvironment.RANDOM_PORT</kbd> attribute means that the current test is going to use a real, running service instance and will require a complete context initialization and application startup, as if it were the real deal. The <kbd>RANDOM_PORT</kbd> value is used to tell Spring Boot to start the Tomcat server on a randomly-chosen HTTP port, which we will later obtain by declaring the <kbd>@LocalServerPortprivate int port;</kbd> value field. This ability to select a random HTTP port is very handy when running tests on a Jenkins or any other CI server where, if multiple jobs are running in parallel, you could encounter port collision.</li>
</ul>
<p>With the class annotations magic dispelled, let's look at the content of the class itself. As this is a Spring Boot test, we can declare any objects that are managed by Spring to be <kbd>@Autowired</kbd> during the execution or set to a specific environment value using a <kbd>@Value</kbd> annotation. In our test, we autowired the <kbd>WebApplicationContext</kbd> and <kbd>BookRepository</kbd> objects, as well as an instance of <kbd>TestRestTemplate</kbd>, which we will use in the execution of the standard JUnit <kbd>@Test</kbd> annotated test cases.</p>
<p>In the first test case, the <kbd>contextLoads()</kbd> method, we will just assert that we have the <kbd>BookRepository</kbd> connection established and that it contains one book entry.</p>
<p>Our second test will ensure that our web application responds to a RESTful URL for a <kbd>Book</kbd> lookup via <kbd>ISBN - "/books/{isbn}"</kbd>. For this test, we will use the instance of <kbd>TestRestTemplate</kbd> and make a RESTful call to the running instance on a randomly-selected port. Spring Boot provides the value of the <kbd>port</kbd> field.</p>
<div class="packt_infobox">In the <kbd>webappBookIsbnApi</kbd> test, we are using a full URL with the starting part being <kbd>"http://localhost:" + port</kbd>, which is technically not required if <kbd>TestRestTemplate</kbd> was autowired and injected by Spring Boot. In this case, it is possible to use a relative URL, looking like <kbd>Book book = restTemplate.getForObject("/books/978-1-78528-415-1", Book.class);</kbd>, and <kbd>TestRestTemplate</kbd> will automatically determine the port of the running test server instance.</div>
<p>Alternatively, we can execute the same flavor of tests by going through the <kbd>MockMvc</kbd> object. This is provided by the Spring Test Framework and allows you to perform MVC testing without actually doing client-side-based testing through <kbd>RestTemplate</kbd>, but instead doing it fully on the server side where the controller requests are executed from the same context as the tested application.</p>
<p>In order to use <kbd>MockMvc</kbd>, we will use the <kbd>MockMvcBuilders</kbd> utility to build an instance using <kbd>@Autowired WebApplicationContext</kbd>. We will do this in the setup method so that we don't have to do it in every test explicitly.</p>
<div class="packt_infobox">It is also possible to get Spring Boot to automatically create an instance of <kbd>MockMvc</kbd>, if we annotate our test using <kbd>WebEnvironment.MOCK</kbd> instead of <kbd>RANDOM_PORT</kbd>. That configuration will only make the test run in the mock context, and no real server will be started. Our example shows how to combine having a real server instance and <kbd>MockMVC</kbd> in the same test class.</div>
<p><kbd>MockMvc</kbd> provides us with a very extensive set of capabilities in order to execute assertions on practically all the things that are related to a web request. It is designed to be used in a method-chained fashion, allowing us to link the various tests together and forming a nice, continuous logical chain:</p>
<ul>
<li><kbd>perform(get(...))</kbd>: This method sets up the web request. In our particular case, we perform a GET request but the <kbd>MockMvcRequestBuilders</kbd> class provides us with static helper functions for all the common method calls.</li>
<li><kbd>andExpect(...)</kbd>: This method can be invoked multiple times, where each call represents an evaluation of a condition against the result of the <kbd>perform(...)</kbd> call. The argument of this call is any implementation of the <kbd>ResultMatcher</kbd> interface along with many stock ones that are provided by the <kbd>MockMvcResultMatchers</kbd> static utility class. This really opens up the possibility of having an infinite number of different checks such as verifying the response status, content type, values stored in a session, flash scope, verify redirects, contents of the rendering model or headers, and much more. We will use a third-party <kbd>json-path</kbd> add-on library (which is automatically brought as a <kbd>spring-boot-test</kbd> dependency) to test the JSON response data in order to ensure that it contains the right elements in the right tree hierarchy. <kbd>andExpect(jsonPath("$.name").value("Packt"))</kbd> validates that we have a name element at the root of the JSON document with a value of <kbd>Packt</kbd>.</li>
</ul>
<div class="mce-root packt_infobox"><span>To learn more about the various possibilities that are available in</span> <span>MockMvc</span><span>, you can refer to</span> <a href="https://github.com/spring-projects/spring-mvc-showcase/tree/master/src/test/java/org/springframework/samples/mvc">https://github.com/spring-projects/spring-mvc-showcase/tree/master/src/test/java/org/springframework/samples/mvc</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring a database schema and populating it</h1>
                </header>
            
            <article>
                
<p>Earlier in the book, in <a href="bd85f38d-1b98-47d6-a98a-b22f4478f68e.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Configuring Web Applications</em>, we manually added a few entries to the database in the <kbd>StartupRunner's run(...)</kbd> method. While doing so programmatically can be a quick and easy way to get something going very quickly, in the long run, it is not really a good idea to do so, especially when you are dealing with a large amount of data. It is also good practice to separate the database preparations, changes, and other configurations from the rest of the running application code, even if it is setting up the test cases. Thankfully, Spring has provided you with the support to make this task fairly easy and straightforward.</p>
<p>We will continue with the state of the application as we left it in the previous recipe. Spring provides us with a couple of ways to define how both the structure and data should be populated in the database. The first way relies on using Hibernate to automatically create the table structure by inferring it from our defined <kbd>@Entity</kbd> objects and using the <kbd>import.sql</kbd> file to populate the data. The second approach is to use the plain old Spring JDBC capability, which relies on using the <kbd>schema.sql</kbd> file that contains the database table definition and a corresponding <kbd>data.sql</kbd> file that contains the data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>First, we will remove the programmatic database population which we created in <a href="bd85f38d-1b98-47d6-a98a-b22f4478f68e.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Configuring Web Applications</em>. So let's comment out the following code from the <kbd>StartupRunner's run(...)</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">Author author = new Author("Alex", "Antonov"); 
author = authorRepository.save(author); 
Publisher publisher = new Publisher("Packt"); 
publisher = publisherRepository.save(publisher); 
Book book = new Book("978-1-78528-415-1", "Spring Boot Recipes", author, publisher); 
bookRepository.save(book); </pre>
<ol start="2">
<li>If we were to run our tests, they might fail if the <kbd>test.h2.db</kbd> file is missing because they expect the data to be in the database. We will populate the database by creating a Hibernate <kbd>import.sql</kbd> file in the <kbd>src/main/resources</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">INSERT INTO author (id, first_name, last_name) VALUES (1, 'Alex', 'Antonov') 
INSERT INTO publisher (id, name) VALUES (1, 'Packt') 
INSERT INTO book (isbn, title, author_id, publisher_id) VALUES ('978-1-78528-415-1', 'Spring Boot Recipes', 1, 1) </pre>
<ol start="3">
<li>On running the tests again by running <kbd>./gradlew clean test</kbd>, they are magically started and get passed again.</li>
<li>Another way to do this is to use the Spring JDBC support for <kbd>schema.sql</kbd> and <kbd>data.sql</kbd>. Let's rename the newly-created <kbd>import.sql</kbd> file to <kbd>data.sql</kbd> and create a <kbd>schema.sql</kbd> file in the same directory with the following content:</li>
</ol>
<pre style="padding-left: 60px">-- Create syntax for TABLE 'author' 
DROP TABLE IF EXISTS `author`; 
CREATE TABLE `author` ( 
  `id` bigint(20) NOT NULL AUTO_INCREMENT, 
  `first_name` varchar(255) DEFAULT NULL, 
  `last_name` varchar(255) DEFAULT NULL, 
  PRIMARY KEY (`id`) 
); 
-- Create syntax for TABLE 'publisher' 
DROP TABLE IF EXISTS `publisher`; 
CREATE TABLE `publisher` ( 
  `id` bigint(20) NOT NULL AUTO_INCREMENT, 
  `name` varchar(255) DEFAULT NULL, 
  PRIMARY KEY (`id`) 
); 
-- Create syntax for TABLE 'reviewer' 
DROP TABLE IF EXISTS `reviewer`; 
CREATE TABLE `reviewer` ( 
  `id` bigint(20) NOT NULL AUTO_INCREMENT, 
  `first_name` varchar(255) DEFAULT NULL, 
  `last_name` varchar(255) DEFAULT NULL, 
  PRIMARY KEY (`id`) 
); 
-- Create syntax for TABLE 'book' 
DROP TABLE IF EXISTS `book`; 
CREATE TABLE `book` ( 
  `id` bigint(20) NOT NULL AUTO_INCREMENT, 
  `description` varchar(255) DEFAULT NULL, 
  `isbn` varchar(255) DEFAULT NULL, 
  `title` varchar(255) DEFAULT NULL, 
  `author_id` bigint(20) DEFAULT NULL, 
  `publisher_id` bigint(20) DEFAULT NULL, 
  PRIMARY KEY (`id`), 
  CONSTRAINT `FK_publisher` FOREIGN KEY (`publisher_id`) REFERENCES `publisher` (`id`), 
  CONSTRAINT `FK_author` FOREIGN KEY (`author_id`) REFERENCES `author` (`id`) 
); 
-- Create syntax for TABLE 'book_reviewers' 
DROP TABLE IF EXISTS `book_reviewers`; 
CREATE TABLE `book_reviewers` ( 
  `book_id` bigint(20) NOT NULL, 
  `reviewers_id` bigint(20) NOT NULL, 
  CONSTRAINT `FK_book` FOREIGN KEY (`book_id`) REFERENCES `book` (`id`), 
  CONSTRAINT `FK_reviewer` FOREIGN KEY (`reviewers_id`) REFERENCES `reviewer` (`id`) 
); </pre>
<ol start="5">
<li>As we are now manually creating the database schema, we will need to tell the Hibernate mapper not to automatically derive one from the entities and populate the database with it. So, let's set the <kbd>spring.jpa.hibernate.ddl-auto=none</kbd> property in the <kbd>application.properties</kbd> file in the <kbd>src/main/resources</kbd> directory at the root of our project.</li>
<li>Execute the tests by running <kbd>./gradlew clean test</kbd> and they should get passed.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we actually explored two ways of achieving the same thing, and this is quite common when you are living in the Spring ecosystem. Depending on the components that are used, whether it's a plain Spring JDBC, Spring JPA with Hibernate, or the Flyway or Liquibase migrations, the approach of populating and initializing the database differs but the end result remains pretty much the same.</p>
<div class="packt_infobox">Both Flyway and Liquibase are frameworks that provide incremental database migration capabilities. This comes in very handy when one wants to maintain the incremental log of the database changes in a programmatic, describable fashion with the ability to quickly put the database in a desired state for a particular version. While these frameworks differ in their approach in terms of providing such support, they are similar in their purpose. More detailed information can be obtained at their respective sites, <a href="http://flywaydb.org"><span class="URLPACKT">http://flywaydb.org</span></a> and <a href="http://www.liquibase.org"><span class="URLPACKT">http://www.liquibase.org</span></a>.</div>
<p>In the preceding example, we explored two different ways of populating and initializing the database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Initializing the database with Spring JPA and Hibernate</h1>
                </header>
            
            <article>
                
<p>In this approach, most of the work is actually done by the <kbd>Hibernate</kbd> library and we merely set up the appropriate configurations and create conventionally expected files that are needed for Hibernate to do the work:</p>
<ul>
<li>The <kbd>spring.jpa.hibernate.ddl-auto=create-drop</kbd> setting instructs Hibernate to use the <kbd>@Entity</kbd> models and, based on their structure, automatically deduces the database schema. Upon starting the application, the calculated schema will be used to preinitialize the database table structure; when the application is shut down, it will all be destroyed. Even in the event that the application was forcefully terminated or it abruptly crashed, upon startup, if the existing tables are detected, they will be dropped and recreated from scratch. So it's probably not a good idea to rely on this for a production environment.</li>
</ul>
<div class="mce-root packt_tip"><span>If</span> <span>the</span> <kbd><span>spring.jpa.hibernate.ddl-auto</span></kbd> <span>property is not explicitly configured, Spring Boot uses</span> <span>create-drop</span> <span>for embedded databases such as</span> <span>H2</span> <span>by default, so be careful and set it appropriately.</span></div>
<ul>
<li><span>Hibernate expects that the <kbd>import.sql</kbd> file is residing in</span> the root of the classpath. This is used to execute the declared SQL statements upon application startup. While any valid SQL statement can go in the file, it is recommended that you put in the data-importing statements such as <kbd>INSERT</kbd> or <kbd>UPDATE</kbd> and steer clear of table structure mutations, as the schema definition is already taken care of by Hibernate.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Initializing the database with Spring JDBC</h1>
                </header>
            
            <article>
                
<p>If the application does not use JPA, or you don't want to depend on the Hibernate functionality explicitly, Spring offers you another way of getting the database set up, as long as the <kbd>spring-boot-starter-jdbc</kbd> dependency is present. So let's take a look at what we did to get it to work, as shown in the following list:</p>
<ul>
<li>The <kbd>spring.jpa.hibernate.ddl-auto=none</kbd> setting tells Hibernate not to do any automatic handling of the database if the Hibernate dependency also exists, as it does in our case. This setting is good practice for a production environment as you probably don't want to get all of your database tables wiped clean inadvertently. That would be one hell of a disaster, that's for sure!</li>
<li>The <kbd>schema.sql</kbd> file is expected to exist in the root of the classpath. It is executed by Spring during the schema creation of the database upon every startup of the application. However, unlike Hibernate, this will not drop any of the existing tables automatically, so it might be a good idea to either use <kbd>DROP TABLE IF EXISTS</kbd> to delete an existing table before creating the new one, or use <kbd>CREATE TABLE IF NOT EXISTS</kbd> as part of the table creation SQL if you only want to create new tables when they don't already exist. This makes it a lot more flexible to declare the database structure evolution logic, thus making it safer to be used in production as well.</li>
<li>The <kbd>data.sql</kbd> file is expected to exist in the root of the classpath. This is used to execute the data population SQL, so this is where all the <kbd>INSERT INTO</kbd> statements go.</li>
</ul>
<p>Given that this is a Spring native functionality, we will also get the ability to define the schema and data files not only globally, but also as per the specific database platform. For example, we can have one set of files that we can use for Oracle, <kbd>schema-oracle.sql</kbd>, and a different one for MySQL, <kbd>schema-mysql.sql</kbd>. The same applies to the <kbd>data.sql</kbd> variants as well; however, they don't have to be defined per platform, so while you might have platform-specific schema files, there could be a shared data file. The <kbd>spring.datasource.platform</kbd> configuration value can be explicitly set if you want to override Spring Boot's automatically deduced value.</p>
<div class="packt_tip">In case one wants to override the default names of <kbd>schema.sql</kbd> and <kbd>data.sql</kbd>, Spring Boot provides the configuration properties, which we can use to control <kbd>spring.datasource.schema</kbd> and <kbd>spring.datasource.data</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating tests using an in-memory database</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, we explored how to get our databases set up with the desired tables and populated with the required data. When it comes to testing, one of the typical challenges is to get the environment set up correctly and predictably so that when the tests are executed, we can safely assert the behavior in a deterministic fashion. In an application that connects to a database, making sure that the database contains a deterministic dataset on which the assertions can be evaluated is extremely important. For an elaborate test suite, it is also necessary to be able to refresh or change that dataset based on the tests. Thankfully, Spring has some nice facilities that aid you in accomplishing this task.</p>
<p>We will pick up from the state of our <kbd>BookPub</kbd> application as we left it in the previous recipe. At this point, we have the <kbd>schema.sql</kbd> file defining all the tables, and we also need the database with some starting data that is defined in <kbd>data.sql</kbd>. In this recipe, we will extend our tests to use the specific data fixture files that are tailored to a particular test suite.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Our first step will be to create a <kbd>resources</kbd> directory in the <kbd>src/test</kbd> directory at the root of our project.</li>
<li>In this directory, we will start placing our fixture SQL data files. Let's create a new file named <kbd>test-data.sql</kbd> in the resources directory with the following content:</li>
</ol>
<pre style="padding-left: 60px">INSERT INTO author (id, first_name, last_name) VALUES (2, 'Greg', 'Turnquist') 
INSERT INTO book (isbn, title, author_id, publisher_id) VALUES ('978-1-78439-302-1', 'Learning Spring Boot', 2, 1) </pre>
<ol start="3">
<li>We now need a way to load this file when our test runs. We will modify our <kbd>BookPubApplicationTests</kbd> class in the following way:</li>
</ol>
<pre style="padding-left: 60px">public class BookPubApplicationTests { 
   ... 
   @Autowired 
   private BookRepository repository; 
   @Autowired 
   private RestTemplate restTemplate; 
   @Autowired 
   private DataSource ds; 
   @LocalServerPort 
   private int port; 
 
   private MockMvc mockMvc; 
   private static boolean loadDataFixtures = true; 
 
   @Before 
   public void setupMockMvc() { 
      ... 
   } 
 
   @Before 
   public void loadDataFixtures() { 
      if (loadDataFixtures) { 
         ResourceDatabasePopulator populator = <br/>           new ResourceDatabasePopulator(<br/>               context.getResource("classpath:/test-data.sql")); 
         DatabasePopulatorUtils.execute(populator, ds); 
         loadDataFixtures = false; 
      } 
   } 
 
   @Test 
   public void contextLoads() { 
      assertEquals(2, repository.count()); 
   } 
 
   @Test 
   public void webappBookIsbnApi() { 
      ... 
   } 
 
   @Test 
   public void webappPublisherApi() throws Exception { 
      ... 
   } 
} </pre>
<ol start="4">
<li>Execute the tests by running <kbd>./gradlew clean test</kbd>, and they should continue to get passed despite us adding another book and its author to the database.</li>
<li>We can also use the method of populating the database that we learned in the previous recipe. As the test code has its own <kbd>resources</kbd> directory, it is possible to add another <kbd>data.sql</kbd> file to it, and Spring Boot will use both the files to populate the database. Let's go ahead and create the <kbd>data.sql</kbd> file in the <kbd>src/test/resources</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">INSERT INTO author (id, first_name, last_name) VALUES (3, 'William', 'Shakespeare') 
INSERT INTO publisher (id, name) VALUES (2, 'Classical Books') 
INSERT INTO book (isbn, title, author_id, publisher_id) VALUES ('978-1-23456-789-1', 'Romeo and Juliet', 3, 2) </pre>
<div class="mce-root packt_tip"><span>As</span><span> </span><span>Spring Boot collects all the occurrences of the data files</span><span>from the classpath,</span><span> </span><span>it is possible to place the data files in JARs or different physical locations that all end up being at the root of the classpath. It is also important to remember that the loading order of these scripts is not deterministic, and if you rely on certain referential IDs, it is better if you use selects to get them instead of making assumptions.</span></div>
<ol start="6">
<li>As we added another book to the database and we now have three of them, we should fix the assertion in our <kbd>contextLoads()</kbd> test method:</li>
</ol>
<pre style="padding-left: 60px">assertEquals(3, repository.count()); </pre>
<ol start="7">
<li>Execute the tests by running <kbd>./gradlew clean test</kbd> and they should continue to get passed.</li>
<li>It would be a fair statement to say that when running unit tests, an in-memory database is probably more suitable for the role than a persistent one. Let's create a dedicated test configuration instance of the <kbd>application.properties</kbd> file in the <kbd>src/test/resources</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">spring.datasource.url = jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE<br/>spring.jpa.hibernate.ddl-auto=update</pre>
<div class="mce-root packt_infobox"><span>It</span> <span>is important to know that Spring Boot loads only one</span> <kbd>application.properties</kbd> file <span>from the classpath. When we created another</span> <kbd>application.properties</kbd> in <kbd><span>src/test/resources</span></kbd><span>, the previous one from</span> <kbd><span>src/main/resources</span></kbd> <span>was no longer loaded and thus none of the properties defined in it were merged in the environment. For this reason, you should configure all of the property values that are required. In our case, we had to redefine the</span> <kbd><span>spring.jpa.hibernate.dll-auto</span></kbd> <span>property, even though it was already declared in the </span><kbd>src/main/resources/application.properties</kbd> location.</div>
<ol start="9">
<li>Execute the tests by running <kbd>./gradlew clean test</kbd> and the tests should continue to get passed.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we relied on the facility that is provided by Spring to initialize and populate the database in order to get our database populated with the data required to run the tests and assert on them. However, we also wanted to be able to use some data that was only relevant to a particular test suite. For this, we turned to the <kbd>ResourceDatabasePopulator</kbd> and <kbd>DatabasePopulatorUtils</kbd> classes to insert the desired data right before the test got executed. These are exactly the same classes that are used internally by Spring in order to handle the <kbd>schema.sql</kbd> and <kbd>data.sql</kbd> files, except now, we are explicitly defining the script files that we want to execute.</p>
<p>So, let's break up what we did step by step, as follows:</p>
<ul>
<li>We created a setup method named <kbd>loadDataFixtures()</kbd>, which we annotated with a <kbd>@Before</kbd> annotation to tell JUnit to run it before every test.</li>
<li>In this method, we obtained a resource handle to the <kbd>classpath:/test-data.sql</kbd> data file that resides in our application's classpath and where we store our test data and execute it against <kbd>@Autowired DataSource ds</kbd>.</li>
<li>As Spring can only autowire dependencies in the instances of the class, and the <kbd>@Before</kbd> annotated setup methods get executed for every test, we had to get a little creative in order to avoid repopulating our database with the duplicate data for every test instead of once per test suite/class. To achieve this, we created a <kbd>static boolean loadDataFixtures</kbd> variable that retained its state for every instance of the <kbd>BookPubApplicationTests</kbd> class, thus ensuring that we executed <kbd>DatabasePopulatorUtils</kbd> only once. The reason that the variable has to be static is as a new instance of the test class gets created for every test method that it runs in the class; having the <kbd>boolean</kbd> flag at the instance level will not do the trick.</li>
</ul>
<div class="mce-root packt_infobox">Alternatively, we could have used the <kbd>@Sql</kbd> annotation instead of the <kbd>loadDataFixtures()</kbd> method and marked our <kbd>BookPubApplicationTests</kbd> class as <kbd>@Transactional</kbd> to make sure that the <kbd>test-data.sql</kbd> file got populated before every test method was run. Then we could have rolled back to the pre-execution state of the database.</div>
<p class="mce-root">This makes test setup a bit simpler and the transactional part allows for having tests that mutate the data in the database without worrying about race conditions, but this has the downside of executing the SQL population before every test, which adds a bit of extra latency.</p>
<p class="mce-root">To make this work, we need to remove the <kbd>loadDataFixtures()</kbd> method and add the following annotations to the <kbd>BookPubApplicationTests</kbd> class:</p>
<pre class="mce-root" style="padding-left: 90px">@Transactional<br/>@Sql(scripts = "classpath:/test-data.sql")</pre>
<ul>
<li>For the finishing touch, we decided to have a separate <kbd>application.properties</kbd> file to be used for testing purposes. We added this to our <kbd>src/test/resources</kbd> classpath with a testing configuration of the in-memory database instead of using the file-based persistent one.</li>
</ul>
<ul>
<li>
<p>Unlike <kbd>application.properties</kbd>, where only one file can be loaded from the classpath, Spring supports a number of profile configurations which will be merged together. So, instead of declaring a completely separate <kbd>application.properties</kbd> file, we could create an <kbd>application-test.properties</kbd> file and set an active profile to test while running the tests.</p>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating tests using mock objects</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, we used a data fixture file to populate an in-memory database in order to run our tests on predictable and static sets of data. While this makes the tests consistent and deterministic, we are still paying the price of having to create a database, populate it with data, and initialize all the JPA and connectivity components, which could be viewed as an excessive step for a test. Luckily, Spring Boot provides internal support for being able to mock beans and inject them as components in the tests for setup and further use as dependencies within an application context.</p>
<p>Let's examine how we can use the power of Mockito so that we don't need to rely on the database at all. We will learn how to elegantly mock the <kbd>Repository</kbd> instance objects using the Mockito framework and some <kbd>@MockBean</kbd> annotation cleverness.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>First, we will create a new <kbd>MockPublisherRepositoryTests</kbd> test class in the <kbd>src/test/java/com/example/bookpub</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">import static org.assertj.core.api.Assertions.assertThat;<br/>import static org.mockito.BDDMockito.given;<br/>import static org.mockito.BDDMockito.reset; 
 
@RunWith(SpringRunner.class) 
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.NONE) 
public class MockPublisherRepositoryTests { 
    @MockBean 
    private PublisherRepository repository; 
 
    @Before 
    public void setupPublisherRepositoryMock() { 
        given(repository.count()).willReturn(5L); 
    } 
 
    @Test 
    public void publishersExist() { 
        assertThat(repository.count()).isEqualTo(5L); 
    } 
 
    @After 
    public void resetPublisherRepositoryMock() { 
        reset(repository); 
    } 
} </pre>
<ol start="2">
<li>Execute the tests by running <kbd>./gradlew clean test</kbd> and the tests should get passed</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>There are a few magical things happening here. Let's start with the annotations that we put into the <kbd>MockPublisherRepositoryTests</kbd> class:</p>
<ul>
<li>The <kbd>@SpringBootTest</kbd> annotation's <kbd>webEnvironment</kbd> attribute was replaced with <kbd>WebEnvironment.NONE</kbd>. This is to inform Spring Boot that we don't want a full application web server to be initialized for this test, since we will only be interacting with the repository object, without making calls to controllers or using any part of the WebMvc stack. We did this to save test startup time, and if one is curious to see the difference, just simply switching it back to the <kbd>WebEnvironment.RANDOM_PORT</kbd> value and rerunning the test would show that the time has almost doubled. (On my beefy MacBook Pro, it increased from 5 seconds to almost 9.)</li>
</ul>
<p>With the application changes examined, let's now look at what we did in the <kbd>MockPublisherRepositoryTests</kbd> class itself:</p>
<ul>
<li>The <kbd>@MockBean</kbd> annotation instructs Spring that this dependency is not a real instance, but a <kbd>mock</kbd> object currently backed by the Mockito framework. This has an interesting effect in that it actually replaces our <kbd>PublisherRepository</kbd> bean instance in the context with the mock one, so, everywhere within the context, all dependencies for <kbd>PublisherRepository</kbd> get wired with the mocked version instead of a real, database-backed one.</li>
</ul>
<p>Now that we know how the mocked instance of <kbd>PublisherRepository</kbd> gets injected into our tests, let's take a look at the newly-created test setup methods. The two methods of particular interest are <kbd>setupPublisherRepositoryMock()</kbd> and <kbd>resetPublisherRepositoryMock()</kbd>. They are described as follows:</p>
<ul>
<li>The <kbd>setupPublisherRepositoryMock()</kbd> method is annotated with <kbd>@Before</kbd>, which tells JUnit to execute this method before running every <kbd>@Test</kbd> method in the class. We will use the Mockito framework in order to configure the behavior of our mocked instance. We configure it such, that when the <kbd>repository.count()</kbd> method is called, it will return <kbd>5</kbd> as a result. The Mockito, Junit, and Hamcrest libraries provide us with many convenient DLS-like methods, which we can use to define such rules with an English-like, easy-to-read style.</li>
<li>The <kbd>resetPublisherRepositoryMock()</kbd> method is annotated with <kbd>@After</kbd>, which tells JUnit to execute this method after running every <kbd>@Test</kbd> method in the class. At the end of every test, we will need to reset the mocked behavior, so we will use the <kbd>reset(...)</kbd> method call to clear out all of our settings and get the mock ready for the next test, which can be used in another test suite altogether.</li>
</ul>
<div class="mce-root packt_infobox"><span>Ideally, there is no need to reset the</span> <kbd>mock</kbd> <span>object at the end of the test run, as each test class gets its own context spawned up, so between test classes the instance of a mock is not shared. It is considered good practice to create many smaller tests instead of a single large one. There are, however, some use cases that warrant resetting the mock when it is being managed by a container injection, so I thought it was worth mentioning. For the best practices on using</span> <kbd>reset(...)</kbd>, see <a href="https://github.com/mockito/mockito/wiki/FAQ#can-i-reset-a-mock">https://github.com/mockito/mockito/wiki/FAQ#can-i-reset-a-mock</a>.<a href="https://github.com/mockito/mockito/wiki/FAQ#can-i-reset-a-mock"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a JPA component test</h1>
                </header>
            
            <article>
                
<p>Most of our previous test examples had to start up the entire application and configure all the beans in order to execute. While that is not a big issue for our simple application, which has little code, it might prove an expensive and lengthy process for some larger, more complex enterprise-grade services. Considering that one of the key aspects of having good test coverage is a low execution time, we might want to opt out of having to bootstrap the entire application in order to test just one component, or <em>slice</em>, as Spring Boot refers to it.</p>
<p>In this recipe, we will try to create a similar test to our previous <kbd>PublisherRepository</kbd> one, but without starting the entire container and initializing all the beans. Conveniently, Spring Boot provides us with the <kbd>@DataJpaTest</kbd> annotation, which we can put on our test class, and it will automatically configure all the components necessary for the JPA functionality, but not the entire context. So beans like controllers, services, and so on, will be missing. This test is very good at quickly testing the validity of entity domain object bindings, to make sure the field names, associations, and so on, have been configured correctly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Let's create a new <kbd>JpaAuthorRepositoryTests</kbd> test class in the <kbd>src/test/java/com/example/bookpub</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">import static org.assertj.core.api.Assertions.assertThat; 
 
@RunWith(SpringRunner.class) 
@DataJpaTest 
public class JpaAuthorRepositoryTests { 
    @Autowired 
    private TestEntityManager mgr; 
 
    @Autowired 
    private AuthorRepository repository; 
 
    @Test 
    public void testAuthorEntityBinding() { 
        Long id = mgr.persistAndGetId(createAuthor(),  
                                      Long.class); 
 
        Author author = repository.findById(id).get(); 
         
        assertThat(author.getFirstName()). 
                   isEqualTo("Mark"); 
        assertThat(author.getLastName()). 
                   isEqualTo("Twain"); 
    } 
 
    private Author createAuthor() { 
        return new Author("Mark", "Twain"); 
    } 
} </pre>
<ol start="2">
<li>Execute the tests by running <kbd>./gradlew clean test</kbd> and the tests should continue to pass</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The key difference from our previous test is the absence of the <kbd>@SpringBootTest</kbd> annotation, which has been replaced with the <kbd>@DataJpaTest</kbd> annotation. The apparent simplicity of the test class itself is possible thanks to the <kbd>@DataJpaTest</kbd> annotation doing the bulk of the declarations and workload to configure the test environment. If we look inside the annotation definition, we will see a myriad of different internal annotations configuring all the necessary components. The important ones are the <kbd>@AutoConfigure*</kbd> annotations, such as <kbd>@AutoConfigureDataJpa</kbd> or <kbd>@AutoConfigureTestDatabase</kbd>. Those annotations essentially instruct Spring Boot to import the necessary component configurations when bootstrapping the test. For example, in <kbd>@DataJpaTest</kbd>, only <kbd>Cache</kbd>, <kbd>DataJpa</kbd>, <kbd>TestDatabase</kbd>, and <kbd>TestEntityManager</kbd> components would be configured and made available, which significantly reduces the test footprint, both memory-wise as well as startup and execution times. The specific configuration classes are then loaded, as we've seen before, from the <kbd>META-INF/spring.factories</kbd> descriptors provided by various artifacts.</p>
<p>With the right components initialized, we can take advantage of some preconfigured beans, such as <kbd>TestEntityManager</kbd>, which gives us the ability to interact with the test instance of the database, pre-initialize the desired state of its content, and manipulate test data. This gives us the guarantee that after each test suite is done executing, we will get a clean slate for the next set without the need of an explicit cleanup. This makes it easier to write tests, without having to worry about the order of execution and potential over stepping of changes from test suite to test suite, avoiding the inadvertent dirty state that makes tests inconsistent.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a WebMvc component test</h1>
                </header>
            
            <article>
                
<p>Another one of the collection of <kbd>*Test</kbd> slices is <kbd>@WebMvcTest</kbd>, which allows us to create tests for the WebMvc part of the application, quickly testing controllers, filters, and so on, while providing ability to use <kbd>@MockBean</kbd> to configure the necessary dependencies such as services, data repositories, and so on.</p>
<p>This is another very useful testing slice provided by the Spring Boot Test Framework, and we will explore its use in this recipe, taking a look at how we can create an Mvc layer test for our <kbd>BookController</kbd> file, mocking the <kbd>BookRepository</kbd> service with a predefined dataset and making sure the returned JSON document is what we would expect based on that data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>First, we will create a new <kbd>WebMvcBookControllerTests</kbd> test class in the <kbd>src/test/java/com/example/bookpub</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">import static org.hamcrest.Matchers.containsString; 
import static org.mockito.BDDMockito.given; 
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; 
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content; 
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath; 
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; 
 
@RunWith(SpringRunner.class) 
@WebMvcTest 
public class WebMvcBookControllerTests { 
    @Autowired 
    private MockMvc mockMvc; 
 
    @MockBean<br/>    private BookRepository repository;<br/><br/>  
    // The 2 repositories below are needed to 
    //successfully initialize StartupRunner<br/>    @MockBean<br/>    private AuthorRepository authorRepository;<br/>    @MockBean<br/>    private PublisherRepository publisherRepository; 
 
    @Test 
    public void webappBookApi() throws Exception { 
        given(repository.findBookByIsbn("978-1-78528-415-1")) 
             .willReturn(new Book("978-1-78528-415-1", <br/>                                  "Spring Boot Recipes", 
                                  new Author("Alex", "Antonov"), 
                                  new Publisher("Packt"))); 
 
        mockMvc.perform(get("/books/978-1-78528-415-1")). 
                andExpect(status().isOk()). 
                andExpect(content().<br/>                          contentType(MediaType.parseMediaType<br/>                          ("application/json;charset=UTF-8"))). 
                andExpect(content().<br/>                          string(containsString("Spring Boot Recipes"))). 
                andExpect(jsonPath("$.isbn").<br/>                                  value("978-1-78528-415-1")); 
    } 
} </pre>
<ol start="2">
<li>Execute the tests by running <kbd>./gradlew clean test</kbd> and the tests should continue to pass</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The functionality of <kbd>@WebMvcTest</kbd> is very similar to the <kbd>@DataJpaTest</kbd> annotation we have seen in the previous recipe. The difference is really just a set of components that get initialized during the test bootstrap. Unlike <kbd>@DataJpaTest</kbd>, this time there are no database components that are provided for us, but instead we get the <kbd>WebMvc</kbd> and <kbd>MockMvc</kbd> configurations, which bring all the necessary foundations for initializing controllers, filters, interceptors, and so on. For that reason, we had to add <kbd>AuthorRepository</kbd> and <kbd>PublisherRepository</kbd> as mock beans into our test code, because otherwise the test would fail to start because Spring Boot would be unable to satisfy the bean dependency that the <kbd>StartupRunner</kbd> class has on those two repositories.</p>
<div class="packt_infobox"><span>Another solution to this problem could be removing the dependency on those two repositories from the </span><kbd>StartupRunner</kbd><span> class, since we've commented out the code that uses them earlier in this chapter, in the </span><em>Configuring database schema and populating it</em><span> recipe. If that was not possible, I wanted to demonstrate how to handle the situation where you have bean dependencies in other classes, unrelated directly to the test, but causing startup failures during initialization and execution.</span></div>
<p>As one can see, unlike our previous recipe test, where we did not use any bean mocking since it was testing a lower-layer component without further dependencies, this time we need to provide a <kbd>BookRepository</kbd> mock, which is being used by our <kbd>BookController</kbd> class, the functionality of which we are testing.</p>
<p>We have already seen how to use the <kbd>@Before</kbd> annotation to preconfigure mock objects in the <kbd>MockPublisherRepositoryTests</kbd> class, so this time we are doing the configuration directly in the <kbd>webappBookApi</kbd> test method, similar to the style you will see when we learn about writing tests using the Spock framework.</p>
<p>Inside the <kbd>given(...)</kbd> call, we pre-configure the behavior of the <kbd>BookRepository</kbd> mock object, instructing it to return a specific <kbd>Book</kbd> instance when its <kbd>findBookByIsbn</kbd> method gets called with <kbd>"978-1-78528-415-1"</kbd> as an argument.</p>
<p><span>Our next call to </span><kbd>mockMvc.perform</kbd>with <kbd>/books/978-1-78528-415-1</kbd><span> triggers the invocation of the </span><kbd>BookController</kbd><kbd>getBook</kbd><span> method, which delegates the pre-wired mocked instance of </span><kbd>bookRepository</kbd><span> and uses our pre-configured </span><kbd>Book</kbd><span> object instance to run validation logic upon.</span></p>
<p>As evident from the log, we can see that only the WebMvc layer has been bootstrapped. No database or other components have been initialized, which has resulted in significant savings in runtime, taking only 3 seconds compared to the 9 seconds it took for a complete application bootstrap test earlier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing tests using Cucumber</h1>
                </header>
            
            <article>
                
<p>Unit testing has been an expected part of the software development life cycle for quite some time now, and one can hardly imagine writing code without having unit tests along with it. The art of testing does not stay the same, and advances in testing philosophies have extended the concept of unit testing even further, introducing things such as service testing, integration testing, and, lastly, what is known as BDD that proposes to create the test suites describing the application behavior at large without getting down to the minute implementation details at the lower levels of the code. One such framework, which has gained a lot of popularity first in the Ruby world and later expanding to other languages including Java, is the Cucumber BDD.</p>
<p>For the purpose of this recipe, we will pick up on our previous example and continue enhancing the testing suite by adding the Cucumber-JVM implementation, which will provide us with the Java-based version of the original Ruby Cucumber framework, and create a few tests in order to demonstrate the capabilities and integration points with the Spring Boot application.</p>
<div class="packt_infobox">This recipe is by no means intended to cover the entire set of functionalities provided by the Cucumber testing framework and is mostly focused on the integration points of Cucumber and Spring Boot. To learn more about Cucumber-JVM, you can go to <a href="https://cukes.info/docs#cucumber-implementations"><span class="URLPACKT">https://cukes.info/docs#cucumber-implementations</span></a> or <a href="https://github.com/cucumber/cucumber-jvm"><span class="URLPACKT">https://github.com/cucumber/cucumber-jvm</span></a> for details.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>The first thing that we need to do is add the necessary dependencies for the Cucumber libraries to our <kbd>build.gradle</kbd> file, as follows:</li>
</ol>
<pre style="padding-left: 60px">dependencies { 
    compile("org.springframework.boot:spring-boot-starter-data-jpa") 
    compile("org.springframework.boot:spring-boot-starter-jdbc") 
    compile("org.springframework.boot:spring-boot-starter-web") 
    compile("org.springframework.boot:spring-boot-starter-data-rest") 
    compile project(":db-count-starter") 
    runtime("com.h2database:h2") 
    runtime("mysql:mysql-connector-java") 
    testCompile("org.springframework.boot:spring-boot-starter-test") 
    testCompile("info.cukes:cucumber-spring:1.2.5") 
    testCompile("info.cukes:cucumber-java8:1.2.5") 
    testCompile("info.cukes:cucumber-junit:1.2.5") 
} </pre>
<ol start="2">
<li>Next, we will need to create a test driver class to run Cucumber tests. Let's create a <kbd>RunCukeTests.java</kbd> file in the <kbd>src/test/java/com/example/bookpub</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">@RunWith(Cucumber.class) 
@CucumberOptions(plugin={"pretty", "html:build/reports/cucumber"},   
                 glue = {"cucumber.api.spring",           <br/>                         "classpath:com.example.bookpub"},  
                 monochrome = true) 
public class RunCukeTests { 
} </pre>
<ol start="3">
<li>With the driver class created, we are ready to start writing what Cucumber refers to as Step Definitions. I will talk briefly about what these are in the <em>How it works...</em> section of this recipe. For now, let's create a <kbd>RepositoryStepdefs.java</kbd> file in the <kbd>src/test/java/com/example/bookpub</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">@WebAppConfiguration 
@ContextConfiguration(classes = BookPubApplication.class, <br/>                  loader = SpringBootContextLoader.class)  
public class RepositoryStepdefs { 
    @Autowired 
    private WebApplicationContext context; 
    @Autowired 
    private DataSource ds; 
    @Autowired 
    private BookRepository bookRepository; 
 
    private Book loadedBook; 
 
    @Given("^([^\"]*) fixture is loaded$") 
    public void data_fixture_is_loaded(String fixtureName)<br/>      throws Throwable { 
        ResourceDatabasePopulator populator <br/>          = new ResourceDatabasePopulator<br/>                (context.getResource("classpath:/" + fixtureName + ".sql")); 
        DatabasePopulatorUtils.execute(populator, ds); 
    } 
 
    @Given("^(\d+) books available in the catalogue$") 
    public void books_available_in_the_catalogue(int bookCount)    <br/>      throws Throwable { 
        assertEquals(bookCount, bookRepository.count()); 
    } 
 
    @When("^searching for book by isbn ([\d-]+)$") 
    public void searching_for_book_by_isbn(String isbn) <br/>      throws Throwable { 
        loadedBook = bookRepository.findBookByIsbn(isbn); 
        assertNotNull(loadedBook); 
        assertEquals(isbn, loadedBook.getIsbn()); 
    } 
 
    @Then("^book title will be ([^"]*)$") 
    public void book_title_will_be(String bookTitle) <br/>      throws Throwable { 
        assertNotNull(loadedBook); 
        assertEquals(bookTitle, loadedBook.getTitle()); 
    } 
} </pre>
<ol start="4">
<li>Now, we will need to create a corresponding testing feature definition file named <kbd>repositories.feature</kbd> in the <kbd>src/test/resources/com/example/bookpub</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">@txn 
Feature: Finding a book by ISBN 
  Background: Preload DB Mock Data 
    Given packt-books fixture is loaded 
 
  Scenario: Load one book 
    Given 3 books available in the catalogue 
    When searching for book by isbn 978-1-78398-478-7 
    Then book title will be Orchestrating Docker </pre>
<ol start="5">
<li>Lastly, we will create one more data SQL file named <kbd>packt-books.sql</kbd> in the <kbd>src/test/resources</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">INSERT INTO author (id, first_name, last_name) VALUES (5, 'Shrikrishna', 'Holla') 
INSERT INTO book (isbn, title, author_id, publisher_id) VALUES ('978-1-78398-478-7', 'Orchestrating Docker', 5, 1) </pre>
<ol start="6">
<li>Execute the tests by running <kbd>./gradlew clean test</kbd> and the tests should get passed.</li>
</ol>
<ol start="7">
<li>With the addition of Cucumber, we also get the results of the tests in both the JUnit report and Cucumber-specific report HTML files. If we open <kbd>build/reports/tests/index.html</kbd> in the browser and click on the <span class="packt_screen">Classes</span> button, we will see our scenario in the table, as shown in the following screenshot:
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="318" src="assets/2f667267-e14b-457e-9ecc-f67e44bbc81e.png" width="825"/></div>
</li>
<li>Selecting the <span class="packt_screen">Scenario: Load one book</span> link will take us to the detailed report page, as shown in the following screenshot:
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="271" src="assets/eb744c2f-eb47-4d40-a585-809d15dfc6c8.png" width="411"/></div>
</li>
</ol>
<ol start="9">
<li>As we can see, the descriptions are nicer than the class and method names that we saw in the original JUnit-based test cases.</li>
<li>Cucumber also generates its own report, which can be viewed by opening <kbd>build/reports/cucumber/index.html</kbd> in the browser.</li>
<li>Being a behavior-driven testing framework, the feature files allow us not only to define individual conditions, but also to declare entire scenario outlines, which make the defining of multiple assertions of similar data easier. Let's create another feature file named <kbd>restful.feature</kbd> in the <kbd>src/test/resources/com/example/bookpub</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">@txn 
Feature: Finding a book via REST API 
  Background: 
    Given packt-books fixture is loaded 
 
  Scenario Outline: Using RESTful API to lookup books by ISBN 
    Given catalogue with books 
    When requesting url /books/&lt;isbn&gt; 
    Then status code will be 200 
    And response content contains &lt;title&gt; 
 
    Examples: 
      |isbn             |title               | 
      |978-1-78398-478-7|Orchestrating Docker| 
      |978-1-78528-415-1|Spring Boot Recipes | </pre>
<ol start="12">
<li>We will also create a corresponding <kbd>RestfulStepdefs.java</kbd> file in the <kbd>src/test/java/com/example/bookpub</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">import cucumber.api.java.Before; 
import cucumber.api.java.en.Given; 
import cucumber.api.java.en.Then; 
import cucumber.api.java.en.When; 
 
import static org.hamcrest.CoreMatchers.containsString; 
import static org.junit.Assert.assertTrue; 
import static org.junit.Assert.assertNotNull; 
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; 
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; 
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content; 
 
@WebAppConfiguration 
@ContextConfiguration(classes = BookPubApplication.class, loader = SpringBootContextLoader.class)  
public class RestfulStepdefs { 
  @Autowired 
  private WebApplicationContext context; 
  @Autowired 
  private BookRepository bookRepository; 
 
  private MockMvc mockMvc; 
  private ResultActions result; 
 
  @Before 
  public void setup() throws IOException { 
    mockMvc = <br/>       MockMvcBuilders.webAppContextSetup(context).build(); 
  } 
 
  @Given("^catalogue with books$") 
  public void catalogue_with_books() { 
    assertTrue(bookRepository.count() &gt; 0); 
  } 
 
  @When("^requesting url ([^"]*)$") 
  public void requesting_url(String url) throws Exception { 
    result = mockMvc.perform(get(url)); 
  } 
 
  @Then("^status code will be ([\d]*)$") 
  public void status_code_will_be(int code) throws <br/>     Throwable { 
    assertNotNull(result); 
    result.andExpect(status().is(code)); 
  } 
 
  @Then("^response content contains ([^"]*)$") 
  public void response_content_contains(String content) <br/>     throws Throwable { 
 
    assertNotNull(result);     
    result.andExpect( 
      content().string(containsString(content)) 
    ); 
  } 
} </pre>
<ol start="13">
<li>Execute the tests by running <kbd>./gradlew clean test</kbd> and the tests should continue to get passed.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>If you feel a bit lost after looking at all this code and following along without having a full understanding of what exactly is going on, here you will find a detailed breakdown of everything that we did.</p>
<p>Let's start with a quick overview of what <strong>Step Definitions</strong> are. As the Cucumber framework uses the <strong>Gherkin</strong> feature document files in order to describe the business rules that are to be tested, which are represented in the form of English-like sentence statements, these need to be translated into executable code. This is the job of the Step Definition classes. Every step in a defined feature scenario needs to be matched to a method in a Step Definition class that will execute it. This matching is done by declaring a regular expression in the step annotations above the methods. The regex contains the matching groups that Cucumber uses so as to extract the method arguments and pass them to the executing method.</p>
<p>In <kbd>RepositoryStepdefs</kbd>, we can see this in the following method:</p>
<pre style="padding-left: 30px">@Given("^([^\"]*) fixture is loaded$") 
public void data_fixture_is_loaded(String fixtureName) {...} </pre>
<p>The <kbd>@Given</kbd> annotation contains the regular expression that matches the <kbd>Given packt-books fixture is loaded</kbd> text, loaded from <kbd>repositories.feature</kbd> file, and extracts the <kbd>packt-books</kbd> text from the pattern, which is then passed as a <kbd>fixtureName</kbd> argument to the method. The <kbd>@When</kbd> and <kbd>@Then</kbd> annotations work on exactly the same principle. So, in effect, what the Cucumber framework does is it matches the English-like worded rules from the feature files to the matched patterns of the executing methods and extracts parts of the rules as arguments to the matched methods.</p>
<div class="packt_infobox">More information on Gherkin and how to use it can be found at <a href="https://cukes.info/docs/reference#gherkin"><span class="URLPACKT">https://cukes.info/docs/reference#gherkin</span></a>.</div>
<p>With the basic Cucumber overview explained, let's shift our focus to how the tests integrate with Spring Boot and are configured.</p>
<p>It all starts with the driver harness class, which in our case is <kbd>RunCukeTests</kbd>. This class itself does not contain any tests, but it has two important annotations that stitch things together, <kbd>@RunWith(Cucumber.class)</kbd> and <kbd>@CucumberOptions</kbd>:</p>
<ul>
<li><kbd>@RunWith(Cucumber.class)</kbd>: This is a JUnit annotation that indicates that JUnit runner should use the Cucumber feature files to execute the tests.</li>
</ul>
<p class="mce-root"><kbd>@CucumberOptions</kbd><span>: This provides additional configuration for Cucumber:</span></p>
<ul>
<li><kbd>plugin={"pretty", "html:build/reports/cucumber"}</kbd>: This tells Cucumber to generate its reports in HTML format in the <kbd>build/reports/cucumber</kbd> directory.</li>
<li><kbd>glue = {"cucumber.api.spring", "classpath:com.example.bookpub"}</kbd>: This is a very important setting, as it tells Cucumber which packages to load and from where to load them during the execution of the tests. The <kbd>cucumber.api.spring</kbd> package needs to be present in order to take advantage of the <kbd>cucumber-spring</kbd> integration library, and the <kbd>com.example.bookpub</kbd> package is the location of our Step Definition implementation classes.</li>
<li><kbd>monochrome = true</kbd>: This tells Cucumber not to print the output with the ANSI color as we integrate with JUnit, as it will not look correct in the saved console output files.</li>
</ul>
<div class="mce-root packt_infobox" style="color: black;font-size: 1em">A complete list of the options can be found at <a href="https://cukes.info/docs/reference/jvm#list-all-options">https://cukes.info/docs/reference/jvm#list-all-options</a>.</div>
<p>Now let's look at the <kbd>RepositoryStepdefs</kbd> class. It starts with the following annotations at the class level:</p>
<ul>
<li><kbd>@WebAppConfiguration</kbd> instructs Spring that this class needs <kbd>WebApplicationContext</kbd> to be initialized, and it will be used for testing purposes during the execution</li>
<li><kbd>@ContextConfiguration(classes = BookPubApplication.class</kbd> and <kbd>loader = SpringBootContextLoader.class)</kbd> instruct Spring to use the <kbd>BookPubApplication</kbd> class as a configuration for the Spring application context, as well as to use the <kbd>SpringBootContextLoader</kbd> class from Spring Boot in order to bootstrap the testing harness</li>
</ul>
<div class="mce-root packt_infobox">It is important to note that these annotations have to match  all the Step Definition classes, or only one of the classes will be annotated with the <kbd>@ContextConfiguration</kbd> annotation to wire in the Spring support for the Cucumber test.</div>
<p>As the <kbd>cucumber-spring</kbd> integration does not know about Spring Boot but only about Spring, we can't use the <kbd>@SpringBootTest</kbd> meta-annotation. We have to resort to using only the annotations from Spring in order to stitch things together. Thankfully, we don't have to go through many hoops, but just declare the exact annotation that <kbd>SpringBootTest</kbd> facades by passing the desired configuration classes and loader.</p>
<p>Once the proper annotations are in place, Spring and Spring Boot will take over and provide us with the same convenience of autowiring beans as dependencies of our Step Definition classes.</p>
<p>One interesting characteristic of the Cucumber tests is the instantiation of a new instance of the Step Definition class for every execution of a <strong>Scenario</strong>. Even though the method namespace is global—meaning that we can use the methods that are declared in the different Step Definition classes—they operate on states defined in them and are not directly shared. It is, however, possible to <kbd>@Autowire</kbd> an instance of another Step Definition in a different Step Definition instance and rely on public methods or fields to access and mutate the data.</p>
<p>As a new instance gets created per scenario, the definition classes are stateful and rely on internal variables to keep a state among transitions from assertion to assertion. For example, in the <kbd>@When</kbd> annotated method, a particular state gets set, and in the <kbd>@Then</kbd> annotated method, a set of assertions on that state get evaluated. In our example of the <kbd>RepositoryStepdefs</kbd> class, we will internally set the state of the <kbd>loadedBook</kbd> class variable in its <kbd>searching_for_book_by_isbn(...)</kbd> method, which later gets used to assert on so as to verify the match of the book's title in the <kbd>book_title_will_be(...)</kbd> method afterwards. Due to this, if we mix the rules from the different definition classes in our feature files, the internal states would not be accessible among the multiple classes.</p>
<p>When integrating with Spring, one can use the injection of the mocked objects—as we have seen in <kbd>MockPublisherRepositoryTests</kbd> from one of our previous examples—and can have the shared <kbd>@Given</kbd> annotated method be used to set up the particular behavior of the mock for the given test. Then we can use the same dependency instance and inject it into another definition class that can be used in order to evaluate the <kbd>@Then</kbd> annotated assertion methods.</p>
<p>Another approach is the one that we saw in the second definition class, <kbd>RestfulStepdefs</kbd>, where we injected <kbd>BookRepository</kbd>. However, in <kbd>restful.feature</kbd>, we will be using the <kbd>Given packt-books fixture is loaded</kbd> behavior declaration that translates to the invocation of <kbd>data_fixture_is_loaded</kbd> method from the <kbd>RepositoryStepdefs</kbd> class, which shares the same instance of the injected <kbd>BookRepository</kbd> object, inserting the <kbd>packt-books.sql</kbd> data into it.</p>
<p>If we were to have a need to access the value of the <kbd>loadedBook</kbd> field from the <kbd>RepositoryStepdefs</kbd> instance inside the <kbd>RestfulStepdefs</kbd> class, we could declare the <kbd>@Autowired RepositoryStepdefs</kbd> field inside <kbd>RestfulStepdefs</kbd> and make the <kbd>loadedBook</kbd> field <kbd>public</kbd> instead of <kbd>private</kbd> to make it accessible to the outside world.</p>
<p>Another neat feature of the Cucumber and Spring integration is the use of the <kbd>@txn</kbd> annotation in the feature files. This tells Spring to execute the tests in a transaction wrapper, reset the database between the test executions, and guarantee a clean database state for every test.</p>
<p>Due to the global method namespace among all the Step Definition classes and test behavior defining feature files, we can use the power of Spring injection to our advantage so as to reuse the testing models and have a common setup logic for all of the tests. This makes the tests behave similarly to how our application would function in a real production environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing tests using Spock</h1>
                </header>
            
            <article>
                
<p>Another no-less-popular testing framework is Spock, which was written in Groovy by Peter Niederwieser. Being a Groovy-based framework, it is ideally suited to create testing suites for a majority of the JVM-based languages, especially for Java and Groovy itself. The dynamic language traits of Groovy make it well suited to write elegant, efficient, and expressive specifications in the Groovy language without the need for translations. It is done in Cucumber with the help of the Gherkin library. Being based on top of JUnit, and integrating with it through the JUnit's <kbd>@RunWith</kbd> facility, just like Cucumber does, it is an easy enhancement to the traditional unit tests and works well with all the existing tools, which have built-in support or integration with JUnit.</p>
<p>In this recipe, we will pick up from where the previous recipe left off and enhance our test collection with a couple of Spock-based tests. In these tests, we will see how to set up MockMVC using the Spring dependency injection and testing harnesses. These will be used by the Spock test specifications in order to validate the fact that our data repository services will return the data as expected.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>In order to add the Spock tests to our application, we will need to make a few changes to our <kbd>build.gradle</kbd> file first. As Spock tests are written in Groovy, the first thing to do is add a <kbd>groovy</kbd> plugin to our <kbd>build.gradle</kbd> file, as follows:</li>
</ol>
<pre style="padding-left: 60px">apply plugin: 'java' 
apply plugin: 'eclipse' 
apply plugin: 'groovy' 
apply plugin: 'spring-boot' </pre>
<ol start="2">
<li>We will also need to add the necessary Spock framework dependencies to the <kbd>build.gradle</kbd> dependencies block:</li>
</ol>
<pre style="padding-left: 60px">dependencies { 
  ... 
  testCompile('org.spockframework:spock-core:1.1-groovy-2.4-rc-2') 
  testCompile('org.spockframework:spock-spring:1.1-groovy-2.4-rc-2') 
  ... 
} </pre>
<ol start="3">
<li>As the tests will be in Groovy, we will need to create a new source directory for the files. Let's create the <kbd>src/test/groovy/com/example/bookpub</kbd> directory in the root of our project.</li>
<li>Now we are ready to write our first test. Create a <kbd>SpockBookRepositorySpecification.groovy</kbd> file in the <kbd>src/test/groovy/com/example/bookpub</kbd> directory at the root of our project with the following content:</li>
</ol>
<p class="mce-root"/>
<pre style="padding-left: 60px">package com.example.bookpub;<br/><br/>import com.example.bookpub.entity.Author;<br/>import com.example.bookpub.entity.Book<br/>import com.example.bookpub.entity.Publisher<br/>import com.example.bookpub.repository.BookRepository<br/>import com.example.bookpub.repository.PublisherRepository<br/>import org.mockito.Mockito<br/>import org.springframework.beans.factory.annotation.Autowired<br/>import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc<br/>import org.springframework.boot.test.context.SpringBootTest<br/>import org.springframework.boot.test.mock.mockito.MockBean<br/>import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils<br/>import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator<br/>import org.springframework.test.web.servlet.MockMvc<br/>import org.springframework.transaction.annotation.Transactional<br/>import org.springframework.web.context.ConfigurableWebApplicationContext<br/>import spock.lang.Specification<br/><br/>import javax.sql.DataSource<br/><br/>import static org.hamcrest.CoreMatchers.containsString<br/>import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get<br/>import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content<br/>import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; 
<br/>@SpringBootTest 
@AutoConfigureMockMvc 
class SpockBookRepositorySpecification extends Specification { 
  @Autowired 
  private ConfigurableWebApplicationContext context 
 
  @Autowired 
  private DataSource ds; 
 
  @Autowired 
  private BookRepository repository; 
 
  @Autowired 
  private MockMvc mockMvc; 
 
  void setup() { 
    ResourceDatabasePopulator populator = <br/>       new ResourceDatabasePopulator(<br/>         context.getResource("classpath:/packt-books.sql")); 
    DatabasePopulatorUtils.execute(populator, ds); 
  } 
 
  @Transactional 
  def "Test RESTful GET"() { 
    when: 
      def result = mockMvc.perform(get("/books/${isbn}")); 
 
    then: 
      result.andExpect(status().isOk()) 
      result.andExpect( 
        content().string(containsString(title)) 
      ); 
 
    where: 
      isbn               | title 
      "978-1-78398-478-7"|"Orchestrating Docker" 
      "978-1-78528-415-1"|"Spring Boot Recipes" 
  } 
 
  @Transactional 
  def "Insert another book"() { 
    setup: 
      def existingBook =  
        repository.findBookByIsbn("978-1-78528-415-1") 
      def newBook = new Book("978-1-12345-678-9",<br/>         "Some Future Book", existingBook.getAuthor(), <br/>         existingBook.getPublisher() 
      ) 
 
    expect: 
      repository.count() == 3 
 
    when: 
      def savedBook = repository.save(newBook) 
 
    then: 
      repository.count() == 4 
      savedBook.id &gt; -1 
  } 
} </pre>
<ol start="5">
<li>Execute the tests by running <kbd>./gradlew clean test</kbd> and the tests should get passed.</li>
</ol>
<ol start="6">
<li>As Spock integrates with JUnit, we can see the execution report of the Spock tests together with the rest of our test suite. If we open <kbd>build/reports/tests/index.html</kbd> in the browser and click the <span class="packt_screen">Classes</span> button, we will see our specification in the table, as shown in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/a534256a-f4a6-4297-995e-5e37da0f0deb.png"/></div>
<ol start="7">
<li>Selecting the <span class="packt_screen">com.example.bookpub.SpockBookRespositorySpecification</span> link will take us to the detailed report page, which is as follows:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="232" src="assets/a2d3fda6-0523-4366-a865-e45b874fdb76.png" style="text-align: center;font-size: 1em" width="451"/></div>
<ol start="8">
<li>Next, we will take our tests a bit further and explore the mocking functionality of the database repositories. Let's use <kbd>PublisherRepository</kbd> as our candidate to mock, and wire it into the <kbd>BookController</kbd> class to provide a <kbd>getBooksByPublisher</kbd> functionality. Let's add the following content to the <kbd>BookController</kbd> class in the <kbd>src/main/java/com/example/bookpub/controllers</kbd> directory at the root of our project:</li>
</ol>
<pre style="padding-left: 60px">@Autowired 
private PublisherRepository publisherRepository; 
 
@RequestMapping(value = "/publisher/{id}", method = RequestMethod.GET) 
public List&lt;Book&gt; getBooksByPublisher(@PathVariable("id") Long id) { 
    Optional&lt;Publisher&gt; publisher =<br/>        publisherRepository.findById(id);<br/>    Assert.notNull(publisher);<br/>    Assert.isTrue(publisher.isPresent());<br/>    return publisher.get().getBooks(); 
} </pre>
<ol start="9">
<li>Let's add the following to the <kbd>Publisher</kbd> class in the <kbd>src/main/java/com/example/bookpub/entity</kbd> directory at the root of our project:</li>
</ol>
<pre style="padding-left: 60px">@OneToMany(mappedBy = "publisher") 
@JsonBackReference 
private List&lt;Book&gt; books; 
 </pre>
<ol start="10">
<li>Lastly, let's add a getter and setter for the books to the <kbd>Publisher</kbd> entity class as well:</li>
</ol>
<pre style="padding-left: 60px">public List&lt;Book&gt; getBooks() { 
    return books; 
} 
 
public void setBooks(List&lt;Book&gt; books) { 
    this.books = books; 
} </pre>
<ol start="11">
<li>With all the code additions completed, we are ready to add another test to the <kbd>SpockBookRepositorySpecification.groovy</kbd> file in the <kbd>src/test/groovy/com/example/bookpub</kbd> directory at the root of our project with the following content:</li>
</ol>
<pre style="padding-left: 60px">... 
class SpockBookRepositorySpecification extends Specification { 
    ... 
    @MockBean 
    private PublisherRepository publisherRepository 
 
    @Transactional 
    def "Test RESTful GET books by publisher"() { 
        setup: 
          Publisher publisher =  
                    new Publisher("Strange Books") 
          publisher.setId(999) 
          Book book = new Book("978-1-98765-432-1", 
                "Mystery Book", 
                new Author("John", "Doe"), 
                publisher) 
          publisher.setBooks([book]) 
          Mockito.when(publisherRepository.count()). 
                thenReturn(1L)                    
          Mockito.when(publisherRepository.findById(1L)). 
                thenReturn(Optional.of(publisher)) 
 
        when: 
          def result =  
            mockMvc.perform(get("/books/publisher/1")) 
 
        then: 
          result.andExpect(status().isOk()) 
          result.andExpect(content(). 
                string(containsString("Strange Books"))) 
 
        cleanup: 
          Mockito.reset(publisherRepository) 
    } 
} </pre>
<ol start="12">
<li>Execute the tests by running <kbd>./gradlew clean test</kbd> and the tests should continue to get passed.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As you saw from this example, writing tests can be just as elaborate and sophisticated as the production code being tested itself. Let's examine the steps that we took in order to get the Spock tests integrated into our Spring Boot application.</p>
<p>The first thing that we did was to add a Groovy plugin in order to make our build Groovy-friendly, and we also added the required Spock library dependencies of <kbd>spock-core</kbd> and <kbd>spock-spring</kbd>, both of which are required to make Spock work with Spring's dependency injection and contexts.</p>
<p>The next step was to create the <kbd>SpockBookRepositorySpecification</kbd> Spock specification, which extends the Spock's specification abstract base class. Extending the <kbd>Specification</kbd> class is very important because this is how JUnit knows that our class is the test class that needs to be executed. If we look in the <kbd>Specification</kbd> source, we will see the <kbd>@RunWith(Sputnik.class)</kbd> annotation, just like the one that we used in the Cucumber recipe. In addition to the JUnit bootstrapping, the <kbd>Specification</kbd> class provides us with many helpful methods and mocking support as well.</p>
<div class="packt_infobox">For more information about the detailed capabilities that are offered by Spock, you can refer to the Spock documentation that is available at <span class="URLPACKT"><a href="http://spockframework.github.io/spock/docs/current/index.html">http://spockframework.github.io/spock/docs/current/index.html</a></span>.</div>
<p>It is also worth mentioning that we used the same annotations for the <kbd>SpockBookRepositorySpecification</kbd> class as we did for our Spring Boot-based tests, as shown in the following code:</p>
<pre style="padding-left: 60px">@SpringBootTest<br/>@AutoConfigureMockMvc </pre>
<p>The reason that we had to add <kbd>@AutoConfigureMockMvc</kbd> in addition to <kbd>@SpringBootTest</kbd> is to add functionality to allow us to use the <kbd>@Autowire MockMvc</kbd> instance instead of having to create one ourselves. Regular <kbd>@SpringBootTest</kbd> does not automatically create and configure an instance of a <kbd>MockMvc</kbd> object, so we could have either created it manually, as we did in <kbd>BookPubApplicationTests</kbd>, or added the <kbd>@AutoConfigureMockMvc</kbd> annotation, which is what gets used inside <kbd>@WebMvcTest</kbd>, to let Spring handle it for us. The good news is that we can always use the same annotation compositions as used by Spring Boot, and annotate our classes directly, which is exactly what we did.</p>
<p>Unlike Cucumber, Spock combines all the aspects of the test in one <kbd>Specification</kbd> class, dividing it into multiple blocks, as follows:</p>
<ul>
<li><kbd>setup</kbd>: This block is used to configure the specific test with variables, populating data, building mocks, and so on.</li>
<li><kbd>expect</kbd>: This block is one of the stimulus blocks, as Spock defines it, designed to contain simple expressions asserting a state or condition. Besides evaluating the conditions, we can only define variables in this block, and nothing else is allowed.</li>
<li><kbd>when</kbd>: This block is another stimulus type block, which always goes together with <kbd>then</kbd>. It can contain any arbitrary code and is designed to define the behavior that we are trying to test.</li>
<li><kbd>then</kbd>: This block is a response type block. It is similar to <kbd>expect</kbd> and can only contain conditions, exception checking, variable definition, and object interactions, such as how many times a particular method has been called and so forth.</li>
</ul>
<div class="mce-root packt_infobox">More information on interaction testing is available on Spock's website at <a href="http://spockframework.org/spock/docs/1.0/interaction_based_testing.html">http://spockframework.github.io/spock/docs/current/interaction_based_testing.html</a>.</div>
<ul>
<li><kbd>cleanup</kbd>: This block is used to clean the state of the environment and potentially undo whatever changes were done as part of the individual test execution. In our recipe, this is where we will reset our <kbd>PublisherRepository</kbd> mock object.</li>
</ul>
<p>Spock provides us with the instance-based <kbd>setup()</kbd> and <kbd>cleanup()</kbd> methods as well, which can be used to define the setup and cleanup behavior that is common to all the tests in the specification.</p>
<p>If we look at our <kbd>setup()</kbd> method, this is where we can configure the database population with the test data. An interesting and important nuance is that the <kbd>setup()</kbd> method gets executed before every test method, not once per class. It is important to keep that in mind when doing things like populating a database to avoid re-insertion of the same data multiple times without proper rollback.</p>
<p>To help us with that is the <kbd>@Transactional</kbd> annotation of the test methods. Just like the <kbd>@txn</kbd> tag in the Cucumber feature files, this annotation instructs Spock to execute the annotated method and its corresponding <kbd>setup()</kbd> and <kbd>cleanup()</kbd> executions with a transaction scope, which get rolled back after the particular test method is finished. We rely on this behavior to get a clean database state for every test, so we don't end up inserting duplicate data during the execution of the <kbd>setup()</kbd> method every time each of our tests runs.</p>
<p>Most of you are probably wondering why we had to add the <kbd>@JsonBackReference</kbd> annotation to our <kbd>Publisher</kbd> entity class. The answer has to do with the Jackson JSON parser and how it handles circular dependency. In our model, we have a book belonging to a publisher and each publisher has multiple books. When we created our <kbd>Publisher</kbd> class with the <kbd>Books</kbd> mock and assigned a publisher instance to a book—which later got put in the publisher's book collection—we created a circular reference. During the execution of the <kbd>BookController.getBooksByPublisher(...)</kbd> method, the Jackson renderer would have thrown <kbd>StackOverflowError</kbd> while trying to write the object model to JSON. By adding this annotation to <kbd>Publisher</kbd>, we told Jackson how the objects reference each other, so instead of trying to write out the complete object tree, Jackson now handles it correctly, thus avoiding the circular reference loop situation.</p>
<p>The last thing that is important to keep in mind is how Spring Boot handles and processes the repository interfaces that are annotated with <kbd>@RepositoryRestResource</kbd>. Unlike the <kbd>BookRepository</kbd> interface, which we have annotated with a plain <kbd>@Repository</kbd> annotation and later explicitly declared as an autowire dependency of our <kbd>BookController</kbd> class, we did not create an explicit controller to handle RESTful requests for the rest of our repository interfaces such as <kbd>PublisherRepository</kbd> and others. These interfaces get scanned by Spring Boot and automatically wrapped with the mapped endpoints that trap the requests and delegate the calls to the backing <kbd>SimpleJpaRepository</kbd> proxy. Due to this setup, we can use only the mock object replacement approach for these objects that have been explicitly injected as bean dependencies such as with our example of <kbd>BookRepository</kbd>. The good news is that in these situations, where we don't explicitly expect beans to be wired and only use some annotations to stereotype the interfaces for Spring Boot to do its magic, we can rely on Spring Boot to do the job correctly. We know that it has tested all the functionalities behind it so that we don't have to test them. To test the actual repository and entity functionality, we can use the <kbd>@DataJpaTest</kbd> annotation to do a specific JPA slice test instead.</p>


            </article>

            
        </section>
    </body></html>