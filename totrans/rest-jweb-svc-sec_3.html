<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Security Management with RESTEasy"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Security Management with RESTEasy</h1></div></div></div><p>Welcome to the third chapter. We hope you are enjoying and learning with us. In this chapter, you will get more involved with security management. You will also work with some more advanced security concepts.</p><p>Security management in applications built with RESTful web services can be more granular than what we reviewed in the previous chapter. If we think around authentication and authorization topics, we described the former; authorization was set aside. This is because we want to treat it slowly and in a very detailed level in this chapter.</p><p>The topics covered in this chapter are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Implementing security restrictions related to authentication and authorization in to an application</li><li class="listitem" style="list-style-type: disc">Implementing fine-grained security</li><li class="listitem" style="list-style-type: disc">Using annotations to obtain more granularity over resource access control</li></ul></div><div class="section" title="Fine-grained and coarse-grained security"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec16"/>Fine-grained and coarse-grained security</h1></div></div></div><p>There are two levels of <a class="indexterm" id="id92"/>security we can manage:<a class="indexterm" id="id93"/> <span class="strong"><strong>fine-grained</strong></span> and <span class="strong"><strong>coarse-grained</strong></span>.</p><p>When we mention the term<a class="indexterm" id="id94"/> coarse-grained in the context of security, we refer to security systems that are generally handled at high levels within the application. The examples in <a class="link" href="ch02.html" title="Chapter 2. The Importance of Securing Web Services">Chapter 2</a>, <span class="emphasis"><em>The Importance of Securing Web Services</em></span>, in which a user with any role can make use of the services, is a perfect example of coarse-grained <a class="indexterm" id="id95"/>because the coarse-grained option is used when the security restrictions give access to users without worrying about roles or more specific features about the authenticated user. This means that in order for the system to allow access to functions, we just verify the user identity; in other words, it authenticates the user. However, it is not enough to have an authenticated user of the application in real life. It will also be necessary that the user is authorized to use certain features. We can achieve this using fine-grained controls. Validating the user's assigned permissions to access functions means using authorization controls.</p><p>To demonstrate these concepts in a practical way, we will make use of the application we created in the previous<a class="indexterm" id="id96"/> chapter. You can access the source code on GitHub at the following URL, under the basic authentication section:</p><p>
<a class="ulink" href="https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/basic-authentication">https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/basic-authentication</a>
</p><p>Let's start; suppose we want only users with the role <code class="literal">administrator</code> to be able to make use of the features in our application. The first thing to do is to change the <code class="literal">web.xml</code> file and add a constraint as follows. Note how the changes appear in bold:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="3.0" 
  
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
  http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt;
  
  &lt;security-role&gt;
<span class="strong"><strong>    &lt;description&gt;Application roles&lt;/description&gt;</strong></span>
<span class="strong"><strong>    &lt;role-name&gt;administrator&lt;/role-name&gt;</strong></span>
  &lt;/security-role&gt;
  &lt;security-constraint&gt;
    &lt;display-name&gt;Area secured&lt;/display-name&gt;
    &lt;web-resource-collection&gt;
      &lt;web-resource-name&gt;protected_resources&lt;/web-resource-name&gt;
      &lt;url-pattern&gt;/services/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
<span class="strong"><strong>      &lt;description&gt;User with administrator role&lt;/description&gt;</strong></span>
<span class="strong"><strong>  &lt;role-name&gt;administrator&lt;/role-name&gt;</strong></span>
    &lt;/auth-constraint&gt;
  &lt;/security-constraint&gt;
  &lt;login-config&gt;
    &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
  &lt;/login-config&gt;
&lt;/web-app&gt;</pre></div><p>Now, let's try to make the request using the user we just created (<code class="literal">username</code>). You will be surprised when you get a <code class="literal">403 Forbidden</code> error.</p><p>Note that if you try to make the request with invalid credentials, you will get the error <code class="literal">HTTP/1.1 401 Unauthorized</code>. The error is pretty clear; the access is unauthorized. This means that we have sent invalid credentials, and hence the user can't be authenticated. The error we just got is <code class="literal">HTTP/1.1 403 Forbidden</code>, which indicates that the user was successfully<a class="indexterm" id="id97"/> logged in but was not authorized to use the functionality that they require. This is demonstrated in the following screenshot:</p><div class="mediaobject"><img alt="Fine-grained and coarse-grained security" src="graphics/0109OS_03_01.jpg"/></div><p>Now, let's create a new user with the role <code class="literal">administrator</code> using the <code class="literal">JBOSS_HOME/standalone/bin/adduser.sh</code> file. Enter the requested information as shown in the following screenshot:</p><div class="mediaobject"><img alt="Fine-grained and coarse-grained security" src="graphics/0109OS_03_02.jpg"/></div><p>When we change<a class="indexterm" id="id98"/> the credentials in SoapUI, the result of the request is successful, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Fine-grained and coarse-grained security" src="graphics/0109OS_03_03.jpg"/></div><p>As you can see, we used an additional control in which we restricted only authenticated users with the <code class="literal">administrator</code> role assigned to them; they are capable of using the web service functions. It is very common to use these kinds of controls when managing security<a class="indexterm" id="id99"/> on real-world applications. As we have implemented a more detailed level of control, the platform offers us the opportunity to implement more granular controls, such as the ones we will see right now.</p><div class="section" title="Securing HTTP methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec14"/>Securing HTTP methods</h2></div></div></div><p>One of the benefits of JAAS is that we have control even at the level of HTTP methods. Thus, we can implement security controls to allow only users with a certain role to use certain methods with regards to our convenience; for example, one role to save information, another to delete it, others to read it, and so on.</p><p>To implement these kinds of<a class="indexterm" id="id100"/> controls, it is necessary that we understand the HTTP methods' functionality in the application. In our example, we already know that in order to save information, the application always uses the <code class="literal">HTTP POST</code> method. Also, when we want to read information, the application uses the <code class="literal">HTTP GET</code> method. Therefore, we will modify our example so that only users with the <code class="literal">administrator</code> role are able to use the <code class="literal">savePerson</code> (<code class="literal">HTTP POST</code>) method. Meanwhile, only those with the <code class="literal">reader</code> role will be able to read information using<a class="indexterm" id="id101"/> the <code class="literal">findById</code> (<code class="literal">HTTP GET</code>) method.</p><p>With this as our objective, we will modify our <code class="literal">web.xml</code> file as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="3.0" 
  
xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
  http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt;
  &lt;!-- Roles --&gt;
  &lt;security-role&gt;
    &lt;description&gt;Role for save information&lt;/description&gt;
    &lt;role-name&gt;administrator&lt;/role-name&gt;
  &lt;/security-role&gt;
  &lt;security-role&gt;
    &lt;description&gt;Role for read information&lt;/description&gt;
    &lt;role-name&gt;reader&lt;/role-name&gt;
  &lt;/security-role&gt;

  &lt;!-- Resource / Role Mapping --&gt;
  &lt;security-constraint&gt;
    &lt;display-name&gt;Administrator area&lt;/display-name&gt;
    &lt;web-resource-collection&gt;
  &lt;web-resource-name&gt;protected_resources&lt;/web-resource-name&gt;
      &lt;url-pattern&gt;/services/*&lt;/url-pattern&gt;
      &lt;http-method&gt;POST&lt;/http-method&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
    &lt;description&gt;User with administrator role&lt;/description&gt;
      &lt;role-name&gt;administrator&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
  &lt;/security-constraint&gt;
  &lt;security-constraint&gt;
    &lt;display-name&gt;Reader area&lt;/display-name&gt;
    &lt;web-resource-collection&gt;
  &lt;web-resource-name&gt;protected_resources&lt;/web-resource-name&gt;
      &lt;url-pattern&gt;/services/*&lt;/url-pattern&gt;
      &lt;http-method&gt;GET&lt;/http-method&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
      &lt;description&gt;User with reader role&lt;/description&gt;
      &lt;role-name&gt;reader&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
  &lt;/security-constraint&gt;

  &lt;login-config&gt;
    &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
  &lt;/login-config&gt;
&lt;/web-app&gt;</pre></div><p>Before we continue, we <a class="indexterm" id="id102"/>must create a new user (<code class="literal">readeruser</code>) with the role <code class="literal">reader</code> using the <code class="literal">JBOSS_HOME/standalone/bin/adduser.sh</code> script.</p><p>Now, let's test the roles and their permissions using SoapUI.</p><div class="section" title="HTTP method – POST"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec05"/>HTTP method – POST</h3></div></div></div><p>We are going to test the <code class="literal">POST</code> method <a class="indexterm" id="id103"/>using a role that doesn't have the required permissions. You will <a class="indexterm" id="id104"/>see the permission error message.</p><p>Role: Reader</p><p>This method is not allowed when using this role. This is demonstrated in the following screenshot:</p><div class="mediaobject"><img alt="HTTP method – POST" src="graphics/0109OS_03_04.jpg"/></div><p>Role: Administrator</p><p>With this role, you can<a class="indexterm" id="id105"/> execute the method successfully. This is<a class="indexterm" id="id106"/> demonstrated in the following screenshot:</p><div class="mediaobject"><img alt="HTTP method – POST" src="graphics/0109OS_03_05.jpg"/></div></div><div class="section" title="HTTP method – GET"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec06"/>HTTP method – GET</h3></div></div></div><p>Now, we are going to use a user <a class="indexterm" id="id107"/>with the required permissions to use<a class="indexterm" id="id108"/> the GET method. The execution should be successful with this role.</p><p>Role: Reader</p><p>Now, the execution is successful with this role. This is demonstrated in the following screenshot:</p><div class="mediaobject"><img alt="HTTP method – GET" src="graphics/0109OS_03_06.jpg"/></div><p>Role: Administrator</p><p>The admin role does not<a class="indexterm" id="id109"/> have access to this method. This is <a class="indexterm" id="id110"/>demonstrated in the following screenshot:</p><div class="mediaobject"><img alt="HTTP method – GET" src="graphics/0109OS_03_07.jpg"/></div><p>The same consideration of roles can be used for URL patterns. In our example, we apply the restriction on the <code class="literal">/services/*</code> pattern. However, you can apply it at a deeper level, for example <code class="literal">/services/person/*</code>. We mean that if we had another service that is exposed under the URL <code class="literal">/services/other-service/</code>, we can set it so that a role has access to services under the path <code class="literal">/services/person/*</code> and different levels of access under the path <code class="literal">/services/other-service/*</code>. This example is quite simple and is proposed as a basic example to the reader.</p><p>After applying all the changes, we set security over all methods listed in the <code class="literal">web.xml</code> file. However, we must ask ourselves a question; what happens with the methods that haven't been included?</p><p>The OWASP (Open Web Application Security Project), a nonprofit organization<a class="indexterm" id="id111"/> dedicated to finding and fixing security holes in software, has written a paper on this, and it is called the following:</p><p><span class="emphasis"><em>Bypassing Web Authentication and Authorization with HTTP Verb Tampering: How to inadvertently allow attackers full access to your web application.</em></span></p><p>If you want to check out the complete document, you can do so by accessing the following link:</p><p>
<a class="ulink" href="http://dl.packetstormsecurity.net/papers/web/Bypassing_VBAAC_with_HTTP_Verb_Tampering.pdf">http://dl.packetstormsecurity.net/papers/web/Bypassing_VBAAC_with_HTTP_Verb_Tampering.pdf</a>
</p><p>What the OWASP describes in the aforementioned document is simple. It shows that JEE exposes potential security gaps in the <code class="literal">web.xml</code> configuration file if we don't take certain precautions as all methods<a class="indexterm" id="id112"/> that are not listed in the file can be used without any restrictions. This means that a user that hasn't been authenticated in the application<a class="indexterm" id="id113"/> can invoke any other HTTP method.</p><p>The OWASP states the following in the earlier article:</p><p><span class="emphasis"><em>Unfortunately, almost all the implementations of this mechanism work in an unexpected and insecure war. Rather than denying methods not specified in the rule, they allow any method not listed. Ironically, by listing specific methods in their rule, developers are actually allowing more access than they intended.</em></span></p><p>In order to understand this in a better way, let's focus on an analogy.</p><p>Suppose you have a web application to write books that handles two roles—one for authors who are able to write the pages of the books and another for reviewers who can only read the books and add notes with comments. Now, suppose a user ends up getting the URL of your application by mistake. This user does not have any credentials to deliver, and the obvious thing is that the user should not even be able to access the application. However, the problem that is demonstrated by the OWASP is that instead of doing what seems obvious, it actually enables application access to unauthenticated users with enough permission to perform any operation on the books, such as removing them.</p><p>Let's take an example in order to see this inconvenience, and after that, we will implement OWASP's suggestions to solve it.</p><p>Let's create a new method within the class <code class="literal">PersonService</code>; we'll use one of the methods that has not been listed in the <code class="literal">web.xml</code> file this time. One of the most used methods is <code class="literal">HTTP DELETE</code>; its functionality is to remove one of the entries stored in memory using its ID. This will pass the ID of the record as a parameter in the URL, so the URL of the request will look like the following:</p><p>
<code class="literal">http://localhost:8080/resteasy-examples/services/person/[ID]</code>
</p><p>The method implementation should look like the following:</p><div class="informalexample"><pre class="programlisting">@DELETE
@Path("{id}")
public Response delete(@PathParam("id") int id) {
  Person person = dataInMemory.get(id);
if (person == null) {
  // There is no person with this ID
throw new WebApplicationException(Response.Status.NOT_FOUND);
  }
  dataInMemory.remove(id);
  return Response.status(Status.GONE).build();
}</pre></div><p>In order to test the method, we <a class="indexterm" id="id114"/>must first create a couple of registers<a class="indexterm" id="id115"/> through SoapUI, also using the <code class="literal">HTTP POST</code> method and a string such as the following:</p><div class="informalexample"><pre class="programlisting">&lt;person&gt;&lt;name&gt;Rene&lt;/name&gt;&lt;lastname&gt;Enriquez&lt;/lastname&gt;&lt;/person&gt;</pre></div><p>Now, select the <code class="literal">DELETE</code> method in SoapUI, remove the information on the credentials we use for authentication, and perform a request using one of the item IDs, as shown in the following screenshot:</p><div class="mediaobject"><img alt="HTTP method – GET" src="graphics/0109OS_03_08.jpg"/></div><p>As you can see, the item was removed and the server returns the message <code class="literal">HTTP/1.1 410 Gone</code>. This indicates that<a class="indexterm" id="id116"/> the resource is no longer available. As you have noted, when we don't specify that this method should be protected by default, it is marked <a class="indexterm" id="id117"/>as available. In our case, any user without the need to authenticate can remove our application resources.</p><p>To overcome this drawback, the OWASP recommends adding another security constraint in the <code class="literal">web.xml</code> file. This new security constraint should not have any HTTP method listed within itself, which means denying access to all HTTP methods, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;security-constraint&gt;
  &lt;display-name&gt;For any user&lt;/display-name&gt;
  &lt;web-resource-collection&gt;
  &lt;web-resource-name&gt;protected_resources&lt;/web-resource-name&gt;
    &lt;url-pattern&gt;/services/*&lt;/url-pattern&gt;
  &lt;/web-resource-collection&gt;
  &lt;auth-constraint&gt;
    &lt;description&gt;User with any role&lt;/description&gt;
    &lt;role-name&gt;*&lt;/role-name&gt;
  &lt;/auth-constraint&gt;
&lt;/security-constraint&gt; </pre></div><p>Also, we will have to add a new role in order to determine an authenticated user in the application, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;security-role&gt;
    &lt;description&gt;Any role&lt;/description&gt;
    &lt;role-name&gt;*&lt;/role-name&gt;
  &lt;/security-role&gt;</pre></div><p>Now, we run the request from SoapUI, and we can see the error message <code class="literal">HTTP/1.1 401 Unauthorized</code>. This indicates that <a class="indexterm" id="id118"/>you cannot execute the request because the <a class="indexterm" id="id119"/>user has not been authenticated, which in turn means that unauthenticated users cannot use the <code class="literal">DELETE</code> or any other method.</p></div></div><div class="section" title="Fine-grained security implementation through annotations"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec15"/>Fine-grained security implementation through annotations</h2></div></div></div><p>The <code class="literal">web.xml</code> file, the file that allows all security settings, is not the only way in which you can achieve fine-grained <a class="indexterm" id="id120"/>security implementation; the platform also offers the possibility of using annotations for security checks. To do this, there are three options that can be chosen depending on your needs, listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@RolesAllowed</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">@DenyAll</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">@PermitAll</code></li></ul></div><div class="section" title="The @RolesAllowed annotation"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec07"/>The @RolesAllowed annotation</h3></div></div></div><p>The <code class="literal">@RolesAllowed</code> annotation can be<a class="indexterm" id="id121"/> applied at the method or class level. With this annotation, you can define a set of roles that are allowed to <a class="indexterm" id="id122"/>use the annotated resource. As a parameter annotation, let's write all allowed roles. For this example, we will modify our <code class="literal">web.xml</code> file as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="3.0" 
  
xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
  http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt;
  &lt;!-- Roles --&gt;
<span class="strong"><strong>  &lt;context-param&gt;</strong></span>
<span class="strong"><strong>    &lt;param-name&gt;resteasy.role.based.security&lt;/param-name&gt;</strong></span>
<span class="strong"><strong>    &lt;param-value&gt;true&lt;/param-value&gt;</strong></span>
<span class="strong"><strong>  &lt;/context-param&gt;</strong></span>
  &lt;security-role&gt;
    &lt;description&gt;Any role&lt;/description&gt;
    &lt;role-name&gt;*&lt;/role-name&gt;
  &lt;/security-role&gt;
  &lt;!-- Resource / Role Mapping --&gt;
  &lt;security-constraint&gt;
  &lt;display-name&gt;Area for authenticated users&lt;/display-name&gt;
    &lt;web-resource-collection&gt;
  &lt;web-resource-name&gt;protected_resources&lt;/web-resource-name&gt;
      &lt;url-pattern&gt;/services/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
      &lt;description&gt;User with any role&lt;/description&gt;
      &lt;role-name&gt;*&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
  &lt;/security-constraint&gt;
  &lt;login-config&gt;
    &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
  &lt;/login-config&gt;
&lt;/web-app&gt;</pre></div><p>In the class <code class="literal">PersonService</code>, let's use the annotation<a class="indexterm" id="id123"/> on every method with the roles we want to be able to execute the method, as follows:</p><div class="informalexample"><pre class="programlisting">  @RolesAllowed({ "reader", "administrator" })
  @POST
  @Consumes("application/xml")
  public Response savePerson(Person person) {...
  
  @RolesAllowed({ "administrator" })
  @GET
  @Path("{id}")
  @Produces("application/xml")
  public Person findById(@PathParam("id") int id) {...</pre></div><p>It is now time to test it through SoapUI.</p><div class="section" title="The savePerson method"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec01"/>The savePerson method</h4></div></div></div><p>Now, we will test<a class="indexterm" id="id124"/> the <code class="literal">savePerson</code> method of<a class="indexterm" id="id125"/> the <code class="literal">PersonService</code> class with the admin role, as shown in the following screenshot:</p><div class="mediaobject"><img alt="The savePerson method" src="graphics/0109OS_03_09.jpg"/></div><p>The execution was successful, as you can see in the preceding screenshot. The reason is because we included both roles in the <code class="literal">@RolesAllowed</code> annotation. Also, we will test the execution using the <code class="literal">reader</code> role for it to be successful, as shown in the following screenshot:</p><div class="mediaobject"><img alt="The savePerson method" src="graphics/0109OS_03_10.jpg"/></div><p>As you can see, we grant permissions<a class="indexterm" id="id126"/> to specific roles<a class="indexterm" id="id127"/> when we use the annotation <code class="literal">@RolesAllowed</code>. For this method, we used <code class="literal">administrator</code> and <code class="literal">reader</code>.</p></div><div class="section" title="The findById method"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec02"/>The findById method</h4></div></div></div><p>We will now<a class="indexterm" id="id128"/> test the method <code class="literal">findById</code> with the <code class="literal">administrator</code> role, as shown in the <a class="indexterm" id="id129"/>following screenshot:</p><div class="mediaobject"><img alt="The findById method" src="graphics/0109OS_03_11.jpg"/></div><p>The screenshot <a class="indexterm" id="id130"/>shows that the execution was successful because the <code class="literal">@RolesAllowed</code> annotation includes admin. As we <a class="indexterm" id="id131"/>didn't include the <code class="literal">reader</code> role, the next execution should not be authorized. Let's test it right now, as shown in the following screenshot:</p><div class="mediaobject"><img alt="The findById method" src="graphics/0109OS_03_12.jpg"/></div><p>Once again, we used the annotation <code class="literal">@RolesAllowed</code> to grant permissions at a method level, but this<a class="indexterm" id="id132"/> time we specified just<a class="indexterm" id="id133"/> one role, <code class="literal">administrator</code>.</p><p>All the source code for this chapter can be found at the following URL:</p><p>
<a class="ulink" href="https://github.com/restful-java-web-services-security/source-code/tree/master/chapter03">https://github.com/restful-java-web-services-security/source-code/tree/master/chapter03</a>
</p></div></div><div class="section" title="The @DenyAll annotation"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec08"/>The @DenyAll annotation</h3></div></div></div><p>The <code class="literal">@DenyAll</code> annotation allows us to define operations that cannot be invoked regardless of whether the user is<a class="indexterm" id="id134"/> authenticated <a class="indexterm" id="id135"/>or the roles are related to the user. The specification defines this annotation as follows:</p><p><span class="emphasis"><em>Specifies that no security roles are allowed to invoke the specified method(s) - i.e. that the methods are to be excluded from execution in the J2EE container.</em></span></p></div><div class="section" title="The @PermitAll annotation"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec09"/>The @PermitAll annotation</h3></div></div></div><p>When we use the <code class="literal">@PermitAll</code> annotation, we tell the <a class="indexterm" id="id136"/>container that<a class="indexterm" id="id137"/> the annotated resource (a method or all methods of the class) can be invoked by any user who has logged in to the application. This means<a class="indexterm" id="id138"/> that it is only necessary that the user be authenticated; it's not required to have any specific role assigned.</p><p>From these three annotations, the most used is undoubtedly the first one (<code class="literal">@RolesAllowed</code>); the others aren't often used since <code class="literal">@PermitAll</code> can be easily replaced in the <code class="literal">web.xml</code> file, and <code class="literal">@DenyAll</code> can be used only in few scenarios.</p></div></div><div class="section" title="Programmatical implementation of fine-grained security"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Programmatical implementation of fine-grained security</h2></div></div></div><p>RESTEasy, besides providing options for security management that we have seen, programmatically provides an additional mechanism for access control.</p><p>Within the operations of <a class="indexterm" id="id139"/>web services, you can add an additional parameter to the method. This allows access to the security context, without altering the way clients invoke the method or the action that the method executes. The parameter must be included in the following way:</p><div class="informalexample"><pre class="programlisting">@GET...
@Consumes("text/xml")
public returnType methodName(@Context SecurityContext secContext, …) {...</pre></div><p>Suppose that in our example, in the method <code class="literal">savePerson</code>, we want access to this functionality. The only change we need to make is shown in the following code snippets.</p><p>Earlier, the method used just one parameter, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@POST
@Consumes("application/xml")
public Response savePerson(Person person) {
  int id = dataInMemory.size() + 1;
  person.setId(id);
  dataInMemory.put(id, person);
  return Response.created(URI.create("/person/" + id)).build();
}</pre></div><p>Now, the method has another parameter, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">@POST
@Consumes("application/xml")
public Response savePerson(@Context SecurityContext secContext, Person person) {
  int id = dataInMemory.size() + 1;
  person.setId(id);
  dataInMemory.put(id, person);
  return Response.created(URI.create("/person/" + id)).build();
}</pre></div><p>The interface <code class="literal">javax.ws.rs.core.SecurityContext</code> offers the following three interesting<a class="indexterm" id="id140"/> features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">isUserInRole()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">getUserPrincipal()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">isSecure()</code></li></ul></div><p>The functionality of the method <code class="literal">isUserInRole ()</code> is similar to the annotation <code class="literal">@RolesAllowed</code>; its goal is to<a class="indexterm" id="id141"/> perform a check in order to determine if a logged user belongs to a specified role, as follows:</p><div class="informalexample"><pre class="programlisting">@POST
@Consumes("application/xml")
public Response savePerson(@Context SecurityContext secContext, Person person) {
  boolean isInDesiredRole = 	secContext.isUserInRole ("NameOfDesiredRole");
  int id = dataInMemory.size() + 1;
  person.setId(id);
  dataInMemory.put(id, person);
  return Response.created(URI.create("/person/" + id)).build();
}</pre></div><p>The <code class="literal">getUserPrincipal()</code> method <a class="indexterm" id="id142"/>obtains the primary user in the application, in other words, the logged user. You can obtain information such as the username that represents it through this user; this is always useful in scenarios in which you want to generate audit trails.</p><p>Finally, the method <code class="literal">isSecure()</code> determines <a class="indexterm" id="id143"/>whether the invocation is being made through a secure means of communication, such as whether you are using HTTPS.</p><p>As you know, HTTP and HTTPS are protocols to exchange information; the former is usually used when you share information that is not sensitive, and the latter is often used when the information is sensitive and we need a secure channel.</p><p>Let's imagine the web portal of ABC Bank, particularly the home page where it shows information about services and stuff related to the bank's business that can be managed with HTTP. We can't manage the web pages that work with information about accounts or money transfers with the HTTP protocol; this is because the information is not protected. Through the HTTPS protocol, we can encrypt the information; when the information is intercepted by a traffic analyzer such as Wireshark, it can't be interpreted.</p><p>This functionality can be tested by applying the changes to the project to enable HTTPS, as we show you in <a class="link" href="ch02.html" title="Chapter 2. The Importance of Securing Web Services">Chapter 2</a>, <span class="emphasis"><em>The Importance of Securing Web Services</em></span>.</p><p>When you invoke this method using HTTP, the result will be false, but it will be true when you invoke the same method using HTTPS.</p><p>These three methods we just analyzed are very useful when we want to implement fine-grained security checks. For<a class="indexterm" id="id144"/> example, when we want to implement an audit, we can determine if one action was executed using a transmission secure protocol such as HTTPS; also, we can discover information about the user that is executing the action.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Summary</h1></div></div></div><p>The needs that we have when implementing application security can be quite varied. In this chapter, we saw how JAX-RS offers mechanisms to handle security, starting from a fairly basic model (coarse-grained) to a more elaborate one (fine-grained) in which you can perform more exhaustive controls, including programmatic controls and controls through configuration files.</p><p>Of course, it is always recommended to keep these checks in configuration files such as <code class="literal">web.xml</code>. Since you have the controls centralized in one place, it facilitates maintenance. This does not occur when security is handled at the level of source code, because when there are many classes that are part of the project, the tasks get complicated when some form of modification to the current functionality is required.</p><p>Now, you should prepare for the next chapter, in which we will talk about OAuth. It's a very exciting topic because this protocol is widely accepted and used across Internet applications. The rockstar companies of the World Wide Web, such as Google, Twitter, and Facebook, among others, use it with great success.</p></div></body></html>