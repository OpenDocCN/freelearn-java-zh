- en: RESTful Web Services Using Spring Boot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Boot的RESTful Web服务
- en: 'In this chapter, we are going to cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating a simple Spring Boot application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的Spring Boot应用程序
- en: Interacting with the database
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数据库交互
- en: Creating a RESTful web service
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建RESTful Web服务
- en: Creating multiple profiles for Spring Boot
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Spring Boot创建多个配置文件
- en: Deploying RESTful web services to Heroku
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将RESTful Web服务部署到Heroku
- en: Containerizing the RESTful web service using Docker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker容器化RESTful Web服务
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In recent years, the drive for microservice-based architecture has gained wide
    adoption, thanks to the simplicity and ease of maintenance it provides when done
    the right way. A lot of companies, such as Netflix, Amazon, and the like, have
    moved from monolithic systems to more focused and lighter systems, all talking
    with each other via RESTful web services. The advent of RESTful web services and
    its straightforward approach to creating web services using the known HTTP protocol
    has made it easier for communication between applications than the older SOAP-based
    web services.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，基于微服务架构的推动力得到了广泛的应用，这得益于它提供的简单性和易于维护。许多公司，如Netflix、Amazon等，已经从单体系统迁移到更专注和更轻的系统，所有这些系统都通过RESTful
    Web服务相互通信。RESTful Web服务的出现及其使用已知HTTP协议创建Web服务的直接方法，使得应用程序之间的通信比旧的基于SOAP的Web服务更容易。
- en: In this chapter, we will look at the **Spring Boot** framework, which provides
    a convenient way to create production-ready microservices using Spring libraries.
    Using Spring Boot, we will develop a simple RESTful web service and deploy the
    same on the cloud.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨**Spring Boot**框架，该框架提供了一个方便的方式来使用Spring库创建生产就绪的微服务。使用Spring Boot，我们将开发一个简单的RESTful
    Web服务并将其部署到云上。
- en: Creating a simple Spring Boot application
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的Spring Boot应用程序
- en: Spring Boot helps in creating production-ready Spring-based applications easily.
    It provides support for working with almost all Spring libraries, without any
    need for configuring them explicitly. There are autoconfiguration classes provided
    for easy integration with most commonly used libraries, databases, message queues,
    and the likes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot可以帮助轻松地创建生产就绪的基于Spring的应用程序。它提供了对几乎所有Spring库的支持，无需显式配置。它提供了自动配置类，以便与大多数常用库、数据库、消息队列等轻松集成。
- en: In this recipe, we will look at creating a simple Spring Boot application with
    a controller that prints a message when opened in the browser.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将探讨创建一个简单的Spring Boot应用程序，其中包含一个控制器，当在浏览器中打开时打印一条消息。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Spring Boot supports Maven and Gradle as the build tools and we will be using
    Maven in our recipes. The URL, [http://start.spring.io/](http://start.spring.io/),
    provides a convenient way to create an empty project with the required dependencies.
    We will use it to download an empty project. Follow these steps to create and
    download an empty Spring Boot-based project:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot支持Maven和Gradle作为构建工具，在我们的食谱中我们将使用Maven。URL [http://start.spring.io/](http://start.spring.io/)
    提供了一种方便的方式来创建一个带有所需依赖项的空项目。我们将使用它来下载一个空项目。按照以下步骤创建和下载一个基于Spring Boot的空项目：
- en: 'Navigate to [http://start.spring.io/](http://start.spring.io/) to see something
    similar to the following screenshot:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 [http://start.spring.io/](http://start.spring.io/) 以查看以下截图类似的内容：
- en: '![](img/e495acd3-651c-446e-af0c-a1ef90f6010b.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e495acd3-651c-446e-af0c-a1ef90f6010b.png)'
- en: You can select the dependency management and build tool, selecting the appropriate
    option in the dropdown after the text, **Generate a**.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过在文本后的下拉菜单中选择适当的选项来选择依赖关系管理和构建工具，**Generate a**。
- en: Spring Boot supports Java, Kotlin, and Groovy. You can choose the language by
    changing the dropdown after the text, **with**.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Boot支持Java、Kotlin和Groovy。您可以通过更改文本后的下拉菜单来选择语言，**with**。
- en: Select the Spring Boot version by choosing its value from the dropdown after
    the text, and Spring Boot. For this recipe, we'll use the latest milestone edition
    of Spring Boot 2 I.E 2.0.0 M2.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在文本后的下拉菜单中选择Spring Boot的版本值，选择Spring Boot。对于这个食谱，我们将使用Spring Boot 2的最新里程碑版2.0.0
    M2。
- en: On the left-hand side, under Project Metadata, we have to provide Maven-related
    information, that is, the group ID and artifact ID. We'll use Group as `com.packt`
    and Artifact as `boot_demo`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧，在项目元数据下，我们必须提供与Maven相关的信息，即组ID和工件ID。我们将组设置为`com.packt`，工件设置为`boot_demo`。
- en: On the right-hand side, under Dependencies, you can search for the dependencies
    you want to add. For this recipe, we need web and Thymeleaf dependencies. This
    means that we want to create a web application which uses Thymeleaf UI templates
    and would want all the dependencies, such as Spring MVC, Embedded Tomcat, and
    others, to be part of the application.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧的依赖项下，你可以搜索你想添加的依赖项。对于这个菜谱，我们需要web和Thymeleaf依赖项。这意味着我们想要创建一个使用Thymeleaf UI模板的Web应用程序，并且希望所有依赖项，如Spring
    MVC、嵌入式Tomcat等，都成为应用程序的一部分。
- en: Then, click on the Generate Project button to download the empty project. You
    can load this empty project in any IDE of your choice, just like any other Maven
    project.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击生成项目按钮以下载空项目。你可以将这个空项目加载到你选择的任何IDE中，就像其他Maven项目一样。
- en: At this point, you will have your empty project loaded into an IDE of your choice
    and ready to explore further. In this recipe, we will make use of the Thymeleaf
    template engine to define our web pages and create a simple controller to render
    the web page.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你将把你的空项目加载到你选择的IDE中，并准备好进一步探索。在这个菜谱中，我们将使用Thymeleaf模板引擎来定义我们的Web页面，并创建一个简单的控制器来渲染Web页面。
- en: The complete code for this recipe can be found at the location, `chp10/1_boot_demo`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整代码可以在位置`chp10/1_boot_demo`找到。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: If you have followed the group ID and artifact ID naming as mentioned in the
    *Getting ready* section, you will have a package structure, `com.packt.boot_demo`,
    and a `BootDemoApplication.java` main class already created for you. There will
    be an equivalent package structure and a `BootDemoApplicationTests.java` main
    class under the `tests` folder.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你遵循了*准备就绪*部分中提到的组ID和工件ID命名，你将有一个包结构`com.packt.boot_demo`和一个为你创建的`BootDemoApplication.java`主类。在`tests`文件夹下将有一个等效的包结构和`BootDemoApplicationTests.java`主类。
- en: 'Create a new class, `SimpleViewController`, under the `com.packt.boot_demo`
    package, with the following code:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packt.boot_demo`包下创建一个新的类，名为`SimpleViewController`，代码如下：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a web page, `message.html`, under the location, `src/main/resources/templates`,
    with the following code:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在位置`src/main/resources/templates`下创建一个名为`message.html`的Web页面，代码如下：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the command prompt, navigate to the project root folder and issue the command, `mvn
    spring-boot:run`; you'll see the application being launched. Once it completes
    the initialization and starts, it would be running on the default port, `8080`.
    Navigate to `http://localhost:8080/message` to see the message.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令提示符导航到项目根目录，并执行命令`mvn spring-boot:run`；你会看到应用程序正在启动。一旦初始化完成并开始运行，它将默认在端口`8080`上运行。导航到`http://localhost:8080/message`以查看消息。
- en: We are using Spring Boot's Maven plugin, which provides us with convenient tools
    to launch the application during development. But for production, we will create
    a fat JAR, that is, a JAR comprising all the dependencies, and deploy it as a
    Linux or Windows service. We can even run the fat JAR using the `java -jar` command.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Spring Boot的Maven插件，它为我们提供了在开发期间启动应用程序的便捷工具。但对于生产环境，我们将创建一个胖JAR，即包含所有依赖项的JAR文件，并将其作为Linux或Windows服务部署。我们甚至可以使用`java
    -jar`命令运行胖JAR。
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will not go into the working of Spring Boot or the other Spring libraries.
    But to state in brief, Spring Boot creates an embedded Tomcat running on the default
    port, that is, `8080`. It then registers all the controllers, components, and
    services that are available in the packages and sub packages of the class with
    the annotation, `@SpringBootApplication`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨Spring Boot或其他Spring库的工作原理。但简要来说，Spring Boot创建了一个在默认端口`8080`上运行的嵌入式Tomcat。然后，它将类中带有`@SpringBootApplication`注解的包和子包中的所有控制器、组件和服务注册到Spring框架中。
- en: In our recipe, the `BootDemoApplication` class in the `com.packt.boot_demo`
    package is annotated with `@SpringBootApplication`. So, all the classes that are
    annotated with `@Controller`, `@Service`, `@Configuration`, `@Component`, and
    the likes of it get registered with the Spring framework as beans and are managed
    by it. Now, these can be injected into the code by using the `@Autowired` annotation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的菜谱中，位于`com.packt.boot_demo`包下的`BootDemoApplication`类被注解为`@SpringBootApplication`。因此，所有被注解为`@Controller`、`@Service`、`@Configuration`、`@Component`等注解的类都会注册到Spring框架中作为bean，并由它管理。现在，我们可以通过使用`@Autowired`注解将这些类注入到代码中。
- en: 'There are two ways we can create a web controller:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方式可以创建一个Web控制器：
- en: Annotating with `@Controller`
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`@Controller`注解
- en: Annotating with `@RestController`
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`@RestController`注解
- en: 'In the first approach, we create a controller that can serve both raw data
    and HTML data (generated by template engines such as Thymeleaf, Freemarker, JSP,
    and others). In the second approach, the controller supports endpoints that can
    only serve raw data in the form of JSON or XML. In our recipe, we used the former
    approach, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种方法中，我们创建了一个可以提供原始数据和 HTML 数据（由模板引擎如 Thymeleaf、Freemarker、JSP 等）生成的控制器。在第二种方法中，控制器支持只能以
    JSON 或 XML 格式提供原始数据的端点。在我们的菜谱中，我们使用了前者，如下所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can annotate the class with `@RequestMapping` with, say, `@RequestMapping("/api")`.
    In this case, any HTTP endpoints exposed in the controller are prepended by `/api`.
    There is a specialized annotation mapping for HTTP `GET`, `POST`, `DELETE`, and
    `PUT` methods, namely `@GetMapping`, `@PostMapping`, `@DeleteMapping`, and `@PutMapping`,
    respectively. We can also rewrite our controller class as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 `@RequestMapping` 注解类，例如 `@RequestMapping("/api")`。在这种情况下，控制器中暴露的任何 HTTP
    端点都将由 `/api` 预先添加。对于 HTTP `GET`、`POST`、`DELETE` 和 `PUT` 方法，有专门的注解映射，分别是 `@GetMapping`、`@PostMapping`、`@DeleteMapping`
    和 `@PutMapping`。我们还可以将我们的控制器类重写如下：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can modify the port by providing `server.port = 9090` in the `application.properties`
    file. This file can be found in the location, `src/main/resources/application.properties`.
    There is a whole set of properties ([http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html](http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html))
    that we can use to customize and connect with different components.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 `application.properties` 文件中提供 `server.port = 9090` 来修改端口号。此文件位于 `src/main/resources/application.properties`
    位置。我们可以使用一整套属性（[http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html](http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html)）来自定义并连接到不同的组件。
- en: Interacting with the database
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数据库交互
- en: In this recipe, we will look at how to integrate with a database to create,
    read, modify, and delete the data. For this, we will set up a MySQL database with
    the required table. Subsequently, we will update the data in a table from our
    Spring Boot application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何与数据库集成以创建、读取、修改和删除数据。为此，我们将设置一个包含所需表的 MySQL 数据库。随后，我们将从我们的 Spring
    Boot 应用程序中更新表中的数据。
- en: We will be using Windows as the platform of development for this recipe. You
    can perform a similar action on Linux as well, but you would first have to set
    up your MySQL database.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Windows 作为本菜谱的开发平台。你同样可以在 Linux 上执行类似操作，但首先你必须设置你的 MySQL 数据库。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we start integrating our application with the database, we need to set
    up the database locally on our development machines. In the subsequent sections,
    we will download and install MySQL tools and then create a sample table with some
    data, which we will use with our application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将应用程序与数据库集成之前，我们需要在我们的开发机器上本地设置数据库。在接下来的章节中，我们将下载并安装 MySQL 工具，然后创建一个包含一些数据的示例表，我们将使用这个表与我们的应用程序一起。
- en: Installing MySQL tools
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 MySQL 工具
- en: 'First, download the MySQL installer from [https://dev.mysql.com/downloads/windows/installer/5.7.html](https://dev.mysql.com/downloads/windows/installer/5.7.html).
    This MySQL bundle is for Windows only. Follow the onscreen instructions to successfully
    install MySQL along with other tools such as MySQL Workbench. To confirm that
    the MySQL daemon (`mysqld`) is running, open the task manager and you should be
    able to see a process similar to the one shown in the following image:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从 [https://dev.mysql.com/downloads/windows/installer/5.7.html](https://dev.mysql.com/downloads/windows/installer/5.7.html)
    下载 MySQL 安装程序。这个 MySQL 包仅适用于 Windows。遵循屏幕上的说明成功安装 MySQL 以及其他工具，如 MySQL Workbench。要确认
    MySQL 守护进程（`mysqld`）正在运行，打开任务管理器，你应该能看到以下图像中类似的过程：
- en: '![](img/808e253f-61e7-4001-8276-dd89038c5ea2.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/808e253f-61e7-4001-8276-dd89038c5ea2.png)'
- en: You should remember the password you set for the root user.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记住为 root 用户设置的密码。
- en: 'Let''s run the MySQL workbench; on starting up, you should be able to see something
    similar to the following image, among other things provided by the tool:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 MySQL 工作台；启动时，你应该能看到以下图像以及其他由该工具提供的图像：
- en: '![](img/1209d7ad-07ef-481f-9787-121d25f3adcf.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1209d7ad-07ef-481f-9787-121d25f3adcf.png)'
- en: 'If you don''t find a connection like the preceding image, you can add one using
    the (+) sign. On clicking on (+), you will see the following dialog. Fill it up
    and click on Test Connection to get a success message:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您找不到前面的图像中的连接，您可以使用（+）符号添加一个。点击（+）后，您将看到以下对话框。填写它并点击测试连接以获取成功消息：
- en: '![](img/f17690ad-740e-40a6-9821-292b79e0144f.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f17690ad-740e-40a6-9821-292b79e0144f.png)'
- en: 'A successful Test Connection will result in the following message:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的测试连接将产生以下消息：
- en: '![](img/2ad5d683-ac9c-48a7-9742-5f6b73ef038a.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2ad5d683-ac9c-48a7-9742-5f6b73ef038a.png)'
- en: Double-click on the connection to connect to the database, and you should see
    a list of DBs on the left-hand side, an empty area on the right-hand side, and
    menu and toolbars on the top. From the File menu, click on New Query Tab or, alternatively,
    press *Ctrl* + *T* to get a new query window. Here, we will write our queries
    to create a database and create a table within that database.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 双击连接以连接到数据库，您应该在左侧看到数据库列表，右侧有一个空白区域，顶部有菜单和工具栏。从文件菜单中，点击新建查询标签或，作为替代，按*Ctrl*
    + *T*以获取一个新的查询窗口。在这里，我们将编写我们的查询以创建数据库并在该数据库中创建一个表。
- en: The bundled installer downloaded from [https://dev.mysql.com/downloads/windows/installer/5.7.html](https://dev.mysql.com/downloads/windows/installer/5.7.html)
    is for Windows only. Linux users have to download the MySQL Server and MySQL Workbench
    (GUI for interacting with DB) separately.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://dev.mysql.com/downloads/windows/installer/5.7.html](https://dev.mysql.com/downloads/windows/installer/5.7.html)下载的捆绑安装程序仅适用于Windows。Linux用户必须分别下载MySQL服务器和MySQL
    Workbench（与数据库交互的GUI）。
- en: The MySQL server can be downloaded from [https://dev.mysql.com/downloads/mysql/](https://dev.mysql.com/downloads/mysql/).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL服务器可以从[https://dev.mysql.com/downloads/mysql/](https://dev.mysql.com/downloads/mysql/)下载。
- en: The MySQL Workbench can be downloaded from [https://dev.mysql.com/downloads/workbench/](https://dev.mysql.com/downloads/workbench/).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Workbench可以从[https://dev.mysql.com/downloads/workbench/](https://dev.mysql.com/downloads/workbench/)下载。
- en: Creating a sample database
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建示例数据库
- en: 'Run the following SQL statement to create a database:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下SQL语句来创建数据库：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating a person table
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建人员表
- en: 'Run the following SQL statements to use the newly created database and create
    a simple person table:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下SQL语句以使用新创建的数据库并创建一个简单的人员表：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Populating sample data
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充示例数据
- en: 'Let''s go ahead and insert some sample data in the table we just created:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在我们的新创建的表中插入一些示例数据：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we have our database ready, we will go ahead and download the empty
    Spring Boot project from [http://start.spring.io/](http://start.spring.io/) with
    the following options:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了数据库，我们将继续从[http://start.spring.io/](http://start.spring.io/)下载空的Spring
    Boot项目，以下是一些选项：
- en: '![](img/ce36c8dc-a4b2-4bb7-b329-59e87c0807ac.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ce36c8dc-a4b2-4bb7-b329-59e87c0807ac.png)'
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a model class, `com.packt.boot_db_demo.Person`, for representing a person.
    We will make use of Lombok annotations to generate the getters and setters for
    us:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表示人员的模型类`com.packt.boot_db_demo.Person`。我们将使用Lombok注解为我们生成getter和setter：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s create `com.packt.boot_db_demo.PersonMapper` to map the data from the
    database into our model class, `Person`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建`com.packt.boot_db_demo.PersonMapper`来将数据库中的数据映射到我们的模型类`Person`：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s add a method to get all the rows from the table. Note that the next
    few methods will be written inside the `PersonMapper` interface:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个方法来获取表中的所有行。注意，接下来的几个方法将编写在`PersonMapper`接口内部：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Another method to get the details of a single person identified by ID is as
    follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个方法是通过ID获取单个人员的详细信息如下：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The method to create a new row in the table is as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建表中新行的方法如下：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The method to update an existing row in the table, identified by the ID is
    as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新表中由ID标识的现有行的方法如下：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, the method to delete a row from the table, identified by the ID is
    as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，删除表中由ID标识的行的方法如下：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s create a `com.packt.boot_db_demo.PersonController` class, which we will
    use to write our web endpoints:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个`com.packt.boot_db_demo.PersonController`类，我们将使用它来编写我们的Web端点：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s create an endpoint to list all the entries in the `person` table:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个端点来列出`person`表中的所有条目：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s create an endpoint to add a new row in the `person` table:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个端点来在`person`表中添加新行：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s create an endpoint to add a new row or edit an existing row in the `person`
    table:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`person`表中创建一个端点来添加新行或编辑现有行：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s create an endpoint to delete a row from the `person` table:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个端点来从`person`表中删除一行：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we need to update the `src/main/resources/application.properties`
    file to provide the configuration related to our data source, that is, our MySQL
    database:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要更新`src/main/resources/application.properties`文件，以提供与我们的数据源（即我们的MySQL数据库）相关的配置：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can run the application from the command line using `mvn spring-boot:run`.
    This application starts up on the default port, that is, `8080`. Navigate to `http://localhost:8080/persons`
    in your browser.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`mvn spring-boot:run`命令行运行应用程序。该应用程序在默认端口启动，即`8080`。在浏览器中导航到`http://localhost:8080/persons`。
- en: The complete code for this recipe can be found at the location, `chp10/2_boot_db_demo`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整代码可以在以下位置找到，`chp10/2_boot_db_demo`。
- en: 'On visiting `http://localhost:8080/persons`, this is what you will find:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`http://localhost:8080/persons`时，你会看到以下内容：
- en: '![](img/9d1e94e0-7e9a-44a9-ba09-f1865e9c311f.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d1e94e0-7e9a-44a9-ba09-f1865e9c311f.png)'
- en: 'On clicking on **New Person**, you''ll get the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**新建人员**后，你会看到以下内容：
- en: '![](img/a17f99f6-e99f-44bf-9782-cb5ced34c31f.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a17f99f6-e99f-44bf-9782-cb5ced34c31f.png)'
- en: 'On clicking on **Edit**, you''ll get the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**编辑**后，你会看到以下内容：
- en: '![](img/d5c693af-c327-4da1-93ba-28a03bc5cf08.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5c693af-c327-4da1-93ba-28a03bc5cf08.png)'
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Firstly, `com.packt.boot_db_demo.PersonMapper` annotated with `org.apache.ibatis.annotations.Mapper`
    knows how to execute the query provided within the `@Select`, `@Update`, or `@Delete`
    annotations and to return relevant results. This is all managed by the MyBatis
    and Spring Data libraries.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`com.packt.boot_db_demo.PersonMapper`被`org.apache.ibatis.annotations.Mapper`注解，知道如何执行`@Select`、`@Update`或`@Delete`注解中提供的查询，并返回相关结果。这一切都由MyBatis和Spring
    Data库管理。
- en: You must be wondering how the connection to database was achieved. One of the
    Spring Boot autoconfiguration classes, `DataSourceAutoConfiguration`, does the
    work of setting up by making use of the `spring.datasource.*` properties defined
    in your `application.properties` file to give us an instance of `javax.sql.DataSource`.
    This `javax.sql.DataSource` object is then used by the MyBatis library to provide
    you with an instance of `SqlSessionTemplate`, which is what is used by our `PersonMapper`
    under the hood.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道数据库连接是如何实现的。Spring Boot自动配置类之一`DataSourceAutoConfiguration`通过使用你在`application.properties`文件中定义的`spring.datasource.*`属性来设置配置，为我们提供一个`javax.sql.DataSource`实例。然后，MyBatis库使用这个`javax.sql.DataSource`对象为你提供一个`SqlSessionTemplate`实例，这就是我们的`PersonMapper`在底层使用的。
- en: Then, we make use of `com.packt.boot_db_demo.PersonMapper` by injecting it into
    the `com.packt.boot_db_demo.PersonController` class by using `@AutoWired`. The
    `@AutoWired` annotation looks for any Spring managed beans, which are either instances
    of the exact type or its implementation. Take a look at the *Creating a simple
    Spring Boot application* recipe in this chapter to understand the `@Controller`
    annotation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过使用`@AutoWired`将`com.packt.boot_db_demo.PersonMapper`注入到`com.packt.boot_db_demo.PersonController`类中，来使用`com.packt.boot_db_demo.PersonMapper`。`@AutoWired`注解会查找任何Spring管理的bean，这些bean要么是确切类型的实例，要么是其实现。查看本章中的*创建一个简单的Spring
    Boot应用程序*食谱，以了解`@Controller`注解。
- en: With very little configuration, we have been able to quickly set up simple CRUD
    operations. This is the flexibility and agility that Spring Boot provides to developers!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过极少的配置，我们能够快速设置简单的CRUD操作。这正是Spring Boot为开发者提供的灵活性和敏捷性！
- en: Creating a RESTful web service
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建RESTful Web服务
- en: In our previous recipe, we interacted with data using web forms. In this recipe,
    we will see how to interact with data using RESTful web services. These web services
    are a means to interact with other applications using the known HTTP protocol
    and its methods, namely GET, POST, PUT, and others. The data can be exchanged
    in the form of XML, JSON, or even plain text. We will be using JSON in our recipe.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的食谱中，我们使用Web表单与数据交互。在这个食谱中，我们将看到如何使用RESTful Web服务与数据交互。这些Web服务是使用已知的HTTP协议及其方法（即GET、POST、PUT等）与其他应用程序交互的一种方式。数据可以以XML、JSON或纯文本的形式交换。在我们的食谱中，我们将使用JSON。
- en: So, we will create RESTful APIs to support retrieving data, creating new data,
    editing data, and deleting data.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将创建RESTful API来支持检索数据、创建新数据、编辑数据和删除数据。
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As usual, download the starter project from [http://start.spring.io/](http://start.spring.io/) by
    selecting the dependencies as shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，通过选择以下截图所示的依赖项，从[http://start.spring.io/](http://start.spring.io/)下载启动项目：
- en: '![](img/65375392-107e-43d6-89f2-7bb3c66a35f2.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65375392-107e-43d6-89f2-7bb3c66a35f2.png)'
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will copy the `Person` class from the previous recipe:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从之前的菜谱中复制`Person`类：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will do the `PersonMapper` part in a different way. We will write all our
    SQL queries in a mapper XML file and then refer to them from the `PersonMapper`
    interface. We will place the mapper XML under the `src/main/resources/mappers`
    folder. We'll set the value of the `mybatis.mapper-locations` property to `classpath*:mappers/*.xml`.
    This way, the `PersonMapper` interface can discover the SQL queries corresponding
    to its methods.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将以不同的方式处理`PersonMapper`部分。我们将把所有的SQL查询写在映射XML文件中，然后从`PersonMapper`接口中引用它们。我们将映射XML放在`src/main/resources/mappers`文件夹下。我们将`mybatis.mapper-locations`属性的值设置为`classpath*:mappers/*.xml`。这样，`PersonMapper`接口就可以发现与其方法对应的SQL查询。
- en: 'First, let''s create the `com.packt.boot_rest_demo.PersonMapper` interface:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建`com.packt.boot_rest_demo.PersonMapper`接口：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let''s create the SQL in `PersonMapper.xml`. One thing to make sure of
    is that the `namespace` attribute of the `<mapper>` tag should be the same as
    the fully qualified name of the `PersonMapper` mapper interface:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`PersonMapper.xml`中创建SQL。需要确保的是`<mapper>`标签的`namespace`属性应该与`PersonMapper`映射接口的完全限定名称相同：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will define the application properties in the `src/main/resources/application.properties`
    file:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`src/main/resources/application.properties`文件中定义应用程序属性：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create an empty controller for our REST APIs. This controller will be marked
    with the `@RestController` annotation because all the APIs in it are going to
    deal solely with data:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的REST API创建一个空的控制器。这个控制器将使用`@RestController`注解，因为其中的所有API都将仅处理数据：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s add an API to list all the rows in the `person` table:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个API来列出`person`表中的所有行：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s add an API to get the details of a single person:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个API来获取单个人员的详细信息：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s add an API to add new data to the table:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个API来向表中添加新数据：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s add an API to edit the data in the table:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个API来编辑表中的数据：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s add an API to delete the data in the table:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个API来删除表中的数据：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can find the complete code at the location, `chp10/3_boot_rest_demo`. You
    can launch the application by using `mvn spring-boot:run` from the project folder.
    Once the application has started, navigate to `http://localhost:8080/api/persons`
    to view all the data in the person table.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在指定位置找到完整的代码，`chp10/3_boot_rest_demo`。您可以从项目文件夹中使用`mvn spring-boot:run`启动应用程序。一旦应用程序启动，导航到`http://localhost:8080/api/persons`以查看人员表中的所有数据。
- en: To test the other APIs, we will make use of the Postman REST client app for
    Google Chrome.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试其他API，我们将使用Google Chrome的Postman REST客户端应用。
- en: 'This is what adding a new person looks like. Look at the request body, that
    is, the person detail specified in JSON:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是添加新人员的样子。看看请求体，即JSON中指定的人员详细信息：
- en: '![](img/50ab051d-1b1b-441e-8166-209c9df8424e.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50ab051d-1b1b-441e-8166-209c9df8424e.png)'
- en: 'This is how we edit a person''s detail:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何编辑一个人的详细信息：
- en: '![](img/b053a527-ed07-45e2-b949-d8da14f6eab6.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b053a527-ed07-45e2-b949-d8da14f6eab6.png)'
- en: 'This is what deleting a person looks like:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是删除一个人的样子：
- en: '![](img/5328fb47-7242-4ce9-b772-b04d52732a48.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5328fb47-7242-4ce9-b772-b04d52732a48.png)'
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, let's look at how the `PersonMapper` interface discovers the SQL statements
    to execute. If you look at `src/main/resources/mappers/PersonMapper.xml`, you
    will find that the `<mapper>` `namespace` attribute is `org.packt.boot_rest_demo.PersonMapper`.
    This is a requirement that the value of `namespace` attribute should be the fully
    qualified name of the mapper interface, which, in our case, is `org.packt.boot_rest_demo.PersonMapper`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看`PersonMapper`接口是如何发现要执行的SQL语句的。如果您查看`src/main/resources/mappers/PersonMapper.xml`，您会发现`<mapper>`的`namespace`属性是`org.packt.boot_rest_demo.PersonMapper`。这是`namespace`属性值应该是映射接口的完全限定名称的要求，在我们的例子中是`org.packt.boot_rest_demo.PersonMapper`。
- en: Next the `id` attributes of the individual SQL statements defined within `<select>`,
    `<insert>`, `<update>`, and `<delete>` should match the name of the method in
    the mapper interface. For example, the `getPersons()` method in the `PersonMapper`
    interface looks for an SQL statement with `id="getPersons"`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`<select>`、`<insert>`、`<update>`和`<delete>`中定义的各个SQL语句的`id`属性应该与映射接口中的方法名称匹配。例如，`PersonMapper`接口中的`getPersons()`方法查找`id="getPersons"`的SQL语句。
- en: Now the MyBatis library discovers the location of this mapper XML by reading
    the value of the `mybatis.mapper-locations` property.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在MyBatis库通过读取`mybatis.mapper-locations`属性的值来发现这个mapper XML的位置。
- en: Coming to the controller, we have introduced a new annotation, `@RestController`.
    This special annotation indicates, in addition to it being a web controller, that
    all the methods defined in the class return a response that is sent via the HTTP
    response body; so do all the REST APIs. They just work with the data.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 来到控制器部分，我们引入了一个新的注解`@RestController`。这个特殊的注解除了表示它是一个Web控制器外，还表示类中定义的所有方法都返回通过HTTP响应体发送的响应；所有REST
    API也是如此。它们只是与数据一起工作。
- en: As usual, you can launch your Spring Boot application either by using the Maven
    Spring-Boot plugin, `mvn spring-boot:run` or by executing the JAR created by the
    Maven package, `java -jar my_jar_name.jar`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常一样，你可以通过使用Maven Spring-Boot插件`mvn spring-boot:run`或通过执行Maven打包创建的JAR文件`java
    -jar my_jar_name.jar`来启动你的Spring Boot应用程序。
- en: Creating multiple profiles for Spring Boot
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Spring Boot创建多个配置文件
- en: Generally, web applications are deployed on different environments--first, they
    are run locally on a developer's machine, then deployed on test servers, and finally
    deployed on production servers. We would have the application interacting with
    components located in different places for each environment. The best approach
    for this is to maintain different profiles for each environment. One way to do
    this is by creating different versions of the `application.properties` file, that
    is, different versions of the file that stores the application-level properties.
    These property files in Spring Boot can also be YML files, such as `application.yml`.
    Even if you create different versions, you need a mechanism to tell your applications
    to pick the relevant version of the file, based on the environment it has been
    deployed to.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Web应用程序部署在不同的环境中--首先，它们在开发者的机器上本地运行，然后部署到测试服务器，最后部署到生产服务器。对于每个环境，应用程序都会与位于不同位置的不同组件交互。为此，最佳做法是为每个环境维护不同的配置文件。一种方法是通过创建`application.properties`文件的不同版本来实现，即存储应用程序级别属性的文件的不同版本。这些Spring
    Boot中的属性文件也可以是YML文件，例如`application.yml`。即使你创建了不同的版本，你也需要一种机制来告诉你的应用程序根据它部署到的环境选择相关版本的文件。
- en: Spring Boot provides amazing support for such a feature. It allows you to have
    multiple configuration files, each representing a specific profile, and then,
    you can launch your application in different profiles, depending on the environment
    it is being deployed to. Let's see this in action, and then we will explain how
    it works.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot为这样的特性提供了惊人的支持。它允许你拥有多个配置文件，每个文件代表一个特定的配置文件，然后，你可以根据应用程序部署到的环境启动应用程序。让我们看看它是如何工作的，然后我们将解释它是如何工作的。
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, there are two options to host another instance of your MySQL
    database:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，有两种方式来托管MySQL数据库的另一个实例：
- en: Use a cloud provider such as AWS and use its Amazon **Relational Database Service**
    (**RDS**) ([https://aws.amazon.com/rds/](https://aws.amazon.com/rds/)). They have
    a certain free usage limit.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用像AWS这样的云服务提供商，并使用其Amazon **关系数据库服务**（**RDS**）([https://aws.amazon.com/rds/](https://aws.amazon.com/rds/))。他们有一定的免费使用限制。
- en: Use a cloud provider such as DigitalOcean ([https://www.digitalocean.com/](https://www.digitalocean.com/))
    to purchase a droplet (that is, a server) for as little as $5 per month. Then
    install the MySQL server on it.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用像DigitalOcean([https://www.digitalocean.com/](https://www.digitalocean.com/))这样的云服务提供商，以每月最低5美元的价格购买一个droplet（即服务器）。然后在上面安装MySQL服务器。
- en: Use VirtualBox to install Linux on your machine, assuming we are using Windows,
    or vice versa if you are using Linux. Then install the MySQL server on it.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用VirtualBox在你的机器上安装Linux，假设我们使用Windows，或者如果你使用Linux，则相反。然后在上面安装MySQL服务器。
- en: 'The options are much more right from hosted database services to servers, which
    give you complete root access to install the MySQL server. For this recipe, we
    did the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 选项从托管数据库服务到服务器，这些服务器可以让你完全访问root权限来安装MySQL服务器。对于这个食谱，我们做了以下操作：
- en: We purchased a basic droplet from DigitalOcean.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从DigitalOcean购买了基本droplet。
- en: We installed MySQL using `sudo apt-get install mysql-server-5.7` with a password
    for the root user.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`sudo apt-get install mysql-server-5.7`安装MySQL，并为root用户设置密码。
- en: 'We created another user, `springboot`, so that we can use this user to connect
    from our RESTful web service application:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`springboot`的新用户，这样我们就可以使用这个用户从我们的RESTful Web服务应用程序连接：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We modified the MySQL configuration file so that the MySQL allows remote connections.
    This can be done by editing the `bind-address` property in the `/etc/mysql/mysql.conf.d/mysqld.cnf`
    file to the IP of the server.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们修改了MySQL配置文件，以便MySQL允许远程连接。这可以通过在`/etc/mysql/mysql.conf.d/mysqld.cnf`文件中编辑`bind-address`属性为服务器的IP地址来实现。
- en: From MySQL workbench, we added the new MySQL connection by using `IP = <Digital
    Ocean droplet IP>`, `username = springboot`, and `password = springboot`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从MySQL工作台，我们通过使用`IP = <Digital Ocean droplet IP>`、`username = springboot`和`password
    = springboot`添加了新的MySQL连接。
- en: 'The  location for the MySQL configuration file in Ubuntu OS is `/etc/mysql/mysql.conf.d/mysqld.cnf`.
    One way to find out the location of a configuration file specific to your OS is
    to do the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu OS中，MySQL配置文件的位置是`/etc/mysql/mysql.conf.d/mysqld.cnf`。找出特定于您的操作系统的配置文件位置的一种方法如下：
- en: Run `mysql --help`
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`mysql --help`
- en: In the output, search for `Default options are read from the following files
    in the given order:` and what follows is the possible locations for the MySQL
    configuration file.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输出中，搜索`Default options are read from the following files in the given order:`，后面是MySQL配置文件的可能位置。
- en: We will create the required table and populate some data. But before that, we
    will create the `sample` database as `root` and grant all privileges on it to
    the `springboot` user.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建所需的表并填充一些数据。但在那之前，我们将以`root`用户创建`sample`数据库，并授予`springboot`用户对该数据库的所有权限。
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let''s connect to the database as the `springboot` user, create the required
    table, and populate it with some sample data:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以`springboot`用户连接到数据库，创建所需的表，并用一些示例数据填充它：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now we have our cloud instance of the MySQL DB ready. Let's look at how to manage
    the information of two different connections based on the profile the application
    is running in.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了MySQL DB的云实例。让我们看看如何根据应用程序运行的配置来管理两个不同连接的信息。
- en: The initial sample app required for this recipe can be found at the location, `chp10/4_boot_multi_profile_incomplete`.
    We will convert this app to make it run on different environments.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为此菜谱所需的初始示例应用程序可以在位置`chp10/4_boot_multi_profile_incomplete`找到。我们将转换此应用程序，使其能够在不同的环境中运行。
- en: How to do it...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In the `src/main/resources/application.properties` file, add a new `springboot`
    property, `spring.profiles.active = local`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/resources/application.properties`文件中，添加一个新的`springboot`属性，`spring.profiles.active
    = local`。
- en: Create a new file, `application-local.properties`, at the location, `src/main/resources/`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/resources/`位置创建一个新的文件，`application-local.properties`。
- en: 'Add the following properties to `application-local.properties` and remove them
    from the `application.properties` file:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到`application-local.properties`中，并从`application.properties`文件中删除它们：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Create another file, `application-cloud.properties`, at `src/main/resources/`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/resources/`处创建另一个文件，`application-cloud.properties`。
- en: 'Add the following properties to `application-cloud.properties`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到`application-cloud.properties`中：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The complete code for the complete application can be found at `chp10/4_boot_multi_profile_incomplete`**.** You
    can run the application by using the `mvn spring-boot:run` command. Spring Boot
    reads the `spring.profiles.active` property from the `application.properties`
    file and runs the application in a local profile. Open the URL, `http://localhost:8080/api/persons`,
    in the browser to find the following data:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 完整应用程序的完整代码可以在`chp10/4_boot_multi_profile_incomplete`**.**处找到。您可以通过使用`mvn spring-boot:run`命令来运行应用程序。Spring
    Boot从`application.properties`文件中读取`spring.profiles.active`属性，并在本地配置下运行应用程序。在浏览器中打开URL，`http://localhost:8080/api/persons`，以找到以下数据：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, run the application on the cloud profile by using the `mvn spring-boot:run
    -Dspring.profiles.active=cloud` command. Then open `http://localhost:8080/api/persons`
    in the browser to find the following data:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过使用`mvn spring-boot:run -Dspring.profiles.active=cloud`命令在云配置下运行应用程序。然后，在浏览器中打开`http://localhost:8080/api/persons`以找到以下数据：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can see that there is a different set of data returned by the same API
    and the preceding data was inserted in our MySQL database running on the cloud.
    So, we have been able to successfully run the app in two different profiles: local
    and cloud.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，相同的API返回了不同的数据集，而先前的数据已被插入到我们在云上运行的MySQL数据库中。因此，我们已经成功地在两个不同的配置下运行了应用程序：本地和云。
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'There are multiple ways Spring Boot can read the configuration for the application.
    Some significant ones are listed here in the order of their relevance (the property
    defined in the earlier source overrides the property defined in the later sources):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 可以以多种方式读取应用程序的配置。这里按相关性的顺序列出了一些重要的方式（在较早的源中定义的属性会覆盖在较晚的源中定义的属性）：
- en: From the command line. The properties are specified using the `-D` option, like
    we did while launching the app in the cloud profile, `mvn spring-boot:run -Dspring.profiles.active=cloud`.
    Or, if you are using JAR, then it would be `java -Dspring.profiles.active=cloud
    -jar myappjar.jar`.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行。使用 `-D` 选项指定属性，就像我们在云配置文件中启动应用程序时做的那样，`mvn spring-boot:run -Dspring.profiles.active=cloud`。或者，如果您正在使用
    JAR 文件，那么它将是 `java -Dspring.profiles.active=cloud -jar myappjar.jar`。
- en: From the Java system properties, using `System.getProperties()`.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Java 系统属性，使用 `System.getProperties()`。
- en: OS Environment variables.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统环境变量。
- en: Profile-specific application properties, `application-{profile}.properties`,
    or the `application-{profile}.yml` files, outside of the packaged JAR.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与特定配置文件相关的应用程序属性，`application-{profile}.properties` 或 `application-{profile}.yml`
    文件，位于打包的 JAR 文件之外。
- en: Profile-specific application properties `application-{profile}.properties` or
    `application-{profile}.yml` files, packaged within the JAR.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包在 JAR 中的特定配置文件应用程序属性 `application-{profile}.properties` 或 `application-{profile}.yml`
    文件。
- en: Application properties, `application.properties`, or `application.yml` defined
    outside of the packaged JAR.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义在打包的 JAR 之外的应用程序属性，`application.properties` 或 `application.yml`。
- en: Application properties, `application.properties`, or `application.yml` packaged
    within the JAR.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包在 JAR 中的应用程序属性，`application.properties` 或 `application.yml`。
- en: Configuration classes (that is, annotated with `@Configuration`) serving as
    property sources (annotated with `@PropertySource`).
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为属性源（带有 `@PropertySource` 注解）的配置类（即带有 `@Configuration` 注解的类）。
- en: Spring Boot's default properties.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 的默认属性。
- en: 'In our recipe, we specified all the generic properties such as the following
    in the `application.properties` file, and any profile-specific property were specified
    in the profile-specific application properties file:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配方中，我们在 `application.properties` 文件中指定了所有通用的属性，如下所示，并且任何特定配置文件的属性都在特定配置文件的应用程序属性文件中指定：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: From the preceding list, we can find that the `application.properties` or `application-{profile}.properties`
    file can be defined outside the application JAR. There are default locations where
    Spring Boot will search for the properties file, and one such path is the `config`
    sub directory of the current directory the app is running from.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的列表中，我们可以找到 `application.properties` 或 `application-{profile}.properties`
    文件可以定义在应用程序 JAR 之外。Spring Boot 将在默认位置搜索属性文件，其中一个路径是应用程序运行当前目录的 `config` 子目录。
- en: The complete list of Spring Boot-supported application properties can be found
    at [http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html](http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html).
    In addition to these, we can create our own properties required for our application.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 支持的所有应用程序属性的完整列表可以在 [http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html](http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html)
    找到。除了这些之外，我们还可以创建我们应用程序所需的自己的属性。
- en: The complete code for this can be found at the location, `chp10/4_boot_multi_profile_complete`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码可以在位置 `chp10/4_boot_multi_profile_complete` 找到。
- en: There's more...
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can create a configuration server using Spring Boot, which will act as a
    repository for all the properties for all the apps in all the profiles. The client
    apps can then connect with the configuration server to read the relevant properties
    based on the app name and the app profile.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Spring Boot 创建一个配置服务器，该服务器将作为所有配置文件中所有应用程序的所有属性的存储库。然后，客户端应用程序可以连接到配置服务器，根据应用程序名称和应用程序配置读取相关属性。
- en: In the configuration server, the application properties can be read from the
    filesystem using the classpath or a GitHub repository. The advantage of using
    a GitHub repository is that the property files can be versioned. The property
    files in the configuration server can be updated, and these updates can be pushed
    to the client apps by setting up a message queue to relay the changes downstream.
    Also, another way is to use the `@RefreshScope` beans and then invoke the `/refresh`
    API whenever we need the client apps to pull the configuration changes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置服务器中，可以使用类路径或 GitHub 仓库从文件系统读取应用程序属性。使用 GitHub 仓库的优势在于属性文件可以进行版本控制。配置服务器中的属性文件可以更新，并且可以通过设置消息队列来中继更改，将这些更新推送到客户端应用程序。另一种方法是使用
    `@RefreshScope` 实例，并在需要客户端应用程序拉取配置更改时调用 `/refresh` API。
- en: Deploying RESTful web services to Heroku
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Heroku 上部署 RESTful 网络服务
- en: '**Platform as a Service** (**Paas**) is one of the cloud computing models (the
    other two being **Software as a Service** (**SaaS**) and **Infrastructure as a
    Service** (**IaaS**)) where the cloud computing provider provides managed computing
    platforms, which includes OS, programming language runtime, database, and other
    add ons such as queues, log management, and alerting. They also provide you tools
    to ease the deployment and dashboards to monitor your applications.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**平台即服务**（**PaaS**）是云计算模型之一（其他两个是**软件即服务**（**SaaS**）和**基础设施即服务**（**IaaS**）），其中云计算提供商提供管理的计算平台，包括操作系统、编程语言运行时、数据库以及其他附加功能，如队列、日志管理和警报。他们还提供工具以简化部署，并提供仪表板以监控您的应用程序。'
- en: Heroku is one of the earliest players in the field of PaaS providers. It supports
    the following programming languages: Ruby, Node.js, Java, Python, Clojure, Scala,
    Go, and PHP. Heroku supports multiple data stores, such as MySQL, MongoDB, Redis,
    and Elastic search. It provides integration with logging tools, network utils,
    email services, and monitoring tools.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku 是 PaaS（平台即服务）提供商领域的早期参与者之一。它支持以下编程语言：Ruby、Node.js、Java、Python、Clojure、Scala、Go
    和 PHP。Heroku 支持多种数据存储，如 MySQL、MongoDB、Redis 和 Elastic search。它提供与日志工具、网络工具、电子邮件服务和监控工具的集成。
- en: Heroku provides a command-line tool called heroku-cli ([cli.heroku.com](http://cli.heroku.com)),
    which can be used to create Heroku applications, deploy, monitor, add resources,
    and more. The functionality provided from their web dashboard is supported by
    the CLI as well. It uses Git to store the application's source code. So, when
    you push the application code to Heroku's Git repository, it triggers a build,
    based on the build pack you are using. Then, it either uses the default way to
    spawn the application or `ProcFile` to execute your application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku 提供了一个名为 heroku-cli 的命令行工具（[cli.heroku.com](http://cli.heroku.com)），可用于创建
    Heroku 应用程序、部署、监控、添加资源等。他们提供的网页仪表板功能也由 CLI 支持。它使用 Git 存储应用程序的源代码。因此，当您将应用程序代码推送到
    Heroku 的 Git 仓库时，它将根据您使用的构建包触发构建。然后，它将使用默认方式启动应用程序或使用 `ProcFile` 执行您的应用程序。
- en: In this recipe, we will deploy our Spring Boot-based RESTful web service to
    Heroku. We will continue to use the database we created on another cloud provider
    in the previous recipe, *Creating multiple profiles for Spring Boot*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将部署我们的基于 Spring Boot 的 RESTful 网络服务到 Heroku。我们将继续使用在前一个食谱“为 Spring Boot
    创建多个配置文件”中创建的数据库。
- en: Getting ready
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we proceed with deploying our sample application on Heroku, we need to
    sign up for a Heroku account and install its tools, which will enable us to work
    from the command line. In the subsequent sections, we will guide you through the
    sign up process, creating a sample app via the web UI, and via the Heroku **command-line
    interface** (**CLI**).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始在 Heroku 上部署我们的示例应用程序之前，我们需要注册一个 Heroku 账户并安装其工具，这将使我们能够从命令行工作。在接下来的章节中，我们将指导您完成注册过程，通过网页用户界面创建一个示例应用程序，以及通过
    Heroku **命令行界面**（**CLI**）创建。
- en: Setting up a Heroku account
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Heroku 账户
- en: 'Visit [http://www.heroku.com](http://www.heroku.com) and sign up if you don''t
    have an account. If you have an account, then you can log in. For signing up,
    the URL is [https://signup.heroku.com](https://signup.heroku.com):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有账户，请访问 [http://www.heroku.com](http://www.heroku.com) 并注册。如果您已有账户，则可以登录。注册的
    URL 是 [https://signup.heroku.com](https://signup.heroku.com)：
- en: '![](img/da58d677-a96c-42fb-a3e0-0281b942f753.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/da58d677-a96c-42fb-a3e0-0281b942f753.png)'
- en: 'For login, the URL is [https://id.heroku.com/login](https://id.heroku.com/login):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 登录的 URL 是 [https://id.heroku.com/login](https://id.heroku.com/login)：
- en: '![](img/89fc20f7-51c7-4073-bc36-413f39c821c0.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/89fc20f7-51c7-4073-bc36-413f39c821c0.png)'
- en: 'Once you log in successfully, you will see a dashboard with the list of apps,
    if you have any:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 登录成功后，您将看到一个包含应用程序列表的仪表板，如果您有任何应用程序：
- en: '![](img/2c284855-7193-4bfd-a460-02e6b2f1aa63.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/2c284855-7193-4bfd-a460-02e6b2f1aa63.png)'
- en: Creating a new app from the UI
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从UI创建新应用
- en: 'Click on New | Create new app, and fill in the details, as shown in the following
    screenshot, and click on Create App:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“新建 | 创建新应用”，并填写以下截图中的详细信息，然后点击“创建应用”：
- en: '![](img/024a1459-63ea-47ea-9d2e-ecf78d12fb5b.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/024a1459-63ea-47ea-9d2e-ecf78d12fb5b.png)'
- en: Creating a new app from the CLI
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从CLI创建新应用
- en: 'Perform the following steps to create a new app from the CLI:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤从CLI创建新应用：
- en: Install the Heroku CLI from [https://cli.heroku.com](https://cli.heroku.com).
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://cli.heroku.com](https://cli.heroku.com)安装Heroku CLI。
- en: Once installed, Heroku should be in your system's `PATH` variable.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，Heroku应该位于您的系统`PATH`变量中。
- en: 'Open a command prompt and run `heroku create`. You will see output similar
    to the following:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符并运行`heroku create`。您将看到类似于以下输出的内容：
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The app name is generated dynamically and a remote Git repository is created.
    You can specify the app name and region (as done via the UI) by running the command:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序名称是动态生成的，并创建了一个远程Git仓库。您可以通过运行命令指定应用程序名称和区域（如通过UI执行）：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The deployment to Heroku is done via `git push` to the remote Git repository
    created on Heroku. We will see this in the next section.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 将部署到Heroku是通过`git push`到在Heroku上创建的远程Git仓库完成的。我们将在下一节中看到这一点。
- en: We have the source code for the app at `chp10/5_boot_on_heroku`. So, copy this
    application and go ahead and deploy on Heroku.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`chp10/5_boot_on_heroku`有应用程序的源代码。因此，复制此应用程序并继续在Heroku上部署。
- en: You have to log in to the Heroku account before running any of the commands
    in Heroku's cli. You can log in by running the command, `heroku login`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行Heroku cli中的任何命令之前，您必须登录到Heroku账户。您可以通过运行命令`heroku login`来登录。
- en: How to do it...
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Run the following command to create a Heroku application:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令创建Heroku应用程序：
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Initialize the Git repository in the project folder:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件夹中初始化Git仓库：
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add the Heroku Git repository as a remote to your local Git repository:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Heroku Git仓库作为远程仓库添加到本地Git仓库：
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Push the source code, that is, the master branch, to the Heroku Git repository:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将源代码，即master分支，推送到Heroku Git仓库：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When the code is pushed to the Heroku Git repository, it triggers a build.
    As we are using Maven, it runs the following command:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当代码推送到Heroku Git仓库时，会触发构建。由于我们使用Maven，它会运行以下命令：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Once the code has completed the build and deployed, you can open the application
    by using the `heroku open` command. This will open the application in a browser.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码完成构建和部署后，您可以使用`heroku open`命令打开应用程序。这将使用浏览器打开应用程序。
- en: You can monitor the logs of the application using the `heroku logs --tail` command.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`heroku logs --tail`命令监控应用程序的日志。
- en: 'Once the app has been successfully deployed, and after you run the `heroku
    open` command, you should see the URL being loaded by the browser:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序成功部署后，运行`heroku open`命令后，您应该在浏览器中看到正在加载的URL：
- en: '![](img/98ed28ee-931f-402f-ac8c-667b5258c5ea.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/98ed28ee-931f-402f-ac8c-667b5258c5ea.png)'
- en: 'Clicking on the Persons link will display the following information:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“人员”链接将显示以下信息：
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The interesting thing here is that we have our app running on Heroku, which
    is connecting to a MySQL database on a DigitalOcean server. We can even provision
    a database along with the Heroku app and connect to that database. Check out how
    to do this in the *There's more...* section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是，我们的应用程序正在Heroku上运行，它连接到DigitalOcean服务器上的MySQL数据库。我们甚至可以与Heroku应用程序一起配置数据库并连接到该数据库。在“更多...”部分查看如何操作。
- en: There's more...
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'Add a new DB add-on to the application:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向应用程序添加新的数据库附加组件：
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, `addons:create` takes the add-on name and the service plan name, both
    separated by a colon (`:`). You can know more about the add-on details and plans
    at [https://elements.heroku.com/addons/jawsdb-maria](https://elements.heroku.com/addons/jawsdb-maria).
    Also, the Heroku CLI command to add the add-on to your application is given towards
    the end of the add-on details page for all add-ons.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`addons:create`接受附加组件名称和服务计划名称，两者之间用冒号（`:`）分隔。您可以在[https://elements.heroku.com/addons/jawsdb-maria](https://elements.heroku.com/addons/jawsdb-maria)了解更多关于附加组件和计划的详细信息。此外，所有附加组件详情页面末尾都提供了将附加组件添加到应用程序的Heroku
    CLI命令。
- en: 'Open the DB dashboard to view the connection details, such as URL, username,
    password, and the database name:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开数据库仪表板以查看连接详情，例如URL、用户名、密码和数据库名称：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `jawsdb` dashboard looks something similar to as shown below:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`jawsdb`仪表板看起来与以下所示类似：'
- en: '![](img/cc9b5188-5489-4840-926b-344dbd518a8d.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cc9b5188-5489-4840-926b-344dbd518a8d.png)'
- en: 'You can even get the MySQL connection string from the `JAWSDB_URL` configuration
    property. You can list the configuration for your app by using the following command:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您甚至可以从`JAWSDB_URL`配置属性中获取MySQL连接字符串。您可以使用以下命令列出您应用的配置：
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Copy the connection details and create a new connection in MySQL Workbench
    and connect to this connection. The database name is also created by the add-on.
    Run the following SQL statements after connecting to the database:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制连接详情，在MySQL Workbench中创建一个新的连接并连接到此连接。数据库名称也是由附加组件创建的。连接到数据库后，运行以下SQL语句：
- en: '[PRE49]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a new properties file for the Heroku profile, `application-heroku.properties`
    at  `src/main/resources`, with the following properties:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/resources`下为Heroku配置创建一个新的属性文件，名为`application-heroku.properties`，包含以下属性：
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can find the connection related details from the add-on dashboard.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从附加仪表板中找到连接相关详情。
- en: Update the `src/main/resources/application.properties` file to replace the value
    of the `spring.profiles.active` property to `heroku`
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`src/main/resources/application.properties`文件，将`spring.profiles.active`属性的值替换为`heroku`
- en: 'Commit and push the changes to Heroku remote:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更改提交并推送到Heroku远程仓库：
- en: '[PRE51]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Once the deployment succeeds, run the `heroku open` command. Then, once the
    page loads in the browser, click on the Persons link. This time, you will see
    a different set of data, the one which we entered in our Heroku add-on:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署成功后，运行`heroku open`命令。然后，一旦页面在浏览器中加载，点击“人员”链接。这次，您将看到一组不同的数据，这是我们输入到我们的Heroku附加组件中的：
- en: '[PRE52]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: With this, we have integrated with a database created on Heroku.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经与在Heroku上创建的数据库集成了。
- en: Containerizing the RESTful web service using Docker
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker容器化RESTful Web服务
- en: We have advanced a lot from the time where an app would be installed across
    servers to each server being virtualized and the app then being installed on these
    smaller virtual machines. Scalability issues for the applications were resolved
    by adding more virtual machines, with the app running to the load balancer.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从应用安装在服务器上的时代，到每个服务器都被虚拟化，然后应用被安装在这些较小的虚拟机上，我们已经取得了很大的进步。通过添加更多的虚拟机，并让应用运行到负载均衡器上，解决了应用的扩展性问题。
- en: In virtualization, a large server is divided into multiple virtual machines
    by allocating the computing power, memory, and storage among the multiple virtual
    machines. This way, each of the virtual machines is in itself capable of all those
    things that a server was, albeit on a smaller scale. This way, virtualization
    has helped us a lot in judiciously making use of the server's computing, memory,
    and storage resources.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟化中，通过在多个虚拟机之间分配计算能力、内存和存储，一个大服务器被分割成多个虚拟机。这样，每个虚拟机本身就能够具备服务器所具有的所有功能，尽管规模较小。这种方式，虚拟化大大帮助我们合理利用服务器的计算、内存和存储资源。
- en: However, virtualization needs some setup, that is, you need to create the virtual
    machine, install the required dependencies, and then run the app. Moreover, you
    may not be 100% sure if the app would run successfully. The reason for failure
    may be due to the incompatible OS versions or even due to some configuration missed
    while setting up or some missing dependency. This setup also leads to some difficulty
    in horizontal scaling because there is some time spent in the provisioning of
    the virtual machine and then deploying the app.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虚拟化需要一些设置，也就是说，您需要创建虚拟机，安装所需的依赖项，然后运行应用。此外，您可能无法100%确定应用是否能够成功运行。失败的原因可能是由于不兼容的操作系统版本，甚至可能是由于在设置过程中遗漏了一些配置或缺失的依赖项。这种设置还导致了一些水平扩展的困难，因为虚拟机的配置和应用的部署都需要花费一些时间。
- en: Using tools such as Puppet and Chef does help in provisioning, but then the
    setting up of the app can often result in issues that might be due to a missing
    or wrong configuration. This led to the introduction of another concept called
    containerization.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Puppet和Chef等工具确实有助于配置，但设置应用时往往会遇到一些问题，这些问题可能是由于缺少或错误的配置引起的。这导致了另一个概念的出现，即容器化。
- en: 'In the world of virtualization, we have the host OS and then a virtualization
    software, that is, the hypervisor. We then end up creating multiple machines,
    where each machine has its own OS on which apps are deployed. However, in containerization,
    we don''t divide the resources of the server. Instead, we have the server with
    its host OS, and above that, we have a containerization layer which is a software
    abstraction layer. We package apps as containers, where a container is packaged
    with just enough OS functions required to run the app, the software dependencies
    for the app, and then the app itself. The following image taken from [https://docs.docker.com/get-started/#container-diagram](https://docs.docker.com/get-started/#containers-vs-virtual-machines) best
    depicts this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟化的世界中，我们有宿主操作系统和虚拟化软件，即虚拟机管理程序。然后我们最终创建了多个机器，每个机器都有自己的操作系统，应用程序就在这些操作系统上运行。然而，在容器化中，我们不分割服务器的资源。相反，我们有一个带有宿主操作系统的服务器，在其之上，我们有一个容器化层，这是一个软件抽象层。我们将应用程序打包成容器，其中容器只包含运行应用程序所需的足够操作系统功能、应用程序的软件依赖以及应用程序本身。以下图像来自
    [https://docs.docker.com/get-started/#container-diagram](https://docs.docker.com/get-started/#containers-vs-virtual-machines)，最能描绘这一点：
- en: '![](img/c0758437-eabe-43d7-a5fd-51e22c3b6d35.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0758437-eabe-43d7-a5fd-51e22c3b6d35.png)'
- en: 'The preceding image illustrates a typical architecture of virtualization systems.
    The following image illustrates a typical architecture of containerization systems:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像展示了虚拟化系统的典型架构。下面的图像展示了容器化系统的典型架构：
- en: '![](img/838f967c-db09-46d6-9846-cc003b135e3c.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/838f967c-db09-46d6-9846-cc003b135e3c.png)'
- en: The biggest advantage of containerization is that you bundle all the dependencies
    of the app into a container image. This image is then run on the containerization
    platform, leading to the creation of a container. We can have multiple containers
    running simultaneously on the server. If there is a need to add more instances,
    we can just deploy the image, and this deployment can be automated to support
    high scalability in an easy way.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化的最大优势在于，你可以将应用程序的所有依赖项打包到一个容器镜像中。然后，这个镜像在容器化平台上运行，从而创建一个容器。我们可以在服务器上同时运行多个容器。如果需要添加更多实例，我们只需部署镜像，并且这种部署可以自动化，以支持简单易行的高可扩展性。
- en: Docker is the world's most popular software containerization platform. In this
    recipe, we will package our sample app found at the location into a Docker image
    and run the Docker image to launch our application.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是全球最受欢迎的软件容器化平台。在本教程中，我们将把位于指定位置的示例应用程序打包成 Docker 镜像，并运行 Docker 镜像来启动我们的应用程序。
- en: Getting ready
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will use a Linux server running Ubuntu 16.04.2 x64.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本教程，我们将使用运行 Ubuntu 16.04.2 x64 的 Linux 服务器。
- en: 'Download the latest `.deb` file from [https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/](https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/).
    For other Linux distros, you can find the packages at [https://download.docker.com/linux/](https://download.docker.com/linux/):'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/](https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/)
    下载最新的 `.deb` 文件。对于其他 Linux 发行版，你可以在 [https://download.docker.com/linux/](https://download.docker.com/linux/)
    找到相应的软件包：
- en: '[PRE53]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Install the Docker package using the `dpkg` package manager:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dpkg` 软件包管理器安装 Docker 软件包：
- en: '[PRE54]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The name of the package will vary based on the version you have downloaded.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包的名称将根据你下载的版本而有所不同。
- en: 'After successful installation, the Docker service starts running. You can verify
    this by using the `service` command:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装成功后，Docker 服务开始运行。你可以使用 `service` 命令来验证这一点：
- en: '[PRE55]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The application to be dockerized is available at the location, `chp10/6_boot_with_docker`,
    of the source code downloaded for this book.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要容器化的应用程序位于源代码下载的 `chp10/6_boot_with_docker` 位置。
- en: How to do it...
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create `Dockerfile` at the root of the application with the following content:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的根目录下创建 `Dockerfile`，内容如下：
- en: '[PRE56]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Run the following command to build a Docker image using `Dockerfile` created
    in the preceding step:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令，使用前面步骤中创建的 `Dockerfile` 构建Docker镜像：
- en: '[PRE57]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can view the images installed by using the command:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用命令查看已安装的镜像：
- en: '[PRE58]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You will see that there are OpenJDK and Ubuntu images as well. These were downloaded
    to build the image for our app, which is listed first.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到还有 OpenJDK 和 Ubuntu 镜像。这些是为了构建我们的应用程序镜像而下载的，并且列在第一位。
- en: 'Now, we need to run the image to create a container that contains our running
    application:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要运行镜像以创建一个包含运行应用程序的容器的容器：
- en: '[PRE59]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The large string printed after the `run` command is the identifier of the container.
    You can use the initial few characters to uniquely identify the container. Alternatively,
    you can use the container name, `restapp`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `run` 命令之后打印出的长字符串是容器的标识符。您可以使用前几个字符来唯一标识容器。或者，您可以使用容器名称，`restapp`。
- en: 'The app will have already started. You can view the logs by running the following
    command:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序已经启动。您可以通过运行以下命令来查看日志：
- en: '[PRE60]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You can view the Docker containers created by using the following command:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下命令查看创建的 Docker 容器：
- en: '[PRE61]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output for the above command looks similar to as shown below:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出类似于以下所示：
- en: '![](img/630227a1-3af6-4221-9225-daca31800a1d.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/630227a1-3af6-4221-9225-daca31800a1d.png)'
- en: 'You can manage the container by using the following command:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下命令管理容器：
- en: '[PRE62]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Once the app is running, open `http://<hostname>:8090/api/persons`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序运行，打开 `http://<hostname>:8090/api/persons`。
- en: How it works...
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You define the container structure and its contents by defining `Dockerfile`.
    `Dockerfile` follows a structure, where each line is of the form, `INSTRUCTION
    arguments`. There is a predefined set of instructions, namely `FROM`, `RUN`, `CMD`,
    `LABEL`, `ENV`, `ADD`, `COPY`, and others. A complete list can be found at [https://docs.docker.com/engine/reference/builder/#from](https://docs.docker.com/engine/reference/builder/#from).
    Let''s look at our defined `Dockerfile`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过定义 `Dockerfile` 来定义容器结构和其内容。`Dockerfile` 遵循一种结构，其中每一行都是 `INSTRUCTION arguments`
    的形式。存在一组预定义的指令，包括 `FROM`、`RUN`、`CMD`、`LABEL`、`ENV`、`ADD`、`COPY` 以及其他指令。完整的列表可以在
    [https://docs.docker.com/engine/reference/builder/#from](https://docs.docker.com/engine/reference/builder/#from)
    找到。让我们看看我们定义的 `Dockerfile`：
- en: '[PRE63]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The first two lines using the `FROM` instruction specified the base image for
    our Docker image. We use the Ubuntu OS image as the base image and then combine
    it with the OpenJDK 9 image. The `VOLUME` instruction is used to specify the mount
    point for the image. This is usually a path in the host OS.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `FROM` 指令的前两行指定了我们的 Docker 镜像的基础镜像。我们使用 Ubuntu 操作系统镜像作为基础镜像，然后与 OpenJDK 9
    镜像结合。`VOLUME` 指令用于指定镜像的挂载点。这通常是在主机操作系统中的一个路径。
- en: The `ADD` instruction is used to copy the file from the source to the destination
    directory under the working directory. The `ENV` instruction is used for defining
    the environment variables.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD` 指令用于将文件从源目录复制到工作目录下的目标目录。`ENV` 指令用于定义环境变量。'
- en: The `ENTRYPOINT` instruction is used to configure the container to run as an
    executable. For this instruction, we pass an array of arguments, which we would
    otherwise have executed directly from the command line. In our scenario, we are
    using the bash shell to run `java -$JAVA_OPTS -jar <jar name>`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT` 指令用于配置容器以可执行方式运行。对于此指令，我们传递一个参数数组，否则我们将直接从命令行执行这些参数。在我们的场景中，我们使用
    bash shell 来运行 `java -$JAVA_OPTS -jar <jar name>`。'
- en: Once we have defined `Dockerfile`, we instruct the Docker tool to build an image
    using `Dockerfile`. We also provide a name for the image using the `--tag` option.
    When building our app image, it will download the required based images, which,
    in our case, are Ubuntu and OpenJDK images. So, if you list the Docker images,
    then you will see the base images along with our app image.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了 `Dockerfile`，我们就指导 Docker 工具使用 `Dockerfile` 构建镜像。我们还使用 `--tag` 选项为镜像提供名称。在构建我们的应用程序镜像时，它将下载所需的基于镜像，在我们的例子中是
    Ubuntu 和 OpenJDK 镜像。因此，如果您列出 Docker 镜像，您将看到基础镜像以及我们的应用程序镜像。
- en: This Docker image is a reusable entity. If we need more instances of the app,
    we spawn a new container using the `docker run` command. When we run the Docker
    image, we have multiple options, where one of them is a `-p` option, which maps
    the ports from within the container to the host OS. In our case, we map the `8080`
    port of our Spring Boot app to `8090` of the host OS.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Docker 镜像是一个可重用的实体。如果我们需要更多应用程序的实例，我们可以使用 `docker run` 命令创建一个新的容器。当我们运行 Docker
    镜像时，我们有多个选项，其中之一是 `-p` 选项，它将容器内的端口映射到主机操作系统。在我们的例子中，我们将 Spring Boot 应用程序的 `8080`
    端口映射到主机操作系统的 `8090`。
- en: Now, to check the status of our running app, we can check the logs using `docker
    logs restapp`. Apart from this, the `docker` tool supports multiple commands.
    It's highly recommended to run `docker help` and explore the commands supported.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了检查运行中的应用程序的状态，我们可以使用 `docker logs restapp` 命令来查看日志。除了这个之外，`docker` 工具支持多个命令。强烈建议运行
    `docker help` 并探索支持的命令。
- en: Docker, the company behind Docker has created a set of base images, which can
    be used to create containers. For example, there are images for MySQL DB, Couchbase,
    Ubuntu, and other operating systems. You can explore the packages at [https://store.docker.com/](https://store.docker.com/).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Docker公司，作为Docker背后的公司，创建了一系列基础镜像，这些镜像可以用来创建容器。例如，有MySQL数据库、Couchbase、Ubuntu以及其他操作系统的镜像。您可以在[https://store.docker.com/](https://store.docker.com/)上探索这些包。
