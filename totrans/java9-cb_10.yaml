- en: RESTful Web Services Using Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple Spring Boot application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a RESTful web service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating multiple profiles for Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying RESTful web services to Heroku
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerizing the RESTful web service using Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent years, the drive for microservice-based architecture has gained wide
    adoption, thanks to the simplicity and ease of maintenance it provides when done
    the right way. A lot of companies, such as Netflix, Amazon, and the like, have
    moved from monolithic systems to more focused and lighter systems, all talking
    with each other via RESTful web services. The advent of RESTful web services and
    its straightforward approach to creating web services using the known HTTP protocol
    has made it easier for communication between applications than the older SOAP-based
    web services.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at the **Spring Boot** framework, which provides
    a convenient way to create production-ready microservices using Spring libraries.
    Using Spring Boot, we will develop a simple RESTful web service and deploy the
    same on the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple Spring Boot application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot helps in creating production-ready Spring-based applications easily.
    It provides support for working with almost all Spring libraries, without any
    need for configuring them explicitly. There are autoconfiguration classes provided
    for easy integration with most commonly used libraries, databases, message queues,
    and the likes.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at creating a simple Spring Boot application with
    a controller that prints a message when opened in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Boot supports Maven and Gradle as the build tools and we will be using
    Maven in our recipes. The URL, [http://start.spring.io/](http://start.spring.io/),
    provides a convenient way to create an empty project with the required dependencies.
    We will use it to download an empty project. Follow these steps to create and
    download an empty Spring Boot-based project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to [http://start.spring.io/](http://start.spring.io/) to see something
    similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e495acd3-651c-446e-af0c-a1ef90f6010b.png)'
  prefs: []
  type: TYPE_IMG
- en: You can select the dependency management and build tool, selecting the appropriate
    option in the dropdown after the text, **Generate a**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spring Boot supports Java, Kotlin, and Groovy. You can choose the language by
    changing the dropdown after the text, **with**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Spring Boot version by choosing its value from the dropdown after
    the text, and Spring Boot. For this recipe, we'll use the latest milestone edition
    of Spring Boot 2 I.E 2.0.0 M2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the left-hand side, under Project Metadata, we have to provide Maven-related
    information, that is, the group ID and artifact ID. We'll use Group as `com.packt`
    and Artifact as `boot_demo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the right-hand side, under Dependencies, you can search for the dependencies
    you want to add. For this recipe, we need web and Thymeleaf dependencies. This
    means that we want to create a web application which uses Thymeleaf UI templates
    and would want all the dependencies, such as Spring MVC, Embedded Tomcat, and
    others, to be part of the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click on the Generate Project button to download the empty project. You
    can load this empty project in any IDE of your choice, just like any other Maven
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, you will have your empty project loaded into an IDE of your choice
    and ready to explore further. In this recipe, we will make use of the Thymeleaf
    template engine to define our web pages and create a simple controller to render
    the web page.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code for this recipe can be found at the location, `chp10/1_boot_demo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have followed the group ID and artifact ID naming as mentioned in the
    *Getting ready* section, you will have a package structure, `com.packt.boot_demo`,
    and a `BootDemoApplication.java` main class already created for you. There will
    be an equivalent package structure and a `BootDemoApplicationTests.java` main
    class under the `tests` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new class, `SimpleViewController`, under the `com.packt.boot_demo`
    package, with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a web page, `message.html`, under the location, `src/main/resources/templates`,
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From the command prompt, navigate to the project root folder and issue the command, `mvn
    spring-boot:run`; you'll see the application being launched. Once it completes
    the initialization and starts, it would be running on the default port, `8080`.
    Navigate to `http://localhost:8080/message` to see the message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are using Spring Boot's Maven plugin, which provides us with convenient tools
    to launch the application during development. But for production, we will create
    a fat JAR, that is, a JAR comprising all the dependencies, and deploy it as a
    Linux or Windows service. We can even run the fat JAR using the `java -jar` command.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will not go into the working of Spring Boot or the other Spring libraries.
    But to state in brief, Spring Boot creates an embedded Tomcat running on the default
    port, that is, `8080`. It then registers all the controllers, components, and
    services that are available in the packages and sub packages of the class with
    the annotation, `@SpringBootApplication`.
  prefs: []
  type: TYPE_NORMAL
- en: In our recipe, the `BootDemoApplication` class in the `com.packt.boot_demo`
    package is annotated with `@SpringBootApplication`. So, all the classes that are
    annotated with `@Controller`, `@Service`, `@Configuration`, `@Component`, and
    the likes of it get registered with the Spring framework as beans and are managed
    by it. Now, these can be injected into the code by using the `@Autowired` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways we can create a web controller:'
  prefs: []
  type: TYPE_NORMAL
- en: Annotating with `@Controller`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Annotating with `@RestController`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the first approach, we create a controller that can serve both raw data
    and HTML data (generated by template engines such as Thymeleaf, Freemarker, JSP,
    and others). In the second approach, the controller supports endpoints that can
    only serve raw data in the form of JSON or XML. In our recipe, we used the former
    approach, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can annotate the class with `@RequestMapping` with, say, `@RequestMapping("/api")`.
    In this case, any HTTP endpoints exposed in the controller are prepended by `/api`.
    There is a specialized annotation mapping for HTTP `GET`, `POST`, `DELETE`, and
    `PUT` methods, namely `@GetMapping`, `@PostMapping`, `@DeleteMapping`, and `@PutMapping`,
    respectively. We can also rewrite our controller class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can modify the port by providing `server.port = 9090` in the `application.properties`
    file. This file can be found in the location, `src/main/resources/application.properties`.
    There is a whole set of properties ([http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html](http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html))
    that we can use to customize and connect with different components.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at how to integrate with a database to create,
    read, modify, and delete the data. For this, we will set up a MySQL database with
    the required table. Subsequently, we will update the data in a table from our
    Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using Windows as the platform of development for this recipe. You
    can perform a similar action on Linux as well, but you would first have to set
    up your MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start integrating our application with the database, we need to set
    up the database locally on our development machines. In the subsequent sections,
    we will download and install MySQL tools and then create a sample table with some
    data, which we will use with our application.
  prefs: []
  type: TYPE_NORMAL
- en: Installing MySQL tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, download the MySQL installer from [https://dev.mysql.com/downloads/windows/installer/5.7.html](https://dev.mysql.com/downloads/windows/installer/5.7.html).
    This MySQL bundle is for Windows only. Follow the onscreen instructions to successfully
    install MySQL along with other tools such as MySQL Workbench. To confirm that
    the MySQL daemon (`mysqld`) is running, open the task manager and you should be
    able to see a process similar to the one shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/808e253f-61e7-4001-8276-dd89038c5ea2.png)'
  prefs: []
  type: TYPE_IMG
- en: You should remember the password you set for the root user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the MySQL workbench; on starting up, you should be able to see something
    similar to the following image, among other things provided by the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1209d7ad-07ef-481f-9787-121d25f3adcf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you don''t find a connection like the preceding image, you can add one using
    the (+) sign. On clicking on (+), you will see the following dialog. Fill it up
    and click on Test Connection to get a success message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f17690ad-740e-40a6-9821-292b79e0144f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A successful Test Connection will result in the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ad5d683-ac9c-48a7-9742-5f6b73ef038a.png)'
  prefs: []
  type: TYPE_IMG
- en: Double-click on the connection to connect to the database, and you should see
    a list of DBs on the left-hand side, an empty area on the right-hand side, and
    menu and toolbars on the top. From the File menu, click on New Query Tab or, alternatively,
    press *Ctrl* + *T* to get a new query window. Here, we will write our queries
    to create a database and create a table within that database.
  prefs: []
  type: TYPE_NORMAL
- en: The bundled installer downloaded from [https://dev.mysql.com/downloads/windows/installer/5.7.html](https://dev.mysql.com/downloads/windows/installer/5.7.html)
    is for Windows only. Linux users have to download the MySQL Server and MySQL Workbench
    (GUI for interacting with DB) separately.
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL server can be downloaded from [https://dev.mysql.com/downloads/mysql/](https://dev.mysql.com/downloads/mysql/).
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL Workbench can be downloaded from [https://dev.mysql.com/downloads/workbench/](https://dev.mysql.com/downloads/workbench/).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sample database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following SQL statement to create a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Creating a person table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following SQL statements to use the newly created database and create
    a simple person table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Populating sample data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and insert some sample data in the table we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our database ready, we will go ahead and download the empty
    Spring Boot project from [http://start.spring.io/](http://start.spring.io/) with
    the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce36c8dc-a4b2-4bb7-b329-59e87c0807ac.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a model class, `com.packt.boot_db_demo.Person`, for representing a person.
    We will make use of Lombok annotations to generate the getters and setters for
    us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create `com.packt.boot_db_demo.PersonMapper` to map the data from the
    database into our model class, `Person`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a method to get all the rows from the table. Note that the next
    few methods will be written inside the `PersonMapper` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Another method to get the details of a single person identified by ID is as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The method to create a new row in the table is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The method to update an existing row in the table, identified by the ID is
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the method to delete a row from the table, identified by the ID is
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a `com.packt.boot_db_demo.PersonController` class, which we will
    use to write our web endpoints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an endpoint to list all the entries in the `person` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an endpoint to add a new row in the `person` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an endpoint to add a new row or edit an existing row in the `person`
    table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an endpoint to delete a row from the `person` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to update the `src/main/resources/application.properties`
    file to provide the configuration related to our data source, that is, our MySQL
    database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can run the application from the command line using `mvn spring-boot:run`.
    This application starts up on the default port, that is, `8080`. Navigate to `http://localhost:8080/persons`
    in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code for this recipe can be found at the location, `chp10/2_boot_db_demo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On visiting `http://localhost:8080/persons`, this is what you will find:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d1e94e0-7e9a-44a9-ba09-f1865e9c311f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On clicking on **New Person**, you''ll get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a17f99f6-e99f-44bf-9782-cb5ced34c31f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On clicking on **Edit**, you''ll get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5c693af-c327-4da1-93ba-28a03bc5cf08.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firstly, `com.packt.boot_db_demo.PersonMapper` annotated with `org.apache.ibatis.annotations.Mapper`
    knows how to execute the query provided within the `@Select`, `@Update`, or `@Delete`
    annotations and to return relevant results. This is all managed by the MyBatis
    and Spring Data libraries.
  prefs: []
  type: TYPE_NORMAL
- en: You must be wondering how the connection to database was achieved. One of the
    Spring Boot autoconfiguration classes, `DataSourceAutoConfiguration`, does the
    work of setting up by making use of the `spring.datasource.*` properties defined
    in your `application.properties` file to give us an instance of `javax.sql.DataSource`.
    This `javax.sql.DataSource` object is then used by the MyBatis library to provide
    you with an instance of `SqlSessionTemplate`, which is what is used by our `PersonMapper`
    under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we make use of `com.packt.boot_db_demo.PersonMapper` by injecting it into
    the `com.packt.boot_db_demo.PersonController` class by using `@AutoWired`. The
    `@AutoWired` annotation looks for any Spring managed beans, which are either instances
    of the exact type or its implementation. Take a look at the *Creating a simple
    Spring Boot application* recipe in this chapter to understand the `@Controller`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: With very little configuration, we have been able to quickly set up simple CRUD
    operations. This is the flexibility and agility that Spring Boot provides to developers!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a RESTful web service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous recipe, we interacted with data using web forms. In this recipe,
    we will see how to interact with data using RESTful web services. These web services
    are a means to interact with other applications using the known HTTP protocol
    and its methods, namely GET, POST, PUT, and others. The data can be exchanged
    in the form of XML, JSON, or even plain text. We will be using JSON in our recipe.
  prefs: []
  type: TYPE_NORMAL
- en: So, we will create RESTful APIs to support retrieving data, creating new data,
    editing data, and deleting data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, download the starter project from [http://start.spring.io/](http://start.spring.io/) by
    selecting the dependencies as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65375392-107e-43d6-89f2-7bb3c66a35f2.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will copy the `Person` class from the previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We will do the `PersonMapper` part in a different way. We will write all our
    SQL queries in a mapper XML file and then refer to them from the `PersonMapper`
    interface. We will place the mapper XML under the `src/main/resources/mappers`
    folder. We'll set the value of the `mybatis.mapper-locations` property to `classpath*:mappers/*.xml`.
    This way, the `PersonMapper` interface can discover the SQL queries corresponding
    to its methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, let''s create the `com.packt.boot_rest_demo.PersonMapper` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the SQL in `PersonMapper.xml`. One thing to make sure of
    is that the `namespace` attribute of the `<mapper>` tag should be the same as
    the fully qualified name of the `PersonMapper` mapper interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define the application properties in the `src/main/resources/application.properties`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an empty controller for our REST APIs. This controller will be marked
    with the `@RestController` annotation because all the APIs in it are going to
    deal solely with data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add an API to list all the rows in the `person` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add an API to get the details of a single person:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add an API to add new data to the table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add an API to edit the data in the table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add an API to delete the data in the table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can find the complete code at the location, `chp10/3_boot_rest_demo`. You
    can launch the application by using `mvn spring-boot:run` from the project folder.
    Once the application has started, navigate to `http://localhost:8080/api/persons`
    to view all the data in the person table.
  prefs: []
  type: TYPE_NORMAL
- en: To test the other APIs, we will make use of the Postman REST client app for
    Google Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what adding a new person looks like. Look at the request body, that
    is, the person detail specified in JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50ab051d-1b1b-441e-8166-209c9df8424e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is how we edit a person''s detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b053a527-ed07-45e2-b949-d8da14f6eab6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is what deleting a person looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5328fb47-7242-4ce9-b772-b04d52732a48.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's look at how the `PersonMapper` interface discovers the SQL statements
    to execute. If you look at `src/main/resources/mappers/PersonMapper.xml`, you
    will find that the `<mapper>` `namespace` attribute is `org.packt.boot_rest_demo.PersonMapper`.
    This is a requirement that the value of `namespace` attribute should be the fully
    qualified name of the mapper interface, which, in our case, is `org.packt.boot_rest_demo.PersonMapper`.
  prefs: []
  type: TYPE_NORMAL
- en: Next the `id` attributes of the individual SQL statements defined within `<select>`,
    `<insert>`, `<update>`, and `<delete>` should match the name of the method in
    the mapper interface. For example, the `getPersons()` method in the `PersonMapper`
    interface looks for an SQL statement with `id="getPersons"`.
  prefs: []
  type: TYPE_NORMAL
- en: Now the MyBatis library discovers the location of this mapper XML by reading
    the value of the `mybatis.mapper-locations` property.
  prefs: []
  type: TYPE_NORMAL
- en: Coming to the controller, we have introduced a new annotation, `@RestController`.
    This special annotation indicates, in addition to it being a web controller, that
    all the methods defined in the class return a response that is sent via the HTTP
    response body; so do all the REST APIs. They just work with the data.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you can launch your Spring Boot application either by using the Maven
    Spring-Boot plugin, `mvn spring-boot:run` or by executing the JAR created by the
    Maven package, `java -jar my_jar_name.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating multiple profiles for Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, web applications are deployed on different environments--first, they
    are run locally on a developer's machine, then deployed on test servers, and finally
    deployed on production servers. We would have the application interacting with
    components located in different places for each environment. The best approach
    for this is to maintain different profiles for each environment. One way to do
    this is by creating different versions of the `application.properties` file, that
    is, different versions of the file that stores the application-level properties.
    These property files in Spring Boot can also be YML files, such as `application.yml`.
    Even if you create different versions, you need a mechanism to tell your applications
    to pick the relevant version of the file, based on the environment it has been
    deployed to.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot provides amazing support for such a feature. It allows you to have
    multiple configuration files, each representing a specific profile, and then,
    you can launch your application in different profiles, depending on the environment
    it is being deployed to. Let's see this in action, and then we will explain how
    it works.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, there are two options to host another instance of your MySQL
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a cloud provider such as AWS and use its Amazon **Relational Database Service**
    (**RDS**) ([https://aws.amazon.com/rds/](https://aws.amazon.com/rds/)). They have
    a certain free usage limit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a cloud provider such as DigitalOcean ([https://www.digitalocean.com/](https://www.digitalocean.com/))
    to purchase a droplet (that is, a server) for as little as $5 per month. Then
    install the MySQL server on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use VirtualBox to install Linux on your machine, assuming we are using Windows,
    or vice versa if you are using Linux. Then install the MySQL server on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The options are much more right from hosted database services to servers, which
    give you complete root access to install the MySQL server. For this recipe, we
    did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We purchased a basic droplet from DigitalOcean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We installed MySQL using `sudo apt-get install mysql-server-5.7` with a password
    for the root user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We created another user, `springboot`, so that we can use this user to connect
    from our RESTful web service application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We modified the MySQL configuration file so that the MySQL allows remote connections.
    This can be done by editing the `bind-address` property in the `/etc/mysql/mysql.conf.d/mysqld.cnf`
    file to the IP of the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From MySQL workbench, we added the new MySQL connection by using `IP = <Digital
    Ocean droplet IP>`, `username = springboot`, and `password = springboot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The  location for the MySQL configuration file in Ubuntu OS is `/etc/mysql/mysql.conf.d/mysqld.cnf`.
    One way to find out the location of a configuration file specific to your OS is
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `mysql --help`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the output, search for `Default options are read from the following files
    in the given order:` and what follows is the possible locations for the MySQL
    configuration file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will create the required table and populate some data. But before that, we
    will create the `sample` database as `root` and grant all privileges on it to
    the `springboot` user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s connect to the database as the `springboot` user, create the required
    table, and populate it with some sample data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now we have our cloud instance of the MySQL DB ready. Let's look at how to manage
    the information of two different connections based on the profile the application
    is running in.
  prefs: []
  type: TYPE_NORMAL
- en: The initial sample app required for this recipe can be found at the location, `chp10/4_boot_multi_profile_incomplete`.
    We will convert this app to make it run on different environments.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `src/main/resources/application.properties` file, add a new `springboot`
    property, `spring.profiles.active = local`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file, `application-local.properties`, at the location, `src/main/resources/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following properties to `application-local.properties` and remove them
    from the `application.properties` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Create another file, `application-cloud.properties`, at `src/main/resources/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following properties to `application-cloud.properties`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete code for the complete application can be found at `chp10/4_boot_multi_profile_incomplete`**.** You
    can run the application by using the `mvn spring-boot:run` command. Spring Boot
    reads the `spring.profiles.active` property from the `application.properties`
    file and runs the application in a local profile. Open the URL, `http://localhost:8080/api/persons`,
    in the browser to find the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the application on the cloud profile by using the `mvn spring-boot:run
    -Dspring.profiles.active=cloud` command. Then open `http://localhost:8080/api/persons`
    in the browser to find the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that there is a different set of data returned by the same API
    and the preceding data was inserted in our MySQL database running on the cloud.
    So, we have been able to successfully run the app in two different profiles: local
    and cloud.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are multiple ways Spring Boot can read the configuration for the application.
    Some significant ones are listed here in the order of their relevance (the property
    defined in the earlier source overrides the property defined in the later sources):'
  prefs: []
  type: TYPE_NORMAL
- en: From the command line. The properties are specified using the `-D` option, like
    we did while launching the app in the cloud profile, `mvn spring-boot:run -Dspring.profiles.active=cloud`.
    Or, if you are using JAR, then it would be `java -Dspring.profiles.active=cloud
    -jar myappjar.jar`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the Java system properties, using `System.getProperties()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS Environment variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profile-specific application properties, `application-{profile}.properties`,
    or the `application-{profile}.yml` files, outside of the packaged JAR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profile-specific application properties `application-{profile}.properties` or
    `application-{profile}.yml` files, packaged within the JAR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application properties, `application.properties`, or `application.yml` defined
    outside of the packaged JAR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application properties, `application.properties`, or `application.yml` packaged
    within the JAR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration classes (that is, annotated with `@Configuration`) serving as
    property sources (annotated with `@PropertySource`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot's default properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our recipe, we specified all the generic properties such as the following
    in the `application.properties` file, and any profile-specific property were specified
    in the profile-specific application properties file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding list, we can find that the `application.properties` or `application-{profile}.properties`
    file can be defined outside the application JAR. There are default locations where
    Spring Boot will search for the properties file, and one such path is the `config`
    sub directory of the current directory the app is running from.
  prefs: []
  type: TYPE_NORMAL
- en: The complete list of Spring Boot-supported application properties can be found
    at [http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html](http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html).
    In addition to these, we can create our own properties required for our application.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code for this can be found at the location, `chp10/4_boot_multi_profile_complete`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can create a configuration server using Spring Boot, which will act as a
    repository for all the properties for all the apps in all the profiles. The client
    apps can then connect with the configuration server to read the relevant properties
    based on the app name and the app profile.
  prefs: []
  type: TYPE_NORMAL
- en: In the configuration server, the application properties can be read from the
    filesystem using the classpath or a GitHub repository. The advantage of using
    a GitHub repository is that the property files can be versioned. The property
    files in the configuration server can be updated, and these updates can be pushed
    to the client apps by setting up a message queue to relay the changes downstream.
    Also, another way is to use the `@RefreshScope` beans and then invoke the `/refresh`
    API whenever we need the client apps to pull the configuration changes.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying RESTful web services to Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Platform as a Service** (**Paas**) is one of the cloud computing models (the
    other two being **Software as a Service** (**SaaS**) and **Infrastructure as a
    Service** (**IaaS**)) where the cloud computing provider provides managed computing
    platforms, which includes OS, programming language runtime, database, and other
    add ons such as queues, log management, and alerting. They also provide you tools
    to ease the deployment and dashboards to monitor your applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Heroku is one of the earliest players in the field of PaaS providers. It supports
    the following programming languages: Ruby, Node.js, Java, Python, Clojure, Scala,
    Go, and PHP. Heroku supports multiple data stores, such as MySQL, MongoDB, Redis,
    and Elastic search. It provides integration with logging tools, network utils,
    email services, and monitoring tools.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku provides a command-line tool called heroku-cli ([cli.heroku.com](http://cli.heroku.com)),
    which can be used to create Heroku applications, deploy, monitor, add resources,
    and more. The functionality provided from their web dashboard is supported by
    the CLI as well. It uses Git to store the application's source code. So, when
    you push the application code to Heroku's Git repository, it triggers a build,
    based on the build pack you are using. Then, it either uses the default way to
    spawn the application or `ProcFile` to execute your application.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will deploy our Spring Boot-based RESTful web service to
    Heroku. We will continue to use the database we created on another cloud provider
    in the previous recipe, *Creating multiple profiles for Spring Boot*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we proceed with deploying our sample application on Heroku, we need to
    sign up for a Heroku account and install its tools, which will enable us to work
    from the command line. In the subsequent sections, we will guide you through the
    sign up process, creating a sample app via the web UI, and via the Heroku **command-line
    interface** (**CLI**).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Heroku account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visit [http://www.heroku.com](http://www.heroku.com) and sign up if you don''t
    have an account. If you have an account, then you can log in. For signing up,
    the URL is [https://signup.heroku.com](https://signup.heroku.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da58d677-a96c-42fb-a3e0-0281b942f753.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For login, the URL is [https://id.heroku.com/login](https://id.heroku.com/login):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89fc20f7-51c7-4073-bc36-413f39c821c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you log in successfully, you will see a dashboard with the list of apps,
    if you have any:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c284855-7193-4bfd-a460-02e6b2f1aa63.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a new app from the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Click on New | Create new app, and fill in the details, as shown in the following
    screenshot, and click on Create App:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/024a1459-63ea-47ea-9d2e-ecf78d12fb5b.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a new app from the CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to create a new app from the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the Heroku CLI from [https://cli.heroku.com](https://cli.heroku.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once installed, Heroku should be in your system's `PATH` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a command prompt and run `heroku create`. You will see output similar
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The app name is generated dynamically and a remote Git repository is created.
    You can specify the app name and region (as done via the UI) by running the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The deployment to Heroku is done via `git push` to the remote Git repository
    created on Heroku. We will see this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: We have the source code for the app at `chp10/5_boot_on_heroku`. So, copy this
    application and go ahead and deploy on Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: You have to log in to the Heroku account before running any of the commands
    in Heroku's cli. You can log in by running the command, `heroku login`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following command to create a Heroku application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the Git repository in the project folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the Heroku Git repository as a remote to your local Git repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Push the source code, that is, the master branch, to the Heroku Git repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When the code is pushed to the Heroku Git repository, it triggers a build.
    As we are using Maven, it runs the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Once the code has completed the build and deployed, you can open the application
    by using the `heroku open` command. This will open the application in a browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can monitor the logs of the application using the `heroku logs --tail` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the app has been successfully deployed, and after you run the `heroku
    open` command, you should see the URL being loaded by the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98ed28ee-931f-402f-ac8c-667b5258c5ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the Persons link will display the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The interesting thing here is that we have our app running on Heroku, which
    is connecting to a MySQL database on a DigitalOcean server. We can even provision
    a database along with the Heroku app and connect to that database. Check out how
    to do this in the *There's more...* section.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a new DB add-on to the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, `addons:create` takes the add-on name and the service plan name, both
    separated by a colon (`:`). You can know more about the add-on details and plans
    at [https://elements.heroku.com/addons/jawsdb-maria](https://elements.heroku.com/addons/jawsdb-maria).
    Also, the Heroku CLI command to add the add-on to your application is given towards
    the end of the add-on details page for all add-ons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the DB dashboard to view the connection details, such as URL, username,
    password, and the database name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `jawsdb` dashboard looks something similar to as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc9b5188-5489-4840-926b-344dbd518a8d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can even get the MySQL connection string from the `JAWSDB_URL` configuration
    property. You can list the configuration for your app by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the connection details and create a new connection in MySQL Workbench
    and connect to this connection. The database name is also created by the add-on.
    Run the following SQL statements after connecting to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new properties file for the Heroku profile, `application-heroku.properties`
    at  `src/main/resources`, with the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You can find the connection related details from the add-on dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Update the `src/main/resources/application.properties` file to replace the value
    of the `spring.profiles.active` property to `heroku`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Commit and push the changes to Heroku remote:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the deployment succeeds, run the `heroku open` command. Then, once the
    page loads in the browser, click on the Persons link. This time, you will see
    a different set of data, the one which we entered in our Heroku add-on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have integrated with a database created on Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: Containerizing the RESTful web service using Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have advanced a lot from the time where an app would be installed across
    servers to each server being virtualized and the app then being installed on these
    smaller virtual machines. Scalability issues for the applications were resolved
    by adding more virtual machines, with the app running to the load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: In virtualization, a large server is divided into multiple virtual machines
    by allocating the computing power, memory, and storage among the multiple virtual
    machines. This way, each of the virtual machines is in itself capable of all those
    things that a server was, albeit on a smaller scale. This way, virtualization
    has helped us a lot in judiciously making use of the server's computing, memory,
    and storage resources.
  prefs: []
  type: TYPE_NORMAL
- en: However, virtualization needs some setup, that is, you need to create the virtual
    machine, install the required dependencies, and then run the app. Moreover, you
    may not be 100% sure if the app would run successfully. The reason for failure
    may be due to the incompatible OS versions or even due to some configuration missed
    while setting up or some missing dependency. This setup also leads to some difficulty
    in horizontal scaling because there is some time spent in the provisioning of
    the virtual machine and then deploying the app.
  prefs: []
  type: TYPE_NORMAL
- en: Using tools such as Puppet and Chef does help in provisioning, but then the
    setting up of the app can often result in issues that might be due to a missing
    or wrong configuration. This led to the introduction of another concept called
    containerization.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the world of virtualization, we have the host OS and then a virtualization
    software, that is, the hypervisor. We then end up creating multiple machines,
    where each machine has its own OS on which apps are deployed. However, in containerization,
    we don''t divide the resources of the server. Instead, we have the server with
    its host OS, and above that, we have a containerization layer which is a software
    abstraction layer. We package apps as containers, where a container is packaged
    with just enough OS functions required to run the app, the software dependencies
    for the app, and then the app itself. The following image taken from [https://docs.docker.com/get-started/#container-diagram](https://docs.docker.com/get-started/#containers-vs-virtual-machines) best
    depicts this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0758437-eabe-43d7-a5fd-51e22c3b6d35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding image illustrates a typical architecture of virtualization systems.
    The following image illustrates a typical architecture of containerization systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/838f967c-db09-46d6-9846-cc003b135e3c.png)'
  prefs: []
  type: TYPE_IMG
- en: The biggest advantage of containerization is that you bundle all the dependencies
    of the app into a container image. This image is then run on the containerization
    platform, leading to the creation of a container. We can have multiple containers
    running simultaneously on the server. If there is a need to add more instances,
    we can just deploy the image, and this deployment can be automated to support
    high scalability in an easy way.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is the world's most popular software containerization platform. In this
    recipe, we will package our sample app found at the location into a Docker image
    and run the Docker image to launch our application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will use a Linux server running Ubuntu 16.04.2 x64.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the latest `.deb` file from [https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/](https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/).
    For other Linux distros, you can find the packages at [https://download.docker.com/linux/](https://download.docker.com/linux/):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the Docker package using the `dpkg` package manager:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The name of the package will vary based on the version you have downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'After successful installation, the Docker service starts running. You can verify
    this by using the `service` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The application to be dockerized is available at the location, `chp10/6_boot_with_docker`,
    of the source code downloaded for this book.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create `Dockerfile` at the root of the application with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to build a Docker image using `Dockerfile` created
    in the preceding step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view the images installed by using the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: You will see that there are OpenJDK and Ubuntu images as well. These were downloaded
    to build the image for our app, which is listed first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to run the image to create a container that contains our running
    application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The large string printed after the `run` command is the identifier of the container.
    You can use the initial few characters to uniquely identify the container. Alternatively,
    you can use the container name, `restapp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The app will have already started. You can view the logs by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view the Docker containers created by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the above command looks similar to as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/630227a1-3af6-4221-9225-daca31800a1d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can manage the container by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Once the app is running, open `http://<hostname>:8090/api/persons`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You define the container structure and its contents by defining `Dockerfile`.
    `Dockerfile` follows a structure, where each line is of the form, `INSTRUCTION
    arguments`. There is a predefined set of instructions, namely `FROM`, `RUN`, `CMD`,
    `LABEL`, `ENV`, `ADD`, `COPY`, and others. A complete list can be found at [https://docs.docker.com/engine/reference/builder/#from](https://docs.docker.com/engine/reference/builder/#from).
    Let''s look at our defined `Dockerfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines using the `FROM` instruction specified the base image for
    our Docker image. We use the Ubuntu OS image as the base image and then combine
    it with the OpenJDK 9 image. The `VOLUME` instruction is used to specify the mount
    point for the image. This is usually a path in the host OS.
  prefs: []
  type: TYPE_NORMAL
- en: The `ADD` instruction is used to copy the file from the source to the destination
    directory under the working directory. The `ENV` instruction is used for defining
    the environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: The `ENTRYPOINT` instruction is used to configure the container to run as an
    executable. For this instruction, we pass an array of arguments, which we would
    otherwise have executed directly from the command line. In our scenario, we are
    using the bash shell to run `java -$JAVA_OPTS -jar <jar name>`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have defined `Dockerfile`, we instruct the Docker tool to build an image
    using `Dockerfile`. We also provide a name for the image using the `--tag` option.
    When building our app image, it will download the required based images, which,
    in our case, are Ubuntu and OpenJDK images. So, if you list the Docker images,
    then you will see the base images along with our app image.
  prefs: []
  type: TYPE_NORMAL
- en: This Docker image is a reusable entity. If we need more instances of the app,
    we spawn a new container using the `docker run` command. When we run the Docker
    image, we have multiple options, where one of them is a `-p` option, which maps
    the ports from within the container to the host OS. In our case, we map the `8080`
    port of our Spring Boot app to `8090` of the host OS.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to check the status of our running app, we can check the logs using `docker
    logs restapp`. Apart from this, the `docker` tool supports multiple commands.
    It's highly recommended to run `docker help` and explore the commands supported.
  prefs: []
  type: TYPE_NORMAL
- en: Docker, the company behind Docker has created a set of base images, which can
    be used to create containers. For example, there are images for MySQL DB, Couchbase,
    Ubuntu, and other operating systems. You can explore the packages at [https://store.docker.com/](https://store.docker.com/).
  prefs: []
  type: TYPE_NORMAL
