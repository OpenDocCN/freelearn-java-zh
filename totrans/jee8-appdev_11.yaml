- en: Microservices Development with Java EE
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java EE进行微服务开发
- en: Microservices is an architectural style in which code is deployed in small,
    granular modules. A microservices architecture reduces coupling and increases
    cohesion. Typically, microservices are implemented as RESTful web services, usually
    using JSON to pass data to one another by invoking HTTP methods (`GET`, `POST`,
    `PUT` or `DELETE`) on each other. Since communication between microservices is
    done via HTTP methods, microservices written in different programming languages
    can interact with each other. In this chapter, we will cover how we can use Java
    EE to implement microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一种将代码部署在小而粒度化的模块中的架构风格。微服务架构减少了耦合并增加了内聚。通常，微服务被实现为RESTful Web服务，通常使用JSON通过调用HTTP方法（`GET`、`POST`、`PUT`或`DELETE`）在彼此之间传递数据。由于微服务之间的通信是通过HTTP方法完成的，因此用不同编程语言编写的微服务可以相互交互。在本章中，我们将介绍如何使用Java
    EE实现微服务。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Introduction to microservices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务简介
- en: Advantages of a microservices architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构的优势
- en: Disadvantages of a microservices architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构的劣势
- en: Developing microservices using Java EE
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java EE开发微服务
- en: Introduction to microservices
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务简介
- en: Architecting applications as a series of microservices offer some advantages
    over traditionally designed applications, as well as some disadvantages. When
    considering a microservices architecture for our applications, we must carefully
    weigh the advantages and disadvantages before we make our decision.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序设计为一系列微服务相对于传统设计应用程序有一些优势，但也存在一些劣势。在考虑为我们的应用程序采用微服务架构时，我们必须在做出决定之前仔细权衡利弊。
- en: Advantages of a microservices architecture
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构的优势
- en: 'Developing an application as a series of microservices offers several advantages
    over traditionally designed applications:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序作为一系列微服务开发具有比传统设计应用程序的多个优势：
- en: '**Smaller code bases**: since each microservice is a small, standalone unit,
    code bases for microservices tend to be smaller and easier to manage than traditionally
    designed applications.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更小的代码库**：由于每个微服务都是一个小的、独立的单元，因此微服务的代码库通常比传统设计的应用程序更小，更容易管理。'
- en: '**Microservices encourage good coding practices:** a microservices architecture
    encourages loose coupling and high cohesion.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务鼓励良好的编码实践**：微服务架构鼓励松耦合和高内聚。'
- en: '**Greater resilience:** traditionally designed applications act as a single
    point of failure; if any component of the application is down or unavailable,
    the whole application is unavailable. Since microservices are independent modules,
    one component (that is, one microservice) being down does not necessarily make
    the whole application unavailable.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更高的容错性**：传统设计的应用程序作为一个单点故障；如果应用程序的任何组件出现故障或不可用，整个应用程序将不可用。由于微服务是独立的模块，一个组件（即一个微服务）出现故障并不一定导致整个应用程序不可用。'
- en: '**Scalability:** since applications developed as a series of microservices
    are composed of a number of different modules, scalability becomes easier; we
    can focus only on those services that may need scaling, without having to waste
    effort on parts of the application that do not need to be scaled.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：由于作为一系列微服务开发的应用程序由多个不同的模块组成，因此可伸缩性变得更容易；我们只需关注可能需要扩展的服务，而无需在不需要扩展的应用程序部分上浪费精力。'
- en: Disadvantages of a microservices architecture
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构的劣势
- en: 'Developing and deploying applications adhering to microservice architecture
    comes with its own set of challenges, regardless of which programming language
    or application framework is used to develop the application:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪种编程语言或应用程序框架来开发应用程序，开发并部署遵循微服务架构的应用程序都会带来其自身的挑战：
- en: '**Additional operational and tooling overhead:** each microservice implementation
    would require its own (possibly automated) deployment, monitoring systems, and
    so on.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**额外的操作和工具开销**：每个微服务实现都需要其自己的（可能是自动化的）部署、监控系统等。'
- en: '**Debugging microservices may be more involved than debugging traditional enterprise
    applications:** if an end user reports a problem with their application and that
    application utilizes multiple microservices internally, it is not always clear
    which of the microservices may be the culprit. This may be especially difficult
    if the microservices involved are developed by different teams with different
    priorities.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试微服务可能比调试传统的企业应用程序更复杂**：如果最终用户报告了他们应用程序的问题，并且该应用程序内部使用了多个微服务，那么并不总是清楚哪个微服务可能是罪魁祸首。如果涉及的微服务是由不同团队开发，且优先级不同，这可能会特别困难。'
- en: '**Distributed transactions may be a challenge:** rolling back a transaction
    involving several microservices may be hard. A common approach to working around
    this is to isolate microservices as much as possible, treating them as single
    units, then have local transaction management for each microservice. For example,
    if microservice A invokes microservice B, if there is a problem with microservice
    B, a local transaction in microservice B would roll back, then it would return
    an HTTP status code `500` (server error) to microservice A. Microservice A could
    then use this HTTP status code as a signal to initiate a compensating transaction
    to bring the system back to its initial state.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式事务可能是一个挑战**：涉及多个微服务的回滚事务可能很难。一种常见的解决方案是尽可能地将微服务隔离，将它们视为单一单元，然后为每个微服务进行本地事务管理。例如，如果微服务A调用了微服务B，如果微服务B存在问题，微服务B的本地事务将回滚，然后它将返回HTTP状态码`500`（服务器错误）给微服务A。微服务A可以使用这个HTTP状态码作为信号来启动补偿事务，使系统恢复到初始状态。'
- en: '**Network latency:** since microservices rely on HTTP method calls for communication,
    performance can sometimes suffer due to network latency.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络延迟**：由于微服务依赖于HTTP方法调用来进行通信，性能有时会因网络延迟而受到影响。'
- en: '**Potential for complex interdependencies:** while independent microservices
    tend to be simple, they are dependent on each other. A microservices architecture
    can potentially create a complex dependency graph. This situation can be worrisome
    if some of our services depend on microservices developed by other teams who may
    have conflicting priorities (for example, if we find a bug in their microservice,
    however, fixing the bug may not be a priority for the other team).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**潜在的复杂依赖性**：虽然独立的微服务往往很简单，但它们相互依赖。微服务架构可能创建一个复杂的依赖图。如果我们的某些服务依赖于其他团队开发的微服务，而这些团队可能有冲突的优先级（例如，如果我们发现他们的微服务中存在一个错误，然而，修复这个错误可能不是其他团队的优先事项），这种情况可能会令人担忧。'
- en: '**Susceptible to the fallacies of distributed computing:** applications developed
    following microservice architecture may make some incorrect assumptions, such
    as network reliability, zero latency, infinite bandwidth, and so on.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容易受到分布式计算谬误的影响**：按照微服务架构开发的应用程序可能会做出一些不正确的假设，例如网络可靠性、零延迟、无限带宽等。'
- en: Microservices and Java EE
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务与Java EE
- en: Some may think that Java EE is "too heavyweight" for microservices development,
    but this is simply not the case. Because of this misconception, some may think
    that Java EE may not be suitable for a microservices architecture, when, in reality,
    Java EE fits microservices development well. In the past, Java EE applications
    were deployed to a "heavyweight" application server. Nowadays, most Java EE application
    server vendors offer lightweight application servers that use very little memory
    or disk space. Some examples of these Java EE compliant lightweight application
    servers include IBM's Open Liberty, Red Hat's WildFly Swarm, Apache TomEE, and
    Payara Micro.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能认为Java EE对于微服务开发来说“过于重量级”，但这根本不是事实。正因为这种误解，有些人可能会认为Java EE可能不适合微服务架构，然而实际上，Java
    EE非常适合微服务开发。在过去，Java EE应用程序被部署到“重量级”的应用服务器上。如今，大多数Java EE应用服务器供应商都提供轻量级的应用服务器，这些服务器使用的内存或磁盘空间非常少。这些Java
    EE兼容的轻量级应用服务器的例子包括IBM的Open Liberty、Red Hat的WildFly Swarm、Apache TomEE和Payara Micro。
- en: Developing microservices with Java EE involves writing standard Java EE applications
    while limiting yourself to a certain subset of Java EE APIs—typically, JAX-RS
    and JSON-P or JSON-B, and perhaps some others, such as CDI and, if interacting
    with a relational database, JPA. Java EE developers can leverage their existing
    expertise when developing microservices. The main requirement is the development
    of RESTful web services using JAX-RS. Then, these web services are packaged in
    a WAR file and deployed to a lightweight application server as usual.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Java EE 开发微服务涉及编写标准的 Java EE 应用程序，同时将自己限制在 Java EE API 的某个子集——通常是 JAX-RS
    和 JSON-P 或 JSON-B，以及一些其他，如 CDI，如果与关系数据库交互，则是 JPA。Java EE 开发者可以在开发微服务时利用他们现有的专业知识。主要要求是使用
    JAX-RS 开发 RESTful 网络服务。然后，将这些网络服务打包在 WAR 文件中，并像往常一样部署到轻量级应用程序服务器上。
- en: When using modern, embeddable Java EE application servers, usually only one
    application is deployed to each instance of the application server, and, in some
    cases, the "tables are turned" so to speak, by having the application server be
    just a library that the application uses as a dependency. With these modern application
    servers, several instances of the application server are often deployed to a server,
    making modern Java EE particularly suitable for microservices development. Many
    modern, lightweight Java EE application servers are embeddable, allowing the creation
    of an "uber jar", which includes both the application code and the application
    server libraries. This "uber jar" is then transferred to the server and run as
    a standalone application. In addition to "uber jars", modern application servers
    can be added to a container image (such as Docker), then applications can be deployed
    as a thin war, typically only a few kilobytes in size; this approach has the advantage
    of very fast deployments, usually under 2 seconds.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用现代、可嵌入的 Java EE 应用程序服务器时，通常每个应用程序服务器实例只部署一个应用程序，在某些情况下，可以说“形势逆转”，应用程序服务器只是一个应用程序作为依赖项使用的库。使用这些现代应用程序服务器，通常会在服务器上部署多个应用程序服务器实例，这使得现代
    Java EE 特别适合微服务开发。许多现代、轻量级的 Java EE 应用程序服务器是可嵌入的，允许创建一个“超级 jar”，它包含应用程序代码和应用程序服务器库。然后，将这个“超级
    jar”传输到服务器上并作为独立应用程序运行。除了“超级 jar”之外，现代应用程序服务器还可以添加到容器镜像（如 Docker）中，然后应用程序可以作为瘦
    war 部署，通常只有几KB大小；这种方法具有非常快速部署的优势，通常在 2 秒以内。
- en: By deploying to a contemporary Java EE Web Profile compliant application server
    (or, as explained in the previous paragraph, creating an "uber jar"), Java EE
    developers can certainly leverage their existing expertise to develop microservice
    compliant applications.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过部署到符合当代 Java EE Web Profile 的应用程序服务器（或，如前一段所述，创建一个“超级 jar”），Java EE 开发者当然可以利用他们现有的专业知识来开发符合微服务规范的应用程序。
- en: Developing microservices using Java EE
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Java EE 开发微服务
- en: Now that we have given a brief introduction to microservices, we are ready to
    see an example microservices application written using Java EE. Our example application
    should be very familiar to most Java EE developers. It is a simple **CRUD** (**Create,
    Read, Update, Delete**) application. Developed as a series of microservices, the
    application will follow the familiar MVC design pattern, with the "View" and "Controller"
    developed as microservices. The application will also utilize the very common
    DAO pattern, with our DAO developed as a microservice as well.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对微服务进行了简要介绍，我们准备查看一个使用 Java EE 编写的示例微服务应用程序。我们的示例应用程序对大多数 Java EE 开发者来说应该非常熟悉。它是一个简单的
    **CRUD**（**创建、读取、更新、删除**）应用程序。作为一系列微服务的开发，该应用程序将遵循熟悉的 MVC 设计模式，其中“视图”和“控制器”作为微服务进行开发。该应用程序还将利用非常常见的
    DAO 模式，我们的 DAO 也作为微服务进行开发。
- en: Actually, the example code is not a full CRUD application. For simplicity, we
    decided to only implement the "Create" part of our CRUD application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，示例代码不是一个完整的 CRUD 应用程序。为了简单起见，我们决定只实现 CRUD 应用程序的“创建”部分。
- en: We will be using Payara Micro to deploy our example code. Payara Micro is a
    lightweight Java EE application server derived from GlassFish, it is open source
    and freely available, and supports the Java EE web profile, which includes a subset
    of all Java EE specifications, namely, Security, Bean Validation, CDI, EJB Lite
    (provides a subset of full EJB functionality), the Unified Expression Language,
    JAX-RS, JDBC, JNDI, JPA, JSF, JSON-P, JSP, Servlets, and WebSockets.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Payara Micro来部署我们的示例代码。Payara Micro是从GlassFish派生出的轻量级Java EE应用程序服务器，它是开源的，可以免费获取，并支持Java
    EE网络配置文件，该配置文件包括所有Java EE规范的一个子集，即安全、Bean验证、CDI、EJB Lite（提供完整EJB功能的一个子集）、统一表达式语言、JAX-RS、JDBC、JNDI、JPA、JSF、JSON-P、JSP、Servlets和WebSockets。
- en: Payara Micro can be downloaded at [https://www.payara.fish/downloads.](https://www.payara.fish/downloads)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://www.payara.fish/downloads.](https://www.payara.fish/downloads)下载Payara
    Micro。
- en: 'Our application will be developed as three modules: first, a microservices
    client, followed by a microservices implementation of a controller in the MVC
    design pattern, then an implementation of the DAO design pattern implemented as
    a microservice.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将开发为三个模块：首先是一个微服务客户端，其次是MVC设计模式中的控制器微服务实现，然后是实现为微服务的DAO设计模式。
- en: Developing microservices client code
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发微服务客户端代码
- en: Before delving into developing our services, we will first develop a microservices
    client, in the form of an HTML5 page, using the popular Twitter Bootstrap CSS
    library as well as the ubiquitous jQuery JavaScript library. The JavaScript code
    in the frontend service will invoke the controller microservice, passing a JSON
    representation of user entered data. The controller service will then invoke the
    persistence service and save data to a database. Each microservice will return
    an HTTP code indicating success or an error condition.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入开发我们的服务之前，我们首先将开发一个微服务客户端，其形式为一个HTML5页面，使用流行的Twitter Bootstrap CSS库以及无处不在的jQuery
    JavaScript库。前端服务中的JavaScript代码将调用控制器微服务，传递用户输入数据的JSON表示。然后，控制器服务将调用持久化服务并将数据保存到数据库中。每个微服务都将返回一个HTTP状态码，指示成功或错误条件。
- en: The most relevant parts of our client code are the HTML form and the jQuery
    code to submit the form to our controller microservice.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们客户端代码中最相关的部分是HTML表单以及提交表单到我们的控制器微服务的jQuery代码。
- en: 'We will only show small snippets of code here. The complete code for the sample
    application can be found at:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里只展示代码的小片段。示例应用的完整代码可以在以下位置找到：
- en: '[https://github.com/dheffelfinger/Java-EE-8-Application-Development-Code-Samples](https://github.com/dheffelfinger/Java-EE-8-Application-Development-Code-Samples).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/dheffelfinger/Java-EE-8-Application-Development-Code-Samples](https://github.com/dheffelfinger/Java-EE-8-Application-Development-Code-Samples).'
- en: 'Markup for the form in our HTML5 page looks as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们HTML5页面中的表单标记如下所示：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The script is invoked when the Submit button on the page is clicked. It uses
    jQuery's `serializeArray()` function to collect user-entered form data and create
    a JSON-formatted array with it. The `serializeArray()` function creates an array
    of JSON objects. Each element on the array has a name property matching the name
    attribute on the HTML markup, and a `value` property matching the user-entered
    value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面上的提交按钮被点击时，将调用脚本。它使用jQuery的`serializeArray()`函数收集用户输入的表单数据，并创建一个带有该数据的JSON格式数组。`serializeArray()`函数创建一个JSON对象数组。数组中的每个元素都有一个与HTML标记上的名称属性匹配的名称属性，以及一个与用户输入值匹配的`value`属性。
- en: 'For example, if a user selected `"Mr"` in the salutation drop down, entered
    `"John"` in the first name field, left the middle name blank, and entered `"Doe"`
    as the last name, the generated JSON array would look as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果用户在问候下拉菜单中选择了`"Mr"`，在名字字段中输入了`"John"`，中间名留空，并以`"Doe"`作为姓氏，生成的JSON数组将如下所示：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the value of each `"name"` property in the JSON array above matches
    the `"name"` attributes in the HTML form; the corresponding `"value"` attributes
    match the user entered values.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，上述JSON数组中每个`"name"`属性的值与HTML表单中的`"name"`属性匹配；相应的`"value"`属性与用户输入的值匹配。
- en: Since the generated HTTP request will be sent to a different instance of Payara
    Micro, we need to set the `crossDomain` property of the `Ajax` settings object
    to `true`, even though we are deploying all of our microservices to the same server
    (or, in our case, to our local workstation).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于生成的HTTP请求将被发送到Payara Micro的不同实例，即使我们将所有微服务部署到同一服务器（或在我们的情况下，部署到我们的本地工作站），我们也需要将`Ajax`设置对象的`crossDomain`属性设置为`true`。
- en: Notice that the `url` property value of the `Ajax` setting objects has a port
    of `8180`, we need to make sure our controller microservice is listening to this
    port when we deploy it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Ajax`设置对象的`url`属性值端口为`8180`，当我们部署时，我们需要确保我们的控制器微服务正在监听这个端口。
- en: 'We can deploy our View microservice to Payara Micro from the command line as
    follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从命令行将我们的View微服务部署到Payara Micro，如下所示：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Payara micro is distributed as an executable JAR file, therefore, we can start
    it via the `java -jar` command. The exact name of the JAR file will depend on
    the version of Payara Micro you are using.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Payara micro以可执行的JAR文件形式分发，因此我们可以通过`java -jar`命令启动它。JAR文件的准确名称将取决于你使用的Payara
    Micro版本。
- en: By default, Payara Micro instances running on the same server form a cluster
    automatically. For our simple example, we don't need this functionality, therefore,
    we used the `--noCluster` command-line argument.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，运行在同一服务器上的Payara Micro实例会自动形成一个集群。对于我们的简单示例，我们不需要这个功能，因此我们使用了`--noCluster`命令行参数。
- en: The `--deploy` command-line argument is used to specify the artifact we want
    to deploy. In our case, it is a WAR file containing the HTML5 page serving as
    the user interface of our example application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`--deploy`命令行参数用于指定我们想要部署的工件。在我们的例子中，它是一个包含作为我们示例应用程序用户界面的HTML5页面的WAR文件。'
- en: 'We can examine the Payara Micro output to make sure our application was deployed
    successfully:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查Payara Micro的输出以确保我们的应用程序已成功部署：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now point our browser to our CrudView application URL (`http://localhost:8080/CrudView`
    in our example). After entering some data, the page will look as shown in the
    following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的浏览器指向我们的CrudView应用程序URL（在我们的例子中是`http://localhost:8080/CrudView`）。输入一些数据后，页面将看起来如下截图所示：
- en: '![](img/8168e3e7-e98e-4f9e-a8ad-180cd90c6aa2.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/8168e3e7-e98e-4f9e-a8ad-180cd90c6aa2.png)'
- en: When the user clicks on the Submit button, the client passes a JSON representation
    of user-entered data to the controller service.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击提交按钮时，客户端将用户输入数据的JSON表示传递给控制器服务。
- en: The controller service
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器服务
- en: 'The controller service is a standard RESTful web service implementation of
    a controller in the MVC design pattern, implemented using JAX-RS:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器服务是MVC设计模式中控制器的一个标准RESTful Web服务实现，使用JAX-RS实现：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `options()` method, annotated with the `javax.ws.rs.OPTIONS` annotation,
    is necessary since the browser automatically calls it before invoking the actual
    `POST` request containing the main logic of our server. In this method, we set
    some header values to allow **Cross-Origin Resource Sharing** (**CORS**), which
    in simple terms means we allow our service to be invoked from a different server
    than the one our service is running on. In our case, the client is deployed to
    a different instance of Payara Micro, therefore, it is considered a different
    origin. These headers are necessary to allow our client code and controller service
    to communicate with each other. Notice that we explicitly allow requests from
    `http://localhost:8080`, which is the host and port where our client code is deployed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`javax.ws.rs.OPTIONS`注解的`options()`方法是必要的，因为浏览器在调用包含我们服务器主要逻辑的实际`POST`请求之前会自动调用它。在这个方法中，我们设置了一些头部值以允许**跨源资源共享**（**CORS**），简单来说就是允许我们的服务从不同于我们服务运行的服务器上调用。在我们的例子中，客户端部署到了Payara
    Micro的不同实例上，因此被视为不同的源。这些头部值是必要的，以便允许我们的客户端代码和控制器服务相互通信。注意，我们明确允许来自`http://localhost:8080`的请求，这是我们的客户端代码部署的主机和端口。
- en: The main logic of our controller service is in the `addCustomer()` method. This
    method receives the JSON string sent by the client as a parameter. In this method,
    we create an instance of `CustomerPersistenceClient()`, which is a client for
    the persistence service implemented using the JAX-RS client API.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们控制器服务的主要逻辑位于`addCustomer()`方法中。此方法接收客户端发送的JSON字符串作为参数。在这个方法中，我们创建了一个`CustomerPersistenceClient()`实例，这是一个使用JAX-RS客户端API实现的持久化服务客户端。
- en: We then create an instance of a `Customer` class by invoking the `jsonToCustomer()`
    method. This method takes the JSON string sent by the client and, using the standard
    Java EE JSON-P API, populates an instance of the `Customer` class with the corresponding
    values in the JSON string.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用`jsonToCustomer()`方法创建一个`Customer`类的实例。此方法接收客户端发送的JSON字符串，并使用标准的Java
    EE JSON-P API，用JSON字符串中的对应值填充`Customer`类的实例。
- en: The `Customer` class is a simple **Data Transfer Object** (**DTO**) containing
    a few properties matching the input fields in the form in the client, plus corresponding
    getters and setters. The class is so simple we decided not to show it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Customer` 类是一个简单的 **数据传输对象** (**DTO**)，包含一些属性，与客户端表单中的输入字段相匹配，以及相应的 getter
    和 setter。这个类非常简单，所以我们决定不展示它。'
- en: Our `addCustomer()` method then invokes the persistence service by invoking
    the `create()` method on `CustomerPersistenceClient`, checks the HTTP status code
    returned by the persistence service, then returns a corresponding status code
    to the client.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的 `addCustomer()` 方法通过在 `CustomerPersistenceClient` 上调用 `create()` 方法来调用持久化服务，检查持久化服务返回的
    HTTP 状态码，然后向客户端返回相应的状态码。
- en: 'Let''s now take a look at the implementation of our JAX-RS client code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看我们的 JAX-RS 客户端代码的实现：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our controller service only uses two standard Java EE APIs, namely JAX-RS and
    JSON-P. As we can see, our client code is a fairly simple class. Making use of
    the JAX-RS client API, we declare a constant containing the base URI of the service
    we are invoking (our persistence service). In its constructor, we create a new
    instance of `javax.ws.rs.client.ClientBuilder`, then set its base URI and path,
    matching the appropriate values for our persistence service. Our client class
    has a single method, which submits an HTTP `POST` request to the persistence service,
    then returns the response sent back from it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的控制器服务只使用了两个标准的 Java EE API，即 JAX-RS 和 JSON-P。正如我们所见，我们的客户端代码是一个相当简单的类。利用
    JAX-RS 客户端 API，我们声明一个包含我们正在调用的服务的基础 URI 的常量（我们的持久化服务）。在其构造函数中，我们创建一个新的 `javax.ws.rs.client.ClientBuilder`
    实例，然后设置其基础 URI 和路径，匹配我们持久化服务的适当值。我们的客户端类有一个单一的方法，该方法向持久化服务提交一个 HTTP `POST` 请求，然后返回它发送回来的响应。
- en: 'We can deploy our controller service to Payara Micro from the command line
    as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从命令行将我们的控制器服务部署到 Payara Micro，如下所示：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'By examining Payara Micro''s output, we can see that our code deployed successfully:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查 Payara Micro 的输出，我们可以看到我们的代码部署成功：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have successfully deployed our controller service, we are ready
    to go through the final component of our application, the persistence service:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功部署了我们的控制器服务，我们准备检查我们应用程序的最后一个组件，即持久化服务：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, since the client code invoking our service is developed in Java,
    there is no need to convert the JSON string we receive to Java code; this is done
    automatically under the covers. Our `create()` method is invoked when the controller
    service sends an HTTP `POST` request to the persistence service. This method simply
    invokes a `create()` method on a class implementing the DAO design pattern. Our
    persistence service returns an `HTTP response 201` (created). If everything goes
    well, if the DAO's `create()` method throws an exception, then our service will
    return an `HTTP error 500` (Internal Server Error).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于调用我们服务的客户端代码是用 Java 开发的，所以我们不需要将接收到的 JSON 字符串转换为 Java 代码；这是在幕后自动完成的。我们的
    `create()` 方法在控制器服务向持久化服务发送 HTTP `POST` 请求时被调用。该方法简单地在一个实现 DAO 设计模式的类上调用 `create()`
    方法。我们的持久化服务返回 `HTTP 响应 201`（已创建）。如果一切顺利，如果 DAO 的 `create()` 方法抛出异常，那么我们的服务将返回
    `HTTP 错误 500`（内部服务器错误）。
- en: 'Our DAO is implemented as a CDI-managed bean, using JPA to insert data into
    the database:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 DAO 作为 CDI 管理的 Bean 实现，使用 JPA 将数据插入到数据库中：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our DAO couldn't be much simpler; it implements a single method that invokes
    the `persist()` method on an injected instance of `EntityManager`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 DAO 实现非常简单；它实现了一个方法，该方法在注入的 `EntityManager` 实例上调用 `persist()` 方法。
- en: In our persistence service project, the `Customer` class is a trivial JPA entity.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的持久化服务项目中，`Customer` 类是一个简单的 JPA 实体。
- en: 'We now deploy our persistence service to Payara Micro as usual:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在像往常一样将我们的持久化服务部署到 Payara Micro：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Examining Payara Micro''s output, we can see that our persistence service was
    deployed successfully:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 Payara Micro 的输出，我们可以看到我们的持久化服务已成功部署：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we have deployed all three components of our application, we are ready
    to see it in action.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经部署了应用程序的所有三个组件，我们准备看到它在实际中的应用。
- en: 'Once the user enters some data and clicks the Submit button, we should see
    a *success* message at the top of our page:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户输入一些数据并点击提交按钮，我们应该在我们的页面顶部看到一条 *成功* 消息：
- en: '![](img/df5271b0-d2ec-495c-923c-d07e61c65b4e.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df5271b0-d2ec-495c-923c-d07e61c65b4e.png)'
- en: 'If we take a look at the database, we should see that the user-entered data
    was persisted successfully:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看数据库，我们应该看到用户输入的数据已成功持久化：
- en: '![](img/a7e9c3e2-7e30-42ac-b6f5-7b99ee7401bc.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7e9c3e2-7e30-42ac-b6f5-7b99ee7401bc.png)'
- en: As shown by our example code, developing applications following microservices
    architecture in Java EE is very simple; it doesn't require any special knowledge.
    Microservices are developed using standard Java EE APIs and deployed to a lightweight
    application server. All of our example code used standard Java EE APIs, covered
    in previous chapters.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们的示例代码所示，在Java EE中遵循微服务架构开发应用程序非常简单；它不需要任何特殊知识。微服务使用标准的Java EE API进行开发，并部署到轻量级的应用服务器。我们所有的示例代码都使用了之前章节中介绍的标准Java
    EE API。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we can see, Java EE is particularly suitable for microservices development.
    Java EE developers can leverage their existing knowledge to develop a microservice
    architecture and deploy it to modern, lightweight application servers. Traditional
    Java EE applications can interact with microservices well, as well as being refactored
    iteratively into a microservice architecture when it makes sense. Whether developing
    new applications following a microservice architecture, refactoring an existing
    application to microservices, or modifying existing applications to interact with
    microservices, Java EE developers can leverage their existing skills for the task
    at hand.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Java EE特别适合微服务开发。Java EE开发者可以利用他们现有的知识来开发微服务架构并将其部署到现代、轻量级的应用服务器。传统的Java
    EE应用程序可以很好地与微服务交互，并且在有意义的场合可以迭代重构为微服务架构。无论是开发遵循微服务架构的新应用程序，重构现有应用程序为微服务，还是修改现有应用程序以与微服务交互，Java
    EE开发者都可以利用他们现有的技能来完成这项任务。
