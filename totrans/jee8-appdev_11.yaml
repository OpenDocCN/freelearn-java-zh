- en: Microservices Development with Java EE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices is an architectural style in which code is deployed in small,
    granular modules. A microservices architecture reduces coupling and increases
    cohesion. Typically, microservices are implemented as RESTful web services, usually
    using JSON to pass data to one another by invoking HTTP methods (`GET`, `POST`,
    `PUT` or `DELETE`) on each other. Since communication between microservices is
    done via HTTP methods, microservices written in different programming languages
    can interact with each other. In this chapter, we will cover how we can use Java
    EE to implement microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of a microservices architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of a microservices architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing microservices using Java EE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Architecting applications as a series of microservices offer some advantages
    over traditionally designed applications, as well as some disadvantages. When
    considering a microservices architecture for our applications, we must carefully
    weigh the advantages and disadvantages before we make our decision.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of a microservices architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Developing an application as a series of microservices offers several advantages
    over traditionally designed applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Smaller code bases**: since each microservice is a small, standalone unit,
    code bases for microservices tend to be smaller and easier to manage than traditionally
    designed applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices encourage good coding practices:** a microservices architecture
    encourages loose coupling and high cohesion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Greater resilience:** traditionally designed applications act as a single
    point of failure; if any component of the application is down or unavailable,
    the whole application is unavailable. Since microservices are independent modules,
    one component (that is, one microservice) being down does not necessarily make
    the whole application unavailable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability:** since applications developed as a series of microservices
    are composed of a number of different modules, scalability becomes easier; we
    can focus only on those services that may need scaling, without having to waste
    effort on parts of the application that do not need to be scaled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of a microservices architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Developing and deploying applications adhering to microservice architecture
    comes with its own set of challenges, regardless of which programming language
    or application framework is used to develop the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional operational and tooling overhead:** each microservice implementation
    would require its own (possibly automated) deployment, monitoring systems, and
    so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debugging microservices may be more involved than debugging traditional enterprise
    applications:** if an end user reports a problem with their application and that
    application utilizes multiple microservices internally, it is not always clear
    which of the microservices may be the culprit. This may be especially difficult
    if the microservices involved are developed by different teams with different
    priorities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed transactions may be a challenge:** rolling back a transaction
    involving several microservices may be hard. A common approach to working around
    this is to isolate microservices as much as possible, treating them as single
    units, then have local transaction management for each microservice. For example,
    if microservice A invokes microservice B, if there is a problem with microservice
    B, a local transaction in microservice B would roll back, then it would return
    an HTTP status code `500` (server error) to microservice A. Microservice A could
    then use this HTTP status code as a signal to initiate a compensating transaction
    to bring the system back to its initial state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network latency:** since microservices rely on HTTP method calls for communication,
    performance can sometimes suffer due to network latency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Potential for complex interdependencies:** while independent microservices
    tend to be simple, they are dependent on each other. A microservices architecture
    can potentially create a complex dependency graph. This situation can be worrisome
    if some of our services depend on microservices developed by other teams who may
    have conflicting priorities (for example, if we find a bug in their microservice,
    however, fixing the bug may not be a priority for the other team).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Susceptible to the fallacies of distributed computing:** applications developed
    following microservice architecture may make some incorrect assumptions, such
    as network reliability, zero latency, infinite bandwidth, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices and Java EE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some may think that Java EE is "too heavyweight" for microservices development,
    but this is simply not the case. Because of this misconception, some may think
    that Java EE may not be suitable for a microservices architecture, when, in reality,
    Java EE fits microservices development well. In the past, Java EE applications
    were deployed to a "heavyweight" application server. Nowadays, most Java EE application
    server vendors offer lightweight application servers that use very little memory
    or disk space. Some examples of these Java EE compliant lightweight application
    servers include IBM's Open Liberty, Red Hat's WildFly Swarm, Apache TomEE, and
    Payara Micro.
  prefs: []
  type: TYPE_NORMAL
- en: Developing microservices with Java EE involves writing standard Java EE applications
    while limiting yourself to a certain subset of Java EE APIsâ€”typically, JAX-RS
    and JSON-P or JSON-B, and perhaps some others, such as CDI and, if interacting
    with a relational database, JPA. Java EE developers can leverage their existing
    expertise when developing microservices. The main requirement is the development
    of RESTful web services using JAX-RS. Then, these web services are packaged in
    a WAR file and deployed to a lightweight application server as usual.
  prefs: []
  type: TYPE_NORMAL
- en: When using modern, embeddable Java EE application servers, usually only one
    application is deployed to each instance of the application server, and, in some
    cases, the "tables are turned" so to speak, by having the application server be
    just a library that the application uses as a dependency. With these modern application
    servers, several instances of the application server are often deployed to a server,
    making modern Java EE particularly suitable for microservices development. Many
    modern, lightweight Java EE application servers are embeddable, allowing the creation
    of an "uber jar", which includes both the application code and the application
    server libraries. This "uber jar" is then transferred to the server and run as
    a standalone application. In addition to "uber jars", modern application servers
    can be added to a container image (such as Docker), then applications can be deployed
    as a thin war, typically only a few kilobytes in size; this approach has the advantage
    of very fast deployments, usually under 2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: By deploying to a contemporary Java EE Web Profile compliant application server
    (or, as explained in the previous paragraph, creating an "uber jar"), Java EE
    developers can certainly leverage their existing expertise to develop microservice
    compliant applications.
  prefs: []
  type: TYPE_NORMAL
- en: Developing microservices using Java EE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have given a brief introduction to microservices, we are ready to
    see an example microservices application written using Java EE. Our example application
    should be very familiar to most Java EE developers. It is a simple **CRUD** (**Create,
    Read, Update, Delete**) application. Developed as a series of microservices, the
    application will follow the familiar MVC design pattern, with the "View" and "Controller"
    developed as microservices. The application will also utilize the very common
    DAO pattern, with our DAO developed as a microservice as well.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, the example code is not a full CRUD application. For simplicity, we
    decided to only implement the "Create" part of our CRUD application.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using Payara Micro to deploy our example code. Payara Micro is a
    lightweight Java EE application server derived from GlassFish, it is open source
    and freely available, and supports the Java EE web profile, which includes a subset
    of all Java EE specifications, namely, Security, Bean Validation, CDI, EJB Lite
    (provides a subset of full EJB functionality), the Unified Expression Language,
    JAX-RS, JDBC, JNDI, JPA, JSF, JSON-P, JSP, Servlets, and WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: Payara Micro can be downloaded at [https://www.payara.fish/downloads.](https://www.payara.fish/downloads)
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application will be developed as three modules: first, a microservices
    client, followed by a microservices implementation of a controller in the MVC
    design pattern, then an implementation of the DAO design pattern implemented as
    a microservice.'
  prefs: []
  type: TYPE_NORMAL
- en: Developing microservices client code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before delving into developing our services, we will first develop a microservices
    client, in the form of an HTML5 page, using the popular Twitter Bootstrap CSS
    library as well as the ubiquitous jQuery JavaScript library. The JavaScript code
    in the frontend service will invoke the controller microservice, passing a JSON
    representation of user entered data. The controller service will then invoke the
    persistence service and save data to a database. Each microservice will return
    an HTTP code indicating success or an error condition.
  prefs: []
  type: TYPE_NORMAL
- en: The most relevant parts of our client code are the HTML form and the jQuery
    code to submit the form to our controller microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will only show small snippets of code here. The complete code for the sample
    application can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/dheffelfinger/Java-EE-8-Application-Development-Code-Samples](https://github.com/dheffelfinger/Java-EE-8-Application-Development-Code-Samples).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Markup for the form in our HTML5 page looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The script is invoked when the Submit button on the page is clicked. It uses
    jQuery's `serializeArray()` function to collect user-entered form data and create
    a JSON-formatted array with it. The `serializeArray()` function creates an array
    of JSON objects. Each element on the array has a name property matching the name
    attribute on the HTML markup, and a `value` property matching the user-entered
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if a user selected `"Mr"` in the salutation drop down, entered
    `"John"` in the first name field, left the middle name blank, and entered `"Doe"`
    as the last name, the generated JSON array would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the value of each `"name"` property in the JSON array above matches
    the `"name"` attributes in the HTML form; the corresponding `"value"` attributes
    match the user entered values.
  prefs: []
  type: TYPE_NORMAL
- en: Since the generated HTTP request will be sent to a different instance of Payara
    Micro, we need to set the `crossDomain` property of the `Ajax` settings object
    to `true`, even though we are deploying all of our microservices to the same server
    (or, in our case, to our local workstation).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `url` property value of the `Ajax` setting objects has a port
    of `8180`, we need to make sure our controller microservice is listening to this
    port when we deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can deploy our View microservice to Payara Micro from the command line as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Payara micro is distributed as an executable JAR file, therefore, we can start
    it via the `java -jar` command. The exact name of the JAR file will depend on
    the version of Payara Micro you are using.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Payara Micro instances running on the same server form a cluster
    automatically. For our simple example, we don't need this functionality, therefore,
    we used the `--noCluster` command-line argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `--deploy` command-line argument is used to specify the artifact we want
    to deploy. In our case, it is a WAR file containing the HTML5 page serving as
    the user interface of our example application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can examine the Payara Micro output to make sure our application was deployed
    successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now point our browser to our CrudView application URL (`http://localhost:8080/CrudView`
    in our example). After entering some data, the page will look as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8168e3e7-e98e-4f9e-a8ad-180cd90c6aa2.png)'
  prefs: []
  type: TYPE_IMG
- en: When the user clicks on the Submit button, the client passes a JSON representation
    of user-entered data to the controller service.
  prefs: []
  type: TYPE_NORMAL
- en: The controller service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The controller service is a standard RESTful web service implementation of
    a controller in the MVC design pattern, implemented using JAX-RS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `options()` method, annotated with the `javax.ws.rs.OPTIONS` annotation,
    is necessary since the browser automatically calls it before invoking the actual
    `POST` request containing the main logic of our server. In this method, we set
    some header values to allow **Cross-Origin Resource Sharing** (**CORS**), which
    in simple terms means we allow our service to be invoked from a different server
    than the one our service is running on. In our case, the client is deployed to
    a different instance of Payara Micro, therefore, it is considered a different
    origin. These headers are necessary to allow our client code and controller service
    to communicate with each other. Notice that we explicitly allow requests from
    `http://localhost:8080`, which is the host and port where our client code is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: The main logic of our controller service is in the `addCustomer()` method. This
    method receives the JSON string sent by the client as a parameter. In this method,
    we create an instance of `CustomerPersistenceClient()`, which is a client for
    the persistence service implemented using the JAX-RS client API.
  prefs: []
  type: TYPE_NORMAL
- en: We then create an instance of a `Customer` class by invoking the `jsonToCustomer()`
    method. This method takes the JSON string sent by the client and, using the standard
    Java EE JSON-P API, populates an instance of the `Customer` class with the corresponding
    values in the JSON string.
  prefs: []
  type: TYPE_NORMAL
- en: The `Customer` class is a simple **Data Transfer Object** (**DTO**) containing
    a few properties matching the input fields in the form in the client, plus corresponding
    getters and setters. The class is so simple we decided not to show it.
  prefs: []
  type: TYPE_NORMAL
- en: Our `addCustomer()` method then invokes the persistence service by invoking
    the `create()` method on `CustomerPersistenceClient`, checks the HTTP status code
    returned by the persistence service, then returns a corresponding status code
    to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now take a look at the implementation of our JAX-RS client code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Our controller service only uses two standard Java EE APIs, namely JAX-RS and
    JSON-P. As we can see, our client code is a fairly simple class. Making use of
    the JAX-RS client API, we declare a constant containing the base URI of the service
    we are invoking (our persistence service). In its constructor, we create a new
    instance of `javax.ws.rs.client.ClientBuilder`, then set its base URI and path,
    matching the appropriate values for our persistence service. Our client class
    has a single method, which submits an HTTP `POST` request to the persistence service,
    then returns the response sent back from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can deploy our controller service to Payara Micro from the command line
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'By examining Payara Micro''s output, we can see that our code deployed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have successfully deployed our controller service, we are ready
    to go through the final component of our application, the persistence service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, since the client code invoking our service is developed in Java,
    there is no need to convert the JSON string we receive to Java code; this is done
    automatically under the covers. Our `create()` method is invoked when the controller
    service sends an HTTP `POST` request to the persistence service. This method simply
    invokes a `create()` method on a class implementing the DAO design pattern. Our
    persistence service returns an `HTTP response 201` (created). If everything goes
    well, if the DAO's `create()` method throws an exception, then our service will
    return an `HTTP error 500` (Internal Server Error).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our DAO is implemented as a CDI-managed bean, using JPA to insert data into
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our DAO couldn't be much simpler; it implements a single method that invokes
    the `persist()` method on an injected instance of `EntityManager`.
  prefs: []
  type: TYPE_NORMAL
- en: In our persistence service project, the `Customer` class is a trivial JPA entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now deploy our persistence service to Payara Micro as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Examining Payara Micro''s output, we can see that our persistence service was
    deployed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have deployed all three components of our application, we are ready
    to see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the user enters some data and clicks the Submit button, we should see
    a *success* message at the top of our page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df5271b0-d2ec-495c-923c-d07e61c65b4e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we take a look at the database, we should see that the user-entered data
    was persisted successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7e9c3e2-7e30-42ac-b6f5-7b99ee7401bc.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown by our example code, developing applications following microservices
    architecture in Java EE is very simple; it doesn't require any special knowledge.
    Microservices are developed using standard Java EE APIs and deployed to a lightweight
    application server. All of our example code used standard Java EE APIs, covered
    in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we can see, Java EE is particularly suitable for microservices development.
    Java EE developers can leverage their existing knowledge to develop a microservice
    architecture and deploy it to modern, lightweight application servers. Traditional
    Java EE applications can interact with microservices well, as well as being refactored
    iteratively into a microservice architecture when it makes sense. Whether developing
    new applications following a microservice architecture, refactoring an existing
    application to microservices, or modifying existing applications to interact with
    microservices, Java EE developers can leverage their existing skills for the task
    at hand.
  prefs: []
  type: TYPE_NORMAL
