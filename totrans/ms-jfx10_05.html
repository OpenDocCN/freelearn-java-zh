<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Exploring Advanced Interactions of WebDriver</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we discussed the WebDriver interface and its features, including taking screenshots, working with Windows, frames, alerts, cookies, and synchronizing tests. In this chapter, we will go through some advanced ways of performing actions on WebElements. We will learn how to perform actions, using <span>the actions API of Selenium WebDriver, including the following:</span></p>
<ul>
<li>Complex mouse actions, such as moving the mouse, double-clicking, and dragging and dropping</li>
<li>Keyboard shortcuts</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the build and perform actions</h1>
                </header>
            
            <article>
                
<p>We know how to perform some basic actions, such as clicking on a button and typing text into a textbox; however, there are many scenarios where we have to perform multiple actions at the same time, for example, keeping the <em>Shift</em> button pressed and typing text for uppercase letters, and the dragging and dropping mouse actions.</p>
<p>Let's see a simple scenario here. Open the <a href="http://guidebook.seleniumacademy.com/Selectable.html">http://guidebook.seleniumacademy.com/Selectable.html</a>. A box of tiles numbered 1 to 12 will appear, as seen in this screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/83234a72-4071-496d-a528-be94774ba35b.png" style=""/></div>
<p>If you inspect the elements with browser developer tools, you will see an ordered list tag:</p>
<pre>&lt;<span>ol </span>id=<span>"selectable"</span> <span>class</span>=<span>"ui-selectable"</span>&gt;<br/>    &lt;<span>li </span><span>class</span>=<span>"ui-state-default ui-selectee" </span>name=<span>"one"</span>&gt;<span>1</span>&lt;/li&gt;<br/>    &lt;<span>li </span><span>class</span>=<span>"ui-state-default ui-selectee" </span>name=<span>"two"</span>&gt;<span>2</span>&lt;/li&gt;<br/>    &lt;<span>li </span><span>class</span>=<span>"ui-state-default ui-selectee" </span>name=<span>"three"</span>&gt;<span>3</span>&lt;/li&gt;<br/>    &lt;<span>li </span><span>class</span>=<span>"ui-state-default ui-selectee" </span>name=<span>"four"</span>&gt;<span>4</span>&lt;/li&gt;<br/>    &lt;<span>li </span><span>class</span>=<span>"ui-state-default ui-selectee" </span>name=<span>"five"</span>&gt;<span>5</span>&lt;/li&gt;<br/>    &lt;<span>li </span><span>class</span>=<span>"ui-state-default ui-selectee" </span>name=<span>"six"</span>&gt;<span>6</span>&lt;/li&gt;<br/>    &lt;<span>li </span><span>class</span>=<span>"ui-state-default ui-selectee" </span>name=<span>"seven"</span>&gt;<span>7</span>&lt;/li&gt;<br/>    &lt;<span>li </span><span>class</span>=<span>"ui-state-default ui-selectee" </span>name=<span>"eight"</span>&gt;<span>8</span>&lt;/li&gt;<br/>    &lt;<span>li </span><span>class</span>=<span>"ui-state-default ui-selectee" </span>name=<span>"nine"</span>&gt;<span>9</span>&lt;/li&gt;<br/>    &lt;<span>li </span><span>class</span>=<span>"ui-state-default ui-selectee" </span>name=<span>"ten"</span>&gt;<span>10</span>&lt;/li&gt;<br/>    &lt;<span>li </span><span>class</span>=<span>"ui-state-default ui-selectee" </span>name=<span>"eleven"</span>&gt;<span>11</span>&lt;/li&gt;<br/>    &lt;<span>li </span><span>class</span>=<span>"ui-state-default ui-selectee" </span>name=<span>"twelve"</span>&gt;<span>12</span>&lt;/li&gt;<br/>&lt;/ol&gt;</pre>
<p>If you click a number, its background color changes to orange. Try selecting the tiles 1, 3, and 5. You do that by holding down <em>Ctrl</em> + tile 1 + tile 3 + tile 5. This involves performing multiple actions, that is, holding <em>Ctrl</em> continuously and clicking on tiles 1, 3, and 5. How do we perform these multiple actions using WebDriver? The following code demonstrates how:</p>
<pre><span>@Test<br/></span><span>public void </span><span>shouldPerformCompositeAction</span>() {<br/><br/>    <span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/Selectable.html"</span>)<span>;<br/></span><span><br/></span><span>    </span>WebElement one = <span>driver</span>.findElement(By.<span>name</span>(<span>"one"</span>))<span>;<br/></span><span>    </span>WebElement three = <span>driver</span>.findElement(By.<span>name</span>(<span>"three"</span>))<span>;<br/></span><span>    </span>WebElement five = <span>driver</span>.findElement(By.<span>name</span>(<span>"five"</span>))<span>;<br/></span><span><br/></span><span>    </span><span>// Add all the actions into the Actions builder.<br/></span><strong>    Actions actions = new Actions(driver);<br/>    actions.keyDown(Keys.CONTROL)</strong><br/><strong>            .click(one)</strong><br/><strong>            .click(three)</strong><br/><strong>            .click(five)</strong><br/><strong>            .keyUp(Keys.CONTROL)</strong><span><strong>;</strong><br/></span><span><br/></span><span>    </span><span>// Generate the composite action.<br/></span><span>    </span><strong>Action compositeAction = actions.build()</strong><span><strong>;</strong><br/></span><span><br/></span><span>    </span><span>// Perform the composite action.<br/></span><strong>    compositeAction.perform()</strong><span><strong>;</strong><br/></span>}</pre>
<p>Now, if you refer to the code, we are getting introduced to a new class named <kbd>Actions</kbd>. This <kbd>Actions</kbd> class is the one that is used to emulate all the complex user events. Using this, the developer of the test script could combine all the necessary user gestures into one composite action. We have declared all the actions that are to be executed to achieve the functionality of clicking on the numbers 1, 3, and 5<span>. Once all the actions are grouped together, we build that into a composite action. </span><kbd>Action</kbd> <span>is an interface that has only the</span> <kbd>perform()</kbd> <span>method, which executes the composite action. When we execute the test, tiles 1, 3, and 5</span><span> will be selected one by one. Finally, tile 5 </span><span>will be selected, as shown in this screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3536f3af-e12e-48f4-8ec0-71bbded32f68.png" style=""/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>So, to make WebDriver perform multiple actions at the same time, you need to follow a three-step process of using the user-facing API of the actions class to group all the actions, then build the composite action, and perform the action. This process can be made into a two-step process, as the <kbd>perform()</kbd> method internally calls the <kbd>build()</kbd> method. So the previous code will look as follows: </p>
<pre><span>@Test<br/></span><span>public void </span><span>shouldPerformAction</span>() {<br/><br/>    <span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/Selectable.html"</span>)<span>;<br/></span><span><br/></span><span>    </span>WebElement one = <span>driver</span>.findElement(By.<span>name</span>(<span>"one"</span>))<span>;<br/></span><span>    </span>WebElement three = <span>driver</span>.findElement(By.<span>name</span>(<span>"three"</span>))<span>;<br/></span><span>    </span>WebElement five = <span>driver</span>.findElement(By.<span>name</span>(<span>"five"</span>))<span>;<br/></span><span><br/></span><span>    </span><span>// Add all the actions into the Actions builder.<br/></span><span>    </span><strong>Actions actions = new Actions(driver);<br/>    actions.keyDown(Keys.CONTROL)</strong><br/><strong>            .click(one)</strong><br/><strong>            .click(three)</strong><br/><strong>            .click(five)</strong><br/><strong>            .keyUp(Keys.CONTROL)</strong><span><strong>;</strong><br/></span><span><br/></span><span>    </span><span>// Perform the action<br/></span><span>    </span><strong>actions.perform()</strong><span><strong>;</strong><br/></span>}</pre>
<p>In the preceding code, we have directly invoked the <kbd>perform()</kbd> method on the <kbd>Actions</kbd> instance, which internally calls the <kbd>build()</kbd> method to create a composite action before executing it. In the subsequent sections of this chapter, we will take a closer look at the <kbd>Actions</kbd> class. All the actions are basically divided into two categories: mouse-based actions and keyboard-based actions. In the following sections, we will discuss all the actions that are specific to the mouse and keyboard available in the <kbd>Actions</kbd> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning mouse based interactions</h1>
                </header>
            
            <article>
                
<p>There are around eight different mouse actions that can be performed using the actions class. We will see each of their syntax and a working example.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The moveByOffset action</h1>
                </header>
            
            <article>
                
<p>The <kbd>moveByOffset()</kbd> method is used to move the mouse from its current position to another point on the web page. Developers can specify the <em>x</em> distance and the <em>y</em> distance the mouse has to be moved. When the page is loaded, generally the initial position of the mouse would be (0, 0), unless there is an explicit focus declared by the page.</p>
<p>The API syntax for the <kbd>moveByOffset()</kbd> method is as follows:</p>
<pre> public Actions moveByOffset(int xOffSet, int yOffSet)</pre>
<p>In the preceding code, <kbd>xOffSet</kbd> is the input parameter providing the WebDriver the amount of offset to be moved along the <em>x</em> axis. A positive value is used to move the cursor to the right, and a negative value is used to move the cursor to the left.</p>
<p><kbd>yOffSet</kbd> is the input parameter providing the WebDriver the amount of offset to be moved along the <em>y</em> axis. A positive value is used to move the cursor down along the <em>y</em> axis, and a negative value is used to move the cursor toward the top.</p>
<p>When the <kbd>xOffSet</kbd> and <kbd>yOffSet</kbd> values result in moving the cursor out of the document, a  <kbd>MoveTargetOutOfBounds</kbd> exception <span>is raised. </span><kbd><br/></kbd></p>
<p>Let's see a working example of it. The objective of the following code is to move the cursor on to tile 3 on the web page:</p>
<pre><span>@Test<br/></span><span>public void </span><span>shouldMoveByOffSet</span>() {<br/><br/>    <span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/Selectable.html"</span>)<span>;<br/></span><span><br/></span><span>    </span>WebElement three = <span>driver</span>.findElement(By.<span>name</span>(<span>"three"</span>))<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"X coordinate: " </span>+ three.getLocation().getX()<br/>            + <span>", Y coordinate: " </span>+ three.getLocation().getY())<span>;<br/></span><strong>    Actions actions = new Actions(driver);<br/>    actions.moveByOffset(three.getLocation().getX() + 1, three.</strong><br/><strong>            getLocation().getY() + 1);<br/>    actions.perform()</strong><span><strong>;</strong><br/></span>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The output will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/eabd86c4-a1fb-4b7a-b922-4fb254413d85.png" style=""/></div>
<p>We have added <kbd>+1</kbd> to the coordinates, because if you observe the element in Firebug, we have a style border of 1 px. The border is a CSS-style attribute, which when applied to an element will add a border of the specified color around the element, with the specified amount of thickness. Though the previous code does move your mouse over tile 3, we don't realize this, because we are not performing any action there. We will see this shortly, when we use the <kbd>moveByOffset()</kbd> method in combination with the <kbd>click()</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The click at current location action</h1>
                </header>
            
            <article>
                
<p>The <kbd>click()</kbd> method is used to simulate the left-click of your mouse at its current point of location. This method doesn't really realize where or on which element it is clicking. It just clicks wherever it is at that point in time. Hence, this method is used in combination with some other action, rather than independently, to create a composite action.</p>
<p>The API syntax for the <kbd>click()</kbd> method is as follows: </p>
<p><kbd>public Actions click()</kbd>.</p>
<p class="mce-root"/>
<p>The <kbd>click()</kbd> method doesn't really have any context about where it is performing its action; hence, it doesn't take any input parameter. Let's see a code example of the <kbd>click()</kbd> method:</p>
<pre><span>@Test<br/></span><span>public void </span><span>shouldMoveByOffSetAndClick</span>() {<br/><br/>    <span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/Selectable.html"</span>)<span>;<br/></span><span><br/></span><span>    </span>WebElement seven = <span>driver</span>.findElement(By.<span>name</span>(<span>"seven"</span>))<span>;<br/></span><span>    </span>System.<span>out</span>.println(<span>"X coordinate: " </span>+ seven.getLocation().getX() +<br/>            <span>", Y coordinate: " </span>+ seven.getLocation().getY())<span>;<br/></span><strong>    Actions actions = new Actions(driver);<br/>    actions.moveByOffset(seven.getLocation().getX() + 1, seven.</strong><br/><strong>            getLocation().getY() + 1).click();<br/>    actions.perform()</strong><span><strong>;</strong><br/></span>}</pre>
<p>In the above example we have used a combination of the <kbd>moveByOffset()</kbd> and <kbd>click()</kbd> methods to move the cursor from point (0, 0) to the point of tile <span class="packt_screen">7</span>. Because the initial position of the mouse is (0, 0), the <em>x</em>, <em>y</em> offset provided for the <kbd>moveByOffset()</kbd> method is nothing but the location of the tile <span class="packt_screen">7</span> element. Now let's try to move the cursor from tile 1 to tile 11, and from there to tile 5, and see how the code looks. Before we get into the code, let's inspect the <kbd>Selectable.html</kbd> page using Firebug. The following is the style of each tile:</p>
<pre>#selectable li {<br/>    <span>float</span>: left<span>;<br/></span><span>    </span>font-size: <span>4e</span>m<span>;<br/></span><span>    </span><strong>height: 80px</strong><span><strong>;</strong><br/></span><span>    </span>text-align: center<span>;<br/></span><span>    </span><strong>width: 100px</strong><span><strong>;</strong><br/></span>}<br/>.ui-state-<span>default, </span>.ui-widget-content .ui-state-<span>default, </span>.ui-widgetheader .ui-state-<span>default </span>{<br/>    background: url(<span>"images/ui-bg_glass_75_e6e6e6_1x400.png"</span>) repeat-x<br/>    scroll <span>50</span>% <span>50</span>% #E6E6E6<span>;<br/></span><strong>    border: 1px solid #D3D3D3</strong><span><strong>;</strong><br/></span><span>    </span>color: #<span>555555</span><span>;<br/></span><span>    </span>font-weight: normal<span>;<br/></span>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The three elements with which we are concerned for our offset movement in the preceding style code are: <kbd>height</kbd>, <kbd>width</kbd>, and the <kbd>border</kbd> thickness. Here, the <kbd>height</kbd> value is <kbd>80px</kbd>, the <kbd>width</kbd> value is <kbd>100px</kbd>, and the <kbd>border</kbd> value is <kbd>1px</kbd>. Use these three factors to calculate the offset to navigate from one tile to the other. Note that the border thickness between any two tiles will result in <kbd>2 px</kbd>, that is, <kbd>1 px</kbd> from each tile. The following is the code that uses the <kbd>moveByOffset</kbd> and <kbd>click()</kbd> methods to navigate from tile 1 to tile 11, and from there to tile 5:</p>
<pre><span>@Test<br/></span><span>public void </span><span>shouldMoveByOffSetAndClickMultiple</span>() {<br/><br/>    <span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/Selectable.html"</span>)<span>;<br/></span><span><br/></span><span>    </span>WebElement one = <span>driver</span>.findElement(By.<span>name</span>(<span>"one"</span>))<span>;<br/></span><span>    </span>WebElement eleven = <span>driver</span>.findElement(By.<span>name</span>(<span>"eleven"</span>))<span>;<br/></span><span>    </span>WebElement five = <span>driver</span>.findElement(By.<span>name</span>(<span>"five"</span>))<span>;<br/></span><span>    int </span>border = <span>1</span><span>;<br/></span><span>    int </span>tileWidth = <span>100</span><span>;<br/></span><span>    int </span>tileHeight = <span>80</span><span>;<br/></span><span>    </span>Actions actions = <span>new </span>Actions(<span>driver</span>)<span>;<br/></span><span><br/></span><span>    </span><span>//Click on One<br/></span><span>    </span>actions.moveByOffset(one.getLocation().getX() + border<span>, </span>one.getLocation().getY() + border).click()<span>;<br/></span><span>    </span>actions.build().perform()<span>;<br/></span><span><br/></span><span>    </span><span>// Click on Eleven<br/></span><span>    actions.moveByOffset(2 * tileWidth + 4 * border, 2 * tileHeight + 4 * border).click();</span><span><br/></span><span>    </span>actions.build().perform()<span>;<br/></span><span><br/></span><span>    </span><span>//Click on Five<br/></span><span>    </span>actions.moveByOffset(-<span>2 </span>* tileWidth - <span>4 </span>* border<span>, </span>-tileHeight - <span>2 </span>* border).<br/>            click()<span>;<br/></span><span>    </span>actions.build().perform()<span>;<br/></span>}</pre>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The click on a WebElement action</h1>
                </header>
            
            <article>
                
<p>We have seen how to click a WebElement by calculating the offset to it. This process may not be needed every time, especially when the WebElement has its own identifiers, such as a name or an ID. We can use another overloaded version of the <kbd>click()</kbd> method to click directly on the WebElement.</p>
<p>The API syntax for clicking on a WebElement is as follows:</p>
<pre>public Actions click(WebElement onElement)</pre>
<p>The input parameter for this method is an instance of the WebElement on which the <kbd>click</kbd> action should be performed. This method, like all the other methods in the <kbd>Actions</kbd> class, will return an <kbd>Actions</kbd> instance.</p>
<p>Now let's try to modify the previous code example to use the <kbd>click(WebElement)</kbd> method, instead of using the <kbd>moveByOffset()</kbd> method, to move to the location of the WebElement and click on it using the <kbd>click()</kbd> method:</p>
<pre><span>@Test<br/></span><span>public void </span><span>shouldClickOnElement</span>() {<br/><br/>    <span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/Selectable.html"</span>)<span>;<br/></span><span><br/></span><span>    </span>WebElement one = <span>driver</span>.findElement(By.<span>name</span>(<span>"one"</span>))<span>;<br/></span><span>    </span>WebElement eleven = <span>driver</span>.findElement(By.<span>name</span>(<span>"eleven"</span>))<span>;<br/></span><span>    </span>WebElement five = <span>driver</span>.findElement(By.<span>name</span>(<span>"five"</span>))<span>;<br/></span><span>    </span>Actions actions = <span>new </span>Actions(<span>driver</span>)<span>;<br/></span><span><br/></span><strong>    //Click on One<br/>    actions.click(one);<br/>    actions.build().perform();<br/><br/>    // Click on Eleven<br/>    actions.click(eleven);<br/>    actions.build().perform();<br/><br/>    //Click on Five<br/>    actions.click(five);<br/>    actions.build().perform();<br/>}</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now the <kbd>moveByOffset()</kbd> method has been replaced by the <kbd>click(WebElement)</kbd> method, and, all of a sudden, the complex coordinate geometry has been removed from the code. If you're a tester, this is one more good reason to push your developers to provide identifiers for the WebElements.</p>
<p>If you observe the previous examples for the <kbd>moveByOffset</kbd> and <kbd>click</kbd> methods, all the operations of moving the mouse and clicking on tiles 1, 11, and 5 are built separately and performed separately. This is not how we use our <kbd>Actions</kbd> class. You can actually build all these actions together and then perform them. So, the preceding code will turn out to be as follows:</p>
<pre>    <span>@Test<br/></span><span>    </span><span>public void </span><span>shouldClickOnElement</span>() {<br/><br/>        <span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/Selectable.html"</span>)<span>;<br/></span><span><br/></span><span>        </span>WebElement one = <span>driver</span>.findElement(By.<span>name</span>(<span>"one"</span>))<span>;<br/></span><span>        </span>WebElement eleven = <span>driver</span>.findElement(By.<span>name</span>(<span>"eleven"</span>))<span>;<br/></span><span>        </span>WebElement five = <span>driver</span>.findElement(By.<span>name</span>(<span>"five"</span>))<span>;<br/></span><span>        </span>Actions actions = <span>new </span>Actions(<span>driver</span>)<span>;<br/></span><span><br/></span><strong>        actions.click(one)</strong><br/><strong>                .click(eleven)</strong><br/><strong>                .click(five)</strong><br/><strong>                .build().perform()</strong><span><strong>;</strong><br/></span><span>    </span>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The click and hold at current location action</h1>
                </header>
            
            <article>
                
<p>The <kbd>clickAndHold()</kbd> method is another method of the actions class that left-clicks on an element and holds it without releasing the left button of the mouse. This method will be useful when executing operations such as drag and drop. This method is one of the variants of the <kbd>clickAndHold()</kbd> method that the actions class provides. We will discuss the other variant in the next section.</p>
<p>Now open the <kbd>Sortable.html</kbd> file that came with the book. You can see that the tiles can be moved from one position to the other. Now let's try to move tile 3 to the position of tile 2. The sequence of steps that are involved to do this are the following:</p>
<ol>
<li>Move the cursor to the position of tile 3.</li>
<li>Click and hold tile 3.</li>
<li>Move the cursor in this position to tile 2's location.</li>
</ol>
<p>Now let's see how this can be accomplished, using the WebDriver's <kbd>clickAndHold()</kbd> method:</p>
<pre><span>@Test<br/></span><span>public void </span><span>shouldClickAndHold</span>() {<br/><br/>    <span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/Sortable.html"</span>)<span>;<br/></span><span><br/></span><span>    </span>Actions actions = <span>new </span>Actions(<span>driver</span>)<span>;<br/></span><span><br/></span><span>    </span><span>//Move tile3 to the position of tile2<br/></span><span>    </span><strong>actions.moveByOffset(200, 20)</strong><br/><strong>            .clickAndHold()</strong><br/><strong>            .moveByOffset(120, 0)</strong><br/><strong>            .perform()</strong><span><strong>;</strong><br/></span>}</pre>
<p>Let's analyze the following line of code:</p>
<pre><strong>actions.moveByOffset(200, 20)</strong><br/><strong>            .clickAndHold()</strong><br/><strong>            .moveByOffset(120, 0)</strong><br/><strong>            .perform()</strong><span><strong>;</strong></span></pre>
<p>The tile movement will be similar to the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/944e4722-7d84-4f9e-9483-70df3f8ed449.png" style=""/></div>
<p class="mce-root"/>
<p>First, we move the cursor to the location of tile 3. Then, we click and hold tile 3. Then, we move the cursor by <kbd>120px</kbd> horizontally to the position of tile 2. The last line performs all the preceding actions. Now execute this in your eclipse and see what happens. If you observe closely, tile 3 doesn't properly go into the position of tile 2. This is because we are yet to release the left button. We just commanded the WebDriver to click and hold, but not to release. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The click and hold a WebElement action</h1>
                </header>
            
            <article>
                
<p>In the previous section, we have seen the <kbd>clickAndHold()</kbd> method, which will click and hold a WebElement at the current position of the cursor. It doesn't care about which element it is dealing with. So, if we want to deal with a particular WebElement on the web page, we have to first move the cursor to the appropriate position and then perform the <kbd>clickAndHold()</kbd> action. To avoid the hassle of moving the cursor geometrically, WebDriver provides the developers with another variant or overloaded method of the <kbd>clickAndHold()</kbd> method that takes the WebElement as input.</p>
<p>The API syntax is this: </p>
<pre>public Actions clickAndHold(WebElement onElement)</pre>
<p>The input parameter for this method is the WebElement that has to be clicked and held. The return type, as in all the other methods of the <kbd>Actions</kbd> class, is the <kbd>Actions</kbd> instance. Now let's refactor the example in the previous section to use this method, as follows:</p>
<pre><span>@Test<br/></span><span>public void </span><span>shouldClickAndHoldElement</span>() {<br/><br/>    <span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/Sortable.html"</span>)<span>;<br/></span><span><br/></span><span>    </span>Actions actions = <span>new </span>Actions(<span>driver</span>)<span>;<br/></span><span>    </span>WebElement three = <span>driver</span>.findElement(By.<span>name</span>(<span>"three"</span>))<span>;<br/></span><span><br/></span><span>    </span><span>//Move tile3 to the position of tile2<br/></span><span>    </span><strong>actions.clickAndHold(three)</strong><br/><strong>            .moveByOffset(120, 0)</strong><br/><strong>            .perform()</strong><span><strong>;</strong><br/></span>}</pre>
<p>The only change is that we have removed the action of moving the cursor to the <kbd>(200, 20)</kbd> position and provided the WebElement to the <kbd>clickAndHold()</kbd> method that will take care of identifying the WebElement.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The release at current location action</h1>
                </header>
            
            <article>
                
<p>Now, in the previous example, we have seen how to click and hold an element. The ultimate action that has to be taken on a held WebElement is to release it so that the element can be dropped or released from the mouse. The <kbd>release()</kbd> method is the one that can release the left mouse button on a WebElement.</p>
<p>The API syntax for the <kbd>release()</kbd> method is as follows: <kbd>public Actions release()</kbd>.</p>
<p>The preceding method doesn't take any input parameter and returns the <kbd>Actions</kbd> class instance.</p>
<p>Now, let's modify the previous code to include the <kbd>release</kbd> action in it:</p>
<pre><span>@Test<br/></span><span>public void </span><span>shouldClickAndHoldAndRelease</span>() {<br/><br/>    <span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/Sortable.html"</span>)<span>;<br/></span><span><br/></span><span>    </span>WebElement three = <span>driver</span>.findElement(By.<span>name</span>(<span>"three"</span>))<span>;<br/></span><span>    </span>Actions actions = <span>new </span>Actions(<span>driver</span>)<span>;<br/></span><span><br/></span><span>    </span><span>//Move tile3 to the position of tile2<br/></span><span>    </span><strong>actions.clickAndHold(three)</strong><br/><strong>            .moveByOffset(120, 0)</strong><br/><strong>            .release()</strong><br/><strong>            .perform()</strong><span><strong>;</strong><br/></span>}</pre>
<p>The preceding code will make sure that the mouse is released at the specified location.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The release on another WebElement action </h1>
                </header>
            
            <article>
                
<p>This is an overloaded version of the <kbd>release()</kbd> method. Using this, you can actually release the currently held WebElement in the middle of another WebElement. In this way, we don't have to calculate the offset of the target WebElement from the held WebElement.</p>
<p>The API syntax is as follows:</p>
<pre>public Actions release(WebElement onElement)</pre>
<p class="mce-root"/>
<p>The input parameter for the preceding method is obviously the target WebElement, where the held WebElement should be dropped. The return type is the instance of the <kbd>Actions</kbd> class.</p>
<p>Let's modify the preceding code example to use this method:</p>
<pre><span>@Test<br/></span><span>public void </span><span>shouldClickAndHoldAndReleaseOnElement</span>() {<br/><br/>    <span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/Sortable.html"</span>)<span>;<br/></span><span><br/></span><span>    </span>WebElement three = <span>driver</span>.findElement(By.<span>name</span>(<span>"three"</span>))<span>;<br/></span><span>    </span>WebElement two = <span>driver</span>.findElement(By.<span>name</span>(<span>"two"</span>))<span>;<br/></span><span>    </span>Actions actions = <span>new </span>Actions(<span>driver</span>)<span>;<br/></span><span><br/></span><span>    </span><span>//Move tile3 to the position of tile2<br/></span><span>    </span><strong>actions.clickAndHold(three)</strong><br/><strong>            .release(two)</strong><br/><strong>            .perform()</strong><span><strong>;</strong><br/></span>}</pre>
<p>Look at how simple the preceding code is. We have removed all the <kbd>moveByOffset</kbd> code and added the <kbd>release()</kbd> method that takes the WebElement with the name <kbd>two</kbd> as the input parameter.</p>
<div class="packt_infobox">Invoking the <kbd>release()</kbd> or <kbd>release(WebElement)</kbd> methods without calling the <kbd>clickAndHold()</kbd> method will result in an undefined behavior.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The moveToElement action</h1>
                </header>
            
            <article>
                
<p>The <kbd>moveToElement()</kbd> method is another method of WebDriver that helps us to move the mouse cursor to a WebElement on the web page.</p>
<p>The API syntax for the <kbd>moveToElement()</kbd> method is as follows:</p>
<pre>public Actions moveToElement(WebElement toElement)</pre>
<p class="mce-root"/>
<p>The input parameter for the preceding method is the target WebElement, where the mouse should be moved. Now go back to the <kbd>clickAndHold</kbd> at <em>current location action</em> section of this chapter and try to modify the code to use this method. The following is the code we have written in <em>The click-and-hold-at-current-location action</em> section:</p>
<pre><span>@Test<br/></span><span>public void </span><span>shouldClickAndHold</span>() {<br/><br/>    <span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/Sortable.html"</span>)<span>;<br/></span><span><br/></span><span>    </span>Actions actions = <span>new </span>Actions(<span>driver</span>)<span>;<br/></span><span><br/></span><span>    </span><span>//Move tile3 to the position of tile2<br/></span><strong>    actions.moveByOffset(200, 20)</strong><br/><strong>            .clickAndHold()</strong><br/><strong>            .moveByOffset(120, 0)</strong><br/><strong>            .perform()</strong><span><strong>;</strong><br/></span>}</pre>
<p>In the preceding code, we will replace the <kbd>moveByOffset(x, y)</kbd> method with the <kbd>moveToElement(WebElement)</kbd> method:</p>
<pre><span>@Test<br/></span><span>public void </span><span>shouldClickAndHoldAndMove</span>() {<br/><br/>    <span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/Sortable.html"</span>)<span>;<br/></span><span><br/></span><span>    </span>WebElement three = <span>driver</span>.findElement(By.<span>name</span>(<span>"three"</span>))<span>;<br/></span><span>    </span>Actions actions = <span>new </span>Actions(<span>driver</span>)<span>;<br/></span><span><br/></span><span>    </span><span>//Move tile3 to the position of tile2<br/></span><span>    </span><strong>actions.moveToElement(three)</strong><br/><strong>            .clickAndHold()</strong><br/><strong>            .moveByOffset(120, 0)</strong><br/><strong>            .perform()</strong><span><strong>;</strong><br/></span>}</pre>
<p>In the preceding code, we have moved to tile 3, clicked and held it, and then moved to the location of tile 2, by specifying its offset. If you want, you can add the <kbd>release()</kbd> method before the <kbd>perform()</kbd> method.</p>
<div class="packt_tip packt_infobox">There might be a number of ways to achieve the same task. It is up to the user to choose the appropriate ones that best suit the given circumstances.</div>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The dragAndDropBy action</h1>
                </header>
            
            <article>
                
<p>There might be many instances where we may have to drag and drop components or WebElements of a web page. We can accomplish that by using many of the actions seen until now. But WebDriver has given us a convenient out-of-the-box method to use. Let's see its API syntax.</p>
<p>The API syntax for the <kbd>dragAndDropBy()</kbd> method is as follows:</p>
<pre>public Actions dragAndDropBy(WebElement source, int xOffset,int yOffset)</pre>
<p>The <kbd>WebElement</kbd> input parameter is the target WebElement to be dragged, the <kbd>xOffset</kbd> parameter is the horizontal offset to be moved, and the <kbd>yOffset</kbd> parameter is the vertical offset to be moved.</p>
<p>Let's see a code example for it. Open the HTML file, <kbd>DragMe.html</kbd>, provided with this book. It has a square box, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9dfa2b9d-f4b9-465a-a5e1-c32911386701.png" style=""/></div>
<p class="mce-root"/>
<p>You can actually drag that rectangle to any location on the web page. Let's see how we can do that, using WebDriver. The following is the code example for that:</p>
<pre><span>@Test<br/></span><span>public void </span><span>shouldDrag</span>() {<br/><br/>    <span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/DragMe.html"</span>)<span>;<br/></span><span><br/></span><span>    </span>WebElement dragMe = <span>driver</span>.findElement(By.<span>id</span>(<span>"draggable"</span>))<span>;<br/></span><span>    </span>Actions actions = <span>new </span>Actions(<span>driver</span>)<span>;<br/></span><span>    </span><strong>actions.dragAndDropBy(dragMe, 300, 200).perform()</strong><span><strong>;</strong><br/></span>}</pre>
<p>In the preceding code, <kbd>dragMe</kbd> is the WebElement that is identified by its <kbd>id</kbd>, and that is dragged <kbd>300px</kbd> horizontally and <kbd>200px</kbd> vertically. The following screenshot shows how an element is dragged from this position:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8db11150-9639-44a0-8c0b-c431f32f1c7d.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The dragAndDrop action</h1>
                </header>
            
            <article>
                
<p>The <kbd>dragAndDrop()</kbd> method is similar to the <kbd>dragAndDropBy()</kbd> method. The only difference being that, instead of moving the WebElement by an offset, we move it on to a target element.</p>
<p class="mce-root"/>
<p>The API syntax for the <kbd>dragAndDrop()</kbd> method is as follows:</p>
<pre>public Actions dragAndDrop(WebElement source, WebElement target)</pre>
<p>The input parameters for the preceding method are the WebElement source and the WebElement target, while the return type is the <kbd>Actions</kbd> class.</p>
<p>Let's see a working code example for it. Open the <kbd>DragAndDrop.html</kbd> file, which is provided with the book, with two square boxes, as shown in this screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a805d005-ebdd-4cdc-80fe-12c29f8158f6.png" style=""/></div>
<p>Here, we can actually drag the <span class="packt_screen">Drag me</span> <span class="packt_screen">to my target</span> rectangle to the <span class="packt_screen">Drop here</span> rectangle. Try that. Let's see how that can be achieved, using WebDriver:</p>
<pre><span>@Test<br/></span><span>public void </span><span>shouldDragAndDrop</span>() {<br/><br/>    <span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/DragAndDrop.html"</span>)<span>;<br/></span><span><br/></span><span>    </span>WebElement src = <span>driver</span>.findElement(By.<span>id</span>(<span>"draggable"</span>))<span>;<br/></span><span>    </span>WebElement trgt = <span>driver</span>.findElement(By.<span>id</span>(<span>"droppable"</span>))<span>;<br/></span><span>    </span>Actions actions = <span>new </span>Actions(<span>driver</span>)<span>;<br/></span><span>    </span><strong>actions.dragAndDrop(src, trgt).perform()</strong><span><strong>;</strong><br/></span>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the preceding code, the source and target WebElements are identified by their IDs, and the <kbd>dragAndDrop()</kbd> method is used to drag one to the other. Here, out of the script with first square box dropped on the second box shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6ee19696-4b35-42f6-ac0c-9b6172088063.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The double click at current location action</h1>
                </header>
            
            <article>
                
<p> Moving on to another action that can be performed using a mouse, <kbd>doubleClick()</kbd> is another out- of-the-box method that WebDriver provides to emulate the double-clicking of the mouse. This method, like the <kbd>click()</kbd> method, comes in two flavors. One is double-clicking a WebElement, which we will discuss in next section; the second is clicking at the current location of the cursor, which will be discussed here.</p>
<p>The API syntax is as follows:</p>
<pre>public Actions doubleClick()</pre>
<p>Obviously, the preceding method doesn't take any input parameters, as it just clicks on the current cursor location and returns an actions class instance. Let's see how the previous code can be converted to use this method:</p>
<pre><span>@Test<br/></span><span>public void </span><span>shouldDoubleClick</span>() {<br/><br/>    <span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/DoubleClick.html"</span>)<span>;<br/></span><span><br/></span><span>    </span>WebElement dblClick= <span>driver</span>.findElement(By.<span>name</span>(<span>"dblClick"</span>))<span>;<br/></span><span>    </span>Actions actions = <span>new </span>Actions(<span>driver</span>)<span>;<br/></span><span>    </span><strong>actions.moveToElement(dblClick).doubleClick().perform()</strong><span><strong>;</strong><br/></span>}</pre>
<p class="mce-root"/>
<p>In the preceding code, we have used the <kbd>moveToElement(WebElement)</kbd> method to move the mouse to the location of the button element and just double-clicked at the current location. Here is the output after performing the double-click on the element on the sample page:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f703cd69-1145-43e4-9b43-c8a65cd189bc.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The double click on WebElement action</h1>
                </header>
            
            <article>
                
<p>Now that we have seen a method that double-clicks at the current location, we will discuss another method that WebDriver provides to emulate the double-clicking of a WebElement.</p>
<p>The API syntax for the <kbd>doubleClick()</kbd> method is as follows:</p>
<pre>public Actions doubleClick(WebElement onElement)</pre>
<p>The input parameter for the preceding method is the target WebElement that has to be double-clicked, and the return type is the <kbd>Actions</kbd> class.</p>
<p>Let's see a code example for this. Open the <kbd>DoubleClick.html</kbd> file and <em>single</em>-click on the <span class="packt_screen">Click Me</span> button. You shouldn't see anything happening. Now double-click on the button; you should see an alert saying <span class="packt_screen">Double Clicked !!</span>. Now we will try to do the same thing using WebDriver. The following is the code to do that:</p>
<pre><span>@Test<br/></span><span>public void </span><span>shouldDoubleClickElement</span>() {<br/><span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/DoubleClick.html"</span>)<span>;<br/></span><span><br/></span><span>    </span>WebElement dblClick = <span>driver</span>.findElement(By.<span>name</span>(<span>"dblClick"</span>))<span>;<br/></span><span>    </span>Actions actions = <span>new </span>Actions(<span>driver</span>)<span>;<br/></span><span>    </span><strong>actions.doubleClick(dblClick).perform()</strong><span><strong>;</strong><br/></span>}</pre>
<p>After executing the preceding code, you should see an alert dialog saying that the button has been double-clicked.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The context click on WebElement action</h1>
                </header>
            
            <article>
                
<p>The <kbd>contextClick()</kbd> method, also known as <em>right-click</em>, is quite common on many web pages these days. It displays a menu similar to this screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3dabf2a1-2c7f-4ab4-a9ed-b66686e65be4.png" style=""/></div>
<p>This context menu can be accessed by a right-click of the mouse on the WebElement. WebDriver provides the developer with an option of emulating that action, using the <kbd>contextClick()</kbd> method. Like many other methods, this method has two variants as well. One is clicking on the current location and the other overloaded method is clicking on the WebElement. Let's discuss the context of clicking on WebElement here.</p>
<p>The API syntax for the <kbd>contextClick()</kbd> method is as follows:</p>
<pre>public Actions contextClick(WebElement onElement)</pre>
<p>The input parameter is obviously the WebElement that has to be right-clicked, and the return type is the <kbd>Actions</kbd> instance. As we do normally, its time to see a code example. If you open the <kbd>ContextClick.html</kbd> file, you can right-click on the text visible on the page, and it will display the context menu. Now clicking any item pops up an alert dialog stating which item has been clicked. Now let's see how to implement this in WebDriver, using the following code:</p>
<pre><span>@Test<br/></span><span>public void </span><span>shouldContextClick</span>() {<br/><br/>    <span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/ContextClick.html"</span>)<span>;<br/></span><span><br/></span><span>    </span>WebElement contextMenu = <span>driver</span>.findElement(By.<span>id</span>(<span>"div-context"</span>))<span>;<br/></span><span>    </span>Actions actions = <span>new </span>Actions(<span>driver</span>)<span>;<br/></span><span>    </span><strong>actions.contextClick(contextMenu)</strong><br/><strong>            .click(driver.findElement(By.name("Item 4")))</strong><br/><strong>            .perform()</strong><span><strong>;</strong><br/></span>}</pre>
<p>In the preceding code, first we have right-clicked using the <kbd>contextClick()</kbd> method on the WebElement contextMenu, and then left-clicked on <span class="packt_screen">Item 4</span> from the context menu. This should pop up an alert dialog saying <span class="packt_screen">Item 4 Clicked</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The context click at current location action</h1>
                </header>
            
            <article>
                
<p>Now that we have seen context click on a WebElement, it's time to explore the <kbd>contextClick()</kbd> method at the current mouse location. The API syntax for the <kbd>contextClick()</kbd> method is as follows:</p>
<pre>public Actions contextClick()</pre>
<p>As expected, the preceding method doesn't expect any input parameter and returns the <kbd>Actions</kbd> instance. Let's see the necessary modifications needed for the previous example to use this method. The following is the code refactored to achieve this:</p>
<pre><span>@Test<br/></span><span>public void </span><span>shouldContextClickAtCurrentLocation</span>() {<br/><br/>    <span>driver</span>.get(<span>"http://guidebook.seleniumacademy.com/ContextClick.html"</span>)<span>;<br/></span><span><br/></span><span>    </span>WebElement contextMenu = <span>driver</span>.findElement(By.<span>id</span>(<span>"div-context"</span>))<span>;<br/></span><span>    </span>Actions actions = <span>new </span>Actions(<span>driver</span>)<span>;<br/></span><strong>    actions.moveToElement(contextMenu)</strong><br/><strong>            .contextClick()</strong><br/><strong>            .click(driver.findElement(By.name("Item 4")))</strong><br/><strong>            .perform()</strong><span><strong>;</strong><br/></span>}</pre>
<p>The preceding code first moves the cursor to the <kbd>div-context</kbd> WebElement and then context-clicks it.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning keyboard-based interactions</h1>
                </header>
            
            <article>
                
<p>Until now, we have seen all the actions that can be taken using a mouse. Now it's time to look at some of the actions that are specific to the keyboard in the <kbd>Actions</kbd> class. Basically, there are three different actions that are available in the <kbd>Actions</kbd> class that are specific to the keyboard. They are the <kbd>keyUp</kbd>, <kbd>keyDown</kbd>, and <kbd>sendKeys</kbd> actions, each having two overloaded methods. One method is to execute the action directly on the WebElement, and the other is to just execute the method irrespective of its context.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The keyDown and keyUp actions</h1>
                </header>
            
            <article>
                
<p>The <kbd>keyDown()</kbd> method is used to simulate the action of pressing and holding a key. The keys that we are referencing here are the <em>Shift</em>, <em>Ctrl</em>, and <em>Alt</em> keys. The <kbd>keyUp()</kbd> method is used to release the key that is already pressed using the <kbd>keyDown()</kbd> method. The API syntax for the <kbd>keyDown()</kbd> method is as follows:</p>
<pre>public Actions keyDown(Keys theKey) throws IllegalArgumentException</pre>
<p>An <kbd>IllegalArgumentException</kbd> is thrown when the passed key is not one of the <em>Shift</em>, <em>Ctrl</em>, and <em>Alt</em> keys. The API syntax for the <kbd>keyUp()</kbd> method is as follows:</p>
<pre>public Actions keyUp(Keys theKey)</pre>
<p>The <kbd>keyUp</kbd> action performed on a key, on which a <kbd>keyDown</kbd> action is not already being performed, will result in some unexpected results. So, we have to make sure we perform the <kbd>keyUp</kbd> action after a <kbd>keyDown</kbd> action is performed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The sendKeys method</h1>
                </header>
            
            <article>
                
<p>This is used to type in alphanumeric and special character keys into WebElements such as textbox, textarea, and so on. This is different than the <kbd>WebElement.sendKeys(CharSequence keysToSend)</kbd> method, as this method expects the WebElements to have the focus before being called. The API syntax for the <kbd>sendkeys()</kbd> method is as follows:</p>
<pre>public Actions sendKeys(CharSequence keysToSend)</pre>
<p>We expect you to implement a couple of test scripts around these keyboard events using the <kbd>keyUp</kbd>, <kbd>keyDown</kbd>, and <kbd>sendKeys()</kbd> methods.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have learned how to use the actions class to create a set of actions, and build them into a composite action to execute it in one pass, using the <kbd>perform()</kbd> method. In this way, we can aggregate a series of complex user actions into a single functionality, which can be executed in one pass. In the next <a href="480ab588-a7a3-4592-8b58-1b98060a0568.xhtml">chapter</a>, we will learn WebDriver events and how we can listen and perform advanced actions, using WebDriver.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>True or False – the drag and drop action requires the source element and the target element.</li>
<li>List the keyboard methods that we can perform using the actions API.</li>
<li>Which method of the actions API will help in performing a double-click operation?</li>
<li>Using the actions API, how we can perform a save option (that is to say, <em>Ctrl</em> + <em>S</em>)?</li>
<li>How can we open a context menu using the actions API?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further information</h1>
                </header>
            
            <article>
                
<p><span>You can check the following links for more information about the topics we covered in this chapter:</span></p>
<ul>
<li>Read more about Advanced User Interaction at<a href="https://github.com/SeleniumHQ/selenium/wiki/Advanced-User-Interactions"> https://github.com/SeleniumHQ/selenium/wiki/Advanced-User-Interactions</a></li>
<li>See Chapter 4 : <em>Working with Selenium API</em> in<em> Selenium Testing Tools</em> Cookbook, second edition, by Unmesh Gundecha, and Chapter 6,<em> Utilizing the Advanced User Interactions API</em> in <em>Master Selenium WebDriver,</em> by<em> </em>Mark Collin, for more examples of the actions API</li>
</ul>


            </article>

            
        </section>
    </body></html>