- en: Chapter 9. Taking Our Game to the Next Level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a muzzle flash using ParticleEmitter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a trigger system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a timer trigger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an interaction trigger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling AI with triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a dynamic skybox with a moving sun
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving a scene with postprocessing filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing complex movements with MotionPaths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cutscenes using cinematics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a positional audio and environmental effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So the core mechanics are in and the game is playable, yet it still feels like
    the game lacks something. In this chapter, we will explore different methods to
    enhance games and fuse together some of the recipes from other chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a muzzle flash using ParticleEmitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Weapons of some sort are a common feature of many games and muzzle flashes
    greatly enhance the appearance and feeling when you fire. This recipe will show
    a way to create good-looking muzzle flashes by tweaking a ParticleEmitter''s properties.
    The following screenshot shows a texture with four muzzle flashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a muzzle flash using ParticleEmitter](img/6478OS_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two things needed before we can begin work on the ParticleEmitter:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all we need a texture for the muzzle flash. This can have anything
    from one to several images of muzzle flashes. The texture should be gray scaled.
    We'll add color using `ParticleEmitter`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Secondly, we need to create a `Material` using the texture by performing the
    following steps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right-click on your project's material folder and select **New.../Empty Material
    file**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Particle.j3md** as **Material Definition**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then select the muzzle flash texture as **Texture**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we can begin creating the muzzle flash emitter:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **Emitters** folder in the project and select **New.../Empty
    jme3 Scene**. We should now have a fresh scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the main node in the **SceneExplorer** window and select **Add
    Spatial/Particle Emitter**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the emitter instance and open the **Properties** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the **Shadow Mode** option is **Off** and **Queue Bucket** is **Transparent**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, select the muzzle flash material we created in the **Geometry/Material**
    section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the **Emitter** shape really small, for example, something like `[Sphere,
    0.0, 0.0, 0.0, 0.05]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Num Particles** should be `1`, and **Particles Per Sec** should be `0.0`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Start Color** to something like `[1.0, 1.0, 0.4, 1.0]` and **End Color**
    to `[1.0, 0.6, 0.2, 0.7]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both **Start Size** and **End Size** should be `1.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**High Life** and **Low Life** should be `0.15`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Gravity** and **Face Normal** should be `[0.0, 0.0, 0.0]`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **Facing Velocity** box and set the **Initial Velocity** to`[0.0,
    0.0, 1.0]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Images X** and **Images Y** should reflect the number of frames in the texture
    we created.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can now test the emitter by clicking on the **Emit!** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All these values can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/6478OS_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The muzzle flash works pretty much like a normal ParticleEmitter with a couple
    of exceptions. Instead of outputting a constant stream of particles, it will only
    emit one. This is because **Num Particles** is set to `1`, meaning only one particle
    can be alive at any given time. **Particles Per Sec** is `0.0` so it won't continuously
    emit anything.
  prefs: []
  type: TYPE_NORMAL
- en: The colors are set to be yellowish, turning a bit orange and fading slightly
    at the end of the lifetime; the lifetime being very short in this case, only 0.15
    seconds.
  prefs: []
  type: TYPE_NORMAL
- en: A muzzle flash is emitted in one direction only. This is why we set **Facing
    Velocity** to `true` so that the particle will point in the direction of the velocity.
  prefs: []
  type: TYPE_NORMAL
- en: Getting it to appear in the correct position in relation to the weapon can require
    a bit of tweaking. Using **Local Translation** can help us in this.
  prefs: []
  type: TYPE_NORMAL
- en: To use the muzzle flash on a weapon, open the target in **Scene Composer** and
    then choose **Link in Scene** on the muzzle flash. This way the original file
    can be modified and the changes will automatically appear in the places its being
    used.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the muzzle flash and added it to a weapon, we can create a
    control in order to use it within the game by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `WeaponControl` extending `AbstractControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `ParticleEmitter` field called `muzzleFlash`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `setSpatial` method, check whether the supplied spatial has a suitable
    child, either by type or name (requires that the muzzle flash has a fixed name),
    and set the `muzzleFlash` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create a publicly available `onFire` method and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This control should then be added to the weapon spatial inside the game and
    `onFire` should be called whenever the weapon fires. The class is suitable to
    play sounds and keeps track of ammunition as well.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a trigger system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all story-driven games require some kind of system to trigger some sort
    of event for example, dialogs, enemies, or doors opening. Unless the game is very
    small, you generally don't want to hardcode these. The following recipe will describe
    a trigger system, which can be used for almost any type of game from FPSs to RTSs
    and RPGs.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start out by laying the ground work with an AppState controlling all the
    script objects and the basic functionality of a `Trigger` class. Then, we'll look
    into how to actually activate the trigger and use it for something.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start with the actual implementation, we create a small interface
    that we will use for various scripting scenarios. We call it `ScriptObject` and
    it should have the following three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we can implement the `ScriptObject` in a class called `Trigger`. This
    will have six steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following fields to the `Trigger` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `enabled` and `delay` fields should have getters and setters and `targets`
    should have a `addTarget` and `removeTarget` method publically available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `trigger` method, we add the following functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the script is enabled in the `update` method, we should perform the following
    steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `triggered` is `true` and delay is more than 0, the timer should be increased
    by tpf.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then if the timer is more than or equal to delay, it should call `onTrigger()`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If delay is 0 and `triggered` is `true`, the timer should also call `onTrigger()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `onTrigger` method, we should parse through all the values of `targetsMap`
    and call the trigger on them. Then `triggered` should be set to `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, perform the following set of steps to control the `Trigger` class.
  prefs: []
  type: TYPE_NORMAL
- en: We define a new class called `ScriptAppState`, which extends `AbstractAppState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It should have a `List<ScriptObject>` called `scriptObjects`, together with
    methods to add and remove ScriptObjects from `List`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `update` method, if `isEnabled()` is `true`, it should parse `scriptObjects`
    and call an update on all of the ScriptObjects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we have a flexible system where one `ScriptObject` can trigger another.
    We''re still lacking input and output effects though. One common way to trigger
    events is when a player enters an area. So let''s go ahead and add that functionality
    by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `EnterableTrigger`, which extends `Trigger`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This trigger needs a `Vector3f` field called `position` to define its place
    in the physical world along with a getter and setter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `BoundingVolume` field called `volume`. In the `setter` method for this,
    we should call `volume.setCenter(position)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, it needs a `List<Spatial>` called `actors` along with `add` and `remove`
    methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we should override the `update` method and then call the trigger if any
    item in the `actors` list is inside `volume`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We've taken care of the triggering now. Let's actually do something with that
    trigger by creating a new class called `SpawnTarget`, implementing `ScriptObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like the `EnterableTrigger` class, the `SpawnTarget` class needs a `position`
    field and also a `Quaternion` field called `rotation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `SpawnTarget` class also requires a `Spatial` field called `target` and
    a Boolean field called `triggered` to know whether it's been triggered yet or
    not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should also add a `Node` field called `sceneNode` to attach the target to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `trigger` method, we should check whether it has been triggered already.
    If not, we should set `triggered` to `true` and call `onTrigger`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `onTrigger` method should apply the position and rotation to the target
    and attach it to the `sceneNode`. Depending on the implementation, we might want
    to subtract the `worldTranslation` and `worldRotation` values from the values
    we apply:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s have a look at another common game object that can be picked up. In
    many games, characters can pick up various power-up weapons or other items simply
    by walking over them. This section will have the following eight steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new class called `Pickup` extending `Trigger`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like `EnterableTrigger`, the `Pickup` class needs a position and a `List<Spatial>`
    called `actors`. We also need to add a `Spatial` field called `triggeringActor`
    and a float called `triggeringDistance`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this class, we also need something to pick up, represented here by an interface
    called `Pickupable`. In addition, we need to keep track of whether it's been picked
    up by a Boolean called `pickedUp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The difference between the previous ScriptObjects we've worked with and the
    current ScriptObjects is that the one in this recipe should be visible in the
    world, represented by a `Spatial` called `model`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `update` method, we should check whether the `Pickup` object is enabled
    and not `pickedUp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make it stand out a bit in the game world, we rotate the model a little bit
    by applying the `model.rotate(0, 0.05f, 0)` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Still inside the `if` clause, we check that `actors` is not null and parse
    through the list. If any of the actors is inside the radius of the `triggerDistance`,
    we set it to be `triggeringActor` and call the `trigger` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, in the `onTrigger` method, we should set `pickedUp` to `true`, detach
    `model` from scene graph and call `pickupObject.apply(triggeringActor)` to have
    it apply whatever the `Pickupable` object is supposed to do.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Trigger` class has a fairly simple functionality. It will wait for something
    to call its `trigger` method.
  prefs: []
  type: TYPE_NORMAL
- en: When this happens, it will either trigger all the connected ScriptObjects immediately
    or if a delay is set, it will start counting until the time has passed and then
    execute the trigger. Once this is done, it will be set up so it can be triggered
    again.
  prefs: []
  type: TYPE_NORMAL
- en: The `ScriptAppState` state is a convenient way to control the scripts. Since
    the `AppState` is either disabled or not attached to the `stateManager`, no call
    to `update` in `ScripObjects` is made. This way, we can easily disable all the
    scripting if we want to.
  prefs: []
  type: TYPE_NORMAL
- en: To create a working example with `Trigger`, we extended it into a class called
    `EnterableTrigger`. The idea with the `EnterableTrigger` class was that if any
    of the supplied actor spatials enter its `BoundingVolume` instance, then it should
    trigger whatever is connected to it.
  prefs: []
  type: TYPE_NORMAL
- en: The basic `Trigger` method doesn't have the need for a position as it is a purely
    logical object. The `EnterableTrigger` object, however, has to have a relation
    to the physical space as it needs to know when one of the actors has entered its
    `BoundingVolume` instance.
  prefs: []
  type: TYPE_NORMAL
- en: This is true for `SpawnTarget` as well, which in addition to a location should
    have a rotation, to rotate a potential enemy in a certain direction. Spawning
    characters or items in games is commonly used to control the gameplay flow and
    save some performance. The `SpawnTarget` option allows this kind of control by
    adding new spatials only when triggered.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy for how to perform spawning might differ depending on the implementation
    but the way described here assumes it involves attaching the target `Spatial`
    to the main node tree, which would generally activate its update method and controls.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, the `rootNode` of the scene graph is not necessarily the best choice
    to attach the target to and depends a lot on the game architecture. It could be
    any `Spatial`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in this recipe, we created a `Pickup` object, which is very common in
    many games. These can be anything from items that increase health instantly or
    weapons or other equipment that are added to an inventory. In many cases, it's
    similar to the `EnterableTrigger` except it only requires a radius to see whether
    someone is within the pickup range or not. We keep track of the actor that enters
    it so that we know who to apply the pickup to. In this recipe, the pickup is represented
    by an object called `Pickupable`.
  prefs: []
  type: TYPE_NORMAL
- en: Once it's picked up, we set `pickedUp` to `true` so that it can't be picked
    up again and detach the model from the node tree to make it disappear. If it is
    a recurring power up, a delay can be used here to make it available again after
    some time.
  prefs: []
  type: TYPE_NORMAL
- en: Pickups in games usually stand out from other objects in the game world to draw
    attention to them. How this is done depends on the game style, but here we apply
    a small rotation to it in each call to the `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: Since `Pickup` also extends `Trigger`, it's possible to use it to trigger other
    things as well!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a timer trigger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Creating a trigger system* recipe, we laid the foundation for a `Trigger`
    system as well as created some basic implementations. A timer can be very useful
    when creating complex scripts that rely on timing or sequenced events. Not only
    does it do the obvious (trigger the blast of the door and then the soldiers running
    through) but it can also work as a relay trigger in case many things should be
    triggered at the same time. In this recipe, we'll create this `Timer` object as
    well as an actual implementation of it where it triggers an explosion with several
    components. To save some time, we'll use the `TestExplosion` test from jMonkeyEngine
    to get `ParticleEmitters` set up and the timing for free. We'll also create a
    new `ScriptObject` called `PlayEffect`, which controls the particle emitters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be able to control a `ParticleEmitter` object from our script system, we
    need a new class to handle the `ParticleEmitter` object:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new class called `PlayEffect`, which implements `ScriptObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `PlayEffect` class needs a Boolean called `emitAllParticles`, a `ParticleEmitter`
    field called `effect`, and a Boolean to control whether it's enabled or not (default
    it to `true`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `trigger` method should call `onTrigger` if the object is enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `onTrigger` method should enable `effect` and if `emitAllParticles` is `true`,
    it should call `emitter.emitAllParticles()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Apart from the setter methods, this is all that''s needed for the `PlayEffect`
    class. Now, we can look at the `Timer` class by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new class called `Timer`, which implements `ScriptObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It will use a simple callback interface to keep track of events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It needs two Boolean fields. One called `enabled` and another called `running`.
    It also needs to keep track of time with three floats called `time`, `lastTime`,
    and `maxTime`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will store the events in `HashMap<Float, TimerEvent>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need a method to add events to the timer. Call it `addTimerEvent` and add
    inputs for `time` in seconds to execute the event, as well as a `TimerEvent` object
    with the code to execute it. After `TimerEvent` is placed in the `timerEvents`
    map, we check whether the supplied `time` value is higher than the current `maxTime`
    and set `maxTime` to `time` if true, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `trigger` method should call `onTrigger`, if it is enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `onTrigger` method should set time to `0` and set `running` to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `update` method should first check whether the `Timer` is `enabled` and
    `running`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is, tpf should be added to the time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `same` statement, we then create an iterator based on `keySet` of
    `timerEvents` and parse through it. If the key (a float) is more than `lastTime`
    and less or equal to the current time, we should get the corresponding value from
    the `timerEvents` map and execute it. Otherwise, if the key is less than `lastTime`,
    we should just continue using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Outside of the previous loop, we check if `time` is more than `maxTime`, in
    which case, we should set `running` to `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally in the `update` method, we set `lastTime` to be equal to `time`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the basic logic done, let''s take a look at how we can use the timer for
    something real and use it to trigger an explosion by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `TestExplosion` class from jMonkeyEngine's test package and strip it
    from everything except the methods that create `ParticleEmitters` and the lines
    in `simpleInitApp`, which uses them and sets up the camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, create a `PlayEffect` instance for each of `ParticleEmitters` and set
    the effect accordingly with `emitAllParticles` set to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `Timer` instance called `explosionTimer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new `TimerEvent` at time 0 where it triggers the `flash`, `spark`, `smoke`,
    `debris`, and `shockwave` effects, by calling `trigger()` on each of the `PlayEffects`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, add another `TimerEvent` at time `0.05f`, which triggers the `flame` and
    `roundSpark` effects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last `TimerEvent` should happen at time `5f` and should call `stop()` on
    all of the effects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we create a `ScriptAppState` instance to which we add `explosionTimer`
    and then add it to `stateManager` using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we can trigger `explosionTimer`. It should perform the explosion in the
    same way as `TestExplosion` does.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once triggered, `Timer` works by checking the time that has passed since it
    was started (`time`). It then checks each of the events in the `timerEvents` map
    to see whether their execution time is anywhere between the current time and the
    last time (`lastTime`). The `maxTime` option is used by the `Timer` to know when
    it has executed the last of its events and can switch itself off. If the `Timer`
    was only meant to be used once, the events can simply be removed from the `timerEvent`
    map. This way it can be reused.
  prefs: []
  type: TYPE_NORMAL
- en: The `PlayEffect` instance has a fairly simple functionality to turn it on and
    off. Since `ParticleEmitters` can be used in two ways, fire all their particles
    at once, or emit a continuous stream of particles, it needs to know which way
    to fire it.
  prefs: []
  type: TYPE_NORMAL
- en: In the example application, we create `ScriptAppState` since it's needed to
    update the `Timer` with the passed time. We don't need to add the `PlayEffect`
    instances since they don't use the `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an interaction trigger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common trigger is the one where an action from the player is required.
    For example, you can use it to open a door, or access an in-game store system
    or dialog.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We begin by creating a new class called `InteractionTrigger`, which extends
    `Trigger` and also implements `ActionListener`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `InteractionTrigger` class needs a `Vector3f` field called position, a `BoundingVolume`
    field called `volume`, a `Spatial` field called `player`, and a `boolean` field
    called `inside`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Furthermore, the `InteractionTrigger` class needs access to the application's
    `guiNode`, which we store in a `Node` field with the same name and a `BitmapText`
    field called `interactionPrompt`. The text will be displayed when interaction
    is possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also have to define a static string called `INTERACTION_KEY = "Interact"`
    either in this class or the `input manager` class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `update` method will check whether the player is inside `BoundingVolume`.
    If it is and `inside` is `false`, it will show `interactionPrompt`. On the other
    hand, if `inside` is `true` and the player is not inside `BoundingVolume`, it
    will remove it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the implemented `onAction` method, we check for when the key corresponding
    to `INTERACTION_KEY` is released. Then, we see whether the trigger is enabled
    and whether `inside` is `true` or not. If both are `true`, we call `trigger()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Some logic outside the class is required to get the trigger to work. Apart
    from supplying `guiNode` and `BitmapText` to the trigger, the `INTERACTION_KEY`
    needs to be bound to `inputManager`. This can be done with the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `InteractionTrigger` instance also needs to be added as a listener to `inputManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InteractionTrigger` instance has several things in common with `EnterableTrigger`,
    which we created in the *Creating a trigger system* recipe, and it also has a
    new functionality. Rather than firing the trigger as soon as the player enters
    it, it sets the `inside` flag, which defines whether it's possible to interact
    with it or not. It also displays a text on the GUI for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `InteractionTrigger` receives a call to its `onAction` method from
    `InputManager`, it checks whether `inside` is `true` and calls `trigger`. To brush
    up your knowledge on how input is handled, check out [Chapter 2](ch02.html "Chapter 2. Cameras
    and Game Controls"), *Cameras and Game Control*.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling AI with triggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. Artificial Intelligence"), *Artificial Intelligence*,
    deals with several methods to control AI in games. As we learned in that chapter,
    control and predictability are very important. Even if we have the smartest AI
    in the world, as programmers, we want to be able to know that the AI will perform
    a certain action at a certain time. This is where triggers can be extremely useful.
    In fact, with a good trigger system there might not be need for much AI at all.'
  prefs: []
  type: TYPE_NORMAL
- en: One example of trigger usage might be a warehouse where guards are in a patrolling
    state. Once the player reaches a certain area (maybe where they should not go),
    an alarm is triggered. At this point, we also want the guards to switch to a more
    aggressive state.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will link the trigger system we created previously in the chapter
    with the StateMachine-based `AIControl` class from the *Decision making – Finite
    State Machine* recipe in [Chapter 5](ch05.html "Chapter 5. Artificial Intelligence"),
    *Artificial Intelligence*. Even if you haven't followed the recipes in [Chapter
    5](ch05.html "Chapter 5. Artificial Intelligence"), *Artificial Intelligence*,
    but have a different class controlling AI, it should be quite easy to adapt this
    recipe to accommodate that class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with the previous examples, we begin by creating a new class that extends
    the `ScriptObject` interface. We can call it `AIScriptControl`.
  prefs: []
  type: TYPE_NORMAL
- en: It needs to have an `AIControl` field called `aiControl` and a `Class<AIState>`
    field called `targetState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It might also have a `Spatial` called `target`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we add a Boolean called `enabled`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its `trigger` method, we should call `onTrigger` if `enabled` is `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `onTrigger` method, we apply `targetState` to `aiControl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If `target` is not null, we call `aiControl.setTarget(target)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `StateMachine` for the `AIControl` we created was a closed system and it
    didn't need any external input to change the states. Now, we need to be able to
    trigger it externally so let's add a setter method in the `AIControl`. Create
    a new method called `setState`, which takes a `Class<AIState>` called `state`
    as an input parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside, we check whether `spatial` has the supplied state, and enable it if
    possible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe follows the pattern we established in the *Creating a trigger system*
    recipe. In the `onTrigger` method, we apply `targetState`, which will change the
    behavior and actions of the AI. For example, it can change from `PatrolState`
    to `AttackState`. We only supply the class type and not a whole instance of the
    class since the AI should already have the state and it might be configured already.
    In this way, we tell the AI to simply change the state if it is available. We
    also have a `target` field, in case the new state requires that.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It doesn't have to end with that. We can, for example, with some modification
    trigger the AI to start walking a path, turn in a certain direction, or take cover
    and other things. This functionality can either be built into this class or be
    made as separate classes.
  prefs: []
  type: TYPE_NORMAL
- en: To explore an example in detail, let's have a look at what will be needed to
    have the AI move to a specific location once `AIScriptControl` is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: We will need an `AIState`, which handles moving to a set location. [Chapter
    5](ch05.html "Chapter 5. Artificial Intelligence"), *Artificial Intellegence*,
    explains this. The `SeekCoverState` can easily be modified to only have a `target`
    field rather than a list to choose from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will need something to function as a waypoint or target. Again, the `CoverPoint`
    control from the same recipe can function as a waypoint too. It can also be extended
    so that using cover at `WayPoint` is an option within the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will need to pass `WayPoint` to the state. Since we're not supplying
    a whole class, we can't set it in `AIState` itself. One way would be to pass it
    through the `setTarget` method of `AIControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a dynamic skybox with a moving sun
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered how to create static skyboxes in [Chapter 1](ch01.html "Chapter 1. SDK
    Game Development Hub"), *SDK Game Development Hub*. While they are fine for many
    implementations, some games require day and night cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will show us how to create a moving sun, which can be superimposed
    on a regular skybox. In this case, a neutral skybox without any protruding features
    such as mountains will work best. We'll also learn how to make a sky that changes
    color during the day. In this case, no skybox is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need a texture that should have a transparent background with
    a filled, white circle in it, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6478OS_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We begin by creating a new application class extending `SimpleApplication`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `simpleInitApp` method, we first need to create `Geometry` for the sun:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to set some rendering hints on it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we can load a `Material` instance based on the unshaded material definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For `ColorMap`, we load the texture with the white circle in it and apply the
    texture. Then, for `Color` we can set an almost white color with a tint of yellow
    in it. We also have to enable alpha in the material:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So, the basic `Geometry` is set up and we can create a `Control` class to move
    the sun across the sky by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class called `SunControl`, which extends `AbstractControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It should have a `float` field called `time`, a reference to the application
    camera called `cam`, a `Vector3f` field called `position`, and a `DirectionalLight`
    field called `directionalLight`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `controlUpdate` method, we start by finding the `x` and `z` positions
    based on the time and multiply the result to move it some distance away. We can
    also make the sun move up and down by doing the same for the `y` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we should set `localTranslation` of the sun. Since we want it to appear
    to be very far away, we add the camera''s location. This way it will always appear
    to be the same distance from the camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also want the sun to always face the camera. This is easily done by calling
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the `directionalLight` field is set, we should also set its direction. We
    get the direction by inverting `position`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we increase the `time` value by a factor of `tpf` (depending on how
    fast we want the sun to move). Since two PI in radians make up a circle, we start
    over once `time` exceeds that value, using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Going back to the `application` class, we add the control to the `Geometry`
    sun and `Geometry` to the scene graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The previous implementation can be enough for many games but it can be taken
    much further. Let''s explore how to make the sun color dynamic based on its height
    above the horizon and how to also have a dynamic sky color by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let's introduce two static `ColorRGBA` fields in the `SunControl`
    class called `dayColor` and `eveningColor`. We also add another `ColorRGBA` field
    called `sunColor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `controlUpdate` method, we take the `y` value of the sun and divide it
    so that we get a value between `-1` and `1`, and store this as the height.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ColorRGBA` has a method to interpolate two colors that we can use to get a
    smooth transition during the day:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After this, we set the color of `directionalLight` to the same as `sunColor`
    and also set the material''s `Color` parameter to the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Handling the sky color will take a bit more work. To do this, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by creating a new class called `SkyControl` extending `AbstractControl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Like `SunControl`, the `SkyControl` class needs a `Camera` field called `cam`.
    It also needs a `ColorRGBA` field called `color` and three static `ColorRGBA`
    fields for different times in the day:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `SkyControl` class needs to know about the sun's location so we add a `SunControl`
    field called `sun`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `controlUpdate` method, we set the `localTranslation` of the spatial
    to the location of the `cam`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we get the sun''s height and if it is higher than 0, we interpolate the
    color between `eveningColor` and `dayColor`. Otherwise, we interpolate between
    the `eveningColor` and `nightColor` instead. Then, we set the resulting color
    in the sky''s material''s `Color` parameter, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Going back to the `application` class, we create a box shaped `Geometry` called
    `sky`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: for the control with `10f` sides.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like the sun geometry, sky should have the Sky `QueueBucket`, `ShadowMode.Offand
    CullHint.Never` settings applied to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition, we should call `getAdditionalRenderState` and set `FaceCullMode`
    to `FaceCullMode.Off`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Always causing the geometries of this recipe follow the camera around is one
    of the parts that make this recipe work. The other trick is using the Sky `QueueBucket`.
    The Sky `QueueBucket` can be thought of as lists of items to be rendered. Everything
    in the Sky bucket is rendered first. Because it's rendered first, other things
    will be rendered on top of it. This is why it appears to be far away even though
    it's really close to the camera.
  prefs: []
  type: TYPE_NORMAL
- en: We also use the direction of the sun from the camera for `DirectionalLight`
    in the scene, making it follow the sun as it moves across the sky.
  prefs: []
  type: TYPE_NORMAL
- en: When updating the control, we handle the movement of the sun using the `time`
    value, which increases with each update. Using `FastMath.sin` and `FastMath.cos`
    for the `x` and `z` values, we get it to move in a circle around the camera. Using
    `FastMath.sin` again for the `y` value will move it in an arc above (and below)
    the horizon. By multiplying the `y` value, we can get it to rise higher in the
    sky.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting position was added to the camera's location to always make the
    sun centered around the camera. Since the sun is a simple quad, we also had to
    rotate it to face the camera with every update.
  prefs: []
  type: TYPE_NORMAL
- en: We went on to change the color of the sun based on the height above the horizon.
    We used the interpolate method of `ColorRGBA` to do this. Interpolation requires
    a value between `0.0` and `1.0`. That's why we needed to divide the `y` value
    by the max `y` value (or amplitude) in the case where we've multiplied it earlier
    to get a higher arc in the sky.
  prefs: []
  type: TYPE_NORMAL
- en: The movement of the box simulating the sky is similar. We just keep it centered
    around the camera so that even if it's a small box, it appears to cover the whole
    sky. Normally, we wouldn't see the sides of the box when we're inside it so we
    set `FaceCullMode` to `Off` to always make it render the sides.
  prefs: []
  type: TYPE_NORMAL
- en: '`SkyControl` was fitted with three instances of `ColorRGBA: dayColor` with
    a bluish tint, `eveningColor` with orange, and `nightColor` almost black. The
    `SunControl` was supplied to the control and used to interpolate between the colors
    based on the height of the sun. Anything above `0.0f` is considered day.'
  prefs: []
  type: TYPE_NORMAL
- en: In this implementation, the whole sky changes color with the sun. Any further
    development of `SkyControl` could include a more complex shape, such as a cylinder
    or sphere where only the vertices on the same side as the sun change color. Clouds
    can be implemented and they also use a quad that moves in the xz-plane.
  prefs: []
  type: TYPE_NORMAL
- en: Another improvement would be to have a night-time, star-filled skybox outside
    of the box we made and fade the alpha value of `nightColor` to let it gradually
    shine through the night time.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we try the recipe with the unshaded material definition for the sky, it will
    work well in most cases. However, when it comes to the postprocessor water filter,
    it will not pick up the sky color properly. To achieve this, we will have to make
    some modifications to its material. We don't need to actually change any of the
    `.vert` or `.frag` files, but can create a new `Material Definition (.j3md)` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things as easy as possible, we can copy the `Unshaded.j3md` file. Refer
    to the following code within the `Unshaded.j3md` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the previous line with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This means we'll be using the vertex shader normally used by the Sky material
    to handle the positions of the vertices for the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to change the `WorldParameters` segment to contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Improving a scene with postprocessing filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Creating dynamic skybox with moving sun* recipe, we created a dynamic
    skybox that has many applications. It's possible to improve the appearance of
    this (and any other) scene significantly with postprocessing filters. They are
    called postprocessing filters because they are applied after the scene has already
    been rendered. This also makes them affect everything in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered how to create an advanced postfilter in [Chapter 1](ch01.html
    "Chapter 1. SDK Game Development Hub"), *SDK Game Development Hub*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sun we have is now moving across the sky. It has very sharp edges and we
    can use a bloom filter to smooth it out a bit. Perform the following steps to
    improve a scene with the help of postprocessing filters:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to create a new `FilterPostProcessor` instance called
    `processor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add this to the main view port, by calling `viewPort.addProcessor(processor)`
    from within the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we create a new bloom filter called `bloomFilter`. The default settings
    will produce a decent result, but it might be worth playing around a bit with
    the settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `bloomFilter` to `processor.addFilter(bloomFilter)` and try it again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we create a new `LightScatteringFilter` instance called `lightScatteringFilter`
    and add it again to `processor.addFilter(lightScatteringFilter)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is dependent on a position for the light to scatter, so we need to make
    it aware of the sun's location. We can achieve this by adding a new field for
    the filter in the `SunControl` class from the last recipe along with a setter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then in the `controlUpdate` method, once we have updated `position`, we add
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We still have some tweaking to do as it will now also apply the effect when
    the sun is below the ground. To mitigate this, we can disable the filter during
    nighttime:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `FilterPostProcessor` acts as a container for the filters and applies them
    to the rendered result. Several filters can be added to the same processor and
    the order matters. If we add `LightScatteringFilter` before `bloomFilter`, we
    will get bloom applied to the light scattering and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: The `bloomFilter` works by blurring the image slightly and intensifying colors,
    making the result appear a bit softer. Bloom filters work best with tweaking and
    shouldn't just be slapped on to the scene. It's easy to be impressed by the initial
    effect and leave it at that but it should always be adapted to the art style of
    the game. A fantasy game in an enchanted forest might get away with more bloom
    than a hard-boiled cyberpunk shooter.
  prefs: []
  type: TYPE_NORMAL
- en: The `LightScatteringFilter` instance does two things. Firstly, it creates a
    halo of rays emanating from the direction of the light source. Secondly, if the
    camera is pointing towards the light source, it will whiteout the image increasingly,
    simulating glare.
  prefs: []
  type: TYPE_NORMAL
- en: In a normal skybox, the sun would be static but in this example the sun keeps
    moving. By supplying the filter to `SunControl`, we could keep the logic to update
    the position within that class. We will also get some weird effects as the glare
    will still show. The easy way out is to simply turn off the effect as the sun
    gets below the horizon.
  prefs: []
  type: TYPE_NORMAL
- en: Performing complex movements with MotionPaths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Players in games have been obliged to jump on moving platforms since the dawn
    of gaming. Even with the incredibly advanced games of today, it's not uncommon
    to encounter this most primitive game mechanic albeit with better graphics. There's
    also a popular retro genre that calls for the same, not the least for mobile games.
  prefs: []
  type: TYPE_NORMAL
- en: How do we do that in jMonkeyEngine? One way is, of course, to simply use move
    or `setLocalTranslation` on geometries. This can quickly get complex if we want
    to make sequenced paths. A better option is to use MotionPaths and MotionEvents.
  prefs: []
  type: TYPE_NORMAL
- en: A `MotionPath` object is basically a set of waypoints through which an object
    will move in an interpolated way meaning the movement will be smooth. The `MotionEvent`
    is the control class defining when and how the object should move along the `MotionPath`
    object. It can define how an object should be rotated along the path and if and
    how the path should be cycled through.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll check out how to use them for a game, which could be a
    side-scrolling 2D game, but the same principles can be used to create advanced
    cinematic cutscenes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s begin by creating a platform object to move, by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a new `Geometry` called `platform` and apply the `Unshaded` material
    to it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we attach the `platform` object to `rootNode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we define a new `MotionPath` object called `path`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We add 8 waypoints in a circular pattern, using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we call `path.setCycle(true)` to make it connect the first and last waypoints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can define a new `MotionEvent` called `event` and supply `platform`
    and `path` in the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call `event.setInitialDuration(10f)` and `setSpeed(1f)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we call `event.setLoopMode(LoopMode.Loop)`.![How to do it...](img/6478OS_09_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Debug MotionPath with red waypoints
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Optionally, we can visualize the path by calling the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, all we need to do is call `event.play()` to start the event!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `for` loop creates eight waypoints along a circle at 45 degrees distance
    from each other. However, to make a complete circle the first and last waypoints
    need to be connected or the path will stop at the final one. This is why `setCycle(true)`
    must be set. This is treated as the ninth waypoint at the same position as the
    first.
  prefs: []
  type: TYPE_NORMAL
- en: MotionEvent's `initialDuration` is the time it should take to complete the path.
    The speed defines the factor at which the `initialDuration` should be completed.
    So, setting the speed to 2f will halve the actual time it takes for the object
    to complete its movement. The `loopMode`, not surprisingly, defines whether the
    object should stop once it has completed the path, or continue. There's also an
    option to make it go back the same path again with `LoopMode.Cycle`. This is not
    related to MotionPath's `setCycle` method.
  prefs: []
  type: TYPE_NORMAL
- en: While this recipe doesn't explore the option, it's possible to have the spatial
    in `MotionPath` perform various types of rotation. By default, no rotation will
    be applied. By calling `setDirectionType` it is possible to, for example, let
    the object follow the path's rotation (face the direction of the path) or rotate
    by a fixed amount or always face a certain point. Some of the direction types
    require a rotation to be supplied with the `setRotation` method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, the object is moving along its given path and we can add several platforms
    moving in different patterns. Let's say we want something to happen once a platform
    reaches the end of its path. Maybe it should start the next one or trigger one
    of our ScriptObjects from the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that case, we can use `MotionPathListener`. This is an interface with a
    callback method called `onWayPointReached`, which will be called every time the
    path passes a waypoint. It will supply both the `MotionEvent` and the `index`
    of the waypoint. If we want to trigger something at the end of the path, it might
    look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Cutscenes using cinematics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe explored the possibilities of using `MotionPaths` to move
    objects around. One step up from that and a way to organize many events in a sequence
    is cinematics. It can be used both to create in-game scripted events and advanced
    cutscenes. The power of a well-scripted in-game event should not be underestimated
    but neither should the time it takes to get one right.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll explore the possibilities of the `Cinematics` system by
    creating a cutscene using content that we have created before.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some basic knowledge of `MotionPaths` and `MotionEvents` is required. Checking
    out the *Performing complex movements with MotionPath* recipe should provide enough
    information to get started. A new class that is introduced is the `Cinematic`
    class. This works as a sequencer or manager of many events firing them at set
    times. The events don't just have to be `MotionEvents` but could be `AnimationEvents`
    dealing with skeleton-based animations, `SoundEvents`, and even `GuiEvents`. It
    can also manage several cameras and switch between them.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting the actual implementation of a cinematic scene, it's good to
    have some kind of script describing what is going to happen. This will help organize
    the cinematic event and will save time in the end.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will use the `TestScene` from [Chapter 1](ch01.html "Chapter 1. SDK
    Game Development Hub"), *SDK Game Development Hub*. We can also use the animated
    sky box from earlier in this chapter. It will display Jaime walking from his initial
    position to stand by the edge of the water looking into the horizon. While he's
    walking, several switches between panning cameras will occur.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/6478OS_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using an empty node as a waypoint
  prefs: []
  type: TYPE_NORMAL
- en: Finding out good waypoints for characters and cameras can be difficult enough
    and it's not any easier if you have to do it all in code. A trick is to use the
    SceneComposer to create markers much like real movie makers use tape to designate
    where actors should move. Right-clicking on the scene node and selecting **Add
    Spatial.../New Node** will give us an invisible marker. Give this a recognizable
    name and drag it into place by using the `Move` function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So now that we have a scene prepared with some waypoints we can get to work
    with implementing the cutscene itself by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by loading a scene where the `Cinematic` will be played out. The scene
    reference will be used in several places, so it is a good idea to store it in
    a field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll also create a `Spatial` field called Jaime, the main actor and either
    load or extract him from the scene (depending on the setup).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can create a `MotionPath` instance called `jaimePath` for Jaime. Since
    we created `Nodes` for each waypoint in `SceneComposer`, we can get their location
    from the scene by using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We go on and create a `MotionEvent` called `jaimeMotionEvent` using `jaimePath`
    and `initialDuration` of 25 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It's also preferable if Jaime faces in the direction of the path he travels
    along, so we also set `directionType` to `MotionEvent.Direction.Path`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we get too far, we want to check out that the path Jaime follows is
    alright. Therefore, we should go ahead and create a `Cinematic` instance at this
    point. To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing this is as simple as supplying it with a scene, which will affect `rootNode`
    together with the total duration of the cinematic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we add `MotionEvent` with the following line; 0 being the time
    it should start at:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We also need to add cinematic to the `stateManager` of the application with
    `stateManager.attach(cinematic)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling `cinematic.play()` at this point should display Jaime sliding along
    the path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we''re happy with it, we can go on and do the camera work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Cinematic` instance will create a `CameraNode` for us if we call `cinematic.bindCamera("cam1",
    cam)`, so let's do that for our first camera. The string is the reference that
    `Cinematic` will know the camera by.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will be a camera that pans so we create a `MotionPath` instance and a `MotionEvent`
    instance for it. Again, we can get the waypoints of the camera path from the scene.
    Since the `Node` we added in `SceneComposer` by default snaps to the ground, we
    need to add between 1.5f and 2.0f to the y axis to get it to a suitable height.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The camera should look at a fixed point as it pans, so we set `directionType`
    of camera''s `MotionEvent` to `LookAt` and then also set the direction it should
    look at with `cam1Event.setLookAt` where the first `Vector3f` is the location
    to look at and the second is `Vector3f`, which is up in the world:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With that done, we can test the first camera pan. We do that by calling the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next camera will get its own `MotionPath` and `MotionEvent` instances and
    can similarly get its own `CameraNode`. It's perfectly fine to use the same physical
    camera for both of the CameraNodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can start doing something about the lack of animation in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing Jaime does in the scene is walk towards the beach. We can create
    a new `AnimationEvent` instance that uses the `Walk` animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then add it to `cinematic` at 0 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Jaime should stop when he reaches the last waypoint, which is also when the
    `jaimeMotionEvent` ends. So we create another `AnimationEvent` with the idle animation
    and add it at the end of the duration of the `jaimeMotionEvent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the time of writing this, it seems the cinematic doesn''t end the animation
    when it starts a new one, so we have to do something to stop it ourselves. Using
    a MotionPathListener, we can check when the final waypoint is reached and manually
    stop the walking animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Cinematic` acts as a sequencer for all the different events and apart from
    firing events at the defined intervals, we can instead use `cinematic.enqueueCinematicEvent`.
    Doing so will start the supplied event just after the previous one is done. This
    can be useful if we want to trigger a series of animations right after each other.
    Cinematics can also be set to loop or cycle just like `MotionEvents` and you don't
    need to start them at time 0.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, using cinematics is not particularly technical. It's just difficult
    to get all the positions, angles, and timings right, especially since there's
    no intelligence or collision involved in the script. Once you get it right, however,
    the result will be extremely rewarding.
  prefs: []
  type: TYPE_NORMAL
- en: Using a positional audio and environmental effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Audio is an incredibly powerful mood setter and should not be overlooked in
    a game. In this recipe, we'll go through how to make the most of your sound assets
    using runtime effects and settings. If you're simply looking for omnipresent sounds
    or the basics on how to play them, check out [Chapter 1](ch01.html "Chapter 1. SDK
    Game Development Hub"), *SDK Game Development Hub*.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will do well in an FPS, where you have a number of footstep sounds
    that are played when the player moves around. However, the principle is true for
    any short sound that is played often enough to sound repetitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll approach this recipe in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will learn how to vary a basic, repetitive sound. We can achieve this
    by varying the sound's pitch and using `LowPassFilter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the second step, we'll use reverb to vary it further, depending on the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, we need some basics set up.
  prefs: []
  type: TYPE_NORMAL
- en: We create a new application extending `SimpleApplication`, and add an `AudioNode`
    field called `audioNode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition to this, we need to keep track of passed time with a `float` field
    called `time` and another `float` field called `pauseTime`, which we set to `0.7f`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `simpleInitApp` method, we create a new `audioNode` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We override the `simpleUpdate` method and begin by checking whether `time` is
    more than `pauseTime`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If it is, we should set a new float called `pitch`. This should have a value
    of `1f +- 10%`, which can be achieved with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we call `audioNode.setPitch(pitch)` to set it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since this particular sound file plays four footsteps in sequence, we tell
    the node to not start from the beginning and only play the last of the footsteps
    by skipping forward in time, using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before exiting the `if` statement, we set `time` to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we shouldn't forget to increase `time` by tpf.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try running the application now. We should hear the same sound over and over
    again but with a slight variation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use `LowPassFilter` to further vary the sound. We instantiate it by
    supplying a float for the general volume, and another for the high frequency volume.
    To get the most variation, we can supply two random values between 0f and 1f:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we call `audioNode.setDryFilter(filter)` before `audioNode.playInstance()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we play it again, we should hear a slightly more varied sound that from
    time to time gets more muffled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reverb is another parameter we can use for our sounds. But unlike the previous
    examples, this should not be randomized each time we play it (or randomized at
    all!). We can add reverb using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new instance of `Environment` in the `simpleInitApp` method using
    one of the premade static ones in the `Environment` class and telling the application''s
    `audioRenderer` to use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running the application again with this environment should give each footstep
    a huge echo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first part of the recipe, we varied a single sound by changing its pitch
    slightly every time it was played. This will still sound repetitive and it is
    recommended to have several premade variants of a sound and use it in combination
    with this technique to get more out of them.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this, filters are not developed past `LowPassFilter`
    and have a limited use. It can still be used to cut the dryness of the sound and
    make it more muffled, as if heard through a wall, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Having a sound file with a sequence of footsteps, like the one in the test-data
    library is fine for some types of games. They work best when you know how far
    a character will move each time, such as in an RTS or turn-based game. In an FPS,
    however, where we don't know how fast or far a player decides to move, it's better
    to have footstep sounds split up and played individually based on movement speed.
  prefs: []
  type: TYPE_NORMAL
- en: Using an `Environment` class is a great way to add immersion to sounds without
    having to bake the effect into the sound file. Controlling the effect unless it's
    level-wide can be a bit trickier. For example, you may want more reverb outside
    than in a furnished room. One way could be to use the trigger system from earlier
    in the chapter and big bounding volumes triggering a change in environment as
    the player enters their area.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we used the `setDryFilter` method of the `audioNode`. This
    will not modify any reverb coming from the environment. To do that, we have to
    use `setReverbFilter`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe has covered playing audio originating from the player. It is almost
    as easy doing this for other entities in the scene. Since `AudioNode` extends
    `Node`, it has a position in the scene graph. Attaching an `AudioNode` instance
    to the scene graph will play the sound using its `worldTranslation` field, just
    like how a model will be shown at that location.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from setting `localTranslation`, we also need to make sure that the positional
    Boolean in `AudioNode` is `true` (which it is by default). We're also only allowed
    to use mono channel sounds when using positional audio.
  prefs: []
  type: TYPE_NORMAL
