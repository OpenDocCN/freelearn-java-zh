- en: Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: As we have seen in the previous chapter, Continuous Delivery pipelines allow
    developers to ship software with constant velocity and quality. In order to meet
    this quality, automated software tests are required. Engineers that work on features
    want to be sure that everything works as expected. This is even more the case
    when the software project advances, changes, and potentially breaks existing behavior.
    Developers need to be sure that no unwanted side-effects are introduced.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，持续交付管道允许开发者以恒定的速度和质量发布软件。为了达到这一质量标准，需要自动化软件测试。从事功能开发的工作者希望确保一切按预期工作。当软件项目发展、变化并可能破坏现有行为时，这一点尤为重要。开发者需要确保没有引入不希望出现的副作用。
- en: Ideally, the software tests contained in a build pipeline are sufficient, without
    further manual verification, to deploy to production.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，构建管道中包含的软件测试足够，无需进一步的手动验证，即可部署到生产环境中。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The requirements of software tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件测试的要求
- en: Different test levels and scopes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的测试级别和范围
- en: Unit, component, integration, system, and performance tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试、组件测试、集成测试、系统测试和性能测试
- en: How to run test scenarios locally
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在本地运行测试场景
- en: How to craft maintainable tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建可维护的测试
- en: Required test technology
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要的测试技术
- en: The necessity of tests
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试的必要性
- en: Tests are necessary to be able to rely on that a certain functionality behaves
    in a certain way later in production. In all kinds of manufacturing businesses,
    tests are a natural part of the process. A car has countless parts that need to
    be tested independently as well as interdependently. Nobody wants to drive a car
    which has its first test run on a real street with the actual customer.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是确保在后期生产中某个功能以特定方式行为所必需的。在所有类型的制造业务中，测试是过程的一个自然部分。一辆汽车有无数个部件需要独立以及相互依赖地进行测试。没有人愿意驾驶一辆在真实街道上首次进行测试跑车的汽车。
- en: Tests simulate production behavior and verify components in a safe environment.
    Manufactured parts that break during test runs are something positive; they have
    just pointed out potential errors and nothing more than time and materials is
    lost. Parts that break in production can cause more harm.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模拟生产行为，并在安全环境中验证组件。在测试运行期间损坏的制造部件是积极的事情；它们只是指出了潜在的错误，而且仅仅损失了时间和材料。在生产中损坏的部件可能造成更大的损害。
- en: The same is true for software tests. Test failures are something positive, at
    worst they used up some time and effort, at best they prevent potential bugs from
    going to production.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于软件测试来说，也是如此。测试失败是积极的事情，最坏的情况是浪费了一些时间和精力，最好的情况是防止潜在的缺陷进入生产。
- en: As seen previously, tests need to run with the least required human interaction
    possible. Humans are good at thinking about reasonable test cases and crafting
    creative test scenarios. Computers, however, are better at executing them. Verifying
    complex tests is something computers also do well, after they have been given
    clear verification instructions. With software growing more complex over time,
    the effort of manually verifying behavior gets bigger and bigger and more prone
    to error over time. Computers perform better and more reliably at repetitive tasks.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，测试需要在尽可能少的人类交互下运行。人类擅长思考合理的测试用例和构建创意测试场景。然而，计算机在执行这些任务方面更胜一筹。在给出明确的验证指令后，计算机也能很好地验证复杂的测试。随着时间的推移，软件变得越来越复杂，手动验证行为所需的努力越来越大，而且随着时间的推移更容易出错。计算机在重复性任务上表现更好，也更可靠。
- en: Reliable automated software tests are a prerequisite of moving fast. Automated
    tests can be executed many times, verifying the whole application. Builds run
    many times a day, execute all tests every time - even if only minor changes were
    introduced - and enable verified versions to go to production. This would not
    be feasible with tests executed by humans.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠的自动化软件测试是快速发展的先决条件。自动化测试可以多次执行，验证整个应用程序。构建每天运行多次，每次都执行所有测试——即使只有微小的更改——并允许经过验证的版本投入生产。如果由人类执行测试，这是不可行的。
- en: Automated tests increase the reliability of and confidence in the Continuous
    Delivery process. For Continuous Deployment, that is, going directly to production,
    sufficient, automated test scenarios are absolutely required. When all commits
    are potential candidates for production deployment, all software behavior must
    be adequately verified upfront. Without this automated verification, Continuous
    Deployment wouldn't be possible.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试提高了持续交付过程的可靠性和信心。对于直接进入生产的持续部署来说，绝对需要足够的自动化测试场景。当所有提交都是生产部署的潜在候选者时，所有软件行为都必须在事先得到充分验证。没有这种自动化验证，持续部署将不可能实现。
- en: Requirements of well-crafted tests
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优秀测试的要求
- en: Today's software world has agreed that tests are crucial to working software.
    But what makes a good software test? What software components do we have to test?
    And, more importantly, how can we develop well-crafted tests?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当今的软件世界普遍认为测试对工作软件至关重要。但什么是一个好的软件测试？我们必须测试哪些软件组件？更重要的是，我们如何开发精心设计的测试？
- en: 'In general, tests should fulfill the following requirements:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，测试应满足以下要求：
- en: Predictability
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可预测性
- en: Isolation
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离性
- en: Reliability
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠性
- en: Fast execution
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速执行
- en: Automation
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化
- en: Maintainability
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可维护性
- en: The following describes these requirements.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下描述了这些要求。
- en: Predictability
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可预测性
- en: First of all, software tests have to be stable, predictable, and reproducible.
    The same project circumstances must predictably produce the same test case outcomes,
    that is, passing or failing. Tests that sometimes pass and sometimes fail are
    not helpful at all. They either distract developers by providing false positive
    results or suppress actual bugs with false negative outcomes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，软件测试必须是稳定的、可预测的和可重复的。必须可预测地产生相同的测试用例结果，即通过或失败。有时通过有时失败的测试根本没有任何帮助。它们要么通过提供假阳性结果来分散开发者的注意力，要么通过提供假阴性结果来抑制实际的错误。
- en: Circumstances that need to be taken into account are, among others, the current
    time, time zones, locales, randomly generated data, and concurrent execution of
    other tests that could interfere. The test scenarios should be predictably and
    explicitly set up, so that these circumstances have no influence on the outcome.
    If the tested functionality is in fact influenced by these factors, this is a
    sign that there is a need for additional test scenarios, considering different
    configurations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的情况包括当前时间、时区、地区、随机生成数据以及其他可能干扰的测试的并发执行。测试场景应可预测且明确设置，以便这些情况不会影响结果。如果测试的功能实际上受到这些因素的影响，这是一个需要考虑不同配置的额外测试场景的迹象。
- en: Isolation
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离性
- en: The requirement of predictability also relates to isolation. Test cases have
    to run self-sufficiently, without affecting other tests. Changing and maintaining
    test cases should also have no impact on other test scenarios.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 预测性的要求也与隔离性相关。测试用例必须独立运行，不得影响其他测试。更改和维护测试用例也不应影响其他测试场景。
- en: Besides leveraging predictability and maintainability, isolating tests also
    has an impact on the reproducibility of errors. Complex test scenarios may contain
    a lot of concerns and responsibilities that can make it hard to find the root
    causes of failing tests. Isolated tests with smaller scope, however, limit the
    possibilities of causes and enable developers to find bugs faster.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了利用可预测性和可维护性之外，隔离测试还对错误的可重复性有影响。复杂的测试场景可能包含许多关注点和责任，这可能会使找到失败测试的根本原因变得困难。然而，具有较小范围的隔离测试可以限制原因的可能性，并使开发者能够更快地找到错误。
- en: The several test scopes an enterprise project usually has, which we will see
    later in this chapter, also come with several test isolation layers. Tests with
    a small scope, such as unit tests, run more isolated than, for example, end-to-end
    tests. It certainly makes sense to write test cases in different scopes, which
    implies different test isolation layers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 企业项目通常具有的几个测试范围，我们将在本章后面看到，也伴随着几个测试隔离层。范围较小的测试，如单元测试，比例如端到端测试运行得更隔离。在不同的范围内编写测试用例，意味着不同的测试隔离层，这当然是有意义的。
- en: Reliability
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可靠性
- en: Ideally, software tests of a project reliably test all functionality. The mantra
    should be that software that passes the tests is ready for production usage. This
    is of course a goal to strive for, for example by continuous improvement.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，项目的软件测试应可靠地测试所有功能。口头禅应该是：通过测试的软件适合生产使用。这当然是一个值得追求的目标，例如通过持续改进。
- en: Using Continuous Delivery and especially Continuous Deployment requires a reliable
    and sufficient test harness. The software tests are the ultimate quality barrier
    before production deployment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用持续交付和特别是持续部署需要可靠且充足的测试环境。软件测试是生产部署前的最终质量屏障。
- en: Reliable tests that pass should not require any further interaction. Therefore,
    they should not output verbose logs if the overall execution was successful. While
    a detailed explanation of what happened during execution is very helpful in failing
    tests, it becomes distracting in passing runs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过的可靠测试不应需要任何进一步的交互。因此，如果整体执行成功，它们不应输出冗长的日志。虽然执行过程中发生的事情的详细解释对于失败的测试非常有帮助，但在通过运行中它变得分散注意力。
- en: Fast execution
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速执行
- en: As said before, tests are required to execute quickly. Fast running tests are
    a necessity for development pipelines providing fast feedback. Especially with
    the number of tests growing over time by applying continuous improvement, the
    only way to keep the pipeline effective is to keep test execution time low.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，测试需要快速执行。快速运行的测试是提供快速反馈的开发管道的必要条件。特别是随着测试数量随着时间的推移通过持续改进而增加，保持管道有效率的唯一方法就是保持测试执行时间低。
- en: Typically, test execution spends the most time in starting up the test technology.
    Integration tests in particular, which use an embedded container, consume a lot
    of startup time. The time spent performing the actual test is in most cases not
    such a big issue.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，测试执行花费最多的时间是启动测试技术。特别是使用嵌入式容器的集成测试，消耗了大量的启动时间。实际执行测试所花费的时间在大多数情况下并不是一个大问题。
- en: Tests that consume a lot of time contradict the idea of continuous improvement
    of quality. The more test cases and scenarios that are added to the project, the
    longer the overall test execution and the slower is the feedback. Especially with
    the challenges of a fast-moving world, software tests need to perform as fast
    as possible. The rest of this chapter will show you how we can achieve this goal,
    particularly in regard to end-to-end test scenarios.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 耗费大量时间的测试与质量持续改进的理念相矛盾。随着项目中新增加的测试用例和场景越多，整体测试执行时间就越长，反馈就越慢。特别是在快速变化的世界中，软件测试需要尽可能快地执行。本章的其余部分将向您展示我们如何实现这一目标，特别是在端到端测试场景方面。
- en: Automation
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化
- en: Automation is a prerequisite for fast feedback. Continuous Delivery pipeline
    steps should run with the least human intervention as possible. The same is true
    for test scenarios. Executing software tests and validating their results should
    run completely and reliably without human interaction.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化是快速反馈的前提。持续交付管道步骤应尽可能减少人工干预。测试场景也是如此。执行软件测试和验证其结果应完全且可靠地运行，无需人工交互。
- en: The test cases define the functionality's expected behavior and validate the
    outcome against it. The test will then reliably pass without additional notice
    or fail with a detailed explanation. Passing tests should not require any further
    human interaction.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例定义了功能的预期行为，并验证结果是否符合预期。然后，测试将可靠地通过，无需额外通知，或者在详细说明的情况下失败。通过测试不应需要任何进一步的人工交互。
- en: A scenarios with huge or complex test data in particular represent a certain
    challenge in automating test cases. In order to deal with this issue, engineers
    should craft test cases in a maintainable way.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是具有大量或复杂测试数据的场景，在自动化测试用例方面代表了一定的挑战。为了处理这个问题，工程师应该以可维护的方式编写测试用例。
- en: Maintainability
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性
- en: Developing test cases is one thing. Keeping efficient test cases with good coverage
    when functionality changes is another thing. The challenge with having poorly-crafted
    test scenarios is that as soon as production functionality changes, the tests
    need to change as well, requiring a lot of time and effort.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 开发测试用例是一回事。在功能发生变化时保持高效且覆盖良好的测试用例是另一回事。测试场景设计不当的挑战在于，一旦生产功能发生变化，测试也需要相应地改变，这需要大量的时间和精力。
- en: Crafting test cases requires the same attention and effort as production code.
    Experience shows that without this effort put in, tests contain a lot of duplication
    and multiple responsibilities. In the same way as for production code, test code
    requires refactoring.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试用例需要与生产代码相同的关注和努力。经验表明，如果没有投入这种努力，测试用例中会包含大量的重复和多重责任。与生产代码一样，测试代码也需要重构。
- en: It should be possible to change or extend test scenarios without much effort
    required. In particular the test data that changes needs to be represented effectively.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 应该能够在不花费太多努力的情况下更改或扩展测试场景。特别是需要更改的测试数据需要有效地表示。
- en: Maintainable tests are a prerequisite for enterprise projects that have proper
    test coverage and yet are flexible for changes in their business logic. Being
    able to adapt in a fast-moving world requires adjustable test scenarios as well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护的测试是企业项目的先决条件，这些项目具有适当的测试覆盖率，同时对其业务逻辑的变化具有灵活性。能够适应快速变化的世界需要可调整的测试场景。
- en: What to test
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要测试的内容
- en: Before we go into the topic of how to craft effective, fast, reliable, automated,
    and maintainable test cases, let's have a look at what assets to test. There are
    tests on a code layer as well as end-to-end tests. Code layer tests are based
    on the project's source code and are usually executed during development and build
    time, whereas end-to-end tests, of all kinds, operate on a running application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨如何创建有效、快速、可靠、自动化和可维护的测试用例之前，让我们先看看需要测试哪些资产。这些测试包括代码层测试以及端到端测试。代码层测试基于项目的源代码，通常在开发和构建时执行，而端到端测试则对所有类型的运行应用程序进行操作。
- en: Depending on the test scopes, which we will get to know in the next section,
    there are different layers of tests, whether tests operate on classes, multiple
    components, enterprise applications, or whole environments. In all cases the test
    object needs to be isolated from external concerns. The nature of tests is that
    they verify certain behavior under specific conditions. The environment surrounding
    the test object, such as the test cases as well as used components, have to interact
    with the test object accordingly. The test case will therefore control the test
    object. This not only includes tests at code level, but also end-to-end tests
    with external systems being simulated and mocked away.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 根据测试范围，我们将在下一节中了解，存在不同的测试层，无论是测试操作在类、多个组件、企业应用程序还是整个环境中。在所有情况下，测试对象都需要从外部关注点中隔离出来。测试的本质是在特定条件下验证某些行为。测试对象周围的环境，如测试用例以及使用的组件，必须相应地与测试对象交互。因此，测试用例将控制测试对象。这不仅包括代码级别的测试，还包括模拟和模拟外部系统的端到端测试。
- en: Most importantly, software tests should verify business behavior. The specified
    use cases all have to perform certain logic that has to be tested before production
    deployment. Software tests should therefore verify that the application fulfills
    the business requirements. Special and corner cases need to be covered as well
    as negative tests.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，软件测试应该验证业务行为。所有指定的用例都必须执行某些逻辑，这些逻辑在生产部署之前必须经过测试。因此，软件测试应该验证应用程序是否满足业务需求。同时，还需要涵盖特殊情况和边缘情况以及负面测试。
- en: For example, testing authentication functionality not only needs to verify that
    a user can log in with the correct credentials, but also that they can not log
    in using wrong the credentials. A corner case of this example would be to verify
    that the authentication component notifies a user whose password is about to expire
    as soon as he logs in successfully.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，测试身份验证功能不仅需要验证用户能否使用正确的凭据登录，还需要验证他们不能使用错误的凭据登录。这个例子中的一个边缘情况是验证身份验证组件在用户成功登录后立即通知密码即将到期的用户。
- en: Besides business behavior, technical aspects and cross-cutting components also
    need to be tested. Accessed databases and external systems and the form of the
    communication is required to be verified on both ends in order to guarantee a
    working team. These concerns are best tested in end-to-end tests.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了业务行为之外，还需要测试技术方面和横切组件。需要验证访问的数据库和外部系统以及通信形式，以确保团队的工作效率。这些关注点最好在端到端测试中进行测试。
- en: In all cases the test object should not be modified during the test, but work
    in the way as it will in production. This is crucial for crafting reliable tests
    that will not alter their behavior later on. For code level tests, this only requires
    that the contents of all involved components are the same. For end-to-end tests,
    this includes the whole enterprise application as well as the installation and
    configuration of the application's runtime.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，测试对象在测试过程中不应被修改，而应按照在生产环境中工作的方式运行。这对于创建不会在以后改变其行为的可靠测试至关重要。对于代码级别的测试，这只需要确保所有相关组件的内容相同。对于端到端测试，这包括整个企业应用程序以及应用程序运行时的安装和配置。
- en: Definition of test scopes
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试范围的定义
- en: There are several test scopes and responsibilities to consider. The following
    will introduce the different scopes the rest of this chapter will cover.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的测试范围和责任有几个。以下将介绍本章剩余部分将涵盖的不同范围。
- en: Certain namings, such as *integation tests*, are used ambiguously in various
    enterprise projects. This sub-chapter defines consistent test scope names that
    are used for the rest of this book.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 某些命名，如*集成测试*，在各个企业项目中使用得模糊不清。本子章节定义了用于本书其余部分的统一测试范围名称。
- en: Unit tests
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests verify the behavior of individual units of an application. A unit
    test usually represents a single class, in some cases a few interdependent classes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试验证应用程序单个单元的行为。单元测试通常代表一个类，在某些情况下是一两个相互依赖的类。
- en: Unit tests operate on code level. They are usually executed in the IDE during
    development as well as part of the build process before the application is packaged.
    Unit tests have the shortest execution time of all test scopes. They only execute
    limited functionality that can be instantiated easily on code level. Potential
    dependencies of the units are simulated using mocks or dummy classes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试在代码级别上操作。它们通常在开发期间在IDE中执行，也是应用程序打包前的构建过程的一部分。单元测试是所有测试范围中执行时间最短的。它们仅执行可以在代码级别上轻松实例化的有限功能。单元的潜在依赖通过模拟或哑类进行模拟。
- en: Component tests
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件测试
- en: Component tests verify the behavior of a coherent component. They span more
    than just an individual unit, but still operate on code level. Component tests
    aim to integrate several components together, which verify the interdependent
    behavior without setting up container environments.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 组件测试验证一个连贯组件的行为。它们不仅跨越单个单元，而且仍然在代码级别上操作。组件测试旨在将多个组件集成在一起，这验证了相互依赖的行为，而无需设置容器环境。
- en: The scope of component tests is to provide more integration than unit tests
    without running the application in potentially slow, simulated environments. Similar
    to unit tests, they use mocking functionality to delimit and simulate test boundaries.
    An embedded or remote enterprise container is not required.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 组件测试的范围是在不运行可能缓慢的模拟环境中的应用程序的情况下提供比单元测试更多的集成。与单元测试类似，它们使用模拟功能来界定和模拟测试边界。不需要嵌入式或远程企业容器。
- en: Integration tests
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: There is a lot of disagreement as to what integration tests represent and how
    they are designed. The aimed integration can happen on various levels.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于集成测试代表什么以及如何设计它们，存在很多分歧。目标集成可以在多个级别发生。
- en: I will use the term as it is quite widely used in the Java ecosystem and as
    it is represented in the Maven conventions. Integration tests run on code level,
    providing integration of several units and components, and usually run some more-or-less
    complex testing framework. This is the main distinction from component tests here.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用这个术语，因为它在Java生态系统中被广泛使用，并且在Maven约定中表示。集成测试在代码级别上运行，提供多个单元和组件的集成，并且通常运行一些更复杂或更简单的测试框架。这是与组件测试的主要区别。
- en: Integration tests have a similar scope as component tests also integrate several
    units; however, the focus is on the integration. This integration is more technology
    than business related. For example, managed beans can make use of CDI injection
    to acquire certain dependencies using qualifiers or CDI producers. Developers
    need to verify whether the CDI *plumbing* has been done properly, that is, the
    correct annotations have been used, without necessarily deploying the application
    to a server.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的范围与组件测试相似，也集成多个单元；然而，重点是集成。这种集成更多与技术相关而不是与业务相关。例如，管理豆可以使用CDI注入通过限定符或CDI生产者获取某些依赖。开发者需要验证CDI*管道*是否已经正确完成，也就是说，已经使用了正确的注解，而无需将应用程序部署到服务器。
- en: Testing frameworks start up an embedded runtime that will build up several components
    and run code level tests against them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架启动一个嵌入式运行时，该运行时会构建几个组件，并对它们执行代码级别的测试。
- en: Component tests, however, solely focus on the business logic and are limited
    to simple dependencies that are easily resolvable without sophisticated containers.
    In general, component tests are preferable for testing business use cases since
    they contain less moving parts and will run faster.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，组件测试仅关注业务逻辑，并且局限于简单依赖，这些依赖容易在没有复杂容器的情况下解决。一般来说，组件测试更适合测试业务用例，因为它们包含的移动部件较少，运行速度更快。
- en: System tests
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统测试
- en: The term system tests is sometimes also used ambiguously. In this context, the
    term covers all test cases that run the application or the system as a whole,
    verifying use cases in an end-to-end manner. Sometimes the terms acceptance or
    integration tests are used respectively. However, this book consistently uses
    the term system tests to refer to end-to-end tests.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: “系统测试”一词有时也模糊地使用。在此上下文中，该术语涵盖了所有运行应用程序或整个系统的测试用例，以端到端的方式验证用例。有时分别使用“验收测试”或“集成测试”等术语。然而，本书始终使用“系统测试”一词来指代端到端测试。
- en: System tests are quite important to verify that a deployed application works
    as expected, including both business logic and technical concerns. Whereas the
    majority of business logic should already be covered by unit and component tests,
    system tests verify that the overall behavior, including all external systems,
    is met. This includes how functionality is integrated and interacts within the
    system landscape.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试对于验证已部署的应用程序按预期工作非常重要，包括业务逻辑和技术问题。虽然大多数业务逻辑应该已经通过单元和组件测试得到覆盖，但系统测试验证的是整体行为，包括所有外部系统，是否符合预期。这包括功能如何在系统景观中集成和交互。
- en: For an application to provide value, it is not sufficient to only include business
    logic, but also how that logic is accessed. This needs to be verified in an end-to-end
    manner.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让一个应用程序提供价值，仅仅包含业务逻辑是不够的，还需要考虑如何访问这些逻辑。这需要在端到端的方式下进行验证。
- en: Since this book is targeted for backend applications, UI level tests are not
    considered here; this includes UI end-to-end tests as well as UI reactiveness
    tests. Developers typically develop UI tests using test technology such as **Arquillian
    Graphene**. The system test approaches described in this chapter are applicable
    to UI level tests as well.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书针对的是后端应用程序，因此在此不考虑UI级别测试；这包括UI端到端测试以及UI响应性测试。开发者通常使用如**Arquillian Graphene**等测试技术来开发UI测试。本章中描述的系统测试方法也适用于UI级别测试。
- en: Performance tests
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测试
- en: Performance tests verify the non-functional aspect of how a system performs
    in terms of responsiveness and correct behavior under certain workloads.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试验证了系统在特定工作负载下的响应性和正确行为方面的非功能性方面。
- en: It needs to be ensured that an application can provide business value, not only
    under laboratory conditions but also in production. In production the load on
    the system can vary heavily, depending on the nature of the application and its
    use cases. Applications that are publicly available also run the risk of becoming
    the target of denial of service attacks.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 需要确保应用程序不仅能在实验室条件下提供业务价值，而且在生产环境中也能如此。在生产环境中，系统的负载可能会因应用程序的性质和使用案例而大幅变化。公开可用的应用程序也面临着成为拒绝服务攻击目标的危险。
- en: Performance tests are a helpful tool to detect potential performance issues
    that are caused by the application. This includes, for example, resource leaks,
    misconfiguration, deadlock situations, or missing timeouts. Putting the application
    under simulated workload will bring these issues to light.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试是检测由应用程序引起的潜在性能问题的有用工具。例如，这包括资源泄漏、配置错误、死锁情况或缺少超时。将应用程序置于模拟的工作负载下将这些问题暴露出来。
- en: However, as we will see in Chapter 9, *Monitoring, Performance, and Logging*,
    performance tests aren't necessarily helpful to predict production responsiveness
    or tune an application's performance. They should be used as a barrier against
    obvious mistakes, providing fast feedback.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们在第9章“监控、性能和日志记录”中将要看到的，性能测试并不一定有助于预测生产环境的响应性或调整应用程序的性能。它们应该用作防止明显错误的障碍，提供快速的反馈。
- en: For the rest of this book, I will use the term performance tests to describe
    performance as well as load or stress tests that put the application under performance
    load.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余部分，我将使用“性能测试”一词来描述性能测试以及将应用程序置于性能负载下的负载或压力测试。
- en: Stress tests
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压力测试
- en: Similar to performance tests, stress tests aim to put the system under a certain
    stress to verify correct behavior in abnormal situations. Whereas performance
    tests mainly target the application's performance in terms of responsibility and
    stability, stress tests can cover all aspects and attempts that try to bring the
    system down.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与性能测试类似，压力测试旨在将系统置于一定的压力之下，以验证在异常情况下的正确行为。虽然性能测试主要针对应用程序在责任和稳定性方面的性能，但压力测试可以涵盖所有试图使系统崩溃的方面和尝试。
- en: This includes invalid calls, neglecting communication contracts, or random,
    unexpected events from the environment. This list of tests is non-exhaustive here
    and beyond the scope of this book.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括无效调用、忽视通信契约，或来自环境的随机、意外事件。这里列出的测试列表并不全面，并且超出了本书的范围。
- en: However, to give a few examples, stress test may verify against misuse of HTTP
    connections, such as SYN flooding, DDoS attacks in general, unexpected shutdowns
    of infrastructure, or further, so-called fuzz or monkey testing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了举几个例子，压力测试可能验证对 HTTP 连接的误用，例如 SYN 洪水、DDoS 攻击、基础设施意外关闭，或者更进一步，所谓的模糊或猴子测试。
- en: Creating a sophisticated test harness containing a lot of stress tests would
    practically be beyond the scope of most projects. However, for enterprise projects
    it makes sense to include a few reasonable stress tests that match the used environment.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建包含大量压力测试的复杂测试框架实际上超出了大多数项目的范围。然而，对于企业项目来说，包含一些与使用环境相匹配的合理压力测试是有意义的。
- en: Implementing tests
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现测试
- en: After the motivations, requirements, and different scopes, let's have a closer
    look at how to craft test cases in Java Enterprise projects.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在动机、需求和不同范围之后，让我们更深入地了解一下如何在 Java 企业项目中编写测试用例。
- en: Unit tests
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests verify the behavior of individual units of an application. In a Java
    EE application, this usually regards single entity, boundary, and control classes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试验证应用程序各个单元的行为。在Java EE应用程序中，这通常涉及单个实体、边界和控制类。
- en: In order to unit test a single class, no exhaustive test case should be required.
    Ideally, instantiating the test object and setting up minimum dependencies should
    be sufficient to be able to invoke and verify its business functionality.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对单个类进行单元测试，不需要详尽的测试用例。理想情况下，实例化测试对象并设置最小依赖关系应该足以调用和验证其业务功能。
- en: Modern Java EE supports this approach. Java EE components, such as EJBs as well
    as CDI managed beans are testable in a straightforward way by simply instantiating
    the classes. As we saw previously, modern enterprise components represent plain
    Java objects, including annotations, without extending or implementing technically
    motivated superclasses or interfaces, so-called no-interface views.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Java EE支持这种做法。Java EE组件，如EJB以及CDI管理豆，可以通过简单地实例化类以直接方式测试。正如我们之前看到的，现代企业组件代表普通的Java对象，包括注解，而不需要扩展或实现技术驱动的超类或接口，即所谓的无接口视图。
- en: This allows tests to instantiate EJB or CDI classes and to wire them up as required.
    Used delegates such as injected controls that are irrelevant to the test case
    are mocked away. By doing so, we define the boundaries of the test case, what
    should be tested, and what is not relevant. Mocked delegates enable to verify
    the test object interaction.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许测试实例化EJB或CDI类，并按需将它们连接起来。用于测试案例无关的代理，如注入的控制，被模拟掉。通过这样做，我们定义了测试用例的边界，应该测试什么，以及什么是不相关的。模拟的代理使能够验证测试对象的交互。
- en: A mock object simulates behavior of an actual instance of its type. Calling
    methods on mocks usually only returns dummy or mock values. Test objects are not
    aware that they communicate with a mock object. The behavior of mocks, as well
    as the verification of invoked methods, is controlled within the test scenario.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象模拟其实例类型的实际行为。在模拟对象上调用方法通常只会返回虚拟或模拟值。测试对象不知道它们正在与模拟对象通信。模拟对象的行为以及调用方法的验证都在测试场景内进行控制。
- en: Implementation
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: 'Let''s start with a unit test of a Java EE core component. The `CarManufacturer`
    boundary executes certain business logic and invokes a `CarFactory` delegate control:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对Java EE核心组件的单元测试开始。`CarManufacturer` 边界执行某些业务逻辑并调用 `CarFactory` 代理控制：
- en: '[PRE0]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since the EJB boundary is a plain Java class, it can be instantiated and set
    up in a unit test. The most commonly used Java unit test technology is **JUnit**
    together with **Mockito** for mocking. The following code snippet shows the car
    manufacturer test case, instantiating the boundary test object and using Mockito
    to mock away used delegates:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 EJB 边界是一个普通的 Java 类，它可以在单元测试中实例化和设置。最常用的 Java 单元测试技术是 **JUnit** 与 **Mockito**
    用于模拟。以下代码片段展示了汽车制造商测试用例，实例化边界测试对象并使用 Mockito 模拟使用的代理：
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The JUnit framework instantiates the `CarManufacturerTest` test class once during
    the test execution.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 框架在测试执行期间一次性实例化 `CarManufacturerTest` 测试类。
- en: The `@Before` method, `setUp()` here, is executed every time before a `@Test`
    method runs. Similarly, methods annotated with `@After` run after every test run.
    The `@BeforeClass` and `@AfterClass` methods, however, are only executed once
    per test class, before and after the execution, respectively.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Before` 方法，这里的 `setUp()`，在每次 `@Test` 方法运行之前都会执行。同样，被 `@After` 注解的方法在每次测试运行之后执行。然而，`@BeforeClass`
    和 `@AfterClass` 方法，分别在测试类执行前和执行后只执行一次。'
- en: Mockito methods, such as `mock()`, `when()`, or `verify()` are used to create,
    set up, and verify mocking behavior, respectively. Mock objects are instructed
    to behave in a certain way. After the test execution, they can verify whether
    certain functionality has been called on them.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 方法，如 `mock()`、`when()` 或 `verify()`，分别用于创建、设置和验证模拟行为。模拟对象被指示以某种方式行为。测试执行后，它们可以验证是否对其调用了某些功能。
- en: This is an admittedly easy example, but it contains the essence of unit testing
    core components. No further custom test runner, neither an embedded container
    is required to verify the boundary's behavior. As opposed to custom runners, the
    JUnit framework can run unit tests at a very high rate. Hundreds of examples like
    these will be executed on modern hardware in no time. The startup time is short
    and the rest is just Java code execution, with a tiny overhead from the testing
    framework.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个简单的例子，但它包含了单元测试核心组件的精髓。不需要进一步的自定义测试运行器，也不需要嵌入式容器来验证边界行为的边界。与自定义运行器相比，JUnit
    框架可以以非常高的速率运行单元测试。在现代硬件上，数百个这样的例子将很快被执行。启动时间短，其余的只是 Java 代码执行，测试框架的额外开销很小。
- en: Some readers may have noticed the package-private visibility on the `CarManufacturer`
    class. This is due to providing better testability in order to be able to set
    the delegate on instantiated classes. Test classes that reside in the same package
    as the boundary are able to modify its dependencies. However, engineers might
    argue that this violates the encapsulation of the boundary. Theoretically they're
    right, but no caller will be able to modify the references once the components
    run in an enterprise container. The referenced object is not the actual delegate,
    but a proxy thereof, hence the CDI implementation can prevent misuse. It certainly
    is possible to inject the mock object using reflection or by using constructor-based
    injection. However, field-based injection together with directly setting the dependencies
    in the test cases provides better readability with the same production behavior.
    As of today, many enterprise projects have agreed upon using field dependency
    injection with package-private visibility.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一些读者可能已经注意到了 `CarManufacturer` 类的包私有可见性。这是为了提供更好的可测试性，以便能够在实例化类上设置代理。位于与边界相同包中的测试类能够修改其依赖项。然而，工程师可能会认为这违反了边界的封装。从理论上讲，他们是正确的，但一旦组件在企业容器中运行，任何调用者都无法修改引用。引用的对象不是实际的代理，而是一个代理，因此
    CDI 实现可以防止误用。当然，可以使用反射或基于构造函数的注入来注入模拟对象。然而，字段注入与在测试用例中直接设置依赖项相结合提供了更好的可读性，同时保持了相同的生产行为。截至目前，许多企业项目已同意使用字段依赖注入和包私有可见性。
- en: 'Another discussion is whether to use custom JUnit runners such as `MockitoJUnitRunner`
    together with custom mocking annotations or a plain setup approach, as shown previously.
    The following code snippet shows a more dense example using a custom runner:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个讨论点是是否使用自定义 JUnit 运行器，如 `MockitoJUnitRunner`，与自定义模拟注解或如前所述的普通设置方法一起使用。以下代码片段展示了使用自定义运行器的更密集的示例：
- en: '[PRE2]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the custom Mockito runner allows developers to configure tests with less
    code as well as to define injections with private visibility in the service class.
    Using a plain approach, as shown previously, provides more flexibility for complex
    mock scenarios. However, which method to use in order to run and define Mockito
    mocks is indeed a question of taste.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义 Mockito 运行器允许开发者用更少的代码配置测试，并在服务类中定义具有私有可见性的注入。使用如前所述的普通方法提供了更复杂的模拟场景的更多灵活性。然而，确实使用哪种方法来运行和定义
    Mockito 模拟是一个口味问题。
- en: 'Parameterized tests is an additional JUnit functionality to define test cases
    that are similar in the scenario, but differ in input and output data. The `manufactureCar()`
    method could be tested with a variety of input data, resulting in a slightly different
    outcome. Parameterized test cases enable to develop these scenarios more productively.
    The following code snippet shows an example of such test cases:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化测试是JUnit的附加功能，用于定义在场景上相似但输入和输出数据不同的测试用例。`manufactureCar()`方法可以用各种输入数据进行测试，从而产生略有不同的结果。参数化测试用例使开发这些场景更加高效。以下代码片段显示了此类测试用例的示例：
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Parameterized test classes are instantiated and executed following the data
    in the `@Parameters` test data method. Each element in the returned collection
    results in a separate test execution. The test class populates its parameter properties
    and continues the text execution as usual. The test data contains test input parameters
    as well as expected values.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化测试类根据`@Parameters`测试数据方法中的数据实例化和执行。返回集合中的每个元素都会导致单独的测试执行。测试类填充其参数属性，并像往常一样继续文本执行。测试数据包含测试输入参数以及预期值。
- en: The benefit of this parameterized approach is that it enables developers to
    add new test cases by simply adding another line within the `testData()` method.
    The preceding example shows the combination of a parameterized unit test using
    mocks. That combination is only possible using a plain Mockito approach, as described
    previously, instead of using `MockitoJUnitRunner`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种参数化方法的好处是它允许开发者通过在`testData()`方法中添加另一行来简单地添加新的测试用例。前面的示例显示了使用模拟的参数化单元测试的组合。这种组合仅使用之前描述的纯Mockito方法，而不是使用`MockitoJUnitRunner`。
- en: Technology
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术
- en: These examples use JUnit 4 which, at the time of writing, is the most used unit
    testing framework version. Mockito is used to mock objects and it provides sufficient
    flexibility for the majority of use cases. In order to assert conditions, these
    examples use **AssertJ** as the test matching library. It provides functionality
    to verify the state of objects using productive method-chaining invocations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例使用JUnit 4，在撰写本文时，它是使用最广泛的单元测试框架版本。Mockito用于模拟对象，并为大多数用例提供了足够的灵活性。为了断言条件，这些示例使用**AssertJ**作为测试匹配库。它提供了使用生产方法链调用来验证对象状态的功能。
- en: These technologies serve as examples for the required test aspects. The point
    here, however, is not to dictate certain functionalities rather it is to showcase
    specific, reasonable choices for these test requirements. Other technology that
    provides similar functionality and benefits is equally advisable.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术作为所需测试方面的示例。然而，这里的重点不是规定某些功能，而是展示针对这些测试要求的具体、合理的选择。提供类似功能和益处的其他技术同样值得推荐。
- en: A typical example of another widely-used technology is Hamcrest matchers as
    a test matching library or the less frequently used **TestNG** unit test framework.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个广泛使用的技术典型示例是Hamcrest匹配器作为测试匹配库，或者较少使用的**TestNG**单元测试框架。
- en: By the time you're reading this, JUnit version 5 will have emerged, which provides
    some additional functionalities, especially regarding to dynamic tests. Dynamic
    tests have similar motivations as parameterized tests, by programmatically and
    dynamically defining test cases.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到你阅读这篇文章的时候，JUnit版本5已经出现，它提供了一些额外的功能，特别是在动态测试方面。动态测试与参数化测试有类似的动机，通过程序化和动态地定义测试用例。
- en: Component tests
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件测试
- en: Component tests verify the behavior of a coherent component. They provide more
    integration than unit tests without running the application in simulated environments.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 组件测试验证一个连贯组件的行为。它们提供了比单元测试更多的集成，而不需要在模拟环境中运行应用程序。
- en: Motivation
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动机
- en: The behavior of coherent functionality represented by several interdependent
    classes needs to be verified in order to test the integration thereof. Component
    tests should run as fast as unit tests by still isolating functionality, that
    is, testing coherent units. Therefore they aim to provide fast feedback by integrating
    yet more logic than just unit tests. Component tests verify business use cases,
    from the boundary down to involved controls.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试集成，需要验证由几个相互依赖的类表示的连贯功能的行为。组件测试应该尽可能快地运行，同时仍然隔离功能，即测试连贯单元。因此，它们旨在通过集成比单元测试更多的逻辑来提供快速的反馈。组件测试验证业务用例，从边界到涉及的控制。
- en: Code level component tests are possible since the vast majority of managed beans
    use quite straightforward delegates. The injected types are in most cases directly
    resolvable without interfaces or qualifiers and could practically be instantiated
    and injected, even without embedded containers. This enables component tests to
    be implemented using the same testing frameworks as unit tests. Required delegates
    and mocks are set up as part of the test case. The test scenario we want to show
    starts from the beginning of a business use case down to injected controls.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数受管理的Bean使用相当直接的代理，因此可以进行代码级别的组件测试。注入的类型在大多数情况下可以直接解析，无需接口或限定符，甚至在没有嵌入式容器的情况下也可以实例化和注入。这使得组件测试可以使用与单元测试相同的测试框架来实现。所需的代理和模拟作为测试用例的一部分进行设置。我们想要展示的测试场景从业务用例的开始到注入的控制。
- en: The following examples will examine how to implement component tests with some
    basic code quality practices, that help writing maintainable tests.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将检查如何使用一些基本的代码质量实践来实现组件测试，这些实践有助于编写可维护的测试。
- en: Implementation
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: Imagine the whole manufacture car use case shown in the previous example in
    the *Unit tests* section, needs to be tested. A car is created, using a delegate
    `CarFactory`, and then is persisted into the database. Testing the persistence
    layer is out of this test scope, therefore the entity manager will be mocked away.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下在之前“单元测试”部分中展示的整个制造汽车用例需要被测试。使用代理`CarFactory`创建一辆车，然后将其持久化到数据库中。测试持久化层超出了这个测试范围，因此实体管理器将被模拟。
- en: 'The following code snippet shows the component test to the manufacture car
    use case:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了针对制造汽车用例的组件测试：
- en: '[PRE4]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding example is quite similar to the previous ones, with the exception
    that `CarFactory` is instantiated, using the actual business logic. The mocks,
    which represent the boundaries of the test case, verify correct behavior.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例与之前的示例非常相似，唯一的区别是`CarFactory`被实例化，使用了实际的业务逻辑。代表测试用例边界的模拟验证了正确的行为。
- en: However, while this approach works for straightforward use cases, it is somewhat
    naive in regard to more sophisticated real-world scenarios. The boundaries of
    the test case are as seen in the test class, for the `CarFactory` delegate to
    be self-sufficient and not inject further controls. Of course, all interdependent
    units that are part of a component test can define delegates. Depending on the
    nature of the test and the use case, these nested delegates also need to be instantiated
    or mocked away.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管这种方法对于简单的用例是有效的，但在更复杂、更接近现实世界的场景中，它有些天真。测试用例的边界正如在测试类中看到的那样，对于`CarFactory`代理来说，要自给自足且不注入更多的控制。当然，所有作为组件测试一部分的相互依赖的单位都可以定义代理。根据测试的性质和用例，这些嵌套代理也需要被实例化或模拟。
- en: This will eventually lead to a lot of effort required in setting up the test
    case. We could make use of test framework functionality such as Mockito annotations
    here. Doing so, the test case injects all classes that are involved in the test
    case. Developers specify which of them will be instantiated or mocked away, respectively.
    Mockito provides functionality to resolve references, which is sufficient for
    the majority of use cases.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这最终会导致在设置测试用例时需要付出很多努力。我们可以利用测试框架功能，如Mockito注解在这里。这样做，测试用例会注入所有涉及测试用例的类。开发者指定其中哪些将被实例化或模拟。Mockito提供了解析引用的功能，这对于大多数用例来说是足够的。
- en: 'The following code snippet shows a component test of a similar scenario, this
    time using a `CarFactory` delegate that has an `AssemblyLine` and `Automation`
    as nested dependencies. These are mocked away in the test case:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了类似场景的组件测试，这次使用了一个具有嵌套依赖项`AssemblyLine`和`Automation`的`CarFactory`代理。这些在测试用例中被模拟：
- en: '[PRE5]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `@InjectMocks` functionality of Mockito attempts to resolve object references
    with mock objects injected as `@Mock` in the test case. The references are set
    using reflection. If boundaries or controls define new delegates, they need to
    be defined at least as a `@Mock` object in the test cases to prevent `NullPointerException`.
    However, this approach only partially improves the situation since it leads to
    a lot of dependencies being defined in the test class.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito的`@InjectMocks`功能尝试使用在测试用例中注入为`@Mock`的模拟对象解析对象引用。这些引用是通过反射设置的。如果边界或控制定义了新的代理，它们至少需要在测试用例中定义为`@Mock`对象，以防止`NullPointerException`。然而，这种方法只部分改善了情况，因为它导致测试类中定义了大量的依赖项。
- en: An enterprise project with a growing number of component tests introduces a
    lot of verbosity and duplication if it follows only this approach.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个随着组件测试数量不断增长的企事业项目，如果仅采用这种方法，将会引入大量的冗余和重复。
- en: To make the test code less verbose and restrict this duplication, we could introduce
    a test superclass for a specific use case scenario. That superclass would contain
    all `@Mock` and `@InjectMock` definitions, setting up required dependencies, delegates,
    and mocks. However, such test superclasses also contain a lot of implicit logic,
    which delegates are defined and being used somewhere in the extended test cases.
    This approach leads to test cases that are tightly coupled to commonly used superclasses,
    eventually leading to implicitly coupling the test cases.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试代码更简洁并限制这种重复，我们可以为特定的用例场景引入一个测试超类。这个超类将包含所有`@Mock`和`@InjectMock`定义，设置所需的依赖、委派和模拟。然而，这样的测试超类也包含大量的隐式逻辑，这些委派在扩展的测试用例中被定义和使用。这种方法导致测试用例与常用的超类紧密耦合，最终导致测试用例的隐式耦合。
- en: Delegating test components
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委派测试组件
- en: It is more advisable to use delegation rather than extension.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用委派而不是扩展更为可取。
- en: Mocking and verification logic that depends on the used components is delegated
    to separate test objects. The delegates thus encapsulate and manage this logic
    individually.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于所使用组件的模拟和验证逻辑被委派到单独的测试对象中。因此，委派封装并单独管理这种逻辑。
- en: 'The following code snippet shows the test case using components that define
    the car manufacture and car factory dependencies:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了使用定义汽车制造和汽车工厂依赖的组件的测试用例：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Component` test dependencies specify the declared dependencies and mocks
    including the setup and verification behavior for our test cases. The idea is
    to define components that are reusable within multiple component tests, wiring
    up similar logic.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`组件`测试依赖指定了声明的依赖和模拟，包括测试用例的设置和验证行为。其理念是定义可在多个组件测试中复用的组件，连接相似逻辑。'
- en: 'The following code snippet shows the definition of `CarManufacturerComponent`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了`CarManufacturerComponent`的定义：
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The class resides in the same package as the `CarManufacturer` class, but under
    the test sources. It can subclass the boundary to add mocking and verification
    logic. In this example, it is dependent on the `CarFactory` component, that also
    provides additional test logic:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 该类位于与`CarManufacturer`类相同的包中，但在测试源下。它可以继承边界以添加模拟和验证逻辑。在这个例子中，它依赖于`CarFactory`组件，该组件还提供了额外的测试逻辑：
- en: '[PRE8]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These components serve as reusable test objects that wire up certain dependencies
    and configure mocking behavior, accordingly. They can be reused within multiple
    component tests and enhanced without affecting usages.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件作为可复用的测试对象，连接特定的依赖并配置模拟行为。它们可以在多个组件测试中复用，并在不影响使用的情况下进行增强。
- en: These examples aim to give an idea of what is possible in order to write maintainable
    tests. For components being reused, more refactoring approaches should be considered,
    for example, using a builder-pattern like configuration to satisfy different situations.
    The *Maintaining test data and scenarios* section in this chapter contains more
    about how to write maintainable test code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例旨在提供一个想法，以便编写可维护的测试。对于被复用的组件，应考虑更多的重构方法，例如，使用类似于构建器模式的配置来满足不同情况。本章中关于*维护测试数据和场景*的部分包含了更多关于如何编写可维护的测试代码的信息。
- en: The benefit of component tests is that they run as fast as unit tests and yet
    verify more complex integration logic. The complex logic is tackled by delegation
    and encapsulation, increasing maintainability. The code and overhead required
    to setup is limited.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 组件测试的优点是它们运行速度与单元测试相当，但又能验证更复杂的集成逻辑。复杂的逻辑通过委派和封装来解决，从而提高可维护性。设置所需的代码和开销有限。
- en: It makes sense to verify coherent business logic using component tests. Use
    case invocations are tested on a business level with technical low-level aspects
    being mocked away.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件测试来验证一致的业务逻辑是有意义的。用例调用在业务级别进行测试，而技术低级方面则通过模拟来处理。
- en: Technology
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术
- en: These examples again demonstrate plain JUnit and Mockito test approaches. With
    some code quality practices, it's certainly possible to write maintainable, dense
    test cases with limited configuration overhead.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例再次展示了纯JUnit和Mockito测试方法。通过一些代码质量实践，当然可以写出可维护的、密集的测试用例，且配置开销有限。
- en: Component tests implemented as shown previously are a practical approach to
    wire up components that use straightforward dependency injection. If the production
    code makes use of CDI producers and qualifiers, the injection logic of the test
    components will change accordingly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述实现的组件测试是连接使用简单依赖注入的组件的实用方法。如果生产代码使用了CDI生产者和限定符，测试组件的注入逻辑将相应地改变。
- en: Component tests aim to verify the business use case behavior of coherent units.
    They usually don't verify the technical wiring. It's advisable to use integration
    tests in order to verify whether CDI injection was used correctly, for example,
    in terms of custom qualifiers, producers, or scopes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 组件测试旨在验证一致单元的业务用例行为。它们通常不验证技术连接。建议使用集成测试来验证CDI注入是否正确使用，例如，在自定义限定符、生产者或作用域方面。
- en: However, there are test technologies that provide dependency injection into
    test cases. Examples for these are **CDI-Unit** or the more sophisticated **Aquillian
    Testing Framework**. Test cases using these frameworks run in containers, either
    embedded or even remotely, and are able to further verify the integration of components.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些测试技术可以为测试用例提供依赖注入。这些技术的例子包括**CDI-Unit**或更复杂的**Aquillian 测试框架**。使用这些框架的测试用例在容器中运行，无论是嵌入式还是远程，并且能够进一步验证组件的集成。
- en: Sophisticated test frameworks certainly provide test cases that are closer to
    the enterprise application, but also come with the challenge of slow application
    startups. The containers are usually executed and configured in every test case,
    typically taking a few hundred milliseconds or more. This does not sound that
    much but quickly adds up as more tests arrive.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的测试框架确实提供了更接近企业应用程序的测试用例，但也带来了应用程序启动缓慢的挑战。容器通常在每个测试用例中执行和配置，通常需要几百毫秒或更多时间。这听起来并不多，但随着测试数量的增加，很快就会累积起来。
- en: For component tests that aim to solely verify business behavior, faster, and
    lightweight approaches like the one presented, are therefore preferable. With
    their fast nature, component tests as well as unit tests are per default executed
    during the project build. They should be the default way how to verify application
    business logic.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于旨在仅验证业务行为的组件测试，更快速、轻量级的方法，如所展示的方法，是更可取的。由于它们的快速特性，组件测试以及单元测试默认情况下在项目构建期间执行。它们应该是验证应用程序业务逻辑的默认方式。
- en: The following shows code level integration tests that make use of simulated
    containers.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了使用模拟容器的代码级集成测试。
- en: Integration tests
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: Component tests verify coherent business logic in isolated and fast tests. Sophisticated
    Java EE integration behavior, such as injection, custom qualifiers, CDI events,
    or scopes are not covered by these tests.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 组件测试通过隔离和快速测试验证一致的业务逻辑。这些测试不涵盖复杂的Java EE集成行为，如注入、自定义限定符、CDI事件或作用域。
- en: Integration tests aim to verify the technical collaboration of components within
    the enterprise system. This covers concerns such as configuration of Java EE core
    components, communication with external systems, or persistence. Are the Java
    EE components annotated correctly? Does the JSON-B mapping produce the desired
    JSON format? Is the JPA ORM mapping defined properly?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试旨在验证企业系统内组件之间的技术协作。这包括诸如Java EE核心组件的配置、与外部系统的通信或持久性等问题。Java EE组件是否正确注解？JSON-B映射是否产生所需的JSON格式？JPA
    ORM映射是否定义得当？
- en: The idea behind code level integration tests is to provide faster feedback by
    verifying correct integration without the need to build and deploy the application
    to a test environment.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 代码级集成测试背后的理念是通过验证正确的集成来提供更快的反馈，而无需构建和部署应用程序到测试环境。
- en: Embedded containers
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式容器
- en: Since unit test technology is not aware of Java EE specifics, integration tests
    need more sophisticated test functionality in the form of containers. There are
    several technologies available that start up an embedded container and make parts
    of the application available.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单元测试技术不了解Java EE的具体细节，集成测试需要更复杂的测试功能，以容器形式存在。有几种技术可以启动嵌入式容器，并使应用程序的部分功能可用。
- en: An example for this is CDI-Unit. It provides functionality to run test cases
    in a CDI container, further enabling developers to enhance and modify its configuration.
    CDI-Unit scans the dependencies of tested objects and configures them accordingly.
    Required mocks and test specific behavior are defined in a declarative approach.
    A managed bean such as the car manufacturer boundary is set up within the test
    case, with all required dependencies and mocks.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个例子：CDI-Unit。它提供了在CDI容器中运行测试用例的功能，进一步使开发者能够增强和修改其配置。CDI-Unit扫描测试对象的依赖项并相应地配置它们。所需的模拟和特定的测试行为以声明性方式定义。在测试用例中设置了一个管理Bean，例如汽车制造商边界，包括所有必需的依赖项和模拟。
- en: 'This approach detects configuration errors, such as missing CDI annotations.
    The following code snippet shows a car manufacture test, similar to the component
    test before, that instantiates the boundary:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法可以检测配置错误，例如缺少CDI注解。以下代码片段展示了与之前的组件测试类似的汽车制造测试，它实例化了边界：
- en: '[PRE9]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The custom JUnit runner detects beans injected into the test case and resolves
    them accordingly. Since CDI-Unit only supports the CDI standard and not the full
    Java EE API, the test explicitly mocks and sets the entity manager. All other
    used controls, such as the car factory, automation, and assembly line, are instantiated
    and injected, accordingly.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义JUnit运行器检测注入到测试用例中的Bean，并相应地解析它们。由于CDI-Unit只支持CDI标准而不支持完整的Java EE API，测试明确模拟并设置实体管理器。所有其他使用的控制，如汽车工厂、自动化和装配线，都实例化并注入。
- en: CDI-Unit tests can be enhanced to serve more sophisticated scenarios. It's possible
    to produce beans that are being used within the test scope.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: CDI-Unit测试可以增强以服务于更复杂的场景。可以生成在测试范围内使用的Bean。
- en: However, this technology certainly has its limits. CDI-Unit is helpful to quickly
    verify configuration and collaboration of managed beans.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这项技术肯定有其局限性。CDI-Unit有助于快速验证配置和管理Bean的协作。
- en: Another, more sophisticated technology for testing applications is Arquillian.
    Arquillian bundles integration test cases into deployable archives, manages enterprise
    containers, either embedded or remotely, and deploys, executes, and verifies the
    test archives. It makes it possible to enhance test cases with custom test behavior
    depending on the scenario.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种更复杂的应用程序测试技术是Arquillian。Arquillian将集成测试用例打包成可部署的存档，管理企业容器，无论是嵌入的还是远程的，并部署、执行和验证测试存档。它使得根据场景增强测试用例以自定义测试行为成为可能。
- en: The advantage of Arquillian is that it supports containers with full Java EE
    support. This enables integration tests to operate in more production-near scenarios.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian的优势在于它支持具有完整Java EE支持的容器。这使得集成测试可以在更接近生产环境的场景中运行。
- en: 'The following code snippet shows a simple example of deploying the car manufacturer
    boundary to an embedded enterprise container managed by Arquillian:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了将汽车制造商边界部署到由Arquillian管理的嵌入式企业容器中的简单示例：
- en: '[PRE10]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This test case will create a dynamic web archive that ships the boundary and
    required delegates and deploys it into an embedded container. The test itself
    can inject and call methods on the specific components.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试用例将创建一个动态Web存档，包含边界和所需的代表，并将其部署到嵌入的容器中。测试本身可以注入并调用特定组件的方法。
- en: The container does not necessarily have to run in an embedded way, it can also
    be a managed or remote container. Containers that run for longer than just the
    test execution avoid the container startup time and execute tests much more quickly.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 容器不一定要以嵌入的方式运行，也可以是托管或远程容器。运行时间超过仅测试执行的容器避免了容器启动时间，并可以更快地执行测试。
- en: Executing these integration tests will take a comparatively long time, but operate
    closer to production environments. Misconfigured managed beans will be detected
    during development before the application is shipped. The flexibility and customization
    of Arquillian, by including custom bean definitions that reside in the test scope,
    enables pragmatic test scenarios.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这些集成测试将需要相对较长的时间，但操作更接近生产环境。在应用程序发货之前，将在开发过程中检测到配置不当的管理Bean。通过包括位于测试范围内的自定义Bean定义，Arquillian的灵活性和定制性使得实际的测试场景成为可能。
- en: However, this example only slightly touches the functionality of embedded container
    tests. Test frameworks such as Arquillian can be used for validating the integration
    of container configuration, communication, persistence, and UI. In the rest of
    this chapter, we will see some shortcomings of integration tests that operate
    on simulated or embedded environments.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个例子只是略微触及了嵌入式容器测试的功能。可以使用Arquillian等测试框架来验证容器配置、通信、持久化和UI的集成。在本章的其余部分，我们将看到在模拟或嵌入式环境中运行的集成测试的不足之处。
- en: Embedded databases
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式数据库
- en: Mapping persistence of domain entities is usually defined using JPA annotations.
    Validating this mapping before an actual server deployment prevents careless mistakes
    and saves time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 域实体持久化的映射通常使用JPA注解定义。在实际服务器部署之前验证此映射可以防止粗心大意造成的错误并节省时间。
- en: In order to verify a correct database mapping, a database is required. Besides
    using deployed environment database instances, embedded databases provide similar
    verification with fast feedback. Embedded container tests running on frameworks
    such as Arquillian can be used to access this functionality. However, for basic
    verification it's not necessary for the application to run inside a container.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证正确的数据库映射，需要一个数据库。除了使用部署环境数据库实例外，嵌入式数据库提供了类似的验证和快速反馈。在Arquillian等框架上运行的嵌入式容器测试可以用来访问此功能。然而，对于基本验证，应用程序不需要在容器内运行。
- en: JPA ships with the possibility to run standalone, in any Java SE environment.
    We can make use of this and write test cases that wire up the JPA configuration
    and connect against an embedded or local database.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: JPA带有在任意Java SE环境中独立运行的可能性。我们可以利用这一点来编写测试用例，将JPA配置连接到嵌入式或本地数据库。
- en: 'Imagine a car part that is manufactured and assembled in the car manufacture.
    The car part domain entity is mapped with JPA as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个在汽车制造厂制造和组装的汽车部件。汽车部件领域实体使用JPA映射如下：
- en: '[PRE11]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In order to verify correct persistence, a test entity bean should at least
    be persisted and reloaded from the database. The following code snippet shows
    an integration test that sets up a standalone JPA persistence:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证正确的持久化，测试实体Bean至少应该被持久化并从数据库中重新加载。以下代码片段显示了一个设置独立JPA持久化的集成测试：
- en: '[PRE12]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Since the persistence runs standalone, there is no container taking care of
    handling transactions. The test case does this programmatically, as well as setting
    up the entity manager, using the persistence unit `it`. The persistence unit is
    configured in test scope `persistence.xml`. For this test purpose it''s sufficient
    to configure a resource local transactional unit:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于持久化是独立运行的，没有容器负责处理事务。测试用例以编程方式执行此操作，以及设置实体管理器，使用持久化单元`it`。持久化单元在测试范围的`persistence.xml`中配置。为此测试目的，配置一个本地事务性资源单元就足够了：
- en: '[PRE13]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The involved entity classes such as `CarPart` have to be specified explicitly,
    since there is no container that takes care of annotation scanning. The JDBC configuration
    points to an embedded database, in this case **Apache Derby**.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的实体类，如`CarPart`，必须明确指定，因为没有容器负责处理注解扫描。JDBC配置指向一个嵌入式数据库，在这种情况下是**Apache Derby**。
- en: The enterprise project does not include the Java EE implementation, only the
    API. Therefore, an JPA implementation, such as **EclipseLink**, is added as a
    test dependency, together with the Derby database.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 企业项目不包括Java EE实现，只包括API。因此，添加了一个JPA实现，如**EclipseLink**，以及Derby数据库作为测试依赖项。
- en: This integration test provides faster feedback for configuration mismatches
    and careless mistakes by validating the persistence mapping locally. For example,
    the shown test case would fail because the `order` property of the `CarPart` type
    isn't able to be mapped, since `order` is a reserved SQL keyword. The solution
    to this is to change the column mapping, for example, by renaming the column with
    `@Column(name = "part_order")`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此集成测试通过在本地验证持久化映射，为配置不匹配和粗心大意造成的错误提供更快的反馈。例如，所示测试用例会失败，因为`CarPart`类型的`order`属性无法映射，因为`order`是保留的SQL关键字。解决方案是更改列映射，例如，通过使用`@Column(name
    = "part_order")`重命名列。
- en: This is a typical example of mistakes developers make while configuring the
    persistence. Preventing these errors, that otherwise won't be detected before
    deployment time, provides faster feedback and saves time and effort.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在配置持久化时开发者常犯的错误的一个典型例子。防止这些错误（否则在部署时间之前不会被发现），可以提供更快的反馈并节省时间和精力。
- en: Of course, this approach will not find all database related integration mismatches.
    There is no container being used and persistence errors, for example, related
    to concurrent transactions, won't be found before fully-fledged system tests are
    executed. Still, it provides a helpful first verification in the pipeline.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种方法不会发现所有数据库相关的集成不匹配。没有使用容器，并且持久化错误，例如与并发事务相关的错误，在完全的系统测试执行之前不会被发现。尽管如此，它仍然在管道中提供了一个有用的初步验证。
- en: Running integration tests
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行集成测试
- en: Attentive readers may have noticed the naming convention of integration tests
    ending with `IT` for integration test. This naming emerged from a Maven naming
    convention, excluding test classes, that don't match the `Test` naming pattern,
    in the *test* phase. Classes ending with `IT` will be run by a different life
    cycle plugin.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细阅读的读者可能已经注意到了集成测试的命名惯例，以 `IT` 结尾表示集成测试。这种命名源于 Maven 的命名惯例，不包括不匹配 `Test` 命名模式的测试类，在
    *test* 阶段。以 `IT` 结尾的类将由不同的生命周期插件运行。
- en: This approach supports developers in crafting effective development pipelines,
    since code level integration tests shouldn't necessarily run in the first build
    step depending on the time they take. With the example of Maven, the **Failsafe
    Plugin** runs integration tests, using the command `mvn failsafe:integration-test
    failsafe:verify`, after the project has been built.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法支持开发者构建有效的开发流程，因为代码级别的集成测试不一定要在第一次构建步骤中运行，这取决于它们所需的时间。以 Maven 为例，**Failsafe
    插件**在项目构建完成后运行集成测试，使用命令 `mvn failsafe:integration-test failsafe:verify`。
- en: The IDE, of course, supports both running `Test` named tests as well as other
    naming conventions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，IDE 支持运行以 `Test` 命名的测试以及其他命名约定。
- en: Gradle doesn't take this naming structure into account. In order to achieve
    the same goal, Gradle projects would use multiple sets of test sources that are
    executed separately.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 并不考虑这种命名结构。为了达到相同的目标，Gradle 项目会使用多组分别执行的测试源代码。
- en: Code level integration tests versus system tests
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码级别集成测试与系统测试
- en: Code level tests, such as unit, component, or integration tests, provide fast
    feedback during development. They enable developers to verify whether the business
    logic works as expected for isolated components and the overall configuration
    is sane.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 代码级别的测试，如单元、组件或集成测试，在开发过程中提供快速反馈。它们使开发者能够验证隔离组件的业务逻辑是否按预期工作，以及整体配置是否合理。
- en: Shortcomings of integration tests
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试的缺点
- en: However, in order to verify the application's production behavior, these tests
    are not sufficient. There will be differences in technology, configuration, or
    runtime that eventually lead to gaps in the test cases. Examples are enterprise
    containers with different versions, mismatches in the bean configuration once
    the whole application is deployed, different database implementations, or differences
    in JSON serialization.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了验证应用程序的生产行为，这些测试是不够的。在技术、配置或运行时可能会有差异，最终导致测试用例存在差距。例如，不同版本的 enterprise
    容器、整个应用程序部署后配置不匹配、不同的数据库实现或 JSON 序列化差异。
- en: Ultimately, the application runs in production. It makes a lot of sense to verify
    the behavior in environments that are equivalent to production.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，应用程序在生产环境中运行。在相当于生产环境的环境中验证行为是非常有意义的。
- en: Certainly, it is advisable to craft several test scopes to both have tests with
    isolated scope and faster feedback as well as integrational tests. The shortcoming
    of code level integration tests is that they often take a great amount of time.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，建议构建几个测试范围，以便既有具有隔离范围的测试和更快的反馈，也有集成测试。代码级别集成测试的缺点是它们通常需要花费大量时间。
- en: In my projects in the past, integration tests running containers such as Arquillian,
    usually were responsible for the vast majority of the build time, resulting in
    build with 10 minutes and more. This greatly slows down the Continuous Delivery
    pipeline, resulting in slow feedback and fewer builds. An attempt to solve this
    shortcoming is to use remote or managed containers in Arquillian tests. They will
    run with a longer life cycle than the test run and eliminate the startup times.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我过去的项目中，运行容器（如 Arquillian）的集成测试通常负责大部分构建时间，导致构建时间长达 10 分钟以上。这极大地减缓了持续交付管道，导致反馈慢和构建次数减少。为了解决这一不足，尝试在
    Arquillian 测试中使用远程或管理的容器。它们将具有比测试运行更长的生命周期，并消除启动时间。
- en: Code level integration tests are a helpful way to quickly verify application
    configuration, what cannot be tested using unit or component tests. They are not
    ideal for testing business logic.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 代码层面的集成测试是快速验证应用配置的有用方法，这是单元测试或组件测试无法测试的内容。它们不适合测试业务逻辑。
- en: Integration tests that deploy the whole application on simulated environments,
    such as embedded containers, provide certain value, but are not sufficient to
    verify production behavior since they are not equivalent to production. No matter
    whether on code level or simulated environments, integration tests tend to slow
    down the overall pipeline.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟环境（如嵌入式容器）上部署整个应用的集成测试提供了一定的价值，但不足以验证生产行为，因为它们并不等同于生产环境。无论在代码层面还是模拟环境中，集成测试往往会减慢整体流程。
- en: Shortcomings of system tests
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统测试的不足
- en: System tests which test an application that is deployed to a production-like
    environment in an end-to-end fashion provide the most representative verification.
    Since they run in a later step in the Continuous Delivery pipeline, they provide
    slower feedback. Test cases, such as verifying the JSON mappings of an HTTP endpoint,
    will take longer before they provide feedback to engineers.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试以端到端的方式测试部署到类似生产环境中的应用程序，提供了最具代表性的验证。由于它们在持续交付管道的较晚阶段运行，因此提供了较慢的反馈。例如，验证HTTP端点的JSON映射的测试用例在提供反馈给工程师之前会花费更长的时间。
- en: Tackling and maintaining complex test scenarios is an aspect that takes quite
    some time and effort. Enterprise applications require definition and maintenance
    of test data and configuration, especially when many external systems are involved.
    For example, an end-to-end test that verifies creating a car in the car manufacture
    application requires external concerns such as the assembly line to be set up
    as well as test data. Managing these scenarios involves a certain effort.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 应对和维护复杂的测试场景是一个需要相当多的时间和精力的方面。企业应用程序需要定义和维护测试数据和配置，尤其是在涉及许多外部系统的情况下。例如，验证在汽车制造应用程序中创建汽车的端到端测试需要设置外部关注点，如装配线以及测试数据。管理这些场景涉及一定的努力。
- en: End-to-end tests attempt to use external systems and databases similarly to
    production. This introduces the challenge to handle unavailable or erroneous environments.
    External systems or databases that are unavailable cause the tests to fail; however,
    the application is not responsible for this test failure. This scenario violates
    the requirement of predictability, that tests should not depend on external factors
    that provide false positives. Therefore, it's advisable that system tests mock
    away external systems that are not part of the application under test. Doing this
    enables to construct predictable end-to-end tests. The Sub-chapter *System tests*
    covers how to implement this approach.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试试图使用与生产环境类似的外部系统和数据库。这引入了处理不可用或错误环境的挑战。不可用的外部系统或数据库会导致测试失败；然而，应用程序对此测试失败并不负责。这种情况违反了可预测性的要求，即测试不应依赖于提供假阳性的外部因素。因此，建议系统测试模拟测试中不属于测试应用程序的外部系统。这样做可以构建可预测的端到端测试。子章节“系统测试”涵盖了如何实现这种方法。
- en: Conclusion
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: Code level unit and component tests verify isolated, specific business logic.
    They provide immediate feedback and prevent careless mistakes. Component tests,
    in particular, cover the integration of business related software units.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 代码层面的单元和组件测试验证了隔离的、特定的业务逻辑。它们提供即时反馈，并防止粗心大意造成的错误。特别是组件测试涵盖了与业务相关的软件单元的集成。
- en: The delimitation of component tests is that they run without a simulated container,
    setting up the test cases in a programmatic fashion. Integration tests rely on
    inversion of control, similar to application containers that wire up components
    with less developer effort involved. However, crafting maintainable test cases
    using a programmatic approach with unit test technology ultimately leads to more
    effective tests. We will see in the *Maintaining test data and scenarios* section
    in this chapter, what methods support us in crafting productive test cases.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 组件测试的界定在于它们在没有模拟容器的情况下运行，以编程方式设置测试用例。集成测试依赖于控制反转，类似于涉及较少开发者努力的连接组件的应用容器。然而，使用单元测试技术以编程方式构建可维护的测试用例最终会导致更有效的测试。在本章的“维护测试数据和场景”部分，我们将看到哪些方法支持我们构建高效的测试用例。
- en: Integration tests verify the technical integration as well as configuration
    of application components. Their feedback is certainly faster than deploying the
    application as part of the pipeline. However, integration tests do not provide
    sufficient verification compared to production.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试验证应用程序组件的技术集成以及配置。它们的反馈速度肯定比将应用程序作为管道的一部分部署要快。然而，与生产环境相比，集成测试提供的验证并不充分。
- en: They are a good fit to provide a first basic barrier against common errors and
    careless mistakes. Since starting up integration tests usually takes quite some
    time, it makes a lot of sense to run a limited number of them. Ideally test frameworks
    such as Arquillian deploy to managed or remote containers that keep running beyond
    a single test case.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 它们非常适合提供对常见错误和粗心大意的初步基本屏障。由于启动集成测试通常需要相当长的时间，因此运行有限数量的测试是非常有意义的。理想情况下，测试框架如Arquillian部署到管理或远程容器中，这些容器在单个测试用例之外继续运行。
- en: System tests verify the application's behavior in the most production-like fashion.
    They provide the ultimate feedback, whether the whole enterprise application works
    as expected, including business as well as technical aspects. In order to construct
    predictable test scenarios, it's important to consider external concerns, such
    as databases and external systems.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试以最类似生产的方式验证应用程序的行为。它们提供最终的反馈，即整个企业应用程序是否按预期工作，包括业务和技术方面。为了构建可预测的测试场景，考虑外部因素，如数据库和外部系统，非常重要。
- en: Crafting test cases, especially complex test scenarios, takes a lot of time
    and effort. The question is where does it make the most sense to spend this effort
    on? In order to test business logic, and especially coherent components, it's
    advisable to use component tests. Integration tests don't provide ultimate verification,
    but still take certain time and effort. It makes sense to use a few of them for
    fast integration feedback, but not to test business logic. Developers may also
    find ways to reuse created scenarios in several test scopes, for example both
    integration tests and system tests.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 编制测试用例，尤其是复杂的测试场景，需要花费大量的时间和精力。问题是应该在何处投入这种努力最有意义？为了测试业务逻辑，特别是协调一致的组件，建议使用组件测试。集成测试不能提供最终的验证，但仍然需要一定的时间和精力。使用少数几个集成测试以快速获得集成反馈是有意义的，但不应用于测试业务逻辑。开发者还可以找到在多个测试范围内重用创建的场景的方法，例如集成测试和系统测试。
- en: The overall goal should be to minimize the time and effort spent to craft and
    maintain test cases, to minimize the overall pipeline execution time and to maximize
    the application verification coverage.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 总体目标应该是最大限度地减少创建和维护测试用例所需的时间和精力，最大限度地减少整体管道执行时间，并最大限度地提高应用程序验证覆盖率。
- en: System tests
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统测试
- en: System tests run against a deployed enterprise application. The application
    contains the same code, configuration, and runtime as in production. The test
    cases use external communication, such as HTTP, to initiate use cases. They verify
    that the overall outcome, such as HTTP responses, database state, or communication
    with external systems, matches the expectations of the application.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试是对已部署的企业应用程序进行的。该应用程序包含与生产环境中相同的代码、配置和运行时。测试用例使用外部通信，例如HTTP，来启动用例。它们验证整体结果，例如HTTP响应、数据库状态或与外部系统的通信，是否符合应用程序的预期。
- en: 'System tests answer the question what to test with: the application that runs
    in the same way as in production, excluding external concerns, accessed using
    its regular interfaces. External concerns will be simulated, ensuring predictable
    tests and enabling verification of the communication. It depends on the scenario
    whether a used database is seen as part of the application and used similarly,
    or mocked away as well.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试回答了“测试什么”的问题：与生产环境中运行方式相同的应用程序，排除外部关注点，通过其常规接口访问。外部关注点将被模拟，确保测试的可预测性，并使通信验证成为可能。这取决于场景，所使用的数据库是否被视为应用程序的一部分并按类似方式使用，或者也被模拟。
- en: Managing test scenarios
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理测试场景
- en: System test scenarios can easily get quite complex, involving several concerns
    and obfuscating the actual use case that is to be tested.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试场景可能会变得相当复杂，涉及多个关注点，并模糊了实际要测试的实际用例。
- en: In order to manage the complexity of scenarios it makes sense to first craft
    the procedure of the test case without writing actual code. Defining the required
    steps in comments, or even on paper first, provides a good overview of what the
    test scenario is about. Implementing the actual test case afterwards with regard
    to reasonable abstraction layers will result in more maintainable test cases,
    with potentially reusable functionality. We will cover this approach in an example
    later in this sub-chapter.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理场景的复杂性，首先在不编写实际代码的情况下制定测试用例的流程是有意义的。在注释中定义所需的步骤，或者在纸上先定义，可以很好地概述测试场景的内容。在之后根据合理的抽象层实现实际的测试用例，将导致更易于维护的测试用例，并可能具有可重用的功能。我们将在本子章节的后面通过一个示例来介绍这种方法。
- en: It's important to take test data into consideration. The more responsibilities
    a scenario holds, the more complex it will be to define and maintain the test
    data. It makes sense to put some effort into test data functionality that is being
    used commonly in the test cases. Depending on the nature of the application and
    its domain, it may even make sense to define a specific engineer role for this.
    Providing reusable functionality that is usable effectively can provide some relief;
    however, it may still be necessary to at least define and document common test
    data and scenarios.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑测试数据是很重要的。一个场景承担的责任越多，定义和维护测试数据的复杂度就越高。对在测试用例中常用到的测试数据功能投入一些努力是有意义的。根据应用的性质和其领域，甚至可能有必要为这个定义一个特定的工程师角色。提供可重用的、有效使用的功能可以提供一些缓解；然而，仍然可能至少需要定义和记录常见的测试数据和场景。
- en: Ultimately it doesn't help to ignore the complexity of test data. If the application
    domain does include sophisticated scenarios, ignoring this situation by leaving
    out certain test cases or postponing test scenarios until production doesn't improve
    the application's quality.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，忽视测试数据的复杂性是没有帮助的。如果应用领域确实包括复杂的场景，通过省略某些测试用例或推迟测试场景到生产来忽略这种情况，并不能提高应用程序的质量。
- en: In order to craft predictable isolated test cases, the scenario should run as
    stateless and self-sufficient as possible. Test cases should have a starting point
    similar to production and not rely on a certain state of the system. They should
    consider other potential tests and usages running simultaneously.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作可预测的隔离测试用例，场景应该尽可能无状态和自给自足。测试用例应该有一个类似于生产的起点，而不是依赖于系统的某种状态。它们应该考虑同时运行的其他潜在测试和用途。
- en: For example, creating a new car should not make assumptions about the number
    of existing cars. The test case should not verify that the list of all cars is
    empty before the creation or that it only contains the created car afterwards.
    It rather verifies that the created car is part of the list at all.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，创建一辆新车不应假设现有汽车的数量。测试用例不应验证在创建之前所有汽车的列表是否为空，或者之后它只包含创建的汽车。它更验证的是创建的汽车是否是列表的一部分。
- en: For the same reason it should be avoided that system tests have an impact on
    the environment life cycle. In situations that involve external systems, it's
    necessary to control the behavior of the mocked systems. If possible, these cases
    should be limited in order to enable to execute other scenarios concurrently.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原因，应避免系统测试对环境生命周期产生影响。在涉及外部系统的情况下，有必要控制模拟系统的行为。如果可能，这些情况应限制在最小范围内，以便能够并行执行其他场景。
- en: Simulating external concerns
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟外部关注点
- en: System test scenarios use external systems in the same way as in production.
    However, similar to mock objects in unit and component tests, system tests simulate
    and mock away external systems. In this way, potential issues that the application
    isn't responsible for are eliminated. System tests run in dedicated environments,
    for example, provided by container orchestration frameworks. The test object is
    the sole application, deployed, executed and configured in the same way as in
    production.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试场景以与生产相同的方式使用外部系统。然而，类似于单元测试和组件测试中的模拟对象，系统测试模拟和模拟外部系统。通过这种方式，消除了应用不负责的潜在问题。系统测试在专用环境中运行，例如由容器编排框架提供。测试对象是唯一的应用程序，以与生产相同的方式部署、执行和配置。
- en: Simulated external systems are configured to provide the expected behavior once
    accessed by the application. Similar to a mock object, they verify correct communication
    depending on the use case.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟的外部系统配置为在应用程序访问时提供预期的行为。类似于模拟对象，它们根据用例验证正确的通信。
- en: For the majority of use cases, used databases would not be mocked away. The
    test scenario can manage and populate database contents as part of the test life
    cycle, if required. If the database system contains a lot of concerns external
    to the application, for example containing a lot of database code or representing
    a search engine, it may make sense to mock and simulate this behavior.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数用例，使用的数据库不会进行模拟。如果需要，测试场景可以管理并填充数据库内容，作为测试生命周期的部分。
- en: Container orchestration strongly supports these efforts by abstracting systems
    as services. Pod images can be replaced by other implementations without affecting
    the tested application. The mocked services can be accessed and configured from
    within the running system test, defining behavior and external test data.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 容器编排通过将系统抽象为服务来强烈支持这些努力。Pod镜像可以被其他实现替换，而不会影响被测试的应用程序。模拟的服务可以在运行中的系统测试中访问和配置，定义行为和外部测试数据。
- en: '![](img/abb98818-2655-46ba-9880-823c439a14f8.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/abb98818-2655-46ba-9880-823c439a14f8.png)'
- en: The dotted line illustrates the control and verification of the mocked system
    as part of the test scenario. The running application will use the external service
    as usual, with the difference that this service is in fact, backed by a mock.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 点线说明了作为测试场景一部分的模拟系统的控制和验证。运行中的应用程序将像往常一样使用外部服务，不同之处在于这个服务实际上是由模拟支持的。
- en: Designing system tests
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计系统测试
- en: System tests run as a step within the Continuous Delivery pipeline. They connect
    against a running application on a test environment, invoke business use cases,
    and verify the overall outcome.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试作为持续交付管道中的一个步骤运行。它们连接到测试环境中的运行应用程序，调用业务用例，并验证整体结果。
- en: System test cases usually don't impact the application's life cycle. The application
    is deployed upfront as part of the CD pipeline. If required, the system tests
    control the state and behavior of external mocks and contents of databases.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试案例通常不会影响应用程序的生命周期。应用程序作为CD管道的一部分提前部署。如果需要，系统测试可以控制外部模拟的状态和行为以及数据库的内容。
- en: Generally speaking, it makes sense to develop system tests as separate build
    projects without any code dependency to the project. Since system tests access
    the application from the outside there should be no implications on how the system
    is being used. System tests are developed against the application's endpoint contracts.
    Similarly, the system tests should not use classes or functionality that is part
    of the application, such as using the application's JSON mapping classes. Defining
    technology and system access from the outside as separate build projects prevents
    unwanted side effects caused by existing functionality. The system test project
    can reside besides the application project in the same repository.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，将系统测试作为独立的构建项目开发是有意义的，没有任何代码依赖项。由于系统测试从外部访问应用程序，因此不应影响系统的使用方式。系统测试针对应用程序的端点合同进行开发。同样，系统测试不应使用应用程序的一部分类或功能，例如使用应用程序的JSON映射类。将技术和系统访问定义为独立的构建项目，可以防止由现有功能引起的不希望出现的副作用。系统测试项目可以位于应用程序项目旁边的同一存储库中。
- en: The following example will construct a system test from a top-down approach,
    defining test scenarios and appropriate abstraction layers.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将从自顶向下的方法构建系统测试，定义测试场景和适当的抽象层。
- en: The business use cases of the car manufacture application are accessed via HTTP.
    They involve external systems and database accesses. In order to verify the creation
    of a car, the system test will connect against the running application, as a real-world
    use case would.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车制造应用程序的业务用例通过HTTP访问。它们涉及外部系统和数据库访问。为了验证汽车的创建，系统测试将连接到运行中的应用程序，就像现实世界的用例一样。
- en: 'In order to manage the test scenario, the case is crafted using logical steps
    with comments as placeholders first, and then implemented in several abstraction
    layers:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理测试场景，首先使用带有注释作为占位符的逻辑步骤来构建案例，然后在这些抽象层中实现：
- en: '[PRE14]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These comments represent the logical steps that are executed and verified when
    testing creation of a car. They are related to the business rather than the technical
    implementation.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这些注释代表了在测试创建汽车时执行和验证的逻辑步骤。它们与业务相关，而不是与技术实现相关。
- en: 'We realize these comments in private methods, or better, own delegates. The
    delegates encapsulate technical concerns, as well as potential life cycle behavior:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些注释实现为私有方法，或者更好的是，拥有自己的代理。代理封装了技术问题以及潜在的生命周期行为：
- en: We define `CarManufacturer` and `AssemblyLine` delegates that abstract the access
    and behavior of the applications and delegates. They are defined as part of the
    system test and have no relation to or knowledge of the managed beans with the
    same name in the application code. The system test project code is defined independently.
    It could also be implemented using a different technology, only depending on the
    communication interface of the application.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`CarManufacturer`和`AssemblyLine`代理，它们抽象了应用程序和代理的访问和行为。它们作为系统测试的一部分定义，与应用程序代码中具有相同名称的管理豆没有关系。系统测试项目代码是独立定义的。它也可以使用不同的技术实现，只要依赖于应用程序的通信接口。
- en: 'The following code snippet shows the integration of the delegates. The car
    creation system test only contains business logic relevant to implementation,
    with the delegates realizing the actual invocations. This leverages readable as
    well as maintainable test cases. Similar system tests will reuse the delegate
    functionality:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了代理的集成。汽车创建系统测试仅包含与实现相关的业务逻辑，代理实现实际的调用。这利用了可读性和可维护性良好的测试用例。类似的系统测试将重用代理功能：
- en: '[PRE15]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This serves as a basic example for an application system test. The delegates
    such as `CarManufacturer` handle the lower-level communication and validation:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个应用程序系统测试的基本示例。例如`CarManufacturer`这样的代理处理低级通信和验证：
- en: '[PRE16]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The test delegate is configured against the car manufacture test environment.
    This configuration could be made configurable, for example, by a Java system property
    or environment variable in order to make the test reusable against several environments.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代理配置在汽车制造测试环境中。此配置可以通过Java系统属性或环境变量进行配置，以便使测试可重用于多个环境。
- en: If the delegate needs to hook up into the test case life cycle, it can be defined
    as a JUnit 4 rule or JUnit 5 extension model.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代理需要连接到测试用例的生命周期，它可以定义为JUnit 4规则或JUnit 5扩展模型。
- en: This example connects against a running car manufacture application via HTTP.
    It can create and read cars, mapping and verifying the responses. The reader may
    have noted how the delegate encapsulates communication internals, such as HTTP
    URLs, status codes, or JSON mapping. Its public interface only comprises classes
    that are relevant to the business domain of the test scenario, such as `Car` or
    `EngineType`. The domain entity types used in system tests don't have to match
    the ones defined in the application. For reasons of simplicity, system tests can
    use different, simpler types that are sufficient for the given scenario.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例通过HTTP连接到一个正在运行的汽车制造应用程序。它可以创建和读取汽车，映射和验证响应。读者可能已经注意到，代理封装了通信内部细节，例如HTTP
    URL、状态码或JSON映射。其公共接口仅包含与测试场景的业务域相关的类，例如`Car`或`EngineType`。系统测试中使用的域实体类型不必与在应用程序中定义的类型相匹配。出于简单起见，系统测试可以使用不同、更简单的类型，这些类型对于给定的场景是足够的。
- en: Deploying and controlling external mocks
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和控制外部模拟
- en: We just saw how to connect a system test against a running enterprise application.
    But how can we control and manipulate the external system that is used inside
    the application's use case?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何将系统测试连接到一个正在运行的企业应用程序。但我们如何控制和管理应用程序用例内部使用的外部系统呢？
- en: An external system can be mocked away using mock server technology such as **WireMock**.
    WireMock runs as a standalone web server, which is configured to answer specific
    requests accordingly. It acts like a code level test mock object, that stubs and
    verifies behavior.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用模拟服务器技术，如**WireMock**，来模拟外部系统。WireMock作为一个独立的Web服务器运行，配置为相应地回答特定请求。它像一个代码级别的测试模拟对象，模拟并验证行为。
- en: The benefit of using container orchestration frameworks for system tests is
    that services can be easily replaced by mock servers. The external system's infrastructure
    as code configuration for the system test environment can contain a WireMock Docker
    image, which is executed instead of the actual system.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器编排框架进行系统测试的好处是，服务可以很容易地被模拟服务器所替代。系统测试环境的外部系统基础设施作为代码配置可以包含一个WireMock Docker镜像，它将代替实际系统执行。
- en: 'The following code snippet shows an example Kubernetes configuration for the
    assembly line system, using a WireMock Docker image in the running pods:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了用于组装线系统的示例Kubernetes配置，使用运行中的Pod中的WireMock Docker镜像：
- en: '[PRE17]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The system test connects against this service, using an administration URL to
    set up and modify the mock server's behavior.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试连接到该服务，使用管理URL来设置和修改模拟服务器的行为。
- en: 'The following code snippet shows an implementation of the `AssemblyLine` test
    delegate, using the WireMock API to control the service:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了使用WireMock API控制服务的`AssemblyLine`测试代表的实现：
- en: '[PRE18]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The initial behavior instructs the WireMock instance to answer HTTP requests
    appropriately. The behavior can also be modified during the test case, if more
    complex processes and conversations have to be represented.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 初始行为指示WireMock实例适当地响应HTTP请求。在测试用例期间，如果需要表示更复杂的过程和对话，行为也可以被修改。
- en: If a more sophisticated test scenario involves asynchronous communication such
    as long-running processes, the test cases can use polling to wait for verifications.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更复杂的测试场景涉及异步通信，如长时间运行的过程，测试用例可以使用轮询等待验证。
- en: The defined car manufacturer and assembly line delegates can be reused within
    multiple test scenarios. Some cases might require to run system tests mutually
    exclusively.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 定义好的汽车制造商和组装线代表可以在多个测试场景中重复使用。某些情况可能需要互斥地运行系统测试。
- en: In the *Maintaining test data and scenarios* section, we will see what further
    methods and approaches support developers in writing maintainable test cases.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在“维护测试数据和场景”部分，我们将看到哪些进一步的方法和途径支持开发者编写可维护的测试用例。
- en: Performance tests
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测试
- en: Performance tests verify the non-functional requirement of how a system performs
    in terms of responsiveness. They don't verify business logic, they verify the
    application's technology, implementation, and configuration.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试验证系统在响应性方面的非功能性需求。它们不验证业务逻辑，而是验证应用程序的技术、实现和配置。
- en: In production systems the load on the systems can vary heavily. This is especially
    true for applications that are publicly available.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产系统中，系统的负载可能会有很大的变化。这对于公开可用的应用程序来说尤其如此。
- en: Motivation
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动机
- en: Similar to tests that verify business behavior, it can be helpful to test upfront
    whether an application, or component thereof, is likely to meet their performance
    expectations in production. The motivation is to prevent major performance drops,
    potentially caused by introduced errors.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 与验证业务行为的测试类似，测试应用程序或其组件是否可能满足生产中的性能预期是有帮助的。动机是防止由于引入的错误而导致的性能大幅下降。
- en: It's important to consider the application logic when constructing performance
    test scenarios. Some invocations perform more expensive processes than others.
    Generally it makes sense to construct performance tests after realistic production
    scenarios, in regard to the frequency and nature of requests.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建性能测试场景时，考虑应用程序逻辑是很重要的。某些调用比其他调用执行更昂贵的进程。通常，在考虑请求的频率和性质时，在现实的生产场景之后构建性能测试是有意义的。
- en: For example, the ratio of guests browsing an online shop to customers actually
    performing purchase transactions should somehow reflect the real world.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，浏览在线商店的访客与实际执行购买交易的客户之间的比例应该以某种方式反映现实世界。
- en: However, it also makes sense to construct tests that excessively perform expensive
    invocations, to detect potential issues that emerge when the system is under stress.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，构建执行昂贵调用测试也是合理的，以检测系统在压力下可能出现的问题。
- en: In Chapter 9, *Monitoring, Performance, and Logging*, we will see why performance
    tests on environments other than production are a poor tool to explore the application's
    limits and potential bottlenecks. Instead of putting great effort into crafting
    sophisticated performance test scenarios, it makes more sense to invest into technical
    insights into production systems.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9章“监控、性能和日志记录”中，我们将了解为什么在生产环境之外进行性能测试是探索应用程序极限和潜在瓶颈的糟糕工具。与其投入大量精力来构建复杂的性能测试场景，不如将精力投入到对生产系统技术洞察的投资中。
- en: Still, we will see a few techniques of how to craft simple load tests that put
    a simulated application under pressure to find evident issues.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍将看到一些如何构建简单的负载测试的技术，这些测试将模拟应用程序的压力，以发现明显的问题。
- en: A reasonable attempt is to simulate usual load, ramp up the number of concurrent
    users, and explore at which point the application becomes unresponsive. If the
    responsiveness breaks sooner than from an earlier test run, this could indicate
    an issue.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一个合理的尝试是模拟正常负载，增加并发用户数量，并探索应用程序何时变得无响应。如果响应性比早期测试运行更快地下降，这可能会表明存在问题。
- en: Key performance indicators
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键性能指标
- en: Key performance indicators give information about the application's responsiveness
    during normal behavior as well as under simulated workload. There are several
    indicators that can be gathered that directly affect the user, such as the response
    time or the error rate. These gauges represent the system's state and will provide
    insights about its behavior under performance tests. The indicated values will
    change depending on the number of concurrent users as well as the test scenario.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 关键性能指标提供了关于应用程序在正常行为以及模拟工作负载下的响应性的信息。有几种指标可以直接影响用户，例如响应时间或错误率。这些仪表代表了系统的状态，并将提供关于其在性能测试下行为的洞察。指示的值将根据并发用户数量以及测试场景而变化。
- en: A first interesting insight is the application's response time - the time it
    takes to respond to a client's request including all transmissions. It directly
    affects the quality of the offered service. If the response time falls below a
    certain threshold, timeouts may occur that cancel and fail the request. The latency
    time is the time it takes until the server receives the first byte of the request.
    It mainly depends on the network setup.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的洞察是应用程序的响应时间——包括所有传输在内的响应客户端请求所需的时间。它直接影响所提供服务的质量。如果响应时间低于某个阈值，可能会发生超时，取消并失败请求。延迟时间是服务器接收到请求的第一个字节所需的时间。它主要取决于网络设置。
- en: During performance tests, it's especially interesting to see how the response
    time and latency time change compared to their average. When increasing the load
    on an application, at some point the application will become unresponsive. This
    unresponsiveness can originate from all kinds of reasons. For example, available
    connections or threads may be consumed, timeouts can occur, or database optimistic
    locking may fail. The request error rate represents the ratio of failed requests.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能测试期间，特别有趣的是观察响应时间和延迟时间与平均值的比较。当增加应用程序的负载时，在某个点上应用程序将变得无响应。这种无响应性可能源于各种原因。例如，可用的连接或线程可能已被消耗，可能会发生超时，或者数据库乐观锁定可能失败。请求错误率表示失败请求的比例。
- en: The number of concurrent users or load size in a specific interval of time affects
    the performance metrics of the application and needs to be considered in the test
    results. A higher number of users will put the system under more stress, depending
    on the nature of the request. This number is related to the number of concurrent
    transactions, technical transactions in this case, that indicate how many transactions
    the application can handle at a time.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定时间间隔内并发用户数量或负载大小会影响应用程序的性能指标，需要在测试结果中考虑。用户数量越多，系统所承受的压力就越大，这取决于请求的性质。这个数字与并发事务的数量相关，在这种情况下是技术事务，它表明应用程序一次可以处理多少事务。
- en: The CPU and memory utilization provide insights about the application's resources.
    Whereas the values don't necessarily say much about the application's health,
    they represent the trend of resource consumption during load simulation.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: CPU和内存利用率提供了关于应用程序资源的洞察。虽然这些值并不一定说明应用程序的健康状况，但它们代表了负载模拟期间资源消耗的趋势。
- en: Similarly, the overall throughput indicates the total amount of data that the
    server transmits to the connected users at any point in time.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，整体吞吐量表示服务器在任何时刻向连接用户传输的总数据量。
- en: The key performance indicators provide insights about the application's responsiveness.
    They help gather experience and especially trends during development. This experience
    can be used to verify future application versions. Especially after making changes
    in technology, implementation, or configuration, performance tests can indicate
    a potential performance impact.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 关键性能指标提供了关于应用程序响应性的见解。它们有助于在开发过程中积累经验，特别是趋势。这种经验可以用来验证未来的应用程序版本。特别是在技术、实现或配置更改后，性能测试可以指示潜在的性能影响。
- en: Developing performance tests
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发性能测试
- en: It makes sense to design performance test scenarios that are close to the real
    world. Performance test technology should support scenarios that not only ramp
    up a big amount of users, but simulate user behavior. Typical behavior could be,
    for example, a user visits the home page, logs in, follows a link to an article,
    adds the article to their shopping cart, and performs the purchase.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 设计接近现实世界的性能测试场景是有意义的。性能测试技术应支持不仅能够增加大量用户，还能模拟用户行为的场景。典型的行为可能是，例如，用户访问主页，登录，点击链接到文章，将文章添加到购物车，并执行购买。
- en: There are several performance test technologies available. At the time of writing,
    the arguably most used ones are **Gatling** and **Apache JMeter**.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的性能测试技术有多种。在撰写本文时，最常用的可能是**Gatling**和**Apache JMeter**。
- en: Apache JMeter executes test scenarios that put applications under load and generates
    reports from the test execution. It uses XML-based configuration, supports multiple
    or custom communication protocols and can be used to replay recorded load test
    scenarios. Apache JMeter defines test plans that contain compositions of so-called
    samplers and logic controllers. They are used to define test scenarios that simulate
    user behavior. JMeter is distributed, using a master/slave architecture and can
    be used to generate load from several directions. It ships a graphical UI which
    is is used to edit the test plan configuration. Command-line tools execute the
    tests locally or on a Continuous Integration server.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Apache JMeter执行将应用程序置于负载下的测试场景，并从测试执行中生成报告。它使用基于XML的配置，支持多种或自定义通信协议，并且可以用于回放记录的负载测试场景。Apache
    JMeter定义了包含所谓采样器和逻辑控制器的测试计划。它们用于定义模拟用户行为的测试场景。JMeter是分布式的，使用主/从架构，可以从多个方向生成负载。它提供了一个图形用户界面，用于编辑测试计划配置。命令行工具在本地或持续集成服务器上执行测试。
- en: Gatling provides a similar performance test solution, but it defines test scenarios
    programmatically written in Scala. It therefore provides a lot of flexibility
    in defining test scenarios, behavior of virtual users, and how the test progresses.
    Gatling can also record and reuse user behavior. Since the tests are defined programmatically,
    there are a lot of flexible solutions possible, such as dynamically feeding cases
    from external sources. The so-called checks and assertions are used to verify
    whether a single test request or the whole test case was successful.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Gatling提供了一个类似性能测试解决方案，但它以Scala编写的程序方式定义测试场景。因此，它在定义测试场景、虚拟用户行为以及测试进展方面提供了很多灵活性。Gatling还可以记录和重用用户行为。由于测试是程序定义的，因此有许多灵活的解决方案，例如从外部源动态提供案例。所谓的检查和断言用于验证单个测试请求或整个测试案例是否成功。
- en: Unlike JMeter, Gatling runs on a single host, not distributed.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 与JMeter不同，Gatling在单个主机上运行，而不是分布式。
- en: 'The following code snippet shows the definition of a simple Gatling simulation
    in Scala:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了简单Gatling模拟的Scala定义：
- en: '[PRE19]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `create_car` scenario involves three client requests, which retrieve all
    cars, create a car, and follow the created resource. The scenarios configure multiple
    virtual users. The number of users starts at `10` and is ramped up to `20` users
    within `10` seconds runtime.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_car`场景涉及三个客户端请求，这些请求检索所有汽车，创建一辆汽车，并跟踪创建的资源。场景配置了多个虚拟用户。用户数量从`10`开始，在`10`秒运行时间内增加到`20`用户。'
- en: 'The simulation is triggered via the command line and executed against a running
    environment. Gatling provides test results in HTML files. The following code snippet
    shows the Gatling HTML output of the test example run:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟通过命令行触发，并在运行环境中执行。Gatling提供HTML文件格式的测试结果。以下代码片段显示了Gatling测试示例的HTML输出：
- en: '![](img/87e5c982-56ad-4d5a-9fcf-65516195e3c2.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/87e5c982-56ad-4d5a-9fcf-65516195e3c2.png)'
- en: This example gives an idea of what is possible with Gatling tests.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子给出了使用Gatling测试可能实现的内容。
- en: Since performance tests should reflect somewhat realistic user scenarios, it
    makes sense to reuse existing system test scenarios for performance tests. Besides
    programmatically defining user behavior, pre-recorded test runs can be used to
    feed in data from external sources such as web server log files.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 由于性能测试应该在一定程度上反映现实用户场景，因此使用现有系统测试场景进行性能测试是有意义的。除了程序定义用户行为外，预先录制的测试运行还可以用于从外部源（如Web服务器日志文件）输入数据。
- en: Insights
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 见解
- en: The point in executing performance tests is less a *green* or *red* outcome
    than the insights gathered from the runs. The test reports and the application's
    behavior are collected during the test runs. These collections enable us to gain
    experience and discover trends in performance.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 执行性能测试的目的与其说是关注*绿色*或*红色*的结果，不如说是从运行中获得见解。测试运行期间收集测试报告和应用程序的行为。这些收集使我们能够获得经验并发现性能的趋势。
- en: While the performance tests can be executed standalone, they ideally run continuously
    as part of a Continuous Delivery pipeline. It's already helpful to gain these
    insights without needing to affect the outcome of the pipeline step. After some
    metrics have been gathered, engineers can consider defining a performance run
    as failed if the measured performance indicated a major drop from the usual expectations.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然性能测试可以独立执行，但它们理想情况下应作为持续交付管道的一部分持续运行。在没有影响管道步骤结果的情况下获得这些见解已经很有帮助了。收集了一些指标后，工程师可以考虑如果测量的性能与通常的预期相比有大幅下降，则将性能运行定义为失败。
- en: This matches the idea of continuous improvement or in this case avoiding responsiveness
    deterioration.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这与持续改进的理念相符，或者在这种情况下，避免响应性下降。
- en: Running tests locally
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地运行测试
- en: The previous chapter covered development workflows and Continuous Delivery pipelines.
    It's crucial for modern enterprise applications to define an effective pipeline.
    However, while the CI server takes care of all build, test, and deploy steps,
    software engineers are still required to build and test on their local environments.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了开发工作流程和持续交付管道。对于现代企业应用程序来说，定义一个有效的管道至关重要。然而，尽管CI服务器负责所有构建、测试和部署步骤，软件工程师仍然需要在本地环境中进行构建和测试。
- en: Continuous Delivery pipelines with proper tests sufficiently verify that enterprise
    applications work as expected. However, the shortcoming with only relying on the
    pipeline is that engineers receive feedback later and only after they have pushed
    their changes to the central repository. Whereas this is the idea behind Continuous
    Integration, developers still want certainty in their changes before committing
    them.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适当的测试的持续交付管道充分验证企业应用程序按预期工作。然而，仅依赖管道的不足之处在于工程师在将更改推送到中央存储库之后才会收到反馈。虽然这是持续集成的理念，但在提交更改之前，开发者仍然希望对他们的更改有确定性。
- en: Committing changes that contain careless mistakes disturbs other team members
    by unnecessarily breaking the build. Errors that are easy to detect can be prevented
    by verifying the commit locally. This is certainly doable in code level tests,
    such as unit, component, and integration tests, which run on local environments
    as well. Performing code level tests before committing prevents the majority of
    mistakes.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 提交包含粗心大意的错误更改会通过不必要的破坏构建来打扰其他团队成员。通过在本地验证提交可以防止易于检测的错误。这当然可以在代码级别的测试中实现，例如单元测试、组件测试和集成测试，这些测试也在本地环境中运行。在提交之前执行代码级别的测试可以防止大多数错误。
- en: When developing technical or cross-cutting concerns, such as interceptors or
    JAX-RS JSON mapping, engineers also want feedback before committing the changes
    to the pipeline. As mentioned before, system tests against actually running applications
    provide the most realistic verification.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发技术或横切关注点，如拦截器或JAX-RS JSON映射时，工程师在将更改提交到管道之前也希望得到反馈。如前所述，针对实际运行的应用程序进行的系统测试提供了最真实的验证。
- en: For local environments, developers could write sophisticated integration tests,
    running on embedded containers, to receive faster feedback. However, as we saw
    previously, this requires quite some time and effort and still does not reliably
    cover all situations.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地环境，开发者可以编写复杂的集成测试，在嵌入式容器中运行，以获得更快的反馈。然而，正如我们之前所看到的，这需要相当多的时间和精力，并且仍然不能可靠地覆盖所有情况。
- en: Using container technologies enables engineers to run the same software images
    on multiple environments, including locally. There are Docker installations available
    for the major operating systems. Local machines can run Docker containers in the
    same way as in production, setting up custom configuration or wiring up their
    own networks, if required.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器技术使工程师能够在多个环境中运行相同的软件镜像，包括本地环境。主要操作系统都有可用的Docker安装。本地机器可以像在生产环境中一样运行Docker容器，如果需要，可以设置自定义配置或连接自己的网络。
- en: This enables us to run fully-fledged system tests on local environments as well.
    Whereas this step doesn't necessarily have to be performed during development,
    it's helpful for developers that want to verify integrational behavior.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够在本地环境中运行完整的系统测试。虽然这一步不一定需要在开发期间执行，但对于想要验证集成行为的开发者来说很有帮助。
- en: Developers can perform build and test steps locally, similar to the Continuous
    Delivery pipeline. Running steps via the command line greatly facilitates this
    approach. Docker `run` commands enable us to dynamically configure volumes, networks,
    or environment variables based on the local host.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以在本地执行构建和测试步骤，类似于持续交付管道。通过命令行运行步骤极大地简化了这种方法。Docker `run` 命令使我们能够根据本地主机动态配置卷、网络或环境变量。
- en: In order to automate the process, the separate build, deploy, and test commands
    are combined into shell scripts.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化这个过程，将单独的构建、部署和测试命令组合到shell脚本中。
- en: 'The following code snippet shows one example of a Bash script that performs
    several steps. Bash scripts can be run on Windows as well, via Unix-console emulators:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了Bash脚本执行多个步骤的一个示例。Bash脚本也可以在Windows上通过Unix控制台模拟器运行：
- en: '[PRE20]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The *hello-cloud* application is contained in the `hello-cloud/` subfolder and
    built with Maven and Docker. The Docker `run` command configures a custom properties
    file. This is similar to the orchestration configuration example shown in [Chapter
    5](a24f88d4-1af2-4746-91c9-9717d077dd27.xhtml), *Container and Cloud Environments
    with Java EE*.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`*hello-cloud*` 应用程序包含在 `hello-cloud/` 子目录中，并使用 Maven 和 Docker 构建。Docker `run`
    命令配置了一个自定义属性文件。这与第 5 章[容器和云环境与 Java EE](a24f88d4-1af2-4746-91c9-9717d077dd27.xhtml)中展示的编排配置示例类似。'
- en: The `hello-cloud-st/` directory contains system tests that connect against a
    running application. In order to direct the system test to the local environment,
    the *hosts* configuration of the local machine can be adapted. The Maven test
    run executes the system tests.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello-cloud-st/` 目录包含连接到运行中的应用程序的系统测试。为了将系统测试指向本地环境，可以调整本地机器的 *hosts* 配置。Maven测试运行执行系统测试。'
- en: This approach enables developers to verify behavior in fully-fledged system
    tests that are executed in the Continuous Delivery pipelines as well as locally,
    if required.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使开发者能够在执行在持续交付管道中以及必要时本地执行的完整系统测试中验证行为。
- en: If the system test scenario requires several external systems, they are equally
    run as Docker containers, similar to the test environment. Applications that run
    in container orchestration environments use logical service names to resolve external
    systems. The same is possible for natively running Docker containers, that are
    part of custom Docker networks. Docker resolves container names in containers
    running in the same network.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统测试场景需要多个外部系统，它们将作为Docker容器同等运行，类似于测试环境。在容器编排环境中运行的应用程序使用逻辑服务名称来解析外部系统。对于作为自定义Docker网络一部分的原生运行Docker容器，这也是可能的。Docker在相同网络中运行的容器中解析容器名称。
- en: This approach is used to run all kinds of services locally and is especially
    useful to run mock servers.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法用于在本地运行各种服务，特别是运行模拟服务器特别有用。
- en: 'The following snippet shows an example of the idea of running a local test
    environment:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了运行本地测试环境的思想示例：
- en: '[PRE21]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Similar to the system test example, the WireMock server will be configured as
    part of the test case. The local environment needs to ensure that hostnames point
    to the corresponding localhost containers.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 与系统测试示例类似，WireMock服务器将作为测试用例的一部分进行配置。本地环境需要确保主机名指向相应的localhost容器。
- en: For more complex setups, it makes sense to run the services in a container orchestration
    cluster as well. There are local installation options for Kubernetes or OpenShift
    available. The container orchestration abstracts cluster nodes. It therefore makes
    no difference for infrastructure as code definitions, whether a cluster runs locally,
    as a single node, in a server environment on-premises, or in the cloud.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: This enables engineers to use the very same definitions that are used in the
    test environments. Running a local Kubernetes installation simplifies the shell
    scripts to a few `kubectl` commands.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: If installing Kubernetes or OpenShift locally is too oversized, orchestration
    alternatives such as Docker Compose can be used as lightweight alternatives. Docker
    Compose also defines multi-container environments and their configuration in infrastructure
    as code files - executable by a single command. It provides similar benefits as
    Kubernetes. Arquillian Cube is another sophisticated way of orchestrating and
    running Docker containers.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Automating steps locally via scripts, highly increases the developer's productivity.
    Running system tests on local machines benefits engineers by providing faster
    feedback with less disruption.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining test data and scenarios
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test cases verify that the application will behave as expected when deployed
    to production. The tests also ensure that the expectations are still met when
    new features are developed.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: However, it's not sufficient to define test scenarios and test data only once.
    Business logic will evolve and change over time and test cases need to adapt.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Importance of maintainable tests
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both for writing and managing test cases, it's crucial to create maintainable
    test code. Over time the number of test cases will increase. In order to stay
    productive during development, some time and effort needs to be spent on the test
    code quality.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: For production code, every engineer agrees that code quality is an important
    requirement. Since tests are not part of the application that is running in production
    they are often treated differently. Experience shows that developers rarely invest
    time and effort in test code quality. However, the quality of test cases has a
    huge impact on the developer's productivity.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: There are some signs that indicate poorly written tests.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Signs of lack of test quality
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally speaking, development time that is overly spent in test code rather
    than in production code can be a sign of poorly designed or crafted tests. A feature
    that is being implemented or changed will cause some tests to fail. How fast can
    the test code adapt? How many occurrences of test data or functionality are there
    that need to be changed? How easy is it to add test cases to the existing code
    base?
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Failing tests that are being `@Ignored` for more than a very short period of
    time are also an indicator of a potential flaw in test quality. If the test case
    is logically still relevant, it needs to be stabilized and fixed. If it becomes
    obsolete, it should be deleted. However, tests should never be deleted in order
    to save time and effort that would be necessary to fix them when the test scenarios
    would logically still be relevant.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 被忽略超过非常短时间的失败测试也是测试质量潜在缺陷的指标。如果测试用例在逻辑上仍然相关，它需要被稳定下来并修复。如果它变得过时，它应该被删除。然而，为了节省修复测试用例所需的时间和精力，不应该删除测试，因为当测试场景在逻辑上仍然相关时。
- en: Copy and pasting test code should also be an alarming signal. This practice
    is sadly quite common in enterprise projects, especially when test scenarios slightly
    differ in their behavior. Copy and pasting violates the **don't repeat yourself**
    (**DRY**) principle and introduces a lot of duplication which makes future changes
    expensive.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 复制粘贴测试代码也应该是一个令人警觉的信号。这种做法在企业项目中相当普遍，尤其是在测试场景的行为略有不同时。复制粘贴违反了**不要重复自己**（**DRY**）原则，并引入了大量重复，使得未来的更改变得昂贵。
- en: Test code quality
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码质量
- en: While production code quality is important for keeping a constant development
    velocity, test code quality is so as well. Tests, however, are mostly not treated
    in the same way. Experience shows that enterprise projects rarely invest time
    and effort into refactoring tests.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然生产代码的质量对于保持恒定的开发速度很重要，但测试代码的质量也同样重要。然而，测试通常并没有得到同等的对待。经验表明，企业项目很少投入时间和精力去重构测试代码。
- en: In general the same practices for high code quality apply for test code as they
    do for live code. Certain principles are especially important for tests.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于高代码质量的做法适用于测试代码，就像它们适用于实时代码一样。某些原则对于测试尤为重要。
- en: First of all, the DRY principle certainly has its importance. On code level
    this means to avoid repeating definitions, test procedures, and code duplication
    that contains just minor differences.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，DRY原则当然很重要。在代码层面，这意味着避免重复定义、测试流程以及包含微小差异的代码重复。
- en: For test data, the same principle applies. Experience shows that multiple test
    case scenarios that use similar test data tempt developers to use copy and pasting.
    However, doing so will lead to an unmaintainable code base, once changes in the
    test data have to be made.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试数据，同样的原则也适用。经验表明，使用类似测试数据的多个测试用例场景会诱使开发者使用复制粘贴。然而，这样做一旦测试数据发生变化，就会导致代码库难以维护。
- en: The same is true for assertions and mock verifications. Assert statements and
    verifications that are applied one by one directly in the test method, similarly
    lead to duplication and challenges with maintenance.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 对于断言和模拟验证也是如此。逐个直接在测试方法中应用的断言语句和验证同样会导致重复和维护挑战。
- en: Typically the biggest issue in test code quality is missing abstraction layers.
    Test cases too often contain different aspects and responsibilities. They mix
    business with technical concerns.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，测试代码质量的最大问题是缺少抽象层。测试用例往往包含不同的方面和责任。它们将业务与技术问题混合在一起。
- en: 'Let me give an example of a poorly written system test in pseudo code:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给出一个伪代码中编写不良的系统测试的例子：
- en: '[PRE22]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Readers might have noticed that it requires quite some effort to comprehend
    the test case. The inline comments provide some help, but comments like these
    are in general rather a sign of poorly constructed code.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可能已经注意到，理解测试用例需要付出相当大的努力。内联注释提供了一些帮助，但这类注释通常只是代码结构不佳的标志。
- en: The example, however, is similar to the system test example crafted previously.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个例子与之前精心制作的系统测试示例相似。
- en: The challenge with test cases like these is not only that they're harder to
    comprehend. Mixing multiple concerns, both technically and business motivated
    into a single class, or even a single method, introduces duplication and rules
    out maintainability. What if the payload of the car manufacture service changes?
    What if the logical flow of the test case changes? What if new test cases with
    similar flow but different data need to be written? Do developers copy and paste
    all code and modify the few aspects then? Or what if the overall communication
    changes from HTTP to another protocol?
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试用例的挑战不仅在于它们更难理解。将多个关注点，无论是技术还是业务驱动的，混合到一个类中，或者甚至是一个方法中，会导致代码重复，并排除可维护性。如果汽车制造服务的有效负载发生变化怎么办？如果测试用例的逻辑流程发生变化怎么办？如果需要编写具有类似流程但不同数据的新的测试用例怎么办？开发者是否需要复制粘贴所有代码并修改少数几个方面？或者如果整体通信从HTTP变为其他协议怎么办？
- en: For test cases, the most important code quality principles are to apply proper
    abstraction layers together with delegation.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试用例，最重要的代码质量原则是应用适当的抽象层以及委托。
- en: Developers need to ask themselves which concerns this test scenario has. There
    is the test logical flow, verifying the creation of a car with required steps.
    There is the communication part, involving HTTP invocations and JSON mapping.
    There might be an external system involved, maybe represented as a mock server
    that needs to be controlled. And there are assertions and verifications to be
    performed on these different aspects.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者需要问自己这个测试场景有哪些关注点。有测试逻辑流程，验证按照所需步骤创建一辆车。有通信部分，涉及HTTP调用和JSON映射。可能还涉及外部系统，可能表示为需要控制的模拟服务器。并且需要对这些不同方面进行断言和验证。
- en: This is the reason why we crafted the previous system test example with several
    components, all of them concerning different responsibilities. There should be
    one component for accessing the application under test, including all communication
    implementation details required. In the previous example, this was the responsibility
    of the car manufacturer delegate.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们精心设计了之前的系统测试示例，其中包含多个组件，它们都涉及不同的责任。应该有一个组件用于访问正在测试的应用程序，包括所有所需的通信实现细节。在之前的示例中，这是汽车制造商委托的责任。
- en: Similar to the assembly line delegate, it makes sense to add one component for
    every mock system involved. These components encapsulate configuration, control,
    and verification behavior of the mock servers.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于装配线委托，为每个涉及的模拟系统添加一个组件是有意义的。这些组件封装了模拟服务器的配置、控制和验证行为。
- en: Verifications that are made on test business level are advisably outsourced
    as well, either into private methods or delegates depending on the situation.
    The test delegates can then again encapsulate logic into more abstraction layers,
    if required by the technology or the test case.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试业务级别进行的验证也应建议外包，无论是私有方法还是委托，具体取决于情况。测试委托可以再次将逻辑封装到更多的抽象层中，如果技术或测试用例需要的话。
- en: All of these delegate classes and methods become single points of responsibility.
    They are reused within all similar test cases. Potential changes only affect the
    points of responsibility, leaving other parts of the test cases unaffected.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些委托类和方法都成为单一的责任点。它们在所有类似的测试用例中都被重用。潜在的变化只会影响责任点，而不会影响测试用例的其他部分。
- en: This requires the definition of clear interfaces between the components that
    don't leak the implementation details. For this reason it makes sense, especially
    for the system test scope, to have a dedicated, simple model representation. This
    model can be implemented simply and straightforward with potentially less type
    safety than the production code.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要定义组件之间的清晰接口，这些接口不会泄露实现细节。因此，对于系统测试范围来说，有一个专门的、简单的模型表示是有意义的。这个模型可以简单地直接实现，可能比生产代码具有更少的类型安全性。
- en: A reasonable green field approach, similar to the previous system test example,
    is to start with writing comments and continuously replacing them with delegates
    while going down the abstraction layers. This starts with what the test logically
    executes first, implementation details second. Following that approach naturally
    avoids mixing business and technical test concerns. It also enables simpler integration
    of test technology that supports writing tests productively, such as **Cucumber-JVM**
    or **FitNesse**.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Test technology support
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some test technology also support crafting maintainable tests. AssertJ, for
    example, provides the possibility to create custom assertions. In our test case
    the car needs to verify the correct engine and color encapsulated into car specifications.
    Custom assertions can decrease overall duplication in the test scope.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows a custom `AssertJ` assertion for verifying a car:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The assertion is then usable within the test scope. The correct static import
    of the `CarAssert` class has to be chosen for the `assertThat()` method:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The examples in this chapter showed tests written mainly with Java, JUnit, and
    Mockito, with the exception of embedded application containers and Gatling. There
    are dozens of other test technologies that uses different frameworks as well as
    dynamic JVM languages.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: A famous example of this the **Spock Testing Framework** which uses Groovy.
    The motivation behind this technology was to write leaner, more maintainable tests.
    Since dynamic JVM languages such as Groovy or Scala are less verbose than plain
    Java, this idea sounds reasonable.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Test frameworks, such as Spock, indeed result in test cases that require minimal
    code. They make use of dynamic JVM language features such as less-constraint method
    names such as `def "car X123A234 should be created"()`. Spock testing also provides
    clear readability with low effort.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: However, readable tests are achievable with all test technologies if test code
    quality is minded. Maintainability, in particular, is rather a question of well-crafted
    test cases and proper abstraction layers than of the technology being used. Once
    test cases become quite complex, the impact of the technology on maintainability
    becomes less relevant.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: When choosing test technology, the team's familiarity with the technology should
    also be considered. At the time of writing, enterprise Java developers are usually
    less familiar with dynamic JVM languages.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: However, the test code quality should be more important than the used technology.
    Applying good practices of software engineering to tests should be considered
    as mandatory, using other test frameworks as optional. Refactoring test cases
    frequently increases the maintainability and reusability of test components and
    ultimately the quality of the software project.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tests are required to verify software functionality in simulated environments.
    Software tests should run predictably, isolated, reliably, fast, and in an automated
    way. In order to enable productive project life cycles, it's important to keep
    tests maintainable.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 测试需要在模拟环境中验证软件功能。软件测试应该可预测、隔离、可靠、快速，并以自动化的方式进行。为了使项目生命周期更加高效，保持测试的可维护性非常重要。
- en: Unit tests verify the behavior of individual units of an application, mostly
    single entity, boundary, or control classes. Component tests verify the behavior
    of coherent components. Integration tests fulfill the need to verify the interaction
    of the Java EE components. Database integration tests use embedded databases together
    with standalone JPA to verify the persistence mapping. System tests verify deployed
    applications that run on actual environments. Container orchestration heavily
    supports running system test environments with potential mock applications.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试验证应用程序单个单元的行为，通常是单个实体、边界或控制类。组件测试验证一致组件的行为。集成测试满足验证 Java EE 组件交互的需求。数据库集成测试使用嵌入式数据库与独立的
    JPA 一起验证持久化映射。系统测试验证在真实环境中运行的应用程序。容器编排强烈支持运行带有潜在模拟应用程序的系统测试环境。
- en: In order to verify functionality before it is pushed to the central repository,
    engineers need the ability to run tests on their local environment. Changes that
    contain careless mistakes disturb other teammates by unnecessarily breaking the
    build. Docker, Docker Compose, and Kubernetes can run on local environments as
    well, enabling developers to verify behavior upfront. It's advisable to craft
    simple automation scripts that include the required steps.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在将功能推送到中央仓库之前验证其功能，工程师需要能够在本地环境中运行测试。包含粗心大意的错误更改会通过不必要的破坏构建来打扰其他团队成员。Docker、Docker
    Compose 和 Kubernetes 也可以在本地环境中运行，使开发者能够事先验证行为。建议编写简单的自动化脚本，包括所需的步骤。
- en: In order to achieve a constant development velocity, it's required to develop
    maintainable test cases. In general, test code should have a similar quality to
    production code. This includes refactoring, proper abstraction layers, and software
    quality in general.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现恒定的开发速度，需要开发可维护的测试用例。一般来说，测试代码应该与生产代码具有相似的质量。这包括重构、适当的抽象层和软件质量。
- en: These approaches are, in fact, more helpful than introducing sophisticated test
    frameworks using dynamic JVM languages. Whereas frameworks such as Spock certainly
    enable readable, minimal test cases, the benefits of using proper practices of
    software craftsmanship have a more positive impact on the overall test code quality,
    especially once test scenarios become complex. No matter what testing technology
    is being used, software engineers are advised to mind the test code quality in
    order to keep test cases maintainable.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法实际上比使用动态 JVM 语言引入复杂的测试框架更有帮助。虽然像 Spock 这样的框架确实能够使测试用例易于阅读，但遵循软件工艺的正确实践对整体测试代码质量的影响更为积极，尤其是在测试场景变得复杂时。无论使用什么测试技术，软件工程师都应关注测试代码质量，以保持测试用例的可维护性。
- en: The following chapter will cover the topic of distributed systems and microservices
    architectures.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将涵盖分布式系统和微服务架构的主题。
