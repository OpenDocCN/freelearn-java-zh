- en: Chapter 8. The Java Message Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Java Message Service** (**JMS**) **API** provides a mechanism for Java
    EE applications to send messages to each other. Java EE 7 introduces JMS 2.0,
    a new version of JMS that greatly simplifies the development of applications involving
    messaging functionality.
  prefs: []
  type: TYPE_NORMAL
- en: JMS applications do not communicate directly; instead, message producers send
    messages to a destination, and message consumers receive that message from the
    destination.
  prefs: []
  type: TYPE_NORMAL
- en: The message destination is a message queue when the **Point-to-Point** (**PTP**)
    messaging domain is used, and a message topic when the Publish/Subscribe (pub/sub)
    messaging domain is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up GlassFish for JMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with message queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with message topics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up GlassFish for JMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can start writing code to take advantage of the JMS API, we need to
    configure some GlassFish resources. Specifically, we need to set up a JMS Connection
    Factory, a message queue, and a message topic.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java EE 7 requires all compliant application servers to provide a default JMS
    connection factory. GlassFish, which is a fully compliant Java EE 7 application
    server (and the Java EE 7 reference implementation), complies with this requirement;
    so strictly speaking, we don't really need to set up a connection factory, however,
    in many cases we may need to set one up. Therefore, in the following section we
    illustrate how set up can be done.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a JMS connection factory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to set up a JMS connection factory is via GlassFish''s web
    console. Recall from [Chapter 1](ch01.html "Chapter 1. Getting Started with GlassFish"),
    *Getting Started with GlassFish*, that the web console can be accessed by starting
    our domain by entering the following command in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then, go to `http://localhost:4848` and log in.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a JMS connection factory](img/6886EN_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A connection factory can be added by expanding the **Resources** node in the
    tree to the left-hand side of the web console; to do this, expand the **JMS Resources**
    node, click on the **Connection Factories** node, and then click on the **New...**
    button in the main area of the web console.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a JMS connection factory](img/6886EN_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For our purposes, we can maintain most of the defaults; the only thing we need
    to do is enter a pool name in the **JNDI Name** field and pick a resource type
    for our connection factory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is always a good idea to use a pool name starting with `"jms/"` when naming
    JMS resources. This way, JMS resources can be easily identified when browsing
    a JNDI tree.
  prefs: []
  type: TYPE_NORMAL
- en: In the field labeled **JNDI Name**, enter `jms/GlassFishBookConnectionFactory`.
    Our code examples later in this chapter will use this JNDI name to obtain a reference
    to this connection factory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Resource Type** dropdown has the following three options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**javax.jms.TopicConnectionFactory**: This option is used to create a connection
    factory that creates JMS topics for JMS clients using the pub/sub messaging domain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**javax.jms.QueueConnectionFactory**: This option is used to create a connection
    factory that creates JMS queues for JMS clients using the PTP messaging domain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**javax.jms.ConnectionFactory**: This option is used to create a connection
    factory that creates either JMS topics or JMS queues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our example, we will select **javax.jms.ConnectionFactory**; this way, we
    can use the same connection factory for all of our examples, those using the PTP
    messaging domain and the pub/sub messaging domain.
  prefs: []
  type: TYPE_NORMAL
- en: After entering the pool name in the **JNDI Name** field for our connection factory,
    selecting a connection factory type, and optionally entering a description for
    our connection factory, we need to click on the **OK** button for the changes
    to take effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should then see our newly created connection factory (**jms/GlassFishBookConnectionFactory**)
    listed in the main area of the GlassFish web console, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a JMS connection factory](img/6886EN_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up a JMS queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A JMS queue can be added by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Expand the **Resources** node in the tree at the left-hand side of the web console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a value in the **JNDI Name** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a value in the **Physical Destination Name** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **javax.jms.Queue** in the **Resource Type** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **OK** button.![Setting up a JMS queue](img/6886EN_08_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our example, the JNDI name of the message queue is `jms/GlassFishBookQueue`.
    The resource type for message queues must be `javax.jms.Queue`. Additionally,
    a value must be entered in the **Physical Destination Name** field. In our example,
    we use `GlassFishBookQueue` as the value for this field.
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking on the **OK** button, we should see the newly created queue,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a JMS queue](img/6886EN_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up a JMS topic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting up a JMS topic in GlassFish is very similar to setting up a message
    queue. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Expand the JMS **Resources** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Destination** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **New...** button in the main area of the web console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a name for our topic in the **JNDI Name** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a physical destination name for our topic in the **Physical Destination
    Name** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **javax.jms.Topic** from the **Resource Type** dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **OK** button, shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Setting up a JMS topic](img/6886EN_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our examples will use `jms/GlassFishBookTopic` in the **JNDI Name** field. Since
    this is a message topic, **Resource Type** must be set to `javax.jms.Topic`. The
    **Description** field is optional. The **Physical Destination Name** property
    is required; for our example, we will use `GlassFishBookTopic` as the value for
    this property.
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking on the **OK** button, we can see our newly created message topic
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a JMS topic](img/6886EN_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have set up a connection factory, a message queue, and a message
    topic, we are ready to start writing code using the JMS API.
  prefs: []
  type: TYPE_NORMAL
- en: Working with message queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like we mentioned earlier, message queues are used when our JMS code uses the
    **Point-To-Point** (**PTP**) messaging domain. For the PTP messaging domain, there
    is usually one message producer and one message consumer. The message producer
    and the message consumer don't need to be running concurrently in order to communicate.
    The messages placed in the message queue by the message producer will stay there
    until the message consumer executes and requests for the messages from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages to a message queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sending messages to a JMS queue consists of injecting a few resources to our
    code and making a few simple JMS API calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how to add messages to a message queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Before delving into the details of our code, alert readers may have noticed
    that the `MessageSender` class is a standalone Java application, since it contains
    a main method. Since this class is standalone, it is executed outside of the application
    server; yet, we can see that some resources are injected into it, specifically
    the connection factory object and the queue. The reason we can inject resources
    into this code even though it runs outside the application server is because GlassFish
    includes a utility called `appclient`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This utility allows us to "wrap" an executable JAR file and allow it to have
    access to the application server resources. To execute our code, assuming it is
    packaged in an executable JAR file called `jmsptpproducer.jar`, we would type
    the following in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We would then see, after some GlassFish log entries, the following output on
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `appclient` executable script can be found under `[GlassFish installation
    directory]/glassfish/bin`; our example assumes that this directory is in the `PATH`
    variable and if it isn't, the complete path to the `appclient` script must be
    typed in the command line.
  prefs: []
  type: TYPE_NORMAL
- en: With that out of the way, we can now explain the code.
  prefs: []
  type: TYPE_NORMAL
- en: The `produceMessages()` method performs all the necessary steps to send messages
    to a message queue.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing this method does is create an instance of `javax.jms.JMSContext`
    by invoking the `createContext()` method on the injected instance of `javax.jms.ConnectionFactory`.
    Notice that the `mappedName` attribute of the `@Resource` annotation decorating
    the connection factory object matches the JNDI name of the connection factory
    we set up in the GlassFish web console. Behind the scenes, a JNDI lookup is made
    using this name to obtain the connection factory object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create an instance of `javax.jms.JMSProducer` by invoking the `createProducer()`
    method on the `JMSContext` instance we just created.
  prefs: []
  type: TYPE_NORMAL
- en: After obtaining an instance of `JMSProducer`, the code sends a series of text
    messages by invoking its `send()` method; this method takes the message destination
    as its first parameter, and a string containing the message text as its second
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: There are several overloaded versions of the `send()` method in `JMSProducer`;
    the one we used in our example is a convenience method that creates an instance
    of `javax.jms.TextMessage` and sets its text to the string we provide as the second
    parameter in the method invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Although our example sends only text messages to the queue, we are not limited
    to sending only this type of message. The JMS API provides several types of messages
    that can be sent and received by JMS applications. All message types are defined
    as interfaces in the `javax.jms` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists all of the available message types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Message Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `BytesMessage` | Allows sending an array of bytes as a message. `JMSProducer`
    has a convenience `send()` method that takes an array of bytes as one of its parameters;
    this method creates an instance of `javax.jms.BytesMessage` on the fly as the
    message is being sent. |'
  prefs: []
  type: TYPE_TB
- en: '| `MapMessage` | Allows sending an implementation of `java.util.Map` as a message.
    `JMSProducer` has a convenience `send()` method that takes a `Map` as one of its
    parameters; this method creates an instance of `javax.jms.MapMessage` on the fly
    as the message is being sent. |'
  prefs: []
  type: TYPE_TB
- en: '| `ObjectMessage` | Allows sending any Java object implementing `java.io.Serializable`
    as a message. `JMSProducer` has a convenience `send()` method that takes an instance
    of a class implementing `java.io.Serializable` as its second parameter; this method
    creates an instance of `javax.jms.ObjectMessage` on the fly as the message is
    being sent. |'
  prefs: []
  type: TYPE_TB
- en: '| `StreamMessage` | Allows sending an array of bytes as a message. Differs
    from `BytesMessage` in that it stores the type of each primitive type added to
    the stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `TextMessage` | Allows sending `java.lang.String` as a message. As seen in
    our example, `JMSProducer` has a convenience `send()` method that takes `String`
    type as its second parameter; this method creates an instance of `javax.jms.TextMessage`
    on the fly as the message is being sent. |'
  prefs: []
  type: TYPE_TB
- en: For more information on all JMS message types, consult their JavaDoc documentation
    at [http://docs.oracle.com/javaee/7/api/](http://docs.oracle.com/javaee/7/api/).
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving messages from a message queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, there is no point in sending messages from a queue if nothing is
    going to receive them. The following example illustrates how to retrieve messages
    from a JMS message queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Just like in the previous example, an instance of `javax.jms.ConnectionFactory`
    and an instance of `javax.jms.Queue` are injected using the `@Resource` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: In our code, we get an instance of `javax.jms.JMSContext` by invoking the `createContext()`
    method of `ConnectionFactory`, just like in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we obtain an instance of `javax.jms.JMSConsumer` by calling
    the `createConsumer()` method on our `JMSContext` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Messages are received by invoking the `receiveBody()` method on our instance
    of `JMSConsumer`. This method takes the type of the message we are expecting as
    its sole parameter (`String.class` in our example). This method returns an object
    of the type specified in its parameter (an instance of `java.lang.String` in our
    example).
  prefs: []
  type: TYPE_NORMAL
- en: In this particular example, we placed this method call in a `while` loop since
    we are expecting a message that will let us know that no more messages are coming.
    Specifically, we are looking for a message containing the text `"Good bye!"`.
    Once we receive that message, we break out of the loop and continue with further
    processing. In this particular case, there is no more processing left to do, therefore,
    execution ends after we break out of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like in the previous example, using the `appclient` utility allows us
    to inject resources into the code and prevents us from having to add any libraries
    to the CLASSPATH. After executing the code through the `appclient` utility, we
    should see the following output in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The previous example placed some messages on the queue. This example retrieves
    the messages. If the previous example has not been executed yet, then there are
    no messages to retrieve.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronously receiving messages from a message queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `JMSConsumer.receiveBody()` method has a disadvantage: it blocks execution
    until a message is received from the queue. We worked around this limitation in
    our previous example by breaking out of the loop once we received a specific message
    (`"Good bye!"`).'
  prefs: []
  type: TYPE_NORMAL
- en: We can prevent our JMS consumer code from blocking execution by receiving messages
    asynchronously via an implementation of the `javax.jms.MessageListener` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `javax.jms.MessageListener` interface contains a single method called `onMessage`,
    it takes an instance of a class implementing the `javax.jms.Message` interface
    as its sole parameter. The following example illustrates a typical implementation
    of this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `onMessage()` method simply outputs the message text to the
    console. Recall that behind the scenes, the JMS API creates instances of `javax.jms.TextMessage`
    when we invoke `JMSProducer.send()` with a `String` as its second parameter; our
    `MessageListener` implementation casts the `Message` instance it receives as a
    parameter to `TextMessage`, and then gets the `String message` sent by the `JMSProducer`
    variable, invoking its `getText()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our main code can now delegate message retrieval to our custom `MessageListener`
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The only relevant difference between this example and the one in the previous
    section is that in this case, we are calling the `setMessageListener()` method
    on the instance of `javax.jms.JMSConsumer` obtained from the JMS context. We pass
    an instance of our custom implementation of `javax.jms.MessageListener` to this
    method; its `onMessage()` method is automatically called whenever there is a message
    waiting in the queue. Using this approach, the main code does not block execution
    while it is waiting to receive messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the preceding example (using, of course, GlassFish''s `appclient`
    utility), results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the messages were received and processed while the main thread was
    executing. We can tell that this is the case because the output of our `MessageListener`
    class' `onMessage()` method can be seen between calls to `System.out.println()`
    in the primary class.
  prefs: []
  type: TYPE_NORMAL
- en: Browsing message queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JMS provides a way to browse message queues without actually removing the messages
    from the queue. The following example illustrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the procedure to browse messages in a message queue is straightforward.
    We obtain a JMS connection factory, a JMS queue, and a JMS context in the usual
    way, and then invoke the `createBrowser()` method on the JMS context object. This
    method returns an implementation of the `javax.jms.QueueBrowser` interface, containing
    a `getEnumeration()` method that we can invoke to obtain an `Enumeration` containing
    all messages in the queue. To examine the messages in the queue, we simply traverse
    this enumeration and obtain the messages one by one. In our example, we simply
    invoked the `getText()` method of each message in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Working with message topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Message topics are used when our JMS code uses the Publish/Subscribe (pub/sub)
    messaging domain. When using this messaging domain, the same message can be sent
    to all subscribers of a topic.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages to a message topic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sending messages to a JMS topic is very similar to sending messages to a queue;
    simply inject the required resources and make some simple JMS API calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how to send messages to a message topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, this example is nearly identical to the `MessageSender` class
    we saw when we discussed Point-To-Point messaging. As a matter of fact, the only
    lines of code that are different are those that are highlighted. The JMS API was
    designed this way so that application developers do not have to learn two different
    APIs for the PTP and pub/sub domains.
  prefs: []
  type: TYPE_NORMAL
- en: Since the code is nearly identical to the corresponding example in the *Working
    with message queues* section, we will only explain the differences between the
    two examples. In this example, instead of declaring an instance of a class implementing
    `javax.jms.Queue`, we declare an instance of a class implementing `javax.jms.Topic`.
    We will then pass this instance of `javax.jms.Topic` as the first parameter of
    the `send()` method of our `JMSProducer` object, along with the message we wish
    to send.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving messages from a message topic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as sending messages to a message topic is nearly identical to sending
    messages to a message queue, receiving messages from a message topic is nearly
    identical to receiving messages from a message queue, as can be seen in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the differences between this code and the corresponding code for
    PTP messaging are simple. Instead of declaring an instance of a class implementing
    `javax.jms.Queue`, we declare a class implementing `javax.jms.Topic`. We use the
    `@Resource` annotation to inject an instance of this class into our code using
    the JNDI name we used when creating it in the GlassFish web console. We then obtain
    an instance of `JMSContext` and `JMSConsumer` as we did before, and then receive
    the messages from the topic by invoking the `receiveBody()` method on `JMSConsumer`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the pub/sub messaging domain as illustrated in this section has the advantage
    that messages can be sent to several message consumers. This can be easily tested
    by concurrently executing two instances of the `MessageReceiver` class we developed
    in this section, and then executing the `MessageSender` class we developed in
    the previous section. We should see the console output for each instance, indicating
    that both instances received all messages.
  prefs: []
  type: TYPE_NORMAL
- en: Just like with message queues, messages can be retrieved asynchronously from
    a message topic. The procedure to do so is so similar to the message queue version
    that we will not show an example. To convert the asynchronous example shown earlier
    in this chapter to use a message topic, simply replace the `javax.jms.Queue` variable
    with an instance of `javax.jms.Topic` and inject the appropriate instance using
    `"jms/GlassFishBookTopic"` as the value of the `mappedName` attribute of the `@Resource`
    annotation decorating the instance of `javax.jms.Topic`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating durable subscribers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The disadvantage of using the pub/sub messaging domain is that message consumers
    must be running when the messages are sent to the topic. If the message consumer
    is not running at the time, it will not receive the messages; whereas, in PTP,
    messages are kept in the queue until the message consumer runs. Fortunately, the
    JMS API provides a way to use the pub/sub messaging domain and keep messages in
    the topic until all subscribed message consumers run and receive the message.
    This can be accomplished by creating durable subscribers for a JMS topic.
  prefs: []
  type: TYPE_NORMAL
- en: In order to be able to serve durable subscribers, we need to set the `ClientId`
    property of our JMS connection factory. Each durable subscriber must have a unique
    client ID; therefore, a unique connection factory must be declared for each potential
    durable subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**InvalidClientIdException?**'
  prefs: []
  type: TYPE_NORMAL
- en: Only one JMS client can connect to a topic for a specific client ID. If more
    than one JMS client attempts to obtain a JMS connection using the same connection
    factory, a `JMSException` stating that the Client ID is already in use will be
    thrown. The solution is to create a connection factory for each potential client
    that will be receiving messages from the durable topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like we mentioned before, the easiest way to add a connection factory is through
    the GlassFish web console, as shown in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Expand the **Resources** node to the left-hand side of the web console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **JMS Resources** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Connection Factories** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **New...** button in the main area of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our next example will use the settings displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating durable subscribers](img/6886EN_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before clicking on the **OK** button, we need to scroll to the bottom of the
    page, click on the **Add Property** button, and enter a new property named `ClientId`.
    Our example will use `ExampleId` as the value for this property, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating durable subscribers](img/6886EN_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have set up GlassFish to be able to provide durable subscriptions,
    we are ready to write some code to take advantage of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, this code is not very different from the previous examples of
    code, the purpose of which was to retrieve messages. There are only two differences
    from previous examples: the instance of `ConnectionFactory` that we are injecting
    is the one we set up earlier in this section to handle durable subscriptions,
    and instead of calling the `createConsumer()` method on the JMS context object,
    we are calling `createDurableConsumer()`. The `createDurableConsumer()` method
    takes two arguments: a JMS topic object to retrieve messages from and a `String`
    designating a name for this subscription. This second parameter must be unique
    across all subscribers to that durable topic.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to set up JMS connection factories, JMS message
    queues, and JMS message topics in GlassFish using the GlassFish web console.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered how to send messages to a message queue via the `javax.jms.JMSProducer`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we covered how to receive messages from a message queue via the
    `javax.jms.JMSConsumer` interface. We also covered how to asynchronously receive
    messages from a message queue by implementing the `javax.jms.MessageListener`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how to use these interfaces to send and receive messages to and
    from a JMS message topic.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered how to browse messages in a message queue without removing them
    from the queue via the `javax.jms.QueueBrowser` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how to set up and interact with durable subscriptions to JMS
    topics.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover how to secure Java EE applications.
  prefs: []
  type: TYPE_NORMAL
