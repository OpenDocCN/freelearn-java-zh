- en: Chapter 8. The Java Message Service
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Java Message Service** (**JMS**) **API** provides a mechanism for Java
    EE applications to send messages to each other. Java EE 7 introduces JMS 2.0,
    a new version of JMS that greatly simplifies the development of applications involving
    messaging functionality.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: JMS applications do not communicate directly; instead, message producers send
    messages to a destination, and message consumers receive that message from the
    destination.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The message destination is a message queue when the **Point-to-Point** (**PTP**)
    messaging domain is used, and a message topic when the Publish/Subscribe (pub/sub)
    messaging domain is used.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Setting up GlassFish for JMS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with message queues
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with message topics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up GlassFish for JMS
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can start writing code to take advantage of the JMS API, we need to
    configure some GlassFish resources. Specifically, we need to set up a JMS Connection
    Factory, a message queue, and a message topic.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java EE 7 requires all compliant application servers to provide a default JMS
    connection factory. GlassFish, which is a fully compliant Java EE 7 application
    server (and the Java EE 7 reference implementation), complies with this requirement;
    so strictly speaking, we don't really need to set up a connection factory, however,
    in many cases we may need to set one up. Therefore, in the following section we
    illustrate how set up can be done.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a JMS connection factory
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to set up a JMS connection factory is via GlassFish''s web
    console. Recall from [Chapter 1](ch01.html "Chapter 1. Getting Started with GlassFish"),
    *Getting Started with GlassFish*, that the web console can be accessed by starting
    our domain by entering the following command in the command line:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, go to `http://localhost:4848` and log in.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a JMS connection factory](img/6886EN_08_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: A connection factory can be added by expanding the **Resources** node in the
    tree to the left-hand side of the web console; to do this, expand the **JMS Resources**
    node, click on the **Connection Factories** node, and then click on the **New...**
    button in the main area of the web console.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a JMS connection factory](img/6886EN_08_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: For our purposes, we can maintain most of the defaults; the only thing we need
    to do is enter a pool name in the **JNDI Name** field and pick a resource type
    for our connection factory.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is always a good idea to use a pool name starting with `"jms/"` when naming
    JMS resources. This way, JMS resources can be easily identified when browsing
    a JNDI tree.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: In the field labeled **JNDI Name**, enter `jms/GlassFishBookConnectionFactory`.
    Our code examples later in this chapter will use this JNDI name to obtain a reference
    to this connection factory.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Resource Type** dropdown has the following three options:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '**javax.jms.TopicConnectionFactory**: This option is used to create a connection
    factory that creates JMS topics for JMS clients using the pub/sub messaging domain'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**javax.jms.QueueConnectionFactory**: This option is used to create a connection
    factory that creates JMS queues for JMS clients using the PTP messaging domain'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**javax.jms.ConnectionFactory**: This option is used to create a connection
    factory that creates either JMS topics or JMS queues'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our example, we will select **javax.jms.ConnectionFactory**; this way, we
    can use the same connection factory for all of our examples, those using the PTP
    messaging domain and the pub/sub messaging domain.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: After entering the pool name in the **JNDI Name** field for our connection factory,
    selecting a connection factory type, and optionally entering a description for
    our connection factory, we need to click on the **OK** button for the changes
    to take effect.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'We should then see our newly created connection factory (**jms/GlassFishBookConnectionFactory**)
    listed in the main area of the GlassFish web console, as shown in the following
    screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a JMS connection factory](img/6886EN_08_03.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: Setting up a JMS queue
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A JMS queue can be added by going through the following steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Expand the **Resources** node in the tree at the left-hand side of the web console.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a value in the **JNDI Name** field.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a value in the **Physical Destination Name** field.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **javax.jms.Queue** in the **Resource Type** field.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **OK** button.![Setting up a JMS queue](img/6886EN_08_04.jpg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our example, the JNDI name of the message queue is `jms/GlassFishBookQueue`.
    The resource type for message queues must be `javax.jms.Queue`. Additionally,
    a value must be entered in the **Physical Destination Name** field. In our example,
    we use `GlassFishBookQueue` as the value for this field.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking on the **OK** button, we should see the newly created queue,
    as shown in the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a JMS queue](img/6886EN_08_05.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: Setting up a JMS topic
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting up a JMS topic in GlassFish is very similar to setting up a message
    queue. Perform the following steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Expand the JMS **Resources** node.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Destination** node.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **New...** button in the main area of the web console.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a name for our topic in the **JNDI Name** field.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a physical destination name for our topic in the **Physical Destination
    Name** field.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **javax.jms.Topic** from the **Resource Type** dropdown.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **OK** button, shown in the following screenshot:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Setting up a JMS topic](img/6886EN_08_06.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: Our examples will use `jms/GlassFishBookTopic` in the **JNDI Name** field. Since
    this is a message topic, **Resource Type** must be set to `javax.jms.Topic`. The
    **Description** field is optional. The **Physical Destination Name** property
    is required; for our example, we will use `GlassFishBookTopic` as the value for
    this property.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking on the **OK** button, we can see our newly created message topic
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a JMS topic](img/6886EN_08_07.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: Now that we have set up a connection factory, a message queue, and a message
    topic, we are ready to start writing code using the JMS API.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Working with message queues
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like we mentioned earlier, message queues are used when our JMS code uses the
    **Point-To-Point** (**PTP**) messaging domain. For the PTP messaging domain, there
    is usually one message producer and one message consumer. The message producer
    and the message consumer don't need to be running concurrently in order to communicate.
    The messages placed in the message queue by the message producer will stay there
    until the message consumer executes and requests for the messages from the queue.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages to a message queue
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sending messages to a JMS queue consists of injecting a few resources to our
    code and making a few simple JMS API calls.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how to add messages to a message queue:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Before delving into the details of our code, alert readers may have noticed
    that the `MessageSender` class is a standalone Java application, since it contains
    a main method. Since this class is standalone, it is executed outside of the application
    server; yet, we can see that some resources are injected into it, specifically
    the connection factory object and the queue. The reason we can inject resources
    into this code even though it runs outside the application server is because GlassFish
    includes a utility called `appclient`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'This utility allows us to "wrap" an executable JAR file and allow it to have
    access to the application server resources. To execute our code, assuming it is
    packaged in an executable JAR file called `jmsptpproducer.jar`, we would type
    the following in the command line:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We would then see, after some GlassFish log entries, the following output on
    the console:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `appclient` executable script can be found under `[GlassFish installation
    directory]/glassfish/bin`; our example assumes that this directory is in the `PATH`
    variable and if it isn't, the complete path to the `appclient` script must be
    typed in the command line.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: With that out of the way, we can now explain the code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The `produceMessages()` method performs all the necessary steps to send messages
    to a message queue.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The first thing this method does is create an instance of `javax.jms.JMSContext`
    by invoking the `createContext()` method on the injected instance of `javax.jms.ConnectionFactory`.
    Notice that the `mappedName` attribute of the `@Resource` annotation decorating
    the connection factory object matches the JNDI name of the connection factory
    we set up in the GlassFish web console. Behind the scenes, a JNDI lookup is made
    using this name to obtain the connection factory object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create an instance of `javax.jms.JMSProducer` by invoking the `createProducer()`
    method on the `JMSContext` instance we just created.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: After obtaining an instance of `JMSProducer`, the code sends a series of text
    messages by invoking its `send()` method; this method takes the message destination
    as its first parameter, and a string containing the message text as its second
    parameter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: There are several overloaded versions of the `send()` method in `JMSProducer`;
    the one we used in our example is a convenience method that creates an instance
    of `javax.jms.TextMessage` and sets its text to the string we provide as the second
    parameter in the method invocation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Although our example sends only text messages to the queue, we are not limited
    to sending only this type of message. The JMS API provides several types of messages
    that can be sent and received by JMS applications. All message types are defined
    as interfaces in the `javax.jms` package.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists all of the available message types:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '| Message Type | Description |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| `BytesMessage` | Allows sending an array of bytes as a message. `JMSProducer`
    has a convenience `send()` method that takes an array of bytes as one of its parameters;
    this method creates an instance of `javax.jms.BytesMessage` on the fly as the
    message is being sent. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| `MapMessage` | Allows sending an implementation of `java.util.Map` as a message.
    `JMSProducer` has a convenience `send()` method that takes a `Map` as one of its
    parameters; this method creates an instance of `javax.jms.MapMessage` on the fly
    as the message is being sent. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| `ObjectMessage` | Allows sending any Java object implementing `java.io.Serializable`
    as a message. `JMSProducer` has a convenience `send()` method that takes an instance
    of a class implementing `java.io.Serializable` as its second parameter; this method
    creates an instance of `javax.jms.ObjectMessage` on the fly as the message is
    being sent. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| `StreamMessage` | Allows sending an array of bytes as a message. Differs
    from `BytesMessage` in that it stores the type of each primitive type added to
    the stream. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| `TextMessage` | Allows sending `java.lang.String` as a message. As seen in
    our example, `JMSProducer` has a convenience `send()` method that takes `String`
    type as its second parameter; this method creates an instance of `javax.jms.TextMessage`
    on the fly as the message is being sent. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: For more information on all JMS message types, consult their JavaDoc documentation
    at [http://docs.oracle.com/javaee/7/api/](http://docs.oracle.com/javaee/7/api/).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving messages from a message queue
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, there is no point in sending messages from a queue if nothing is
    going to receive them. The following example illustrates how to retrieve messages
    from a JMS message queue:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Just like in the previous example, an instance of `javax.jms.ConnectionFactory`
    and an instance of `javax.jms.Queue` are injected using the `@Resource` annotation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: In our code, we get an instance of `javax.jms.JMSContext` by invoking the `createContext()`
    method of `ConnectionFactory`, just like in the previous example.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we obtain an instance of `javax.jms.JMSConsumer` by calling
    the `createConsumer()` method on our `JMSContext` instance.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Messages are received by invoking the `receiveBody()` method on our instance
    of `JMSConsumer`. This method takes the type of the message we are expecting as
    its sole parameter (`String.class` in our example). This method returns an object
    of the type specified in its parameter (an instance of `java.lang.String` in our
    example).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: In this particular example, we placed this method call in a `while` loop since
    we are expecting a message that will let us know that no more messages are coming.
    Specifically, we are looking for a message containing the text `"Good bye!"`.
    Once we receive that message, we break out of the loop and continue with further
    processing. In this particular case, there is no more processing left to do, therefore,
    execution ends after we break out of the loop.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like in the previous example, using the `appclient` utility allows us
    to inject resources into the code and prevents us from having to add any libraries
    to the CLASSPATH. After executing the code through the `appclient` utility, we
    should see the following output in the command line:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The previous example placed some messages on the queue. This example retrieves
    the messages. If the previous example has not been executed yet, then there are
    no messages to retrieve.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronously receiving messages from a message queue
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `JMSConsumer.receiveBody()` method has a disadvantage: it blocks execution
    until a message is received from the queue. We worked around this limitation in
    our previous example by breaking out of the loop once we received a specific message
    (`"Good bye!"`).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: We can prevent our JMS consumer code from blocking execution by receiving messages
    asynchronously via an implementation of the `javax.jms.MessageListener` interface.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'The `javax.jms.MessageListener` interface contains a single method called `onMessage`,
    it takes an instance of a class implementing the `javax.jms.Message` interface
    as its sole parameter. The following example illustrates a typical implementation
    of this interface:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, the `onMessage()` method simply outputs the message text to the
    console. Recall that behind the scenes, the JMS API creates instances of `javax.jms.TextMessage`
    when we invoke `JMSProducer.send()` with a `String` as its second parameter; our
    `MessageListener` implementation casts the `Message` instance it receives as a
    parameter to `TextMessage`, and then gets the `String message` sent by the `JMSProducer`
    variable, invoking its `getText()` method.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Our main code can now delegate message retrieval to our custom `MessageListener`
    implementation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The only relevant difference between this example and the one in the previous
    section is that in this case, we are calling the `setMessageListener()` method
    on the instance of `javax.jms.JMSConsumer` obtained from the JMS context. We pass
    an instance of our custom implementation of `javax.jms.MessageListener` to this
    method; its `onMessage()` method is automatically called whenever there is a message
    waiting in the queue. Using this approach, the main code does not block execution
    while it is waiting to receive messages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the preceding example (using, of course, GlassFish''s `appclient`
    utility), results in the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice how the messages were received and processed while the main thread was
    executing. We can tell that this is the case because the output of our `MessageListener`
    class' `onMessage()` method can be seen between calls to `System.out.println()`
    in the primary class.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Browsing message queues
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JMS provides a way to browse message queues without actually removing the messages
    from the queue. The following example illustrates how to do this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see, the procedure to browse messages in a message queue is straightforward.
    We obtain a JMS connection factory, a JMS queue, and a JMS context in the usual
    way, and then invoke the `createBrowser()` method on the JMS context object. This
    method returns an implementation of the `javax.jms.QueueBrowser` interface, containing
    a `getEnumeration()` method that we can invoke to obtain an `Enumeration` containing
    all messages in the queue. To examine the messages in the queue, we simply traverse
    this enumeration and obtain the messages one by one. In our example, we simply
    invoked the `getText()` method of each message in the queue.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Working with message topics
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Message topics are used when our JMS code uses the Publish/Subscribe (pub/sub)
    messaging domain. When using this messaging domain, the same message can be sent
    to all subscribers of a topic.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages to a message topic
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sending messages to a JMS topic is very similar to sending messages to a queue;
    simply inject the required resources and make some simple JMS API calls.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how to send messages to a message topic:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see, this example is nearly identical to the `MessageSender` class
    we saw when we discussed Point-To-Point messaging. As a matter of fact, the only
    lines of code that are different are those that are highlighted. The JMS API was
    designed this way so that application developers do not have to learn two different
    APIs for the PTP and pub/sub domains.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Since the code is nearly identical to the corresponding example in the *Working
    with message queues* section, we will only explain the differences between the
    two examples. In this example, instead of declaring an instance of a class implementing
    `javax.jms.Queue`, we declare an instance of a class implementing `javax.jms.Topic`.
    We will then pass this instance of `javax.jms.Topic` as the first parameter of
    the `send()` method of our `JMSProducer` object, along with the message we wish
    to send.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Receiving messages from a message topic
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as sending messages to a message topic is nearly identical to sending
    messages to a message queue, receiving messages from a message topic is nearly
    identical to receiving messages from a message queue, as can be seen in the following
    example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once again, the differences between this code and the corresponding code for
    PTP messaging are simple. Instead of declaring an instance of a class implementing
    `javax.jms.Queue`, we declare a class implementing `javax.jms.Topic`. We use the
    `@Resource` annotation to inject an instance of this class into our code using
    the JNDI name we used when creating it in the GlassFish web console. We then obtain
    an instance of `JMSContext` and `JMSConsumer` as we did before, and then receive
    the messages from the topic by invoking the `receiveBody()` method on `JMSConsumer`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Using the pub/sub messaging domain as illustrated in this section has the advantage
    that messages can be sent to several message consumers. This can be easily tested
    by concurrently executing two instances of the `MessageReceiver` class we developed
    in this section, and then executing the `MessageSender` class we developed in
    the previous section. We should see the console output for each instance, indicating
    that both instances received all messages.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Just like with message queues, messages can be retrieved asynchronously from
    a message topic. The procedure to do so is so similar to the message queue version
    that we will not show an example. To convert the asynchronous example shown earlier
    in this chapter to use a message topic, simply replace the `javax.jms.Queue` variable
    with an instance of `javax.jms.Topic` and inject the appropriate instance using
    `"jms/GlassFishBookTopic"` as the value of the `mappedName` attribute of the `@Resource`
    annotation decorating the instance of `javax.jms.Topic`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Creating durable subscribers
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The disadvantage of using the pub/sub messaging domain is that message consumers
    must be running when the messages are sent to the topic. If the message consumer
    is not running at the time, it will not receive the messages; whereas, in PTP,
    messages are kept in the queue until the message consumer runs. Fortunately, the
    JMS API provides a way to use the pub/sub messaging domain and keep messages in
    the topic until all subscribed message consumers run and receive the message.
    This can be accomplished by creating durable subscribers for a JMS topic.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: In order to be able to serve durable subscribers, we need to set the `ClientId`
    property of our JMS connection factory. Each durable subscriber must have a unique
    client ID; therefore, a unique connection factory must be declared for each potential
    durable subscriber.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够为持久订阅者提供服务，我们需要设置我们的JMS连接工厂的`ClientId`属性。每个持久订阅者都必须有一个唯一的客户端ID；因此，必须为每个潜在的持久订阅者声明一个唯一的连接工厂。
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**InvalidClientIdException?**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**InvalidClientIdException**？'
- en: Only one JMS client can connect to a topic for a specific client ID. If more
    than one JMS client attempts to obtain a JMS connection using the same connection
    factory, a `JMSException` stating that the Client ID is already in use will be
    thrown. The solution is to create a connection factory for each potential client
    that will be receiving messages from the durable topic.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个JMS客户端可以连接到特定客户端ID的主题。如果有多个JMS客户端尝试使用相同的连接工厂获取JMS连接，将抛出一个`JMSException`，指出客户端ID已被使用。解决方案是为每个将接收持久主题消息的潜在客户端创建一个连接工厂。
- en: 'Like we mentioned before, the easiest way to add a connection factory is through
    the GlassFish web console, as shown in the following steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，通过GlassFish网页控制台添加连接工厂的最简单方法是按照以下步骤进行：
- en: Expand the **Resources** node to the left-hand side of the web console.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开位于网页控制台左侧的**资源**节点。
- en: Expand the **JMS Resources** node.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**JMS资源**节点。
- en: Click on the **Connection Factories** node.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**连接工厂**节点。
- en: Click on the **New...** button in the main area of the page.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面主区域中的**新建...**按钮。
- en: 'Our next example will use the settings displayed in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的示例将使用以下截图显示的设置：
- en: '![Creating durable subscribers](img/6886EN_08_08.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![创建持久订阅者](img/6886EN_08_08.jpg)'
- en: 'Before clicking on the **OK** button, we need to scroll to the bottom of the
    page, click on the **Add Property** button, and enter a new property named `ClientId`.
    Our example will use `ExampleId` as the value for this property, as shown in the
    following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击**确定**按钮之前，我们需要滚动到页面底部，点击**添加属性**按钮，并输入一个名为`ClientId`的新属性。我们的示例将使用`ExampleId`作为此属性的值，如下截图所示：
- en: '![Creating durable subscribers](img/6886EN_08_09.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![创建持久订阅者](img/6886EN_08_09.jpg)'
- en: 'Now that we have set up GlassFish to be able to provide durable subscriptions,
    we are ready to write some code to take advantage of them:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了GlassFish以能够提供持久订阅，我们准备好编写一些代码来利用它们：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we can see, this code is not very different from the previous examples of
    code, the purpose of which was to retrieve messages. There are only two differences
    from previous examples: the instance of `ConnectionFactory` that we are injecting
    is the one we set up earlier in this section to handle durable subscriptions,
    and instead of calling the `createConsumer()` method on the JMS context object,
    we are calling `createDurableConsumer()`. The `createDurableConsumer()` method
    takes two arguments: a JMS topic object to retrieve messages from and a `String`
    designating a name for this subscription. This second parameter must be unique
    across all subscribers to that durable topic.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，此代码与之前用于检索消息的示例代码没有太大区别，其目的是检索消息。与之前的示例相比，只有两个不同之处：我们注入的`ConnectionFactory`实例是我们在本节中较早设置的，用于处理持久订阅，并且我们不是在JMS上下文对象上调用`createConsumer()`方法，而是调用`createDurableConsumer()`。`createDurableConsumer()`方法接受两个参数：一个用于检索消息的JMS主题对象和一个指定此订阅名称的`String`。此第二个参数必须在该持久主题的所有订阅者中是唯一的。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to set up JMS connection factories, JMS message
    queues, and JMS message topics in GlassFish using the GlassFish web console.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何使用GlassFish网页控制台在GlassFish中设置JMS连接工厂、JMS消息队列和JMS消息主题。
- en: We also covered how to send messages to a message queue via the `javax.jms.JMSProducer`
    interface.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了如何通过`javax.jms.JMSProducer`接口向消息队列发送消息。
- en: Additionally, we covered how to receive messages from a message queue via the
    `javax.jms.JMSConsumer` interface. We also covered how to asynchronously receive
    messages from a message queue by implementing the `javax.jms.MessageListener`
    interface.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还介绍了如何通过`javax.jms.JMSConsumer`接口从消息队列接收消息。我们还介绍了如何通过实现`javax.jms.MessageListener`接口异步地从消息队列接收消息。
- en: We also saw how to use these interfaces to send and receive messages to and
    from a JMS message topic.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何使用这些接口在JMS消息主题之间发送和接收消息。
- en: We also covered how to browse messages in a message queue without removing them
    from the queue via the `javax.jms.QueueBrowser` interface.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how to set up and interact with durable subscriptions to JMS
    topics.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover how to secure Java EE applications.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
