- en: Chapter 8. The Java Message Service
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. Java消息服务
- en: The **Java Message Service** (**JMS**) **API** provides a mechanism for Java
    EE applications to send messages to each other. Java EE 7 introduces JMS 2.0,
    a new version of JMS that greatly simplifies the development of applications involving
    messaging functionality.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java消息服务**（**JMS**）**API**为Java EE应用程序之间发送消息提供了一个机制。Java EE 7引入了JMS 2.0，这是JMS的一个新版本，它极大地简化了涉及消息功能的应用程序的开发。'
- en: JMS applications do not communicate directly; instead, message producers send
    messages to a destination, and message consumers receive that message from the
    destination.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JMS应用程序不直接通信；相反，消息生产者将消息发送到目的地，而消息消费者从目的地接收该消息。
- en: The message destination is a message queue when the **Point-to-Point** (**PTP**)
    messaging domain is used, and a message topic when the Publish/Subscribe (pub/sub)
    messaging domain is used.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用**点对点**（**PTP**）消息域时，消息目的地是一个消息队列，当使用发布/订阅（pub/sub）消息域时，消息目的地是一个消息主题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up GlassFish for JMS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置GlassFish以支持JMS
- en: Working with message queues
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消息队列
- en: Working with message topics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消息主题
- en: Setting up GlassFish for JMS
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置GlassFish以支持JMS
- en: Before we can start writing code to take advantage of the JMS API, we need to
    configure some GlassFish resources. Specifically, we need to set up a JMS Connection
    Factory, a message queue, and a message topic.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以开始编写代码以利用JMS API之前，我们需要配置一些GlassFish资源。具体来说，我们需要设置一个JMS连接工厂、一个消息队列和一个消息主题。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Java EE 7 requires all compliant application servers to provide a default JMS
    connection factory. GlassFish, which is a fully compliant Java EE 7 application
    server (and the Java EE 7 reference implementation), complies with this requirement;
    so strictly speaking, we don't really need to set up a connection factory, however,
    in many cases we may need to set one up. Therefore, in the following section we
    illustrate how set up can be done.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 7要求所有符合标准的应用服务器提供默认的JMS连接工厂。GlassFish是一个完全符合Java EE 7的应用服务器（也是Java EE
    7的参考实现），符合这一要求；因此，严格来说，我们实际上并不需要设置连接工厂，然而，在许多情况下，我们可能需要设置一个。因此，在下一节中，我们将说明如何进行设置。
- en: Setting up a JMS connection factory
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置JMS连接工厂
- en: 'The easiest way to set up a JMS connection factory is via GlassFish''s web
    console. Recall from [Chapter 1](ch01.html "Chapter 1. Getting Started with GlassFish"),
    *Getting Started with GlassFish*, that the web console can be accessed by starting
    our domain by entering the following command in the command line:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 设置JMS连接工厂最简单的方法是通过GlassFish的网页控制台。回想一下[第1章](ch01.html "第1章. 开始使用GlassFish")，“开始使用GlassFish”，网页控制台可以通过在命令行中输入以下命令来访问我们的域：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, go to `http://localhost:4848` and log in.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，转到`http://localhost:4848`并登录。
- en: '![Setting up a JMS connection factory](img/6886EN_08_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![设置JMS连接工厂](img/6886EN_08_01.jpg)'
- en: A connection factory can be added by expanding the **Resources** node in the
    tree to the left-hand side of the web console; to do this, expand the **JMS Resources**
    node, click on the **Connection Factories** node, and then click on the **New...**
    button in the main area of the web console.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过展开位于网页控制台左侧的**资源**节点来添加连接工厂；为此，展开**JMS资源**节点，点击**连接工厂**节点，然后在网页控制台的主要区域中点击**新建...**按钮。
- en: '![Setting up a JMS connection factory](img/6886EN_08_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![设置JMS连接工厂](img/6886EN_08_02.jpg)'
- en: For our purposes, we can maintain most of the defaults; the only thing we need
    to do is enter a pool name in the **JNDI Name** field and pick a resource type
    for our connection factory.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们可以保持大多数默认设置；我们唯一需要做的是在**JNDI名称**字段中输入一个池名称，并为我们的连接工厂选择一个资源类型。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is always a good idea to use a pool name starting with `"jms/"` when naming
    JMS resources. This way, JMS resources can be easily identified when browsing
    a JNDI tree.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名JMS资源时，始终使用以`"jms/"`开头的池名称是一个好主意。这样，在浏览JNDI树时可以轻松识别JMS资源。
- en: In the field labeled **JNDI Name**, enter `jms/GlassFishBookConnectionFactory`.
    Our code examples later in this chapter will use this JNDI name to obtain a reference
    to this connection factory.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记为**JNDI名称**的字段中输入`jms/GlassFishBookConnectionFactory`。本章后面的代码示例将使用此JNDI名称来获取对连接工厂的引用。
- en: 'The **Resource Type** dropdown has the following three options:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源类型**下拉菜单有以下三个选项：'
- en: '**javax.jms.TopicConnectionFactory**: This option is used to create a connection
    factory that creates JMS topics for JMS clients using the pub/sub messaging domain'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**javax.jms.TopicConnectionFactory**：此选项用于创建一个连接工厂，该工厂为使用发布/订阅消息域的JMS客户端创建JMS主题'
- en: '**javax.jms.QueueConnectionFactory**: This option is used to create a connection
    factory that creates JMS queues for JMS clients using the PTP messaging domain'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**javax.jms.QueueConnectionFactory**：此选项用于创建一个连接工厂，该工厂为使用PTP消息域的JMS客户端创建JMS队列'
- en: '**javax.jms.ConnectionFactory**: This option is used to create a connection
    factory that creates either JMS topics or JMS queues'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**javax.jms.ConnectionFactory**：此选项用于创建一个连接工厂，该工厂可以创建JMS主题或JMS队列'
- en: For our example, we will select **javax.jms.ConnectionFactory**; this way, we
    can use the same connection factory for all of our examples, those using the PTP
    messaging domain and the pub/sub messaging domain.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将选择**javax.jms.ConnectionFactory**；这样，我们可以为所有示例使用相同的连接工厂，包括使用PTP消息域和发布/订阅消息域的示例。
- en: After entering the pool name in the **JNDI Name** field for our connection factory,
    selecting a connection factory type, and optionally entering a description for
    our connection factory, we need to click on the **OK** button for the changes
    to take effect.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在**JNDI名称**字段中输入我们的连接工厂的池名称，选择连接工厂类型，并可选地输入我们的连接工厂的描述后，我们需要单击**确定**按钮以使更改生效。
- en: 'We should then see our newly created connection factory (**jms/GlassFishBookConnectionFactory**)
    listed in the main area of the GlassFish web console, as shown in the following
    screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该会看到新创建的连接工厂（**jms/GlassFishBookConnectionFactory**）在GlassFish Web控制台的主区域中列出，如下面的截图所示：
- en: '![Setting up a JMS connection factory](img/6886EN_08_03.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![设置JMS连接工厂](img/6886EN_08_03.jpg)'
- en: Setting up a JMS queue
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置JMS队列
- en: 'A JMS queue can be added by going through the following steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下步骤添加JMS队列：
- en: Expand the **Resources** node in the tree at the left-hand side of the web console.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web控制台左侧的树中展开**资源**节点。
- en: Enter a value in the **JNDI Name** field.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**JNDI名称**字段中输入一个值。
- en: Enter a value in the **Physical Destination Name** field.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**物理目标名称**字段中输入一个值。
- en: Select **javax.jms.Queue** in the **Resource Type** field.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**资源类型**字段中选择**javax.jms.Queue**。
- en: Click on the **OK** button.![Setting up a JMS queue](img/6886EN_08_04.jpg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**确定**按钮。![设置JMS队列](img/6886EN_08_04.jpg)
- en: In our example, the JNDI name of the message queue is `jms/GlassFishBookQueue`.
    The resource type for message queues must be `javax.jms.Queue`. Additionally,
    a value must be entered in the **Physical Destination Name** field. In our example,
    we use `GlassFishBookQueue` as the value for this field.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，消息队列的JNDI名称为`jms/GlassFishBookQueue`。消息队列的资源类型必须是`javax.jms.Queue`。此外，必须在**物理目标名称**字段中输入一个值。在我们的示例中，我们将`GlassFishBookQueue`用作此字段的值。
- en: 'After clicking on the **OK** button, we should see the newly created queue,
    as shown in the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 单击**确定**按钮后，我们应该会看到新创建的队列，如下面的截图所示：
- en: '![Setting up a JMS queue](img/6886EN_08_05.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![设置JMS队列](img/6886EN_08_05.jpg)'
- en: Setting up a JMS topic
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置JMS主题
- en: 'Setting up a JMS topic in GlassFish is very similar to setting up a message
    queue. Perform the following steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在GlassFish中设置JMS主题与设置消息队列非常相似。执行以下步骤：
- en: Expand the JMS **Resources** node.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开JMS **资源**节点。
- en: Click on the **Destination** node.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**目的地**节点。
- en: Click on the **New...** button in the main area of the web console.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web控制台的主区域中单击**新建...**按钮。
- en: Enter a name for our topic in the **JNDI Name** field.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**JNDI名称**字段中为我们的主题输入一个名称。
- en: Enter a physical destination name for our topic in the **Physical Destination
    Name** field.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**物理目标名称**字段中为我们的主题输入一个物理目标名称。
- en: Select **javax.jms.Topic** from the **Resource Type** dropdown.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**资源类型**下拉菜单中选择**javax.jms.Topic**。
- en: 'Click on the **OK** button, shown in the following screenshot:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击以下截图所示的**确定**按钮：
- en: '![Setting up a JMS topic](img/6886EN_08_06.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![设置JMS主题](img/6886EN_08_06.jpg)'
- en: Our examples will use `jms/GlassFishBookTopic` in the **JNDI Name** field. Since
    this is a message topic, **Resource Type** must be set to `javax.jms.Topic`. The
    **Description** field is optional. The **Physical Destination Name** property
    is required; for our example, we will use `GlassFishBookTopic` as the value for
    this property.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将在**JNDI名称**字段中使用`jms/GlassFishBookTopic`。由于这是一个消息主题，**资源类型**必须设置为`javax.jms.Topic`。**描述**字段是可选的。**物理目标名称**属性是必需的；在我们的示例中，我们将使用`GlassFishBookTopic`作为此属性的值。
- en: 'After clicking on the **OK** button, we can see our newly created message topic
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**按钮后，我们可以看到我们新创建的消息主题如下：
- en: '![Setting up a JMS topic](img/6886EN_08_07.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![设置JMS主题](img/6886EN_08_07.jpg)'
- en: Now that we have set up a connection factory, a message queue, and a message
    topic, we are ready to start writing code using the JMS API.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个连接工厂、一个消息队列和一个消息主题，我们就可以开始使用JMS API编写代码了。
- en: Working with message queues
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与消息队列一起工作
- en: Like we mentioned earlier, message queues are used when our JMS code uses the
    **Point-To-Point** (**PTP**) messaging domain. For the PTP messaging domain, there
    is usually one message producer and one message consumer. The message producer
    and the message consumer don't need to be running concurrently in order to communicate.
    The messages placed in the message queue by the message producer will stay there
    until the message consumer executes and requests for the messages from the queue.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，当我们的JMS代码使用**点对点**（**PTP**）消息域时，会使用消息队列。对于PTP消息域，通常有一个消息生产者和一个消息消费者。消息生产者和消息消费者不需要同时运行以进行通信。消息生产者放入消息队列中的消息将保留在那里，直到消息消费者执行并从队列中请求消息。
- en: Sending messages to a message queue
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向消息队列发送消息
- en: Sending messages to a JMS queue consists of injecting a few resources to our
    code and making a few simple JMS API calls.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 向JMS队列发送消息包括将一些资源注入到我们的代码中，并执行一些简单的JMS API调用。
- en: 'The following example illustrates how to add messages to a message queue:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何向消息队列添加消息：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Before delving into the details of our code, alert readers may have noticed
    that the `MessageSender` class is a standalone Java application, since it contains
    a main method. Since this class is standalone, it is executed outside of the application
    server; yet, we can see that some resources are injected into it, specifically
    the connection factory object and the queue. The reason we can inject resources
    into this code even though it runs outside the application server is because GlassFish
    includes a utility called `appclient`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究代码的细节之前，细心的读者可能已经注意到`MessageSender`类是一个独立的Java应用程序，因为它包含一个主方法。由于这个类是独立的，它是在应用程序服务器之外执行的；然而，我们可以看到一些资源被注入到其中，特别是连接工厂对象和队列。我们可以将资源注入到这个代码中，即使它是在应用程序服务器之外运行的，这是因为GlassFish包含一个名为`appclient`的实用程序。
- en: 'This utility allows us to "wrap" an executable JAR file and allow it to have
    access to the application server resources. To execute our code, assuming it is
    packaged in an executable JAR file called `jmsptpproducer.jar`, we would type
    the following in the command line:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此实用程序允许我们“包装”一个可执行的JAR文件，并允许它访问应用程序服务器资源。假设我们的代码打包在一个名为`jmsptpproducer.jar`的可执行JAR文件中，我们将在命令行中输入以下内容：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We would then see, after some GlassFish log entries, the following output on
    the console:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些GlassFish日志条目之后，我们将在控制台上看到以下输出：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `appclient` executable script can be found under `[GlassFish installation
    directory]/glassfish/bin`; our example assumes that this directory is in the `PATH`
    variable and if it isn't, the complete path to the `appclient` script must be
    typed in the command line.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`appclient`可执行脚本可以在`[GlassFish安装目录]/glassfish/bin`下找到；我们的示例假设此目录在`PATH`变量中，如果不是，必须在命令行中输入`appclient`脚本的完整路径。'
- en: With that out of the way, we can now explain the code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决这个问题之后，我们现在可以解释代码。
- en: The `produceMessages()` method performs all the necessary steps to send messages
    to a message queue.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`produceMessages()`方法执行所有必要的步骤以将消息发送到消息队列。'
- en: The first thing this method does is create an instance of `javax.jms.JMSContext`
    by invoking the `createContext()` method on the injected instance of `javax.jms.ConnectionFactory`.
    Notice that the `mappedName` attribute of the `@Resource` annotation decorating
    the connection factory object matches the JNDI name of the connection factory
    we set up in the GlassFish web console. Behind the scenes, a JNDI lookup is made
    using this name to obtain the connection factory object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法首先执行的操作是通过在注入的`javax.jms.ConnectionFactory`实例上调用`createContext()`方法来创建一个`javax.jms.JMSContext`实例。请注意，装饰连接工厂对象的`@Resource`注解的`mappedName`属性与我们在GlassFish
    Web控制台中设置的连接工厂的JNDI名称相匹配。在幕后，使用此名称进行JNDI查找以获取连接工厂对象。
- en: Next, we create an instance of `javax.jms.JMSProducer` by invoking the `createProducer()`
    method on the `JMSContext` instance we just created.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过在刚刚创建的`JMSContext`实例上调用`createProducer()`方法来创建一个`javax.jms.JMSProducer`实例。
- en: After obtaining an instance of `JMSProducer`, the code sends a series of text
    messages by invoking its `send()` method; this method takes the message destination
    as its first parameter, and a string containing the message text as its second
    parameter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`JMSProducer`实例后，代码通过调用其`send()`方法发送一系列文本消息；该方法将消息目的地作为其第一个参数，将包含消息文本的字符串作为其第二个参数。
- en: There are several overloaded versions of the `send()` method in `JMSProducer`;
    the one we used in our example is a convenience method that creates an instance
    of `javax.jms.TextMessage` and sets its text to the string we provide as the second
    parameter in the method invocation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`JMSProducer`中，`send()`方法有几个重载版本；我们示例中使用的是一种便利方法，该方法创建一个`javax.jms.TextMessage`实例，并将其文本设置为方法调用中提供的第二个参数的字符串。
- en: Although our example sends only text messages to the queue, we are not limited
    to sending only this type of message. The JMS API provides several types of messages
    that can be sent and received by JMS applications. All message types are defined
    as interfaces in the `javax.jms` package.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的示例只向队列发送文本消息，但我们并不局限于只发送此类消息。JMS API提供了多种类型的消息，这些消息可以被JMS应用程序发送和接收。所有消息类型都在`javax.jms`包中定义为接口。
- en: 'The following table lists all of the available message types:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了所有可用的消息类型：
- en: '| Message Type | Description |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 消息类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `BytesMessage` | Allows sending an array of bytes as a message. `JMSProducer`
    has a convenience `send()` method that takes an array of bytes as one of its parameters;
    this method creates an instance of `javax.jms.BytesMessage` on the fly as the
    message is being sent. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `BytesMessage` | 允许发送字节数组作为消息。`JMSProducer`有一个便利的`send()`方法，它将字节数组作为其参数之一；在发送消息时，该方法会动态创建一个`javax.jms.BytesMessage`实例。|'
- en: '| `MapMessage` | Allows sending an implementation of `java.util.Map` as a message.
    `JMSProducer` has a convenience `send()` method that takes a `Map` as one of its
    parameters; this method creates an instance of `javax.jms.MapMessage` on the fly
    as the message is being sent. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `MapMessage` | 允许发送`java.util.Map`的实现作为消息。`JMSProducer`有一个便利的`send()`方法，它将`Map`作为其参数之一；在发送消息时，该方法会动态创建一个`javax.jms.MapMessage`实例。|'
- en: '| `ObjectMessage` | Allows sending any Java object implementing `java.io.Serializable`
    as a message. `JMSProducer` has a convenience `send()` method that takes an instance
    of a class implementing `java.io.Serializable` as its second parameter; this method
    creates an instance of `javax.jms.ObjectMessage` on the fly as the message is
    being sent. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `ObjectMessage` | 允许发送实现`java.io.Serializable`接口的任何Java对象作为消息。`JMSProducer`有一个便利的`send()`方法，它将实现`java.io.Serializable`接口的类的实例作为其第二个参数；在发送消息时，该方法会动态创建一个`javax.jms.ObjectMessage`实例。|'
- en: '| `StreamMessage` | Allows sending an array of bytes as a message. Differs
    from `BytesMessage` in that it stores the type of each primitive type added to
    the stream. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `StreamMessage` | 允许发送字节数组作为消息。与`BytesMessage`不同，它存储添加到流中的每个原始类型的类型。|'
- en: '| `TextMessage` | Allows sending `java.lang.String` as a message. As seen in
    our example, `JMSProducer` has a convenience `send()` method that takes `String`
    type as its second parameter; this method creates an instance of `javax.jms.TextMessage`
    on the fly as the message is being sent. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `TextMessage` | 允许发送`java.lang.String`作为消息。正如我们的示例所示，`JMSProducer`有一个便利的`send()`方法，它将`String`类型作为其第二个参数；在发送消息时，该方法会动态创建一个`javax.jms.TextMessage`实例。|'
- en: For more information on all JMS message types, consult their JavaDoc documentation
    at [http://docs.oracle.com/javaee/7/api/](http://docs.oracle.com/javaee/7/api/).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所有JMS消息类型的更多信息，请参阅[http://docs.oracle.com/javaee/7/api/](http://docs.oracle.com/javaee/7/api/)的JavaDoc文档。
- en: Retrieving messages from a message queue
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从消息队列中检索消息
- en: 'Of course, there is no point in sending messages from a queue if nothing is
    going to receive them. The following example illustrates how to retrieve messages
    from a JMS message queue:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果没有任何接收者，从队列中发送消息是没有意义的。以下示例说明了如何从JMS消息队列中检索消息：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Just like in the previous example, an instance of `javax.jms.ConnectionFactory`
    and an instance of `javax.jms.Queue` are injected using the `@Resource` annotation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的示例一样，使用`@Resource`注解注入了`javax.jms.ConnectionFactory`和`javax.jms.Queue`的实例。
- en: In our code, we get an instance of `javax.jms.JMSContext` by invoking the `createContext()`
    method of `ConnectionFactory`, just like in the previous example.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们通过调用`ConnectionFactory`的`createContext()`方法来获取`javax.jms.JMSContext`实例，就像在之前的示例中一样。
- en: In this example, we obtain an instance of `javax.jms.JMSConsumer` by calling
    the `createConsumer()` method on our `JMSContext` instance.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们通过在 `JMSContext` 实例上调用 `createConsumer()` 方法来获取 `javax.jms.JMSConsumer`
    的实例。
- en: Messages are received by invoking the `receiveBody()` method on our instance
    of `JMSConsumer`. This method takes the type of the message we are expecting as
    its sole parameter (`String.class` in our example). This method returns an object
    of the type specified in its parameter (an instance of `java.lang.String` in our
    example).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `JMSConsumer` 的实例上调用 `receiveBody()` 方法来接收消息。此方法接受我们期望的消息类型作为其唯一参数（在我们的示例中是
    `String.class`）。此方法返回其参数指定的类型的对象（在我们的示例中是一个 `java.lang.String` 实例）。
- en: In this particular example, we placed this method call in a `while` loop since
    we are expecting a message that will let us know that no more messages are coming.
    Specifically, we are looking for a message containing the text `"Good bye!"`.
    Once we receive that message, we break out of the loop and continue with further
    processing. In this particular case, there is no more processing left to do, therefore,
    execution ends after we break out of the loop.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的示例中，我们将这个方法调用放在了一个 `while` 循环中，因为我们期望一个消息会告诉我们没有更多的消息到来。具体来说，我们正在寻找包含文本
    `"Good bye!"` 的消息。一旦我们收到这个消息，我们就退出循环并继续进行进一步的处理。在这个特定的案例中，没有更多的处理要做，因此，在退出循环后执行结束。
- en: 'Just like in the previous example, using the `appclient` utility allows us
    to inject resources into the code and prevents us from having to add any libraries
    to the CLASSPATH. After executing the code through the `appclient` utility, we
    should see the following output in the command line:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在先前的示例中一样，使用 `appclient` 工具允许我们将资源注入到代码中，并防止我们不得不将任何库添加到 CLASSPATH 中。通过 `appclient`
    工具执行代码后，我们应该在命令行中看到以下输出：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The previous example placed some messages on the queue. This example retrieves
    the messages. If the previous example has not been executed yet, then there are
    no messages to retrieve.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的示例在队列上放置了一些消息。此示例检索这些消息。如果先前的示例尚未执行，则没有要检索的消息。
- en: Asynchronously receiving messages from a message queue
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步从消息队列接收消息
- en: 'The `JMSConsumer.receiveBody()` method has a disadvantage: it blocks execution
    until a message is received from the queue. We worked around this limitation in
    our previous example by breaking out of the loop once we received a specific message
    (`"Good bye!"`).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`JMSConsumer.receiveBody()` 方法有一个缺点：它会在接收到队列中的消息之前阻塞执行。在先前的示例中，我们通过在接收到特定消息（`"Good
    bye!"`）后退出循环来绕过这个限制。'
- en: We can prevent our JMS consumer code from blocking execution by receiving messages
    asynchronously via an implementation of the `javax.jms.MessageListener` interface.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实现 `javax.jms.MessageListener` 接口来异步接收消息，从而防止我们的 JMS 消费者代码阻塞执行。
- en: 'The `javax.jms.MessageListener` interface contains a single method called `onMessage`,
    it takes an instance of a class implementing the `javax.jms.Message` interface
    as its sole parameter. The following example illustrates a typical implementation
    of this interface:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`javax.jms.MessageListener` 接口包含一个名为 `onMessage` 的单方法，它接受一个实现 `javax.jms.Message`
    接口的类的实例作为其唯一参数。以下示例说明了此接口的典型实现：'
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, the `onMessage()` method simply outputs the message text to the
    console. Recall that behind the scenes, the JMS API creates instances of `javax.jms.TextMessage`
    when we invoke `JMSProducer.send()` with a `String` as its second parameter; our
    `MessageListener` implementation casts the `Message` instance it receives as a
    parameter to `TextMessage`, and then gets the `String message` sent by the `JMSProducer`
    variable, invoking its `getText()` method.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`onMessage()` 方法只是将消息文本输出到控制台。回想一下，在幕后，当我们使用 `String` 作为第二个参数调用 `JMSProducer.send()`
    时，JMS API 会创建 `javax.jms.TextMessage` 的实例；我们的 `MessageListener` 实现将接收到的 `Message`
    实例作为参数转换为 `TextMessage`，然后获取由 `JMSProducer` 变量发送的 `String message`，调用其 `getText()`
    方法。
- en: 'Our main code can now delegate message retrieval to our custom `MessageListener`
    implementation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主代码现在可以将消息检索委托给我们的自定义 `MessageListener` 实现：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The only relevant difference between this example and the one in the previous
    section is that in this case, we are calling the `setMessageListener()` method
    on the instance of `javax.jms.JMSConsumer` obtained from the JMS context. We pass
    an instance of our custom implementation of `javax.jms.MessageListener` to this
    method; its `onMessage()` method is automatically called whenever there is a message
    waiting in the queue. Using this approach, the main code does not block execution
    while it is waiting to receive messages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节中的示例相比，唯一的区别在于本例中，我们在从JMS上下文获取的`javax.jms.JMSConsumer`实例上调用`setMessageListener()`方法。我们将我们的自定义`javax.jms.MessageListener`实现实例传递给此方法；每当队列中有等待的消息时，其`onMessage()`方法会自动被调用。使用这种方法，主代码在等待接收消息时不会阻塞执行。
- en: 'Executing the preceding example (using, of course, GlassFish''s `appclient`
    utility), results in the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的示例（当然，使用GlassFish的`appclient`实用程序），将产生以下输出：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice how the messages were received and processed while the main thread was
    executing. We can tell that this is the case because the output of our `MessageListener`
    class' `onMessage()` method can be seen between calls to `System.out.println()`
    in the primary class.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在主线程执行过程中，消息是如何被接收和处理的。我们可以通过观察`MessageListener`类`onMessage()`方法的输出位于主类中`System.out.println()`调用之间来判断这一点。
- en: Browsing message queues
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览消息队列
- en: 'JMS provides a way to browse message queues without actually removing the messages
    from the queue. The following example illustrates how to do this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: JMS提供了一种在不实际从队列中删除消息的情况下浏览消息队列的方法。以下示例说明了如何进行此操作：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see, the procedure to browse messages in a message queue is straightforward.
    We obtain a JMS connection factory, a JMS queue, and a JMS context in the usual
    way, and then invoke the `createBrowser()` method on the JMS context object. This
    method returns an implementation of the `javax.jms.QueueBrowser` interface, containing
    a `getEnumeration()` method that we can invoke to obtain an `Enumeration` containing
    all messages in the queue. To examine the messages in the queue, we simply traverse
    this enumeration and obtain the messages one by one. In our example, we simply
    invoked the `getText()` method of each message in the queue.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，浏览消息队列的流程非常直接。我们以通常的方式获取JMS连接工厂、JMS队列和JMS上下文，然后在JMS上下文对象上调用`createBrowser()`方法。此方法返回一个实现`javax.jms.QueueBrowser`接口的实例，其中包含一个`getEnumeration()`方法，我们可以调用它来获取包含队列中所有消息的`Enumeration`。要检查队列中的消息，我们只需遍历这个枚举并逐个获取消息。在我们的示例中，我们简单地调用了队列中每个消息的`getText()`方法。
- en: Working with message topics
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与消息主题一起工作
- en: Message topics are used when our JMS code uses the Publish/Subscribe (pub/sub)
    messaging domain. When using this messaging domain, the same message can be sent
    to all subscribers of a topic.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的JMS代码使用发布/订阅（pub/sub）消息域时，会使用消息主题。当使用此消息域时，相同的消息可以发送到主题的所有订阅者。
- en: Sending messages to a message topic
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向消息主题发送消息
- en: Sending messages to a JMS topic is very similar to sending messages to a queue;
    simply inject the required resources and make some simple JMS API calls.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 向JMS主题发送消息与向队列发送消息非常相似；只需注入所需的资源并执行一些简单的JMS API调用即可。
- en: 'The following example illustrates how to send messages to a message topic:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何向消息主题发送消息：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see, this example is nearly identical to the `MessageSender` class
    we saw when we discussed Point-To-Point messaging. As a matter of fact, the only
    lines of code that are different are those that are highlighted. The JMS API was
    designed this way so that application developers do not have to learn two different
    APIs for the PTP and pub/sub domains.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这个示例几乎与我们在讨论点对点消息时看到的`MessageSender`类相同。事实上，唯一不同的代码行是那些被突出显示的。JMS API就是这样设计的，以便应用程序开发者不需要学习两个不同的API来处理PTP和pub/sub域。
- en: Since the code is nearly identical to the corresponding example in the *Working
    with message queues* section, we will only explain the differences between the
    two examples. In this example, instead of declaring an instance of a class implementing
    `javax.jms.Queue`, we declare an instance of a class implementing `javax.jms.Topic`.
    We will then pass this instance of `javax.jms.Topic` as the first parameter of
    the `send()` method of our `JMSProducer` object, along with the message we wish
    to send.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码几乎与*使用消息队列*部分中的相应示例相同，我们只解释两个示例之间的差异。在这个例子中，我们不是声明一个实现`javax.jms.Queue`的类的实例，而是声明一个实现`javax.jms.Topic`的类的实例。然后我们将这个`javax.jms.Topic`的实例作为`JMSProducer`对象的`send()`方法的第一参数传递，以及我们希望发送的消息。
- en: Receiving messages from a message topic
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从消息主题接收消息
- en: 'Just as sending messages to a message topic is nearly identical to sending
    messages to a message queue, receiving messages from a message topic is nearly
    identical to receiving messages from a message queue, as can be seen in the following
    example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 就像向消息主题发送消息几乎与向消息队列发送消息相同一样，从消息主题接收消息几乎与从消息队列接收消息相同，如下例所示：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once again, the differences between this code and the corresponding code for
    PTP messaging are simple. Instead of declaring an instance of a class implementing
    `javax.jms.Queue`, we declare a class implementing `javax.jms.Topic`. We use the
    `@Resource` annotation to inject an instance of this class into our code using
    the JNDI name we used when creating it in the GlassFish web console. We then obtain
    an instance of `JMSContext` and `JMSConsumer` as we did before, and then receive
    the messages from the topic by invoking the `receiveBody()` method on `JMSConsumer`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，此代码与PTP消息的相应代码之间的差异很简单。我们不是声明一个实现`javax.jms.Queue`的类的实例，而是声明一个实现`javax.jms.Topic`的类。我们使用`@Resource`注解，通过在GlassFish
    web控制台创建它时使用的JNDI名称，将此类的实例注入到我们的代码中。然后我们像以前一样获取`JMSContext`和`JMSConsumer`的实例，然后通过在`JMSConsumer`上调用`receiveBody()`方法从主题接收消息。
- en: Using the pub/sub messaging domain as illustrated in this section has the advantage
    that messages can be sent to several message consumers. This can be easily tested
    by concurrently executing two instances of the `MessageReceiver` class we developed
    in this section, and then executing the `MessageSender` class we developed in
    the previous section. We should see the console output for each instance, indicating
    that both instances received all messages.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节所示，使用发布/订阅消息域的优点是消息可以发送到多个消息消费者。这可以通过同时执行本节开发的`MessageReceiver`类的两个实例来轻松测试，然后执行上一节开发的`MessageSender`类。我们应该看到每个实例的控制台输出，表明两个实例都接收到了所有消息。
- en: Just like with message queues, messages can be retrieved asynchronously from
    a message topic. The procedure to do so is so similar to the message queue version
    that we will not show an example. To convert the asynchronous example shown earlier
    in this chapter to use a message topic, simply replace the `javax.jms.Queue` variable
    with an instance of `javax.jms.Topic` and inject the appropriate instance using
    `"jms/GlassFishBookTopic"` as the value of the `mappedName` attribute of the `@Resource`
    annotation decorating the instance of `javax.jms.Topic`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 就像从消息队列中检索消息一样，可以从消息主题异步检索消息。执行此操作的步骤与消息队列版本非常相似，因此我们将不展示示例。要将本章前面展示的异步示例转换为使用消息主题，只需将`javax.jms.Queue`变量替换为`javax.jms.Topic`的一个实例，并使用`"jms/GlassFishBookTopic"`作为装饰`javax.jms.Topic`实例的`@Resource`注解的`mappedName`属性的值来注入适当的实例。
- en: Creating durable subscribers
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建持久订阅者
- en: The disadvantage of using the pub/sub messaging domain is that message consumers
    must be running when the messages are sent to the topic. If the message consumer
    is not running at the time, it will not receive the messages; whereas, in PTP,
    messages are kept in the queue until the message consumer runs. Fortunately, the
    JMS API provides a way to use the pub/sub messaging domain and keep messages in
    the topic until all subscribed message consumers run and receive the message.
    This can be accomplished by creating durable subscribers for a JMS topic.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用发布/订阅消息域的缺点是，当消息被发送到主题时，消息消费者必须正在运行。如果消息消费者当时没有运行，它将不会收到消息；而在PTP中，消息将保存在队列中，直到消息消费者运行。幸运的是，JMS
    API提供了一种使用发布/订阅消息域并保持消息在主题中直到所有已订阅的消息消费者运行并接收消息的方法。这可以通过为JMS主题创建持久订阅者来实现。
- en: In order to be able to serve durable subscribers, we need to set the `ClientId`
    property of our JMS connection factory. Each durable subscriber must have a unique
    client ID; therefore, a unique connection factory must be declared for each potential
    durable subscriber.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够为持久订阅者提供服务，我们需要设置我们的JMS连接工厂的`ClientId`属性。每个持久订阅者都必须有一个唯一的客户端ID；因此，必须为每个潜在的持久订阅者声明一个唯一的连接工厂。
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**InvalidClientIdException?**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**InvalidClientIdException**？'
- en: Only one JMS client can connect to a topic for a specific client ID. If more
    than one JMS client attempts to obtain a JMS connection using the same connection
    factory, a `JMSException` stating that the Client ID is already in use will be
    thrown. The solution is to create a connection factory for each potential client
    that will be receiving messages from the durable topic.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个JMS客户端可以连接到特定客户端ID的主题。如果有多个JMS客户端尝试使用相同的连接工厂获取JMS连接，将抛出一个`JMSException`，指出客户端ID已被使用。解决方案是为每个将接收持久主题消息的潜在客户端创建一个连接工厂。
- en: 'Like we mentioned before, the easiest way to add a connection factory is through
    the GlassFish web console, as shown in the following steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，通过GlassFish网页控制台添加连接工厂的最简单方法是按照以下步骤进行：
- en: Expand the **Resources** node to the left-hand side of the web console.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开位于网页控制台左侧的**资源**节点。
- en: Expand the **JMS Resources** node.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**JMS资源**节点。
- en: Click on the **Connection Factories** node.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**连接工厂**节点。
- en: Click on the **New...** button in the main area of the page.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面主区域中的**新建...**按钮。
- en: 'Our next example will use the settings displayed in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的示例将使用以下截图显示的设置：
- en: '![Creating durable subscribers](img/6886EN_08_08.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![创建持久订阅者](img/6886EN_08_08.jpg)'
- en: 'Before clicking on the **OK** button, we need to scroll to the bottom of the
    page, click on the **Add Property** button, and enter a new property named `ClientId`.
    Our example will use `ExampleId` as the value for this property, as shown in the
    following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击**确定**按钮之前，我们需要滚动到页面底部，点击**添加属性**按钮，并输入一个名为`ClientId`的新属性。我们的示例将使用`ExampleId`作为此属性的值，如下截图所示：
- en: '![Creating durable subscribers](img/6886EN_08_09.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![创建持久订阅者](img/6886EN_08_09.jpg)'
- en: 'Now that we have set up GlassFish to be able to provide durable subscriptions,
    we are ready to write some code to take advantage of them:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了GlassFish以能够提供持久订阅，我们准备好编写一些代码来利用它们：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we can see, this code is not very different from the previous examples of
    code, the purpose of which was to retrieve messages. There are only two differences
    from previous examples: the instance of `ConnectionFactory` that we are injecting
    is the one we set up earlier in this section to handle durable subscriptions,
    and instead of calling the `createConsumer()` method on the JMS context object,
    we are calling `createDurableConsumer()`. The `createDurableConsumer()` method
    takes two arguments: a JMS topic object to retrieve messages from and a `String`
    designating a name for this subscription. This second parameter must be unique
    across all subscribers to that durable topic.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，此代码与之前用于检索消息的示例代码没有太大区别，其目的是检索消息。与之前的示例相比，只有两个不同之处：我们注入的`ConnectionFactory`实例是我们在本节中较早设置的，用于处理持久订阅，并且我们不是在JMS上下文对象上调用`createConsumer()`方法，而是调用`createDurableConsumer()`。`createDurableConsumer()`方法接受两个参数：一个用于检索消息的JMS主题对象和一个指定此订阅名称的`String`。此第二个参数必须在该持久主题的所有订阅者中是唯一的。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to set up JMS connection factories, JMS message
    queues, and JMS message topics in GlassFish using the GlassFish web console.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何使用GlassFish网页控制台在GlassFish中设置JMS连接工厂、JMS消息队列和JMS消息主题。
- en: We also covered how to send messages to a message queue via the `javax.jms.JMSProducer`
    interface.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了如何通过`javax.jms.JMSProducer`接口向消息队列发送消息。
- en: Additionally, we covered how to receive messages from a message queue via the
    `javax.jms.JMSConsumer` interface. We also covered how to asynchronously receive
    messages from a message queue by implementing the `javax.jms.MessageListener`
    interface.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还介绍了如何通过`javax.jms.JMSConsumer`接口从消息队列接收消息。我们还介绍了如何通过实现`javax.jms.MessageListener`接口异步地从消息队列接收消息。
- en: We also saw how to use these interfaces to send and receive messages to and
    from a JMS message topic.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何使用这些接口在JMS消息主题之间发送和接收消息。
- en: We also covered how to browse messages in a message queue without removing them
    from the queue via the `javax.jms.QueueBrowser` interface.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了如何通过`javax.jms.QueueBrowser`接口在消息队列中浏览消息，而无需从队列中移除它们。
- en: Finally, we saw how to set up and interact with durable subscriptions to JMS
    topics.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何设置和与JMS主题的持久订阅进行交互。
- en: In the next chapter, we will cover how to secure Java EE applications.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何确保Java EE应用程序的安全性。
