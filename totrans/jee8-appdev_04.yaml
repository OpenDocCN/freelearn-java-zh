- en: Enterprise JavaBeans
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业JavaBeans
- en: 'Enterprise JavaBeans are server-side components that encapsulate the business
    logic of an application. **Enterprise JavaBeans** (**EJB**) simplify application
    development by automatically taking care of transaction management and security.
    There are two types of Enterprise JavaBean: session beans, which perform business
    logic, and message-driven beans, which act as a message listener.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 企业JavaBeans是封装应用程序业务逻辑的服务端组件。**企业JavaBeans**（**EJB**）通过自动处理事务管理和安全性来简化应用程序开发。企业JavaBean有两种类型：会话Bean，执行业务逻辑，和消息驱动Bean，充当消息监听器。
- en: Readers familiar with previous versions of J2EE will notice that entity beans
    were not mentioned in the preceding paragraph. In Java EE 5, entity beans were
    deprecated in favor of the **Java Persistence API** (**JPA**). Entity beans are
    still supported for backwards compatibility; however, the preferred way of doing
    **Object Relational Mapping** (**ORM**) is through the JPA.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉J2EE先前版本的读者会注意到，在上一段中并未提及实体Bean。在Java EE 5中，为了支持Java持久化API（**JPA**），实体Bean已被弃用。尽管如此，为了向后兼容，实体Bean仍然得到支持；然而，进行对象关系映射（**ORM**）的首选方式是通过JPA。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Session beans
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话Bean
- en: A simple session bean
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的会话Bean
- en: A more realistic example
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个更实际的例子
- en: Using a session bean to implement the DAO design pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用会话Bean实现DAO设计模式
- en: Singleton session beans
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例会话Bean
- en: Message-driven beans
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息驱动Bean
- en: Transactions in enterprise JavaBeans
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业JavaBeans中的事务
- en: Container-managed transactions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器管理的事务
- en: Bean-managed transactions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bean管理的事务
- en: Enterprise JavaBeans life cycles
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业JavaBeans生命周期
- en: Stateful session bean life cycle
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有状态会话Bean生命周期
- en: Stateless session bean life cycle
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态会话Bean生命周期
- en: Message-driven bean life cycle
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息驱动Bean生命周期
- en: EJB timer service
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EJB定时器服务
- en: EJB Security
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EJB安全性
- en: Session beans
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话Bean
- en: 'Like we previously mentioned, session beans typically encapsulate business
    logic. In Java EE, only one or two artifacts need to be created in order to create
    a session bean: the bean itself, and an optional business interface. These artifacts
    need to be decorated with the proper annotations to let the EJB container know
    they are session beans.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，会话Bean通常封装业务逻辑。在Java EE中，创建会话Bean只需要创建一个或两个工件：Bean本身和可选的业务接口。这些工件需要添加适当的注解，以便让EJB容器知道它们是会话Bean。
- en: J2EE required application developers to create several artifacts in order to
    create a session bean. These artifacts include the bean itself, a local or remote
    interface (or both), a local home or a remote home interface (or both), and an
    XML deployment descriptor. As we shall see in this chapter, EJB development was
    greatly simplified in Java EE.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: J2EE要求应用程序开发者创建多个工件以创建会话Bean。这些工件包括Bean本身、本地或远程接口（或两者都有）、本地或远程Home接口（或两者都有），以及一个XML部署描述符。正如我们将在本章中看到的，Java
    EE极大地简化了EJB开发。
- en: A simple session bean
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的会话Bean
- en: 'The following example illustrates a very simple session bean.:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '以下示例演示了一个非常简单的会话Bean。:'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `@Stateless` annotation lets the EJB container know that this class is
    a stateless session bean. There are three types of session bean: stateless, stateful,
    and singleton. Before we explain the difference between these types of session
    bean, we need to clarify how an instance of an EJB is provided to an EJB client
    application.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Stateless`注解让EJB容器知道这个类是一个无状态会话Bean。有三种类型的会话Bean：无状态、有状态和单例。在我们解释这些类型会话Bean之间的区别之前，我们需要明确EJB实例是如何提供给EJB客户端应用程序的。'
- en: When a stateless session bean is deployed, the EJB container creates a series
    of instances of each session bean. This is what is typically referred to as the
    EJB pool. When an EJB client application obtains an instance of an EJB, one of
    the instances in the pool is provided to this client application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当无状态会话Bean被部署时，EJB容器会为每个会话Bean创建一系列实例。这通常被称为EJB池。当EJB客户端应用程序获取一个EJB实例时，池中的一个实例会被提供给这个客户端应用程序。
- en: The difference between stateful and stateless session beans is that stateful
    session beans maintain a conversational state with the client, whereas stateless
    session beans do not. In simple terms, this means that, when an EJB client application
    obtains an instance of a stateful session bean, we are guaranteed that the value
    of any instance variables in the bean will be consistent across method calls.
    Therefore, it is safe to modify any instance variables on a stateful session bean,
    since they will retain their value for the next method call. The EJB container
    saves the conversational state by passivating stateful session beans and retrieves
    the state when the bean is activated. Conversational state is the reason why the
    life cycle of stateful session beans is a bit more complex than the life cycle
    of stateless session beans or message-driven beans (the EJB life cycle is discussed
    later in this chapter).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态会话bean和无状态会话bean之间的区别在于，有状态会话bean与客户端保持会话状态，而无状态会话bean则不保持。简单来说，这意味着，当一个EJB客户端应用程序获取一个有状态会话bean的实例时，我们保证bean中任何实例变量的值在方法调用之间是一致的。因此，在修改有状态会话bean上的任何实例变量时是安全的，因为它们将在下一次方法调用中保留其值。EJB容器通过钝化有状态会话bean来保存会话状态，并在bean被激活时恢复状态。会话状态是有状态会话bean的生命周期比无状态会话bean或消息驱动bean的生命周期复杂一些的原因（EJB生命周期将在本章后面讨论）。
- en: The EJB container may provide any instance of an EJB in the pool when an EJB
    client application requests an instance of a stateless session bean. Since we
    are not guaranteed the same instance for every method call, values set to any
    instance variables in a stateless session bean may be "lost" (they are not really
    lost, the modification is in another instance of the EJB in the pool).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当EJB客户端应用程序请求一个无状态会话bean的实例时，EJB容器可能会在池中提供任何EJB实例。由于我们无法保证每次方法调用都使用相同的实例，因此设置在无状态会话bean中的任何实例变量的值可能会“丢失”（它们实际上并没有丢失，修改发生在池中EJB的另一个实例中）。
- en: 'Other than being decorated with the `@Stateless` annotation, there is nothing
    special about this class. Notice that it implements an interface called **SimpleSession**.
    This interface is the bean''s business interface. The `SimpleSession` interface
    is shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了被`@Stateless`注解装饰外，这个类没有其他特殊之处。请注意，它实现了一个名为**SimpleSession**的接口。这个接口是bean的业务接口。`SimpleSession`接口如下所示：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The only peculiar thing about this interface is that it is decorated with the
    `@Remote` annotation. This annotation indicates that this is a remote business
    interface. What this means is that the interface may be in a different JVM than
    the client application invoking it. Remote business interfaces may even be invoked
    across the network.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口唯一奇特的地方就是它被`@Remote`注解所装饰。这个注解表明这是一个远程业务接口。这意味着该接口可能位于调用它的客户端应用程序不同的JVM中。远程业务接口甚至可以跨网络调用。
- en: Business interfaces may also be decorated with the `@Local` interface. This
    annotation indicates that the business interface is a local business interface.
    Local business interface implementations must be in the same JVM as the client
    application invoking its methods.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 业务接口也可以被`@Local`接口装饰。这个注解表明业务接口是一个本地业务接口。本地业务接口的实现必须与调用其方法的客户端应用程序在同一个JVM中。
- en: Since remote business interfaces can be invoked either from the same JVM or
    from a different JVM as the client application, at first glance we might be tempted
    to make all of our business interfaces remote. Before doing so, we must be aware
    of the fact that the flexibility provided by remote business interfaces comes
    with a performance penalty, since method invocations are made on the assumption
    that they will be made across the network. As a matter of fact, most typical Java
    EE applications consist of web applications acting as client applications for
    EJBs. In this case, the client application and the EJB are running on the same
    JVM, therefore local interfaces are used a lot more frequently than remote business
    interfaces.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于远程业务接口可以从与客户端应用程序相同的JVM或不同的JVM中调用，乍一看我们可能会倾向于将所有业务接口都设置为远程。在这样做之前，我们必须意识到远程业务接口提供的灵活性伴随着性能上的代价，因为方法调用是在假设它们将在网络上进行的情况下进行的。事实上，大多数典型的Java
    EE应用程序由充当EJB客户端应用程序的Web应用程序组成。在这种情况下，客户端应用程序和EJB运行在同一个JVM上，因此本地接口比远程业务接口使用得更多。
- en: Once we have compiled the session bean and its corresponding business interface,
    we need to place them in a JAR file and deploy them. How to deploy an EJB JAR
    file depends on what application server we are using. However, most modern application
    servers have an `autodeploy` directory; we can simply copy our EJB JAR file to
    this directory in most cases. Consult your application server documentation to
    find the exact location of its `autodeploy` directory.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编译了会话Bean及其相应的业务接口，我们需要将它们放入一个JAR文件中并部署它们。如何部署EJB JAR文件取决于我们使用的是哪种应用服务器。然而，大多数现代应用服务器都有一个`autodeploy`目录；在大多数情况下，我们可以简单地复制我们的EJB
    JAR文件到这个目录。请查阅您的应用服务器文档以找到其`autodeploy`目录的确切位置。
- en: Implementing EJB client code
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现EJB客户端代码
- en: 'Now that we have seen the session bean and its corresponding business interface,
    let''s take a look at a client sample application:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了会话Bean及其相应的业务接口，让我们看看一个客户端示例应用程序：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code simply declares an instance variable of type `net.ensode.SimpleSession`,
    which is the business interface for our session bean. The instance variable is
    decorated with the `@EJB` annotation; this annotation lets the EJB container know
    that this variable is a business interface for a session bean. The EJB container
    then injects an implementation of the business interface for the client code to
    use.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码仅仅声明了一个类型为`net.ensode.SimpleSession`的实例变量，这是我们的会话Bean的业务接口。这个实例变量被`@EJB`注解所装饰；这个注解让EJB容器知道这个变量是一个会话Bean的业务接口。然后EJB容器注入一个业务接口的实现供客户端代码使用。
- en: 'Since our client is a standalone application (as opposed to a Java EE artifact
    such as a WAR file or another EJB JAR file), it isn''t actually deployed to the
    application server. In order for it to be able to access code deployed to the
    server, it must have access to the application server''s client libraries. The
    procedure on how to accomplish this varies from application server to application
    server. When using GlassFish, our client code must be placed in a JAR file and
    executed through the `appclient` utility. This utility can be found at `[glassfish
    installation directory]/glassfish/bin/`. Assuming this directory is in the PATH
    environment variable, and assuming we placed our client code in a JAR file called
    `simplesessionbeanclient.jar`, we would execute the preceding client code by typing
    the following command in the command line:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的客户端是一个独立的应用程序（而不是像WAR文件或另一个EJB JAR文件这样的Java EE工件），它实际上并没有部署到应用服务器。为了使其能够访问部署到服务器的代码，它必须能够访问应用服务器的客户端库。如何实现这一点的步骤因应用服务器而异。当使用GlassFish时，我们的客户端代码必须放入一个JAR文件中并通过`appclient`实用程序执行。这个实用程序可以在`[glassfish安装目录]/glassfish/bin/`中找到。假设这个目录在PATH环境变量中，并且假设我们将我们的客户端代码放入一个名为`simplesessionbeanclient.jar`的JAR文件中，我们将在命令行中键入以下命令来执行前面的客户端代码：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Executing the preceding command results in the following console output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述命令会产生以下控制台输出：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is the output of the `SessionBeanClient` class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`SessionBeanClient`类的输出。
- en: We are using Maven to build our code. For this example, we used the Maven Assembly
    plugin ([http://maven.apache.org/plugins/maven-assembly-plugin/](http://maven.apache.org/plugins/maven-assembly-plugin/))
    to build a client JAR file that includes all dependencies. This frees us from
    having to specify all the dependent JAR files in the `-classpath` command line
    option of `appclient`. To build this JAR file, simply invoke `mvn assembly:assembly`
    from the command line.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Maven来构建我们的代码。在这个例子中，我们使用了Maven Assembly插件([http://maven.apache.org/plugins/maven-assembly-plugin/](http://maven.apache.org/plugins/maven-assembly-plugin/))来构建一个包含所有依赖项的客户端JAR文件。这使我们免去了在`appclient`的`-classpath`命令行选项中指定所有依赖JAR文件的需要。要构建这个JAR文件，只需在命令行中调用`mvn
    assembly:assembly`。
- en: The first line of output is simply the return value of the `getMessage()` method
    we implemented in the session bean. The second line of output displays the fully
    qualified class name of the class implementing the business interface. Notice
    that the class name is not the fully qualified name of the session bean we wrote;
    instead, what is actually provided is an implementation of the business interface
    created behind the scenes by the EJB container.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行仅仅是我们在会话Bean中实现的`getMessage()`方法的返回值。输出的第二行显示了实现业务接口的类的完全限定类名。请注意，类名不是我们所写的会话Bean的完全限定名称；相反，实际上提供的是由EJB容器在幕后创建的业务接口的实现。
- en: A more realistic example
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个更实际的例子
- en: In the previous section, we saw a very simple "Hello world" type of example.
    In this section, we will use a more realistic example. Session beans are frequently
    used as Data Access Objects (**DAOs**). Sometimes they are used as a wrapper for
    JDBC calls, other times they are used to wrap calls to obtain or modify JPA entities.
    In this section, we will take the latter approach.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了一个非常简单的“Hello world”类型的示例。在本节中，我们将使用一个更实际的示例。会话Bean通常用作数据访问对象（**DAO**）。有时它们被用作JDBC调用的包装器，有时它们被用来包装获取或修改JPA实体的调用。在本节中，我们将采用后一种方法。
- en: 'The following example illustrates how to implement the DAO design pattern in
    a session bean. Before looking at the bean implementation, let''s look at its
    corresponding business interface:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何在会话Bean中实现DAO设计模式。在查看Bean实现之前，让我们看看其对应的企业接口：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we can see, this is a remote interface implementing three methods; the `saveCustomer()`
    method saves customer data to the database, the `getCustomer()` method obtains
    data for a customer from the database, and the `deleteCustomer()` method deletes
    customer data from the database. All of these methods take an instance of the
    `Customer` entity we developed in [Chapter 3](1dec503e-112f-4f75-8569-4311c0cee377.xhtml),
    *Object Relational Mapping with JPA* as a parameter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这是一个实现三个方法的远程接口；`saveCustomer()`方法将客户数据保存到数据库中，`getCustomer()`方法从数据库中获取客户数据，而`deleteCustomer()`方法从数据库中删除客户数据。所有这些方法都接受我们[第3章](1dec503e-112f-4f75-8569-4311c0cee377.xhtml)中开发的`Customer`实体实例作为参数，*使用JPA进行对象关系映射*。
- en: 'Let''s now take a look at the session bean implementing the preceding business
    interface. As we are about to see, there are some differences between the way
    JPA code is implemented in a session bean and in a plain old `Java` object:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看实现上述业务接口的会话Bean。正如我们即将看到的，在会话Bean和普通的`Java`对象中实现JPA代码的方式之间有一些区别：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The main difference between the preceding session bean and previous JPA examples
    is that in previous examples, JPA calls were wrapped between calls to `UserTransaction.begin()`
    and `UserTransaction.commit()`. The reason we had to do this is because JPA calls
    are required to be wrapped in a transaction; if they are not in a transaction,
    most JPA calls will throw a `TransactionRequiredException`. The reason we don't
    have to explicitly wrap JPA calls in a transaction like in previous examples is
    because session bean methods are implicitly transactional, there is nothing we
    need to do to make them that way. This default behavior is what is known as container-managed
    transactions. Container-managed transactions are discussed in detail later in
    this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 之前会话Bean与之前的JPA示例之间的主要区别在于，在之前的示例中，JPA调用被包裹在`UserTransaction.begin()`和`UserTransaction.commit()`调用之间。我们必须这样做的原因是JPA调用必须被包裹在事务中；如果没有在事务中，大多数JPA调用将抛出`TransactionRequiredException`。我们不需要像之前示例中那样显式地包裹JPA调用在事务中，是因为会话Bean方法隐式地是事务性的，我们不需要做任何事情来使它们成为那样。这种默认行为被称为容器管理事务。容器管理事务将在本章后面详细讨论。
- en: As mentioned in [Chapter 3](1dec503e-112f-4f75-8569-4311c0cee377.xhtml), *Object
    Relational Mapping with Java Persistence API*, when a JPA entity is retrieved
    in one transaction and updated in a different transaction, the `EntityManager.merge()`
    method needs to be invoked to update the data in the database. Invoking `EntityManager.persist()`
    in this case will result in a "Cannot persist detached object" exception.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第3章](1dec503e-112f-4f75-8569-4311c0cee377.xhtml)中所述，*使用Java持久化API进行对象关系映射*，当JPA实体在一个事务中检索并在另一个事务中更新时，需要调用`EntityManager.merge()`方法来更新数据库中的数据。在这种情况下调用`EntityManager.persist()`将导致“无法持久化分离对象”异常。
- en: Invoking session beans from web applications
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Web应用程序调用会话Bean
- en: Frequently, Java EE applications consist of web applications acting as clients
    for EJBs. Before Java EE 6, the most common way of deploying a Java EE application
    that consists of both a web application and one or more session beans was to package
    both the WAR file for the web application and the EJB JAR files into an **EAR**
    (**Enterprise ARchive**) file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Java EE应用程序由充当EJB客户端的Web应用程序组成。在Java EE 6之前，部署包含Web应用程序和一个或多个会话Bean的Java
    EE应用程序的最常见方式是将Web应用程序的WAR文件和EJB JAR文件打包成一个**EAR**（**企业存档**）文件。
- en: Java EE 6 simplified the packaging and deployment of applications consisting
    of both EJBs and web components.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 6简化了包含EJB和Web组件的应用程序的打包和部署。
- en: In this section, we will develop a JSF application with a CDI named bean acting
    as a client to the DAO session bean we just discussed in the previous section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个 JSF 应用程序，其中包含一个 CDI 命名 bean 作为我们刚才在上一节中讨论的 DAO 会话 bean 的客户端。
- en: 'In order to make this application act as an EJB client, we will develop a `CustomerController`
    named bean so that it delegates the logic to save a new customer to the database
    to the `CustomerDaoBean` session bean we developed in the previous section:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个应用程序充当 EJB 客户端，我们将开发一个名为 `CustomerController` 的命名 bean，以便将保存新客户到数据库的逻辑委托给我们在上一节中开发的
    `CustomerDaoBean` 会话 bean：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see, all we had to do was to declare an instance of the `CustomerDaoBean`
    session bean, and decorate it with the `@EJB` annotation so that an instance of
    the corresponding EJB is injected, then invoke the EJB's `saveCustomer()` method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们只需声明 `CustomerDaoBean` 会话 bean 的一个实例，并用 `@EJB` 注解来装饰它，以便注入相应的 EJB 实例，然后调用
    EJB 的 `saveCustomer()` 方法。
- en: Notice that we injected an instance of the session bean directly into our client
    code. The reason we can do this is because of a feature introduced in Java EE
    6\. When using Java EE 6 or newer, we can do away with local interfaces and use
    session bean instances directly in our client code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们直接将会话 bean 的实例注入到我们的客户端代码中。我们可以这样做的原因是 Java EE 6 中引入的一个特性。当使用 Java EE 6
    或更高版本时，我们可以去掉本地接口，并在客户端代码中直接使用会话 bean 实例。
- en: Now that we have modified our web application to be a client for our session
    bean, we need to package it in a **WAR** (**web archive**) file and deploy it
    in order to use it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修改了我们的 Web 应用程序以作为会话 bean 的客户端，我们需要将其打包成 **WAR**（**Web 归档**）文件并部署，以便使用它。
- en: Singleton session beans
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例会话 bean
- en: A new type of session bean that was introduced in Java EE 6 is the singleton
    session bean. A single instance of each singleton session bean exists in the application
    server.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 6 中引入的一种新的会话 bean 类型是单例会话 bean。每个单例会话 bean 在应用服务器中只存在一个实例。
- en: 'Singleton session beans are useful to cache database data. Caching frequently-used
    data in a singleton session bean increases performance since it greatly minimizes
    trips to the database. The common pattern is to have a method in our bean decorated
    with the `@PostConstruct` annotation; in this method we retrieve the data we want
    to cache. Then we provide a setter method for the bean''s clients to call. The
    following example illustrates this technique:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 单例会话 bean 对于缓存数据库数据很有用。在单例会话 bean 中缓存常用数据可以提高性能，因为它大大减少了访问数据库的次数。常见的模式是在我们的
    bean 中有一个带有 `@PostConstruct` 注解的方法；在这个方法中，我们检索我们想要缓存的数据。然后我们提供一个设置方法供 bean 的客户端调用。以下示例说明了这种技术：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since our bean is a singleton, all of its clients would access the same instance,
    avoiding having duplicate data in memory. Additionally, since it is a singleton,
    it is safe to have an instance variable, since all clients access the same instance
    of the bean.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 bean 是单例的，所以所有客户端都会访问同一个实例，避免了内存中存在重复数据。此外，由于它是单例的，因此可以安全地有一个实例变量，因为所有客户端都访问同一个
    bean 的实例。
- en: Asynchronous method calls
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步方法调用
- en: Sometimes it is useful to have some processing done asynchronously, that is,
    invoking a method call and returning control immediately to the client, without
    having the client wait for the method to finish.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有时进行异步处理很有用，即调用方法调用并立即将控制权返回给客户端，而无需客户端等待方法完成。
- en: In earlier versions of Java EE, the only way to invoke EJB methods asynchronously
    was to use message-driven beans (discussed in the next section). Although message-driven
    beans are fairly easy to write, they do require some configuration, such as setting
    up JMS message queues or topics, before they can be used.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java EE 的早期版本中，调用 EJB 方法异步的唯一方法是使用消息驱动 bean（将在下一节中讨论）。尽管消息驱动 bean 编写起来相对简单，但它们在使用之前确实需要一些配置，例如设置
    JMS 消息队列或主题。
- en: EJB 3.1 introduced the `@Asynchronous` annotation, which can be used to mark
    a method in a session bean as asynchronous. When an EJB client invokes an asynchronous
    method, control immediately goes back to the client, without waiting for the method
    to finish.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: EJB 3.1 引入了 `@Asynchronous` 注解，它可以用来标记会话 bean 中的方法为异步。当 EJB 客户端调用异步方法时，控制权立即返回客户端，无需等待方法完成。
- en: 'Asynchronous methods can only return `void` or an implementation of the `java.util.concurrent.Future`
    interface. The following example illustrates both scenarios:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法只能返回`void`或`java.util.concurrent.Future`接口的实现。以下示例说明了这两种情况：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When our asynchronous method returns `void`, the only thing we need to do is
    decorate the method with the `@Asynchronous` annotation, then call it as usual
    from the client code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的异步方法返回`void`时，我们只需要用`@Asynchronous`注解装饰该方法，然后像往常一样从客户端代码中调用它。
- en: If we need a return value, this value needs to be wrapped in an implementation
    of the `java.util.concurrent.Future` interface. The Java EE API provides a convenience
    implementation in the form of the `javax.ejb.AsyncResult` class. Both the `Future`
    interface and the `AsyncResult` class use generics; we need to specify our return
    type as the type parameter of these artifacts.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要返回值，则此值需要包装在`java.util.concurrent.Future`接口的实现中。Java EE API以`javax.ejb.AsyncResult`类的形式提供了一个便利的实现。`Future`接口和`AsyncResult`类都使用泛型；我们需要将这些实物的返回类型指定为类型参数。
- en: 'The `Future` interface has several methods we can use to cancel execution of
    an asynchronous method, check to see if the method is done, get the return value
    of the method, or check to see if the method is canceled. The following table
    lists these methods:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future`接口有几个我们可以用来取消异步方法执行、检查方法是否完成、获取方法的返回值或检查方法是否被取消的方法。以下表格列出了这些方法：'
- en: '| **Method** | **Description** |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `cancel(boolean mayInterruptIfRunning)` | Cancels method execution. If the
    `boolean` parameter is true, then this method will attempt to cancel the method
    execution even if it is already running. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `cancel(boolean mayInterruptIfRunning)` | 取消方法执行。如果`boolean`参数为true，则此方法将尝试取消方法执行，即使它已经在运行。
    |'
- en: '| `get()` | Will return the "unwrapped" return value of the method; the return
    value will be of the `type` parameter of the `Future` interface implementation
    returned by the method. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `get()` | 将返回方法的“未包装”返回值；返回值将是方法返回的`Future`接口实现中`type`参数的类型。 |'
- en: '| `get(long timeout, TimeUnit unit)` | Will attempt the "unwrapped" return
    value of the method; the return value will be of the `type` parameter of the `Future`
    interface implementation returned by the method. This method will block the amount
    of time specified by the first parameter. The unit of time to wait is determined
    by the second parameter; the `TimeUnit` enum has constants for NANOSECONDS, MILLISECONDS,
    SECONDS, MINUTES, and so on. Refer to its Javadoc documentation for the complete
    list. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `get(long timeout, TimeUnit unit)` | 将尝试方法的“未包装”返回值；返回值将是方法返回的`Future`接口实现中`type`参数的类型。此方法将阻塞由第一个参数指定的时间量。等待时间的单位由第二个参数确定；`TimeUnit`枚举具有NANOSECONDS、MILLISECONDS、SECONDS、MINUTES等常量。有关完整列表，请参阅其Javadoc文档。
    |'
- en: '| `isCancelled()` | Returns true if the method has been canceled, false otherwise.
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `isCancelled()` | 如果方法已被取消，则返回true，否则返回false。 |'
- en: '| `isDone()` | Returns true if the method has finished executing, false otherwise.
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `isDone()` | 如果方法已执行完成，则返回true，否则返回false。 |'
- en: As we can see, the `@Asynchronous` annotation makes it very easy to make asynchronous
    calls without having the overhead of having to set up message queues or topics.
    It is certainly a welcome addition to the EJB specification.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`@Asynchronous`注解使得在不设置消息队列或主题的开销下进行异步调用变得非常容易。这无疑是EJB规范中的一个受欢迎的补充。
- en: Message-driven beans
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息驱动bean
- en: 'The purpose of a message-driven bean is to consume messages from a Java Message
    Service (JMS) queue or a JMS topic, depending on the messaging domain used (refer
    to [Chapter 8](cef6345a-3cb4-4d30-aa7b-a31c4f710e57.xhtml), *Java Message Service*).
    A message-driven bean must be decorated with the `@MessageDriven` annotation;
    the `mappedName` attribute of this annotation must contain the **Java Naming and
    Directory Interface** (**JNDI**) name of the JMS message queue or JMS message
    topic that the bean will be consuming messages from. The following example illustrates
    a simple message-driven bean:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 消息驱动bean的目的是根据所使用的消息传递域从Java消息服务（JMS）队列或JMS主题中消费消息（请参阅第8章，*Java消息服务*）。消息驱动bean必须用`@MessageDriven`注解装饰；此注解的`mappedName`属性必须包含bean将从中消费消息的JMS消息队列或JMS消息主题的**Java命名和目录接口**（**JNDI**）名称。以下示例说明了一个简单的消息驱动bean：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Message-driven beans must be decorated with the `@MessageDriven` annotation.
    They listen for messages on the queue or topic defined in the `mappedName` attribute
    of the `@MessageDriven` interface (`jms/JavaEEBookQueue` in this example).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 消息驱动 Bean 必须装饰 `@MessageDriven` 注解。它们监听在 `@MessageDriven` 接口的 `mappedName` 属性中定义的队列或主题上的消息（在这个例子中是
    `jms/JavaEEBookQueue`）。
- en: It is recommended, but not required, for message-driven beans to implement the
    `javax.jms.MessageListener` interface; however message-driven beans must have
    a method called `onMessage()` whose signature is identical to the preceding example.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 建议但不是必须的消息驱动 Bean 实现接口 `javax.jms.MessageListener`；然而，消息驱动 Bean 必须有一个名为 `onMessage()`
    的方法，其签名与前面的示例相同。
- en: Client applications never invoke a message-driven bean's methods directly; instead
    they put messages in the message queue or topic, then the bean consumes those
    messages and acts appropriately. The preceding example simply prints the message
    to standard output; since message-driven beans execute inside an EJB container,
    standard output gets redirected to a log. If using GlassFish, the server log file
    can be found at `[GlassFish installation directory]/glassfish/domains/domain1/logs/server.log`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序永远不会直接调用消息驱动 Bean 的方法；相反，它们将消息放入消息队列或主题，然后 Bean 消费这些消息并相应地执行。前面的示例只是将消息打印到标准输出；由于消息驱动
    Bean 在 EJB 容器内执行，标准输出被重定向到日志。如果使用 GlassFish，服务器日志文件可以在 `[GlassFish 安装目录]/glassfish/domains/domain1/logs/server.log`
    中找到。
- en: Transactions in enterprise JavaBeans
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业 JavaBeans 中的事务
- en: Like we mentioned earlier in this chapter, by default all EJB methods are automatically
    wrapped in a transaction. This default behavior is known as container-managed
    transactions, since transactions are managed by the EJB container. Application
    developers may also choose to manage transactions themselves, which can be accomplished
    by using bean-managed transactions. Both of these approaches are discussed in
    the following sections.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面提到的，默认情况下，所有 EJB 方法都会自动包装在一个事务中。这种默认行为被称为容器管理事务，因为事务是由 EJB 容器管理的。应用程序开发者也可以选择自己管理事务，这可以通过使用
    Bean 管理事务来实现。这两种方法将在以下章节中讨论。
- en: Container-managed transactions
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器管理的事务
- en: Because EJB methods are transactional by default, we run into an interesting
    dilemma when an EJB method is invoked from client code that is already in a transaction.
    How should the EJB container behave? Should it suspend the client transaction,
    execute its method in a new transaction, and then resume the client transaction?
    Should it not create a new transaction and execute its method as part of the client
    transaction? Should it throw an exception?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 EJB 方法默认是事务性的，当从已经在事务中的客户端代码调用 EJB 方法时，我们会遇到一个有趣的困境。EJB 容器应该如何表现？它应该挂起客户端事务，在一个新的事务中执行其方法，然后恢复客户端事务吗？或者它不应该创建新的事务，而是将方法作为客户端事务的一部分执行？或者它应该抛出异常？
- en: By default, if an EJB method is invoked by client code that is already in a
    transaction, the EJB container will simply execute the session bean method as
    part of the client transaction. If this is not the behavior we need, we can change
    it by decorating the method with the `@TransactionAttribute` annotation. This
    annotation has a `value` attribute that determines how the EJB container will
    behave when the session bean method is invoked within an existing transaction
    and when it is invoked outside any transactions. The value of the `value` attribute
    is typically a constant defined in the `javax.ejb.TransactionAttributeType` enum.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果 EJB 方法被已经在事务中的客户端代码调用，EJB 容器将简单地执行会话 Bean 方法作为客户端事务的一部分。如果这不是我们需要的操作，我们可以通过在方法上装饰
    `@TransactionAttribute` 注解来改变它。这个注解有一个 `value` 属性，它决定了当会话 Bean 方法在现有事务中调用或在外部任何事务中调用时，EJB
    容器的行为。`value` 属性的值通常是定义在 `javax.ejb.TransactionAttributeType` 枚举中的常量。
- en: 'The following table lists the possible values for the `@TransactionAttribute`
    annotation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了 `@TransactionAttribute` 注解的可能值：
- en: '| **Values** | **Description** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **值** | **描述** |'
- en: '| `TransactionAttributeType.MANDATORY` | Forces the method to be invoked as
    part of a client transaction. If the method is called outside any transactions,
    it will throw a `TransactionRequiredException`. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `TransactionAttributeType.MANDATORY` | 强制方法作为客户端事务的一部分被调用。如果方法在没有任何事务的情况下被调用，它将抛出
    `TransactionRequiredException` 异常。|'
- en: '| `TransactionAttributeType.NEVER` | The method is never executed in a transaction.
    If the method is invoked as part of a client transaction, it will throw a `RemoteException`.
    No transaction is created if the method is not invoked inside a client transaction.
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `TransactionAttributeType.NEVER` | 方法永远不会在事务中执行。如果方法作为客户端事务的一部分被调用，它将抛出`RemoteException`。如果方法不在客户端事务内部调用，则不会创建事务。
    |'
- en: '| `TransactionAttributeType.NOT_SUPPORTED` | If the method is invoked as part
    of a client transaction, the client transaction is suspended and the method is
    executed outside any transaction; after the method completes, the client transaction
    is resumed. No transaction is created if the method is not invoked inside a client
    transaction. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `TransactionAttributeType.NOT_SUPPORTED` | 如果方法作为客户端事务的一部分被调用，客户端事务将被挂起，方法将在任何事务之外执行；方法完成后，客户端事务将恢复。如果方法不在客户端事务内部调用，则不会创建事务。
    |'
- en: '| `TransactionAttributeType.REQUIRED` | If the method is invoked as part of
    a client transaction, the method is executed as part of this transaction. If the
    method is invoked outside any transaction, a new transaction is created for the
    method. This is the default behavior. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `TransactionAttributeType.REQUIRED` | 如果方法作为客户端事务的一部分被调用，则方法将作为此事务的一部分执行。如果方法在没有任何事务的情况下被调用，将为该方法创建一个新的事务。这是默认行为。
    |'
- en: '| `TransactionAttributeType.REQUIRES_NEW` | If the method is invoked as part
    of a client transaction, this transaction is suspended, and a new transaction
    is created for the method. Once the method completes, the client transaction is
    resumed. If the method is called outside any transactions, a new transaction is
    created for the method. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `TransactionAttributeType.REQUIRES_NEW` | 如果方法作为客户端事务的一部分被调用，则此事务将被挂起，并为该方法创建一个新的事务。一旦方法完成，客户端事务将恢复。如果方法在没有任何事务的情况下被调用，将为该方法创建一个新的事务。
    |'
- en: '| `TransactionAttributeType.SUPPORTS` | If the method is invoked as part of
    a client transaction, it is executed as part of this transaction. If the method
    is invoked outside a transaction, no new transaction is created for the method.
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `TransactionAttributeType.SUPPORTS` | 如果方法作为客户端事务的一部分被调用，它将作为此事务的一部分执行。如果方法在事务之外被调用，则不会为该方法创建新的事务。
    |'
- en: 'Although the default transaction attribute is reasonable in most cases, it
    is good to be able to override this default if necessary. For example, as transactions
    have a performance impact, being able to turn off transactions for a method that
    does not need them is beneficial. For a case like this, we would decorate our
    method as illustrated in the following code snippet:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在大多数情况下默认事务属性是合理的，但能够在必要时覆盖此默认值是很好的。例如，由于事务有性能影响，能够关闭不需要事务的方法的事务是有益的。对于这种情况，我们将像以下代码片段所示的那样装饰我们的方法：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Other transaction attribute types can be declared by annotating the methods
    with the corresponding constant in the `TransactionAttributeType` enum.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 其他事务属性类型可以通过在方法上使用`TransactionAttributeType`枚举中相应的常量来声明。
- en: If we wish to override the default transaction attribute consistently across
    all methods in a session bean, we can decorate the session bean class with the
    `@TransactionAttribute` annotation; the value of its `value` attribute will be
    applied to every method in the session bean.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在会话Bean中的所有方法上始终一致地覆盖默认事务属性，我们可以用`@TransactionAttribute`注解装饰会话Bean类；其`value`属性的值将应用于会话Bean中的每个方法。
- en: 'Container-managed transactions are automatically rolled back whenever an exception
    is thrown inside an EJB method. Additionally, we can programmatically roll back
    a container-managed transaction by invoking the `setRollbackOnly()` method on
    an instance of `javax.ejb.EJBContext` corresponding to the session bean in question.
    The following example is a new version of the session bean we saw earlier in this
    chapter, modified to roll back transactions if necessary:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 容器管理的事务在EJB方法内部抛出异常时将自动回滚。此外，我们可以通过在对应于会话Bean的`javax.ejb.EJBContext`实例上调用`setRollbackOnly()`方法来程序化地回滚容器管理的事务。以下示例是本章前面看到的会话Bean的新版本，修改为在必要时回滚事务：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this version of the DAO session bean, we deleted the `saveCustomer()` method
    and made the `saveNewCustomer()` and `updateCustomer()` methods public. Each of
    these methods now checks to see if the `customerId` field is set correctly for
    the operation we are trying to perform (`null` for inserts and not `null` for
    updates). It also checks to make sure the object to be persisted is not `null`.
    If any of the checks results in invalid data, the method simply rolls back the
    transaction by invoking the `setRollBackOnly()` method on the injected instance
    of `EJBContext` and does not update the database.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的DAO会话bean版本中，我们删除了`saveCustomer()`方法，并将`saveNewCustomer()`和`updateCustomer()`方法设置为公共。现在，每个这些方法都会检查我们试图执行的操作的`customerId`字段是否设置正确（对于插入是`null`，对于更新不是`null`）。它还会检查要持久化的对象不是`null`。如果任何检查导致无效数据，该方法将简单地通过在注入的`EJBContext`实例上调用`setRollBackOnly()`方法来回滚交易，并且不更新数据库。
- en: Bean-managed transactions
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bean管理的交易
- en: 'As we have seen, container-managed transactions make it ridiculously easy to
    write code that is wrapped in a transaction. There is nothing special that we
    need to do to make them that way; as a matter of fact, some developers are sometimes
    not even aware that they are writing code that will be transactional in nature
    when they develop session beans. Container-managed transactions cover most typical
    use cases that we will encounter. However they do have a limitation; each method
    can be wrapped in a single transaction or without a transaction. With container-managed
    transactions, it is not possible to implement a method that generates more than
    one transaction, but this can be accomplished by using bean-managed transactions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，容器管理的交易使得编写被交易包裹的代码变得极其简单。我们不需要做任何特别的事情来达到这种效果；事实上，一些开发者在开发会话bean时甚至可能没有意识到他们正在编写具有交易性质的代码。容器管理的交易涵盖了我们将遇到的大部分典型用例。然而，它们确实有一个限制；每个方法可以包裹在一个单独的交易中，或者不包裹在交易中。使用容器管理的交易，无法实现生成多个交易的方法，但可以通过使用bean管理的交易来完成：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we implemented a method named `saveMultipleNewCustomers()`.
    This method takes a `List` of customers as its sole parameter. The intention of
    this method is to save as many elements in the `ArrayList` as possible. An exception
    while saving one of the entities should not stop the method from attempting to
    save the remaining elements. This behavior is not possible using container-managed
    transactions, since an exception thrown when saving one of the entities will roll
    back the whole transaction; the only way to achieve this behavior is through bean-managed
    transactions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们实现了一个名为`saveMultipleNewCustomers()`的方法。此方法仅接受一个客户`List`作为其唯一参数。此方法的目的是在`ArrayList`中尽可能多地保存元素。在保存实体时抛出的异常不应阻止方法尝试保存剩余的元素。使用容器管理的交易无法实现这种行为，因为当保存实体时抛出的异常将回滚整个交易；实现此行为的唯一方法是通过bean管理的交易。
- en: As can be seen in the example, we declare that the session bean uses bean-managed
    transactions by decorating the class with the `@TransactionManagement` annotation
    and using `TransactionManagementType.BEAN` as the value for its `value` attribute
    (the only other valid value for this attribute is `TransactionManagementType.CONTAINER`,
    but since this is the default value, it is not necessary to specify it).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，我们通过在类上添加`@TransactionManagement`注解，并将`TransactionManagementType.BEAN`作为其`value`属性的值（此属性的另一个有效值是`TransactionManagementType.CONTAINER`，但由于这是默认值，因此没有必要指定它）来声明会话bean使用bean管理的交易。
- en: To be able to programmatically control transactions, we inject an instance of
    `javax.transaction.UserTransaction`, which is then used in the `for` loop inside
    the `saveMultipleNewCustomers()` method to begin and commit transactions in each
    iteration of the loop.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够以编程方式控制交易，我们注入了一个`javax.transaction.UserTransaction`实例，然后在`saveMultipleNewCustomers()`方法内的`for`循环中使用它来开始和提交每个循环迭代的交易。
- en: If we need to roll back a bean-managed transaction, we can do it by simply calling
    the `rollback()` method on the appropriate instance of `javax.transaction.UserTransaction`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要回滚一个bean管理的交易，我们可以通过简单地调用`javax.transaction.UserTransaction`适当实例上的`rollback()`方法来实现。
- en: Before moving on, it is worth noting that, even though all the examples in this
    section were session beans, the concepts explained apply to message-driven beans
    as well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，值得注意的是，尽管本节中的所有示例都是会话bean，但所解释的概念也适用于消息驱动的bean。
- en: Enterprise JavaBean life cycles
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业JavaBean生命周期
- en: Enterprise JavaBeans go through different states in their life cycle. Each type
    of EJB has different states. States specific to each type of EJB are discussed
    in the next sections.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 企业JavaBean在其生命周期中会经历不同的状态。每种类型的EJB都有不同的状态。每种类型EJB的特定状态将在下一节中讨论。
- en: Stateful session bean life cycle
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有状态会话Bean生命周期
- en: We can annotate methods in session beans so that they are automatically invoked
    by the EJB container at certain points in the bean's life cycle. For example,
    we could have a method invoked right after the bean is created or right before
    it is destroyed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在会话Bean中注解方法，以便EJB容器在Bean生命周期的特定点自动调用它们。例如，我们可以在Bean创建后立即调用一个方法，或者在其销毁前调用一个方法。
- en: Before explaining the annotations available to implement life cycle methods,
    a brief explanation of the session bean life cycle is in order. The life cycle
    of a stateful session bean is different from the life cycle of a stateless or
    singleton session bean.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释可用于实现生命周期方法的注解之前，有必要简要说明会话Bean的生命周期。有状态会话Bean的生命周期与无状态或单例会话Bean的生命周期不同。
- en: 'A stateful session bean life cycle contains three states: Does Not Exist, Ready,
    and Passive:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态会话Bean的生命周期包含三个状态：不存在、就绪和被动：
- en: '![](img/c17032d2-5069-48a4-9719-59c822d02be3.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c17032d2-5069-48a4-9719-59c822d02be3.png)'
- en: Before a stateful session bean is deployed, it is in the Does Not Exist state.
    Upon successful deployment, the EJB container does any required dependency injection
    on the bean and it goes into the Ready state. At this point, the bean is ready
    to have its methods called by a client application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在有状态会话Bean部署之前，它处于不存在状态。在成功部署后，EJB容器会对Bean进行任何所需的依赖注入，然后进入就绪状态。此时，Bean准备好被客户端应用程序调用其方法。
- en: When a stateful session bean is in the Ready state, the EJB container may decide
    to passivate it, that is, to move it from the main memory to secondary storage,
    when this happens the bean goes into the Passive state.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当有状态会话Bean处于就绪状态时，EJB容器可能会决定将其钝化，即将其从主内存移动到二级存储，当这种情况发生时，Bean进入被动状态。
- en: 'If an instance of a stateful session bean hasn''t been accessed for a period
    of time, the EJB container will set the bean to the Does Not Exist state. How
    long a bean will stay in memory before being destroyed varies from application
    server to application server, and is usually configurable. By default, GlassFish
    will send a stateful session bean to the Does Not Exist state after 90 minutes
    of inactivity. When deploying our code to GlassFish, this default can be changed
    by going to the GlassFish administration console; expanding the Configuration
    node in the tree at the right-hand side; expanding the server-config node; clicking
    on the EJB Container node; scrolling down towards the bottom of the page and modifying
    the value of the Removal Timeout text field; and then finally clicking on either
    of the Save buttons (the top right or bottom right of the main page):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '如果有状态会话Bean的一段时间内没有被访问，EJB容器将把Bean设置为不存在状态。Bean在内存中保持多长时间才被销毁因应用服务器而异，通常是可以配置的。默认情况下，GlassFish将在90分钟的不活动后把有状态会话Bean发送到不存在状态。当将我们的代码部署到GlassFish时，这个默认值可以通过访问GlassFish管理控制台；展开右侧树中的配置节点；展开服务器配置节点；点击EJB容器节点；滚动到页面底部并修改移除超时文本框的值；然后最终点击主页面右上角或右下角的任何一个保存按钮来更改： '
- en: '![](img/7eb7d285-e165-4914-810e-5dfb26e3c601.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb7d285-e165-4914-810e-5dfb26e3c601.png)'
- en: 'However, this technique sets the timeout value for all stateful session beans.
    If we need to modify the timeout value for a specific session bean, we need to
    include a `glassfish-ejb-jar.xml` deployment descriptor in the JAR file containing
    the session bean. In this deployment descriptor, we can set the timeout value
    as the value of the `<removal-timeout-in-seconds>` element:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种技术为所有有状态会话Bean设置了超时值。如果我们需要修改特定会话Bean的超时值，我们需要在包含会话Bean的JAR文件中包含一个`glassfish-ejb-jar.xml`部署描述符。在这个部署描述符中，我们可以将超时值设置为`<removal-timeout-in-seconds>`元素的值：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Even though we are no longer required to create an `ejb-jar.xml` for our session
    beans (this was necessary in previous versions of the J2EE specification), we
    can still write one if we want to. The `<ejb-name>` element in the `glassfish-ejb-jar.xml`
    deployment descriptor must match the value of the element of the same name in
    `ejb-jar.xml`. If we choose not to create an `ejb-jar.xml`, then this value must
    match the name of the EJB class. The timeout value for the stateful session bean
    must be the value of the `<removal-timeout-in-seconds>` element; as the name of
    the element suggests, the unit of time to use is seconds. In the preceding example,
    we set the timeout value to 600 seconds, or 10 minutes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不再需要为我们的会话Bean创建`ejb-jar.xml`（在J2EE规范的先前版本中这是必要的），我们仍然可以创建一个。`glassfish-ejb-jar.xml`部署描述符中的`<ejb-name>`元素必须与`ejb-jar.xml`中同名元素的值匹配。如果我们选择不创建`ejb-jar.xml`，那么这个值必须与EJB类的名称匹配。有状态会话Bean的超时值必须是`<removal-timeout-in-seconds>`元素的值；正如元素名称所暗示的，时间单位是秒。在先前的例子中，我们将超时值设置为600秒，即10分钟。
- en: Any methods in a stateful session bean decorated with the `@PostActivate` annotation
    will be invoked just after the stateful session bean has been activated. Similarly,
    any method decorated with the `@PrePassivate` annotation will be invoked just
    before the stateful session bean is passivated.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰了`@PostActivate`注解的有状态会话Bean中的任何方法将在有状态会话Bean被激活后立即被调用。同样，装饰了`@PrePassivate`注解的任何方法将在有状态会话Bean被钝化之前被调用。
- en: When a stateful session bean that is in the Ready state times out and is sent
    to the Does not Exist state, any method decorated with the `@PreDestroy` annotation
    is executed. If the session bean is in the Passive state and it times out, methods
    decorated with the `@PreDestroy` annotation are not executed. Additionally, if
    a client of the stateful session bean executes any method decorated with the `@Remove`
    annotation, any methods decorated with the `@PreDestroy` annotation are executed
    and the bean is marked for garbage collection.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个处于“就绪”状态的有状态会话Bean超时并被发送到“不存在”状态时，任何装饰了`@PreDestroy`注解的方法将被执行。如果会话Bean处于“钝化”状态并且超时，则不会执行装饰了`@PreDestroy`注解的方法。此外，如果会话Bean的客户端执行了任何装饰了`@Remove`注解的方法，则执行装饰了`@PreDestroy`注解的方法，并且Bean将被标记为垃圾回收。
- en: The `@PostActivate`, `@PrePassivate`, and `@Remove` annotations are valid only
    for stateful session beans. The `@PreDestroy` and `@PostConstruct` annotations
    are valid for stateful session beans, stateless session beans, and message-driven
    beans.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PostActivate`、`@PrePassivate`和`@Remove`注解仅对有状态会话Bean有效。`@PreDestroy`和`@PostConstruct`注解对有状态会话Bean、无状态会话Bean和消息驱动Bean都有效。'
- en: Stateless and singleton session bean life cycles
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态和单例会话Bean的生命周期
- en: 'A stateless or singleton session bean life cycle contains only the Does Not
    Exist and Ready states:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态或单例会话Bean的生命周期只包含“不存在”和“就绪”状态：
- en: '![](img/dc7b289c-697e-46f9-b57a-ba55d6fc22b9.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dc7b289c-697e-46f9-b57a-ba55d6fc22b9.png)'
- en: Stateless and singleton session beans are never passivated. A stateless or singleton
    session bean's methods can be decorated with the `@PostConstruct` and the `@PreDestroy`
    annotations. Just like in stateful session beans, any methods decorated with the
    `@PostConstruct` annotation will be executed when the session bean goes from the
    Does Not Exist to the Ready State, and any methods decorated with the `@PreDestroy`
    annotation will be executed when a stateless session bean goes from the Ready
    state to the Does Not Exist state. Stateless and singleton session beans are never
    passivated, therefore any `@PrePassivate` and `@PostActivate` annotations in a
    stateless session bean are simply ignored by the EJB container.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态和单例会话Bean永远不会被钝化。无状态或单例会话Bean的方法可以装饰`@PostConstruct`和`@PreDestroy`注解。就像在有状态会话Bean中一样，任何装饰了`@PostConstruct`注解的方法将在会话Bean从“不存在”状态转换为“就绪”状态时执行，任何装饰了`@PreDestroy`注解的方法将在无状态会话Bean从“就绪”状态转换为“不存在”状态时执行。由于无状态和单例会话Bean永远不会被钝化，因此无状态会话Bean中的任何`@PrePassivate`和`@PostActivate`注解都将被EJB容器简单地忽略。
- en: 'Most application servers allow us to configure how long to wait before an idle
    stateless or singleton session bean is destroyed. If using GlassFish, we can control
    how the life cycle of stateless session beans (and message-driven beans) is managed
    via the administration web console:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用服务器允许我们配置在销毁空闲的无状态或单例会话Bean之前等待多长时间。如果使用GlassFish，我们可以通过管理Web控制台来控制无状态会话Bean（以及消息驱动Bean）的生命周期管理：
- en: '![](img/0180b4b8-333b-4a8a-95df-2aa96f1c9c83.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0180b4b8-333b-4a8a-95df-2aa96f1c9c83.png)'
- en: 'The settings shown in the preceding screenshot allow us to control the stateless
    session bean life cycle:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示的设置允许我们控制无状态会话豆的生命周期：
- en: Initial and Minimum Pool Size refers to the minimum number of beans in the pool
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始和最小池大小指的是池中最少的豆的数量
- en: Maximum Pool Size refers to the maximum number of beans in the pool
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大池大小指的是池中豆的最大数量
- en: Pool Resize Quantity refers to how many beans will be removed from the pool
    when the pool idle timeout expires
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 池大小调整数量指的是在池空闲超时到期时从池中移除多少个豆。
- en: Pool Idle Timeout refers to the number of seconds of inactivity to wait before
    removing beans from the pool
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 池空闲超时指的是在从池中移除豆之前等待的不活动秒数
- en: 'The preceding settings affect all poolable (stateless session beans and message-driven
    beans) EJBs. Just like with stateful session beans, these settings can be overridden
    on a case-by-case basis, by adding a GlassFish-specific `glassfish-ejb.jar.xml`
    deployment descriptor:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的设置影响所有池化（无状态会话豆和消息驱动豆）的 EJB。就像有状态会话豆一样，这些设置可以根据具体情况覆盖，通过添加特定的GlassFish部署描述符`glassfish-ejb.jar.xml`：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`glassfish-ejb-jar.xml` contains XML tags that are equivalent to the corresponding
    settings in the web console:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`glassfish-ejb-jar.xml`包含与Web控制台中相应设置等效的XML标签：'
- en: '`<steady-pool-size>` corresponds to Initial and Minimum Pool Size in the GlassFish
    web console'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<steady-pool-size>`对应于GlassFish Web控制台中的初始和最小池大小'
- en: '`<max-pool-size>` corresponds to Maximum Pool Size in the GlassFish web console'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<max-pool-size>`对应于GlassFish Web控制台中的最大池大小'
- en: '`<resize-quantity>` corresponds to Pool Resize Quantity in the GlassFish web
    console'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<resize-quantity>`对应于GlassFish Web控制台中的池大小调整数量'
- en: '`<pool-idle-timeout-in-seconds>` corresponds to Pool Idle Timeout in the GlassFish
    web console'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<pool-idle-timeout-in-seconds>`对应于GlassFish Web控制台中的池空闲超时'
- en: Message-driven bean life cycle
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息驱动豆生命周期
- en: 'Just like stateless session beans, message-driven beans contain only the Does
    Not Exist and Ready states:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 就像无状态会话豆一样，消息驱动豆只包含“不存在”和“就绪”状态：
- en: '![](img/84436122-97a2-4839-b994-2e8a6f2fa641.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84436122-97a2-4839-b994-2e8a6f2fa641.png)'
- en: A message-driven bean can have methods decorated with the `@PostConstruct` and
    `@PreDestroy` methods. Methods decorated with the `@PostConstruct` are executed
    just before the bean goes to the Ready state. Methods decorated with the `@PreDestroy`
    annotation are executed just before the bean goes to the Does Not Exist state.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 消息驱动豆可以有被`@PostConstruct`和`@PreDestroy`方法装饰的方法。被`@PostConstruct`装饰的方法在豆进入就绪状态之前执行。被`@PreDestroy`注解的方法在豆进入不存在状态之前执行。
- en: EJB timer service
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EJB 计时器服务
- en: 'Stateless session beans and message-driven beans can have a method that is
    executed periodically at regular intervals of time. This can be accomplished by
    using the EJB timer service. The following example illustrates how to take advantage
    of this feature:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态会话豆和消息驱动豆可以有一个在固定时间间隔定期执行的方法。这可以通过使用EJB计时器服务来实现。以下示例说明了如何利用此功能：
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding example, we inject an implementation of the `javax.ejb.TimerService`
    interface by decorating an instance variable of this type with the `@Resource`
    annotation. We can then create a timer by invoking the `createTimer()` method
    of this `TimerService` instance.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们通过使用`@Resource`注解装饰该类型的实例变量来注入`javax.ejb.TimerService`接口的实现。然后我们可以通过调用此`TimerService`实例的`createTimer()`方法来创建一个计时器。
- en: There are several overloaded versions of the `createTimer()` method. The one
    we chose to use takes an instance of `java.util.Date` as its first parameter;
    this parameter is used to indicate the first time the timer should expire ("trfgo
    off"). In the example, we chose to use a brand new instance of the `Date` class,
    which makes the timer expire immediately. The second parameter of the `createTimer()`
    method is the amount of time to wait, in milliseconds, before the timer expires
    again. In the preceding example, the timer will expire every five seconds. The
    third parameter of the `createTimer()` method can be an instance of any class
    implementing the `java.io.Serializable` interface. Since a single EJB can have
    several timers executing concurrently, this third parameter is used to uniquely
    identify each of the timers. If we don't need to identify the timers, null can
    be passed as a value for this parameter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`createTimer()`方法有几个重载版本。我们选择使用的方法接受一个`java.util.Date`实例作为其第一个参数；此参数用于指示定时器应该到期的第一次时间（"trfgo
    off"）。在示例中，我们选择使用一个新的`Date`类实例，这使得定时器立即到期。`createTimer()`方法的第二个参数是在定时器再次到期之前等待的时间，以毫秒为单位。在上面的示例中，定时器每五秒到期一次。`createTimer()`方法的第三个参数可以是实现`java.io.Serializable`接口的任何类的实例。由于单个EJB可以同时执行多个定时器，因此此第三个参数用于唯一标识每个定时器。如果我们不需要标识定时器，可以将null作为此参数的值。'
- en: The EJB method invoking `TimerService.createTimer()` must be called from an
    EJB client. Placing this call in an EJB method (decorated with the `@PostConstruct`
    annotation to start the timer automatically when the bean is placed in the Ready
    state) will result in an `IllegalStateException` being thrown.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`TimerService.createTimer()`的EJB方法必须从EJB客户端调用。将此调用放置在EJB方法中（使用`@PostConstruct`注解以在bean处于Ready状态时自动启动定时器）将导致抛出`IllegalStateException`异常。
- en: We can stop a timer by invoking its `cancel()` method. There is no way to directly
    obtain a single timer associated with an EJB; what we need to do is invoke the
    `getTimers()` method on the instance of `TimerService` that is linked to the EJB.
    This method will return a collection containing all the timers associated with
    the EJB; we can then iterate through the collection and cancel the correct one
    by invoking its `getInfo()` method. This method will return the `Serializable`
    object we passed as a parameter to the `createTimer()` method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用其`cancel()`方法来停止定时器。无法直接获取与EJB关联的单个定时器；我们需要做的是在链接到EJB的`TimerService`实例上调用`getTimers()`方法。此方法将返回一个包含与EJB关联的所有定时器的集合；然后我们可以遍历集合，通过调用其`getInfo()`方法来取消正确的定时器。此方法将返回我们传递给`createTimer()`方法的`Serializable`对象。
- en: Finally, any EJB method decorated with the `@Timeout` annotation will be executed
    when a timer expires. Methods decorated with this annotation must return void
    and take a single parameter of type `javax.ejb.Timer`. In our example, the method
    simply writes a message to the server log.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，任何被`@Timeout`注解装饰的EJB方法将在定时器到期时执行。被此注解装饰的方法必须返回void类型，并接受一个类型为`javax.ejb.Timer`的单个参数。在我们的例子中，该方法只是将一条消息写入服务器日志。
- en: 'The following class is a standalone client for the preceding EJB:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的类是前面EJB的独立客户端：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The example simply starts a timer, waits for a couple of seconds, and then
    starts a second timer. It then sleeps for 30 seconds and then stops both timers.
    After deploying the EJB and executing the client, we should see some entries like
    this in the server log:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 示例简单地启动一个定时器，等待几秒钟，然后启动第二个定时器。然后它睡眠30秒，然后停止两个定时器。在部署EJB并执行客户端后，我们应该在服务器日志中看到一些类似以下的条目：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These entries are created each time one of the timer expires.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每当定时器中的一个到期时，都会创建这些条目。
- en: Calendar-based EJB timer expressions
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于日历的EJB定时器表达式
- en: 'The example in the previous section has one disadvantage: the `startTimer()`
    method in the session bean must be invoked from a client in order to start the
    timer. This restriction makes it difficult to have the timer start as soon as
    the bean is deployed.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个示例有一个缺点：会话bean中的`startTimer()`方法必须由客户端调用才能启动定时器。这种限制使得定时器在bean部署后立即启动变得困难。
- en: 'Java EE 6 introduced calendar-based EJB timer expressions. Calendar-based expressions
    allow one or more methods in our session beans to be executed at a certain date
    and time. For example, we could configure one of our methods to be executed every
    night at 8:10 pm, which is exactly what our next example does:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 6 引入了基于日历的 EJB 定时器表达式。基于日历的表达式允许我们的会话 beans 中的一个或多个方法在特定的日期和时间执行。例如，我们可以配置我们的一个方法在每晚
    8:10 pm 执行，这正是我们下一个示例所做的事情：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we can see in the preceding example, we set up the time when the method will
    be executed via the `javax.ejb.Schedule` annotation. In this particular example,
    we set up our method to be executed at 8:10 pm by setting the `hour` attribute
    of the `@Schedule` annotation to `"20"`, and its minute attribute to `"10"` (since
    the value of the hour attribute is 24 hour-based, hour 20 is equivalent to 8:00
    pm).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一个示例所示，我们通过 `javax.ejb.Schedule` 注解设置方法执行的时间。在这个特定的例子中，我们通过将 `@Schedule`
    注解的 `hour` 属性设置为 `"20"`，并将其分钟属性设置为 `"10"`（因为小时属性是基于24小时的，小时20相当于晚上8:00），来设置我们的方法在晚上8:10
    pm 执行。
- en: The `@Schedule` annotation has several other attributes that allow a lot of
    flexibility in specifying when the method should be executed. We could, for instance,
    have a method executed on the third Friday of every month, or on the last day
    of the month, and so on and so forth.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Schedule` 注解有几个其他属性，允许在指定方法何时执行时具有很大的灵活性。例如，我们可以有一个方法在每月的第三个星期五执行，或者在月底执行，等等。'
- en: 'The following table lists all the attributes in the `@Schedule` annotation
    that allow us to control when the annotated method will be executed:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了 `@Schedule` 注解中所有允许我们控制注解方法何时执行的属性：
- en: '| **Attribute** | **Description** | **Example values** | **Default value**
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** | **示例值** | **默认值** |'
- en: '| `dayOfMonth` | The day of the month | `"3"`: The third day of the month `"Last"`:
    The last day of the month`"-2"`: Two days before the end of the month`"1st Tue"`:
    The first Tuesday of the month | `"*"` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `dayOfMonth` | 月份中的日期 | `"3"`: 月份的第三天 `"Last"`: 月份的最后一天`"-2"`: 月份结束前两天`"1st
    Tue"`: 月份的第一个星期二 | `"*"` |'
- en: '| `dayOfWeek` | The day of the week | `"3"`: Every Wednesday`"Thu"`: Every
    Thursday | `"*"` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `dayOfWeek` | 周中的日期 | `"3"`: 每周三`"Thu"`: 每周四 | `"*"` |'
- en: '| `hour` | Hour of the day (24 hour-based) | `"14"`: 2:00 pm | `"0"` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `hour` | 一天中的小时（基于24小时制） | `"14"`: 下午2:00 | `"0"` |'
- en: '| `minute` | Minute of the hour | `"10"`: Ten minutes after the hour | `"0"`
    |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `minute` | 小时中的分钟 | `"10"`: 小时后的十分钟 | `"0"` |'
- en: '| `month` | Month of the year | `"2"`: February`"March"`: March | `"*"` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `month` | 年中的月份 | `"2"`: 二月`"March"`: 三月 | `"*"` |'
- en: '| `second` | Second of the minute | `"5"`: Five seconds after the minute |
    `"0"` |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `second` | 分钟中的秒 | `"5"`: 分钟后的五秒 | `"0"` |'
- en: '| `timezone` | Timezone ID | `"America/New York"` | "" |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `timezone` | 时区ID | `"America/New York"` | "" |'
- en: '| `year` | Four digit year | `"2010"` | `"*"` |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `year` | 四位年份 | `"2010"` | `"*"` |'
- en: In addition to single values, most attributes accept the asterisk (`*`) as a
    wild card, meaning that the annotated method will be executed every unit of time
    (every day, hour, and so on).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单个值之外，大多数属性接受星号（`*`）作为通配符，这意味着注解的方法将在每个时间单位（每天、每小时等）执行。
- en: Additionally, we can specify more than one value by separating the values with
    commas; for example, if we needed a method to be executed every Tuesday and Thursday,
    we could annotate the method as `@Schedule(dayOfWeek="Tue, Thu")`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过逗号分隔值来指定多个值；例如，如果我们需要一个方法在每周的星期二和星期四执行，我们可以将方法注解为 `@Schedule(dayOfWeek="Tue,
    Thu")`。
- en: We can also specify a range of values, with the first value and last value separated
    by a dash (-); to execute a method from Monday through Friday, we could use `@Schedule(dayOfWeek="Mon-Fri")`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定一个值的范围，第一个值和最后一个值由破折号（-）分隔；要执行从星期一到星期五的方法，我们可以使用 `@Schedule(dayOfWeek="Mon-Fri")`。
- en: Additionally, we could specify that we need the method to be executed every
    *n* units of time (for example, every day, every 2 hours, every 10 minutes, and
    so on). To do something like this, we could use `@Schedule(hour="*/12")`, which
    would execute the method every 12 hours.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以指定方法需要每 *n* 个时间单位执行（例如，每天、每2小时、每10分钟等）。要执行类似的事情，我们可以使用 `@Schedule(hour="*/12")`，这将使方法每12小时执行一次。
- en: As we can see, the `@Schedule` annotation provides a lot of flexibility when
    it comes to specifying when we need our methods executed. Plus, it provides the
    advantage of not needing a client call to activate the scheduling. Additionally,
    it has the advantage of using a cron-like syntax; therefore, developers familiar
    with this Unix tool will feel right at home using this annotation.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`@Schedule` 注解在指定何时需要执行我们的方法时提供了很多灵活性。此外，它还提供了不需要客户端调用即可激活调度的优势。另外，它还具备使用类似
    cron 的语法的优势；因此，熟悉这个 Unix 工具的开发者在使用这个注解时会感到非常自在。
- en: EJB security
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EJB 安全性
- en: Enterprise JavaBeans allow us to declaratively decide which users can access
    their methods. For example, some methods might only be available to users in certain
    roles. A typical scenario is that only users with the administrator role can add,
    delete, or modify other users in the system.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 企业 JavaBeans 允许我们声明性地决定哪些用户可以访问其方法。例如，某些方法可能仅供具有特定角色的用户使用。一个典型的场景是，只有具有管理员角色的用户可以添加、删除或修改系统中的其他用户。
- en: 'The following example is a slightly modified version of the DAO session bean
    we saw earlier in this chapter. In this version, some methods that were previously
    private are made public. Additionally, the session bean was modified to allow
    only users in certain roles to access its methods:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是本章前面提到的 DAO 会话 bean 的略微修改版本。在这个版本中，一些之前是私有的方法被改为公开。此外，会话 bean 被修改为只允许具有特定角色的用户访问其方法：
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see, we declare what roles have access to the methods by using the
    `@RolesAllowed` annotation. This annotation can take either a single string or
    an array of strings as a parameter. When a single string is used as a parameter
    for this annotation, only users with the role specified by the parameter can access
    the method. If an array of strings is used as a parameter, users with any of the
    roles specified by the array's elements can access the method.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们通过使用 `@RolesAllowed` 注解来声明哪些角色可以访问方法。此注解可以接受单个字符串或字符串数组作为参数。当使用单个字符串作为此注解的参数时，只有具有该参数指定的角色的用户可以访问该方法。如果使用字符串数组作为参数，则具有数组元素中指定的任何角色的用户都可以访问该方法。
- en: The `@RolesAllowed` annotation can be used to decorate an EJB class, in which
    case its values apply to all the methods in the EJB, or to one or more methods;
    in this second case its values apply only to the method the annotation is decorating.
    If, like in our example, both the EJB class and one or more of its methods are
    decorated with the `@RolesAllowed` annotation, the method level annotation takes
    precedence.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `@RolesAllowed` 注解来装饰 EJB 类，在这种情况下，其值适用于 EJB 中的所有方法，或者是一个或多个方法；在后一种情况下，其值仅适用于被注解的方法。如果，像我们的例子一样，EJB
    类及其一个或多个方法都被 `@RolesAllowed` 注解装饰，则方法级别的注解具有优先权。
- en: 'The procedure to create roles varies from application server to application
    server; when using GlassFish, application roles need to be mapped to a security
    realm''s group name (refer to [Chapter 9](31a037d6-63a1-415d-a27f-dbec1ccff2cb.xhtml),
    *Securing Java EE Applications* for details). This mapping, along with what realm
    to use, is set in the `glassfish-ejb-jar.xml` deployment descriptor:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 创建角色的过程因应用服务器而异；当使用 GlassFish 时，应用角色需要映射到安全域的组名（有关详细信息，请参阅第 9 章 [31a037d6-63a1-415d-a27f-dbec1ccff2cb.xhtml]，*Java
    EE 应用程序的安全性*）。此映射以及要使用的域设置在 `glassfish-ejb-jar.xml` 部署描述符中：
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `<security-role-mapping>` element of `glassfish-ejb-jar.xml` does the mapping
    between application roles and the security realm's group. The value of the `<role-name>`
    sub element must contain the application role; this value must match the value
    used in the `@RolesAllowed` annotation. The value of the `<group-name>` sub-element
    must contain the name of the security group in the security realm used by the
    EJB. In the preceding example, we map two application roles to the corresponding
    groups in the security realm. Although in this particular example the name of
    the application role and the security group match, this does not need to be the
    case.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`glassfish-ejb-jar.xml` 的 `<security-role-mapping>` 元素在应用角色和安全域的组之间进行映射。`<role-name>`
    子元素的值必须包含应用角色；此值必须与 `@RolesAllowed` 注解中使用的值匹配。`<group-name>` 子元素的值必须包含 EJB 所使用的安全域中的安全组名称。在上面的示例中，我们将两个应用角色映射到安全域中的相应组。尽管在这个特定的例子中，应用角色和安全组的名称匹配，但这并不一定需要如此。'
- en: 'Automatically matching roles to security groups: When using GlassFish, it is
    possible to automatically match any application roles to identically-named security
    groups in the security realm. This can be accomplished by logging in to the GlassFish
    web console, clicking on the Configuration node, clicking on Security, clicking
    on the checkbox labeled Default Principal To Role Mapping, and finally saving
    this configuration change.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 自动匹配角色到安全组：当使用GlassFish时，可以将任何应用程序角色自动匹配到安全域中同名安全组。这可以通过登录到GlassFish Web控制台，点击配置节点，点击安全，点击标记为默认主体到角色映射的复选框，并最终保存此配置更改来实现。
- en: As can be seen in the example, the security realm to use for authentication
    is defined in the `<realm>` sub-element of the `<as-context>` element. The value
    of this sub-element must match the name of a valid security realm in the application
    server. Other sub-elements of the `<as-context>` element include `<auth-method>;`
    the only valid value for this element is `username_password`, and `<required>`,
    whose only valid values are `true` and `false`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，用于认证的安全域在`<as-context>`元素的`<realm>`子元素中定义。此子元素的值必须与应用服务器中有效安全域的名称匹配。`<as-context>`元素的其它子元素包括`<auth-method>`；此元素的唯一有效值是`username_password`，以及`<required>`，其唯一有效值是`true`和`false`。
- en: Client authentication
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端认证
- en: If the client code accessing a secured EJB is part of a web application whose
    user has already authenticated, then the user's credentials will be used to determine
    whether the user should be allowed to access the method they are trying to execute.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果访问受保护EJB的客户端代码是Web应用程序的一部分，并且该用户已经进行了认证，那么将使用用户的凭据来确定用户是否应该被允许访问他们试图执行的方法。
- en: 'When using GlassFish as our application server, standalone clients must be
    executed through the `appclient` utility. The following code illustrates a typical
    client for the secured session bean:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用GlassFish作为我们的应用服务器时，独立客户端必须通过`appclient`实用程序执行。以下代码演示了一个典型的安全会话Bean客户端：
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As we can see, the code does nothing to authenticate the user. The session
    bean is simply injected into the code via the `@EJB` annotation and it is used
    as usual. How this is handled varies depending on what application server we are
    using. GlassFish''s `appclient` utility takes care of authenticating the user,
    after invoking the client code via the `appclient` utility:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，代码并没有对用户进行认证。会话Bean只是通过`@EJB`注解注入到代码中，并像往常一样使用。这种处理方式取决于我们使用的是哪种应用服务器。GlassFish的`appclient`实用程序在通过`appclient`实用程序调用客户端代码后负责用户认证：
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `appclient` utility will present the user with a login window when it attempts
    to invoke a secure method on the EJB:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当`appclient`实用程序尝试在EJB上调用安全方法时，它将向用户显示登录窗口：
- en: '![](img/ded62140-eecf-4f97-a13a-11fdf832ee38.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ded62140-eecf-4f97-a13a-11fdf832ee38.png)'
- en: 'Assuming the credentials are correct and that the user has the appropriate
    permissions, the EJB code will execute and we should see the expected output from
    the preceding `Client` class:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 假设凭据正确且用户具有适当的权限，EJB代码将执行，我们应该看到来自前面`Client`类的预期输出：
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to implement business logic via stateless and
    stateful session beans. Additionally, we covered how to implement message-driven
    beans to consume JMS messages.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何通过无状态和有状态会话Bean实现业务逻辑。此外，我们还介绍了如何实现消息驱动Bean以消费JMS消息。
- en: We also explained how to take advantage of the transactional nature of EJBs
    to simplify implementing the DAO pattern.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还解释了如何利用EJB的事务性来简化实现DAO模式。
- en: Additionally, we explained the concept of container-managed transactions, and
    how to control them by using the appropriate annotations. We also explained how
    to implement bean-managed transactions, for cases in which container-managed transactions
    are not enough to satisfy our requirements.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们解释了容器管理事务的概念，以及如何通过使用适当的注解来控制它们。我们还解释了如何在容器管理事务不足以满足我们要求的情况下实现Bean管理事务。
- en: Life cycles for the different types of Enterprise JavaBean were covered, including
    an explanation on how to have EJB methods automatically invoked by the EJB container
    at certain points in the life cycle.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍了不同类型的企业JavaBean的生命周期，包括如何让EJB容器在生命周期中的特定点自动调用EJB方法。
- en: We also covered how to have EJB methods invoked periodically by the EJB container
    by taking advantage of the EJB timer service.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了如何利用 EJB 定时器服务，让 EJB 方法被 EJB 容器定期调用。
- en: Finally, we looked at how to make sure EJB methods are only invoked by authorized
    users by annotating EJB classes and/or methods with the appropriate EJB security
    annotations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了如何通过在 EJB 类和/或方法上添加适当的 EJB 安全注解，确保 EJB 方法只被授权用户调用。
