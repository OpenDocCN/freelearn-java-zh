- en: Chapter 5. Testing Your Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the chapters so far, we bootstrapped our application using Activator, developed
    our web application using Scala and the Play framework, and added a Reactive microservice
    call using RxScala for data flow computations. Now we will go ahead and enter
    the unit test and controller testing using the BDD and Play framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Scala applications with JUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavior-driven development principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with ScalaTest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Play framework applications with ScalaTest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tests in Activator / SBT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The need for `testingTest` is a fundamental and very important part of software
    development. Without tests, we cannot be sure that our code works. We should perform
    tests on almost all the code we produce. There are things that don't make sense
    for testing, for instance, case classes and classes that just represent structural
    objects, or, in other words, classes without functions. If you have code that
    applies computations, transformations, and validations, you definitely want to
    test this code with a good code coverage, which refers to features or any important
    code that is not just structural.
  prefs: []
  type: TYPE_NORMAL
- en: Test coverage is important, because it allows us to do refactoring (improve
    application code quality by reducing code, creating generic code, or even deleting
    code) with trust. This is because, if you have tests and if you do something wrong
    by accident, your tests will let you know. This is all about having short cycles
    of feedback. The earlier the better; you want to know if you have introduced bugs
    as soon, and as close to development, as possible. Nobody likes to discover bugs
    that could be caught by a simple test in production.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is the smallest unit of testing that you could possibly apply.
    You need to apply it at the class level. So a unit test will cover your class
    with all the functions you have there. But hold on a minute, a class often has
    dependencies, and these dependencies might have other dependencies, so how do
    you test that? We need to have mocks, simple dumb objects that simulate other
    classes' behavior. This is an important technique to isolate code and allow unit
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: Making code testable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unit testing is simple: basically, we call a function by passing arguments
    to it, and then we check the output to see if it matches our expectations. This
    is also called asserts or assertions. So, unit testing is about asserts. Sometimes,
    your code might not be testable. For instance, let''s say you have a function
    that returns a unit and has no parameters. This is very tough to test, because
    it implies that the function is full of side-effects. If you remember what we
    discussed in [Chapter 1](part0015.xhtml#aid-E9OE1 "Chapter 1. Introduction to
    FP, Reactive, and Scala"), *Introduction to FP, Reactive, and Scala*, this is
    against FP principles. So, if we have this case, we need to refactor the code
    to make the function return something, and then we can test it.'
  prefs: []
  type: TYPE_NORMAL
- en: Isolation and self-contained tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit tests should be self-contained, which means that a unit test's classes
    should not depend on any particular order of execution. Let's say you have a unit
    test class with two test functions. So, each test should test just one function
    at a time, and both functions should be able to run in any order whatsoever. Otherwise,
    the tests will be fragile and hard to maintain in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Effective naming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Effective naming is essential. The test function needs to say exactly what
    the test does. This is important because, when the test fails, it is easier to
    figure out what went wrong and why. Following the same idea, when you do assertions,
    you should assert just one thing at a time. Imagine that you need to test whether
    a web service returns a valid JSON. This particular JSON could have two fields:
    first name and last name. So, you will make one assert for the name and an other
    for the last name. This way, it will be easier to understand what the test does,
    and to troubleshoot when the test fails.'
  prefs: []
  type: TYPE_NORMAL
- en: Levels of testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we run tests, we often do it in layers. Unit testing is the basic level;
    however, there are other levels such as controller tests, integration tests, UI
    tests, End-to-End tests, stress tests, and so many others. For this book, we will
    cover unit tests, controller tests, and UI tests using Junit and `ScalaTest`,Play's
    framework support.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with Junit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you come from a Java background, it is highly possible that you have already
    worked with Junit. It's possible to test with Junit using the Scala and Play framework.
    However, this is not the best practice when we are creating applications with
    the Play framework, since it favors **Behavior Driven Development** (**BDD**)
    testing with Scala Spec. For this chapter, we will cover how to perform all sorts
    of test using BDD and Play. Right now, let's take a look at how we can do unit
    testing with Junit before we move to BDD.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So what we have in the preceding code is a class that extends `PlaySpec`, and
    adds a trait called `AssertionForJunit`. Why don't we have the classical Junit
    class here? Because the Play framework is set up to run Scala tests, so this bridge
    allows us to run Junit by `ScalaTest` Play framework constructs.
  prefs: []
  type: TYPE_NORMAL
- en: Then we have a test function called `testBaseServer` , which uses the `@Test`
    annotation from JUnit. Inside the test method, we create an instance of `ProductService`,
    and then we call the function `findAll`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have assertions that will check if the result is what we are expecting.
    So we don't have products, because we did not insert them earlier. Hence, we expect
    to have `None` as the response, and the result should also not be `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run this in your console using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the result shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing with Junit](img/image00273.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, our test was executed without any issues. It''s also possible
    to run this test and a normal test in Junit using the Eclipse IDE. You just right-click
    on the file and select  ****Run As: Scala Junit Test**;** refer to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing with Junit](img/image00274.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Behavior-Driven Development - BDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Behavior-Driven Development** (**BDD**) is an agile development technique,
    that focuses on the engagement between developers and non-technical people such
    as product owners from the business. The idea is pretty simple: use the same language
    as the business uses in order to extract the reason why the code you are building
    exists in the first place. BDD ends up minimizing the translation between tech
    language and business language, creating more synergy and less noise between information
    technology and business.'
  prefs: []
  type: TYPE_NORMAL
- en: BDD tests describe what the application needs to do, and how it behaves. It's
    very common to write down these tests using pair programing between business people
    and developers. `ScalaTest` is a BDD framework. Play framework has a great integration
    with `ScalaTest`. Let's get started with `ScalaTest` and Play right now.
  prefs: []
  type: TYPE_NORMAL
- en: MyFirstPlaySpec.scala - First BDD with ScalaTest and the Play framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `MyFirstPlaySpec.scala` class should contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'So, you create a class called `MyFirstPlaySpec`, and we extend it from `PlaySpec`
    in order to get Play framework `ScalaTest` support. Then we create two functions
    to test the sum of two numbers. In the first test, `1 +1` should be `2`, and in
    the second, `-1 + 1` should be `0`. When we execute `mustBe`, it is the same thing
    as doing an assert in Junit. The main difference here is that the test has behavior
    explicitly on the Spec. Now we can run the test by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MyFirstPlaySpec.scala - First BDD with ScalaTest and the Play framework](img/image00275.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Testing with Play framework support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will continue building our application. Let's add BDD tests in our application.
    We will start doing tests for your services. We have to test `ProductService`,
    `ImageService`, and `ReviewService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `ProductServiceTestSpec.scala file` should contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For this test, we are testing all public functions available in `ProductService`.
    The tests are pretty straightforward: we call a specific service operation, such
    as `findById`, and then we check the result to make sure that all the data that
    is supposed to be there is present.'
  prefs: []
  type: TYPE_NORMAL
- en: There are scenarios where the service should return an exception, for instance,
    if you try to remove something that does not exist. If you take a look at the
    last test function called `"not remove because does not exist"`, we should get
    an exception. However, there is a bug in the service code. Run the tests, and
    then you will see it.
  prefs: []
  type: TYPE_NORMAL
- en: ProductService.scala - FIX the code issue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'That''s the great thing about tests: they show issues in our code so that we
    can fix them before the code goes to production and affects the user experience.
    To fix the last test, we need to go to the `ProductService` class and fix a method.
    This is how we fix it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: All set now, everything is okay. The Play framework supports testing for expected
    exceptions using the intercept function to pass the expected exception, Let's
    run the test in the console using the `activator` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing this command, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ProductService.scala - FIX the code issue](img/image00276.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: ImageServiceTestSpec.scala - ImageService Test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alright, Now we can add tests for `ImageService` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So these are the BDD tests for `ImageService`. We have covered all the available
    functions on the service. Like in the `ProductService` class, we also have tests
    for unfortunate scenarios where we expect exceptions to happen.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we need to call more than one function to test a specific function
    or a specific test case. For example, in `"remove 1 image"`, we first delete an
    image. Our test case checks for an image that does not exist. Let's run the tests
    on the Activator console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following result will be obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ImageServiceTestSpec.scala - ImageService Test](img/image00277.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: ReviewServiceTestSpec.scala - ReviewService test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we need add tests for the review service. Here we go.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Alright, we have tests for the review service. We can run them now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ReviewServiceTestSpec.scala - ReviewService test](img/image00278.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Testing routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Play framework allows us to test routes as well. This is good, because as
    our application grows and we refactor the code, we can be 100% sure that our routes
    are functioning. Route testing could be easily confused with controller testing.
    The main difference is that, with routing testing, we should test if we are able
    to reach the routes and that's it. After route testing, we will cover controller
    testing in detail.
  prefs: []
  type: TYPE_NORMAL
- en: RoutesTestingSpec.scala - Play framework route testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your `RoutesTestingSpec.scala` file should contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So here we have tests for all our main controllers, which are root, product,
    review, and image. `RootController` is the controller of the main page when you
    visit `http://localhost:9000`.
  prefs: []
  type: TYPE_NORMAL
- en: There is a special helper function called `route` in the Play framework, which
    helps us to test routes. Then we use `FakeRequest` pass the path to the route.
    It's possible to test the status code and content type of the page to which the
    router routed our request.
  prefs: []
  type: TYPE_NORMAL
- en: For product, image, and review controllers, you can see we are trying to call
    an item that does not exist. That's why we have the try...catch, because we expect
    to have an exception happening there.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this preceding command produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![RoutesTestingSpec.scala - Play framework route testing](img/image00279.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Controller testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We did unit tests, we did route tests, and now is the time to add controller
    tests. Controller tests are similar to routes tests, but they are not the same.
    For instance, our controller always respond to UI pages, so we expected to create
    specific HTML pages based on each method. The Play framework has integration with
    Selenium, which is a testing framework for UIs, and a controllers that allows
    you to simulate web browsers, and you can do pretty much the same as you would
    by clicking on the pages like a real user.
  prefs: []
  type: TYPE_NORMAL
- en: So let's get started. First, we will start with `RndDoubleGeneratorControllerTestSpec`.
  prefs: []
  type: TYPE_NORMAL
- en: RndDoubleGeneratorControllerTestSpec.scala - RndDoubleGeneratorController tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `RndDoubleGeneratorControllerTestSpec.scala` file should contain the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This class has some interesting things. For instance, we inject `WSClient` using
    Google Guice with `GuiceApplicationBuilder`. Secondly, we assume that the `ng-microservice` 
    we created in the previous chapter is down, so we can predict the response coming
    from the fallback.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the controller using `WSClient`, and then we map the response to return
    the body content as a string. So this will be an Async Future, and in order to
    get the result, we use `Await` to wait five seconds for the response to come back.
    Once the response is back, we make sure the result is 2.3\. If the result does
    not come back in 15s, the test will fail. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you will see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![RndDoubleGeneratorControllerTestSpec.scala - RndDoubleGeneratorController
    tests](img/image00280.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: All right, now we have a controller test fully working using Guice injections
    and the `WSClient` Play framework library. Let's now make controller tests for
    the product, image, and review controllers.
  prefs: []
  type: TYPE_NORMAL
- en: IntegrationSpec.scala
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can test our main page to check if it is okay. This is a very simple test,
    and gets you ready for the next tests. So, here we go.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This test is very easy. We just call the main page, and we check if it contains
    the text `Welcome to Reactive WebStore`. Let's run it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The result after running this test is shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![IntegrationSpec.scala](img/image00281.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: ProductControllerTestSpec.scala
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will look at the product controller test spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So, for the product controller, we simulate a web browser using Selenium Play's
    framework support. We test basic controller functionality such as inserting a
    new product, details for a specific product, and updating and removing a product.
  prefs: []
  type: TYPE_NORMAL
- en: For insert, we go to the new product form using `goTo`. We use `$port` as a
    variable. We do this because the Play framework will boot up the application for
    us, but we don't know in which port. So we need to use this variable in order
    to get to the product controller.
  prefs: []
  type: TYPE_NORMAL
- en: Then we click on each text field using the `click` function, and we enter values
    using the `enter` function. After filling in the whole form, we submit it using
    the `submit` function.
  prefs: []
  type: TYPE_NORMAL
- en: For details, we just go to the product details page, and we check if the text
    fields have the values that we are expecting. We do that using the `textField.value`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: In order to check the product update function, we need to first update the product
    definition, and then go to details to see if the values we changed are there.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we test the `delete` function. For this function, we need to click
    on a button. We need to set the ID of the button in order to have this working.
    We need to do a small refactoring in our UI to have the ID there.
  prefs: []
  type: TYPE_NORMAL
- en: product_index.scala.html
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your `product_index.scala.html` file should contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: All set. Now we can run our tests on Activators using the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This preceding command shows the result in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![product_index.scala.html](img/image00282.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Since this test runs the application for real and calls the controller simulating
    the web browser, this test could take some time. Now it's time to move to the
    `ImageController` tests.
  prefs: []
  type: TYPE_NORMAL
- en: ImageControllerTestSpec.scala
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your `product_index.scala.html` should contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we need to go to the product controller to insert a product; otherwise,
    we cannot do image operations, since they all need a product ID.
  prefs: []
  type: TYPE_NORMAL
- en: image_index.scala.html
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your `image_index.scala.html` file should contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: All set. Now we can run the `ImageController` tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image_index.scala.html](img/image00283.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '`ImageController` has passed all its tests. Now we will move to the `ReviewController`
    tests.'
  prefs: []
  type: TYPE_NORMAL
- en: ReviewControllerTestSpec.scala
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your `ReviewControllerTestSpec.scala` file should contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we need to go to the product controller to insert a product; otherwise,
    we cannot do image operations, since they all need a product ID.
  prefs: []
  type: TYPE_NORMAL
- en: For insert, we go to the new product form using goto. We use `$port` as a variable.
    We do this because the Play framework will boot up the application for us, but
    we don't know on which port, so we need to use this variable in order to get to
    the product controller.
  prefs: []
  type: TYPE_NORMAL
- en: Then we click on each text field using the `click` function, and we enter values
    using the `enter` function. After filling in the whole form, we submit it using
    the `submit` function.
  prefs: []
  type: TYPE_NORMAL
- en: For details, we just go to the product details page and check if the text fields
    have the values that we expect. We do that using the `textField.value` function.
  prefs: []
  type: TYPE_NORMAL
- en: In order to check the product update function, we need to first update the product
    definition, and then go to the details to see if the values we changed are there.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we test the `delete` function. For this function, we need to click
    on a button. We need to set the ID of the button in order to have this working.
    Then we do a small refactoring in our UI to have the ID there.
  prefs: []
  type: TYPE_NORMAL
- en: review_index.scala.html
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your `review_index.scala.html` file should contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can run the tests on the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The test will show the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![review_index.scala.html](img/image00284.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Alright, `ReviewController` has passed all our tests.
  prefs: []
  type: TYPE_NORMAL
- en: It's a very good practice to have the tests separated by type. However, if you
    want, you could mix all the tests such as unit testing, controller testing, and
    route testing in one single file.
  prefs: []
  type: TYPE_NORMAL
- en: ApplicationSpec.scala
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your `ApplicationSpec.scala` should have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We can run these mixed tests, and they will all pass.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ApplicationSpec.scala](img/image00285.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: OK, we are almost done. We just need to add some tests for the microservice
    called `ng-microservice` , which we created in [Chapter 4](part0060.xhtml#aid-1P71O2
    "Chapter 4. Developing Reactive Backing Services"), *Developing Reactive Backing
    Services*.
  prefs: []
  type: TYPE_NORMAL
- en: NGServiceImplTestSpec.scala
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your NGServiceImplTestSpec.scala file should have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: So here, in the preceding code, we have two methods to test the two operations
    that we have in our microservice. First we generate one double, and then we ask
    for a list of three doubles. As you can see, we just check if we get a positive
    double back from the service, and that's it. Since the result is not predictable,
    this is a good way to test it. Sometimes, even when the result is predictable,
    you want tests like this. Why? Because it makes the tests more reliable, and often,
    when we use too many hardcore values. The values could be changing and breaking
    our tests, and that's not cool. Let's run it on the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result that we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![NGServiceImplTestSpec.scala](img/image00286.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now let's move on to the controller, and do some controller testing.
  prefs: []
  type: TYPE_NORMAL
- en: NGServiceEndpointControllerTest.scala
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your `NGServiceEndpointControllerTest.scala` file should contain the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here we have to inject the `WSClient` library so we can call the controller.
    This controller has two methods like the service we tested before. The second
    method returns a JSON structure. Then we check for `"["and "]"` to make sure that
    the array is present, since this is a list of three numbers.
  prefs: []
  type: TYPE_NORMAL
- en: We use the assert function to check the response from the controller, and to
    be 100% sure that everything is okay. Let's run it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the following screenshot to see the test result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![NGServiceEndpointControllerTest.scala](img/image00287.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Great! We have covered pretty much everything .
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we ran all kinds of tests. We always used the command `$ activator
    "test-only xxx"`; the reason for this is to save time. However, it is very common
    to run all tests. You can do that in both projects; we have to just type `$ activator
    test`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running all the tests in the `ng-microservice` project, we get the result
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![NGServiceEndpointControllerTest.scala](img/image00288.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the other hand, running all the tests in the `ReactiveWebStore` project
    gives the result shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![NGServiceEndpointControllerTest.scala](img/image00289.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to do tests. We added several tests for your
    Scala and Play framework projects. You also learned about unit testing principles,
    testing Scala applications with JUnit, BDD principles, testing with `ScalaTest`,
    testing Play framework applications with `ScalaTest`, and running tests in Activator
    / SBT.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn more about persistence using Slick, which
    is reactive. We will also change our tests a little bit in order to work with
    a database.
  prefs: []
  type: TYPE_NORMAL
