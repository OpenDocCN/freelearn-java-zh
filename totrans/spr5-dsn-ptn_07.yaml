- en: Accessing a Database with Spring and JDBC Template Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In earlier chapters, you learned about Spring core modules like the Spring IoC
    container, the DI pattern, container life cycle, and the used design patterns.
    Also you have seen how Spring makes magic using AOP. Now is the right time to
    move into the battlefield of real Spring applications with persisting data. Do
    you remember your first application during college days where you dealt with database
    access? That time, you probably, had to write boring boilerplate code to load
    database drivers, initialize your data-access framework, open connections, handle
    various exceptions, and to close connections. You also had to be very careful
    about that code. If anything went wrong, you would not have been able to make
    a database connection in your application, even though you would've invested a
    lot of time in such boring code, apart from writing the actual SQL and business
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Because we always try to make things better and simpler, we have to focus on
    the solution to that tedious work for data-access. Spring comes with a solution
    for the tedious and boring work for data-access--it removes the code of data access.
    Spring provides data-access frameworks to integrate with a variety of data-access
    technologies. It allows you to use either JDBC directly or any **object-relational
    mapping** (**ORM**) framework, like Hibernate, to persist your data. Spring handles
    all the low-level code for data access work in your application; you can just
    write your SQL, application logic, and manage your application's data rather than
    investing time in writing code for making and closing database connections, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can choose any technology, such as JDBC, Hibernate, the **Java Persistence
    API** (**JPA**), or others. to persist your application''s data. Irrespective
    of what you choose, Spring provides support for all these technologies for your
    application. In this chapter, we will explore Spring''s support for JDBC. It will
    cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: The best approach to designing your data access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the template design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problems with the traditional JDBC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving problems with the Spring `JdbcTemplate`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the data source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the object pool design pattern to maintain database connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstracting database access by the DAO pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with `JdbcTemplate`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Jdbc callback interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for configuring `JdbcTemplate` in the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we go on to discuss more about JDBC and the template design pattern,
    let's first see the best approach to define the data-access tier in the layered
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The best approach to designing your data-access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous chapters, you have seen that one of Spring''s goals is to allow
    you to develop applications by following one of the OOPs principles of coding
    to interfaces. Any enterprise application needs to read data and write data to
    any kind of database, and to meet this requirement, we have to write the persistence
    logic. Spring allows you to avoid the scattering of persistence logic across all
    the modules in your application. For this, we can create a different component
    for data access and persistence logic, and this component is known as a **data
    access object** (**DAO**). Let''s see, in the following diagram, the best approach
    to create modules in layered applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e991c260-af90-4b2f-8686-622410d96461.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding diagram, for a better approach, many enterprise
    applications consist of the following three logical layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The service layer** (or application layer): This layer of the application
    exposes high-level application functions like use-cases and business logic. All
    application services are defined here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The data access layer**: This layer of the application defines an interface
    to the application''s data repository (such as a Relational or NoSQL database).
    This layer has the classes and interfaces which have the data-access logic''s
    data persisting in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The infrastructure layer**: This layer of the application exposes low-level
    services to the other layers, such as configuring DataSource by using the database
    URL, user credentials, and so on. Such configuration comes under this layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the previous figure, you can see that the **Service Layer** collaborates
    with the **Data Access Layer**. To avoid coupling between the application logic
    and data-access logic, we should expose their functionality through interfaces,
    as interfaces promote decoupling between the collaborating components. If we use
    the data-access logic by implementing interfaces, we can configure any particular
    data-access strategy to the application without making any changes in the application
    logic in the **Service Layer**. The following diagram shows the proper approach
    to designing our data-access layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44d71d81-d448-4266-ad80-3c19a09c6b64.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding figure, your application service objects, that is,
    **TransferService**, don't handle their own data access. Instead, they delegate
    data access to the repositories. The repository's interface, that is, **AccountRepository**
    in your application, keeps it loosely coupled to the service object. You could
    configure any variant of the implementations-either the Jpa implementation of
    **AccountRepository** (**JpaAccountRepository**), or the Jdbc implementation of
    **AccountRepository** (**JdbcAccountRepository**).
  prefs: []
  type: TYPE_NORMAL
- en: Spring not only provides loose coupling between the application components working
    at the different layers in the layered architecture, but also helps to manage
    the resources in the enterprise layered architecture application. Let's see how
    Spring manages the resources, and what design pattern is using by Spring to solve
    the resource management problem.
  prefs: []
  type: TYPE_NORMAL
- en: The resource management problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's understand the resource management problem with the help of a real example.
    You must've ordered pizza online sometime. If so, what are the steps involved
    in the process, from the time of ordering the pizza till its delivery? There are
    many steps to this process--We first go to the online portal of the pizza company,
    select the size of the pizza and the toppings. After that, we place our order
    and check out. The order is accepted by the nearest pizza shop; they prepare our
    pizza accordingly, put the toppings on accordingly, wrap this pizza in the bag,
    the delivery boy comes to your place and hands over the pizza to you, and, finally,
    you enjoy your pizza with your friend. Even though there are many steps to this
    process, you're actively involved in only a couple of them. The pizza company
    is responsible for cooking the pizza and delivering it smoothly. You are involved
    only when you need to be, and other steps are taken care of by the pizza company.
    As you saw in this example, there are many steps involved in managing this process,
    and we also have to assign the resources to each step accordingly such that it
    is treated as a complete task without any break in the flow. This is a perfect
    scenario for a powerful design pattern, the template method pattern. The Spring
    framework implements this template design pattern to handle such type scenarios
    in the DAO layer of an application. Let's see what problems we face if we don't
    use Spring, and work with the traditional application instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a traditional application, we work with the JDBC API to access the data
    from the database. It is a simple application where we access and persist the
    data using the JDBC API, and for this application, the following steps are required:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the connection parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access a data source, and establish a connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Begin a transaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the SQL statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare the parameters, and provide parameter values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare and execute the statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the loop to iterate through the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do the work for each iteration--execute the business logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Process any exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit or roll back the transaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the connection, statement, and resultset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you use the Spring Framework for the same application, then you have to write
    the code for some steps of the preceding list of steps, while spring takes care
    of all the steps involving the low-level processes such as establishing a connection,
    beginning a transaction, processing any exception in the data layer, and closing
    the connection. Spring manages these steps by using the Template method design
    pattern, which we'll study in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the template design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Define the skeleton of an algorithm in an operation, deferring some steps to
    subclasses. Template Method lets subclasses redefine certain steps of an algorithm
    without changing the algorithm's structure.
  prefs: []
  type: TYPE_NORMAL
- en: -GOF Design Pattern
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the Template method design pattern in [Chapter 3](bd05acbb-a42a-4070-9e01-54a8ce049e41.xhtml),
    *Consideration of Structural and Behavioral Patterns*. It is widely used, and
    comes under the structural design pattern of the GOF design pattern family. This
    pattern defines the outline or skeleton of an algorithm, and leaves the details
    to specific implementations later. This pattern hides away large amounts of boilerplate
    code. Spring provides many template classes, such as `JdbcTemplate`, `JmsTemplate`,
    `RestTemplate`, and `WebServiceTemplate`. Mostly, this pattern hides the low-level
    resource management as discussed earlier in the pizza example.
  prefs: []
  type: TYPE_NORMAL
- en: In the example, the process is ordering a pizza for home delivery from an online
    portal. The process followed by the pizza company has some fixed steps for each
    customer, like taking the order, preparing the pizza, adding the toppings according
    to the customer's specifications, and delivering it to the customer's address.
    We can add these steps, or define these steps to a specific algorithm. The system
    can then implement this algorithm accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring implements this pattern to access data from a database. In a database,
    or any other technology, there are some steps that are always common, such as
    establishing a connection to the database, handling transactions, handling exceptions,
    and some clean up actions which are required for each data access process. But
    there are also some steps which are not fixed, but depend on the application''s
    requirement. It is the responsibility of the developer to define these steps.
    But spring allows us to separate the fixed and dynamic parts of the data-access
    process into different parts as templates and callbacks. All fixed steps come
    under the template, and dynamic custom steps come under callbacks. The following
    figure describes the two in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8047e98e-4603-4f21-b4f4-a0d9b28f703c.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding figure, all the fixed parts of the process for
    data access wraps to the template classes of the Spring Framework as open and
    close connection, open and close statements, handling exceptions, and managing
    resources. But the other steps like writing SQLs, declaring connection parameters,
    and so on are parts of the callbacks, and callbacks are handled by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides several implementations of the Template method design pattern
    such as `JdbcTemplate`, `JmsTemplate`, `RestTemplate`, and `WebServiceTemplate`,
    but in this chapter, I will explain only its implementation for the JDBC API as
    `JdbcTemplate`. There is another variant of `JdbcTemplate-NamedParameterJdbcTemplate`,
    which wraps a `JdbcTemplate` to provide named parameters instead of the traditional
    JDBC "`?`" placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with the traditional JDBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the problems we have to face whenever we work with the traditional
    JDBC API:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Redundant results due to error-prone code**: The traditional JDBC API required
    a lot of tedious code to work with the data access layer. Let''s see the following
    code to connect the Database and execute the desired query:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, there are some lines which are highlighted;
    only this bold code matters-the rest is boilerplate. Also, this code handles the
    SQLException in the application inefficiently, because the developer doesn't know
    what should be handled there. Let's now look at another problem in the traditional
    JDBC code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Leads to poor exception handling**: In the preceding code, the exceptions
    in the application are handled very poorly. The developers are not aware of what
    exceptions are to be handled here. SQLException is a checked Exception, which
    means it forces the developers to handle errors, but if you can''t handle it,
    you must declare it. It is a very bad way of handling exceptions, and the intermediate
    methods must declare exception(s) from all methods in the code. It is a form of
    tight coupling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving problems with Spring's JdbcTemplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring''s `JdbcTemplate` solves both the problems listed in the last section.
    `JdbcTemplate` greatly simplifies the use of the JDBC API, and it eliminates repetitive
    boilerplate code. It alleviates the common causes of bugs, and handles SQLExceptions
    properly without sacrificing power. It provides full access to the standard JDBC
    constructs. Let''s see the same code using Spring''s `JdbcTemplate` class to solve
    these two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Removing redundant code from the application using JdbcTemplate**: Suppose
    you want a count of the accounts in a bank. The following code is required if
    you use the `JdbcTemplate` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to access the list of accounts for a particular user ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, you don't need to write the code for Open
    and Close database connection, for preparing a statement to execute query, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Access Exceptions**: Spring provides a consistent exception hierarchy
    to handle technology-specific exceptions like SQLException to its own exception
    class hierarchy with `DataAccessException` as the root exception. Spring wraps
    these original exceptions into different unchecked exceptions. Now Spring does
    not force the developers to handle these exceptions at development time. Spring
    provides the `DataAccessException` hierarchy to hide whether you are using JPA,
    Hibernate, JDBC, or similar. Actually, it is a hierarchy of sub-exceptions, and
    not just one exception for everything. It is consistent across all the supported
    data access technologies. The following diagram depicts the Spring Data Access
    Exception hierarchy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/a72f4691-be06-4a91-a90b-61638a59fd99.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding figure, Spring's `DataAccessException` extends
    the `RuntimeException`, that is, it is an unchecked exception. In an enterprise
    application, unchecked exceptions can be thrown up the call hierarchy to the best
    place to handle it. The good thing is that the methods in between don't know about
    it in the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's first discuss how to configure Spring with a data source to be able to
    connect the database, before declaring the templates and repositories in a Spring
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the data source and object pool pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Spring Framework, DataSource is part of the JDBC API, and it provides
    a connection to the database. It hides many boilerplate codes for connection pooling,
    exception handling, and transaction management issues from the application code.
    As a developer, you let it focus on your business logic only. Don't worry about
    connection pooling, exception handling, and managing transactions; it is the responsibility
    of the application administrators how they set up the container managed data source
    in production. You just write the code, and test that code.
  prefs: []
  type: TYPE_NORMAL
- en: In an enterprise application, we can retrieve DataSource in several ways. We
    can use the JDBC driver to retrieve DataSource, but it is not the best approach
    to create DataSource in the production environment. As performance is one of the
    key issues during application development, Spring implements the object pool pattern
    to provide DataSource to the application in a very efficient way. The object pool
    pattern says that *creation of objects is expensive rather than reuse.*
  prefs: []
  type: TYPE_NORMAL
- en: Spring allows us to implement the object pool pattern for reusing the DataSource
    object in the application. You can use either the application server and container-managed
    pool (JNDI), or you can create a container by using third-party libraries such
    as DBCP, c3p0, and so on. These pools help to manage the available data sources
    in a better way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your Spring application, there are several options to configure the data-source
    beans, and they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring data source using a JDBC driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the object pool design pattern to provide data source objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the data source using JNDI
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the data source using pool connections
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Builder pattern to create an embedded data source
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see how to configure a data-source bean in a Spring application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring a data source using a JDBC driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using a JDBC driver to configure a data-source bean is the simplest data source
    in Spring. The three data source classes provided by Spring are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DriverManagerDataSource`: It always creates a new connection for every connection
    request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SimpleDriverDataSource`: It is similar to the `DriverManagerDataSource` except
    that it works with the JDBC driver directly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SingleConnectionDataSource`: It returns the same connection for every connection
    request, but it is not a pooled data source'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the following code for configuring a data source bean using the
    `DriverManagerDataSource` class of Spring in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java-based configuration, the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In XML-based configuration, the code will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The data source defined in the preceding code is a very simple data source,
    and we can use it in the development environment. It is not a suitable data source
    for production. I, personally, prefer to use JNDI to configure the data source
    for the production environment. Let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: Let's implement the object pool design pattern to provide data source objects
    *by* configuring the data source *using* JNDI.
  prefs: []
  type: TYPE_NORMAL
- en: In a Spring application, you can configure a data source by using the JNDI lookup.
    Spring provides the `<jee:jndi-lookup>` element from Spring's JEE namespace. Let's
    see the code for this configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In XML configuration, the code is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In Java configuration, the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Application servers like WebSphere or JBoss allow you to configure data sources
    to be prepared via JNDI. Even a web container like Tomcat allows you to configure
    data sources to be prepared via JNDI. These servers manage the data sources in
    your application. It is beneficial, because the performance of the data source
    will be greater, as the application servers are often pooled. And they can be
    managed completely external to the application. This is one of the best ways to
    configure a data source to be retrieved via JNDI. If you are not able to retrieve
    through the JNDI lookup in production, you can choose another, better option,
    which we'll discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the data source using pool connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following open-sources technologies provide pooled data sources:'
  prefs: []
  type: TYPE_NORMAL
- en: Apache commons DBCP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: c3p0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BoneCP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following code configures DBCP's `BasicDataSource`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The XML-based DBCP configuration is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The Java-based DBCP configuration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, there are many other properties which
    are introduced for a pooled data sources provider. The properties of the `BasicDataSource`
    class in Spring are listed next:'
  prefs: []
  type: TYPE_NORMAL
- en: '`initialSize`: This is the number of connections created at the time of initialization
    of the pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxActive`: This is the maximum number of connections that can be allocated
    from the pool at the time of initialization of the pool. If you set this value
    to 0, that means there''s no limit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxIdle`: This is the maximum number of connections that can be idle in the
    pool without extras being released. If you set this value to 0, that means there''s
    no limit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxOpenPreparedStatements`: This is the maximum number of prepared statements
    that can be allocated from the statement pool at the time of initialization of
    the pool. If you set this value to `0`, that means there''s no limit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxWait`: This is the maximum waiting time for a connection to be returned
    to the pool before an exception is thrown. If you set it to 1, it means wait indefinitely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minEvictableIdleTimeMillis`: This is the maximum time duration a connection
    can remain idle in the pool before it''s eligible for eviction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minIdle`: This is the minimum number of connections that can remain idle in
    the pool without new connections being created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Builder pattern to create an embedded data source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In application development, the embedded database is very useful, because it
    doesn''t require a separate database server that your application connects. Spring
    provides one more data source for embedded databases. It is not powerful enough
    for the production environment. We can use the embedded data source for the development
    and testing environment. In Spring, the `jdbc` namespace configures an embedded
    database, `H2`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In XML configuration, `H2` is configured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In Java configuration, `H2` is configured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, Spring provides the `EmbeddedDatabaseBuilder`
    class. It actually implements the Builder design pattern to create the object
    of the `EmbeddedDatabaseBuilder` class.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see one more design pattern in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting database access using the DAO pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data access layer works as an aspect between the business layer and the
    database. Data accessing depends on the business call, and it varies depending
    on the source of the data for example database, flat files, XML, and so on. So,
    we can abstract all access by providing an interface. This is known as the data
    access object pattern. From the application's point of view, it makes no difference
    when it accesses a relational database or parses XML files using a DAO.
  prefs: []
  type: TYPE_NORMAL
- en: In an earlier version, EJB provided entity beans managed by the container; they
    were distributed, secure, and transactional components. These beans were very
    transparent to the client, that is, for the service layer in the application,
    they had automatic persistence without the care of underlying database. But mostly,
    the features offered by these entity beans were not required for your application,
    as you needed to persist data to the database. Due to *this,* some non-required
    features of the entity beans, like network traffic, increased, and your application's
    performance was impacted. And that time, the entity beans needed to run inside
    the EJB containers, which is why it was very difficult to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, if you are working with the traditional JDBC API or earlier
    EJB versions, you will face the following problems in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: In a traditional JDBC application, you merge the business tier logic with persistence
    logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Persistence tier or DAO layer is not consistent for the service layer or
    business tier. But DAO should be consistent for the service layer in an enterprise
    application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a traditional JDBC application, you have to handle a lot of boilerplate code
    like making and closing connection, preparing statement, handling exceptions,
    and so on. It degrades reusability and increases development time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With EJB, the entity bean was created *as* an overhead to the application, and
    was difficult to test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see how spring solves these problems.
  prefs: []
  type: TYPE_NORMAL
- en: The DAO pattern with the Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring provides a comprehensive JDBC module to design and develop JDBC-based
    DAOs. These DAOs in the application take care of all the boilerplate code of the
    JDBC API, and help to provide a consistent API for data access. In the Spring
    JDBC, DAO is a generic object to access data for the business tier, and it provides
    a consistent interface to the services at the business tier. The main goal behind
    the DAO's classes is to abstract the underlying data access logic from the services
    at the business tier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our previous example, we saw how the pizza company helped us to understand
    the resource management problem, and now, we will continue with our bank application.
    Let''s see the following example on how to implement DAOs in an application. Suppose,
    in our bank application, we want the total number accounts in a branch in the
    city. For this, we will first create an interface for the DAO. It promotes programming
    to interface, as discussed earlier. It is one of the best practices of the design
    principles. This DAO interface will be injected with the services at the business
    tier, and we can create a number of concrete classes of the DAO interface according
    to the underlying databases in the application. That means our DAO layer will
    be consistent for the business layer. Let''s create a DAO interface as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see a concrete implementation of the DAO interface using Spring''s `JdbcDaoSupport`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can see that the `AccountDaoImpl` class implements
    the `AccountDao` DAO interface, and it extends Spring's `JdbcDaoSupport` class
    to ease development with JDBC-based. This class provides a `JdbcTemplate` to its
    subclasses by using `getJdbcTemplate()`. The `JdbcDaoSupport` class is associated
    with a data source, and supplies the `JdbcTemplate` object for use in the DAO.
  prefs: []
  type: TYPE_NORMAL
- en: Working with JdbcTemplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you learned earlier, Spring''s `JdbcTemplate` solves two main problems in
    the application. It solves the redundant code problem as well as poor exception
    handling of the data access code in the application. Without `JdbcTemplate` in
    your application, only 20% of the code is required for querying a row, but 80%
    is boilerplate which handles exceptions and manages resources. If you use `JdbcTemplate`,
    then there is no need to worry about the 80% boilerplate code. Spring''s `JdbcTemplate`,
    in a nutshell, is responsible for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Acquisition of the connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Participation in the transaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution of the statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing of the result set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling any exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release of the connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see when to use `JdbcTemplate` in the application, and how to create it.
  prefs: []
  type: TYPE_NORMAL
- en: When to use JdbcTemplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`JdbcTemplate` is useful in standalone applications, and anytime when JDBC
    is needed. It is suitable in utility or test code to clean up messy legacy code.
    Also, in any layered application, you can implement a repository or data access
    object. Let''s see how to create it in an application.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a JdbcTemplate in an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to create an object of the `JdbcTemplate` class to access data
    in your Spring application, you need to remember that it requires a `DataSource`
    to create the database connection. Let''s create a template once, and reuse it.
    Do not create one for each thread, it is thread-safe after construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s configure a `JdbcTemplate` bean in Spring with the following `@Bean`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the constructor injection to inject the `DataSource`
    with the `JdbcTemplate` bean in the Spring application. The `dataSource` bean
    being referenced can be any implementation of `javax.sql.DataSource`. Let's see
    how to use the `JdbcTemplate` bean in your JDBC-based repository to access the
    database in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a JDBC-based repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the Spring''s `JdbcTemplate` class to implement the repositories
    in a Spring application. Let''s see how to implement the repository class based
    on the JDBC template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `DataSource` bean is injected with the `JdbcAccountRepository`
    class by using the constructor injection. By using this DataSource, we created
    a `JdbcTemplate` object for accessing the data. The following methods are provided
    by `JdbcTemplate` to access data from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '`queryForObject(..)`: This is a query for simple java types (`int`, `long`,
    `String`, `Date` ...) and for custom domain objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`queryForMap(..)`: This is used when expecting a single row. `JdbcTemplate`
    returns each row of a `ResultSet` as a Map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`queryForList(..)`: This is used when expecting multiple rows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that `queryForInt` and `queryForLong` have been deprecated since Spring
    3.2; you can just use `queryForObject` instead (API improved in Spring 3).
  prefs: []
  type: TYPE_NORMAL
- en: Often, it is useful to map relational data into domain objects, for example,
    a `ResultSet` to an Account in the last code. Spring's `JdbcTemplate` supports
    this by using a callback approach. Let's discuss Jdbc callback interfaces in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Jdbc callback interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring provides three callback interfaces for JDBC as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementing RowMapper**: Spring provides a `RowMapper` interface for mapping
    a single row of a `ResultSet` to an object. It can be used for both single and
    multiple row queries. It is parameterized as of Spring 3.0:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's understand this with the help of an example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a RowMapper class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following example, a class, `AccountRowMapper`, implements the `RowMapper`
    interface of the Spring Jdbc module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, a class, `AccountRowMapper`, maps a row of the result
    set to the domain object. This row-mapper class implements the `RowMapper` callback
    interface of the Spring Jdbc module.
  prefs: []
  type: TYPE_NORMAL
- en: '**Query for single row with JdbcTemplate**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see how the row-mapper maps a single row to the domain object in
    the application in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, there is no need to add typecasting for the Account object. The `AccountRowMapper`
    class maps the rows to the Account objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Query for multiple rows**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how the row mapper maps multiple rows to the list
    of domain objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: RowMapper is the best choice when each row of a `ResultSet` maps to a domain
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing RowCallbackHandler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring provides a simpler `RowCallbackHandler` interface when there is no return
    object. It is used to stream rows to a file, converting the rows to XML, and filtering
    them before adding to a collection. But filtering in SQL is much more efficient,
    and is faster than the JPA equivalent for big queries. Let''s look at the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Example for using a RowCallbackHandler**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of a `RowCallbackHandler` in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In preceding code, we have created a `RowCallbackHandler` implementation; the
    `AccountReportWriter` class implements this interface to process the result set
    returned from the database. Let''s see the following code how to use AccountReportWriter
    call back class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`RowCallbackHandler` is the best choice when no value should be returned from
    the callback method for each row, especially for large queries.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing ResultSetExtractor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring provides a `ResultSetExtractor` interface for processing an entire `ResultSet`
    at once. Here, you are responsible for iterating the `ResultSet`, for example,
    for mapping the entire `ResultSet` to a single object. Let''s see the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Example for using a ResultSetExtractor**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line of code implements the `ResultSetExtractor` interface in
    the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This preceding class, `AccountExtractor`, implements `ResultSetExtractor`,
    and it is used to create an object for the entire data of the result set returned
    from the database. Let''s see how to use this class in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is responsible for accessing all the accounts of a bank, and
    for preparing a list of accounts by using the `AccountExtractor` class. This class
    implements the `ResultSetExtractor` callback interface of the Spring Jdbc module.
  prefs: []
  type: TYPE_NORMAL
- en: '`ResultSetExtractor` is the best choice when multiple rows of a `ResultSet`
    map to a single object.'
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for Jdbc and configuring JdbcTemplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instances of the `JdbcTemplate` class are thread-safe once configured. As a
    best practice of configuring the `JdbcTemplate` in a Spring application, it should
    be constructed in the constructor injection or setter injection of the data source
    bean in your DAO classes by passing that data source bean as a constructor argument
    of the `JdbcTemplate` class. This leads to DAOs that look, in part, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you want to configure the embedded database at the time of development of
    the application, as the best practice, the embedded database will always be assigned
    a uniquely generated name. This is because in the Spring container, the embedded
    database is made available by configuring a bean of type `javax.sql.DataSource`,
    and that data source bean is injected to the data access objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Always use object pooling; this can be achieved in two ways:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection pooling**: It allows the pool manager to keep the connections
    in a *pool* after they are closed'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Statement pooling**: It allows the driver to reuse the prepared Statement
    objects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose the commit mode carefully
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider removing the auto-commit mode for your application, and use manual
    commit instead to better control the commit logic, as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application without data is like a car without fuel. Data is the heart of
    an application. Some applications may exist in the world without data, but these
    applications are simply showcase applications such as static blogs. Data is an
    important part of an application, and you need to develop data-access code for
    your application. This code should very simple, robust, and customizable.
  prefs: []
  type: TYPE_NORMAL
- en: In a traditional Java application, you could use JDBC to access the data. It
    is a very basic way, but sometimes, it is very messy to define specifications,
    handle JDBC exceptions, make database connections, load drivers, and so on. Spring
    simplifies these things by removing the boilerplate code and simplifying JDBC
    exception handling. You just write your SQL that should be executed in the application,
    and the rest is managed by the Spring framework.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you have seen how Spring provides support at the backend for
    data access and data persistence. JDBC is useful, but using the JDBC API directly
    is a tedious and error-prone task. `JdbcTemplate` simplifies data access, and
    enforces consistency. Data access with Spring uses the layered architecture principles-the
    higher layers should not know about data management. It isolates SQLException
    via Data Access Exceptions, and creates a hierarchy to make them easier to handle.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll continue to discuss data access and persistence with
    the ORM framework, like Hibernate and JPA.
  prefs: []
  type: TYPE_NORMAL
