- en: Building a Spring Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to interact with Spring Beans and how to
    configure your Spring context. This is the foundation that every Spring application
    is built on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, you learnt about how to create a Spring Boot project,
    the basic building blocks and the application context were also introduced. Lastly,
    you saw how to utilize Lombok to free you from creating or writing the same code
    over and over again.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Organize dependencies between Spring Beans
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create configuration classes to define Beans by hand
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organize Configuration Properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create strongly typed Property Classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency Injection in Spring
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will see how Spring Beans can depend on each other to provide
    functionality. The Spring Container uses the Beans in the context to inject dependencies
    into other managed instances. This enables you to write concise classes that just
    express their dependencies, and Spring takes care of the rest.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: There is a singleton with a `HashMap` and dedicated factories that create and
    wire up instances. Additionally, there are base classes that inspect the class
    and utilize some kind of singleton to look up other instances.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**Aspect-oriented programming** (to intercept missing dependencies), `classpath`
    scanning (to find available dependencies and injection points), and Inversion
    of Control (to have control over the application lifecycle).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Autowiring
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency Injection, which is the pattern to introduce the Inversion of Control
    for resolving dependencies, is called **Autowiring** in Spring. When Bean-A gets
    a reference for Bean-B injected, it is **autowired**. Autowiring only works for
    Spring Beans, so both need to be known to the **Spring Application Context**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the sample code below:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example code defines a Bean that requires the JDBC DataSource to query
    the database. As you can see, the field does not need to be public – it can even
    be private. Spring achieves this by using reflection, which is a standard Java
    feature. It allows you to create classes that have a very limited public interface,
    which makes it easier to communicate the intent of a class with code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: You might know JavaEE annotations such as `@Inject`. `@Autowired` is the corresponding
    annotation in Spring. Spring aims to be developer-friendly, so `@Inject` also
    works in Spring applications. However, the parameters differ, so you should stick
    to plain Spring annotations if there is no special need to use the JavaEE versions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Injection Types
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Spring, you have a couple of ways to get access to Beans that are in the
    context. You have already seen **Field Injection**, which has been used to autowire
    the `DataSource`, but there are more ways to get Beans injected.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use Autowiring in:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Fields
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Config Methods
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Spring has completely resolved the dependencies of a Bean, it looks for
    a method that is annotated with `PostConstruct` and executes it. There, you can
    perform some final initialization, which will utilize all defined dependencies.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Field Injection
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Field injection is the simplest way to get hold of another Bean. Just annotate
    the field with `@Autowired` and the instance will be there after the Bean's creation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '`TestBase` and `TestClass` are at [https://bit.ly/2RSCHrf](https://bit.ly/2RSCHrf),
    in the `blogmaniaexercise-solution` project folder. When you start the test, you
    will see that the instance information for `MyConfiguration` is printed twice,
    although one is defined in the abstract base class. This helps to group shared
    functionality in base classes.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://bit.ly/2Mp9kcZ](https://bit.ly/2Mp9kcZ) to access the code for
    the `TestBase.java` file. Go to [https://bit.ly/2CNj6WG](https://bit.ly/2CNj6WG)
    to access the code for the `TestClass.java` file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Property Injection
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can add `@Autowired` for setters as well. This will trigger the so-called
    **Config Method** mechanism. Spring will call the method when the dependencies
    are available after the constructor has been called.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: A property usually means that you have a field that follows the Java Bean Standard.
    For example, a property of type String named `foo` will have `setFoo(String …)`
    and String `getFoo()` methods. There are also read-only and write-only properties,
    where one of these is missing. `boolean` fields have a Getter starting with `is`,
    so `isFoo()` would be the correct name in this case.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Config Method Injection
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring is able to call a method after the instance has been created and the
    constructor has been executed. This method can have any number of parameters which
    should be resolvable with Beans from the Spring Context. The method should return
    void; the name is arbitrary and the method does not have to be public.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: You can have more than one of these and they will be executed in an undefined
    order.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this fully covers property injection as well.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Constructor Injection
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Constructor injection is the way to inject Beans that is preferred by the Spring
    Framework team. You just create a constructor with all the required Beans as parameters
    and then you assign these values to your fields if required. You might also do
    something else with the provided dependencies, such as calling a method on it
    to fetch some data, for example. So, you do not have to store the value somewhere
    if you don't need it after the constructor is finished. If you have multiple constructors
    that have parameters, then you need to qualify one constructor by adding the `@Autowired`
    annotation to it. Otherwise, this can be omitted.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall, we use Project Lombok to avoid unnecessary code. This can
    be used here as well. Just add `AllArgsConstructor` or `@RequiredArgsConstructor`
    to your class and Spring will automatically use this generated constructor. You
    do not need to create one yourself or even add `@Autowired` anywhere.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所回忆，我们使用Project Lombok来避免不必要的代码。这也可以在这里使用。只需将`@AllArgsConstructor`或`@RequiredArgsConstructor`添加到你的类中，Spring将自动使用这个生成的构造函数。你不需要自己创建一个，甚至不需要在任何地方添加`@Autowired`。
- en: Circular Dependencies
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环依赖
- en: When you have two or more Spring Beans that form a dependency circle, Spring
    might have a problem creating the Spring context when you use Constructor Injection
    everywhere.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有两个或更多Spring Bean形成依赖循环时，如果你在所有地方都使用构造函数注入，Spring可能会在创建Spring上下文时遇到问题。
- en: 'Example Dependencies:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 示例依赖关系：
- en: Bean-A => Bean-B => Bean-C => Bean-A
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Bean-A => Bean-B => Bean-C => Bean-A
- en: Spring has no chance to solve this when all Beans use constructor injection,
    because the instances cannot be instantiated without the others.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有Bean都使用构造函数注入时，Spring没有机会解决这个问题，因为实例不能在没有其他实例的情况下实例化。
- en: 'There are ways to work around that, but first you should reconsider if this
    is really the right solution; most circular dependencies are a symptom of bad
    design. If there is no way around it, you can configure Spring to solve that by
    doing the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些方法可以解决这个问题，但首先你应该重新考虑这真的是正确的解决方案；大多数循环依赖都是设计不良的症状。如果无法解决这个问题，你可以通过以下方式配置Spring来解决这个问题：
- en: 'Creating a dynamic proxy:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动态代理：
- en: For this, you need to change at least one of the constructors (it cannot be
    generated by Lombok).
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，你需要至少更改其中一个构造函数（它不能由Lombok生成）。
- en: Then, you can mark the constructor parameter by adding `@Lazy` to the type,
    which tells Spring that this dependency is not needed during class creation when
    the Spring Context is built.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以通过在类型上添加`@Lazy`来标记构造函数参数，这告诉Spring在构建Spring上下文时创建类时不需要这个依赖。
- en: Spring will create a proxy around the instance which is working as a facade
    in front of the real instance which is fetched from the context when it's accessed
    for the first time.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当第一次访问时，Spring会在从上下文中获取的真实实例前面创建一个代理实例，该实例作为门面工作。
- en: 'Use Field-/Config-Method-Injection for the first class: When you use these
    injection styles, Spring can defer the resolution of the Bean until the other
    dependencies are met. You can see the first class in the error message that Spring
    prints out during startup.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第一个类使用字段/配置方法注入：当你使用这些注入风格时，Spring可以在满足其他依赖关系之前延迟解析Bean。你可以在Spring在启动时打印出的错误信息中看到第一个类。
- en: To mark the dependency as "`lazy`", you just place the `@Lazy annotation` before
    or after the type.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要将依赖标记为“`懒加载`”，你只需在类型前或后放置`@Lazy注解`。
- en: 'Take a look at the following sample code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下示例代码：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Qualify Beans
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限定Bean
- en: If you have multiple Beans with the same type, then Spring won't be able to
    detect which instance should be assigned. In this case, the application will refuse
    to start and present an error message that explains what is going wrong.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多于一个相同类型的Bean，那么Spring将无法检测出应该分配哪个实例。在这种情况下，应用程序将拒绝启动并显示一个错误信息，解释出了什么问题。
- en: By default, Spring will try to match the name of the parameter/field with the
    names of the Beans of the corresponding type, but if you need a specific Bean
    and the name does not match, you can just add an annotation to resolve that manually.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring会尝试将参数/字段的名称与相应类型的Bean的名称匹配，但如果你需要一个特定的Bean且名称不匹配，你只需添加一个注解来手动解决。
- en: 'For example, you can use the following code to fetch the `myDate` Bean from
    the context:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用以下代码从上下文中获取`myDate` Bean：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can access the Application Context directly and fetch a Bean by type or
    name from there if necessary. You can implement the `ApplicationContextAware`
    interface and Spring will provide a reference to the Application Context for you.
    This should only be used in rare cases, as most of the time, the "static wiring"
    should be sufficient.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你可以直接访问应用程序上下文并从那里通过类型或名称获取Bean。你可以实现`ApplicationContextAware`接口，Spring将为你提供应用程序上下文的引用。这应该只在极少数情况下使用，因为在大多数情况下，“静态绑定”应该足够了。
- en: Bean Scopes
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bean作用域
- en: By now, you have seen how you can define Spring Beans, and you saw that one
    instance is usually created when the application starts. But there are other use
    cases where this is not the right choice.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了如何定义Spring Bean，你也看到了通常在应用程序启动时创建一个实例。但还有其他用例，这种选择并不合适。
- en: 'To specify a scope, just add the `@Scope` annotation to the Bean definition:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The default scope of a Bean is `singleton`, which means there is one instance
    of the Bean in the container and this is returned by the Spring Context. The scope
    reference itself is just a String.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The second standard scope is `prototype`, which returns a new instance whenever
    a Bean with that name is requested from the Context. So, if you define Bean-A
    with the prototype scope and Bean-C and Bean-D have an autowired field for Bean-A,
    then both will get their own instance. This is handy when the Bean has some kind
    of state that should not be shared with other Beans, such as caches, for example.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: There are also other scopes such as `request` and `session`, which are specific
    to Spring WebMVC and will be covered later. You can even define your own scopes,
    but this is an advanced section that we won't cover in this book.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides static constants for the scopes in a few places. The regular
    scopes are defined in the `ConfigurableBeanFactory` class, while the web application-specific
    scopes are defined in `WebApplicationContext`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Configuration Classes
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have seen how to declare Spring Beans by annotating the class definition.
    This is the most common use case, but sometimes you need more control during the
    creation of a Bean. This is where configuration classes come into play. They are
    basically classes with factory methods for Beans. This can be used to create Beans
    of classes that are defined outside of your code base or, for example, to return
    a specific implementation of an interface depending on some configuration values.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Configuration classes are Spring Beans too, so you can use autowired dependencies
    here as well, but constructor injection should be avoided.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a configuration class looks like:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `MyConfiguration` class in the provided source code for this section contains
    even more Beans with their corresponding JavaDoc.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior for configuration classes is to return the correct instance
    from the Spring Context. So, when you autowire a configuration class somewhere
    and call a method that is annotated with `@Bean`, the method may not be executed
    and the result from the Spring Context is returned instead. This is even true
    when you call a `@Bean` method from within the same Configuration. Using configuration
    classes as dependencies in "regular" Beans is technically possible, but not commonly
    done. Most projects use dedicated Factory Beans for a single type or a set of
    types.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing Bean Interdependencies
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim is to utilize Bean interdependencies to relay data to the repository.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for completion are as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Open the IDE and the `BlogMania` application ([https://bit.ly/2QpUDd1](https://bit.ly/2QpUDd1))
    for this section.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the `BlogService` and `BlogRepository` to the `com.packt.springboot.blogmania.blogentries.service` package.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79d60584-3e5c-4022-8137-cb0578776b1d.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: Right-click on the blogentries package and create the new package from there.
    Then, drag and drop the classes into the package.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'You have now created your own Spring Bean and used it in a business context
    in order to solve the task and save the data in memory. Take a look at the output
    screenshot, as shown below:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04552a82-45fc-4fe7-a55d-4e76e66d4033.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: Go to [https://bit.ly/2OeUPtQ](https://bit.ly/2OeUPtQ) to access the code for
    the `BlogmaniaApplicationTests.java` file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Configuration of Spring Boot Applications
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you saw how to connect Spring Beans and which mechanism
    you can use to achieve that.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: When you write your application, you will encounter aspects of your application
    that need to be configurable. If you use a database, you will have different database
    configurations; maybe features that are enabled or disabled, or something like
    that.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: In a Spring Boot application, you don't need to handle this yourself. Spring
    Boot has a very sophisticated system in place to configure your application with
    ease, even in complex scenarios.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will create profiles to target different environments and
    configure the application with property and **YAML** (**YAML Ain't Markup Language**)
    files. You also will see the search order for properties in action with which
    you can configure your Spring Beans in multiple ways.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Profiles
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring applications have a simple mechanism to tell your application that it
    runs in different environments or modes. The application has "Active Profiles",
    which can influence how the application is configured or behaves. The profiles
    are ordered lists of words. Each of these words is a profile. If none is given,
    it is a default.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can start the application with the additional command-line
    parameter `--spring.profiles.active=peter`,`dev`,`postgres`. As you can see, each
    profile is separated by a comma.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: This means that the profiles `peter`, `dev`, and `postgres` are active. In the
    following slides, you will see what you can do with these profiles.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Beans
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you need to enable or disable certain Beans when a profile is active, you
    can use a simple annotation at the Bean definition. This can either be a configuration
    class, the annotated class definition, or the `@Bean` annotated methods.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, you just need to add the `@Profile` annotation at the class or method
    definition. The following code snippet is copied from the `MyConfiguration` class
    ([https://bit.ly/2oYUl05](https://bit.ly/2oYUl05)) and configures the `theConfiguredDate`
    Bean, which is a fixed point in time in dev mode (maybe for tests) and the current
    date and time when the dev profile is not set. Due to the fact that we can''t
    have both methods named the same, we used a feature of the `@Bean` annotation
    to override the default name of the bean with `theConfiguredDate`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `@Profile` annotations can also take a list of profiles, which in this case
    is any of the given profiles that are sufficient enough to trigger the Bean's
    creation. This means that the profiles are evaluated with an implicit `or`, not
    an `and`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There is also a `@Primary` annotation on a Bean definition, which can be used
    to mark a Bean as a default Bean for a given type. This is used when there are
    multiple Beans that would match the type. To select one of the other Beans, you
    would need to add the `@Qualifier` annotation with the correct Bean name.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing Conditional Beans for Various Implementations
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim is to utilize conditional Spring Beans, which can be used, for example,
    to switch (or select) between different implementations. Before beginning, please
    reuse the existing project. Go to [https://bit.ly/2oYUl05](https://bit.ly/2oYUl05)
    to access the code for the blogmania directory.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for completion are as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Create an interface called **Randomizer** with a method that returns a double
    and has no parameters.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/584bbe21-3d77-4358-9b75-ef186fcf3c22.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: Create an implementation that returns a random number using the `nextDouble()`
    method of the `Random` class and make it a Bean.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an implementation that always returns, for example, `3`. Make this a
    Bean that is active when the test profile is active. It should replace or override
    the other Bean.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You have seen how you can override a Bean for tests, which helps you to write
    concise and reliable tests. Take a look at the output screenshot, as shown below:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d341628a-2060-46bd-9bff-3a8fe198f390.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Go to [https://bit.ly/2x8v1s5](https://bit.ly/2x8v1s5) to access the code for
    the `BlogmaniaApplication.java` file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Spring Configuration Files
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot applications are created by the Spring Initializr by default with
    an empty `application.properties` file in the resource folder. This is the default
    configuration file. You can write all default configurations there in the property
    file format, which we will see in more detail soon.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Next to the `application.properties` file, you can place more configuration
    files that are loaded based on active profiles.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: You can create an `application-dev.properties` file there and it will only be
    loaded when the dev profile is active. We will cover the order in which property
    values are applied in a dedicated section soon.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Property Files
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Property files are very common in the Java ecosystem and are even older than
    the now commonly disliked XML files.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'The format is simple:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Values are stored in a `Key=value` fashion where the key usually consists of
    lower case dot-separated words, and the value following the `=` may contain blanks.
    Multiline values need to have a `\` at the end of the line that is continued in
    the next line.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comment lines start with a `#` and are ignored by the parser.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have empty lines.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the mechanism with the profile-based files, you can set or override values.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'An example configuration looks like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Property files should always be encoded in ISO-8859-1, otherwise you will end
    up with weird results. It may work in tests but breaks when you start the application
    or vice-versa.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: YAML Files
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**YAML** (**YAML Ain''t Markup Language**) files are another syntax to create
    configuration files in Spring Boot.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'The format is basically defined by the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Values are stored in a `key: value` fashion.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: YAML supports `subkeys` which are simply indented. Keys on the same level are
    grouped together until the next key is less indented.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists are supported by using a subgroup where each line starts with a dash.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments start with a `#`.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The property example as YAML looks like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see that the dot still works as a group separator, but if you have multiple
    keys with the same parent groups, you can use this shorter version. This is especially
    handy with the deep key structure of the Spring configuration values.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Multi-Profile YAML Files
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using YAML files, you can use a special format to define values that are only
    active in a given profile.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, you use three dashes followed by the `spring.profile` key with
    the profile that this block is supposed to be active in. Here, you can even use
    the negated syntax to set values when a profile is not set:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This advanced mechanism is specified in the YAML standard, but some YAML validators
    may mark this as a no longer valid YAML file. The parsers cut the YAML files at
    the dashes and handle them internally as different (virtual) files. If you have
    static lint checkers on your source code, they might complain about this syntax.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: A **lint checker** is a program that checks files for syntax errors or common
    mistakes. There are lint checkers available for many file types and programming
    languages.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: External Configuration Locations
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The files that we have discussed are located in the classpath, but you might
    have the need to have some host- or environment-specific configuration that you
    don't want to check into version control. For example, your security department
    will not be pleased when production database credentials are hosted in the widely
    accessible Git repository.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The Spring documentation lists 17 different ways of how configuration values
    can be set or overwritten. We will omit a few of the advanced ways for brevity,
    but if you want to see them all, please visit [https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Whenever Spring looks up a configuration value, it searches this list for the
    value. As soon as the value is found, the search stops.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'The following files that are outside the JAR are searched for in the current
    working directory by default:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Command-line arguments
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties from `SPRING_APPLICATION_JSON` (inline JSON embedded in an environment
    variable or system property)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java System properties (set using `-Dmy.config.key=value`)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS environment variables (often used with Docker containers)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profile-specific application properties outside of your packaged JAR (`application-{profile}.properties`
    and `YAML variants`)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profile-specific application properties packaged inside your JAR (`application-{profile}.properties`
    and `YAML variants`)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application properties outside of your packaged JAR (`application.properties`
    and `YAML variants`)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application properties packaged inside your JAR (`application.properties` and
    `YAML variants`)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PropertySource` annotations on your `@Configuration` classes (used to load
    additional property files, but no YAML!)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a bit surprising that the files loaded via `@PropertySource` are evaluated
    last, but the rest is very sensible and enables you to package default values
    with your application and override them for the concrete instance that is running
    on a host or in a container.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Placeholders in Configuration Files
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within a configuration file, you can use a very simple variable replacement
    mechanism which is evaluated when the configuration values are all loaded, so
    even when the replacement refers to a value that is defined in the same file,
    it still can be overridden, for example, by a profile or system property. The
    mechanism works for property and YAML files:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will set the description of the application to whatever is set as `spring.
    application.name` plus is so nice. The syntax looks a lot like **SpEL** (**Spring
    Expression Language**), but is limited to simple variable replacement. SpEL will
    be briefly covered soon.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Environment Values
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen many ways to define configuration values, but we have not used
    them yet. Spring offers multiple ways to access these values. The oldest way is
    to let Spring autowire an instance with the `Environment` type into your Bean.
    This offers ways to access configuration values using code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the example code below: (excerpt from `BlogService.java`):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `log.info(...)` is provided by Project Lombok's `@Slf4j` annotation, which
    creates a static logger that's configured for the class with the name `log` for
    you.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Annotated Fields
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the Environment instance directly is a bit cumbersome, so the Spring developers
    created another annotation called `@Value` which is capable of accessing data
    from the environment and assigning it to a field. The field can be of any type
    that is supported out of the box such as primitive types or other default Java
    classes, or you can provide a `ConversionService` or `PropertyEditors` which are
    mechanisms that Spring uses to convert data to and from strings. Being able to
    create your own converters is out of the scope of this book.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the example code below: (excerpt from `BlogService.java`):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This loads the value using the key `my.config.feature.flag` and converts it
    to a `boolean` value. The value is false by default when the config key is not
    set. Therefore, the syntax is `@Value("${KEY:DEFAULT}")` with the default value
    and `@Value("${KEY}")` without. The default value is the string representation
    of the default value in the same format that you expect in the config file.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Lists are values that are set with square brackets and comma separated values
    like `[1,3,5,7,9];` which is a list of odd integer values.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Spring Expression Language
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Spring Expression Language** (**SpEL**) is similar to the Unified EL,
    which was created for Java Server Pages (JSP) in 2006\. It supports querying and
    manipulating the Spring Context. You can think of it as a lightweight scripting
    language. The SpEL can be used by your code if you use the `SpelExpressionParser`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'SpEL is very powerful, and some of its especially useful features are as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Literal expressions
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to Spring Bean methods and properties
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean operations
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call static methods
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter collections
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example that calls the `getTimeMessage()` method on
    the `blogService` Spring Bean. The resultant String will be converted to uppercase
    afterwards:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `getTimeMessage()` method conforms to the Bean standard and represents the
    `timeMessage` property as read-only. This allows us to skip the get prefix.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Configuration Property Classes
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As your application grows, you will also have a growing set of configuration
    options. Using the `@Value` annotation, you can access these, but scattering this
    all over your application may lead to a lot of duplication and maybe even work,
    for example, when the type, key, or default value changes. Then, you have to update
    all occurrences, which is not preferable.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'To have IDE support for the properties, you need to add this dependency:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, you can create a Configuration Properties class with the `@ConfigurationProperties`
    annotation. The class itself should have properties to store the data, and you
    can define default values here if you like:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To create the getters and setters, we use Lombok. As you can see, you can also
    have deeply nested classes to store and segregate your data. The `@ConfigurationProperties`
    annotation should have a parameter that is a path prefix for the properties. With
    this, you have properties like the following ones:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For this to work, you have to do two things. First, you must register the classes
    that are annotated with `@ConfigurationProperties` in a configuration class definition,
    like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Make the configuration class a Bean by adding `@Component` next to `@ConfigurationProperties`
    or by adding a `@Bean` annotated method for it to a configuration class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that the `iLikePizza` property is now in **kebab-case**
    in the configuration file. The reason behind this is that this is the recommended
    way to write properties. Spring supports relaxed binding for `ConfigurationProperty`
    classes, so you could also use **camelCase** or **snake_case**, but this is not
    recommended, because in certain cases, this can lead to problems.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Examining Autowiring and Configurations'
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Aim**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: To create a few classes to practice autowiring and application configuration.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: You should reuse the project that was used for the previous subsection and open
    it in the IDE. This is a simplified version of a common task, where you read something
    from the configuration and apply that to input.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: You are going to create a greeting service that uses a configured suffix and
    a provided input to create a greeting such as Packt greets the world.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Create the class to read the configuration value for the suffix.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/935dce09-20b9-474a-8244-23e9269d7e2f.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: Create the greeting service.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject the required class in the service.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a public method that creates the greeting.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Application class, add a config method that executes the greeting method
    and prints out the result.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Outcome**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The default message should be INPUT+ greets the world (INPUT is the input with
    the greeter's name to the greeting method), but the location (**the world**) should
    be customizable, so you should also be able to create, for example, INPUT+ greets
    Berlin. The location should be read using the `GreetingProperties`. To trigger
    this code, use the Application class, autowire the service here, and execute it
    with sample data.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the output screenshot, as shown below:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c610792-e841-4a13-9d0f-d94ff777f835.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: To refer to the detailed steps, go to the *Solutions* section at the end of this
    book on page 250.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have seen how you can inject Spring Beans into other Beans
    and how you can help Spring in cases where the injector is not uniquely identifiable.
    You also saw how you can configure your application with profiles and configuration
    files.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will finally start looking at ways we can test our Spring
    Boot applications.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
