- en: Building a Spring Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to interact with Spring Beans and how to
    configure your Spring context. This is the foundation that every Spring application
    is built on.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, you learnt about how to create a Spring Boot project,
    the basic building blocks and the application context were also introduced. Lastly,
    you saw how to utilize Lombok to free you from creating or writing the same code
    over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Organize dependencies between Spring Beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create configuration classes to define Beans by hand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organize Configuration Properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create strongly typed Property Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency Injection in Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will see how Spring Beans can depend on each other to provide
    functionality. The Spring Container uses the Beans in the context to inject dependencies
    into other managed instances. This enables you to write concise classes that just
    express their dependencies, and Spring takes care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: There is a singleton with a `HashMap` and dedicated factories that create and
    wire up instances. Additionally, there are base classes that inspect the class
    and utilize some kind of singleton to look up other instances.
  prefs: []
  type: TYPE_NORMAL
- en: '**Aspect-oriented programming** (to intercept missing dependencies), `classpath`
    scanning (to find available dependencies and injection points), and Inversion
    of Control (to have control over the application lifecycle).'
  prefs: []
  type: TYPE_NORMAL
- en: Autowiring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency Injection, which is the pattern to introduce the Inversion of Control
    for resolving dependencies, is called **Autowiring** in Spring. When Bean-A gets
    a reference for Bean-B injected, it is **autowired**. Autowiring only works for
    Spring Beans, so both need to be known to the **Spring Application Context**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the sample code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This example code defines a Bean that requires the JDBC DataSource to query
    the database. As you can see, the field does not need to be public – it can even
    be private. Spring achieves this by using reflection, which is a standard Java
    feature. It allows you to create classes that have a very limited public interface,
    which makes it easier to communicate the intent of a class with code.
  prefs: []
  type: TYPE_NORMAL
- en: You might know JavaEE annotations such as `@Inject`. `@Autowired` is the corresponding
    annotation in Spring. Spring aims to be developer-friendly, so `@Inject` also
    works in Spring applications. However, the parameters differ, so you should stick
    to plain Spring annotations if there is no special need to use the JavaEE versions.
  prefs: []
  type: TYPE_NORMAL
- en: Injection Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Spring, you have a couple of ways to get access to Beans that are in the
    context. You have already seen **Field Injection**, which has been used to autowire
    the `DataSource`, but there are more ways to get Beans injected.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use Autowiring in:'
  prefs: []
  type: TYPE_NORMAL
- en: Fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Config Methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Spring has completely resolved the dependencies of a Bean, it looks for
    a method that is annotated with `PostConstruct` and executes it. There, you can
    perform some final initialization, which will utilize all defined dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Field Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Field injection is the simplest way to get hold of another Bean. Just annotate
    the field with `@Autowired` and the instance will be there after the Bean's creation.
  prefs: []
  type: TYPE_NORMAL
- en: '`TestBase` and `TestClass` are at [https://bit.ly/2RSCHrf](https://bit.ly/2RSCHrf),
    in the `blogmaniaexercise-solution` project folder. When you start the test, you
    will see that the instance information for `MyConfiguration` is printed twice,
    although one is defined in the abstract base class. This helps to group shared
    functionality in base classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://bit.ly/2Mp9kcZ](https://bit.ly/2Mp9kcZ) to access the code for
    the `TestBase.java` file. Go to [https://bit.ly/2CNj6WG](https://bit.ly/2CNj6WG)
    to access the code for the `TestClass.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: Property Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can add `@Autowired` for setters as well. This will trigger the so-called
    **Config Method** mechanism. Spring will call the method when the dependencies
    are available after the constructor has been called.
  prefs: []
  type: TYPE_NORMAL
- en: A property usually means that you have a field that follows the Java Bean Standard.
    For example, a property of type String named `foo` will have `setFoo(String …)`
    and String `getFoo()` methods. There are also read-only and write-only properties,
    where one of these is missing. `boolean` fields have a Getter starting with `is`,
    so `isFoo()` would be the correct name in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Config Method Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring is able to call a method after the instance has been created and the
    constructor has been executed. This method can have any number of parameters which
    should be resolvable with Beans from the Spring Context. The method should return
    void; the name is arbitrary and the method does not have to be public.
  prefs: []
  type: TYPE_NORMAL
- en: You can have more than one of these and they will be executed in an undefined
    order.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this fully covers property injection as well.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Constructor injection is the way to inject Beans that is preferred by the Spring
    Framework team. You just create a constructor with all the required Beans as parameters
    and then you assign these values to your fields if required. You might also do
    something else with the provided dependencies, such as calling a method on it
    to fetch some data, for example. So, you do not have to store the value somewhere
    if you don't need it after the constructor is finished. If you have multiple constructors
    that have parameters, then you need to qualify one constructor by adding the `@Autowired`
    annotation to it. Otherwise, this can be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall, we use Project Lombok to avoid unnecessary code. This can
    be used here as well. Just add `AllArgsConstructor` or `@RequiredArgsConstructor`
    to your class and Spring will automatically use this generated constructor. You
    do not need to create one yourself or even add `@Autowired` anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Circular Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have two or more Spring Beans that form a dependency circle, Spring
    might have a problem creating the Spring context when you use Constructor Injection
    everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example Dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: Bean-A => Bean-B => Bean-C => Bean-A
  prefs: []
  type: TYPE_NORMAL
- en: Spring has no chance to solve this when all Beans use constructor injection,
    because the instances cannot be instantiated without the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are ways to work around that, but first you should reconsider if this
    is really the right solution; most circular dependencies are a symptom of bad
    design. If there is no way around it, you can configure Spring to solve that by
    doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a dynamic proxy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this, you need to change at least one of the constructors (it cannot be
    generated by Lombok).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you can mark the constructor parameter by adding `@Lazy` to the type,
    which tells Spring that this dependency is not needed during class creation when
    the Spring Context is built.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Spring will create a proxy around the instance which is working as a facade
    in front of the real instance which is fetched from the context when it's accessed
    for the first time.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use Field-/Config-Method-Injection for the first class: When you use these
    injection styles, Spring can defer the resolution of the Bean until the other
    dependencies are met. You can see the first class in the error message that Spring
    prints out during startup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To mark the dependency as "`lazy`", you just place the `@Lazy annotation` before
    or after the type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Qualify Beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have multiple Beans with the same type, then Spring won't be able to
    detect which instance should be assigned. In this case, the application will refuse
    to start and present an error message that explains what is going wrong.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Spring will try to match the name of the parameter/field with the
    names of the Beans of the corresponding type, but if you need a specific Bean
    and the name does not match, you can just add an annotation to resolve that manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can use the following code to fetch the `myDate` Bean from
    the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can access the Application Context directly and fetch a Bean by type or
    name from there if necessary. You can implement the `ApplicationContextAware`
    interface and Spring will provide a reference to the Application Context for you.
    This should only be used in rare cases, as most of the time, the "static wiring"
    should be sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Bean Scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you have seen how you can define Spring Beans, and you saw that one
    instance is usually created when the application starts. But there are other use
    cases where this is not the right choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify a scope, just add the `@Scope` annotation to the Bean definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The default scope of a Bean is `singleton`, which means there is one instance
    of the Bean in the container and this is returned by the Spring Context. The scope
    reference itself is just a String.
  prefs: []
  type: TYPE_NORMAL
- en: The second standard scope is `prototype`, which returns a new instance whenever
    a Bean with that name is requested from the Context. So, if you define Bean-A
    with the prototype scope and Bean-C and Bean-D have an autowired field for Bean-A,
    then both will get their own instance. This is handy when the Bean has some kind
    of state that should not be shared with other Beans, such as caches, for example.
  prefs: []
  type: TYPE_NORMAL
- en: There are also other scopes such as `request` and `session`, which are specific
    to Spring WebMVC and will be covered later. You can even define your own scopes,
    but this is an advanced section that we won't cover in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides static constants for the scopes in a few places. The regular
    scopes are defined in the `ConfigurableBeanFactory` class, while the web application-specific
    scopes are defined in `WebApplicationContext`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have seen how to declare Spring Beans by annotating the class definition.
    This is the most common use case, but sometimes you need more control during the
    creation of a Bean. This is where configuration classes come into play. They are
    basically classes with factory methods for Beans. This can be used to create Beans
    of classes that are defined outside of your code base or, for example, to return
    a specific implementation of an interface depending on some configuration values.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration classes are Spring Beans too, so you can use autowired dependencies
    here as well, but constructor injection should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a configuration class looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `MyConfiguration` class in the provided source code for this section contains
    even more Beans with their corresponding JavaDoc.
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior for configuration classes is to return the correct instance
    from the Spring Context. So, when you autowire a configuration class somewhere
    and call a method that is annotated with `@Bean`, the method may not be executed
    and the result from the Spring Context is returned instead. This is even true
    when you call a `@Bean` method from within the same Configuration. Using configuration
    classes as dependencies in "regular" Beans is technically possible, but not commonly
    done. Most projects use dedicated Factory Beans for a single type or a set of
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing Bean Interdependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim is to utilize Bean interdependencies to relay data to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for completion are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the IDE and the `BlogMania` application ([https://bit.ly/2QpUDd1](https://bit.ly/2QpUDd1))
    for this section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the `BlogService` and `BlogRepository` to the `com.packt.springboot.blogmania.blogentries.service` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79d60584-3e5c-4022-8137-cb0578776b1d.png)'
  prefs: []
  type: TYPE_IMG
- en: Right-click on the blogentries package and create the new package from there.
    Then, drag and drop the classes into the package.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have now created your own Spring Bean and used it in a business context
    in order to solve the task and save the data in memory. Take a look at the output
    screenshot, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04552a82-45fc-4fe7-a55d-4e76e66d4033.png)'
  prefs: []
  type: TYPE_IMG
- en: Go to [https://bit.ly/2OeUPtQ](https://bit.ly/2OeUPtQ) to access the code for
    the `BlogmaniaApplicationTests.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration of Spring Boot Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you saw how to connect Spring Beans and which mechanism
    you can use to achieve that.
  prefs: []
  type: TYPE_NORMAL
- en: When you write your application, you will encounter aspects of your application
    that need to be configurable. If you use a database, you will have different database
    configurations; maybe features that are enabled or disabled, or something like
    that.
  prefs: []
  type: TYPE_NORMAL
- en: In a Spring Boot application, you don't need to handle this yourself. Spring
    Boot has a very sophisticated system in place to configure your application with
    ease, even in complex scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will create profiles to target different environments and
    configure the application with property and **YAML** (**YAML Ain't Markup Language**)
    files. You also will see the search order for properties in action with which
    you can configure your Spring Beans in multiple ways.
  prefs: []
  type: TYPE_NORMAL
- en: Profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring applications have a simple mechanism to tell your application that it
    runs in different environments or modes. The application has "Active Profiles",
    which can influence how the application is configured or behaves. The profiles
    are ordered lists of words. Each of these words is a profile. If none is given,
    it is a default.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can start the application with the additional command-line
    parameter `--spring.profiles.active=peter`,`dev`,`postgres`. As you can see, each
    profile is separated by a comma.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the profiles `peter`, `dev`, and `postgres` are active. In the
    following slides, you will see what you can do with these profiles.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you need to enable or disable certain Beans when a profile is active, you
    can use a simple annotation at the Bean definition. This can either be a configuration
    class, the annotated class definition, or the `@Bean` annotated methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, you just need to add the `@Profile` annotation at the class or method
    definition. The following code snippet is copied from the `MyConfiguration` class
    ([https://bit.ly/2oYUl05](https://bit.ly/2oYUl05)) and configures the `theConfiguredDate`
    Bean, which is a fixed point in time in dev mode (maybe for tests) and the current
    date and time when the dev profile is not set. Due to the fact that we can''t
    have both methods named the same, we used a feature of the `@Bean` annotation
    to override the default name of the bean with `theConfiguredDate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `@Profile` annotations can also take a list of profiles, which in this case
    is any of the given profiles that are sufficient enough to trigger the Bean's
    creation. This means that the profiles are evaluated with an implicit `or`, not
    an `and`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There is also a `@Primary` annotation on a Bean definition, which can be used
    to mark a Bean as a default Bean for a given type. This is used when there are
    multiple Beans that would match the type. To select one of the other Beans, you
    would need to add the `@Qualifier` annotation with the correct Bean name.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing Conditional Beans for Various Implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim is to utilize conditional Spring Beans, which can be used, for example,
    to switch (or select) between different implementations. Before beginning, please
    reuse the existing project. Go to [https://bit.ly/2oYUl05](https://bit.ly/2oYUl05)
    to access the code for the blogmania directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for completion are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an interface called **Randomizer** with a method that returns a double
    and has no parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/584bbe21-3d77-4358-9b75-ef186fcf3c22.png)'
  prefs: []
  type: TYPE_IMG
- en: Create an implementation that returns a random number using the `nextDouble()`
    method of the `Random` class and make it a Bean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an implementation that always returns, for example, `3`. Make this a
    Bean that is active when the test profile is active. It should replace or override
    the other Bean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You have seen how you can override a Bean for tests, which helps you to write
    concise and reliable tests. Take a look at the output screenshot, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d341628a-2060-46bd-9bff-3a8fe198f390.png)'
  prefs: []
  type: TYPE_IMG
- en: Go to [https://bit.ly/2x8v1s5](https://bit.ly/2x8v1s5) to access the code for
    the `BlogmaniaApplication.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Configuration Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot applications are created by the Spring Initializr by default with
    an empty `application.properties` file in the resource folder. This is the default
    configuration file. You can write all default configurations there in the property
    file format, which we will see in more detail soon.
  prefs: []
  type: TYPE_NORMAL
- en: Next to the `application.properties` file, you can place more configuration
    files that are loaded based on active profiles.
  prefs: []
  type: TYPE_NORMAL
- en: You can create an `application-dev.properties` file there and it will only be
    loaded when the dev profile is active. We will cover the order in which property
    values are applied in a dedicated section soon.
  prefs: []
  type: TYPE_NORMAL
- en: Property Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Property files are very common in the Java ecosystem and are even older than
    the now commonly disliked XML files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Values are stored in a `Key=value` fashion where the key usually consists of
    lower case dot-separated words, and the value following the `=` may contain blanks.
    Multiline values need to have a `\` at the end of the line that is continued in
    the next line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comment lines start with a `#` and are ignored by the parser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have empty lines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the mechanism with the profile-based files, you can set or override values.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example configuration looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Property files should always be encoded in ISO-8859-1, otherwise you will end
    up with weird results. It may work in tests but breaks when you start the application
    or vice-versa.
  prefs: []
  type: TYPE_NORMAL
- en: YAML Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**YAML** (**YAML Ain''t Markup Language**) files are another syntax to create
    configuration files in Spring Boot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The format is basically defined by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values are stored in a `key: value` fashion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: YAML supports `subkeys` which are simply indented. Keys on the same level are
    grouped together until the next key is less indented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists are supported by using a subgroup where each line starts with a dash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments start with a `#`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The property example as YAML looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the dot still works as a group separator, but if you have multiple
    keys with the same parent groups, you can use this shorter version. This is especially
    handy with the deep key structure of the Spring configuration values.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-Profile YAML Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using YAML files, you can use a special format to define values that are only
    active in a given profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, you use three dashes followed by the `spring.profile` key with
    the profile that this block is supposed to be active in. Here, you can even use
    the negated syntax to set values when a profile is not set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This advanced mechanism is specified in the YAML standard, but some YAML validators
    may mark this as a no longer valid YAML file. The parsers cut the YAML files at
    the dashes and handle them internally as different (virtual) files. If you have
    static lint checkers on your source code, they might complain about this syntax.
  prefs: []
  type: TYPE_NORMAL
- en: A **lint checker** is a program that checks files for syntax errors or common
    mistakes. There are lint checkers available for many file types and programming
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: External Configuration Locations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The files that we have discussed are located in the classpath, but you might
    have the need to have some host- or environment-specific configuration that you
    don't want to check into version control. For example, your security department
    will not be pleased when production database credentials are hosted in the widely
    accessible Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring documentation lists 17 different ways of how configuration values
    can be set or overwritten. We will omit a few of the advanced ways for brevity,
    but if you want to see them all, please visit [https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever Spring looks up a configuration value, it searches this list for the
    value. As soon as the value is found, the search stops.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following files that are outside the JAR are searched for in the current
    working directory by default:'
  prefs: []
  type: TYPE_NORMAL
- en: Command-line arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties from `SPRING_APPLICATION_JSON` (inline JSON embedded in an environment
    variable or system property)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java System properties (set using `-Dmy.config.key=value`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS environment variables (often used with Docker containers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profile-specific application properties outside of your packaged JAR (`application-{profile}.properties`
    and `YAML variants`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profile-specific application properties packaged inside your JAR (`application-{profile}.properties`
    and `YAML variants`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application properties outside of your packaged JAR (`application.properties`
    and `YAML variants`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application properties packaged inside your JAR (`application.properties` and
    `YAML variants`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PropertySource` annotations on your `@Configuration` classes (used to load
    additional property files, but no YAML!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a bit surprising that the files loaded via `@PropertySource` are evaluated
    last, but the rest is very sensible and enables you to package default values
    with your application and override them for the concrete instance that is running
    on a host or in a container.
  prefs: []
  type: TYPE_NORMAL
- en: Placeholders in Configuration Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within a configuration file, you can use a very simple variable replacement
    mechanism which is evaluated when the configuration values are all loaded, so
    even when the replacement refers to a value that is defined in the same file,
    it still can be overridden, for example, by a profile or system property. The
    mechanism works for property and YAML files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will set the description of the application to whatever is set as `spring.
    application.name` plus is so nice. The syntax looks a lot like **SpEL** (**Spring
    Expression Language**), but is limited to simple variable replacement. SpEL will
    be briefly covered soon.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Environment Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen many ways to define configuration values, but we have not used
    them yet. Spring offers multiple ways to access these values. The oldest way is
    to let Spring autowire an instance with the `Environment` type into your Bean.
    This offers ways to access configuration values using code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the example code below: (excerpt from `BlogService.java`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `log.info(...)` is provided by Project Lombok's `@Slf4j` annotation, which
    creates a static logger that's configured for the class with the name `log` for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Annotated Fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the Environment instance directly is a bit cumbersome, so the Spring developers
    created another annotation called `@Value` which is capable of accessing data
    from the environment and assigning it to a field. The field can be of any type
    that is supported out of the box such as primitive types or other default Java
    classes, or you can provide a `ConversionService` or `PropertyEditors` which are
    mechanisms that Spring uses to convert data to and from strings. Being able to
    create your own converters is out of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the example code below: (excerpt from `BlogService.java`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This loads the value using the key `my.config.feature.flag` and converts it
    to a `boolean` value. The value is false by default when the config key is not
    set. Therefore, the syntax is `@Value("${KEY:DEFAULT}")` with the default value
    and `@Value("${KEY}")` without. The default value is the string representation
    of the default value in the same format that you expect in the config file.
  prefs: []
  type: TYPE_NORMAL
- en: Lists are values that are set with square brackets and comma separated values
    like `[1,3,5,7,9];` which is a list of odd integer values.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Expression Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Spring Expression Language** (**SpEL**) is similar to the Unified EL,
    which was created for Java Server Pages (JSP) in 2006\. It supports querying and
    manipulating the Spring Context. You can think of it as a lightweight scripting
    language. The SpEL can be used by your code if you use the `SpelExpressionParser`.
  prefs: []
  type: TYPE_NORMAL
- en: 'SpEL is very powerful, and some of its especially useful features are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Literal expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to Spring Bean methods and properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call static methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example that calls the `getTimeMessage()` method on
    the `blogService` Spring Bean. The resultant String will be converted to uppercase
    afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `getTimeMessage()` method conforms to the Bean standard and represents the
    `timeMessage` property as read-only. This allows us to skip the get prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration Property Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As your application grows, you will also have a growing set of configuration
    options. Using the `@Value` annotation, you can access these, but scattering this
    all over your application may lead to a lot of duplication and maybe even work,
    for example, when the type, key, or default value changes. Then, you have to update
    all occurrences, which is not preferable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have IDE support for the properties, you need to add this dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can create a Configuration Properties class with the `@ConfigurationProperties`
    annotation. The class itself should have properties to store the data, and you
    can define default values here if you like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the getters and setters, we use Lombok. As you can see, you can also
    have deeply nested classes to store and segregate your data. The `@ConfigurationProperties`
    annotation should have a parameter that is a path prefix for the properties. With
    this, you have properties like the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For this to work, you have to do two things. First, you must register the classes
    that are annotated with `@ConfigurationProperties` in a configuration class definition,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Make the configuration class a Bean by adding `@Component` next to `@ConfigurationProperties`
    or by adding a `@Bean` annotated method for it to a configuration class.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that the `iLikePizza` property is now in **kebab-case**
    in the configuration file. The reason behind this is that this is the recommended
    way to write properties. Spring supports relaxed binding for `ConfigurationProperty`
    classes, so you could also use **camelCase** or **snake_case**, but this is not
    recommended, because in certain cases, this can lead to problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Examining Autowiring and Configurations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: To create a few classes to practice autowiring and application configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: You should reuse the project that was used for the previous subsection and open
    it in the IDE. This is a simplified version of a common task, where you read something
    from the configuration and apply that to input.
  prefs: []
  type: TYPE_NORMAL
- en: You are going to create a greeting service that uses a configured suffix and
    a provided input to create a greeting such as Packt greets the world.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion**'
  prefs: []
  type: TYPE_NORMAL
- en: Create the class to read the configuration value for the suffix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/935dce09-20b9-474a-8244-23e9269d7e2f.png)'
  prefs: []
  type: TYPE_IMG
- en: Create the greeting service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject the required class in the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a public method that creates the greeting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Application class, add a config method that executes the greeting method
    and prints out the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: The default message should be INPUT+ greets the world (INPUT is the input with
    the greeter's name to the greeting method), but the location (**the world**) should
    be customizable, so you should also be able to create, for example, INPUT+ greets
    Berlin. The location should be read using the `GreetingProperties`. To trigger
    this code, use the Application class, autowire the service here, and execute it
    with sample data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the output screenshot, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c610792-e841-4a13-9d0f-d94ff777f835.png)'
  prefs: []
  type: TYPE_IMG
- en: To refer to the detailed steps, go to the *Solutions* section at the end of this
    book on page 250.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have seen how you can inject Spring Beans into other Beans
    and how you can help Spring in cases where the injector is not uniquely identifiable.
    You also saw how you can configure your application with profiles and configuration
    files.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will finally start looking at ways we can test our Spring
    Boot applications.
  prefs: []
  type: TYPE_NORMAL
