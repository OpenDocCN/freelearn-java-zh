- en: Building a Spring Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Spring应用程序
- en: In this chapter, you will learn how to interact with Spring Beans and how to
    configure your Spring context. This is the foundation that every Spring application
    is built on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何与Spring Beans交互以及如何配置你的Spring上下文。这是每个Spring应用程序构建的基础。
- en: In the previous chapter, you learnt about how to create a Spring Boot project,
    the basic building blocks and the application context were also introduced. Lastly,
    you saw how to utilize Lombok to free you from creating or writing the same code
    over and over again.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何创建Spring Boot项目，介绍了基本构建块和应用程序上下文。最后，你看到了如何利用Lombok来让你摆脱重复创建或编写相同代码的烦恼。
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Organize dependencies between Spring Beans
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织Spring Beans之间的依赖关系
- en: Create configuration classes to define Beans by hand
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建配置类以手动定义Beans
- en: Organize Configuration Properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织配置属性
- en: Create strongly typed Property Classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建强类型属性类
- en: Dependency Injection in Spring
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring中的依赖注入
- en: In this section, you will see how Spring Beans can depend on each other to provide
    functionality. The Spring Container uses the Beans in the context to inject dependencies
    into other managed instances. This enables you to write concise classes that just
    express their dependencies, and Spring takes care of the rest.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将看到Spring Beans如何相互依赖以提供功能。Spring容器使用上下文中的Beans将依赖项注入到其他管理实例中。这使得你可以编写简洁的类，只需表达它们的依赖项，Spring负责其余部分。
- en: There is a singleton with a `HashMap` and dedicated factories that create and
    wire up instances. Additionally, there are base classes that inspect the class
    and utilize some kind of singleton to look up other instances.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个单例，它使用`HashMap`和专用工厂来创建和连接实例。此外，还有基类可以检查类并利用某种单例来查找其他实例。
- en: '**Aspect-oriented programming** (to intercept missing dependencies), `classpath`
    scanning (to find available dependencies and injection points), and Inversion
    of Control (to have control over the application lifecycle).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向切面编程**（用于拦截缺失的依赖项），`classpath`扫描（用于查找可用依赖项和注入点），以及控制反转（以控制应用程序生命周期）。'
- en: Autowiring
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动装配
- en: Dependency Injection, which is the pattern to introduce the Inversion of Control
    for resolving dependencies, is called **Autowiring** in Spring. When Bean-A gets
    a reference for Bean-B injected, it is **autowired**. Autowiring only works for
    Spring Beans, so both need to be known to the **Spring Application Context**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入，这是一种引入控制反转以解决依赖项的模式的Spring中的术语，称为**自动装配**。当Bean-A获得对Bean-B的注入引用时，它就是**自动装配**的。自动装配仅适用于Spring
    Beans，因此两者都需要被**Spring应用程序上下文**所知晓。
- en: 'Take a look at the sample code below:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的示例代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example code defines a Bean that requires the JDBC DataSource to query
    the database. As you can see, the field does not need to be public – it can even
    be private. Spring achieves this by using reflection, which is a standard Java
    feature. It allows you to create classes that have a very limited public interface,
    which makes it easier to communicate the intent of a class with code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例代码定义了一个需要JDBC数据源来查询数据库的Bean。正如你所见，字段不需要是公共的——甚至可以是私有的。Spring通过使用反射来实现这一点，这是Java的一个标准特性。它允许你创建具有非常有限的公共接口的类，这使得用代码传达类的意图变得更容易。
- en: You might know JavaEE annotations such as `@Inject`. `@Autowired` is the corresponding
    annotation in Spring. Spring aims to be developer-friendly, so `@Inject` also
    works in Spring applications. However, the parameters differ, so you should stick
    to plain Spring annotations if there is no special need to use the JavaEE versions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道JavaEE注解，如`@Inject`。`@Autowired`是Spring中的对应注解。Spring旨在对开发者友好，所以`@Inject`在Spring应用程序中也适用。然而，参数不同，所以如果没有特殊需要使用JavaEE版本，你应该坚持使用普通的Spring注解。
- en: Injection Types
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入类型
- en: In Spring, you have a couple of ways to get access to Beans that are in the
    context. You have already seen **Field Injection**, which has been used to autowire
    the `DataSource`, but there are more ways to get Beans injected.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，你有几种方法可以访问上下文中的Beans。你已经看到了**字段注入**，它被用来自动装配`DataSource`，但还有更多方法可以注入Beans。
- en: 'You can use Autowiring in:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下方面使用自动装配：
- en: Fields
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段
- en: Properties
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: Config Methods
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置方法
- en: Constructors
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数
- en: When Spring has completely resolved the dependencies of a Bean, it looks for
    a method that is annotated with `PostConstruct` and executes it. There, you can
    perform some final initialization, which will utilize all defined dependencies.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Spring 完全解析了一个 Bean 的依赖关系后，它会寻找一个注解了 `PostConstruct` 的方法并执行它。在那里，您可以执行一些最终的初始化，这将利用所有定义的依赖项。
- en: Field Injection
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段注入
- en: Field injection is the simplest way to get hold of another Bean. Just annotate
    the field with `@Autowired` and the instance will be there after the Bean's creation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 字段注入是获取另一个 Bean 的最简单方式。只需在字段上注解 `@Autowired`，Bean 创建后实例就会存在。
- en: '`TestBase` and `TestClass` are at [https://bit.ly/2RSCHrf](https://bit.ly/2RSCHrf),
    in the `blogmaniaexercise-solution` project folder. When you start the test, you
    will see that the instance information for `MyConfiguration` is printed twice,
    although one is defined in the abstract base class. This helps to group shared
    functionality in base classes.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestBase` 和 `TestClass` 位于 [https://bit.ly/2RSCHrf](https://bit.ly/2RSCHrf)，在
    `blogmaniaexercise-solution` 项目文件夹中。当您启动测试时，您会看到 `MyConfiguration` 的实例信息被打印了两次，尽管其中一个是在抽象基类中定义的。这有助于在基类中分组共享功能。'
- en: Go to [https://bit.ly/2Mp9kcZ](https://bit.ly/2Mp9kcZ) to access the code for
    the `TestBase.java` file. Go to [https://bit.ly/2CNj6WG](https://bit.ly/2CNj6WG)
    to access the code for the `TestClass.java` file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://bit.ly/2Mp9kcZ](https://bit.ly/2Mp9kcZ) 访问 `TestBase.java` 文件的代码。前往
    [https://bit.ly/2CNj6WG](https://bit.ly/2CNj6WG) 访问 `TestClass.java` 文件的代码。
- en: Property Injection
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性注入
- en: You can add `@Autowired` for setters as well. This will trigger the so-called
    **Config Method** mechanism. Spring will call the method when the dependencies
    are available after the constructor has been called.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以为设置器添加 `@Autowired`。这将触发所谓的 **配置方法** 机制。Spring 会在构造函数调用后，依赖项可用时调用该方法。
- en: A property usually means that you have a field that follows the Java Bean Standard.
    For example, a property of type String named `foo` will have `setFoo(String …)`
    and String `getFoo()` methods. There are also read-only and write-only properties,
    where one of these is missing. `boolean` fields have a Getter starting with `is`,
    so `isFoo()` would be the correct name in this case.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 属性通常意味着您有一个遵循 Java Bean 标准的字段。例如，一个名为 `foo` 的 String 类型的属性将具有 `setFoo(String
    …)` 和 String `getFoo()` 方法。也存在只读和只写属性，其中之一可能缺失。`boolean` 字段有一个以 `is` 开头的 Getter，所以在这种情况下
    `isFoo()` 将是正确的名称。
- en: Config Method Injection
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置方法注入
- en: Spring is able to call a method after the instance has been created and the
    constructor has been executed. This method can have any number of parameters which
    should be resolvable with Beans from the Spring Context. The method should return
    void; the name is arbitrary and the method does not have to be public.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 能够在实例创建后、构造函数执行后调用一个方法。该方法可以有任何数量的参数，这些参数应可由 Spring 上下文中的 Bean 解析。该方法应返回
    void；名称是任意的，方法不必是公共的。
- en: You can have more than one of these and they will be executed in an undefined
    order.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以有多个这样的方法，并且它们将以未定义的顺序执行。
- en: As you can see, this fully covers property injection as well.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这完全涵盖了属性注入。
- en: Constructor Injection
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: Constructor injection is the way to inject Beans that is preferred by the Spring
    Framework team. You just create a constructor with all the required Beans as parameters
    and then you assign these values to your fields if required. You might also do
    something else with the provided dependencies, such as calling a method on it
    to fetch some data, for example. So, you do not have to store the value somewhere
    if you don't need it after the constructor is finished. If you have multiple constructors
    that have parameters, then you need to qualify one constructor by adding the `@Autowired`
    annotation to it. Otherwise, this can be omitted.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数注入是 Spring 框架团队首选的注入 Bean 的方式。您只需创建一个带有所有必需 Bean 参数的构造函数，然后根据需要将这些值分配给您的字段。您也可能对提供的依赖项做些其他事情，例如调用它上的方法来获取一些数据，例如。因此，如果您在构造函数完成后不需要存储值，则不需要将其存储在某个地方。如果您有多个具有参数的构造函数，则需要通过添加
    `@Autowired` 注解来指定其中一个构造函数。否则，这可以省略。
- en: As you may recall, we use Project Lombok to avoid unnecessary code. This can
    be used here as well. Just add `AllArgsConstructor` or `@RequiredArgsConstructor`
    to your class and Spring will automatically use this generated constructor. You
    do not need to create one yourself or even add `@Autowired` anywhere.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所回忆，我们使用Project Lombok来避免不必要的代码。这也可以在这里使用。只需将`@AllArgsConstructor`或`@RequiredArgsConstructor`添加到你的类中，Spring将自动使用这个生成的构造函数。你不需要自己创建一个，甚至不需要在任何地方添加`@Autowired`。
- en: Circular Dependencies
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环依赖
- en: When you have two or more Spring Beans that form a dependency circle, Spring
    might have a problem creating the Spring context when you use Constructor Injection
    everywhere.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有两个或更多Spring Bean形成依赖循环时，如果你在所有地方都使用构造函数注入，Spring可能会在创建Spring上下文时遇到问题。
- en: 'Example Dependencies:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 示例依赖关系：
- en: Bean-A => Bean-B => Bean-C => Bean-A
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Bean-A => Bean-B => Bean-C => Bean-A
- en: Spring has no chance to solve this when all Beans use constructor injection,
    because the instances cannot be instantiated without the others.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有Bean都使用构造函数注入时，Spring没有机会解决这个问题，因为实例不能在没有其他实例的情况下实例化。
- en: 'There are ways to work around that, but first you should reconsider if this
    is really the right solution; most circular dependencies are a symptom of bad
    design. If there is no way around it, you can configure Spring to solve that by
    doing the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些方法可以解决这个问题，但首先你应该重新考虑这真的是正确的解决方案；大多数循环依赖都是设计不良的症状。如果无法解决这个问题，你可以通过以下方式配置Spring来解决这个问题：
- en: 'Creating a dynamic proxy:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动态代理：
- en: For this, you need to change at least one of the constructors (it cannot be
    generated by Lombok).
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，你需要至少更改其中一个构造函数（它不能由Lombok生成）。
- en: Then, you can mark the constructor parameter by adding `@Lazy` to the type,
    which tells Spring that this dependency is not needed during class creation when
    the Spring Context is built.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以通过在类型上添加`@Lazy`来标记构造函数参数，这告诉Spring在构建Spring上下文时创建类时不需要这个依赖。
- en: Spring will create a proxy around the instance which is working as a facade
    in front of the real instance which is fetched from the context when it's accessed
    for the first time.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当第一次访问时，Spring会在从上下文中获取的真实实例前面创建一个代理实例，该实例作为门面工作。
- en: 'Use Field-/Config-Method-Injection for the first class: When you use these
    injection styles, Spring can defer the resolution of the Bean until the other
    dependencies are met. You can see the first class in the error message that Spring
    prints out during startup.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第一个类使用字段/配置方法注入：当你使用这些注入风格时，Spring可以在满足其他依赖关系之前延迟解析Bean。你可以在Spring在启动时打印出的错误信息中看到第一个类。
- en: To mark the dependency as "`lazy`", you just place the `@Lazy annotation` before
    or after the type.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要将依赖标记为“`懒加载`”，你只需在类型前或后放置`@Lazy注解`。
- en: 'Take a look at the following sample code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下示例代码：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Qualify Beans
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限定Bean
- en: If you have multiple Beans with the same type, then Spring won't be able to
    detect which instance should be assigned. In this case, the application will refuse
    to start and present an error message that explains what is going wrong.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多于一个相同类型的Bean，那么Spring将无法检测出应该分配哪个实例。在这种情况下，应用程序将拒绝启动并显示一个错误信息，解释出了什么问题。
- en: By default, Spring will try to match the name of the parameter/field with the
    names of the Beans of the corresponding type, but if you need a specific Bean
    and the name does not match, you can just add an annotation to resolve that manually.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring会尝试将参数/字段的名称与相应类型的Bean的名称匹配，但如果你需要一个特定的Bean且名称不匹配，你只需添加一个注解来手动解决。
- en: 'For example, you can use the following code to fetch the `myDate` Bean from
    the context:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用以下代码从上下文中获取`myDate` Bean：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can access the Application Context directly and fetch a Bean by type or
    name from there if necessary. You can implement the `ApplicationContextAware`
    interface and Spring will provide a reference to the Application Context for you.
    This should only be used in rare cases, as most of the time, the "static wiring"
    should be sufficient.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你可以直接访问应用程序上下文并从那里通过类型或名称获取Bean。你可以实现`ApplicationContextAware`接口，Spring将为你提供应用程序上下文的引用。这应该只在极少数情况下使用，因为在大多数情况下，“静态绑定”应该足够了。
- en: Bean Scopes
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bean作用域
- en: By now, you have seen how you can define Spring Beans, and you saw that one
    instance is usually created when the application starts. But there are other use
    cases where this is not the right choice.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了如何定义Spring Bean，你也看到了通常在应用程序启动时创建一个实例。但还有其他用例，这种选择并不合适。
- en: 'To specify a scope, just add the `@Scope` annotation to the Bean definition:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定作用域，只需将`@Scope`注解添加到Bean定义中：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The default scope of a Bean is `singleton`, which means there is one instance
    of the Bean in the container and this is returned by the Spring Context. The scope
    reference itself is just a String.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Bean的默认作用域是`singleton`，这意味着容器中有一个Bean的实例，并且这个实例是由Spring上下文返回的。作用域引用本身只是一个字符串。
- en: The second standard scope is `prototype`, which returns a new instance whenever
    a Bean with that name is requested from the Context. So, if you define Bean-A
    with the prototype scope and Bean-C and Bean-D have an autowired field for Bean-A,
    then both will get their own instance. This is handy when the Bean has some kind
    of state that should not be shared with other Beans, such as caches, for example.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个标准作用域是`prototype`，每次从上下文中请求具有该名称的Bean时都会返回一个新的实例。因此，如果你使用原型作用域定义了Bean-A，而Bean-C和Bean-D都有一个自动装配的字段为Bean-A，那么它们都将获得自己的实例。当Bean具有某种不应与其他Bean共享的状态时，这很有用，例如缓存等。
- en: There are also other scopes such as `request` and `session`, which are specific
    to Spring WebMVC and will be covered later. You can even define your own scopes,
    but this is an advanced section that we won't cover in this book.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他作用域，如`request`和`session`，这些是Spring WebMVC特有的，将在后面介绍。你甚至可以定义自己的作用域，但这是一个高级章节，我们不会在本书中介绍。
- en: Spring provides static constants for the scopes in a few places. The regular
    scopes are defined in the `ConfigurableBeanFactory` class, while the web application-specific
    scopes are defined in `WebApplicationContext`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Spring在几个地方提供了作用域的静态常量。常规作用域在`ConfigurableBeanFactory`类中定义，而特定于Web应用程序的作用域在`WebApplicationContext`中定义。
- en: Configuration Classes
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置类
- en: You have seen how to declare Spring Beans by annotating the class definition.
    This is the most common use case, but sometimes you need more control during the
    creation of a Bean. This is where configuration classes come into play. They are
    basically classes with factory methods for Beans. This can be used to create Beans
    of classes that are defined outside of your code base or, for example, to return
    a specific implementation of an interface depending on some configuration values.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何通过注解类定义来声明Spring Bean。这是最常见的用例，但有时在创建Bean的过程中需要更多的控制。这就是配置类发挥作用的地方。它们基本上是具有Bean工厂方法的类。这可以用来创建代码库外定义的类的Bean，例如，根据某些配置值返回接口的特定实现。
- en: Configuration classes are Spring Beans too, so you can use autowired dependencies
    here as well, but constructor injection should be avoided.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 配置类也是Spring Bean，因此你可以在其中使用自动装配的依赖项，但应避免构造函数注入。
- en: 'This is what a configuration class looks like:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是配置类的样子：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `MyConfiguration` class in the provided source code for this section contains
    even more Beans with their corresponding JavaDoc.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供的源代码中的`MyConfiguration`类包含更多具有相应JavaDoc的Bean。
- en: The default behavior for configuration classes is to return the correct instance
    from the Spring Context. So, when you autowire a configuration class somewhere
    and call a method that is annotated with `@Bean`, the method may not be executed
    and the result from the Spring Context is returned instead. This is even true
    when you call a `@Bean` method from within the same Configuration. Using configuration
    classes as dependencies in "regular" Beans is technically possible, but not commonly
    done. Most projects use dedicated Factory Beans for a single type or a set of
    types.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 配置类的默认行为是从Spring上下文中返回正确的实例。因此，当你在一个配置类中自动装配并调用一个带有`@Bean`注解的方法时，该方法可能不会执行，而是返回Spring上下文的结果。即使在同一个配置中调用`@Bean`方法也是如此。将配置类作为“常规”Bean的依赖项在技术上可行，但并不常见。大多数项目使用专门的Factory
    Bean来处理单个类型或一组类型。
- en: Utilizing Bean Interdependencies
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Bean依赖关系
- en: The aim is to utilize Bean interdependencies to relay data to the repository.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是利用Bean依赖关系将数据传递到仓库。
- en: 'The steps for completion are as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 完成步骤如下：
- en: Open the IDE and the `BlogMania` application ([https://bit.ly/2QpUDd1](https://bit.ly/2QpUDd1))
    for this section.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开IDE和本节的`BlogMania`应用程序([https://bit.ly/2QpUDd1](https://bit.ly/2QpUDd1))。
- en: Move the `BlogService` and `BlogRepository` to the `com.packt.springboot.blogmania.blogentries.service` package.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BlogService`和`BlogRepository`移动到`com.packt.springboot.blogmania.blogentries.service`包中。
- en: 'Take a look at the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的截图：
- en: '![](img/79d60584-3e5c-4022-8137-cb0578776b1d.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/79d60584-3e5c-4022-8137-cb0578776b1d.png)'
- en: Right-click on the blogentries package and create the new package from there.
    Then, drag and drop the classes into the package.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击 blogentries 包，并从那里创建新的包。然后，将类拖放到包中。
- en: 'You have now created your own Spring Bean and used it in a business context
    in order to solve the task and save the data in memory. Take a look at the output
    screenshot, as shown below:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经创建了自己的 Spring Bean，并在业务场景中使用它来解决任务并将数据保存在内存中。请查看下面的输出截图，如下所示：
- en: '![](img/04552a82-45fc-4fe7-a55d-4e76e66d4033.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/04552a82-45fc-4fe7-a55d-4e76e66d4033.png)'
- en: Go to [https://bit.ly/2OeUPtQ](https://bit.ly/2OeUPtQ) to access the code for
    the `BlogmaniaApplicationTests.java` file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://bit.ly/2OeUPtQ](https://bit.ly/2OeUPtQ) 访问 `BlogmaniaApplicationTests.java`
    文件的代码。
- en: Configuration of Spring Boot Applications
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot 应用程序的配置
- en: In the previous section, you saw how to connect Spring Beans and which mechanism
    you can use to achieve that.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您了解了如何连接 Spring Beans 以及可以使用哪种机制来实现这一点。
- en: When you write your application, you will encounter aspects of your application
    that need to be configurable. If you use a database, you will have different database
    configurations; maybe features that are enabled or disabled, or something like
    that.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写应用程序时，您将遇到需要可配置性的应用程序方面。如果您使用数据库，您将拥有不同的数据库配置；也许某些功能是启用或禁用的，或者类似的情况。
- en: In a Spring Boot application, you don't need to handle this yourself. Spring
    Boot has a very sophisticated system in place to configure your application with
    ease, even in complex scenarios.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring Boot 应用程序中，您不需要自己处理这个问题。Spring Boot 有一个非常复杂的系统，可以轻松地配置您的应用程序，即使在复杂场景下也是如此。
- en: In this section, you will create profiles to target different environments and
    configure the application with property and **YAML** (**YAML Ain't Markup Language**)
    files. You also will see the search order for properties in action with which
    you can configure your Spring Beans in multiple ways.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将创建针对不同环境的配置文件，并使用属性和 **YAML**（**YAML 不是标记语言**）文件配置应用程序。您还将看到属性搜索顺序的实际操作，您可以使用它以多种方式配置您的
    Spring Beans。
- en: Profiles
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置文件
- en: Spring applications have a simple mechanism to tell your application that it
    runs in different environments or modes. The application has "Active Profiles",
    which can influence how the application is configured or behaves. The profiles
    are ordered lists of words. Each of these words is a profile. If none is given,
    it is a default.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 应用程序有一个简单的机制来告诉您的应用程序它在不同的环境或模式下运行。应用程序有“活动配置文件”，它可以影响应用程序的配置或行为。配置文件是一系列单词的有序列表。这些单词中的每一个都是一个配置文件。如果没有给出任何内容，则默认为默认配置文件。
- en: For example, you can start the application with the additional command-line
    parameter `--spring.profiles.active=peter`,`dev`,`postgres`. As you can see, each
    profile is separated by a comma.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用额外的命令行参数 `--spring.profiles.active=peter`,`dev`,`postgres` 来启动应用程序。如您所见，每个配置文件之间由逗号分隔。
- en: This means that the profiles `peter`, `dev`, and `postgres` are active. In the
    following slides, you will see what you can do with these profiles.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着配置文件 `peter`、`dev` 和 `postgres` 都是激活的。在接下来的幻灯片中，您将看到您可以使用这些配置文件做什么。
- en: Conditional Beans
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件 Beans
- en: When you need to enable or disable certain Beans when a profile is active, you
    can use a simple annotation at the Bean definition. This can either be a configuration
    class, the annotated class definition, or the `@Bean` annotated methods.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要在配置文件激活时启用或禁用某些 Beans 时，您可以在 Bean 定义中使用一个简单的注解。这可以是配置类、注解的类定义或 `@Bean` 注解的方法。
- en: 'For this, you just need to add the `@Profile` annotation at the class or method
    definition. The following code snippet is copied from the `MyConfiguration` class
    ([https://bit.ly/2oYUl05](https://bit.ly/2oYUl05)) and configures the `theConfiguredDate`
    Bean, which is a fixed point in time in dev mode (maybe for tests) and the current
    date and time when the dev profile is not set. Due to the fact that we can''t
    have both methods named the same, we used a feature of the `@Bean` annotation
    to override the default name of the bean with `theConfiguredDate`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，您只需要在类或方法定义中添加 `@Profile` 注解。以下代码片段是从 `MyConfiguration` 类中复制的（[https://bit.ly/2oYUl05](https://bit.ly/2oYUl05)），并配置了
    `theConfiguredDate` Bean，这是一个在开发模式下的固定时间点（可能是用于测试）以及当未设置开发配置文件时的当前日期和时间。由于我们不能有两个方法具有相同的名称，我们使用了
    `@Bean` 注解的一个特性来用 `theConfiguredDate` 覆盖 Bean 的默认名称：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `@Profile` annotations can also take a list of profiles, which in this case
    is any of the given profiles that are sufficient enough to trigger the Bean's
    creation. This means that the profiles are evaluated with an implicit `or`, not
    an `and`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Profile` 注解也可以接受一个配置文件列表，在这种情况下，任何足够的给定配置文件都可以触发 Bean 的创建。这意味着配置文件是以隐式的 `or`（或）方式评估的，而不是
    `and`（与）方式。'
- en: '**Example**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There is also a `@Primary` annotation on a Bean definition, which can be used
    to mark a Bean as a default Bean for a given type. This is used when there are
    multiple Beans that would match the type. To select one of the other Beans, you
    would need to add the `@Qualifier` annotation with the correct Bean name.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bean 定义上还有一个 `@Primary` 注解，可以用来标记一个 Bean 作为给定类型的默认 Bean。当有多个 Bean 匹配该类型时使用。要选择其他
    Bean 中的一个，你需要添加带有正确 Bean 名称的 `@Qualifier` 注解。
- en: Utilizing Conditional Beans for Various Implementations
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用条件 Bean 进行各种实现
- en: The aim is to utilize conditional Spring Beans, which can be used, for example,
    to switch (or select) between different implementations. Before beginning, please
    reuse the existing project. Go to [https://bit.ly/2oYUl05](https://bit.ly/2oYUl05)
    to access the code for the blogmania directory.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是利用条件 Spring Bean，这可以用来在例如不同实现之间切换（或选择）。在开始之前，请重用现有项目。前往 [https://bit.ly/2oYUl05](https://bit.ly/2oYUl05)
    访问 blogmania 目录的代码。
- en: 'The steps for completion are as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的步骤如下：
- en: Create an interface called **Randomizer** with a method that returns a double
    and has no parameters.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 **Randomizer** 的接口，其中包含一个返回 double 类型且没有参数的方法。
- en: 'Take a look at the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下截图：
- en: '![](img/584bbe21-3d77-4358-9b75-ef186fcf3c22.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/584bbe21-3d77-4358-9b75-ef186fcf3c22.png)'
- en: Create an implementation that returns a random number using the `nextDouble()`
    method of the `Random` class and make it a Bean.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实现，使用 `Random` 类的 `nextDouble()` 方法返回一个随机数，并将其作为一个 Bean。
- en: Create an implementation that always returns, for example, `3`. Make this a
    Bean that is active when the test profile is active. It should replace or override
    the other Bean.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个始终返回，例如，`3` 的实现。使其成为在测试配置文件活动时激活的 Bean。它应该替换或覆盖其他 Bean。
- en: 'You have seen how you can override a Bean for tests, which helps you to write
    concise and reliable tests. Take a look at the output screenshot, as shown below:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何覆盖测试中的 Bean，这有助于你编写简洁和可靠的测试。 查看下面的输出截图，如下所示：
- en: '![](img/d341628a-2060-46bd-9bff-3a8fe198f390.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/d341628a-2060-46bd-9bff-3a8fe198f390.png)'
- en: Go to [https://bit.ly/2x8v1s5](https://bit.ly/2x8v1s5) to access the code for
    the `BlogmaniaApplication.java` file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 [https://bit.ly/2x8v1s5](https://bit.ly/2x8v1s5) 访问 `BlogmaniaApplication.java`
    文件的代码。
- en: Spring Configuration Files
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 配置文件
- en: Spring Boot applications are created by the Spring Initializr by default with
    an empty `application.properties` file in the resource folder. This is the default
    configuration file. You can write all default configurations there in the property
    file format, which we will see in more detail soon.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 应用程序默认由 Spring Initializr 创建，在资源文件夹中有一个空的 `application.properties`
    文件。这是默认配置文件。你可以在属性文件格式中写入所有默认配置，我们将在稍后更详细地介绍。
- en: Next to the `application.properties` file, you can place more configuration
    files that are loaded based on active profiles.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `application.properties` 文件旁边，你可以放置更多基于活动配置文件加载的配置文件。
- en: You can create an `application-dev.properties` file there and it will only be
    loaded when the dev profile is active. We will cover the order in which property
    values are applied in a dedicated section soon.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在那里创建一个 `application-dev.properties` 文件，并且它只有在 dev 配置文件活动时才会被加载。我们将在专门的章节中很快介绍属性值应用的顺序。
- en: Property Files
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性文件
- en: Property files are very common in the Java ecosystem and are even older than
    the now commonly disliked XML files.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 属性文件在 Java 生态系统中非常常见，甚至比现在普遍不喜欢的 XML 文件还要古老。
- en: 'The format is simple:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 格式很简单：
- en: Values are stored in a `Key=value` fashion where the key usually consists of
    lower case dot-separated words, and the value following the `=` may contain blanks.
    Multiline values need to have a `\` at the end of the line that is continued in
    the next line.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值以 `Key=value` 的形式存储，其中键通常由小写点分隔的单词组成，而 `=` 后的值可能包含空格。多行值需要在下一行的末尾加上一个 `\` 以表示行继续。
- en: Comment lines start with a `#` and are ignored by the parser.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释行以 `#` 开头，并被解析器忽略。
- en: You can have empty lines.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以有空白行。
- en: Using the mechanism with the profile-based files, you can set or override values.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于配置文件的机制，你可以设置或覆盖值。
- en: 'An example configuration looks like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例配置看起来像这样：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Property files should always be encoded in ISO-8859-1, otherwise you will end
    up with weird results. It may work in tests but breaks when you start the application
    or vice-versa.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 属性文件应该始终使用ISO-8859-1编码，否则你可能会得到奇怪的结果。在测试中可能工作，但当你启动应用程序或反之亦然时可能会出错。
- en: YAML Files
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAML文件
- en: '**YAML** (**YAML Ain''t Markup Language**) files are another syntax to create
    configuration files in Spring Boot.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**YAML**（YAML Ain''t Markup Language）文件是创建Spring Boot配置文件的另一种语法。'
- en: 'The format is basically defined by the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 格式基本上由以下定义：
- en: 'Values are stored in a `key: value` fashion.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '值以`key: value`的形式存储。'
- en: YAML supports `subkeys` which are simply indented. Keys on the same level are
    grouped together until the next key is less indented.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAML支持`子键`，这些子键只是简单地缩进。同一级别的键会组合在一起，直到下一个键的缩进更少。
- en: Lists are supported by using a subgroup where each line starts with a dash.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表通过使用一个子组来支持，其中每一行都以短横线开头。
- en: Comments start with a `#`.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释以`#`开头。
- en: 'The property example as YAML looks like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 属性示例在YAML中看起来像这样：
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see that the dot still works as a group separator, but if you have multiple
    keys with the same parent groups, you can use this shorter version. This is especially
    handy with the deep key structure of the Spring configuration values.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到点号仍然作为组分隔符使用，但如果你有多个具有相同父组的键，你可以使用这个较短的版本。这对于Spring配置值的深层键结构来说特别方便。
- en: Multi-Profile YAML Files
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多配置文件YAML文件
- en: Using YAML files, you can use a special format to define values that are only
    active in a given profile.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用YAML文件，你可以使用一种特殊格式来定义仅在给定配置文件中激活的值。
- en: 'To do this, you use three dashes followed by the `spring.profile` key with
    the profile that this block is supposed to be active in. Here, you can even use
    the negated syntax to set values when a profile is not set:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，你使用三个短横线后跟`spring.profile`键以及此块应该激活的配置文件。在这里，你甚至可以使用否定语法来设置当配置文件未设置时的值：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This advanced mechanism is specified in the YAML standard, but some YAML validators
    may mark this as a no longer valid YAML file. The parsers cut the YAML files at
    the dashes and handle them internally as different (virtual) files. If you have
    static lint checkers on your source code, they might complain about this syntax.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种高级机制在YAML标准中指定，但某些YAML验证器可能会将其标记为不再有效的YAML文件。解析器在短横线处截断YAML文件，并在内部将它们作为不同的（虚拟）文件处理。如果你在源代码上有静态代码检查器，它们可能会对此语法提出异议。
- en: A **lint checker** is a program that checks files for syntax errors or common
    mistakes. There are lint checkers available for many file types and programming
    languages.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码检查器**是一个检查文件中的语法错误或常见错误的程序。许多文件类型和编程语言都有可用的代码检查器。'
- en: External Configuration Locations
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部配置位置
- en: The files that we have discussed are located in the classpath, but you might
    have the need to have some host- or environment-specific configuration that you
    don't want to check into version control. For example, your security department
    will not be pleased when production database credentials are hosted in the widely
    accessible Git repository.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的文件位于类路径中，但你可能需要一些主机或环境特定的配置，你不想将其提交到版本控制中。例如，如果你的安全部门不高兴，当生产数据库凭据托管在广泛可访问的Git仓库中时。
- en: The Spring documentation lists 17 different ways of how configuration values
    can be set or overwritten. We will omit a few of the advanced ways for brevity,
    but if you want to see them all, please visit [https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Spring文档列出了17种不同的设置或覆盖配置值的方法。为了简洁起见，我们将省略一些高级方法，但如果你想查看所有方法，请访问[https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html)。
- en: Whenever Spring looks up a configuration value, it searches this list for the
    value. As soon as the value is found, the search stops.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当Spring查找配置值时，它会搜索这个列表以找到该值。一旦找到值，搜索就会停止。
- en: 'The following files that are outside the JAR are searched for in the current
    working directory by default:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，以下位于JAR文件之外的文件将在当前工作目录中搜索：
- en: Command-line arguments
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行参数
- en: Properties from `SPRING_APPLICATION_JSON` (inline JSON embedded in an environment
    variable or system property)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 `SPRING_APPLICATION_JSON` 的属性（嵌入在环境变量或系统属性中的内联 JSON）
- en: Java System properties (set using `-Dmy.config.key=value`)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 系统属性（使用 `-Dmy.config.key=value` 设置）
- en: OS environment variables (often used with Docker containers)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统环境变量（通常与 Docker 容器一起使用）
- en: Profile-specific application properties outside of your packaged JAR (`application-{profile}.properties`
    and `YAML variants`)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你打包的 JAR 文件外的特定配置文件的应用程序属性（`application-{profile}.properties` 和 `YAML` 变体）
- en: Profile-specific application properties packaged inside your JAR (`application-{profile}.properties`
    and `YAML variants`)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含在你 JAR 文件内的特定配置文件的应用属性（`application-{profile}.properties` 和 `YAML` 变体）
- en: Application properties outside of your packaged JAR (`application.properties`
    and `YAML variants`)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你打包的 JAR 文件外的应用程序属性（`application.properties` 和 `YAML` 变体）
- en: Application properties packaged inside your JAR (`application.properties` and
    `YAML variants`)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含在你 JAR 文件内的应用程序属性（`application.properties` 和 `YAML` 变体）
- en: '`@PropertySource` annotations on your `@Configuration` classes (used to load
    additional property files, but no YAML!)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的 `@Configuration` 类上的 `@PropertySource` 注解（用于加载额外的属性文件，但不包括 YAML！）
- en: It is a bit surprising that the files loaded via `@PropertySource` are evaluated
    last, but the rest is very sensible and enables you to package default values
    with your application and override them for the concrete instance that is running
    on a host or in a container.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 意外地是，通过 `@PropertySource` 加载的文件是最后被评估的，但其余的部分非常合理，并允许你将默认值打包到你的应用程序中，并覆盖在主机或容器上运行的特定实例。
- en: Placeholders in Configuration Files
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置文件中的占位符
- en: 'Within a configuration file, you can use a very simple variable replacement
    mechanism which is evaluated when the configuration values are all loaded, so
    even when the replacement refers to a value that is defined in the same file,
    it still can be overridden, for example, by a profile or system property. The
    mechanism works for property and YAML files:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置文件中，你可以使用一个非常简单的变量替换机制，该机制在所有配置值加载时被评估，因此即使替换引用的是同一文件中定义的值，它仍然可以被覆盖，例如，由配置文件或系统属性。该机制适用于属性和
    YAML 文件：
- en: '[PRE10]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will set the description of the application to whatever is set as `spring.
    application.name` plus is so nice. The syntax looks a lot like **SpEL** (**Spring
    Expression Language**), but is limited to simple variable replacement. SpEL will
    be briefly covered soon.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置应用程序的描述为 `spring.application.name` 设置的内容加上一些很棒的东西。语法看起来很像 **SpEL**（**Spring
    表达式语言**），但它仅限于简单的变量替换。SpEL 将很快被简要介绍。
- en: Accessing Environment Values
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问环境值
- en: We have seen many ways to define configuration values, but we have not used
    them yet. Spring offers multiple ways to access these values. The oldest way is
    to let Spring autowire an instance with the `Environment` type into your Bean.
    This offers ways to access configuration values using code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多定义配置值的方法，但我们还没有使用它们。Spring 提供了多种访问这些值的方式。最老的方式是让 Spring 自动装配一个具有 `Environment`
    类型的实例到你的 Bean 中。这提供了使用代码访问配置值的方法。
- en: 'Take a look at the example code below: (excerpt from `BlogService.java`):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下面的示例代码：（来自 `BlogService.java` 的摘录）：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `log.info(...)` is provided by Project Lombok's `@Slf4j` annotation, which
    creates a static logger that's configured for the class with the name `log` for
    you.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`log.info(...)` 是由 Project Lombok 的 `@Slf4j` 注解提供的，它为你创建了一个静态的配置了名为 `log` 的类的日志记录器。'
- en: Annotated Fields
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解字段
- en: Using the Environment instance directly is a bit cumbersome, so the Spring developers
    created another annotation called `@Value` which is capable of accessing data
    from the environment and assigning it to a field. The field can be of any type
    that is supported out of the box such as primitive types or other default Java
    classes, or you can provide a `ConversionService` or `PropertyEditors` which are
    mechanisms that Spring uses to convert data to and from strings. Being able to
    create your own converters is out of the scope of this book.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用 Environment 实例有点繁琐，因此 Spring 开发者创建了一个名为 `@Value` 的另一个注解，它能够从环境中访问数据并将其分配给一个字段。该字段可以是任何开箱即用的类型，如原始类型或其他默认的
    Java 类，或者你可以提供一个 `ConversionService` 或 `PropertyEditors`，这些是 Spring 用于将数据转换为字符串以及从字符串转换回数据的机制。能够创建自己的转换器超出了本书的范围。
- en: 'Take a look at the example code below: (excerpt from `BlogService.java`):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下面的示例代码：（来自 `BlogService.java` 的摘录）：
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This loads the value using the key `my.config.feature.flag` and converts it
    to a `boolean` value. The value is false by default when the config key is not
    set. Therefore, the syntax is `@Value("${KEY:DEFAULT}")` with the default value
    and `@Value("${KEY}")` without. The default value is the string representation
    of the default value in the same format that you expect in the config file.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用键`my.config.feature.flag`加载值并将其转换为`boolean`值。当配置键未设置时，默认值为false。因此，语法是`@Value("${KEY:DEFAULT}")`，其中包含默认值，以及没有默认值的`@Value("${KEY}")`。默认值是配置文件中期望的默认值的字符串表示形式。
- en: Lists are values that are set with square brackets and comma separated values
    like `[1,3,5,7,9];` which is a list of odd integer values.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是使用方括号和逗号分隔的值设置的，例如`[1,3,5,7,9]`，这是一个奇数整数的列表。
- en: Spring Expression Language
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring表达式语言
- en: The **Spring Expression Language** (**SpEL**) is similar to the Unified EL,
    which was created for Java Server Pages (JSP) in 2006\. It supports querying and
    manipulating the Spring Context. You can think of it as a lightweight scripting
    language. The SpEL can be used by your code if you use the `SpelExpressionParser`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring表达式语言**（**SpEL**）与2006年为Java服务器页面（JSP）创建的统一EL类似。它支持查询和操作Spring上下文。你可以将其视为一种轻量级脚本语言。如果你的代码使用了`SpelExpressionParser`，则可以使用SpEL。'
- en: 'SpEL is very powerful, and some of its especially useful features are as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: SpEL非常强大，其中一些特别有用的特性如下：
- en: Literal expressions
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文字表达式
- en: Access to Spring Bean methods and properties
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问Spring Bean方法和属性
- en: Boolean operations
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔运算
- en: Call static methods
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用静态方法
- en: Filter collections
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤集合
- en: 'Let''s take a look at an example that calls the `getTimeMessage()` method on
    the `blogService` Spring Bean. The resultant String will be converted to uppercase
    afterwards:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例，该示例在`blogService` Spring Bean上调用`getTimeMessage()`方法。结果字符串随后将被转换为大写：
- en: '[PRE13]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `getTimeMessage()` method conforms to the Bean standard and represents the
    `timeMessage` property as read-only. This allows us to skip the get prefix.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`getTimeMessage()`方法符合Bean标准，将`timeMessage`属性表示为只读。这允许我们省略get前缀。'
- en: Configuration Property Classes
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置属性类
- en: As your application grows, you will also have a growing set of configuration
    options. Using the `@Value` annotation, you can access these, but scattering this
    all over your application may lead to a lot of duplication and maybe even work,
    for example, when the type, key, or default value changes. Then, you have to update
    all occurrences, which is not preferable.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的应用程序的增长，你也将拥有越来越多的配置选项。使用`@Value`注解，你可以访问这些选项，但将它们散布在应用程序的各个地方可能会导致大量的重复，甚至可能产生工作，例如当类型、键或默认值更改时。然后，你必须更新所有出现的地方，这并不是首选的。
- en: 'To have IDE support for the properties, you need to add this dependency:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使IDE支持属性，你需要添加这个依赖项：
- en: '[PRE14]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, you can create a Configuration Properties class with the `@ConfigurationProperties`
    annotation. The class itself should have properties to store the data, and you
    can define default values here if you like:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`@ConfigurationProperties`注解创建一个配置属性类。该类本身应该有属性来存储数据，如果你愿意，可以在这里定义默认值：
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To create the getters and setters, we use Lombok. As you can see, you can also
    have deeply nested classes to store and segregate your data. The `@ConfigurationProperties`
    annotation should have a parameter that is a path prefix for the properties. With
    this, you have properties like the following ones:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建getter和setter，我们使用Lombok。正如你所见，你也可以有深度嵌套的类来存储和分离你的数据。`@ConfigurationProperties`注解应该有一个参数，它是属性的前缀路径。有了这个，你就有如下属性：
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For this to work, you have to do two things. First, you must register the classes
    that are annotated with `@ConfigurationProperties` in a configuration class definition,
    like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这生效，你必须做两件事。首先，你必须在一个配置类定义中注册带有`@ConfigurationProperties`注解的类，如下所示：
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Make the configuration class a Bean by adding `@Component` next to `@ConfigurationProperties`
    or by adding a `@Bean` annotated method for it to a configuration class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`@ConfigurationProperties`旁边添加`@Component`或将一个带有`@Bean`注解的方法添加到配置类中，使配置类成为一个Bean。
- en: You might have noticed that the `iLikePizza` property is now in **kebab-case**
    in the configuration file. The reason behind this is that this is the recommended
    way to write properties. Spring supports relaxed binding for `ConfigurationProperty`
    classes, so you could also use **camelCase** or **snake_case**, but this is not
    recommended, because in certain cases, this can lead to problems.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`iLikePizza` 属性现在在配置文件中是 **kebab-case** 格式。这样做的原因是，这是推荐编写属性的方式。Spring
    支持 `ConfigurationProperty` 类的宽松绑定，因此你也可以使用 **camelCase** 或 **snake_case**，但这是不推荐的，因为在某些情况下，这可能会导致问题。
- en: 'Activity: Examining Autowiring and Configurations'
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动：检查自动装配和配置
- en: '**Aim**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: To create a few classes to practice autowiring and application configuration.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习自动装配和应用配置，创建几个类。
- en: '**Scenario**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: You should reuse the project that was used for the previous subsection and open
    it in the IDE. This is a simplified version of a common task, where you read something
    from the configuration and apply that to input.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该重复使用之前小节中使用的项目，并在 IDE 中打开它。这是一个简化版的常见任务，其中你从配置中读取内容并将其应用于输入。
- en: You are going to create a greeting service that uses a configured suffix and
    a provided input to create a greeting such as Packt greets the world.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建一个问候服务，该服务使用配置的后缀和提供的输入来创建问候，例如 Packt 向世界问候。
- en: '**Steps for Completion**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成步骤**'
- en: Create the class to read the configuration value for the suffix.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类来读取后缀的配置值。
- en: 'Take a look at the following screenshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下截图：
- en: '![](img/935dce09-20b9-474a-8244-23e9269d7e2f.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/935dce09-20b9-474a-8244-23e9269d7e2f.png)'
- en: Create the greeting service.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建问候服务。
- en: Inject the required class in the service.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务中注入所需的类。
- en: Create a public method that creates the greeting.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个公共方法来创建问候。
- en: In the Application class, add a config method that executes the greeting method
    and prints out the result.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Application 类中，添加一个执行问候方法并打印结果的 config 方法。
- en: '**Outcome**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**'
- en: The default message should be INPUT+ greets the world (INPUT is the input with
    the greeter's name to the greeting method), but the location (**the world**) should
    be customizable, so you should also be able to create, for example, INPUT+ greets
    Berlin. The location should be read using the `GreetingProperties`. To trigger
    this code, use the Application class, autowire the service here, and execute it
    with sample data.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 默认消息应该是 INPUT+ 向世界问候（INPUT 是问候方法中输入的问候者的名字），但位置（**世界**）应该是可定制的，因此你也应该能够创建，例如，INPUT+
    向柏林问候。位置应该使用 `GreetingProperties` 读取。要触发此代码，请使用 Application 类，在此处自动装配服务，并使用示例数据执行它。
- en: 'Take a look at the output screenshot, as shown below:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看下面的输出截图：
- en: '![](img/4c610792-e841-4a13-9d0f-d94ff777f835.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4c610792-e841-4a13-9d0f-d94ff777f835.png)'
- en: To refer to the detailed steps, go to the *Solutions* section at the end of this
    book on page 250.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要参考详细步骤，请参阅本书末尾的 *解决方案* 部分，第 250 页。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have seen how you can inject Spring Beans into other Beans
    and how you can help Spring in cases where the injector is not uniquely identifiable.
    You also saw how you can configure your application with profiles and configuration
    files.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了如何将 Spring Beans 注入其他 Beans，以及如何在注入器无法唯一标识的情况下帮助 Spring。你还看到了如何使用配置文件和配置文件配置你的应用程序。
- en: In the next chapter, we will finally start looking at ways we can test our Spring
    Boot applications.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们最终将开始探讨我们可以测试 Spring Boot 应用程序的方法。
