<html><head></head><body>
<div id="_idContainer040">
<h1 class="chapter-number" id="_idParaDest-89"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.1.1">4</span><a id="_idTextAnchor147"/></h1>
<h1 id="_idParaDest-90"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.2.1">Spring Data: SQL, NoSQL, Cache Abstraction, and Batch Processing</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Welcome to </span><a href="B18400_04.xhtml#_idTextAnchor146"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">Here, we are going to take a closer look at the Spring Data approach. </span><span class="koboSpan" id="kobo.5.3">In this chapter, we want to learn how the Spring Data approach can work for us. </span><span class="koboSpan" id="kobo.5.4">Spring Data is one of the key parts of the Spring Boot ecosystem. </span><span class="koboSpan" id="kobo.5.5">This will help you to clearly understand how to work with different kinds of databases in Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">Boot 3.0.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Why does this chapter matter? </span><span class="koboSpan" id="kobo.7.2">In software development, how we manage data is very important, and is more than just storing the data. </span><span class="koboSpan" id="kobo.7.3">This part of the book is not only about studying various parts of Spring Data, but it’s also about putting them to work in real-life situations. </span><span class="koboSpan" id="kobo.7.4">In this chapter, we will see how to configure and use Spring Data, which helps a lot in data management activities. </span><span class="koboSpan" id="kobo.7.5">You will learn how to work with structured data, stored in SQL databases, and unstructured data that is stored in NoSQL databases, ideal for various types of data. </span><span class="koboSpan" id="kobo.7.6">Furthermore, we will cover what cache abstraction is and why it’s good for making your app run faster. </span><span class="koboSpan" id="kobo.7.7">Another really big topic is batch processing, and how to work with a lot of data all at once. </span><span class="koboSpan" id="kobo.7.8">Further than that, you will learn important techniques for changing and updating your </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">data safely.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">Knowing how to handle data, whether it is simple or complex, is key and will contribute to better software programming skills. </span><span class="koboSpan" id="kobo.9.2">By the end of this chapter, you are not just going to know the theory but will be able to be hands-on in actual projects, applying these skills. </span><span class="koboSpan" id="kobo.9.3">We will use a real project, an online bookstore management system, to show you how </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">things work.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">By the end of this chapter, you will have a good grasp of both the theory and practical use of Spring Data. </span><span class="koboSpan" id="kobo.11.2">This is essential for any developer, whether regarded as experienced or just </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">starting out.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">Let’s get the ball rolling. </span><span class="koboSpan" id="kobo.13.2">We will see how Spring Data will help you to change the way you manage data in your projects. </span><span class="koboSpan" id="kobo.13.3">We will turn the theory into real skills and help you to grow as </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">a developer.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">In this chapter, we will focus on these </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.17.1">Introduction to </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Spring Data</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Using Spring Data with </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">SQL databases</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">NoSQL databases in </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">Spring Boot</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Spring Boot </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">cache abstraction</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Spring Boot </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">batch processing</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Data migration </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">and consistency</span></span></li>
</ul>
<h1 id="_idParaDest-91"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.29.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.30.1">For this chapter, we are going to need some installations on our </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">local machines:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.32.1">Docker Desktop</span></span></li>
<li><span class="koboSpan" id="kobo.33.1">GitHub repository: You can clone all repositories related to </span><a href="B18400_04.xhtml#_idTextAnchor146"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.34.1">Chapter 4</span></em></span></a> <span class="No-Break"><span class="koboSpan" id="kobo.35.1">here: </span></span><a href="https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/"><span class="No-Break"><span class="koboSpan" id="kobo.36.1">https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/</span></span></a></li>
</ul>
<p><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.37.1">Here are the steps to install </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">Docker Desktop:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.39.1">Visit the Docker Desktop </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">website: </span></span><a href="https://docs.docker.com/desktop/"><span class="No-Break"><span class="koboSpan" id="kobo.41.1">https://docs.docker.com/desktop/</span></span></a></li>
<li><span class="koboSpan" id="kobo.42.1">Follow the instructions under the </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">Install Docker Desktop</span></strong><span class="koboSpan" id="kobo.44.1"> menu. </span><span class="koboSpan" id="kobo.44.2">It’s available for various operating systems and provides a straightforward </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">installation process.</span></span></li>
</ol>
<h1 id="_idParaDest-92"><a id="_idTextAnchor151"/><a id="_idTextAnchor152"/><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.46.1">Introduction to Spring Data</span></h1>
<p><span class="koboSpan" id="kobo.47.1">In this section, we will look at the general fundamental concepts of Spring Data and how they are useful. </span><span class="koboSpan" id="kobo.47.2">We will also examine their application in our case study project, the online bookstore </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">management system.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.49.1">Spring Data</span></strong><span class="koboSpan" id="kobo.50.1"> is a </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.51.1">part of the Spring Framework that can simplify interaction with data in our application as much as possible. </span><span class="koboSpan" id="kobo.51.2">Its main advantage and greatest strength is the ability to simplify database operations. </span><span class="koboSpan" id="kobo.51.3">This means you can perform tasks such as querying a database or updating records with less code </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">and complexity.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">Understanding Spring Data</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.54.1"> will build your skills in dealing with data effectively – one of the key factors of software development. </span><span class="koboSpan" id="kobo.54.2">Whether it is a small application or a complex enterprise system, effective role-based access on the data layer plays an impactful role in better performance and maintenance of the </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">whole system.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">In this chapter, we will display the main characteristics of Spring Data and how it can help you to simplify your work. </span><span class="koboSpan" id="kobo.56.2">Knowing about these concepts will help you manage data in your software projects, thus making the development process an easier one and expediting </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">its flow.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">So, let’s embark on this interesting journey with Spring Data. </span><span class="koboSpan" id="kobo.58.2">It is going to be a practical and informative ride, and by the end of it, you will surely be well-equipped to manage data in your own applications using </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">Spring Data.</span></span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.60.1">Understanding the fundamentals and benefits of Spring Data</span></h2>
<p><span class="koboSpan" id="kobo.61.1">In this section, we’ll focus on the basics of Spring Data. </span><span class="koboSpan" id="kobo.61.2">We are first going to learn about its core concepts and benefits that are critical to every developer. </span><span class="koboSpan" id="kobo.61.3">From there, we will step into setting up a Spring Boot project and defining some key JPA entities. </span><span class="koboSpan" id="kobo.61.4">By taking little steps like these, we will graduate to having a solid foundation in Spring Data, which will render further applications </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">more advanced.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">We’ll start with what makes Spring Data a powerful tool in the Spring Boot ecosystem and why it could be beneficial for your projects as well. </span><span class="koboSpan" id="kobo.63.2">We’ll then continue to the practical parts of setting up your </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.64.1">project and going deeper into the world of </span><strong class="bold"><span class="koboSpan" id="kobo.65.1">Java Persistence API</span></strong><span class="koboSpan" id="kobo.66.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.67.1">JPA</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">) entities.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">Before diving into the technical setup, let’s first understand the core principles and advantages of using Spring Data in </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">our projects.</span></span></p>
<h3><span class="koboSpan" id="kobo.71.1">Exploring the core concepts of Spring Data</span></h3>
<p><span class="koboSpan" id="kobo.72.1">Spring Data is designed to simplify interaction with databases in Java applications. </span><span class="koboSpan" id="kobo.72.2">Here are some of its </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">fundamental concepts:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.74.1">Data access simplified</span></strong><span class="koboSpan" id="kobo.75.1">: Spring </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.76.1">Data reduces the complexity of data access operations. </span><span class="koboSpan" id="kobo.76.2">You no longer need to write boilerplate code for common database interactions. </span><span class="koboSpan" id="kobo.76.3">We will see how to perform </span><strong class="bold"><span class="koboSpan" id="kobo.77.1">Create, Read, Update, and Delete</span></strong><span class="koboSpan" id="kobo.78.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.79.1">CRUD</span></strong><span class="koboSpan" id="kobo.80.1">) operations </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.81.1">without writing a single line of code. </span><span class="koboSpan" id="kobo.81.2">This will make our code more readable </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">and manageable.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.83.1">Repository abstraction</span></strong><span class="koboSpan" id="kobo.84.1">: One of the</span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.85.1"> key features of Spring Data is its repository abstraction. </span><span class="koboSpan" id="kobo.85.2">This helps us to use database operations like a function in our framework. </span><span class="koboSpan" id="kobo.85.3">If we don’t know how to write a query in a specific database, we don’t need to worry. </span><span class="koboSpan" id="kobo.85.4">This abstraction makes it work the same for all supported databases. </span><span class="koboSpan" id="kobo.85.5">It abstracts the data layer, meaning you can focus more on your business logic rather than </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">database intricacies.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.87.1">Support for multiple database types</span></strong><span class="koboSpan" id="kobo.88.1">: Spring Data supports a wide range of database types, including</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.89.1"> both SQL and NoSQL options. </span><span class="koboSpan" id="kobo.89.2">This versatility makes it a valuable tool for projects that may require different </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">database technologies.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.91.1">Benefits of using Spring Data</span></h3>
<p><span class="koboSpan" id="kobo.92.1">Now, let’s look at why</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.93.1"> Spring Data is beneficial for your </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">development process:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.95.1">Increased efficiency and productivity</span></strong><span class="koboSpan" id="kobo.96.1">: Spring Data not only reduces the boilerplate coding for database operations but also performs these operations in a best-practice, efficient way. </span><span class="koboSpan" id="kobo.96.2">In old structures, we often dealt with connection issues that were not closed. </span><span class="koboSpan" id="kobo.96.3">Spring Data manages all connection pool </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">issues effectively.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.98.1">Easy to learn and use</span></strong><span class="koboSpan" id="kobo.99.1">: Spring Data is designed to be user-friendly. </span><span class="koboSpan" id="kobo.99.2">Just a few pages later, you will understand what I mean. </span><span class="koboSpan" id="kobo.99.3">Developers can quickly learn how to use it and start using it in their projects. </span><span class="koboSpan" id="kobo.99.4">Its integration with the Spring ecosystem also means that it works seamlessly with other </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">Spring technologies.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.101.1">Enhanced code quality and maintainability</span></strong><span class="koboSpan" id="kobo.102.1">: With less code clutter and a cleaner approach to data handling, Spring Data enhances the overall quality of your code. </span><span class="koboSpan" id="kobo.102.2">It makes</span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.103.1"> your applications easier to maintain and update in the </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">long run.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.105.1">You will understand these benefits and concepts better as we progress through the setup and usage of our Spring Boot application. </span><span class="koboSpan" id="kobo.105.2">Now that we have basic knowledge of what Spring Data is and why it’s advantageous, let’s move forward with setting up our project and defining our </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">JPA entities.</span></span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.107.1">Setting up your Spring Boot project</span></h2>
<p><span class="koboSpan" id="kobo.108.1">First things first, let’s set up </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.109.1">a Spring Boot project. </span><span class="koboSpan" id="kobo.109.2">This is your starting point for any Spring application. </span><span class="koboSpan" id="kobo.109.3">You can follow the same steps as in </span><a href="B18400_03.xhtml#_idTextAnchor064"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.110.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.111.1">. </span><span class="koboSpan" id="kobo.111.2">Or you can directly clone the Git repository provided in the </span><em class="italic"><span class="koboSpan" id="kobo.112.1">Technical </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.113.1">requirements</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.114.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">These are the basic dependencies you need while creating </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">the application:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.117.1">
implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
compileOnly 'org.projectlombok:lombok'
annotationProcessor 'org.projectlombok:lombok'</span></pre> <p><span class="koboSpan" id="kobo.118.1">The library, called Lombok, is commonly used to eliminate boilerplate code like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">getId</span></strong><span class="koboSpan" id="kobo.120.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">setId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.122.1"> methods.</span></span></p>
<p><span class="koboSpan" id="kobo.123.1">With these steps, you have your Spring Boot project ready. </span><span class="koboSpan" id="kobo.123.2">Now, let’s define some </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">JPA entities.</span></span></p>
<h3><span class="koboSpan" id="kobo.125.1">Defining JPA entities: Book, Author, and Publisher</span></h3>
<p><span class="koboSpan" id="kobo.126.1">In a bookstore application, we</span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.127.1"> deal with books, authors, and publishers. </span><span class="koboSpan" id="kobo.127.2">Let’s define them as JPA entities. </span><span class="koboSpan" id="kobo.127.3">We will create three classes as follows. </span><span class="koboSpan" id="kobo.127.4">You can see them in the repository under the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">model</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.129.1"> package:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.130.1">
@Entity
@Table(name = "books")
@Data
public class Book {
    @Id @GeneratedValue
    private Long id;
    private String title;
    private String isbn;
}
@Entity
@Table(name = "publishers")
@Data
public class Publisher {
    @Id @GeneratedValue
    private Long id;
    private String name;
    private String address;
}
@Entity
@Table(name = "authors")
@Data
public class Author {
    @Id @GeneratedValue
    private Long id;
    private String name;
    private String biography;
}</span></pre> <p><span class="koboSpan" id="kobo.131.1">Each of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">Book</span></strong><span class="koboSpan" id="kobo.133.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">Author</span></strong><span class="koboSpan" id="kobo.135.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">Publisher</span></strong><span class="koboSpan" id="kobo.137.1"> entities </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.138.1">represents a crucial part of our bookstore system. </span><span class="koboSpan" id="kobo.138.2">By using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">@Data</span></strong><span class="koboSpan" id="kobo.140.1"> annotation, we simplify </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">our code.</span></span></p>
<h3><span class="koboSpan" id="kobo.142.1">Understanding the role of repositories in Spring Data</span></h3>
<p><span class="koboSpan" id="kobo.143.1">After defining our entities, we need to create</span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.144.1"> repositories. </span><strong class="bold"><span class="koboSpan" id="kobo.145.1">Repositories</span></strong><span class="koboSpan" id="kobo.146.1"> in Spring Data help us to interact with the </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">database easily.</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">In order to create a repository for each entity (</span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">Book</span></strong><span class="koboSpan" id="kobo.150.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">Author</span></strong><span class="koboSpan" id="kobo.152.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">Publisher</span></strong><span class="koboSpan" id="kobo.154.1">), create an interface that extends </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">JpaRepository</span></strong><span class="koboSpan" id="kobo.156.1">. </span><span class="koboSpan" id="kobo.156.2">This interface provides methods for common </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">database operations.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">Book</span></strong><span class="koboSpan" id="kobo.160.1">, it might look </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.162.1">
public interface BookRepository extends JpaRepository&lt;Book, Long&gt; {}</span></pre> <p><span class="koboSpan" id="kobo.163.1">These repositories provide some generic methods for saving, finding, deleting, and updating entities. </span><span class="koboSpan" id="kobo.163.2">For instance, to find all books, you can </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">bookRepository.findAll()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.167.1">This setup will be the base for our building in the upcoming Spring Boot application. </span><span class="koboSpan" id="kobo.167.2">By now, you should have a basic project ready with entities </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">and repositories.</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">Now, we have a Spring Boot project set up with Spring Data dependencies, and we’ve defined essential JPA entities and repositories. </span><span class="koboSpan" id="kobo.169.2">This is the foundation of our work with Spring Data. </span><span class="koboSpan" id="kobo.169.3">We have not connected to a </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">database yet.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">In the next section, we’ll delve into how to use Spring Data with SQL databases. </span><span class="koboSpan" id="kobo.171.2">We will look at an easy and effective way to use Spring Data in </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">our project.</span></span></p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.173.1">Using Spring Data with SQL databases</span></h1>
<p><span class="koboSpan" id="kobo.174.1">As a developer who deals with Spring Data, it’s important to understand its relationship with SQL databases. </span><strong class="bold"><span class="koboSpan" id="kobo.175.1">SQL databases</span></strong><span class="koboSpan" id="kobo.176.1"> are </span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.177.1">known for their structured approach to data management. </span><span class="koboSpan" id="kobo.177.2">They are widely used in various applications. </span><span class="koboSpan" id="kobo.177.3">We are going to use them in our online bookstore </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">management system.</span></span></p>
<p><span class="koboSpan" id="kobo.179.1">In this section, we’ll explore how Spring Data JPA interfaces with SQL databases, focusing on PostgreSQL configuration and the creation of complex </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">entity relationships.</span></span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.181.1">Integrating PostgreSQL with Spring Boot using Docker</span></h2>
<p><span class="koboSpan" id="kobo.182.1">First off, we need to have an up-and-running PostgreSQL server on our local machine. </span><span class="koboSpan" id="kobo.182.2">The easiest way of doing this is using Docker containers. </span><strong class="bold"><span class="koboSpan" id="kobo.183.1">Docker</span></strong><span class="koboSpan" id="kobo.184.1"> is </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.185.1">a tool that simplifies the setup and deployment of applications and their dependencies. </span><span class="koboSpan" id="kobo.185.2">Let’s go through how you can set up PostgreSQL using Docker and configure your Spring Boot application to connect </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">to it.</span></span></p>
<h3><span class="koboSpan" id="kobo.187.1">Setting up PostgreSQL with Docker</span></h3>
<p><span class="koboSpan" id="kobo.188.1">Using </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.189.1">Docker, you can easily install and run a PostgreSQL </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.190.1">database. </span><span class="koboSpan" id="kobo.190.2">This method offers a consistent and isolated environment for your database, regardless of your </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">local setup.</span></span></p>
<p><span class="koboSpan" id="kobo.192.1">You already installed Docker Desktop as instructed in the </span><em class="italic"><span class="koboSpan" id="kobo.193.1">Technical requirements</span></em><span class="koboSpan" id="kobo.194.1"> section. </span><span class="koboSpan" id="kobo.194.2">We will use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">Docker Compose</span></strong><span class="koboSpan" id="kobo.196.1"> file, which can also be found in the root folder of the GitHub repository. </span><span class="koboSpan" id="kobo.196.2">Here’s a basic example using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">Docker </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">Compose</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.199.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.200.1">
    version: '3.1'
    services:
      db:
        image: postgres
        restart: always
        environment:
          POSTGRES_PASSWORD: yourpassword
          POSTGRES_DB: bookstore
        ports:
          - "5432:5432"</span></pre> <p><span class="koboSpan" id="kobo.201.1">This will set up a PostgreSQL server with the database named </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">bookstore</span></strong><span class="koboSpan" id="kobo.203.1">. </span><span class="koboSpan" id="kobo.203.2">Replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">yourpassword</span></strong><span class="koboSpan" id="kobo.205.1"> with a secure password of your choice. </span><span class="koboSpan" id="kobo.205.2">Save this file as </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.207.1"> in the root </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">source folder.</span></span></p>
<p><span class="koboSpan" id="kobo.209.1">Run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">docker-compose up</span></strong><span class="koboSpan" id="kobo.211.1"> command in the directory where your </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.213.1"> file is located. </span><span class="koboSpan" id="kobo.213.2">This command will download the PostgreSQL image and start the </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">database server.</span></span></p>
<h3><span class="koboSpan" id="kobo.215.1">Configuring Spring Boot to connect to PostgreSQL</span></h3>
<p><span class="koboSpan" id="kobo.216.1">Now that </span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.217.1">PostgreSQL is running in a Docker container, let’s configure our Spring Boot application to connect </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">to it:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.219.1">Update </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">application.properties</span></strong><span class="koboSpan" id="kobo.221.1">: Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">application.properties</span></strong><span class="koboSpan" id="kobo.223.1"> file in your Spring Boot project. </span><span class="koboSpan" id="kobo.223.2">Add the following properties to configure the connection to the </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">PostgreSQL server:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.225.1">
    spring.datasource.url=jdbc:postgresql://localhost:5432/bookstore
    spring.datasource.username=postgres
    spring.datasource.password=yourpassword
    spring.jpa.hibernate.ddl-auto=update</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.226.1">Make sure to replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">yourpassword</span></strong><span class="koboSpan" id="kobo.228.1"> with the password you set in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">Docker Compose</span></strong><span class="koboSpan" id="kobo.230.1"> file. </span><span class="koboSpan" id="kobo.230.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">spring.jpa.hibernate.ddl-auto=update</span></strong><span class="koboSpan" id="kobo.232.1"> property helps manage the database schema based on your </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">entity classes.</span></span></p></li> <li><span class="koboSpan" id="kobo.234.1">Verifying the connection: Run your Spring Boot application. </span><span class="koboSpan" id="kobo.234.2">At this stage, we can only see whether the app starts up properly or not. </span><span class="koboSpan" id="kobo.234.3">In the </span><em class="italic"><span class="koboSpan" id="kobo.235.1">Implementing practical CRUD operations in the online bookstore</span></em><span class="koboSpan" id="kobo.236.1"> section, we will introduce the REST controller to verify that it connects to the PostgreSQL </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">database successfully.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.238.1">With these steps, you have successfully integrated a PostgreSQL database into your Spring Boot application using Docker. </span><span class="koboSpan" id="kobo.238.2">This setup not only simplifies the initial configuration but also ensures a consistent database environment for development and testing. </span><span class="koboSpan" id="kobo.238.3">Now, we will go one step ahead and introduce the advanced entity relationships between the objects in the </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">next section.</span></span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.240.1">Developing complex relationships between entities</span></h2>
<p><span class="koboSpan" id="kobo.241.1">In this section, we’ll focus on </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.242.1">developing complex relationships between our entities: </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">Book</span></strong><span class="koboSpan" id="kobo.244.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">Author</span></strong><span class="koboSpan" id="kobo.246.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">Publisher</span></strong><span class="koboSpan" id="kobo.248.1">. </span><span class="koboSpan" id="kobo.248.2">We’ll use Spring Data’s annotation-driven approach to link these entities, reflecting real-world connections in our </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">database design.</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">In our bookstore application, we created basic objects. </span><span class="koboSpan" id="kobo.250.2">Now, we are going to connect them to each other. </span><span class="koboSpan" id="kobo.250.3">Let’s start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">Books</span></strong><span class="koboSpan" id="kobo.252.1"> to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">Authors</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.254.1"> connection.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">Each book can have one or more authors, forming a </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">many-to-many relationship.</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">Here’s how we can represent this in our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">Book</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.259.1"> record:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.260.1">
    @ManyToMany
    private List&lt;Author&gt; authors;</span></pre> <p><span class="koboSpan" id="kobo.261.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">@ManyToMany</span></strong><span class="koboSpan" id="kobo.263.1"> annotation indicates that each book can be associated with multiple authors. </span><span class="koboSpan" id="kobo.263.2">This relationship is bidirectional, meaning authors can also be linked to multiple books. </span><span class="koboSpan" id="kobo.263.3">In a many-to-many relationship, you need a new cross table to link these tables. </span><span class="koboSpan" id="kobo.263.4">This is a part of database design, so we will mention this feature so as not to surprise you when you view your tables in </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">Now, we are going to link </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">Authors</span></strong><span class="koboSpan" id="kobo.267.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">Publisher</span></strong><span class="koboSpan" id="kobo.269.1">. </span><span class="koboSpan" id="kobo.269.2">An author may be associated with a publisher. </span><span class="koboSpan" id="kobo.269.3">This is a many-to-one relationship, as multiple authors can be published by the </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">same publisher:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.271.1">
    @ManyToOne
    private Publisher publisher;</span></pre> <p><span class="koboSpan" id="kobo.272.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">@ManyToOne</span></strong><span class="koboSpan" id="kobo.274.1"> annotation </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.275.1">here signifies that each author is linked to one publisher, while a publisher can have </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">multiple authors.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">Publisher</span></strong><span class="koboSpan" id="kobo.279.1"> entity remains simple as it does not need to establish a new relationship in </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">this context.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.282.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.283.1">.1</span></em><span class="koboSpan" id="kobo.284.1">, we can see the tables and the relationships </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">between them:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.286.1"><img alt="Figure 4.1 – Database diagram of the tables" src="image/B18400_04_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.287.1">Figure 4.1 – Database diagram of the tables</span></p>
<p><span class="koboSpan" id="kobo.288.1">The tables you can </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.289.1">see in the diagram were generated by the Spring Data library when we started the application. </span><span class="koboSpan" id="kobo.289.2">You can see there is one extra table called </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">books_authors</span></strong><span class="koboSpan" id="kobo.291.1">. </span><span class="koboSpan" id="kobo.291.2">This table is for a many-to-many relationship between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">books</span></strong><span class="koboSpan" id="kobo.293.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">authors</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.295.1"> tables.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">With this implementation, we have applied a real-world connection between books, authors, and publishers in </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">our application.</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">As we conclude this section on entity relationships, we have defined complex data structures in our online bookstore management system. </span><span class="koboSpan" id="kobo.298.2">Next, we will see how these relationships work in </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">practical scenarios.</span></span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.300.1">Implementing practical CRUD operations in the online bookstore</span></h2>
<p><span class="koboSpan" id="kobo.301.1">With our</span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.302.1"> complex entity relationships</span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.303.1"> established, let’s see how these are practically implemented in the online bookstore management system. </span><span class="koboSpan" id="kobo.303.2">We’ll introduce </span><strong class="bold"><span class="koboSpan" id="kobo.304.1">create, read, update, delete</span></strong><span class="koboSpan" id="kobo.305.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.306.1">CRUD</span></strong><span class="koboSpan" id="kobo.307.1">) operations</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.308.1"> through REST endpoints, demonstrating how the controllers interact with the </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">PostgreSQL database.</span></span></p>
<p><span class="koboSpan" id="kobo.310.1">First, we will create controller classes. </span><span class="koboSpan" id="kobo.310.2">Let’s go over the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">book</span></strong><span class="koboSpan" id="kobo.312.1"> object. </span><span class="koboSpan" id="kobo.312.2">You can make similar changes for both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">Author</span></strong><span class="koboSpan" id="kobo.314.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">Publisher</span></strong><span class="koboSpan" id="kobo.316.1"> objects. </span><span class="koboSpan" id="kobo.316.2">Or, you can check the GitHub repository (</span><a href="https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/tree/main/Chapter-4-1-intorduction-spring-data/src/main/java/com/packt/ahmeric/bookstore/data"><span class="koboSpan" id="kobo.317.1">https://github.com/PacktPublishing/Mastering-Spring-Boot-3.0/tree/main/Chapter-4-1-intorduction-spring-data/src/main/java/com/packt/ahmeric/bookstore/data</span></a><span class="koboSpan" id="kobo.318.1">) for the latest implementation for all </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">three objects.</span></span></p>
<h3><span class="koboSpan" id="kobo.320.1">Developing CRUD endpoints</span></h3>
<p><span class="koboSpan" id="kobo.321.1">Now, we will get our hands dirty to make these objects reachable from outside. </span><span class="koboSpan" id="kobo.321.2">First off, we need a </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">Repository</span></strong><span class="koboSpan" id="kobo.323.1"> class to manage the entities. </span><span class="koboSpan" id="kobo.323.2">This is a basic repository class for </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">book</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.325.1"> objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.326.1">
@Repository
public interface BookRepository extends JpaRepository&lt;Book, Long&gt; { }</span></pre> <p><span class="koboSpan" id="kobo.327.1">This one, single-line class will help us to use so many common methods, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">findAll()</span></strong><span class="koboSpan" id="kobo.329.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">save(book)</span></strong><span class="koboSpan" id="kobo.331.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">findById(id)</span></strong><span class="koboSpan" id="kobo.333.1">. </span><span class="koboSpan" id="kobo.333.2">This is the power of </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">Spring Data.</span></span></p>
<p><span class="koboSpan" id="kobo.335.1">In order to create a controller class for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">book</span></strong><span class="koboSpan" id="kobo.337.1"> object, we introduce the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">BookController</span></strong><span class="koboSpan" id="kobo.339.1"> class to handle requests related to books. </span><span class="koboSpan" id="kobo.339.2">This controller will manage operations such as adding a new book, retrieving book details, updating book information, and deleting </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">a book.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">So, let’s introduce a new class </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">BookController</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.345.1">
@RestController
@RequestMapping("/books")
@RequiredArgsConstructor
public class BookController {
    private final BookRepository bookRepository;
    @PostMapping
    @CacheEvict(value = "books", allEntries = true) // Invalidate the entire books cache
    public ResponseEntity&lt;Book&gt; addBook(@RequestBody Book book) {
        Book savedBook = bookRepository.save(book);
        return ResponseEntity.ok(savedBook);
    }
    @GetMapping("/{id}")
    public ResponseEntity&lt;Book&gt; getBook(@PathVariable Long id) {
        Optional&lt;Book&gt; book = bookRepository.findById(id);
        return book.map(ResponseEntity::ok).orElseGet(() -&gt; ResponseEntity.notFound().build());
    }
}</span></pre> <p><span class="koboSpan" id="kobo.346.1">In this simple class, you can see new annotations above the class name – </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">@RestController</span></strong><span class="koboSpan" id="kobo.348.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">@RequestMapping</span></strong><span class="koboSpan" id="kobo.350.1">. </span><span class="koboSpan" id="kobo.350.2">As you’ll remember, we used them in </span><a href="B18400_03.xhtml#_idTextAnchor064"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.351.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.352.1">. </span><span class="koboSpan" id="kobo.352.2">But there is a new annotation here: </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">@RequiredArgsConstructor</span></strong><span class="koboSpan" id="kobo.354.1">. </span><span class="koboSpan" id="kobo.354.2">This annotation belongs to Lombok as well. </span><span class="koboSpan" id="kobo.354.3">This will create a constructor at compile time, so we have a clear class without boilerplate </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">code lines.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">In this </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.357.1">sample code, we have two endpoints for</span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.358.1"> creating a book and getting a book by ID. </span><span class="koboSpan" id="kobo.358.2">These are REST endpoints that accept and return JSON data. </span><span class="koboSpan" id="kobo.358.3">And you can see we are using default methods from </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">bookRepository</span></strong><span class="koboSpan" id="kobo.360.1">, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">findById()</span></strong><span class="koboSpan" id="kobo.362.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">save()</span></strong><span class="koboSpan" id="kobo.364.1">. </span><span class="koboSpan" id="kobo.364.2">We haven’t written them in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">Repository</span></strong><span class="koboSpan" id="kobo.366.1"> class. </span><span class="koboSpan" id="kobo.366.2">They came from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">JpaRepository</span></strong><span class="koboSpan" id="kobo.368.1"> extension. </span><span class="koboSpan" id="kobo.368.2">The Spring Data JPA repositories, coupled with Hibernate, efficiently manage the underlying SQL queries and transactions, abstracting the complexities and ensuring smooth data handling. </span><span class="koboSpan" id="kobo.368.3">So, we don’t even write a single line of code to save an entity in the database. </span><span class="koboSpan" id="kobo.368.4">We only use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">save()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.370.1">method instead.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">You can see</span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.372.1"> other endpoints for deleting </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.373.1">and finding all updates in the GitHub repository. </span><span class="koboSpan" id="kobo.373.2">If you want, you can create </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">AuthorController</span></strong><span class="koboSpan" id="kobo.375.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">PublisherController</span></strong><span class="koboSpan" id="kobo.377.1"> similarly for managing authors </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">and publishers.</span></span></p>
<p><span class="koboSpan" id="kobo.379.1">As we introduced the relationship between the tables, when we add a book with its authors, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">books_authors</span></strong><span class="koboSpan" id="kobo.381.1"> table will be </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">updated accordingly.</span></span></p>
<p><span class="koboSpan" id="kobo.383.1">Let’s do some curl requests to see how </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">it works.</span></span></p>
<h3><span class="koboSpan" id="kobo.385.1">Using curl requests for a practical run-through</span></h3>
<p><span class="koboSpan" id="kobo.386.1">Run the Spring Boot </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.387.1">application with </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">this command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.389.1">
./gradlew bootRun</span></pre> <p><span class="koboSpan" id="kobo.390.1">Now, we will run the following requests </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">in order:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.392.1">Create </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">a publisher:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.394.1">
curl -X POST --location "http://localhost:8080/publishers" -H "Content-Type: application/json" -d "{\"name\": \"Publisher Name\", \"address\": \"Address of the publisher\"}"</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.395.1">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">the response:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.397.1">{
  "id": 1,
  "name": "Publisher Name",
  "address": "Address of the publisher"
}</span></pre></li> <li><span class="koboSpan" id="kobo.398.1">Create </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">an author:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.400.1">
curl -X POST --location "http://localhost:8080/authors"
    -H "Content-Type: application/json"
    -d "{\"name\": \"Author Name\",
        \"biography\": \"A long story\",
        \"publisher\": {\"id\": 1}}"</span></pre></li> <li><span class="koboSpan" id="kobo.401.1">Create </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">a </span></span><span class="No-Break"><a id="_idIndexMarker292"/></span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">book:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.404.1">
curl -X POST --location "http://localhost:8080/books"-H "Content-Type: application/json" -d "{\"title\": \"Book title\",\"isbn\": \"12345\",\"authors\": [{\"id\": 1}]}"</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.405.1">As you can see, we have used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">id</span></strong><span class="koboSpan" id="kobo.407.1"> of the linked object. </span><span class="koboSpan" id="kobo.407.2">For example, when we created an author, we linked the author with a publisher with </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">ID 1.</span></span></p>
<p><span class="koboSpan" id="kobo.409.1">In this practical implementation phase, we have established how to create functional endpoints within our controllers to manage books, authors, and publishers within the online bookstore. </span><span class="koboSpan" id="kobo.409.2">These endpoints interact seamlessly with the PostgreSQL database, showing us how powerful and effective it is to use Spring Data within a </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">real application.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">With this section under our belts, we’re ready to learn about the next step in our journey – integrating NoSQL databases with Spring Boot and further extending its data </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">management capabilities.</span></span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.413.1">NoSQL databases in Spring Boot</span></h1>
<p><span class="koboSpan" id="kobo.414.1">Having studied structured SQL databases, we will now delve into </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.415.1">NoSQL databases. </span><span class="koboSpan" id="kobo.415.2">We will see how they are more flexible than SQL databases. </span><span class="koboSpan" id="kobo.415.3">In this section, we will see how easy it is to implement NoSQL databases within Spring Boot 3.0. </span><span class="koboSpan" id="kobo.415.4">We will implement this database connection in our bookstore management </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">system application.</span></span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.417.1">Exploring the integration of NoSQL databases in Spring Boot</span></h2>
<p><span class="koboSpan" id="kobo.418.1">At this point in our Spring Boot journey, we’ll shift gears and look at the integration of NoSQL databases, which are an essential part of a modern application stack. </span><span class="koboSpan" id="kobo.418.2">Unlike traditional SQL databases, </span><strong class="bold"><span class="koboSpan" id="kobo.419.1">NoSQL databases</span></strong><span class="koboSpan" id="kobo.420.1"> such as </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.421.1">MongoDB offer a different style of managing data, thus their suitability in this case. </span><span class="koboSpan" id="kobo.421.2">Here, we’ll gain in the context of Spring Boot not just an understanding of these benefits but also learn how to effectively implement them in </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">real-world applications.</span></span></p>
<p><span class="koboSpan" id="kobo.423.1">NoSQL databases shine for being able to flexibly take care of different data types, mostly unstructured or semi-structured. </span><span class="koboSpan" id="kobo.423.2">This flexibility gives a great advantage to developers who are facing diverse data requirements or even an ever-changing data structure. </span><span class="koboSpan" id="kobo.423.3">In the world of NoSQL, MongoDB is distinguished as document-oriented, which makes it one of the best data storage options for applications that demand a scalable and agile data </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">storage platform.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">With regard to the integration of NoSQL databases with Spring Boot, the whole process is simplified and very easy to accomplish. </span><span class="koboSpan" id="kobo.425.2">The way in which Spring Boot integrates well with NoSQL databases such as MongoDB</span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.426.1"> literally allows developers to plug it into their applications without annoying configurations. </span><span class="koboSpan" id="kobo.426.2">This integration opens a new world of application development, the prospects of which revolve around the potential to build more dynamic, scalable, and </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">efficient applications.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">The best thing about that synergy is using NoSQL databases in Spring Boot. </span><span class="koboSpan" id="kobo.428.2">The philosophy of Spring Boot is to simplify the development of an application, which complements NoSQL’s nature, coming with scalability and flexibility. </span><span class="koboSpan" id="kobo.428.3">This combination is particularly potent for the development of applications that do not only involve dealing with complex data structures but must be adaptable to changing demands </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">for data.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">In the context of our online bookstore management system, integrating a NoSQL database such as MongoDB won’t just add a great deal of value to the capabilities of the application but will also present a practical example of how these state-of-the-art families of technologies can be brought together. </span><span class="koboSpan" id="kobo.430.2">We can use MongoDB to integrate functions such as user reviews or even personalized recommendations that leverage the flexible data modeling that is powered by </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">NoSQL databases.</span></span></p>
<p><span class="koboSpan" id="kobo.432.1">When we delve into how to integrate NoSQL databases into Spring Boot, we not only have yet another tool at our disposal but learn a lot more about the workings of various kinds of databases so that we can develop applications that are stronger, more flexible, and perform faster. </span><span class="koboSpan" id="kobo.432.2">This knowledge is priceless in a landscape where the capability to adapt and evolve with modern technological advances remains among the key factors of success. </span><span class="koboSpan" id="kobo.432.3">In the next sections, we will implement MongoDB in our project step </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">by step.</span></span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.434.1">Setting up and configuring MongoDB</span></h2>
<p><span class="koboSpan" id="kobo.435.1">We need to run a MongoDB on</span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.436.1"> our local machine as we did for PostgreSQL in the previous section. </span><span class="koboSpan" id="kobo.436.2">Similar to PostgreSQL, MongoDB can be set up in a Docker container, ensuring an isolated and consistent </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">database environment.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">You can see an enhanced version of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">docker-compose.yml</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.440.1">file here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.441.1">
version: '3.1'
services:
  db:
    image: postgres
    restart: always
    environment:
      POSTGRES_PASSWORD: yourpassword
      POSTGRES_DB: bookstore
    ports:
      - "5432:5432"
  mongodb:
    image: mongo
    restart: always
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_DATABASE: bookstore</span></pre> <p><span class="koboSpan" id="kobo.442.1">You can also find the same file in the GitHub repository. </span><span class="koboSpan" id="kobo.442.2">You can run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">docker-compose up</span></strong><span class="koboSpan" id="kobo.444.1"> command to run both MongoDB and PostgreSQL at the </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">same time.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">After running a </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.447.1">MongoDB instance, we need to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">application.properties</span></strong><span class="koboSpan" id="kobo.449.1"> file in our </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">resources folder.</span></span></p>
<p><span class="koboSpan" id="kobo.451.1">This single configuration line will create a connection between the Spring Boot app </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">and MongoDB:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.453.1">
spring.data.mongodb.uri=mongodb://localhost:27017/bookstore</span></pre> <p><span class="koboSpan" id="kobo.454.1">With this simple configuration update, we are ready to connect MongoDB to our local machine. </span><span class="koboSpan" id="kobo.454.2">In the next section, we will introduce a new object and see how our app works </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">with MongoDB.</span></span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.456.1">Building the Review object and its repository</span></h2>
<p><span class="koboSpan" id="kobo.457.1">As we did for </span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.458.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">Book</span></strong><span class="koboSpan" id="kobo.460.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">Author</span></strong><span class="koboSpan" id="kobo.462.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">Publisher</span></strong><span class="koboSpan" id="kobo.464.1"> objects, we need to introduce a new object called </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">Review.class</span></strong><span class="koboSpan" id="kobo.466.1">. </span><span class="koboSpan" id="kobo.466.2">You can also check it out in the GitHub repository, under the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">data</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.468.1"> package:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.469.1">
@Document(collection = "reviews")
@Data
public class Review {
    @Id
    private String id;
    private Long bookId;
    private String reviewerName;
    private String comment;
    private int rating;
}</span></pre> <p><span class="koboSpan" id="kobo.470.1">You can see the difference from other data objects. </span><span class="koboSpan" id="kobo.470.2">There is a new annotation here called </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">@Document</span></strong><span class="koboSpan" id="kobo.472.1">. </span><span class="koboSpan" id="kobo.472.2">This annotation refers to the collection of this object. </span><span class="koboSpan" id="kobo.472.3">So, whatever we put in this object will be written under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">reviews</span></strong><span class="koboSpan" id="kobo.474.1"> collection. </span><span class="koboSpan" id="kobo.474.2">We have just introduced some basic fields a review </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">might need.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">And now, we also need a repository to manage this document in MongoDB. </span><span class="koboSpan" id="kobo.476.2">Let’s introduce the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">ReviewRepository</span></strong><span class="koboSpan" id="kobo.478.1"> class under the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">repositories</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.480.1"> package:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.481.1">
public interface ReviewRepository extends MongoRepository&lt;Review, String&gt; { }</span></pre> <p><span class="koboSpan" id="kobo.482.1">That’s it! </span><span class="koboSpan" id="kobo.482.2">Now, we </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.483.1">can manage the data wherever we want. </span><span class="koboSpan" id="kobo.483.2">We are extending from </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">MongoRepository</span></strong><span class="koboSpan" id="kobo.485.1"> instead of JPA repository interfaces. </span><span class="koboSpan" id="kobo.485.2">This is the only difference between </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">BookRepository</span></strong><span class="koboSpan" id="kobo.487.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">AuthorRepository</span></strong><span class="koboSpan" id="kobo.489.1">. </span><span class="koboSpan" id="kobo.489.2">So, now we have all CRUD functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">findById()</span></strong><span class="koboSpan" id="kobo.491.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">save()</span></strong><span class="koboSpan" id="kobo.493.1">. </span><span class="koboSpan" id="kobo.493.2">Also, this can be customized for more complex business requirements. </span><span class="koboSpan" id="kobo.493.3">We can start implementing the controller for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">Review</span></strong><span class="koboSpan" id="kobo.495.1"> object in the </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">next section.</span></span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.497.1">Implementing a hybrid data model in the online bookstore</span></h2>
<p><span class="koboSpan" id="kobo.498.1">Our project has </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.499.1">now evolved into a hybrid model, integrating </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.500.1">both SQL (PostgreSQL) and NoSQL (MongoDB) databases. </span><span class="koboSpan" id="kobo.500.2">So, let’s expose the </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">review</span></strong><span class="koboSpan" id="kobo.502.1"> object to the REST world so we can create and read the reviews </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">in MongoDB.</span></span></p>
<p><span class="koboSpan" id="kobo.504.1">We need to create a new controller class in the </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">controller package:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.506.1">
@RestController
@RequestMapping("/reviews")
@RequiredArgsConstructor
public class ReviewController {
    private final ReviewRepository reviewRepository;
    @PostMapping
    public ResponseEntity&lt;Review&gt; addReview(@RequestBody Review review) {
        Review savedReview = reviewRepository.save(review);
        return ResponseEntity.ok(savedReview);
    }
    @GetMapping("/{id}")
    public ResponseEntity&lt;Review&gt; getReview(@PathVariable String id) {
        Optional&lt;Review&gt; review = reviewRepository.findById(id);
        return review.map(ResponseEntity::ok).orElseGet(() -&gt; ResponseEntity.notFound().build());
    }
}</span></pre> <p><span class="koboSpan" id="kobo.507.1">As you can see, there</span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.508.1"> is no difference between</span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.509.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">BookController</span></strong><span class="koboSpan" id="kobo.511.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">ReviewController</span></strong><span class="koboSpan" id="kobo.513.1"> classes, because we have isolated the database layer from the repository level. </span><span class="koboSpan" id="kobo.513.2">These two endpoints expose </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">GET</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.515.1">review</span></strong><span class="koboSpan" id="kobo.516.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">POST</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.518.1">review</span></strong><span class="koboSpan" id="kobo.519.1"> endpoints. </span><span class="koboSpan" id="kobo.519.2">You can introduce the rest of the CRUD endpoints or you can check out the </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">GitHub repository.</span></span></p>
<p><span class="koboSpan" id="kobo.521.1">Let’s do some </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">curl</span></strong><span class="koboSpan" id="kobo.523.1"> requests to see how </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">it works:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.525.1">
curl -X POST --location "http://localhost:8080/reviews"
    -H "Content-Type: application/json"
    -d "{\"bookId\": 1, \"reviewerName\": \"Reader\", \"comment\": \"A great book to read\", \"rating\": 5}"</span></pre> <p><span class="koboSpan" id="kobo.526.1">The response will be </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.528.1">
{
  "id": "65adb0d7c8d33f5ab035b517",
  "bookId": 1,
  "reviewerName": "Reader",
  "comment": "A great book to read",
  "rating": 5
}</span></pre> <p><span class="koboSpan" id="kobo.529.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">id</span></strong><span class="koboSpan" id="kobo.531.1"> of the record is generated by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">@Id</span></strong><span class="koboSpan" id="kobo.533.1"> annotation in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">Review</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.535.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.536.1">And this is how it looks </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">in MongoDB:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.538.1"><img alt="Figure 4.2 – MongoDB data view" src="image/B18400_04_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.539.1">Figure 4.2 – MongoDB data view</span></p>
<p><span class="koboSpan" id="kobo.540.1">In this figure, we can </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.541.1">see how MongoDB tags our object</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.542.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">_class</span></strong><span class="koboSpan" id="kobo.544.1"> attribute. </span><span class="koboSpan" id="kobo.544.2">This exploration of NoSQL databases, with a focus on MongoDB, in a Spring Boot context has broadened our understanding of managing diverse data types in modern applications. </span><span class="koboSpan" id="kobo.544.3">By implementing MongoDB in the online bookstore management system, we have not only enriched the application with new features but also embraced the advantages of a hybrid </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">database approach.</span></span></p>
<p><span class="koboSpan" id="kobo.546.1">As we conclude this section, our journey through the data landscape of Spring Boot continues. </span><span class="koboSpan" id="kobo.546.2">Next, we delve into cache abstraction in Spring Boot, where we will explore strategies to optimize application performance. </span><span class="koboSpan" id="kobo.546.3">This progression from NoSQL databases to caching techniques exemplifies the comprehensive nature of data management in Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">Boot applications.</span></span></p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.548.1">Spring Boot cache abstraction</span></h1>
<p><span class="koboSpan" id="kobo.549.1">In this section, we will delve into </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.550.1">cache abstraction in Spring Boot. </span><span class="koboSpan" id="kobo.550.2">This is one of the significant facilitating components for maximizing your application’s performance. </span><span class="koboSpan" id="kobo.550.3">We’ll see what cache abstraction is, how to do its setup, and finally, how to use it in our application. </span><span class="koboSpan" id="kobo.550.4">We will show this using our online bookstore </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">management system.</span></span></p>
<p><span class="koboSpan" id="kobo.552.1">Your application will gain from cache abstraction since it sits on top of your caching system, remembering the information that is used repeatedly, giving your application a faster execution speed. </span><span class="koboSpan" id="kobo.552.2">It is similar to placing your frequently used tools on top of your desk so you don’t search for them every time. </span><span class="koboSpan" id="kobo.552.3">This comes with a time gain since your application doesn’t have to keep fetching this information over and over again from slow sources such </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">as databases.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">Let us now see how to add </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.555.1">cache abstraction to your Spring Boot application, which will make your app run more smoothly. </span><span class="koboSpan" id="kobo.555.2">In the above context, caching is what can be used to quickly display book details or user reviews that are not </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">changed frequently.</span></span></p>
<p><span class="koboSpan" id="kobo.557.1">By the end of this part, you will know how to make your Spring Boot app faster with caching. </span><span class="koboSpan" id="kobo.557.2">It’s a very nice skill to have in your arsenal for the development of better, </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">faster apps.</span></span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.559.1">Understanding cache abstraction</span></h2>
<p><span class="koboSpan" id="kobo.560.1">So, let us dive into understanding cache abstraction in Spring Boot and why it is like a superpower for your app’s performance. </span><strong class="bold"><span class="koboSpan" id="kobo.561.1">Cache abstraction</span></strong><span class="koboSpan" id="kobo.562.1"> is just storing some pieces of information that your app uses a lot in any application in some special memory space. </span><span class="koboSpan" id="kobo.562.2">This way, the app does </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.563.1">not have to keep asking for the same information over and over again – this can be a </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">total bummer.</span></span></p>
<p><span class="koboSpan" id="kobo.565.1">Using cache abstraction in Spring Boot is pretty simple and carries big dividends. </span><span class="koboSpan" id="kobo.565.2">For instance, in our online bookstore app, we can use caching to remember the details of a book. </span><span class="koboSpan" id="kobo.565.3">Normally, every time somebody wants to see a book, the app has to ask for the information from the database. </span><span class="koboSpan" id="kobo.565.4">With caching, after the application has asked for a book’s details, it </span><em class="italic"><span class="koboSpan" id="kobo.566.1">remembers</span></em><span class="koboSpan" id="kobo.567.1"> them. </span><span class="koboSpan" id="kobo.567.2">And so, the next time somebody wants to see that book, the application can show the details super quickly without going back to the database. </span><span class="koboSpan" id="kobo.567.3">This helps to run your app faster, reduces the load on your database, and gives your users an </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">enhanced experience.</span></span></p>
<p><span class="koboSpan" id="kobo.569.1">Next in this section, we will be looking at how easily caching in Spring Boot 3.0 can be set up and what difference it can make in your app. </span><span class="koboSpan" id="kobo.569.2">We’ll walk through some practical steps to integrate caching within our bookstore app in a way that shows how it could speed things up even more for features that don’t change often. </span><span class="koboSpan" id="kobo.569.3">This is one of the key techniques if you want to build efficient and </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">user-friendly apps.</span></span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.571.1">Configuring and using cache abstraction in the application</span></h2>
<p><span class="koboSpan" id="kobo.572.1">In this section, we’re </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.573.1">going to see how cache abstraction can be implemented effortlessly in Spring Boot 3.0, particularly in our bookstore application. </span><span class="koboSpan" id="kobo.573.2">Cache abstraction is not about the performance boost only but also about making it simple for us to handle the frequently accessed data in our applications. </span><span class="koboSpan" id="kobo.573.3">That reaches a whole new level of simplicity with Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">Boot 3.0.</span></span></p>
<p><span class="koboSpan" id="kobo.575.1">Under the terms of our bookstore app, effectively using cache abstraction implies that often referred to data such as a book’s details are available without hitting the database over and over again. </span><span class="koboSpan" id="kobo.575.2">This is important in improving user experience from two perspectives: reducing the wait time and reducing the </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">server load.</span></span></p>
<p><span class="koboSpan" id="kobo.577.1">Let’s see how easy it is to implement caching in Spring Boot 3.0. </span><span class="koboSpan" id="kobo.577.2">There are two simple steps to enable caching in </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">our project:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.579.1">First, we need to add the library to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">build.gradle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.581.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.582.1">
implementation 'org.springframework.boot:spring-boot-starter-cache'</span></pre></li> <li><span class="koboSpan" id="kobo.583.1">Next, we will add </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">@EnableCaching</span></strong><span class="koboSpan" id="kobo.585.1"> on top of our </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">main class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.587.1">
@SpringBootApplication
@EnableCaching
public class BookstoreApplication {
    public static void main(String[] args) {
        SpringApplication.run(BookstoreApplication.class, args);
    }
}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.588.1">That’s it! </span><span class="koboSpan" id="kobo.588.2">We are now ready to use caching wherever </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">we need.</span></span></p>
<p><span class="koboSpan" id="kobo.590.1">Let’s look at how caching is implemented in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">BookController</span></strong><span class="koboSpan" id="kobo.592.1"> class of our bookstore app. </span><span class="koboSpan" id="kobo.592.2">The controller already has several endpoints – for adding, fetching, updating, and deleting books. </span><span class="koboSpan" id="kobo.592.3">We’ll focus on integrating Spring Boot’s cachin</span><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.593.1">g capabilities to optimize </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">these operations.</span></span></p>
<h3><span class="koboSpan" id="kobo.595.1">Using @CacheEvict for adding, updating, and deleting books</span></h3>
<p><span class="koboSpan" id="kobo.596.1">When a new book is</span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.597.1"> added or an existing one is updated, it’s essential to ensure that our cache reflects these changes. </span><span class="koboSpan" id="kobo.597.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">@CacheEvict</span></strong><span class="koboSpan" id="kobo.599.1"> annotation is used here to invalidate the cache. </span><span class="koboSpan" id="kobo.599.2">This means that the cached data is removed or updated, ensuring that subsequent requests fetch the most </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">recent data.</span></span></p>
<p><span class="koboSpan" id="kobo.601.1">This is what they will </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">look like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.603.1">
@PutMapping("/{id}")
@CacheEvict(value = "books", allEntries = true)
public ResponseEntity&lt;Book&gt; updateBook(@PathVariable Long id, @RequestBody Book book) {...}
@PostMapping
@CacheEvict(value = "books", allEntries = true) // Invalidate the entire books cache
public ResponseEntity&lt;Book&gt; addBook(@RequestBody Book book) {...}</span></pre> <p><span class="koboSpan" id="kobo.604.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">addBook</span></strong><span class="koboSpan" id="kobo.606.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">updateBook</span></strong><span class="koboSpan" id="kobo.608.1"> methods, </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">@CacheEvict(value = "books", allEntries = true)</span></strong><span class="koboSpan" id="kobo.610.1"> effectively clears the cache of all entries related to books. </span><span class="koboSpan" id="kobo.610.2">This approach guarantees that the cache does not serve </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">outdated information.</span></span></p>
<p><span class="koboSpan" id="kobo.612.1">Similarly, when a book is deleted, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">@CacheEvict(value = "books", key = "#id")</span></strong><span class="koboSpan" id="kobo.614.1"> to remove only the cache entry for that specific book. </span><span class="koboSpan" id="kobo.614.2">This targeted approach helps us to maintain cache accuracy without affecting other </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">cached data.</span></span></p>
<h3><span class="koboSpan" id="kobo.616.1">Efficient retrieval with caching</span></h3>
<p><span class="koboSpan" id="kobo.617.1">Although not</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.618.1"> explicitly shown in the provided code, fetching operations (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">getAllBooks</span></strong><span class="koboSpan" id="kobo.620.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">getBook</span></strong><span class="koboSpan" id="kobo.622.1">) can be optimized using </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">@Cacheable</span></strong><span class="koboSpan" id="kobo.624.1">. </span><span class="koboSpan" id="kobo.624.2">This annotation ensures that the result of a method call is stored in the cache, making subsequent requests for the same data faster and </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">more efficient.</span></span></p>
<p><span class="koboSpan" id="kobo.626.1">Also, we can implement this feature at the repository level. </span><span class="koboSpan" id="kobo.626.2">For example, we can introduce a query and make </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">it cacheable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.628.1">
    @Override
    @Cacheable( "books")
    Optional&lt;Book&gt; findById(Long id);</span></pre> <p><span class="koboSpan" id="kobo.629.1">We don’t need some analyzer to see the difference; just run the application and see how you will get a faster response to your </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">second call.</span></span></p>
<p><span class="koboSpan" id="kobo.631.1">In summary, cache abstraction in Spring Boot 3.0 is a powerful and straightforward way to optimize data retrieval processes. </span><span class="koboSpan" id="kobo.631.2">We have seen how easy it is to implement in the bookstore application. </span><span class="koboSpan" id="kobo.631.3">By utilizing cache control annotations such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">@CacheEvict</span></strong><span class="koboSpan" id="kobo.633.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">@Cacheable</span></strong><span class="koboSpan" id="kobo.635.1">, we ensure that our application remains responsive and efficient and always keeps </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">accrual data.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.637.1">In conclusion</span></h2>
<p><span class="koboSpan" id="kobo.638.1">To conclude this exploration of cache abstraction in Spring Boot, we learned about the significant advantages it provides us when it is undertaken to enhance application performance. </span><span class="koboSpan" id="kobo.638.2">We have noticed that caching can bring a lot of improvement to the rapid accessing of data, particularly simple repetitive retrieval of information such as book details in our online bookstore management system. </span><span class="koboSpan" id="kobo.638.3">We have learned from the implementation of cache abstraction that it not only drastically reduces the load on the database but also delivers a smooth, quick </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">user experience.</span></span></p>
<p><span class="koboSpan" id="kobo.640.1">This tour through cache abstraction has given us pragmatic tools that are absolutely essential in the fast-moving technology environments of today. </span><span class="koboSpan" id="kobo.640.2">It is quite evident that understanding and using a cache properly is an important key in developing efficient and responsive applications with </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">Spring Boot.</span></span></p>
<p><span class="koboSpan" id="kobo.642.1">Next, we will get into the world of batch processing in Spring Boot. </span><span class="koboSpan" id="kobo.642.2">We will dig deeper into how to efficiently handle huge sets of data, which are commonly required for applications that are meant for processing high volumes of records. </span><span class="koboSpan" id="kobo.642.3">Batch processing is another key tool in our toolkit for getting things done with Spring Boot, helping us to manage data at scale from all aspects while ensuring our applications cope well without being burdened to the max with </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">complex tasks.</span></span></p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.644.1">Spring Boot batch processing</span></h1>
<p><span class="koboSpan" id="kobo.645.1">Now let’s take a look at one of the </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.646.1">most important features of Spring Boot: batch processing. </span><span class="koboSpan" id="kobo.646.2">We’ll look at how you can manage and process huge amounts of data in an effective manner with Spring Boot. </span><span class="koboSpan" id="kobo.646.3">Batch processing is especially important when your application has to handle tasks such as importing big datasets or performing actions on a large number of records </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">at once.</span></span></p>
<p><span class="koboSpan" id="kobo.648.1">In this part of our guide, we’ll cover three main areas. </span><span class="koboSpan" id="kobo.648.2">To begin with, let’s discuss batch processing in Spring Boot, why it is so crucial at the very beginning of our discussion, and how it can be a game changer for any enterprise or any application related to hefty data operations. </span><span class="koboSpan" id="kobo.648.3">Next, we’ll walk through the detailed setup and execution of batch jobs – a key aspect for efficiently handling large-scale </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">data tasks.</span></span></p>
<p><span class="koboSpan" id="kobo.650.1">Last, but the most interesting, we’ll look at how batch processing can be actually implemented in our online bookstore project. </span><span class="koboSpan" id="kobo.650.2">Imagine how infeasible it would be to have to upload thousands of books or publisher details into the system – batch processing would make such a task extremely feasible. </span><span class="koboSpan" id="kobo.650.3">If you apply all these concepts to the bookstore, you’ll get a real feel of how batch processing works in live applications such as book imports </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">in bulk.</span></span></p>
<p><span class="koboSpan" id="kobo.652.1">By the end of this section, you’ll have a solid grasp of batch processing in Spring Boot and the power to wield it effectively in real-world use cases. </span><span class="koboSpan" id="kobo.652.2">This is critical stuff to know, especially when developing web applications that need high throughput data management for many purposes. </span><span class="koboSpan" id="kobo.652.3">Let’s get started and discover how batch processing can enhance the capabilities of our Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">Boot applications.</span></span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.654.1">Understanding the role of batch processing in Spring Boot</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.655.1">Batch processing</span></strong><span class="koboSpan" id="kobo.656.1"> is a</span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.657.1"> lightweight and very effective way to process large amounts of data. </span><span class="koboSpan" id="kobo.657.2">It’s sort of like having a super-efficient assembly line in your app where big data chores are broken down and processed in manageable batches, especially so if your application is to perform heavy-duty work that involves processing thousands of records at </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">a time.</span></span></p>
<p><span class="koboSpan" id="kobo.659.1">Batch processing in Spring Boot will enable the management of such large-scale data operations. </span><span class="koboSpan" id="kobo.659.2">It helps in the organizing, executing, and automation of the bulk processing of data that is required in many modern-day applications. </span><span class="koboSpan" id="kobo.659.3">Most batch-processing jobs are continuous processes, not one-time processes. </span><span class="koboSpan" id="kobo.659.4">Remember, we have to introduce new books, publishers, and authors to our platform every week or every day. </span><span class="koboSpan" id="kobo.659.5">A batch process will handle it for us automatically in a </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">simple way.</span></span></p>
<p><span class="koboSpan" id="kobo.661.1">You will learn the significance of </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.662.1">batch processing in Spring Boot; you will be able to handle scenarios that involve handling large amounts of datasets and executing them, where the system is not affected. </span><span class="koboSpan" id="kobo.662.2">This is an essential skill to have for developers working on data-intensive applications and to make sure that your app can handle big tasks without seeming to break a sweat. </span><span class="koboSpan" id="kobo.662.3">As we proceed, you will begin to see how batch processing is implemented and the magnitude of the impact it may have on the performance and efficiency of </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">your application.</span></span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.664.1">Implementing Spring Batch</span></h2>
<p><span class="koboSpan" id="kobo.665.1">After all </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.666.1">this theoretical information, we must get our hands dirty to </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">learn better.</span></span></p>
<p><span class="koboSpan" id="kobo.668.1">In this section, we’ll learn how to set up batch processes in Spring Boot 3.0. </span><span class="koboSpan" id="kobo.668.2">We’ll introduce a separate batch repository application, showing you step by step how to handle tasks such as bulk book imports for our </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">online bookstore.</span></span></p>
<h3><span class="koboSpan" id="kobo.670.1">Creating a batch processing application</span></h3>
<p><span class="koboSpan" id="kobo.671.1">We will start by setting up a new</span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.672.1"> Spring Boot project dedicated to batch processing. </span><span class="koboSpan" id="kobo.672.2">We can use the following dependencies in </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">the project:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.674.1">
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-batch'
    compileOnly 'org.projectlombok:lombok'
    runtimeOnly 'org.postgresql:postgresql'
    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}</span></pre> <p><span class="koboSpan" id="kobo.675.1">We have also </span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.676.1">added a PostgreSQL dependency because we would like to import the bulk data into the </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">PostgreSQL database.</span></span></p>
<h3><span class="koboSpan" id="kobo.678.1">Introducing the Publisher class</span></h3>
<p><span class="koboSpan" id="kobo.679.1">We need to</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.680.1"> add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">Publisher</span></strong><span class="koboSpan" id="kobo.682.1"> class again as it is under the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">data</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.684.1"> package:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.685.1">
@Entity
@Table(name = "publishers")
@Data
public class Publisher {
    @Id @GeneratedValue
    private Long id;
    private String name;
    private String address;
}</span></pre> <p><span class="koboSpan" id="kobo.686.1">We will deal with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">Publisher</span></strong><span class="koboSpan" id="kobo.688.1"> object in batch processing. </span><span class="koboSpan" id="kobo.688.2">So, we need the same exact object as we used in </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">our project.</span></span></p>
<h3><span class="koboSpan" id="kobo.690.1">Configuring a batch job</span></h3>
<p><span class="koboSpan" id="kobo.691.1">Let’s define a batch job in our</span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.692.1"> application. </span><span class="koboSpan" id="kobo.692.2">This involves specifying the steps the job will take, such as reading data, processing it, and then writing the results. </span><span class="koboSpan" id="kobo.692.3">Create a package named </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">config</span></strong><span class="koboSpan" id="kobo.694.1"> and create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">BatchConfig.java</span></strong><span class="koboSpan" id="kobo.696.1"> file. </span><span class="koboSpan" id="kobo.696.2">Everything we need will be done in </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">this file.</span></span></p>
<p><span class="koboSpan" id="kobo.698.1">First, we need to understand the flow here. </span><span class="koboSpan" id="kobo.698.2">Our sample code will have one job, but depending on the requirements, we can define </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">multiple jobs.</span></span></p>
<p><span class="koboSpan" id="kobo.700.1">This is what a </span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.701.1">job </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">looks like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.703.1">
  @Bean
    public Job importPublisherJob(JobRepository jobRepository, Step step1) {
        return new JobBuilder("importPublisherJob", jobRepository)
                .incrementer(new RunIdIncrementer())
                .start(step1)
                .build();
    }</span></pre> <p><span class="koboSpan" id="kobo.704.1">As you can see, we have just a job repository and steps. </span><span class="koboSpan" id="kobo.704.2">In our example, we have one step, but we may have more than one, depending on </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">the requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.706.1">Let’s look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">Step</span></strong><span class="koboSpan" id="kobo.708.1"> function because it will explain to us how a step can </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">be built:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.710.1">
@Bean
public Step step1(JobRepository jobRepository,
                  PlatformTransactionManager transactionManager,
                  ItemReader&lt;Publisher&gt; reader,
                  ItemProcessor&lt;Publisher, Publisher&gt; processor,
                  ItemWriter&lt;Publisher&gt; writer) {
    StepBuilder stepBuilder = new StepBuilder("step1",jobRepository);
    return stepBuilder.&lt;Publisher, Publisher &gt;chunk(10, transactionManager)
            .reader(reader)
            .processor(processor)
            .writer(writer)
            .build();
}</span></pre> <p><span class="koboSpan" id="kobo.711.1">As you can see, a step has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">reader</span></strong><span class="koboSpan" id="kobo.713.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">processor</span></strong><span class="koboSpan" id="kobo.715.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">writer</span></strong><span class="koboSpan" id="kobo.717.1"> method. </span><span class="koboSpan" id="kobo.717.2">The functions of these methods are hidden in their names, literally. </span><span class="koboSpan" id="kobo.717.3">These functions basically read the data, process</span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.718.1"> the data if needed, do some processes on it like setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">address</span></strong><span class="koboSpan" id="kobo.720.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">name</span></strong><span class="koboSpan" id="kobo.722.1"> values, and write it to the repository. </span><span class="koboSpan" id="kobo.722.2">Let’s look at them one by one in the </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">next section.</span></span></p>
<h3><span class="koboSpan" id="kobo.724.1">Reading, processing, and writing data</span></h3>
<p><span class="koboSpan" id="kobo.725.1">For each step in the batch job, define how the application will read, process, and </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">write data.</span></span></p>
<p><span class="koboSpan" id="kobo.727.1">In the preceding code</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.728.1"> example, you can see how to read publisher data from a </span><strong class="bold"><span class="koboSpan" id="kobo.729.1">Comma-Separated Values</span></strong><span class="koboSpan" id="kobo.730.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.731.1">CSV</span></strong><span class="koboSpan" id="kobo.732.1">) file, process</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.733.1"> it to map it to your publisher entity, and then write it to </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">the database.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.735.1">
@Bean
public FlatFileItemReader&lt;Publisher&gt; reader() {
    return new FlatFileItemReaderBuilder&lt;Publisher&gt;()
            .name("bookItemReader")
            .resource(new ClassPathResource("publishers.csv"))
            .delimited()
            .names(new String[]{"name", "address"})
            .fieldSetMapper(new BeanWrapperFieldSetMapper&lt;&gt;() {{
                setTargetType(Publisher.class);
            }}).linesToSkip(1)
            .build();
}</span></pre> <p><span class="koboSpan" id="kobo.736.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">reader</span></strong><span class="koboSpan" id="kobo.738.1">, we define where to</span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.739.1"> read data and how to parse the data. </span><span class="koboSpan" id="kobo.739.2">We also map the data to our entity object, and in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">processor</span></strong><span class="koboSpan" id="kobo.741.1"> function, we can convert it to the required object </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">or objects.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.743.1">
@Bean
public ItemProcessor&lt;Publisher, Publisher&gt; processor() {
    return publisher -&gt; {
        publisher.setAddress(publisher.getAddress().toUpperCase());
        publisher.setName(publisher.getName().toUpperCase());
        return publisher;
    };
}</span></pre> <p><span class="koboSpan" id="kobo.744.1">Here is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">processor</span></strong><span class="koboSpan" id="kobo.746.1"> function. </span><span class="koboSpan" id="kobo.746.2">We </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.747.1">can do all the processing steps in this function. </span><span class="koboSpan" id="kobo.747.2">As an example, I have converted the text </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">to uppercase.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.749.1">
@Bean
public JpaItemWriter&lt;Publisher&gt; writer() {
    JpaItemWriter&lt;Publisher&gt; writer = new JpaItemWriter&lt;&gt;();
    writer.setEntityManagerFactory(entityManagerFactory);
    return writer;
}</span></pre> <p><span class="koboSpan" id="kobo.750.1">Finally, this is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">writer</span></strong><span class="koboSpan" id="kobo.752.1"> object; it gets the </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.753.1">processed data from the processor and writes it to the database. </span><span class="koboSpan" id="kobo.753.2">In the next step, we will execute our application and discuss </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">the output.</span></span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.755.1">Executing the batch job</span></h2>
<p><span class="koboSpan" id="kobo.756.1">Once the batch job is set, it </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.757.1">triggers to run either on an event or on a schedule. </span><span class="koboSpan" id="kobo.757.2">This serves to trigger the job to kick-start the processing and manipulation of the big dataset in a very efficient management process of the </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">job task.</span></span></p>
<p><span class="koboSpan" id="kobo.759.1">You can create a simple CSV file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">Resources</span></strong><span class="koboSpan" id="kobo.761.1"> folder. </span><span class="koboSpan" id="kobo.761.2">We can name it </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">publishers.csv</span></strong><span class="koboSpan" id="kobo.763.1">. </span><span class="koboSpan" id="kobo.763.2">This name should match the filename in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">reader</span></strong><span class="koboSpan" id="kobo.765.1"> function. </span><span class="koboSpan" id="kobo.765.2">The sample data will be </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">as follows:</span></span></p>
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">name,address</span></strong></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">Publisher Name </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">1,Address 1</span></strong></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">Publisher Name </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">2,Address 2</span></strong></span></p>
<p><span class="koboSpan" id="kobo.772.1">You can write as many rows as you want. </span><span class="koboSpan" id="kobo.772.2">And we can run our bookstore batch application. </span><span class="koboSpan" id="kobo.772.3">We will see these values have been imported into our PostgreSQL database as processed (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.773.1">Figure 4</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.774.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">).</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<span class="koboSpan" id="kobo.776.1"><img alt="Figure 4.3 – Publishers table after batch operation" src="image/B18400_04_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.777.1">Figure 4.3 – Publishers table after batch operation</span></p>
<p><span class="koboSpan" id="kobo.778.1">As we can see in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.779.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.780.1">.3</span></em><span class="koboSpan" id="kobo.781.1">, the values are uppercased </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">while importing.</span></span></p>
<p><span class="koboSpan" id="kobo.783.1">With such batch processing, this would properly allow managing the large data tasks that will come through our online bookstore application. </span><span class="koboSpan" id="kobo.783.2">This also makes our data handling efficient and subsequently scalable to manage large-scale data operations in our database while the application </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">is running.</span></span></p>
<p><span class="koboSpan" id="kobo.785.1">In conclusion to our exploration of batch processing in Spring Boot 3.0, we gained valuable insights into handling immense datasets efficiently. </span><span class="koboSpan" id="kobo.785.2">We have seen how doing so not only streamlines the process of breaking up massive data tasks into manageable chunks but also helps to make our application perform better. </span><span class="koboSpan" id="kobo.785.3">Within the context of our online bookstore, batch processing has demonstrated how important this feature is in managing large volumes of data, such as bulk </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">publisher imports.</span></span></p>
<p><span class="koboSpan" id="kobo.787.1">On this journey, we learned that batch processing is not just a technical necessity but also an important strategic way to handle intelligent data-intensive operations in Spring Boot. </span><span class="koboSpan" id="kobo.787.2">This insight becomes especially important while working with applications that need to process large volumes of data as part of their business workloads, in the background periodically </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">and regularly.</span></span></p>
<p><span class="koboSpan" id="kobo.789.1">Now, as we move on to our next section, we are poised to dive into data migration and consistency. </span><span class="koboSpan" id="kobo.789.2">We’ve seen some powerful strategies for keeping and evolving the data structure of our applications without any seams. </span><span class="koboSpan" id="kobo.789.3">This is an important aspect to make sure that the handling of data by our applications not only remains efficient but is more reliable and sturdy over time. </span><span class="koboSpan" id="kobo.789.4">So, let’s move forward, geared up for new challenges, thereby strengthening our command of these advanced features of </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">Spring Boot.</span></span></p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.791.1">Data migration and consistency</span></h1>
<p><span class="koboSpan" id="kobo.792.1">In this critical section, we look at data migration</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.793.1"> and consistency with Spring Boot. </span><span class="koboSpan" id="kobo.793.2">We will talk about how we can</span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.794.1"> actually migrate and even amend crucial data in our applications without compromising precision or causing problems. </span><span class="koboSpan" id="kobo.794.2">We are going to detail some strategies for data migration, and we’re specifically going to look at tools such as Liquibase, which enables the management and even automation of </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">such processes.</span></span></p>
<p><span class="koboSpan" id="kobo.796.1">Before that, we are going to start with an introduction to data migration strategies and offer a view on why these are relevant in order to keep your application healthy. </span><span class="koboSpan" id="kobo.796.2">Then, we are going to proceed with the practical steps of data migration implementation with Liquibase as a core tool. </span><span class="koboSpan" id="kobo.796.3">Namely, we will find out how to integrate Liquibase into your project and use it for managing </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">database changes.</span></span></p>
<p><span class="koboSpan" id="kobo.798.1">These strategies will be implemented practically in our online bookstore. </span><span class="koboSpan" id="kobo.798.2">We will see how we can add new features to the bookstore by applying data migration and consistency techniques that could keep the existing data consistent and reliable. </span><span class="koboSpan" id="kobo.798.3">Let’s get started and unlock the skills to manage data changes smoothly </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">and efficiently.</span></span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.800.1">Exploring data migration strategies and tools like Liquibase</span></h2>
<p><span class="koboSpan" id="kobo.801.1">In this section, we’re going to dive</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.802.1"> into </span><strong class="bold"><span class="koboSpan" id="kobo.803.1">data migration strategies</span></strong><span class="koboSpan" id="kobo.804.1">. </span><span class="koboSpan" id="kobo.804.2">We will focus on understanding their importance and how tools like Liquibase are important. </span><strong class="bold"><span class="koboSpan" id="kobo.805.1">Data migration</span></strong><span class="koboSpan" id="kobo.806.1"> is all</span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.807.1"> about moving data from one system to another, or from one version of a database to another, in a way that’s safe, efficient, and reliable. </span><span class="koboSpan" id="kobo.807.2">It’s a vital process, especially when updating or improving </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">your application.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.809.1">Liquibase</span></strong><span class="koboSpan" id="kobo.810.1"> is a </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.811.1">key tool and is like a skilled architect for your data migration. </span><span class="koboSpan" id="kobo.811.2">It helps manage database revisions, track changes, and apply them consistently across different environments. </span><span class="koboSpan" id="kobo.811.3">This tool uses a simple format for defining database changes, making it easier to track and implement changes </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.813.1">If we understand and apply the strategies of data migration tools like Liquibase, then we will be well placed to handle the evolution of our applications’ requirements </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">very effectively.</span></span></p>
<p><span class="koboSpan" id="kobo.815.1">As we wind up this section, we’re preparing to delve into the world of ensuring data consistency that builds on our understanding of migration and how it happens. </span><span class="koboSpan" id="kobo.815.2">This next topic will focus on techniques used in maintaining data integrity throughout data changes, as covered in the previous topic. </span><span class="koboSpan" id="kobo.815.3">Stay tuned as we continue to navigate the intricate landscape of data management in Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">Boot applications.</span></span></p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.817.1">Practical steps for implementing data migration using Liquibase</span></h2>
<p><span class="koboSpan" id="kobo.818.1">When it comes to updating or changing your application’s database, data migration is a crucial step. </span><span class="koboSpan" id="kobo.818.2">In this section, we’ll walk through the practical steps of implementing data migration. </span><span class="koboSpan" id="kobo.818.3">We will use Liquibase. </span><span class="koboSpan" id="kobo.818.4">We will see how it is a powerful tool that helps manage </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">database changes.</span></span></p>
<h3><span class="koboSpan" id="kobo.820.1">Integrating Liquibase into your project</span></h3>
<p><span class="koboSpan" id="kobo.821.1">The first step is to add </span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.822.1">Liquibase to your project. </span><span class="koboSpan" id="kobo.822.2">You can open your book store application, or you can follow these steps in one of your Spring Boot applications to implement Liquibase. </span><span class="koboSpan" id="kobo.822.3">As we have been using Gradle since the beginning, we need to add a dependency in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">build.gradle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.824.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.825.1">
implementation 'org.liquibase:liquibase-core'</span></pre> <p><span class="koboSpan" id="kobo.826.1">This will import all necessary libraries into </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">your project.</span></span></p>
<h3><span class="koboSpan" id="kobo.828.1">Setting up the Liquibase configuration</span></h3>
<p><span class="koboSpan" id="kobo.829.1">Next, you need to configure</span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.830.1"> Liquibase in your application. </span><span class="koboSpan" id="kobo.830.2">This involves specifying the database connection properties and the path to your change log file, which will contain all the database changes you want to apply. </span><span class="koboSpan" id="kobo.830.3">In our application, we will update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">application.properties</span></strong><span class="koboSpan" id="kobo.832.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.834.1">
spring.liquibase.change-log=classpath:/db/changelog/db.changelog-master.yaml</span></pre> <p><span class="koboSpan" id="kobo.835.1">As we already added our database connection settings here, I am just mentioning the line related </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">to Liquibase.</span></span></p>
<h3><span class="koboSpan" id="kobo.837.1">Creating a Liquibase change log</span></h3>
<p><span class="koboSpan" id="kobo.838.1">The change log file in Liquibase is </span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.839.1">where you define your database changes, such as creating new tables, adding columns, or modifying existing structures. </span><span class="koboSpan" id="kobo.839.2">Changes are written in XML, JSON, YAML, or SQL format. </span><span class="koboSpan" id="kobo.839.3">Here’s our sample in </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">YAML format:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.841.1">
databaseChangeLog:
  - includeAll:
      path: db/changelog/changes/</span></pre> <p><span class="koboSpan" id="kobo.842.1">Here, we have used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">includeAll</span></strong><span class="koboSpan" id="kobo.844.1"> method. </span><span class="koboSpan" id="kobo.844.2">It means check the path, sort files alphabetically, and start to execute them one by one. </span><span class="koboSpan" id="kobo.844.3">There is one more approach, in that we can define each file with </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">include</span></strong><span class="koboSpan" id="kobo.846.1"> and Liquibase will follow the orders in this file, not the files in </span><span class="No-Break"><span class="koboSpan" id="kobo.847.1">the folder.</span></span></p>
<h3><span class="koboSpan" id="kobo.848.1">Executing the migration</span></h3>
<p><span class="koboSpan" id="kobo.849.1">Once the change log file is created, Liquibase has </span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.850.1">the capability to perform such changes on your database. </span><span class="koboSpan" id="kobo.850.2">This could be done automatically at the startup of the application or manually running Liquibase commands. </span><span class="koboSpan" id="kobo.850.3">When execution takes place, the change log is read by Liquibase, and then, one by one, the changes get executed, as defined in the order in </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">databaseChangeLog</span></strong><span class="koboSpan" id="kobo.852.1"> or alphabetical order in </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.854.1">Following these steps will let you effectively handle such a change in your database for your projects and will keep you in control so that the probability of making mistakes during migration is reduced. </span><span class="koboSpan" id="kobo.854.2">This kind of approach becomes critical when we have applications evolving with time – like our online bookstore – where data integrity and consistency are paramount </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">in nature.</span></span></p>
<p><span class="koboSpan" id="kobo.856.1">Next, we’ll look into how we can use Liquibase in our </span><span class="No-Break"><span class="koboSpan" id="kobo.857.1">bookstore application.</span></span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.858.1">Implementing migration strategies in the online bookstore</span></h2>
<p><span class="koboSpan" id="kobo.859.1">Now, let’s apply what we’ve </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.860.1">learned about data migration strategies to our online bookstore project. </span><span class="koboSpan" id="kobo.860.2">This practical implementation will focus on integrating new features and maintaining data consistency throughout the process. </span><span class="koboSpan" id="kobo.860.3">Let’s assume we have a new requirement to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">published</span></strong><span class="koboSpan" id="kobo.862.1"> column in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">books</span></strong><span class="koboSpan" id="kobo.864.1"> table. </span><span class="koboSpan" id="kobo.864.2">We need to handle this requirement without breaking the data and by not touching the database server manually. </span><span class="koboSpan" id="kobo.864.3">When we need to run our application on another platform, we need to be sure we don’t need to do anything manually in the data structure; it will be handled by </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">the application.</span></span></p>
<h3><span class="koboSpan" id="kobo.866.1">Setting up Liquibase for migration</span></h3>
<p><span class="koboSpan" id="kobo.867.1">We have already </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.868.1">introduced the dependency and configuration for Liquibase in our bookstore application. </span><span class="koboSpan" id="kobo.868.2">Now, we will introduce a change </span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">log file.</span></span></p>
<p><span class="koboSpan" id="kobo.870.1">Let’s create a folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">changes</span></strong><span class="koboSpan" id="kobo.872.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">resources/db/changelog/</span></strong><span class="koboSpan" id="kobo.874.1">. </span><span class="koboSpan" id="kobo.874.2">This is the folder to which Liquibase listens. </span><span class="koboSpan" id="kobo.874.3">Then create a file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">001-add-published-column.yaml</span></strong><span class="koboSpan" id="kobo.876.1">. </span><span class="koboSpan" id="kobo.876.2">Naming is important for two reasons: As we mentioned before, Liquibase will sort files alphabetically and execute them accordingly. </span><span class="koboSpan" id="kobo.876.3">We need to keep this sorting aligned and the latest change always needs to be at the end of the list. </span><span class="koboSpan" id="kobo.876.4">The second reason is, when we read the filename, we need to understand what it includes. </span><span class="koboSpan" id="kobo.876.5">Otherwise, when we need to track some changes, it takes ages to find the </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">particular file.</span></span></p>
<p><span class="koboSpan" id="kobo.878.1">Here is a sample YAML file to add a published column to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">books</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.880.1"> table:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.881.1">
databaseChangeLog:
  - changeSet:
      id: 1
      author: ahmeric
      changes:
        - addColumn:
            tableName: books
            columns:
              - column:
                  name: published
                  type: boolean
                  defaultValue: false</span></pre> <p><span class="koboSpan" id="kobo.882.1">As you read the </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.883.1">content, you can understand what all these fields mean. </span><span class="koboSpan" id="kobo.883.2">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">author</span></strong><span class="koboSpan" id="kobo.885.1"> is the name of the developer who implements this change. </span><span class="koboSpan" id="kobo.885.2">It basically adds a new column with the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">published</span></strong><span class="koboSpan" id="kobo.887.1"> and the default value </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.891.1">This is enough to change the table in the database, but we also need it to be aligned in our application by updating our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">Book</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.893.1"> entity:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.894.1">
@Entity
@Table(name = "books")
@Data
public class Book {
    @Id @GeneratedValue
    private Long id;
    private String title;
    private String isbn;
    @ManyToMany
    private List&lt;Author&gt; authors;
    private Boolean published;
}</span></pre> <p><span class="koboSpan" id="kobo.895.1">So, when we fetch or save data, we will manage the database </span><span class="No-Break"><span class="koboSpan" id="kobo.896.1">table accordingly.</span></span></p>
<h3><span class="koboSpan" id="kobo.897.1">Executing the migration</span></h3>
<p><span class="koboSpan" id="kobo.898.1">With the change log </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.899.1">ready, we run Liquibase to apply these changes. </span><span class="koboSpan" id="kobo.899.2">This process will create the new column in the books table in our database without disrupting existing data. </span><span class="koboSpan" id="kobo.899.3">This is done carefully to ensure there is no downtime or loss of service for our </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">bookstore’s users.</span></span></p>
<p><span class="koboSpan" id="kobo.901.1">When you check your database, you will see the new column has been created, as you can see in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.902.1">Figure 4</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.903.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.905.1"><img alt="Figure 4.4 – Updated books table" src="image/B18400_04_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.906.1">Figure 4.4 – Updated books table</span></p>
<p><span class="koboSpan" id="kobo.907.1">As we make these changes, we continuously ensure that data consistency is maintained. </span><span class="koboSpan" id="kobo.907.2">This involves checking that the new data aligns with the existing data structures and follows all the </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">integrity rules.</span></span></p>
<p><span class="koboSpan" id="kobo.909.1">We have learned now that we should handle the new feature addition in our online bookstore carefully. </span><span class="koboSpan" id="kobo.909.2">Careful data migration helps the smooth addition of the new column to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">books</span></strong><span class="koboSpan" id="kobo.911.1"> table, thus maintaining the consistency as well as the reliability of the data. </span><span class="koboSpan" id="kobo.911.2">This is essential to keep the bookstore up to date and effective </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">for users.</span></span></p>
<p><span class="koboSpan" id="kobo.913.1">In this section, we have acquired the knowledge and skills to help us manage data as required in application development. </span><span class="koboSpan" id="kobo.913.2">This prepares us for future challenges and hence helps our applications remain relevant in the </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">digital world.</span></span></p>
<p><span class="koboSpan" id="kobo.915.1">Tools such as Liquibase enable us to change our database safely and efficiently. </span><span class="koboSpan" id="kobo.915.2">This is important for updating our apps without harming </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">existing features.</span></span></p>
<p><span class="koboSpan" id="kobo.917.1">These ideas </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.918.1">have been applied to the online bookstore, showing how the theory works out in practice in real life. </span><span class="koboSpan" id="kobo.918.2">It keeps our application accurate as well as reliable </span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">while growing.</span></span></p>
<p><span class="koboSpan" id="kobo.920.1">This section was so informative and has given us essential skills and knowledge. </span><span class="koboSpan" id="kobo.920.2">These are critical to any developer in Spring Boot app development. </span><span class="koboSpan" id="kobo.920.3">Moving on, these lessons on data management will prove to be a strong foundation. </span><span class="koboSpan" id="kobo.920.4">They will guide you in developing applications that are not only functional but also have </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">sturdy data.</span></span></p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.922.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.923.1">As we reach the end of this chapter, let’s recap the key learnings and insights we’ve gathered. </span><span class="koboSpan" id="kobo.923.2">This chapter has been a very deep dive into the world of data management with Spring Boot 3.0, covering a broad spectrum of topics that are crucial for any developer touching any aspect of this powerful framework. </span><span class="koboSpan" id="kobo.923.3">You should now have a grasp of the data management features in Spring Boot, as they are fundamental to building robust, efficient, and scalable applications. </span><span class="koboSpan" id="kobo.923.4">The skills acquired after the completion of this chapter are not only elemental to backend development but also quite useful when working with the intricacies and vagaries posed by modern application </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">development opportunities.</span></span></p>
<p><span class="koboSpan" id="kobo.925.1">Here’s what we </span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">have covered:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.927.1">Introduction to Spring Data</span></strong><span class="koboSpan" id="kobo.928.1">: We began with the basics of Spring Data, understanding how this technology for data access simplifies data access in </span><span class="No-Break"><span class="koboSpan" id="kobo.929.1">Spring applications.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.930.1">SQL databases with Spring Data</span></strong><span class="koboSpan" id="kobo.931.1">: We also touched on database integration, including PostgreSQL, as well as setting both data sources that are simple and that include more than one data source, and how to handle complex </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">relationships entities.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.933.1">NoSQL databases in Spring Boot</span></strong><span class="koboSpan" id="kobo.934.1">: The chapter guided us through the integration of NoSQL databases, specifically MongoDB, pointing out the flexibility and scaling up options </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">they present.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.936.1">Data migration and consistency</span></strong><span class="koboSpan" id="kobo.937.1">: We delved into strategies for data migration, touching on tools such as Liquibase, which comes in handy to ensure the integrity of data is not lost </span><span class="No-Break"><span class="koboSpan" id="kobo.938.1">during transitions.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.939.1">Cache abstraction in Spring Boot</span></strong><span class="koboSpan" id="kobo.940.1">: This topic really exposed us to cache abstraction and raised the point of its importance when seeking to improve the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.941.1">an application.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.942.1">Batch processing in Spring Boot</span></strong><span class="koboSpan" id="kobo.943.1">: We looked at the batch processing concept, which is important when it comes to effectively handling </span><span class="No-Break"><span class="koboSpan" id="kobo.944.1">large datasets.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.945.1">Practical application</span></strong><span class="koboSpan" id="kobo.946.1">: We practically applied those concepts throughout the chapter on a real project, the online bookstore management system, which exhibited the concrete implementation of the described data management strategies in </span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">Spring Boot.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.948.1">As we conclude this chapter, remember that the learning path and mastery of Spring Boot is an ongoing journey. </span><span class="koboSpan" id="kobo.948.2">Technology changes are quite frequent and keeping up to date with these changes will go a long way in making one effective at developing applications. </span><span class="koboSpan" id="kobo.948.3">Keep exploring, keep coding, and let the knowledge from this chapter be a stepping stone to build more complex and efficient Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">Boot applications.</span></span></p>
<p><span class="koboSpan" id="kobo.950.1">In </span><a href="B18400_05.xhtml#_idTextAnchor179"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.951.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.952.1">, we will learn about Advanced Testing Strategies. </span><span class="koboSpan" id="kobo.952.2">This knowledge will help us gain confidence in conducting application testing efficiently. </span><span class="koboSpan" id="kobo.952.3">We will learn about discovering differences between unit and integration tests, testing application reactive components, and securing application features. </span><span class="koboSpan" id="kobo.952.4">Other than that, implementation will demonstrate broad-based comprehension of </span><strong class="bold"><span class="koboSpan" id="kobo.953.1">Test-Driven Development</span></strong><span class="koboSpan" id="kobo.954.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.955.1">TDD</span></strong><span class="koboSpan" id="kobo.956.1">) with the Spring </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">Boot ecosystem.</span></span></p>
</div>
</body></html>