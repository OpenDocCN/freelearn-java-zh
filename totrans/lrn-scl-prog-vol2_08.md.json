["```java\nobject ForExpressions extends App { \n\n  val person1 = Person(\"Albert\", 21, 'm') \n  val person2 = Person(\"Bob\", 25, 'm') \n  val person3 = Person(\"Cyril\", 19, 'f') \n  val persons = List(person1, person2, person3) \n\n  val winners = for { \n    person <- persons \n    age = person.age \n    name = person.name \n    if age > 20 \n  } yield name \n\n  winners.foreach(println) \n\n} \n\ncase class Person(name: String, age: Int, gender: Char) \n```", "```java\nAlbert \nBob \n```", "```java\nval winners1 = persons withFilter(_.age > 20) map(_.name)\nwinners1.foreach(println)\n\ncase class Person(name: String, age: Int, gender: Char) \n```", "```java\nAlbert \nBob \n```", "```java\ncase class Car(name: String, brandName: String) \ncase class Brand(name: String, cars: List[Car]) \n\nval brands = List( \nBrand(\"Toyota\", List(Car(\"Corolla\", \"Toyota\"))), \nBrand(\"Honda\",  List(Car(\"Accord\", \"Honda\"))), \nBrand(\"Tesla\",  List(Car(\"Model S\", \"Tesla\"), \n                                      Car(\"Model 3\", \"Tesla\"), \n                                      Car(\"Model X\", \"Tesla\"), \n                                      Car(\"New Model\", \"Tesla\")))) \n```", "```java\nval teslaCarsStartsWithModel = for { \n  brand <- brands \n  car <- brand.cars \n  if car.name.startsWith(\"Model\") && brand.name == \"Tesla\" \n} yield (brand.name, car.name) \n\nteslaCarsStartsWithModel foreach println \n```", "```java\n(Tesla,Model S) \n(Tesla,Model 3) \n(Tesla,Model X) \n```", "```java\nval teslaCarsStartsWithModel2 = brands.flatMap(brand =>  \n  brand.cars withFilter(_.name.startsWith(\"Model\") && brand.name == \"Tesla\") map(car => (brand.name, car.name))) \n\nteslaCarsStartsWithModel2 foreach println \n```", "```java\n(Tesla,Model S) \n(Tesla,Model 3) \n(Tesla,Model X) \n```", "```java\nFor(gen1 <- list, gen2 <- gen1.list, filter1) \n```", "```java\nfor { \n  brand <- brands \n  car <- brand.cars \n  if car.name.startsWith(\"Model\") && brand.name == \"Tesla\" \n} yield (brand.name, car.name) \n```", "```java\nbrands.flatMap{ brand => \n     for{ \n       car <- brand.cars \n        if car.name.startsWith(\"Model\") && brand.name == \"Tesla\" \n     } yield (brand.name, car.name) \n} \n```", "```java\nbrands.flatMap{ brand => \n      brand.cars withFilter{ car =>  \n         car.name.startsWith(\"Model\") && brand.name == \"Tesla\" \n      } map(car => (brand.name, car.name))  \n} \n```", "```java\nval somelist = List(1,2,3) \n\nsomelist match { \n  case Nil => Nil \n  case _ => ??? \n} \n```", "```java\nval somelist = 1 :: 2 :: 3 :: Nil \n\nval x = somelist match { \n  case Nil => Nil \n  case _ => println(\"anything\") \n  case head :: tail => println(\"something with a head and a tail\") \n} \nWarning:(21, 10) patterns after a variable pattern cannot match (SLS 8.1.1) \n    case _ => println(\"anything\") \nWarning:(22, 33) unreachable code due to variable pattern on line 21 \n    case head :: tail => println(\"something with a head and a tail\") \nWarning:(22, 33) unreachable code \n    case head :: tail => println(\"something with a head and a tail\") \n```", "```java\nimport scala.util.control.NonFatal\n\ndef safeToInt(canBeNumber: String): Option[Int] = { \n  try { \n    Some(canBeNumber.toInt) \n  } catch { \n    case NonFatal(e) => None \n  } \n} \n\nsafeToInt(\"10\") match { \n  case None => println(\"Got nothing\") \n  case someValue =>  println(s\"Got ${someValue.get}\") \n} \n```", "```java\nGot 10 \n```", "```java\ndef matchAgainst(i: Int) = i match { \n  case 1 => println(\"One\") \n  case 2 => println(\"Two\") \n  case 3 => println(\"Three\") \n  case 4 => println(\"Four\") \n  case _ => println(\"Not in Range 1 to 4\") \n} \n\nmatchAgainst(1)\n matchAgainst(5)\n```", "```java\nOne \nNot in Range 1 to 4 \n```", "```java\ndef safeToInt(canBeNumber: String): Option[Int] = { \n  try { \n    Some(canBeNumber.toInt) \n  } catch { \n    case NonFatal(e) => None \n  } \n} \n\nsafeToInt(\"10\") match { \n  case None => println(\"Got nothing\") \n  case Some(value) =>  println(s\"Got $value\") \n} \n```", "```java\nGot 10 \n```", "```java\ncase Some(value) => println(s\"Got $value\") \n```", "```java\n trait Employee \n case class ContractEmp(id: String, name: String) extends Employee \n case class Developer(id: String, name: String) extends Employee \n case class Consultant(id: String, name: String) extends Employee \n\n/* \n * Process joining bonus if \n *     :> Developer has ID Starting from \"DL\"  JB: 1L \n *     :> Consultant has  ID Starting from \"CNL\":  1L \n */ \n def processJoiningBonus(employee: Employee, amountCTC: Double) = employee match { \n   case ContractEmp(id, _) => amountCTC \n   case Developer(id, _) => if(id.startsWith(\"DL\")) amountCTC + 10000.0 else amountCTC \n   case Consultant(id, _) => if(id.startsWith(\"CNL\")) amountCTC + 10000.0 else amountCTC \n } \n\n val developerEmplEligibleForJB = Developer(\"DL0001\", \"Alex\") \n val consultantEmpEligibleForJB = Consultant(\"CNL0001\",\"Henry\") \n val developer = Developer(\"DI0002\", \"Heith\") \n\n println(processJoiningBonus(developerEmplEligibleForJB, 55000)) \n println(processJoiningBonus(consultantEmpEligibleForJB, 65000)) \n println(processJoiningBonus(developer, 66000)) \n```", "```java\n65000.0 \n75000.0 \n66000.0 \n```", "```java\ncase Developer(id, _) => if(id.startsWith(\"DL\")) amountCTC + 10000.0 else amountCTC \n```", "```java\n/* \n * Process joining bonus if \n *     :> Developer has ID Starting from \"DL\"  JB: 1L \n *     :> Consultant has  ID Starting from \"CNL\":  1L \n */ \n def processJoiningBonus(employee: Employee, amountCTC: Double) = employee match { \n   case ContractEmp(id, _) => amountCTC \n   case Developer(id, _) if id.startsWith(\"DL\") => amountCTC + 10000.0 \n   case Consultant(id, _) if id.startsWith(\"CNL\") =>  amountCTC + 10000.0 \n   case _ => amountCTC \n } \n```", "```java\n65000.0 \n75000.0 \n66000.0 \n```", "```java\ncase Developer(id, _) if id.startsWith(\"DL\") => amountCTC + 10000.0 \n```", "```java\ncase class Car(name: String, brand: CarBrand) \ncase class CarBrand(name: String) \n\nval car = Car(\"Model X\", CarBrand(\"Tesla\")) \nval anyCar = Car(\"Model XYZ\", CarBrand(\"XYZ\")) \n\ndef matchCar(c: Car) = c match { \n  case Car(_, brand @ CarBrand(\"Tesla\")) => println(\"It's a Tesla Car!\") \n  case _ => println(\"It's just a Carrr!!\") \n} \n\nmatchCar(car) \nmatchCar(anyCar) \n```", "```java\nIt's a Tesla Car! \nIt's just a Carrr!! \n```", "```java\ndef safeToInt(canBeNumber: String): Option[Int] = { \n  try { \n    Some(canBeNumber.toInt) \n  } catch { \n    case NonFatal(e) => None \n  } \n} \n\nsafeToInt(\"10\") match { \n  case None => println(\"Got nothing\") \n  case Some(value) =>  println(s\"Got $value\") \n} \n```", "```java\nscala> val a: Option = Some(1) \n<console>:11: error: class Option takes type parameters \n       val a: Option = Some(1) \n\nscala> val a: Option[Int] = Some(1) \na: Option[Int] = Some(1) \n```", "```java\nscala> a map println \n1 \n```", "```java\ndef safeToInt(canBeNumber: String): Int = { \n  try { \n     canBeNumber.toInt \n  } catch { \n    case NonFatal(e) => throw Exception \n  } \n} \n```", "```java\nscala> lazy val v = 1 \nv: Int = <lazy> \n\nscala> val z = 1 \nz: Int = 1 \n```", "```java\nimport scala.annotation.tailrec\n\nobject TailRecursion { \n  def main(args: Array[String]): Unit = { \n      val list = List(\"Alex\", \"Bob\", \"Chris\", \"David\", \"Raven\", \"Stuart\") \n    someRecursiveMethod(list) \n\n  } \n\n  /* \n      You have a sorted list of names of employees, within a company. \n      print all names until the name \"Raven\" comes \n  */ \n  @tailrec \n  def someRecursiveMethod(list: List[String]): Unit = { \n      list match { \n        case Nil => println(\"Can't continue. Either printed all names or encountered Raven\") \n        case head :: tail => if(head != \"Raven\") { \n          println(s\"Name: $head\") \n          someRecursiveMethod(tail) \n        } else someRecursiveMethod(Nil) \n      }\n   }\n }\n```", "```java\nName: Alex \nName: Bob \nName: Chris \nName: David \nCan't continue. Either printed all names or encountered Raven \n```", "```java\n@tailrec \ndef someRecursiveMethod(list: List[String]): Unit = { \n    list match { \n      case Nil => println(s\"Can't continue. Either printed all names or encountered Raven\") \n      case head :: tail => if(head != \"Raven\") { \n        println(s\"Name: $head\") \n        someRecursiveMethod(tail) \n        println(\"Won't happen\") \n      } else someRecursiveMethod(Nil) \n\n    } \n} \nError:(21, 30) could not optimize @tailrec annotated method someRecursiveMethod: it contains a recursive call not in tail position \nsomeRecursiveMethod(tail) \n```", "```java\nval brands = List(Brand(\"Toyota\", List(Car(\"Corolla\", \"Toyota\"))), \n                  Brand(\"Honda\", List(Car(\"Accord\", \"Honda\"))), \n                  Brand(\"Tesla\", List(Car(\"Model S\", \"Tesla\"), \n                                      Car(\"Model 3\", \"Tesla\"), \n                                      Car(\"Model X\", \"Tesla\"), \n                                      Car(\"New Model\", \"Tesla\")))) \n\nbrands.foreach((b: Brand) => { \n  //Take the brand name, and check the number of Cars and print them.\nval brandName = b.name \n  println(s\"Brand: $brandName || Total Cars:${b.cars.length}\") \n  (brandName, b.cars) \n}) \n```", "```java\n((x) => x * y) \n```", "```java\ncreditCards.filter(_.limit < 55000)\n               .map(cc => cc.accounts(cc.holder))            .filter(_.isLinkedAccount) \n  .get \n  .info \n```", "```java\nobject TypeParameterization { \n\n  def main(args: Array[String]): Unit = { \n      val mayBeAnInteger = Some(\"101\") \n      val mayBeADouble = Some(\"101.0\") \n      val mayBeTrue = Some(\"true\") \n\n    println(s\"Calling mapToInt: ${mapToInt(mayBeAnInteger, (x: String) => x.toInt)}\") \n    println(s\"Calling mapToDouble: ${mapToDouble(mayBeADouble, (x: String) => x.toDouble)}\") \n    println(s\"Calling mapToBoolean: ${mapToBoolean(mayBeTrue, (x: String) => x.toBoolean)}\") \n  } \n  def mapToInt(mayBeInt: Option[String], function: String => Int) = function(mayBeInt.get) \n\n  def mapToDouble(mayBeDouble: Option[String], function: String => Double) = function(mayBeDouble.get) \n\n  def mapToBoolean(mayBeBoolean: Option[String], function: String => Boolean) = function(mayBeBoolean.get) \n} \n```", "```java\nCalling mapToInt: 101 \nCalling mapToDouble: 101.0 \nCalling mapToBoolean: true \n```", "```java\nobject TypeParameterization { \n\n  def main(args: Array[String]): Unit = { \n      val mayBeAnInteger = Some(\"101\") \n      val mayBeADouble = Some(\"101.0\") \n      val mayBeTrue = Some(\"true\") \n\n    println(s\"Calling mapToValue: ${mapToValue(mayBeAnInteger, x => x.toInt)}\") \n    println(s\"Calling mapToValue: ${mapToValue(mayBeADouble, x => x.toDouble)}\") \n    println(s\"Calling mapToValue: ${mapToValue(mayBeTrue, x => x.toBoolean)}\") \n  } \n\n  def mapToValue[T](mayBeValue: Option[String], function: String => T) = function(mayBeValue.get) \n} \n```", "```java\nCalling mapToValue: 101 \nCalling mapToValue: 101.0 \nCalling mapToValue: true \n```", "```java\ndef mapToValue[T](mayBeValue: Option[String], function: String => T) : T = function(mayBeValue.get) \n```", "```java\ndef mapToValue[A, B](mayBeValue: Option[A], function: A => B) : B = function(mayBeValue.get) \n```", "```java\ndef map[B](f: A => B): Option[B] = if (isEmpty) \n     None \n else \n     Some(f(this.get)) \n```"]