- en: Chapter 6. Concurrent Programming with Reactive Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Your mouse is a database."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Erik Meijer* |'
  prefs: []
  type: TYPE_TB
- en: The futures and promises from [Chapter 4](ch04.html "Chapter 4.  Asynchronous
    Programming with Futures and Promises"), *Asynchronous Programming with Futures
    and Promises*, push concurrent programming to a new level. First, they avoid blocking
    when transferring the result of the computation from the producer to the consumer.
    Second, they allow you to idiomatically compose simple future objects into more
    complex ones, resulting in programs that are more concise. Futures encapsulate
    patterns of asynchronous communication in a way that is clear and easily understandable.
  prefs: []
  type: TYPE_NORMAL
- en: One disadvantage of futures is that they can only deal with a single result.
    For HTTP requests or asynchronous computations that compute a single value, futures
    can be adequate, but sometimes we need to react to many different events coming
    from the same computation. For example, it is cumbersome to track the progress
    status of a file download with futures. Event streams are a much better tool for
    this use case; unlike futures, they can produce any number of values, which we
    call events. First-class event streams, which we will learn about in this chapter,
    can be used inside expressions as if they were regular values. Just as with futures,
    first-class event streams can be composed and transformed using functional combinators.
  prefs: []
  type: TYPE_NORMAL
- en: In computer science, **event-driven programming** is a programming style in
    which the flow of the program is determined by events such as external inputs,
    user actions, or messages coming from other computations. Here, a user action
    might be a mouse click, and an external input can be a network interface. Both
    futures and event streams can be classified as event-driven programming abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reactive programming**, which deals with the propagation of change and the
    flow of data in the program, is a closely related discipline. Traditionally, reactive
    programming is defined as a programming style that allows you to express various
    constraints between the data values in the program. For example, when we say `a
    = b + 1` in an imperative programming model, it means that `a` is assigned the
    current value of `b` increased by `1`. If the value `b` later changes, the value
    of `a` does not change. By contrast, in reactive programming, whenever the value
    `b` changes, the value `a` is updated using the constraint `a = b + 1`. With the
    rising demand for concurrency, the need for event-driven and reactive programming
    grows even larger. Traditional callback-based and imperative APIs have shown to
    be inadequate for this task: they obscure the program flow, mix concurrency concerns
    with program logic, and rely on mutable state. In larger applications, swarms
    of unstructured callback declarations lead to an effect known as the callback
    hell, in which the programmer can no longer make sense of the control flow of
    the program. In a way, callbacks are the `GOTO` statement of reactive programming.
    **Event stream composition** captures patterns of callback declarations, allowing
    the programmer to express them more easily. It is a much more structured approach
    for building event-based systems.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reactive Extensions** (**Rx**) is a programming framework for composing asynchronous
    and event-driven programs using event streams. In Rx, an event stream that produces
    events of type `T` is represented with the type `Observable[T]`. As we will learn
    in this chapter, the Rx framework incorporates principles present both in reactive
    and in event-driven programming. The fundamental concept around Rx is that events
    and data can be manipulated in a similar way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will study the semantics of `RxObservable` objects, and
    learn how to use them to build event-driven and reactive applications. Concretely,
    we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and subscribing to the `Observable` objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The observable contract and how to implement custom `Observable` objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the subscriptions to cancel event sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing observable objects using Rx combinators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling concurrency with Rx scheduler instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Rx subjects for designing larger applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start with simple examples that show you how to create and manipulate
    the `Observable` objects, and illustrate how they propagate events.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Observable objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will study various ways of creating `Observable` objects.
    We will learn how to subscribe to different kinds of event produced by `Observable`
    instances and learn how to correctly create custom `Observable` objects. Finally,
    we will discuss the difference between cold and hot observables.
  prefs: []
  type: TYPE_NORMAL
- en: An `Observable` object is an object that has a method called `subscribe`, which
    takes an object called an observer as a parameter. The observer is a user-specified
    object with custom event-handling logic. When we call the `subscribe` method with
    a specific observer, we can say that the observer becomes subscribed to the respective
    `Observable` object. Every time the `Observable` object produces an event, its
    subscribed observers get notified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Rx implementation for Scala is not a part of the Scala standard library.
    To use Rx in Scala, we need to add the following dependency to our `build.sbt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can import the contents of the `rx.lang.scala` package to start using
    Rx. Let''s say that we want to create a simple `Observable` object that first
    emits several `String` events and then completes the execution. We use the `items`
    factory method on the `Observable` companion object to create an `Observable`
    object `o`. We then call the `subscribe` method, which is similar to the `foreach`
    method on futures introduced in [Chapter 4](ch04.html "Chapter 4.  Asynchronous
    Programming with Futures and Promises"), *Asynchronous Programming with Futures
    and Promises*. The `subscribe` method takes a callback function and instructs
    the `Observable` object `o` to invoke the callback function for each event that
    is emitted. It does so by creating an `Observer` object behind the scenes. The
    difference is that, unlike futures, the `Observable` objects can emit multiple
    events. In our example, the callback functions print the events to the screen
    by calling the `log` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon running this example, we notice two things. First, all the `log` statements
    are executed on the main program thread. Second, the callback associated with
    the first `subscribe` call is invoked for all three programming languages before
    the callback associated with the second `subscribe` call is called for these three
    languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can conclude that the `subscribe` call executes synchronously--it invokes
    callback for all the events emitted by the event stream `o` before returning.
    However, this is not always the case. The `subscribe` call can also return the
    control to the main thread immediately, and invoke the callback functions asynchronously.
    This behavior depends on the implementation of the `Observable` object. In this
    Rx implementation, the `Observable` objects created using the `items` method have
    their events available when the `Observable` object is created, so their `subscribe`
    method is synchronous.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, the `Observable` object feels almost like an immutable
    Scala collection, and the `subscribe` method acts as if it is a `foreach` method
    on a collection. However, the `Observable` objects are more general. We will see
    an `Observable` object that emits events asynchronously next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we want the `Observable` object that emits an event after
    a certain period of time has elapsed. We use the `timer` factory method to create
    such an `Observable` object and set the timeout to 1 second. We then call the
    `subscribe` method with two different callbacks, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the `subscribe` method calls are asynchronous; it makes no sense
    to block the main thread for an entire second and wait until the timeout event
    appears. Running the example shows that the main thread continues before the callback
    functions are invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, the `log` statements reveal that the callback functions are invoked
    on the thread pool internally used by Rx, in an unspecified order.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Observable` objects can emit events either synchronously or asynchronously,
    depending on the implementation of the specific `Observable` object.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see, in most use cases, events are not available when calling the
    `subscribe` method. This is the case with UI events, file modification events,
    or HTTP responses. To avoid blocking the thread that calls the `subscribe` method,
    the `Observable` objects emit such events asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Observables and exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4.  Asynchronous Programming with Futures
    and Promises"), *Asynchronous Programming with Futures and Promises*, we saw that
    asynchronous computations sometimes throw exceptions. When that happens, the `Future`
    object associated with the exception fails; instead of being completed with the
    result of the computation, the `Future` object is completed with the exception
    that failed the asynchronous computation. The clients of the `Future` objects
    can react to exceptions by registering callbacks with the `failed.foreach` or
    `onComplete` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Computations that produce events in `Observable` objects can also throw exceptions.
    To respond to exceptions produced by the `Observable` objects, we can use an overload
    of the `subscribe` method that takes two callback arguments to create an observer--the
    callback function for the events and the callback function for the exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program creates an `Observable` object that emits numbers `1`
    and `2`, and then produces a `RuntimeException`. The `items` factory method creates
    the `Observable` object with the numbers, and the `error` factory method creates
    another `Observable` object with an exception. We then concatenate the two together
    with the `++` operator on `Observable` instances. The first callback logs the
    numbers to the standard output and ignores the exception. Conversely, the second
    callback logs the `Throwable` objects and ignores the numbers. This is shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The program first prints numbers `1` and `2`, and then prints the exception
    object. Without the second callback function being passed to the `subscribe` method,
    the exception will be emitted by the `Observable` object `o`, but never passed
    to the observer. Importantly, after an exception is emitted, the `Observable`
    object is not allowed to emit any additional events. We can redefine the `Observable`
    object `o` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We might expect the program to print events `3` and `4`, but they are not emitted
    by the `Observable` object `o`. When an `Observable` object produces an exception,
    we say that it is in the error state.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When an `Observable` object produces an exception, it enters the error state
    and cannot emit more events.
  prefs: []
  type: TYPE_NORMAL
- en: Irrespective of whether the `Observable` object is created using a factory method,
    or is a custom `Observable` implementation described in the subsequent sections,
    an `Observable` object is not allowed to emit events after it produces an exception.
    In the next section, we will examine this contract in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The Observable contract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have seen how to create simple `Observable` objects and react to
    their events, it is time to take a closer look at the lifetime of an `Observable`
    object. Every `Observable` object can be in three states: uncompleted, error,
    or completed. As long as the `Observable[T]` object is uncompleted, it can emit
    events of type `T`. As we already learned, an `Observable` object can produce
    an exception to indicate that it failed to produce additional data. When this
    happens, the `Observable` object enters the error state and cannot emit any additional
    events. Similarly, when an `Observable` object decides that it will not produce
    any additional data, it might enter the completed state. After an `Observable`
    object is completed, it is not allowed to emit any additional events.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Rx, an object that subscribes to events from an `Observable` object is called
    an `Observer` object. The `Observer[T]` trait comes with three methods: `onNext`,
    `onError`, and `onCompleted`, which get invoked when an `Observable` object emits
    an event, produces an error, or is completed, respectively. This trait is shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous examples, whenever we called the `subscribe` method, Rx created
    an `Observer` object and assigned it to the `Observable` instance. Alternatively,
    we can provide an `Observer` object directly to an overloaded version of the `subscribe`
    method. The following program uses the `from` factory method which converts a
    list of movie titles into an `Observable` object. It then creates an `Observer`
    object and passes it to the `subscribe` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This program first prints our favorite movies, and terminates after calling
    `onCompleted` and printing `"No more movies"`. The `Observable` object `movies`
    is created from a finite collection of strings; after these events are emitted,
    the `movies` event stream calls the `onCompleted` method. In general, the `Observable`
    objects can only call the `onCompleted` method after it is certain that there
    will be no more events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every `Observable` object can call the `onNext` method on its `Observer` objects
    zero or more times. An `Observable` object might then enter the completed or error
    state by calling the `onCompleted` or `onError` method on its `Observer` objects.
    This is known as the `Observable` contract, and is shown graphically in the following
    state diagram, where different nodes denote `Observable` states, and links denote
    calls to different `Observer` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Observable contract](img/image_06_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that an `Observable` object can call the `onCompleted` or `onError` method
    if it knows that it will not emit additional events, but it is free to call neither.
    Some Observable objects, such as `items`, know when they emit the last event.
    On the other hand, an `Observable` instance that emits mouse or keyboard events
    never calls the `onCompleted` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An `Observable` object can call the `onNext` method on the subscribed `Observer`
    objects an unlimited number of times. After optionally calling the `onCompleted`
    or `onError` method, an `Observable` object is not allowed to call any `Observer`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `Observable` objects produced by the Rx API implement the `Observable` contract.
    In practice, we do not need to worry about the `Observable` contract, unless we
    are implementing our own custom `Observable` object. This is the topic of the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing custom Observable objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a custom `Observable` object, we can use the `Observable.create`
    factory method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method takes a function `f` from an `Observer` to a `Subscription`
    object and returns a new `Observable` object. Whenever the `subscribe` method
    gets called, the function `f` is called on the corresponding `Observer` object.
    The function `f` returns a `Subscription` object, which can be used to unsubscribe
    the `Observer` object from the `Observable` instance. The `Subscription` trait
    defines a single method called `unsubscribe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We will talk about the `Subscription` objects in more detail in a subsequent
    section. For now, we only use the empty `Subscription` object, which does not
    unsubscribe the `Observer` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how to use the `Observable.create` method, we implement an `Observable`
    object `vms`, which emits names of popular virtual machine implementations. In
    `Observable.create`, we take care to first call `onNext` with all the VM names,
    and then call `onCompleted` once. Finally, we return the empty `Subscription`
    object. This is shown in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `Observable` object `vms` has a synchronous `subscribe` method. All the
    events are emitted to an `obs` observer before returning the control to the thread
    that called the `subscribe` method. In general, we can use the `Observable.create`
    method in order to create an `Observable` instance that emits events asynchronously.
    We will study how to convert a `Future` object into an `Observable` object next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Observables from futures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Futures are objects that represent the result of an asynchronous computation.
    One can consider an `Observable` object as a generalization of a `Future` object.
    Instead of emitting a single success or failure event, an `Observable` object
    emits a sequence of events, before failing or completing successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scala APIs that deal with asynchronous computations generally return the `Future`
    objects, and not `Observable` instances. In some cases, it is useful to be able
    to convert a `Future` object into an `Observable` object. Here, after a `Future`
    object is completed successfully, the corresponding `Observable` object must emit
    an event with the future value, and then call the `onCompleted` method. If the
    `Future` object fails, the corresponding `Observable` object should call the `onError`
    method. Before we begin, we need to import the contents of the `scala.concurrent`
    package and the global `ExecutionContext` object, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use the `Observable.create` method to create an `Observable` object
    `o`. Instead of calling the `onNext`, `onError`, and `onCompleted` methods directly
    on the `Observer` object, we will install callbacks on the `Future` object `f`,
    as shown in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the `subscribe` method is asynchronous. It returns immediately after
    installing the callback on the `Future` object. In fact, this pattern is so common
    that Rx comes with the `Observable.from` factory method that converts a `Future`
    object into an `Observable` object directly, as shown by the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Still, learning how to convert a `Future` object into an `Observable` object
    is handy. The `Observable.create` method is the preferred way to convert callback-based
    APIs to `Observable` objects, as we will see in subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the `Observable.create` factory method to create the `Observable` objects
    from callback-based APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In the examples so far, we have always returned an empty `Subscription` object.
    Calling the `unsubscribe` method on such a `Subscription` object has no effect.
    Sometimes, the `Subscription` objects need to release resources associated with
    the corresponding `Observable` instance. We will study how to implement and work
    with such `Subscription` objects next.
  prefs: []
  type: TYPE_NORMAL
- en: Subscriptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall the example monitoring the filesystem for changes in [Chapter 4](ch04.html
    "Chapter 4.  Asynchronous Programming with Futures and Promises"), *Asynchronous
    Programming with Futures and Promises*, where we used the file monitoring package
    from the Apache Commons IO library to complete a `Future` object when a new file
    is created. A `Future` object can be completed only once, so the future was completed
    with the name of the first file that was created. It is more natural to use `Observable`
    objects for this use case, as files in a filesystem can be created and deleted
    many times. In an application such as a file browser or an FTP server, we would
    like to receive all such events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later in the program, we might want to unsubscribe from the events in the `Observable`
    object. We will now see how to use the `Subscription` object to achieve this.
    We first import the contents of the **Apache Commons IO file monitoring** package,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We define the `modified` method, which returns an `Observable` object with filenames
    of the modified files in the specified directory. The `Observable.create` method
    bridges the gap between the Commons IO callback-based API and Rx. When the `subscribe`
    method is called, we create a `FileAlterationMonitor` object, which uses a separate
    thread to scan the filesystem and emit filesystem events every 1000 milliseconds,
    a `FileAlterationObserver` object, which specifies a directory to monitor; and
    a `FileAlterationListener` object, which reacts to file events by calling the
    `onNext` method on the Rx `Observer` object. We then call the `start` method on
    the `fileMonitor` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we return a custom `Subscription` object, which calls `stop` on the
    `fileMonitor` object. The `modified` method is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We used the `apply` factory method on the `Subscription` companion object in
    the preceding code snippet. When the `unsubscribe` method is called on the resulting
    `Subscription` object, the specified block of code is run. Importantly, calling
    the `unsubscribe` method, the second time will not run the specified block of
    code again. We say that the `unsubscribe` method is **idempotent**; calling it
    multiple times has the same effect as calling it only once. In our example, the
    `unsubscribe` method calls the `stop` method of the `fileMonitor` object at most
    once. When sub-classing the `Subscription` trait, we need to ensure that the `unsubscribe`
    method is idempotent, and the `Subscription.apply` method is a convenience method
    that ensures idempotence automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Implementations of the `unsubscribe` method in the `Subscription` trait need
    to be idempotent. Use the `Subscription.apply` method to create the `Subscription`
    objects that are idempotent by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `modified` method to track file changes in our project. After we
    call the `subscribe` method on the `Observable` object returned by the `modified`
    method, the main thread suspends for 10 seconds. If we save files in our editor
    during this time, the program will log file modification events to the standard
    output. This is shown in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, in this example, the `FileAlterationMonitor` object is only created
    if the program invokes the `subscribe` method. The `Observable` instance returned
    by the `modified` method does not emit events unless there exists an `Observer`
    object subscribed to it. In Rx, the `Observable` objects that emit events only
    when subscriptions exist are called **cold observables**. On the other hand, some
    `Observable` objects emit events even when there are no associated subscriptions.
    This is usually the case with `Observable` instances that handle user input, such
    as keyboard or mouse events. `Observable` objects that emit events regardless
    of their subscriptions are called **hot observables**. We now reimplement an `Observable`
    object that tracks file modifications as a hot observable. We first instantiate
    and start the `FileAlterationMonitor` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Observable` object uses the `fileMonitor` object to specify the directory
    in order to monitor. The downside is that our `Observable` object now consumes
    computational resources even when there are no subscriptions. The advantage of
    using a hot observable is that multiple subscriptions do not need to instantiate
    multiple `FileAlterationMonitor` objects, which are relatively heavyweight. We
    implement the hot `Observable` object in the `hotModified` method, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `hotModified` method creates an `Observable` object with file changes for
    a given directory by registering the specified directory with the `fileMonitor`
    object, and only then calls the `Observable.create` method. When the `subscribe`
    method is called on the resulting `Observable` object, we instantiate and add
    a new `FileAlterationListener` object. In the `Subscription` object, we remove
    the `FileAlterationListener` object in order to avoid receiving additional file
    modification events, but we do not call the `stop` method on the `fileMonitor`
    object until the program terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Composing Observable objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having seen different ways of creating various types of the `Observable` objects,
    subscribing to their events, and using the `Subscription` objects, we turn our
    attention to composing the `Observable` objects into larger programs. From what
    we have seen so far, the advantages of using the `Observable` objects over a callback-based
    API are hardly worth the trouble.
  prefs: []
  type: TYPE_NORMAL
- en: The true power of Rx becomes apparent when we start composing the `Observable`
    objects using various combinators. We can think of an `Observable` object in a
    similar way as we think of Scala sequence collections. In a Scala sequence, represented
    by the `Seq[T]` trait, elements of type `T` are ordered in the memory according
    to their indices. In an `Observable[T]` trait, events of type `T` are ordered
    in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the `Observable.interval` factory method in order to create an `Observable`
    object, which asynchronously emits a number every 0.5 seconds, and then output
    the first five odd numbers. To do this, we first call `filter` on the `Observable`
    object in order to obtain an intermediate `Observable` object that emits only
    odd numbers. Note that calling the `filter` on an `Observable` object is similar
    to calling `filter` method on a Scala collection. Similarly, we obtain another
    `Observable` object by calling the `map` method in order to transform each odd
    number into a string. We then call `take` to create an `Observable` object `odds`,
    which  contains only the first five events. Finally, we subscribe to `odds` so
    that we can print the events it emits. This is shown in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To concisely explain the semantics of different Rx combinators, we often rely
    on marble diagrams. These diagrams graphically represent events in an `Observable`
    object and transformations between different `Observable` objects. The marble
    diagram represents every `Observable` object with a timeline containing its events.
    The first three intermediate `Observable` objects never call the `onCompleted`
    method on its observers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Observable` object `odds` contains at most five events, so it calls `onCompleted`
    after emitting them. We denote a call to the `onCompleted` method with a vertical
    bar in the marble diagram, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Composing Observable objects](img/image_06_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the preceding diagram is a high-level illustration of the relationships
    between different `Observable` objects, but some of these events can be omitted
    during execution. The particular Rx implementation can detect that the events
    `11` and `12` cannot be observed by the `subscribe` invocation, so these events
    are not emitted to save computational resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an expert on sequential programming in Scala, you probably noticed that
    we can rewrite the previous program more concisely using the for-comprehensions.
    For example, we can output the first five even natural numbers with the following
    for-comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Before moving on to more complex for-comprehensions, we will study a special
    kind of `Observable` object whose events are other `Observable` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Nested Observables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A nested observable, also called a higher-order event stream, is an `Observable`
    object that emits events that are themselves `Observable` objects. A higher-order
    function such as the `foreach` statement is called a higher-order function because
    it has a nested function inside its `(T => Unit) => Unit` type. Similarly, higher-order
    event streams earned this fancy name because they have a type `Observable[T]` as
    part of their type `Observable[Observable[T]]`. In this section, we will study
    when the `nestedObservable` objects are useful and how to manipulate them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that we are writing a book and we want to add a famous quote at
    the beginning of each chapter. Choosing the right quote for a chapter is a hard
    job and we want to automate it. We write a short program that uses `Observable`
    objects to fetch random quotes from the *I Heart Quotes* website every 0.5 seconds
    and prints them to the screen. Once we see a nice quote, we have to quickly copy
    it to our book chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by defining a `fetchQuote` method that returns a `Future` object
    with the text of the quote. Luckily, the HTTP API of the *I Heart Quotes* website
    returns plain text, so we do not need to parse any JSON or XML. We use the `scala.io.Source`
    object to fetch the contents of the proper URL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that we can convert a `Future` object to an `Observable` object using
    the `from` factory method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We now use the `Observable.interval` factory method in order to create an `Observable`
    object that emits a number every 0.5 seconds. For the purposes of our example,
    we take only the first four numbers. Then, we map each of these numbers into an
    `Observable` object that emits a quote, prefixed with the ordinal number of the
    quote. To do this, we call the `fetchQuoteObservable` method and map the quotes
    using a nested `map` call, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the inner `map` call transforms an `Observable[String]` instance,
    which contains the quote text, to another `Observable[String]` instance, which
    contains the quote prefixed with a number. The outer `map` call transforms the
    `Observable[Long]` object, which contains the first four numbers, to an `Observable[Observable[String]]`
    instance, which contains `Observable` objects emitting separate quotes. The `Observable`
    objects created by the `quotes` method are shown in the following marble diagram.
    Events in the nested `Observable` objects presented last are themselves `Observable`
    objects that contain a single event: the text of the quote returned in the `Future`
    object. Note that we omit the nested `map` call from the diagram to make it more
    readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nested Observables](img/image_06_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Drawing a marble diagram makes the contents of this `Observable` object more
    understandable, but how do we subscribe to events in an `Observable[Observable[String]]`
    object? Calling the `subscribe` method on quotes requires observers to handle
    the `Observable[String]` objects, and not the `String` events directly.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, an analogy with Scala sequence collections is useful in order to
    understand how to solve this issue. Whenever we have a nested sequence, say `Seq[Seq[T]]`,
    we can flatten it to a `Seq[T]` collection by calling the `flatten` method. When
    we do this, elements of the nested sequences are simply concatenated together.
    The Rx API provides similar methods that flatten the `Observable` objects, but
    they must deal with the additional complexity associated with the timing of events.
    There are different ways of flattening the `Observable` objects depending on the
    time when their events arrive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method, called `concat`, concatenates the `nestedObservable` objects
    by ordering all the events in one nested `Observable` object before the events
    in a subsequent `Observable` object. An `Observable` object that appears earlier
    must complete before the events from a subsequent `Observable` object can be emitted.
    The marble diagram for the `concat` operation is shown in the following figure. Although
    the quote **Veni, vidi, vici.**, arrives before the quote **Carpe diem**., the
    quote **Veni, vidi, vici.** is emitted only after the `Observable` object associated
    with the quote **Carpe diem.** completes. The resulting `Observable` object completes
    only after the `Observable` object `quotes` and all the nested `Observable` objects
    complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nested Observables](img/image_06_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The second method is called `flatten`, analogously to the similar method in
    the Scala collections API. This method emits events from the nested `Observable`
    objects in the order in which they arrive in time, regardless of when the respective
    nested `Observable` object started. An `Observable` object that appears earlier
    is not required to complete before events from a subsequent `Observable` object
    are emitted.
  prefs: []
  type: TYPE_NORMAL
- en: This is illustrated in the following marble diagram. A quote is emitted to the
    resulting `Observable` object as soon as it appears on any of the nested `Observable`
    objects. Once `quotes` and all the nested `Observable` objects complete, the resulting
    `Observable` object completes as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![Nested Observables](img/image_06_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To test the difference between the `concat` and `flatten` methods, we subscribe
    to events in `quotes` using each of these two methods. If our network is unreliable
    or has particularly nondeterministic latency, the order in which the second `subscribe`
    call prints the `quotes` object can be mangled. We can reduce the interval between
    queries from 0.5 to 0.01 seconds to witness this effect. The ordinal numbers preceding
    each quote become unordered when using the `flatten` method. This is illustrated
    in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How do we choose between the `concat` and `flatten` methods? The `concat` method
    has the advantage that it maintains the relative order between events coming from
    different `Observable` objects. If we had been fetching and printing quotes in
    a lexicographic order, then the `concat` method would be the correct way to flatten
    the nested `Observable` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use `concat` to flatten nested `Observable` objects whenever the order of events
    between different nested `Observable` objects needs to be maintained.
  prefs: []
  type: TYPE_NORMAL
- en: The `concat` method does not subscribe to subsequent `Observable` objects before
    the current `Observable` object completes. If one of the nested `Observable` objects
    takes a long time to complete or does not complete at all, the events from the
    remaining `Observable` objects are postponed or never emitted. The `flatten` method
    subscribes to a nested `Observable` object as soon as the nested `Observable`
    object is emitted, and emits events as soon as they arrive.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If at least one of the nested `Observable` objects has an unbounded number of
    events or never completes, use the `flatten` method instead of the `concat` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also traverse events from multiple `Observable` objects in a `for` comprehension.
    The `Observable` objects come with the `flatMap` method, and this allows you to
    use them in `for` comprehensions. Calling the `flatMap` method on an `Observable`
    object is equivalent to mapping each of its events into a nested `Observable`
    object, and then calling the `flatten` method. Thus, we can rewrite the `quotes.flatten`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Having already mastered `for` comprehensions on Scala collections and `for`
    comprehensions on futures, this pattern of `flatMap` and `map` calls immediately
    rings a bell, and we recognize the previous expression as the following `for`
    comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is much more concise and understandable, and almost feels like we're back
    with collections land. Still, we need to be careful, because for-comprehensions
    on `Observable` objects do not maintain the relative order of the events in the
    way that the for-comprehensions on collections do. In the preceding example, as
    soon as we can pair a `n` number with some quote `txt`, the `s"$n) $txt"` event
    is emitted, irrespective of the events associated with the preceding `n` number.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Calling the `flatMap` method or using `Observable` objects in `for` comprehensions
    emits events in the order in which they arrive, and it does not maintain ordering
    between events from different `Observable` objects. Invoking the `flatMap` method
    is semantically equivalent to calling `map` followed by the `flatten` call.
  prefs: []
  type: TYPE_NORMAL
- en: An attentive reader will notice that we did not consider the case where one
    of the nested `Observable` objects terminates by calling the `onError` method.
    When this happens, both `concat` and `flatten` call the `onError` method with
    the same exception. Similarly, `map` and `filter` fail the resulting `Observable`
    object if the input `Observable` object produces an exception, so it is unclear
    how to compose failed `Observable` objects. This is the focus of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Failure handling in Observables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you ran the previous examples yourself, you might have noticed that some
    of the quotes are long and tedious to read. We don't want to put a long quote
    at the beginning of the chapter. If we did that, our readers might lose interest.
    The best quotes are short and straight to the point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next goal will be to replace quotes longer than 100 characters with a string
    `Retrying...` and print the first quote shorter than 100 characters. This time,
    we define an `Observable` object called `randomQuote`, which emits a random quote
    every time we subscribe to it. We use the `Observable.create` method in order
    to obtain a random quote as before and emit the quote to the observer. We then
    return an empty `Subscription` object. This is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There is a subtle difference between the `Observable` object returned by the
    `randomQuote` method and the one returned by the `fetchQuoteObservable` method,
    defined earlier. The `fetchQuoteObservable` method creates a `Future` object in
    order to obtain a quote and emits the quote in that `Future` object to every observer.
    By contrast, the `randomQuote` method fetches a new quote every time the `subscribe`
    method is called. In the previously introduced terminology, the `randomQuote`
    method creates cold `Observable` objects, which emit events only when we subscribe
    to them, whereas the `fetchQuoteObservable` method creates hot `Observable` objects,
    which emit the same quote to all their observers.
  prefs: []
  type: TYPE_NORMAL
- en: To re-subscribe to a failed `Observable` object, we can use the `retry` combinator.
    The `retry` combinator takes an input `Observable`, and returns another `Observable`
    object that emits events from the input `Observable` object until it either completes
    or fails. If the input `Observable` object fails, the `retry` combinator subscribes
    to the input `Observable` object again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now use the `retry` combinator with the `randomQuote` method to fetch quotes
    until we obtain a quote shorter than 100 characters. We first transform the long
    quotes from the `randomQuote` method into failed observables, which enables `retry`
    to subscribe again to obtain another quote. To do this, we define a new `Observable`
    object called `errorMessage`, which emits a string `"Retrying..."` and then fails.
    We then traverse the `text` quote from `randomQuote` in a `for` comprehension.
    If the `text` quote is shorter than 100 characters, we traverse an `Observable`
    object that emits text. Otherwise, we traverse the `errorMessage` object to output
    `"Retrying..."` instead of `text`. This `for` comprehension defines an `Observable`
    object `quoteMessage`, which either emits a short quote, or emits `"Retrying..."`
    and fails. The marble diagram of the resulting `Observable` object, called `quoteMessage`,
    is shown for these two cases, in which the exception in the `Observable` object
    is shown with a cross symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Failure handling in Observables](img/image_06_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we call the `retry` method on the `quoteMessage` object and subscribe
    to it. We specify that we want to retry up to five times, as omitting the argument
    would retry forever. We implement the `Observable` object `quoteMessage` in the
    following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this program several times. You will notice that a short quote is either
    printed right away, or after a few retries, depending on some random distribution
    of the quotes. You may be wondering how many quotes are on average longer than
    100 characters. It turns out that it is easy to do this statistic in Rx. We introduce
    two new combinators. The first one is called `repeat`, and it is very similar
    to `retry`. Instead of re-subscribing to an `Observable` object when it fails,
    it re-subscribes when an `Observable` object completes. The second combinator
    is called `scan` and it is similar to the `scanLeft` operator on collections.
    Given an input `Observable` object and a starting value for the accumulation,
    it emits the value of the accumulation by applying the specified binary operator
    to the accumulation and the event, updating the accumulation as the events arrive.
    The usage of the `repeat` and `scan` combinators is illustrated in the following
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we use the `Observable` object `quoteMessage` defined
    earlier in order to obtain a short quote or a message `"Retrying..."` followed
    by an exception. We retry quotes that have failed because of being too long, and
    repeat whenever a quote is short enough. We take 100 quotes in total, and use
    the `scan` operator to count the short quotes. When we ran this program, it turned
    out that 57 out of 100 quotes are too long for our book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `retry` method is used in order to repeat events from failed `Observable`
    objects. Similarly, the `repeat` method is used in order to repeat events from
    completed `Observable` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the examples shown so far, we use the same `Observable` object to re-subscribe
    and emit additional events if that `Observable` object fails. In some cases, we
    want to emit specific events when we encounter an exception, or fall back to a
    different `Observable` object. Recall that this is what we did with `Future` objects
    previously. The Rx methods that replace an exception with an event, or multiple
    events from another `Observable` object, are called `onErrorReturn` and `onErrorResumeNext`,
    respectively. In the following program, we first replace the exception from `status`
    with a string `"exception occurred."`. We then replace the exception with strings
    from another `Observable` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Having seen various ways to compose `Observable` objects, we turn to the concurrency
    features of Rx. So far, we did not pay close attention to the thread on which
    an `Observable` object emits events. In the next section, we will study how to
    transfer events between `Observable` objects on different threads, and learn when
    this can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Rx schedulers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we observed that different `Observable` objects
    emit events on different threads. A synchronous `Observable` object emits on the
    caller thread when the `subscribe` method gets invoked. The `Observable.timer`
    object emits events asynchronously on threads internally used by Rx. Similarly,
    events in `Observable` objects created from `Future` objects are emitted on `ExecutionContext`
    threads. What if we want to use an existing `Observable` object to create another
    `Observable` object bound to a specific thread?
  prefs: []
  type: TYPE_NORMAL
- en: 'To encapsulate the choice of the thread on which an `Observable` object should
    emit events, Rx defines a special class called `Scheduler`. A `Scheduler` class
    is similar to the `Executor` and `ExecutionContext` interfaces we saw in [Chapter
    3](ch03.html "Chapter 3. Traditional Building Blocks of Concurrency"), *Traditional
    Building Blocks of Concurrency*. The `Observable` objects come with a combinator
    called `observeOn`. This combinator returns a new `Observable` object that emits
    events using the specified `Scheduler` class. In the following program, we instantiate
    a `Scheduler` object called `ComputationScheduler`, which emits events using an
    internal thread pool. We then emit events with and without calling the `observeOn`
    combinator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'From the output, we can see that the second `subscribe` call uses a thread
    pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `ComputationScheduler` object maintains a pool of threads intended for computational
    tasks. If processing the events blocks or waits for I/O operations, we must use
    the `IOScheduler` object, which automatically spawns new threads when necessary.
    Exceptionally, if processing each event is a very coarse-grained task, we can
    use the `NewThreadScheduler` object, which spawns a new thread for each event.
  prefs: []
  type: TYPE_NORMAL
- en: Using custom schedulers for UI applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Built-in Rx schedulers are useful for most tasks, but in some cases we need
    more control. Most UI toolkits only allow you to read and modify UI elements from
    a special thread. This thread is called the **event-dispatching** thread. This
    approach simplifies the design and the implementation of a UI toolkit, and protects
    clients from subtle concurrency errors. Since the UI usually does not usually
    represent a computational bottleneck, this approach has been widely adopted; the
    Swing toolkit uses an `EventDispatchThread` object in order to propagate events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Observable` objects are particularly useful when applied to UI applications;
    a user interface is all about events. In subsequent examples, we will use the
    Scala Swing library to illustrate the usefulness of Rx in UI code. We start by
    adding the following dependency to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We will start by creating a simple Swing application with a single button.
    Clicking on this button will print a message to the standard output. This application
    illustrates how to convert Swing events into an `Observable` object. We will start
    by importing the relevant Scala Swing packages as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: To create a Swing application, we need to extend the `SimpleSwingApplication`
    class. This class has a single abstract method, `top`, which needs to return a
    `Frame` object. The Swing's abstract `Frame` class represents the application
    window. We return a new `MainFrame` object, which is a subclass of the `Frame`
    object. In the `MainFrame` constructor, we set the window title bar text to `Swing
    Observables`, and instantiate a new `Button` object with the `Click` text. We
    then set the contents of the `MainFrame` constructor to that button.
  prefs: []
  type: TYPE_NORMAL
- en: 'So much for the UI elements and their layout; we now want to add some logic
    to this simple application. Traditionally, we would make a Swing application interactive
    by installing callbacks to various UI elements. Using Rx, we instead convert callbacks
    into event streams; we define an `Observable` object called `buttonClicks` that
    emits an event every time the button element is clicked on. We use the `Observable.create`
    method in order to register a `ButtonClicked` callback that calls the `onNext`
    method on the observer. To log clicks to the standard output, we subscribe to
    `buttonClicks`. The complete Swing application is shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this application opens the window, shown in the following screenshot.
    Clicking on the **Click** button prints a string to the standard output. We can
    see that the events are emitted on the thread called `AWT-EventQueue-0`, which
    is the event-dispatching thread in Swing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using custom schedulers for UI applications](img/image_06_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One downside of single-threaded UI toolkits is that long-running computations
    on the event-dispatching thread block the UI and harm the user experience. If
    we issue a blocking HTTP request each time the user clicks on a button, we will witness
    a noticeable lag after each click. Luckily, this is easy to address by executing
    long-running computations asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, we are not content with just starting an asynchronous computation.
    Once the asynchronous computation produces a result, we would like to display
    it in the application. Recall that we are not allowed to do this directly from
    the computation thread; we need to return the control back to event-dispatching
    thread. Swing defines the `invokeLater` method, which schedules tasks on Swing''s
    event-dispatching thread. On the other hand, Rx has a `Schedulers.from` built-in
    method that converts an `Executor` object into a `Scheduler` object. To bridge
    the gap between Swing''s `invokeLater` method and Rx schedulers, we implement
    a custom `Executor` object that wraps a call to `invokeLater`, and we pass this
    `Executor` object to `Schedulers.from`. The custom `swingScheduler` object is
    implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the newly-defined `swingScheduler` object in order to send events
    back to Swing. To illustrate this, let''s implement a small web browser application.
    Our browser consists of a `urlfield` address bar and the **Feeling lucky** button.
    Typing into the address bar displays suggestions for the URL, and clicking on
    the button displays the raw HTML of the webpage. The browser is not a trivial
    application, so we separate the implementation of the UI layout from the UI logic.
    We start by defining the `BrowserFrame` class, which describes the layout of the
    UI elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Scala Swing was implemented long before the introduction of Rx, so it does
    not come with event streams. We use Scala''s extension method pattern in order
    to enrich the existing UI element classes with `Observable` objects, and add implicit
    classes, `ButtonOps` and `TextFieldOps`, with methods, `clicks` and `texts`, respectively.
    The `clicks` method returns an `Observable` object that emits an event each time
    the corresponding button is clicked on. Similarly, the `texts` method emits an
    event each time the content of a text field changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We now have the necessary utilities to concisely define the logic of our web
    browser. We implement the browser logic in a trait called `BrowserLogic`, annotated
    with a self-type `BrowserFrame` object. The type `self` allows you to mix the
    `BrowserLogic` trait only into classes that extend the `BrowserFrame` object.
    This makes sense; the browser logic needs to know about UI events to react to
    them.
  prefs: []
  type: TYPE_NORMAL
- en: There are two main functionalities supported by the web browser. First, the
    browser needs to suggest possible URLs while the user types into the address bar.
    To facilitate this, we define a helper method, `suggestRequest`, which takes a
    term from the address bar and returns an `Observable` object with the possible
    completions. This `Observable` object uses Google's query suggestion service to
    get a list of possible URLs. To cope with network errors, the `Observable` object
    will time-out after 0.5 seconds if there is no reply from the server, and emit
    an error message.
  prefs: []
  type: TYPE_NORMAL
- en: Second, our browser needs to display the contents of the specified URL, when
    we click on the **Feeling lucky** button. To achieve this, we define another helper
    method named `pageRequest`, which returns an `Observable` object with the raw
    HTML of the web page. This `Observable` object times-out after four seconds if
    the page is not loaded by that time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these helper methods and the UI element `Observable` objects, we can
    encode the browser logic more easily. Each `urlField` text modification event
    maps into a nested `Observable` object with the suggestion. The call to `concat`
    then flattens the nested `Observable` object. The suggestion events transfer back
    to the Swing event-dispatching thread using the `observeOn` combinator. We subscribe
    to the events on the Swing event-dispatching thread in order to modify the contents
    of the `pagefield` text area. We subscribe to `button.clicks` in a similar way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining both the UI layout and the UI logic, we only need to instantiate
    the browser frame in a Swing application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the application opens the browser frame, and we can start surfing in
    our very own Rx-based web browser. The guys at Mozilla and Google will surely
    be impressed when they see the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using custom schedulers for UI applications](img/image_06_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although our web browser is very simple, we managed to separate its functionality
    into the UI layout and browser logic layers. The UI layout layer defines `Observable`
    objects such as `urlfield.texts` and `button.clicks` as part of its interface.
    The browser logic layer relies on the functionality from the UI layout layer;
    for example, we could not describe the updates to the `pagefield` UI element without
    referencing the `Observable` object `button.clicks`.
  prefs: []
  type: TYPE_NORMAL
- en: We say that the browser logic depends on the UI layout, but not vice versa.
    For a UI application, this can be acceptable, but other applications require a
    more loosely coupled design, in which different layers do not refer to each other
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: Subjects and top-down reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composing `Observable` objects is similar to composing functions, collections,
    or futures. Complex `Observable` objects are formed from simpler parts using functional
    composition. This is a very Scala-idiomatic pattern, and it results in concise
    and understandable programs.
  prefs: []
  type: TYPE_NORMAL
- en: A not-so-obvious downside of functional composition is that it favors the **bottom-up
    programming style**. An `Observable` object cannot be created without a reference
    to another `Observable` object that it depends on. For instance, we cannot create
    an `Observable` object using the `map` combinator without having an input `Observable`
    object to call the `map` method on. In a bottom-up programming style, we build
    complex programs by implementing the simplest parts first, and then gradually
    working our way up. By contrast, in a **top-down programming style**, we first
    define the complex parts of the system, and then gradually divide them into successively
    smaller pieces. The top-down programming style allows first declaring an `Observable`
    object, and defining its dependencies later.
  prefs: []
  type: TYPE_NORMAL
- en: To allow building systems in a top-down programming style, Rx defines an abstraction
    called a subject, represented by the `Subject` trait. A `Subject` trait is simultaneously
    an `Observable` object and an `Observer` object. As an `Observable` object, a
    `Subject` trait can emit events to its subscribers. As an `Observer` object, a
    `Subject` trait can subscribe to different input `Observable` objects and forward
    their events to its own subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Subject` trait is an `Observable` object whose inputs can change after its
    creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how to use a Subject trait in practice, let''s assume that we are building
    our own operating system. Having witnessed how practical the Rx event streams
    are, we decide to use them throughout our operating system, which we name **RxOS**.
    To make RxOS pluggable, its functionality is divided into separate components
    called kernel modules. Each kernel module might define a certain number of `Observable`
    objects. For example, a `TimeModule` module exposes an `Observable` object named
    `systemClock`, which outputs a string with the system uptime every second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'System output is an essential part of every operating system. We want RxOS
    to output important system events such as the system uptime. We already know how
    to do this by calling `subscribe` on the `systemClock` object from the `TimeModule`
    module, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say that another team now independently develops another kernel module
    named `FileSystemModule`, which exposes an `Observable` object called `fileModifications`.
    This `Observable` object emits a filename each time a file is modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Our core development team now decides that the `fileModifications` objects
    are important system events and wants to log these events as part of the `messageBus`
    subscription. We now need to redefine the singleton object `RxOS`, as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This patch solves the situation, but what if another kernel module introduces
    another group of important system events? With our current approach, we will have
    to recompile the RxOS kernel each time some third-party developer implements a
    kernel module. Even worse, the `RxOS` object definition references kernel modules,
    and thus, depends on them. Developers who want to build custom, reduced versions
    of RxOS now need to tweak the kernel source code.
  prefs: []
  type: TYPE_NORMAL
- en: This is the classic culprit of the bottom-up programming style; we are unable
    to declare the `messageBus` object without declaring its dependencies, and declaring
    them binds us to specific kernel modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now redefine the `messageBus` object as an Rx subject. We create a new `Subject`
    instance that emits strings, and we then subscribe to it, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the `messageBus` object is not subscribed to any `Observable`
    objects and does not emit any events. We can now define the RxOS boot sequence
    separately from the modules and the kernel code. The boot sequence specifies which
    kernel modules to subscribe with the `messageBus` object, and stores their subscriptions
    into the `loadedModules` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The boot sequence first subscribes the `messageBus` object to each of the required
    modules. We can do this because the `messageBus` object is an `Observer` object,
    in addition to being an `Observable` object. The `RxOS` then stays up for 10 seconds
    before calling `unsubscribe` on the modules and shutting down. During this time,
    the system clock emits an event to the `messageBus` object every second. Similarly,
    the `messageBus` object outputs the name of the modified file every time a file
    modification occurs, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Subjects and top-down reactive programming](img/image_06_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The difference between the two approaches is shown in the preceding figure.
    In the bottom-up approach, we first need to define all the kernel modules and
    then make RxOS depend on them. In the top-down approach, RxOS does not depend
    on the kernel modules. Instead, it is glued together with them by the boot sequence
    module. The RxOS clients no longer need to tweak or recompile the kernel code
    if they want to add a new kernel module. In fact, the new design even allows hot-plugging
    kernel modules into a running RxOS instance, long after the boot sequence is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use `Subject` instances when you need to create an `Observable` object whose
    inputs are not available when the `Observable` object is created.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, designing a web browser is a lot like ordering a MacBook. After
    specifying the preferred processor type and the hard disk size, the MacBook is
    assembled, and its components cannot be exchanged easily. Analogously, after implementing
    the browser's UI layout, the event streams that describe the interaction between
    UI components are declared only once, and cannot change if the UI components are
    replaced. On the other hand, building an OS is more like building a desktop computer
    from custom components. After putting the motherboard into the case, we can plug
    in components such as the graphics card or the RAID controller independently.
    Similarly, after declaring the `messageBus` subject, we can plug in any number
    of kernel modules at any time during the execution of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Although the `Subject` interface is more flexible than the `Observable` interface,
    you should not always use the `Subject` instances and rely exclusively on the
    top-down programming style. While declaring the dependencies of an `Observable`
    object at its creation point makes the application less flexible, it also makes
    it more declarative and easier to understand. Modern large-scale applications
    usually combine both bottom-up and top-down approaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rx defines several other types of subject. The type `ReplaySubject` is a `Subject`
    implementation that buffers the events it receives as an `Observer` object. When
    another `Observer` object subscribes to a `ReplaySubject` instance, all the events
    previously buffered by the `ReplaySubject` instance are replayed. In the following
    code snippet, we define a `ReplaySubject` instance called `messageLog` in `RxOS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `messageLog` object subscribes to the `messageBus` object in order to buffer
    all the system messages. If, for example, we now want to dump all the messages
    into a log file, we can subscribe to the `messageLog` object immediately before
    the application ends, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Rx also defines two other subjects called `BehaviorSubject` and `AsyncSubject`.
    The `BehaviorSubject` class buffers only the most recent event, and the `AsyncSubject`
    class only emits the event immediately preceding `onComplete`. We will not study
    their exact semantics and use case here, but we refer you to the online documentation
    to find out more about them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First-class event streams are an extremely expressive tool for modelling dynamic,
    event-based systems with time-varying values. Rx `Observable` objects are an event
    stream implementation designed to build scalable, concurrent, event-based applications.
    In this chapter, we saw how to create Rx `Observable` objects and how to subscribe
    to their events. We studied the `Observable` contract and learned how to compose
    complex `Observable` objects from simple ones. We investigated various ways of
    recovering from failures and saw how to use Rx schedulers to transfer events between
    threads. Finally, we learned how to design loosely coupled systems with Rx subjects.
    These powerful tools together allow us to build a plethora of different applications,
    ranging from web browsers, FTP servers, the music and video players to real-time
    games and trading platforms, and even operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the increasing popularity of reactive programming, a number of frameworks
    similar to Rx have appeared in the recent years: REScala, Akka Streams, and Reactive
    Collections, to name a few. We did not study the semantics of these frameworks
    in this chapter, but leave it to the readers to explore them on their own.'
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that `Observable` objects are very declarative in nature, making
    the Rx programming model easy to use and understand. Nevertheless, it is sometimes
    useful to model a system imperatively, using explicit state. In the next chapter,
    we will study software transactional memory, which allows accessing shared program
    state without the risk of deadlocks and race conditions, which we learned about
    in [Chapter 2](ch02.html "Chapter 2. Concurrency on the JVM and the Java Memory
    Model"), *Concurrency on the JVM and the Java Memory Model*.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following exercises, you will need to implement different `Observable`
    objects. The exercises show different use cases for `Observable` objects, and
    contrast the different ways of creating `Observable` objects. Also, some of the
    exercises introduce new reactive programming abstractions, such as reactive maps
    and reactive priority queues.
  prefs: []
  type: TYPE_NORMAL
- en: Implement a custom `Observable[Thread]` object that emits an event when it detects
    that a thread was started. The implementation is allowed to miss some of the events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement an `Observable` object that emits an event every 5 seconds and every
    12 seconds, but not if the elapsed time is a multiple of 30 seconds. Use functional
    combinators on `Observable` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `randomQuote` method from this section in order to create an `Observable`
    object with the moving average of the quote lengths. Each time a new quote arrives,
    a new average value should be emitted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the reactive signal abstraction, represented with the `Signal[T]`
    type. The type `Signal[T]` comes with the method `apply`, used to query the last
    event emitted by this signal, and several combinators with the same semantics
    as the corresponding `Observable` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the method `toSignal` to the type `Observable[T]`, which converts
    an `Observable` object to a reactive signal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Consider using Rx subjects for this task.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the reactive cell abstraction, represented with the type `RCell[T]`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A reactive cell is simultaneously a reactive signal from the previous exercise.
    Calling the `:=` method sets a new value to the reactive cell, and emits an event.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the reactive map collection, represented with the `RMap` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `update` method behaves like the update on a regular `Map` collection. Calling
    `apply` on a reactive map returns an `Observable` object with all the subsequent
    updates of the specific key.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the reactive priority queue, represented by the `RPriorityQueue`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The reactive priority queue exposes the `Observable` object `popped`, which
    emits events whenever the smallest element in the priority queue gets removed
    by calling `pop`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the `copyFile` method, which copies a file specified with the `src`
    parameter to the destination specified with the `dest` parameter. The method returns
    an `Observable[Double]` object, which emits an event with the file transfer progress
    every 100 milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The resulting `Observable` object must complete if the file transfer completes
    successfully, or otherwise fail with an exception.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a custom Swing component, called `RxCanvas`, which exposes mouse events
    using `Observable` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the `RxCanvas` component to build your own Paint program, in which you can
    drag lines on the canvas using a brush, and save the contents of the canvas to
    an image file. Consider using nested `Observable` objects to implement dragging.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement a method called `scatterGather` on the type `Observable`, which forwards
    every event to one of the worker threads, performs some work on those threads,
    and emits the computed results on a new `Observable` object. The signature of
    this method is as follows, where type `T` is the type of the events in the original
    `Observable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implement the `sorted` method on the type `Observable`, which emits incoming
    events in the sorted order. The events can be emitted only after the original
    `Observable` terminates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
