- en: Chapter 6. Concurrent Programming with Reactive Extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 使用反应式扩展的并发编程
- en: '|   | *"Your mouse is a database."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"你的鼠标就是一个数据库。"|   |'
- en: '|   | --*Erik Meijer* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*埃里克·梅耶尔* |'
- en: The futures and promises from [Chapter 4](ch04.html "Chapter 4.  Asynchronous
    Programming with Futures and Promises"), *Asynchronous Programming with Futures
    and Promises*, push concurrent programming to a new level. First, they avoid blocking
    when transferring the result of the computation from the producer to the consumer.
    Second, they allow you to idiomatically compose simple future objects into more
    complex ones, resulting in programs that are more concise. Futures encapsulate
    patterns of asynchronous communication in a way that is clear and easily understandable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 来自第4章[异步编程与未来和承诺](ch04.html "第4章. 异步编程与未来和承诺")的“异步编程与未来和承诺”，将并发编程提升到了一个新的水平。首先，它们在将计算结果从生产者传输到消费者时避免了阻塞。其次，它们允许你以惯用的方式将简单的未来对象组合成更复杂的对象，从而产生更简洁的程序。未来以清晰且易于理解的方式封装了异步通信的模式。
- en: One disadvantage of futures is that they can only deal with a single result.
    For HTTP requests or asynchronous computations that compute a single value, futures
    can be adequate, but sometimes we need to react to many different events coming
    from the same computation. For example, it is cumbersome to track the progress
    status of a file download with futures. Event streams are a much better tool for
    this use case; unlike futures, they can produce any number of values, which we
    call events. First-class event streams, which we will learn about in this chapter,
    can be used inside expressions as if they were regular values. Just as with futures,
    first-class event streams can be composed and transformed using functional combinators.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的一个缺点是它们只能处理单个结果。对于HTTP请求或计算单个值的异步操作，未来可能足够用，但有时我们需要对来自同一计算的不同事件做出反应。例如，使用未来跟踪文件下载的进度状态是相当繁琐的。事件流是处理此类用例的更好工具；与未来不同，它们可以产生任意数量的值，我们称之为事件。在本章中，我们将学习的一等事件流可以在表达式中像常规值一样使用。就像未来一样，一等事件流可以使用函数组合子进行组合和转换。
- en: In computer science, **event-driven programming** is a programming style in
    which the flow of the program is determined by events such as external inputs,
    user actions, or messages coming from other computations. Here, a user action
    might be a mouse click, and an external input can be a network interface. Both
    futures and event streams can be classified as event-driven programming abstractions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，**事件驱动编程**是一种编程风格，其中程序的流程由事件（如外部输入、用户操作或其他计算的消息）决定。在这里，用户操作可能是一个鼠标点击，外部输入可以是网络接口。未来和事件流都可以归类为事件驱动编程抽象。
- en: '**Reactive programming**, which deals with the propagation of change and the
    flow of data in the program, is a closely related discipline. Traditionally, reactive
    programming is defined as a programming style that allows you to express various
    constraints between the data values in the program. For example, when we say `a
    = b + 1` in an imperative programming model, it means that `a` is assigned the
    current value of `b` increased by `1`. If the value `b` later changes, the value
    of `a` does not change. By contrast, in reactive programming, whenever the value
    `b` changes, the value `a` is updated using the constraint `a = b + 1`. With the
    rising demand for concurrency, the need for event-driven and reactive programming
    grows even larger. Traditional callback-based and imperative APIs have shown to
    be inadequate for this task: they obscure the program flow, mix concurrency concerns
    with program logic, and rely on mutable state. In larger applications, swarms
    of unstructured callback declarations lead to an effect known as the callback
    hell, in which the programmer can no longer make sense of the control flow of
    the program. In a way, callbacks are the `GOTO` statement of reactive programming.
    **Event stream composition** captures patterns of callback declarations, allowing
    the programmer to express them more easily. It is a much more structured approach
    for building event-based systems.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应式编程**，它处理程序中的变化传播和数据流，是一个与之密切相关的学科。传统上，响应式编程被定义为一种编程风格，允许你表达程序中数据值之间的各种约束。例如，当我们在一个命令式编程模型中说`a
    = b + 1`时，这意味着`a`被分配了`b`当前值加`1`的结果。如果`b`的值后来发生变化，`a`的值不会改变。相比之下，在响应式编程中，每当`b`的值发生变化时，`a`的值都会使用约束`a
    = b + 1`进行更新。随着对并发性的需求增加，对事件驱动和响应式编程的需求也更大。传统的基于回调和命令式的API已被证明不足以完成这项任务：它们模糊了程序流程，将并发问题与程序逻辑混合在一起，并依赖于可变状态。在大型应用程序中，大量的无结构回调声明会导致一种称为回调地狱的现象，程序员无法理解程序的流程控制。从某种意义上说，回调是响应式编程中的`GOTO`语句。**事件流组合**捕获回调声明的模式，允许程序员更容易地表达它们。这是一种构建基于事件的系统的更结构化的方法。'
- en: '**Reactive Extensions** (**Rx**) is a programming framework for composing asynchronous
    and event-driven programs using event streams. In Rx, an event stream that produces
    events of type `T` is represented with the type `Observable[T]`. As we will learn
    in this chapter, the Rx framework incorporates principles present both in reactive
    and in event-driven programming. The fundamental concept around Rx is that events
    and data can be manipulated in a similar way.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应式扩展**（**Rx**）是一个用于使用事件流来组合异步和事件驱动程序的编程框架。在Rx中，产生类型为`T`事件的流以`Observable[T]`类型表示。正如我们将在本章中学习的那样，Rx框架结合了响应式和事件驱动编程中的原则。Rx的基本概念是事件和数据可以以类似的方式进行操作。'
- en: 'In this chapter, we will study the semantics of `RxObservable` objects, and
    learn how to use them to build event-driven and reactive applications. Concretely,
    we will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究`RxObservable`对象的语义，并学习如何使用它们来构建事件驱动和响应式应用程序。具体来说，我们将涵盖以下主题：
- en: Creating and subscribing to the `Observable` objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和订阅`Observable`对象
- en: The observable contract and how to implement custom `Observable` objects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察合同以及如何实现自定义`Observable`对象
- en: Using the subscriptions to cancel event sources
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用订阅来取消事件源
- en: Composing observable objects using Rx combinators
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Rx组合子组合可观察对象
- en: Controlling concurrency with Rx scheduler instances
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Rx调度器实例控制并发
- en: Using Rx subjects for designing larger applications
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Rx主题来设计更大的应用程序
- en: We will start with simple examples that show you how to create and manipulate
    the `Observable` objects, and illustrate how they propagate events.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简单的示例开始，向您展示如何创建和操作`Observable`对象，并说明它们如何传播事件。
- en: Creating Observable objects
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可观察对象
- en: In this section, we will study various ways of creating `Observable` objects.
    We will learn how to subscribe to different kinds of event produced by `Observable`
    instances and learn how to correctly create custom `Observable` objects. Finally,
    we will discuss the difference between cold and hot observables.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究创建`Observable`对象的多种方法。我们将学习如何订阅由`Observable`实例产生的不同类型的事件，以及如何正确创建自定义`Observable`对象。最后，我们将讨论冷可观察对象和热可观察对象之间的区别。
- en: An `Observable` object is an object that has a method called `subscribe`, which
    takes an object called an observer as a parameter. The observer is a user-specified
    object with custom event-handling logic. When we call the `subscribe` method with
    a specific observer, we can say that the observer becomes subscribed to the respective
    `Observable` object. Every time the `Observable` object produces an event, its
    subscribed observers get notified.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable` 对象是一个具有名为 `subscribe` 的方法的对象，该方法接受一个名为观察者的对象作为参数。观察者是一个用户指定的对象，具有自定义的事件处理逻辑。当我们使用特定的观察者调用
    `subscribe` 方法时，我们可以说观察者已经订阅了相应的 `Observable` 对象。每当 `Observable` 对象产生事件时，其已订阅的观察者都会收到通知。'
- en: 'The Rx implementation for Scala is not a part of the Scala standard library.
    To use Rx in Scala, we need to add the following dependency to our `build.sbt`
    file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 的 Rx 实现**不是**Scala 标准库的一部分。要在 Scala 中使用 Rx，我们需要将以下依赖项添加到我们的 `build.sbt`
    文件中：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we can import the contents of the `rx.lang.scala` package to start using
    Rx. Let''s say that we want to create a simple `Observable` object that first
    emits several `String` events and then completes the execution. We use the `items`
    factory method on the `Observable` companion object to create an `Observable`
    object `o`. We then call the `subscribe` method, which is similar to the `foreach`
    method on futures introduced in [Chapter 4](ch04.html "Chapter 4.  Asynchronous
    Programming with Futures and Promises"), *Asynchronous Programming with Futures
    and Promises*. The `subscribe` method takes a callback function and instructs
    the `Observable` object `o` to invoke the callback function for each event that
    is emitted. It does so by creating an `Observer` object behind the scenes. The
    difference is that, unlike futures, the `Observable` objects can emit multiple
    events. In our example, the callback functions print the events to the screen
    by calling the `log` statement, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以导入 `rx.lang.scala` 包的内容以开始使用 Rx。假设我们想要创建一个简单的 `Observable` 对象，该对象首先发出几个
    `String` 事件，然后完成执行。我们使用 `Observable` 伴生对象的 `items` 工厂方法创建一个 `Observable` 对象 `o`。然后我们调用
    `subscribe` 方法，这与在 [第 4 章](ch04.html "第 4 章。使用 futures 和 promises 进行异步编程") 中引入的
    futures 的 `foreach` 方法类似，即 *使用 futures 和 promises 进行异步编程*。`subscribe` 方法接受一个回调函数，并指示
    `Observable` 对象 `o` 为每个发出的事件调用回调函数。它通过在幕后创建一个 `Observer` 对象来实现。不同之处在于，与 futures
    不同，`Observable` 对象可以发出多个事件。在我们的示例中，回调函数通过调用 `log` 语句将事件打印到屏幕上，如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Upon running this example, we notice two things. First, all the `log` statements
    are executed on the main program thread. Second, the callback associated with
    the first `subscribe` call is invoked for all three programming languages before
    the callback associated with the second `subscribe` call is called for these three
    languages:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例后，我们注意到两件事。首先，所有的 `log` 语句都是在主程序线程上执行的。其次，与第一个 `subscribe` 调关联的回调在为这三种编程语言调用与第二个
    `subscribe` 调关联的回调之前，为这三种语言调用：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can conclude that the `subscribe` call executes synchronously--it invokes
    callback for all the events emitted by the event stream `o` before returning.
    However, this is not always the case. The `subscribe` call can also return the
    control to the main thread immediately, and invoke the callback functions asynchronously.
    This behavior depends on the implementation of the `Observable` object. In this
    Rx implementation, the `Observable` objects created using the `items` method have
    their events available when the `Observable` object is created, so their `subscribe`
    method is synchronous.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出结论，`subscribe` 调用是同步执行的——它在返回之前调用事件流 `o` 发出的所有事件的回调。然而，这并不总是如此。`subscribe`
    调用也可以立即将控制权返回给主线程，并异步调用回调函数。这种行为取决于 `Observable` 对象的实现。在这个 Rx 实现中，使用 `items` 方法创建的
    `Observable` 对象在其创建时就有可用的事件，因此它们的 `subscribe` 方法是同步的。
- en: In the previous example, the `Observable` object feels almost like an immutable
    Scala collection, and the `subscribe` method acts as if it is a `foreach` method
    on a collection. However, the `Observable` objects are more general. We will see
    an `Observable` object that emits events asynchronously next.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，`Observable` 对象几乎感觉就像是一个不可变的 Scala 集合，而 `subscribe` 方法就像是在集合上执行的 `foreach`
    方法。然而，`Observable` 对象更为通用。我们将看到下一个异步发出事件的 `Observable` 对象。
- en: 'Let''s assume that we want the `Observable` object that emits an event after
    a certain period of time has elapsed. We use the `timer` factory method to create
    such an `Observable` object and set the timeout to 1 second. We then call the
    `subscribe` method with two different callbacks, as shown in the following code
    snippet:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个在经过一定时间后发出事件的`Observable`对象。我们使用`timer`工厂方法创建这样的`Observable`对象，并将超时设置为1秒。然后我们使用两个不同的回调函数调用`subscribe`方法，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This time, the `subscribe` method calls are asynchronous; it makes no sense
    to block the main thread for an entire second and wait until the timeout event
    appears. Running the example shows that the main thread continues before the callback
    functions are invoked:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`subscribe`方法的调用是异步的；没有必要阻塞整个一秒的主线程，等待超时事件出现。运行示例显示，在回调函数被调用之前，主线程继续运行：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Furthermore, the `log` statements reveal that the callback functions are invoked
    on the thread pool internally used by Rx, in an unspecified order.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`log`语句显示，回调函数是在Rx内部使用的线程池上以未指定的顺序调用的。
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `Observable` objects can emit events either synchronously or asynchronously,
    depending on the implementation of the specific `Observable` object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable`对象可以同步或异步地发出事件，具体取决于特定`Observable`对象的实现。'
- en: As we will see, in most use cases, events are not available when calling the
    `subscribe` method. This is the case with UI events, file modification events,
    or HTTP responses. To avoid blocking the thread that calls the `subscribe` method,
    the `Observable` objects emit such events asynchronously.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，在大多数情况下，在调用`subscribe`方法时事件是不可用的。这是UI事件、文件修改事件或HTTP响应的情况。为了避免阻塞调用`subscribe`方法的线程，`Observable`对象异步地发出此类事件。
- en: Observables and exceptions
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观察对象和异常
- en: In [Chapter 4](ch04.html "Chapter 4.  Asynchronous Programming with Futures
    and Promises"), *Asynchronous Programming with Futures and Promises*, we saw that
    asynchronous computations sometimes throw exceptions. When that happens, the `Future`
    object associated with the exception fails; instead of being completed with the
    result of the computation, the `Future` object is completed with the exception
    that failed the asynchronous computation. The clients of the `Future` objects
    can react to exceptions by registering callbacks with the `failed.foreach` or
    `onComplete` methods.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。使用未来和承诺进行异步编程")中，我们了解到异步计算有时会抛出异常。当这种情况发生时，与异常相关的`Future`对象失败；不是以计算的结果完成，而是以失败异步计算的异常完成`Future`对象。`Future`对象的客户端可以通过使用`failed.foreach`或`onComplete`方法注册回调来对异常做出反应。
- en: Computations that produce events in `Observable` objects can also throw exceptions.
    To respond to exceptions produced by the `Observable` objects, we can use an overload
    of the `subscribe` method that takes two callback arguments to create an observer--the
    callback function for the events and the callback function for the exception.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Observable`对象中产生事件的计算也可能抛出异常。为了响应`Observable`对象产生的异常，我们可以使用接受两个回调参数的重载`subscribe`方法来创建观察者--事件的回调函数和异常的回调函数。
- en: 'The following program creates an `Observable` object that emits numbers `1`
    and `2`, and then produces a `RuntimeException`. The `items` factory method creates
    the `Observable` object with the numbers, and the `error` factory method creates
    another `Observable` object with an exception. We then concatenate the two together
    with the `++` operator on `Observable` instances. The first callback logs the
    numbers to the standard output and ignores the exception. Conversely, the second
    callback logs the `Throwable` objects and ignores the numbers. This is shown in
    the following code snippet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序创建了一个发出数字`1`和`2`的`Observable`对象，然后产生一个`RuntimeException`。`items`工厂方法使用数字创建`Observable`对象，而`error`工厂方法创建另一个带有异常的`Observable`对象。然后我们使用`Observable`实例上的`++`运算符将这两个对象连接起来。第一个回调将数字记录到标准输出并忽略异常。相反，第二个回调记录`Throwable`对象并忽略数字。这在上面的代码片段中显示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The program first prints numbers `1` and `2`, and then prints the exception
    object. Without the second callback function being passed to the `subscribe` method,
    the exception will be emitted by the `Observable` object `o`, but never passed
    to the observer. Importantly, after an exception is emitted, the `Observable`
    object is not allowed to emit any additional events. We can redefine the `Observable`
    object `o` as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先打印数字`1`和`2`，然后打印异常对象。如果没有将第二个回调函数传递给`subscribe`方法，异常将由`Observable`对象`o`发出，但不会传递给观察者。重要的是，在发出异常之后，`Observable`对象不允许再发出任何其他事件。我们可以如下重新定义`Observable`对象`o`：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We might expect the program to print events `3` and `4`, but they are not emitted
    by the `Observable` object `o`. When an `Observable` object produces an exception,
    we say that it is in the error state.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能期望程序打印事件`3`和`4`，但它们并没有由`Observable`对象`o`发出。当一个`Observable`对象抛出异常时，我们说它处于错误状态。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When an `Observable` object produces an exception, it enters the error state
    and cannot emit more events.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个`Observable`对象抛出异常时，它会进入错误状态，无法再发出更多事件。
- en: Irrespective of whether the `Observable` object is created using a factory method,
    or is a custom `Observable` implementation described in the subsequent sections,
    an `Observable` object is not allowed to emit events after it produces an exception.
    In the next section, we will examine this contract in more detail.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 无论`Observable`对象是使用工厂方法创建的，还是后续章节中描述的自定义`Observable`实现，一旦`Observable`对象抛出异常，它就不允许再发出事件。在下一节中，我们将更详细地探讨这个合约。
- en: The Observable contract
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观察者合约
- en: 'Now that we have seen how to create simple `Observable` objects and react to
    their events, it is time to take a closer look at the lifetime of an `Observable`
    object. Every `Observable` object can be in three states: uncompleted, error,
    or completed. As long as the `Observable[T]` object is uncompleted, it can emit
    events of type `T`. As we already learned, an `Observable` object can produce
    an exception to indicate that it failed to produce additional data. When this
    happens, the `Observable` object enters the error state and cannot emit any additional
    events. Similarly, when an `Observable` object decides that it will not produce
    any additional data, it might enter the completed state. After an `Observable`
    object is completed, it is not allowed to emit any additional events.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何创建简单的`Observable`对象并对其事件做出反应，现在是时候更深入地了解`Observable`对象的生命周期了。每个`Observable`对象都可以处于三种状态之一：未完成、错误或完成。只要`Observable[T]`对象未完成，它就可以发出类型为`T`的事件。正如我们已经学到的，`Observable`对象可以抛出异常来指示它未能产生更多数据。当这种情况发生时，`Observable`对象进入错误状态，无法再发出任何其他事件。同样，当`Observable`对象决定它将不再产生任何数据时，它可能会进入完成状态。一旦`Observable`对象完成，它不允许再发出任何其他事件。
- en: 'In Rx, an object that subscribes to events from an `Observable` object is called
    an `Observer` object. The `Observer[T]` trait comes with three methods: `onNext`,
    `onError`, and `onCompleted`, which get invoked when an `Observable` object emits
    an event, produces an error, or is completed, respectively. This trait is shown
    in the following code snippet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rx中，订阅来自`Observable`对象事件的对象被称为`Observer`对象。`Observer[T]`特质包含三个方法：`onNext`、`onError`和`onCompleted`，分别用于在`Observable`对象发出事件、产生错误或完成时被调用。这个特质在以下代码片段中显示：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the previous examples, whenever we called the `subscribe` method, Rx created
    an `Observer` object and assigned it to the `Observable` instance. Alternatively,
    we can provide an `Observer` object directly to an overloaded version of the `subscribe`
    method. The following program uses the `from` factory method which converts a
    list of movie titles into an `Observable` object. It then creates an `Observer`
    object and passes it to the `subscribe` method:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，每次我们调用`subscribe`方法时，Rx都会创建一个`Observer`对象并将其分配给`Observable`实例。或者，我们可以直接将`Observer`对象提供给`subscribe`方法的重载版本。以下程序使用`from`工厂方法，该方法将电影标题列表转换为`Observable`对象。然后它创建一个`Observer`对象并将其传递给`subscribe`方法：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This program first prints our favorite movies, and terminates after calling
    `onCompleted` and printing `"No more movies"`. The `Observable` object `movies`
    is created from a finite collection of strings; after these events are emitted,
    the `movies` event stream calls the `onCompleted` method. In general, the `Observable`
    objects can only call the `onCompleted` method after it is certain that there
    will be no more events.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序首先打印出我们的最爱电影，并在调用`onCompleted`并打印出`"No more movies"`后终止。`movies``Observable`对象是从一个有限的字符串集合中创建的；在这些事件发出后，`movies`事件流会调用`onCompleted`方法。一般来说，`Observable`对象只能在确定不会有更多事件后调用`onCompleted`方法。
- en: 'Every `Observable` object can call the `onNext` method on its `Observer` objects
    zero or more times. An `Observable` object might then enter the completed or error
    state by calling the `onCompleted` or `onError` method on its `Observer` objects.
    This is known as the `Observable` contract, and is shown graphically in the following
    state diagram, where different nodes denote `Observable` states, and links denote
    calls to different `Observer` methods:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Observable`对象都可以对其`Observer`对象调用`onNext`方法零次或多次。然后，`Observable`对象可以通过对其`Observer`对象调用`onCompleted`或`onError`方法进入完成或错误状态。这被称为`Observable`合约，并在以下状态图中以图形方式展示，其中不同的节点表示`Observable`状态，而链接表示对不同的`Observer`方法的调用：
- en: '![The Observable contract](img/image_06_001.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Observable合约](img/image_06_001.jpg)'
- en: Note that an `Observable` object can call the `onCompleted` or `onError` method
    if it knows that it will not emit additional events, but it is free to call neither.
    Some Observable objects, such as `items`, know when they emit the last event.
    On the other hand, an `Observable` instance that emits mouse or keyboard events
    never calls the `onCompleted` method.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果一个`Observable`对象知道它将不会发出更多事件，它可以调用`onCompleted`或`onError`方法，但它也可以不调用。一些`Observable`对象，如`items`，知道何时发出最后一个事件。另一方面，发出鼠标或键盘事件的`Observable`实例永远不会调用`onCompleted`方法。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An `Observable` object can call the `onNext` method on the subscribed `Observer`
    objects an unlimited number of times. After optionally calling the `onCompleted`
    or `onError` method, an `Observable` object is not allowed to call any `Observer`
    methods.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Observable`对象可以在订阅的`Observer`对象上无限次地调用`onNext`方法。在可选地调用`onCompleted`或`onError`方法后，`Observable`对象不允许再调用任何`Observer`方法。
- en: The `Observable` objects produced by the Rx API implement the `Observable` contract.
    In practice, we do not need to worry about the `Observable` contract, unless we
    are implementing our own custom `Observable` object. This is the topic of the
    next section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由Rx API产生的`Observable`对象实现了`Observable`合约。在实践中，我们不需要担心`Observable`合约，除非我们正在实现自己的自定义`Observable`对象。这是下一节的主题。
- en: Implementing custom Observable objects
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现自定义的`Observable`对象
- en: 'To create a custom `Observable` object, we can use the `Observable.create`
    factory method as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个自定义的`Observable`对象，我们可以使用以下`Observable.create`工厂方法：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding method takes a function `f` from an `Observer` to a `Subscription`
    object and returns a new `Observable` object. Whenever the `subscribe` method
    gets called, the function `f` is called on the corresponding `Observer` object.
    The function `f` returns a `Subscription` object, which can be used to unsubscribe
    the `Observer` object from the `Observable` instance. The `Subscription` trait
    defines a single method called `unsubscribe`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法从一个`Observer`对象到一个`Subscription`对象接收一个函数`f`，并返回一个新的`Observable`对象。每当调用`subscribe`方法时，就会在相应的`Observer`对象上调用函数`f`。函数`f`返回一个`Subscription`对象，可以用来从`Observable`实例中取消订阅`Observer`对象。`Subscription`特质定义了一个名为`unsubscribe`的单个方法：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will talk about the `Subscription` objects in more detail in a subsequent
    section. For now, we only use the empty `Subscription` object, which does not
    unsubscribe the `Observer` object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中更详细地讨论`Subscription`对象。现在，我们只使用空的`Subscription`对象，它不会取消订阅`Observer`对象。
- en: 'To illustrate how to use the `Observable.create` method, we implement an `Observable`
    object `vms`, which emits names of popular virtual machine implementations. In
    `Observable.create`, we take care to first call `onNext` with all the VM names,
    and then call `onCompleted` once. Finally, we return the empty `Subscription`
    object. This is shown in the following program:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何使用`Observable.create`方法，我们实现了一个名为`vms`的`Observable`对象，该对象会发出流行虚拟机实现的名字。在`Observable.create`中，我们首先确保使用所有虚拟机名称调用`onNext`，然后调用一次`onCompleted`。最后，我们返回一个空的`Subscription`对象。这在上面的程序中有所展示：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Observable` object `vms` has a synchronous `subscribe` method. All the
    events are emitted to an `obs` observer before returning the control to the thread
    that called the `subscribe` method. In general, we can use the `Observable.create`
    method in order to create an `Observable` instance that emits events asynchronously.
    We will study how to convert a `Future` object into an `Observable` object next.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable` 对象 `vms` 有一个同步的 `subscribe` 方法。在将控制权返回到调用 `subscribe` 方法的线程之前，所有事件都会发送到一个
    `obs` 观察者。一般来说，我们可以使用 `Observable.create` 方法来创建一个异步发送事件的 `Observable` 实例。我们将在下一节学习如何将
    `Future` 对象转换为 `Observable` 对象。'
- en: Creating Observables from futures
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 `Future` 创建 Observables
- en: Futures are objects that represent the result of an asynchronous computation.
    One can consider an `Observable` object as a generalization of a `Future` object.
    Instead of emitting a single success or failure event, an `Observable` object
    emits a sequence of events, before failing or completing successfully.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future` 对象代表异步计算的结果。可以将 `Observable` 对象视为 `Future` 对象的泛化。与只发送一个成功或失败事件不同，`Observable`
    对象在失败或成功完成之前会发送一系列事件。'
- en: 'Scala APIs that deal with asynchronous computations generally return the `Future`
    objects, and not `Observable` instances. In some cases, it is useful to be able
    to convert a `Future` object into an `Observable` object. Here, after a `Future`
    object is completed successfully, the corresponding `Observable` object must emit
    an event with the future value, and then call the `onCompleted` method. If the
    `Future` object fails, the corresponding `Observable` object should call the `onError`
    method. Before we begin, we need to import the contents of the `scala.concurrent`
    package and the global `ExecutionContext` object, as shown in the following code
    snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异步计算的 Scala API 通常返回 `Future` 对象，而不是 `Observable` 实例。在某些情况下，能够将 `Future` 对象转换为
    `Observable` 对象很有用。在这里，当 `Future` 对象成功完成时，相应的 `Observable` 对象必须发出一个包含未来值的事件，然后调用
    `onCompleted` 方法。如果 `Future` 对象失败，相应的 `Observable` 对象应该调用 `onError` 方法。在我们开始之前，我们需要导入
    `scala.concurrent` 包的内容和全局的 `ExecutionContext` 对象，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We then use the `Observable.create` method to create an `Observable` object
    `o`. Instead of calling the `onNext`, `onError`, and `onCompleted` methods directly
    on the `Observer` object, we will install callbacks on the `Future` object `f`,
    as shown in the following program:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `Observable.create` 方法创建一个 `Observable` 对象 `o`。我们不会直接在 `Observer` 对象上调用
    `onNext`、`onError` 和 `onCompleted` 方法，而是在 `Future` 对象 `f` 上安装回调，如下面的程序所示：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This time, the `subscribe` method is asynchronous. It returns immediately after
    installing the callback on the `Future` object. In fact, this pattern is so common
    that Rx comes with the `Observable.from` factory method that converts a `Future`
    object into an `Observable` object directly, as shown by the following code snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`subscribe` 方法是异步的。在将回调安装到 `Future` 对象上后立即返回。实际上，这种模式非常常见，Rx 提供了 `Observable.from`
    工厂方法，可以直接将 `Future` 对象转换为 `Observable` 对象，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Still, learning how to convert a `Future` object into an `Observable` object
    is handy. The `Observable.create` method is the preferred way to convert callback-based
    APIs to `Observable` objects, as we will see in subsequent sections.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，学习如何将 `Future` 对象转换为 `Observable` 对象仍然很有用。`Observable.create` 方法是将基于回调的
    API 转换为 `Observable` 对象的首选方法，正如我们将在后续章节中看到的。
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Use the `Observable.create` factory method to create the `Observable` objects
    from callback-based APIs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Observable.create` 工厂方法从基于回调的 API 创建 `Observable` 对象。
- en: In the examples so far, we have always returned an empty `Subscription` object.
    Calling the `unsubscribe` method on such a `Subscription` object has no effect.
    Sometimes, the `Subscription` objects need to release resources associated with
    the corresponding `Observable` instance. We will study how to implement and work
    with such `Subscription` objects next.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们总是返回一个空的 `Subscription` 对象。在这样一个 `Subscription` 对象上调用 `unsubscribe`
    方法没有任何效果。有时，`Subscription` 对象需要释放与相应的 `Observable` 实例关联的资源。我们将在下一节学习如何实现和使用这样的
    `Subscription` 对象。
- en: Subscriptions
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订阅
- en: Recall the example monitoring the filesystem for changes in [Chapter 4](ch04.html
    "Chapter 4.  Asynchronous Programming with Futures and Promises"), *Asynchronous
    Programming with Futures and Promises*, where we used the file monitoring package
    from the Apache Commons IO library to complete a `Future` object when a new file
    is created. A `Future` object can be completed only once, so the future was completed
    with the name of the first file that was created. It is more natural to use `Observable`
    objects for this use case, as files in a filesystem can be created and deleted
    many times. In an application such as a file browser or an FTP server, we would
    like to receive all such events.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下在第4章中监控文件系统变化的例子，*使用Futures和Promises进行异步编程*，在那里我们使用了Apache Commons IO库中的文件监控包来完成一个`Future`对象，当创建新文件时。`Future`对象只能完成一次，因此使用创建的第一个文件的名称来完成这个未来。对于这种用例，使用`Observable`对象更为自然，因为文件系统中的文件可以创建和删除多次。在一个文件浏览器或FTP服务器等应用中，我们希望接收所有此类事件。
- en: 'Later in the program, we might want to unsubscribe from the events in the `Observable`
    object. We will now see how to use the `Subscription` object to achieve this.
    We first import the contents of the **Apache Commons IO file monitoring** package,
    as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序稍后部分，我们可能想要从`Observable`对象的事件中取消订阅。现在我们将看到如何使用`Subscription`对象来实现这一点。我们首先导入**Apache
    Commons IO文件监控**包的内容，如下所示：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We define the `modified` method, which returns an `Observable` object with filenames
    of the modified files in the specified directory. The `Observable.create` method
    bridges the gap between the Commons IO callback-based API and Rx. When the `subscribe`
    method is called, we create a `FileAlterationMonitor` object, which uses a separate
    thread to scan the filesystem and emit filesystem events every 1000 milliseconds,
    a `FileAlterationObserver` object, which specifies a directory to monitor; and
    a `FileAlterationListener` object, which reacts to file events by calling the
    `onNext` method on the Rx `Observer` object. We then call the `start` method on
    the `fileMonitor` object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`modified`方法，该方法返回一个包含指定目录中修改文件名的`Observable`对象。`Observable.create`方法在Commons
    IO回调API和Rx之间架起了一座桥梁。当调用`subscribe`方法时，我们创建一个`FileAlterationMonitor`对象，该对象使用单独的线程以每1000毫秒的频率扫描文件系统并发出文件系统事件；一个`FileAlterationObserver`对象，指定要监视的目录；以及一个`FileAlterationListener`对象，通过在Rx的`Observer`对象上调用`onNext`方法来响应文件事件。然后我们在`fileMonitor`对象上调用`start`方法。
- en: 'Finally, we return a custom `Subscription` object, which calls `stop` on the
    `fileMonitor` object. The `modified` method is shown in the following code snippet:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回一个自定义的`Subscription`对象，该对象在`fileMonitor`对象上调用`stop`方法。`modified`方法在下面的代码片段中展示：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We used the `apply` factory method on the `Subscription` companion object in
    the preceding code snippet. When the `unsubscribe` method is called on the resulting
    `Subscription` object, the specified block of code is run. Importantly, calling
    the `unsubscribe` method, the second time will not run the specified block of
    code again. We say that the `unsubscribe` method is **idempotent**; calling it
    multiple times has the same effect as calling it only once. In our example, the
    `unsubscribe` method calls the `stop` method of the `fileMonitor` object at most
    once. When sub-classing the `Subscription` trait, we need to ensure that the `unsubscribe`
    method is idempotent, and the `Subscription.apply` method is a convenience method
    that ensures idempotence automatically.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了`Subscription`伴生对象的`apply`工厂方法。当在生成的`Subscription`对象上调用`unsubscribe`方法时，将运行指定的代码块。重要的是，第二次调用`unsubscribe`方法时，不会再次运行指定的代码块。我们说`unsubscribe`方法是无操作的；多次调用它的效果与只调用一次相同。在我们的例子中，`unsubscribe`方法最多调用一次`fileMonitor`对象的`stop`方法。当子类化`Subscription`特质时，我们需要确保`unsubscribe`方法是无操作的，而`Subscription.apply`方法是一个方便的方法，可以自动确保无操作。
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Implementations of the `unsubscribe` method in the `Subscription` trait need
    to be idempotent. Use the `Subscription.apply` method to create the `Subscription`
    objects that are idempotent by default.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Subscription`特质中实现`unsubscribe`方法需要是无操作的。使用`Subscription.apply`方法创建默认无操作的`Subscription`对象。
- en: 'We use the `modified` method to track file changes in our project. After we
    call the `subscribe` method on the `Observable` object returned by the `modified`
    method, the main thread suspends for 10 seconds. If we save files in our editor
    during this time, the program will log file modification events to the standard
    output. This is shown in the following program:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`modified`方法来跟踪项目中文件的变化。在调用由`modified`方法返回的`Observable`对象的`subscribe`方法后，主线程暂停10秒。如果我们在这段时间内编辑器中保存文件，程序将把文件修改事件记录到标准输出。这在上面的程序中有所体现：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that, in this example, the `FileAlterationMonitor` object is only created
    if the program invokes the `subscribe` method. The `Observable` instance returned
    by the `modified` method does not emit events unless there exists an `Observer`
    object subscribed to it. In Rx, the `Observable` objects that emit events only
    when subscriptions exist are called **cold observables**. On the other hand, some
    `Observable` objects emit events even when there are no associated subscriptions.
    This is usually the case with `Observable` instances that handle user input, such
    as keyboard or mouse events. `Observable` objects that emit events regardless
    of their subscriptions are called **hot observables**. We now reimplement an `Observable`
    object that tracks file modifications as a hot observable. We first instantiate
    and start the `FileAlterationMonitor` object, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，只有当程序调用`subscribe`方法时，才会创建`FileAlterationMonitor`对象。`modified`方法返回的`Observable`实例在没有订阅的`Observer`对象时不会发出事件。在Rx中，只有在存在订阅时才发出事件的`Observable`对象被称为**冷可观察对象**。另一方面，一些`Observable`对象即使在没有相关订阅的情况下也会发出事件。这通常适用于处理用户输入的`Observable`实例，例如键盘或鼠标事件。不依赖于其订阅就发出事件的`Observable`对象被称为**热可观察对象**。我们现在重新实现一个将文件修改跟踪作为热可观察对象的`Observable`对象。我们首先实例化和启动`FileAlterationMonitor`对象，如下所示：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `Observable` object uses the `fileMonitor` object to specify the directory
    in order to monitor. The downside is that our `Observable` object now consumes
    computational resources even when there are no subscriptions. The advantage of
    using a hot observable is that multiple subscriptions do not need to instantiate
    multiple `FileAlterationMonitor` objects, which are relatively heavyweight. We
    implement the hot `Observable` object in the `hotModified` method, as shown in
    the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable`对象使用`fileMonitor`对象来指定目录以进行监控。缺点是，我们的`Observable`对象现在即使在没有订阅的情况下也会消耗计算资源。使用热可观察对象的优势在于，多个订阅不需要实例化多个相对较重的`FileAlterationMonitor`对象。我们在`hotModified`方法中实现了热`Observable`对象，如下面的代码所示：'
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `hotModified` method creates an `Observable` object with file changes for
    a given directory by registering the specified directory with the `fileMonitor`
    object, and only then calls the `Observable.create` method. When the `subscribe`
    method is called on the resulting `Observable` object, we instantiate and add
    a new `FileAlterationListener` object. In the `Subscription` object, we remove
    the `FileAlterationListener` object in order to avoid receiving additional file
    modification events, but we do not call the `stop` method on the `fileMonitor`
    object until the program terminates.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`hotModified`方法通过将指定的目录注册到`fileMonitor`对象，并仅在此时调用`Observable.create`方法来创建一个包含给定目录文件变化的`Observable`对象。当在结果`Observable`对象上调用`subscribe`方法时，我们实例化并添加一个新的`FileAlterationListener`对象。在`Subscription`对象中，我们移除`FileAlterationListener`对象以避免接收额外的文件修改事件，但我们不会在程序终止之前在`fileMonitor`对象上调用`stop`方法。'
- en: Composing Observable objects
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写可观察对象
- en: Having seen different ways of creating various types of the `Observable` objects,
    subscribing to their events, and using the `Subscription` objects, we turn our
    attention to composing the `Observable` objects into larger programs. From what
    we have seen so far, the advantages of using the `Observable` objects over a callback-based
    API are hardly worth the trouble.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到创建各种类型的`Observable`对象的不同方法、订阅它们的事件以及使用`Subscription`对象之后，我们将注意力转向将`Observable`对象组合成更大的程序。到目前为止，使用`Observable`对象而不是基于回调的API的优势几乎不值得麻烦。
- en: The true power of Rx becomes apparent when we start composing the `Observable`
    objects using various combinators. We can think of an `Observable` object in a
    similar way as we think of Scala sequence collections. In a Scala sequence, represented
    by the `Seq[T]` trait, elements of type `T` are ordered in the memory according
    to their indices. In an `Observable[T]` trait, events of type `T` are ordered
    in time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用各种组合器来组合 `Observable` 对象时，Rx 的真正威力才显现出来。我们可以将 `Observable` 对象视为与 Scala
    序列集合类似的方式。在 Scala 序列中，由 `Seq[T]` 特质表示，类型 `T` 的元素根据它们的索引在内存中按顺序排列。在 `Observable[T]`
    特质中，类型 `T` 的事件按时间顺序排列。
- en: 'Let''s use the `Observable.interval` factory method in order to create an `Observable`
    object, which asynchronously emits a number every 0.5 seconds, and then output
    the first five odd numbers. To do this, we first call `filter` on the `Observable`
    object in order to obtain an intermediate `Observable` object that emits only
    odd numbers. Note that calling the `filter` on an `Observable` object is similar
    to calling `filter` method on a Scala collection. Similarly, we obtain another
    `Observable` object by calling the `map` method in order to transform each odd
    number into a string. We then call `take` to create an `Observable` object `odds`,
    which  contains only the first five events. Finally, we subscribe to `odds` so
    that we can print the events it emits. This is shown in the following program:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `Observable.interval` 工厂方法来创建一个 `Observable` 对象，该对象异步每 0.5 秒发出一个数字，然后输出前五个奇数。为此，我们首先在
    `Observable` 对象上调用 `filter` 以获得一个中间 `Observable` 对象，该对象只发出奇数。请注意，在 `Observable`
    对象上调用 `filter` 与在 Scala 集合上调用 `filter` 方法类似。同样，我们通过调用 `map` 方法获得另一个 `Observable`
    对象，以将每个奇数转换为字符串。然后我们调用 `take` 来创建一个只包含前五个事件的 `Observable` 对象 `odds`。最后，我们订阅 `odds`
    以打印它发出的事件。这如下面的程序所示：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To concisely explain the semantics of different Rx combinators, we often rely
    on marble diagrams. These diagrams graphically represent events in an `Observable`
    object and transformations between different `Observable` objects. The marble
    diagram represents every `Observable` object with a timeline containing its events.
    The first three intermediate `Observable` objects never call the `onCompleted`
    method on its observers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁地解释不同 Rx 组合器的语义，我们通常依赖于宝石图。这些图以图形方式表示 `Observable` 对象中的事件以及不同 `Observable`
    对象之间的转换。宝石图用包含其事件的时序表示每个 `Observable` 对象。前三个中间 `Observable` 对象永远不会对其观察者调用 `onCompleted`
    方法。
- en: 'The `Observable` object `odds` contains at most five events, so it calls `onCompleted`
    after emitting them. We denote a call to the `onCompleted` method with a vertical
    bar in the marble diagram, as shown in the following diagram:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable` 对象 `odds` 包含最多五个事件，因此在发出它们之后调用 `onCompleted`。我们在宝石图中用竖线表示对 `onCompleted`
    方法的调用，如下所示：'
- en: '![Composing Observable objects](img/image_06_002.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![组成可观察对象](img/image_06_002.jpg)'
- en: Note that the preceding diagram is a high-level illustration of the relationships
    between different `Observable` objects, but some of these events can be omitted
    during execution. The particular Rx implementation can detect that the events
    `11` and `12` cannot be observed by the `subscribe` invocation, so these events
    are not emitted to save computational resources.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的图是不同 `Observable` 对象之间关系的概述，但在执行过程中可以省略其中的一些事件。特定的 Rx 实现可以检测到事件 `11` 和
    `12` 无法通过 `subscribe` 调用观察到，因此这些事件不会发出以节省计算资源。
- en: 'As an expert on sequential programming in Scala, you probably noticed that
    we can rewrite the previous program more concisely using the for-comprehensions.
    For example, we can output the first five even natural numbers with the following
    for-comprehension:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Scala 顺序编程的专家，你可能已经注意到我们可以使用 for-comprehensions 更简洁地重写前面的程序。例如，我们可以使用以下 for-comprehension
    输出前五个偶数自然数：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Before moving on to more complex for-comprehensions, we will study a special
    kind of `Observable` object whose events are other `Observable` objects.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续学习更复杂的 for-comprehensions 之前，我们将研究一种特殊的 `Observable` 对象，其事件是其他 `Observable`
    对象。
- en: Nested Observables
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套的可观察对象
- en: A nested observable, also called a higher-order event stream, is an `Observable`
    object that emits events that are themselves `Observable` objects. A higher-order
    function such as the `foreach` statement is called a higher-order function because
    it has a nested function inside its `(T => Unit) => Unit` type. Similarly, higher-order
    event streams earned this fancy name because they have a type `Observable[T]` as
    part of their type `Observable[Observable[T]]`. In this section, we will study
    when the `nestedObservable` objects are useful and how to manipulate them.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的`Observable`，也称为高阶事件流，是一个发出事件，这些事件本身也是`Observable`对象的`Observable`对象。像`foreach`语句这样的高阶函数被称为高阶函数，因为它在其`(T
    => Unit) => Unit`类型中有一个嵌套函数。同样，高阶事件流因其类型`Observable[T]`是其类型`Observable[Observable[T]]`的一部分而获得了这个花哨的名字。在本节中，我们将研究何时使用`nestedObservable`对象以及如何操作它们。
- en: Let's assume that we are writing a book and we want to add a famous quote at
    the beginning of each chapter. Choosing the right quote for a chapter is a hard
    job and we want to automate it. We write a short program that uses `Observable`
    objects to fetch random quotes from the *I Heart Quotes* website every 0.5 seconds
    and prints them to the screen. Once we see a nice quote, we have to quickly copy
    it to our book chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在编写一本书，并想在每一章的开头添加一个著名的引文。为章节选择合适的引文是一项艰巨的工作，我们希望自动化它。我们编写了一个简短的程序，使用`Observable`对象每0.5秒从*I
    Heart Quotes*网站获取随机引文，并将它们打印到屏幕上。一旦我们看到一个不错的引文，我们必须迅速将其复制到我们的书章节中。
- en: 'We will start by defining a `fetchQuote` method that returns a `Future` object
    with the text of the quote. Luckily, the HTTP API of the *I Heart Quotes* website
    returns plain text, so we do not need to parse any JSON or XML. We use the `scala.io.Source`
    object to fetch the contents of the proper URL, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个`fetchQuote`方法，该方法返回一个包含引文文本的`Future`对象。幸运的是，*I Heart Quotes*网站的HTTP
    API返回纯文本，因此我们不需要解析任何JSON或XML。我们使用`scala.io.Source`对象来获取正确URL的内容，如下所示：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Recall that we can convert a `Future` object to an `Observable` object using
    the `from` factory method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们可以使用`from`工厂方法将`Future`对象转换为`Observable`对象：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We now use the `Observable.interval` factory method in order to create an `Observable`
    object that emits a number every 0.5 seconds. For the purposes of our example,
    we take only the first four numbers. Then, we map each of these numbers into an
    `Observable` object that emits a quote, prefixed with the ordinal number of the
    quote. To do this, we call the `fetchQuoteObservable` method and map the quotes
    using a nested `map` call, as shown in the following code snippet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用`Observable.interval`工厂方法来创建一个每0.5秒发出一个数字的`Observable`对象。为了我们的示例，我们只取前四个数字。然后，我们将这些数字映射到发出带有引文序号的引文的`Observable`对象。为此，我们调用`fetchQuoteObservable`方法，并使用嵌套的`map`调用映射引文，如下面的代码片段所示：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that the inner `map` call transforms an `Observable[String]` instance,
    which contains the quote text, to another `Observable[String]` instance, which
    contains the quote prefixed with a number. The outer `map` call transforms the
    `Observable[Long]` object, which contains the first four numbers, to an `Observable[Observable[String]]`
    instance, which contains `Observable` objects emitting separate quotes. The `Observable`
    objects created by the `quotes` method are shown in the following marble diagram.
    Events in the nested `Observable` objects presented last are themselves `Observable`
    objects that contain a single event: the text of the quote returned in the `Future`
    object. Note that we omit the nested `map` call from the diagram to make it more
    readable:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，内部的`map`调用将包含引文文本的`Observable[String]`实例转换为另一个包含带有编号的引文的`Observable[String]`实例。外部的`map`调用将包含前四个数字的`Observable[Long]`对象转换为包含单独引文`Observable`对象的`Observable[Observable[String]]`实例。由`quotes`方法创建的`Observable`对象在以下
    marble 图中显示。嵌套的`Observable`对象中最后呈现的事件本身也是包含单个事件的`Observable`对象：在`Future`对象中返回的引文文本。注意，我们省略了嵌套的`map`调用以使图表更易于阅读：
- en: '![Nested Observables](img/image_06_003.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![嵌套的可观察对象](img/image_06_003.jpg)'
- en: Drawing a marble diagram makes the contents of this `Observable` object more
    understandable, but how do we subscribe to events in an `Observable[Observable[String]]`
    object? Calling the `subscribe` method on quotes requires observers to handle
    the `Observable[String]` objects, and not the `String` events directly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 画一个宝石图可以使这个 `Observable` 对象的内容更容易理解，但我们如何订阅 `Observable[Observable[String]]`
    对象中的事件呢？在 `quotes` 上调用 `subscribe` 方法要求观察者处理 `Observable[String]` 对象，而不是直接处理 `String`
    事件。
- en: Once again, an analogy with Scala sequence collections is useful in order to
    understand how to solve this issue. Whenever we have a nested sequence, say `Seq[Seq[T]]`,
    we can flatten it to a `Seq[T]` collection by calling the `flatten` method. When
    we do this, elements of the nested sequences are simply concatenated together.
    The Rx API provides similar methods that flatten the `Observable` objects, but
    they must deal with the additional complexity associated with the timing of events.
    There are different ways of flattening the `Observable` objects depending on the
    time when their events arrive.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，与 Scala 序列集合的类比有助于理解如何解决这个问题。每当我们有嵌套序列，比如 `Seq[Seq[T]]`，我们都可以通过调用 `flatten`
    方法将其展平到 `Seq[T]` 集合。当我们这样做时，嵌套序列的元素只是简单地连接在一起。Rx API 提供了类似的方法来展平 `Observable`
    对象，但它们必须处理与事件时间相关的额外复杂性。根据事件到达的时间，有不同方式来展平 `Observable` 对象。
- en: 'The first method, called `concat`, concatenates the `nestedObservable` objects
    by ordering all the events in one nested `Observable` object before the events
    in a subsequent `Observable` object. An `Observable` object that appears earlier
    must complete before the events from a subsequent `Observable` object can be emitted.
    The marble diagram for the `concat` operation is shown in the following figure. Although
    the quote **Veni, vidi, vici.**, arrives before the quote **Carpe diem**., the
    quote **Veni, vidi, vici.** is emitted only after the `Observable` object associated
    with the quote **Carpe diem.** completes. The resulting `Observable` object completes
    only after the `Observable` object `quotes` and all the nested `Observable` objects
    complete:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法被称为 `concat`，它通过将一个嵌套 `Observable` 对象中的所有事件按顺序排列在后续 `Observable` 对象的事件之前来连接
    `nestedObservable` 对象。一个较早出现的 `Observable` 对象必须在后续 `Observable` 对象的事件被发射之前完成。`concat`
    操作的宝石图如下所示。虽然引言 **Veni, vidi, vici.** 在引言 **Carpe diem** 之前出现，但引言 **Veni, vidi,
    vici.** 仅在关联引言 **Carpe diem.** 的 `Observable` 对象完成后才被发射。结果 `Observable` 对象仅在 `quotes`
    和所有嵌套 `Observable` 对象完成后才完成：
- en: '![Nested Observables](img/image_06_004.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![嵌套观察者](img/image_06_004.jpg)'
- en: The second method is called `flatten`, analogously to the similar method in
    the Scala collections API. This method emits events from the nested `Observable`
    objects in the order in which they arrive in time, regardless of when the respective
    nested `Observable` object started. An `Observable` object that appears earlier
    is not required to complete before events from a subsequent `Observable` object
    are emitted.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法被称为 `flatten`，类似于 Scala 集合 API 中的类似方法。该方法按事件到达的时间顺序发射嵌套 `Observable` 对象的事件，而不管相应的嵌套
    `Observable` 对象何时开始。较早出现的 `Observable` 对象不需要在后续 `Observable` 对象的事件被发射之前完成。
- en: This is illustrated in the following marble diagram. A quote is emitted to the
    resulting `Observable` object as soon as it appears on any of the nested `Observable`
    objects. Once `quotes` and all the nested `Observable` objects complete, the resulting
    `Observable` object completes as well.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下面的宝石图中得到了说明。一旦引言出现在任何嵌套 `Observable` 对象上，就会将其发射到结果 `Observable` 对象中。一旦 `quotes`
    和所有嵌套 `Observable` 对象完成，结果 `Observable` 对象也会完成。
- en: '![Nested Observables](img/image_06_005.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![嵌套观察者](img/image_06_005.jpg)'
- en: 'To test the difference between the `concat` and `flatten` methods, we subscribe
    to events in `quotes` using each of these two methods. If our network is unreliable
    or has particularly nondeterministic latency, the order in which the second `subscribe`
    call prints the `quotes` object can be mangled. We can reduce the interval between
    queries from 0.5 to 0.01 seconds to witness this effect. The ordinal numbers preceding
    each quote become unordered when using the `flatten` method. This is illustrated
    in the following program:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 `concat` 和 `flatten` 方法之间的差异，我们使用这两种方法中的每一种订阅 `quotes` 中的事件。如果我们的网络不可靠或具有特别非确定性的延迟，第二个
    `subscribe` 调打印 `quotes` 对象的顺序可能会混乱。我们可以将查询间隔从 0.5 秒减少到 0.01 秒来观察这种效果。使用 `flatten`
    方法时，每个引言前的序号变得无序。这在下述程序中得到了说明：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How do we choose between the `concat` and `flatten` methods? The `concat` method
    has the advantage that it maintains the relative order between events coming from
    different `Observable` objects. If we had been fetching and printing quotes in
    a lexicographic order, then the `concat` method would be the correct way to flatten
    the nested `Observable` objects.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在 `concat` 和 `flatten` 方法之间做出选择？`concat` 方法的优势在于它保持了来自不同 `Observable` 对象的事件之间的相对顺序。如果我们按字典顺序获取和打印引文，那么
    `concat` 方法将是展平嵌套 `Observable` 对象的正确方式。
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Use `concat` to flatten nested `Observable` objects whenever the order of events
    between different nested `Observable` objects needs to be maintained.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要保持不同嵌套 `Observable` 对象之间事件顺序时，请使用 `concat` 方法来展平嵌套的 `Observable` 对象。
- en: The `concat` method does not subscribe to subsequent `Observable` objects before
    the current `Observable` object completes. If one of the nested `Observable` objects
    takes a long time to complete or does not complete at all, the events from the
    remaining `Observable` objects are postponed or never emitted. The `flatten` method
    subscribes to a nested `Observable` object as soon as the nested `Observable`
    object is emitted, and emits events as soon as they arrive.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat` 方法在当前 `Observable` 对象完成之前不会订阅后续的 `Observable` 对象。如果嵌套的 `Observable`
    对象中有一个需要很长时间才能完成或根本不会完成，剩余的 `Observable` 对象的事件将被推迟或永远不会发出。`flatten` 方法在嵌套 `Observable`
    对象发出时立即订阅它，并在事件到达时立即发出事件。'
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If at least one of the nested `Observable` objects has an unbounded number of
    events or never completes, use the `flatten` method instead of the `concat` method.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果至少有一个嵌套的 `Observable` 对象有无限数量的事件或永远不会完成，请使用 `flatten` 方法而不是 `concat` 方法。
- en: 'We can also traverse events from multiple `Observable` objects in a `for` comprehension.
    The `Observable` objects come with the `flatMap` method, and this allows you to
    use them in `for` comprehensions. Calling the `flatMap` method on an `Observable`
    object is equivalent to mapping each of its events into a nested `Observable`
    object, and then calling the `flatten` method. Thus, we can rewrite the `quotes.flatten`
    method as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在 `for` 理解中遍历多个 `Observable` 对象的事件。`Observable` 对象自带 `flatMap` 方法，这允许你在
    `for` 理解中使用它们。在 `Observable` 对象上调用 `flatMap` 方法相当于将其每个事件映射到一个嵌套的 `Observable`
    对象中，然后调用 `flatten` 方法。因此，我们可以将 `quotes.flatten` 方法重写如下：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Having already mastered `for` comprehensions on Scala collections and `for`
    comprehensions on futures, this pattern of `flatMap` and `map` calls immediately
    rings a bell, and we recognize the previous expression as the following `for`
    comprehension:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 已经熟练掌握了 Scala 集合上的 `for` 理解和 futures 上的 `for` 理解，这种 `flatMap` 和 `map` 调用模式立刻让人想起，我们认出前面的表达式是以下
    `for` 理解的形式：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is much more concise and understandable, and almost feels like we're back
    with collections land. Still, we need to be careful, because for-comprehensions
    on `Observable` objects do not maintain the relative order of the events in the
    way that the for-comprehensions on collections do. In the preceding example, as
    soon as we can pair a `n` number with some quote `txt`, the `s"$n) $txt"` event
    is emitted, irrespective of the events associated with the preceding `n` number.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这要简洁得多，也更容易理解，几乎感觉像是回到了集合的世界。然而，我们仍需小心，因为 `Observable` 对象上的 `for` 理解并不像集合上的
    `for` 理解那样保持事件的相对顺序。在前面的例子中，一旦我们可以将一个 `n` 数字与某个引文 `txt` 配对，就会发出 `s"$n) $txt"`
    事件，而不考虑与前面的 `n` 数字相关的事件。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Calling the `flatMap` method or using `Observable` objects in `for` comprehensions
    emits events in the order in which they arrive, and it does not maintain ordering
    between events from different `Observable` objects. Invoking the `flatMap` method
    is semantically equivalent to calling `map` followed by the `flatten` call.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for` 理解中调用 `flatMap` 方法或使用 `Observable` 对象会按照事件到达的顺序发出事件，并且不会保持来自不同 `Observable`
    对象的事件之间的顺序。调用 `flatMap` 方法在语义上等同于调用 `map` 后跟 `flatten` 调用。
- en: An attentive reader will notice that we did not consider the case where one
    of the nested `Observable` objects terminates by calling the `onError` method.
    When this happens, both `concat` and `flatten` call the `onError` method with
    the same exception. Similarly, `map` and `filter` fail the resulting `Observable`
    object if the input `Observable` object produces an exception, so it is unclear
    how to compose failed `Observable` objects. This is the focus of the next section.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个细心的读者会注意到我们没有考虑其中一个嵌套的 `Observable` 对象通过调用 `onError` 方法终止的情况。当这种情况发生时，`concat`
    和 `flatten` 都会使用相同的异常调用 `onError` 方法。同样，如果输入 `Observable` 对象产生异常，`map` 和 `filter`
    会使结果 `Observable` 对象失败，因此不清楚如何组合失败的 `Observable` 对象。这是下一节的重点。
- en: Failure handling in Observables
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Observable` 的错误处理'
- en: If you ran the previous examples yourself, you might have noticed that some
    of the quotes are long and tedious to read. We don't want to put a long quote
    at the beginning of the chapter. If we did that, our readers might lose interest.
    The best quotes are short and straight to the point.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你亲自运行了前面的示例，你可能已经注意到其中一些引用很长，读起来很枯燥。我们不希望在章节的开头放置一个很长的引用。如果我们那样做，我们的读者可能会失去兴趣。最好的引用是简短且直接了当的。
- en: 'Our next goal will be to replace quotes longer than 100 characters with a string
    `Retrying...` and print the first quote shorter than 100 characters. This time,
    we define an `Observable` object called `randomQuote`, which emits a random quote
    every time we subscribe to it. We use the `Observable.create` method in order
    to obtain a random quote as before and emit the quote to the observer. We then
    return an empty `Subscription` object. This is shown in the following code snippet:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个目标将是将超过100个字符的引用替换为字符串 `Retrying...` 并打印第一个小于100个字符的引用。这次，我们定义了一个名为 `randomQuote`
    的 `Observable` 对象，每次我们订阅它时都会发出一个随机引用。我们使用 `Observable.create` 方法来获取一个随机引用，就像之前一样，并将引用发送给观察者。然后我们返回一个空的
    `Subscription` 对象。这在上面的代码片段中显示：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There is a subtle difference between the `Observable` object returned by the
    `randomQuote` method and the one returned by the `fetchQuoteObservable` method,
    defined earlier. The `fetchQuoteObservable` method creates a `Future` object in
    order to obtain a quote and emits the quote in that `Future` object to every observer.
    By contrast, the `randomQuote` method fetches a new quote every time the `subscribe`
    method is called. In the previously introduced terminology, the `randomQuote`
    method creates cold `Observable` objects, which emit events only when we subscribe
    to them, whereas the `fetchQuoteObservable` method creates hot `Observable` objects,
    which emit the same quote to all their observers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `randomQuote` 方法返回的 `Observable` 对象和之前定义的 `fetchQuoteObservable` 方法返回的 `Observable`
    对象之间存在一个细微的差别。`fetchQuoteObservable` 方法创建一个 `Future` 对象来获取一个引用，并将引用在该 `Future`
    对象中发送给每个观察者。相比之下，`randomQuote` 方法每次调用 `subscribe` 方法时都会获取一个新的引用。在之前引入的术语中，`randomQuote`
    方法创建冷 `Observable` 对象，只有在订阅时才会发出事件，而 `fetchQuoteObservable` 方法创建热 `Observable`
    对象，将相同的引用发送给所有观察者。
- en: To re-subscribe to a failed `Observable` object, we can use the `retry` combinator.
    The `retry` combinator takes an input `Observable`, and returns another `Observable`
    object that emits events from the input `Observable` object until it either completes
    or fails. If the input `Observable` object fails, the `retry` combinator subscribes
    to the input `Observable` object again.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新订阅一个失败的 `Observable` 对象，我们可以使用 `retry` 组合器。`retry` 组合器接收一个输入 `Observable`，并返回另一个
    `Observable` 对象，该对象会从输入 `Observable` 对象中发出事件，直到它完成或失败。如果输入 `Observable` 对象失败，`retry`
    组合器会再次订阅该输入 `Observable` 对象。
- en: 'We now use the `retry` combinator with the `randomQuote` method to fetch quotes
    until we obtain a quote shorter than 100 characters. We first transform the long
    quotes from the `randomQuote` method into failed observables, which enables `retry`
    to subscribe again to obtain another quote. To do this, we define a new `Observable`
    object called `errorMessage`, which emits a string `"Retrying..."` and then fails.
    We then traverse the `text` quote from `randomQuote` in a `for` comprehension.
    If the `text` quote is shorter than 100 characters, we traverse an `Observable`
    object that emits text. Otherwise, we traverse the `errorMessage` object to output
    `"Retrying..."` instead of `text`. This `for` comprehension defines an `Observable`
    object `quoteMessage`, which either emits a short quote, or emits `"Retrying..."`
    and fails. The marble diagram of the resulting `Observable` object, called `quoteMessage`,
    is shown for these two cases, in which the exception in the `Observable` object
    is shown with a cross symbol:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用`retry`组合器与`randomQuote`方法一起使用，以获取一个小于100个字符的引语。我们首先将`randomQuote`方法中的长引语转换为失败的`Observable`对象，这样`retry`就可以再次订阅以获取另一个引语。为此，我们定义了一个新的`Observable`对象，称为`errorMessage`，它发出一个字符串`"Retrying..."`然后失败。然后我们使用`for`推导式遍历`randomQuote`中的`text`引语。如果`text`引语短于100个字符，我们遍历一个发出文本的`Observable`对象。否则，我们遍历`errorMessage`对象以输出`"Retrying..."`而不是`text`。这个`for`推导式定义了一个`Observable`对象`quoteMessage`，它要么发出一个短引语，要么发出`"Retrying..."`然后失败。称为`quoteMessage`的最终`Observable`对象的宝石图显示了这两种情况，其中`Observable`对象中的异常用交叉符号表示：
- en: '![Failure handling in Observables](img/image_06_006.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![Observables中的失败处理](img/image_06_006.jpg)'
- en: 'Finally, we call the `retry` method on the `quoteMessage` object and subscribe
    to it. We specify that we want to retry up to five times, as omitting the argument
    would retry forever. We implement the `Observable` object `quoteMessage` in the
    following program:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`quoteMessage`对象上调用`retry`方法并订阅它。我们指定我们想要重试最多五次，因为省略参数将无限重试。我们在以下程序中实现了`Observable`对象`quoteMessage`：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run this program several times. You will notice that a short quote is either
    printed right away, or after a few retries, depending on some random distribution
    of the quotes. You may be wondering how many quotes are on average longer than
    100 characters. It turns out that it is easy to do this statistic in Rx. We introduce
    two new combinators. The first one is called `repeat`, and it is very similar
    to `retry`. Instead of re-subscribing to an `Observable` object when it fails,
    it re-subscribes when an `Observable` object completes. The second combinator
    is called `scan` and it is similar to the `scanLeft` operator on collections.
    Given an input `Observable` object and a starting value for the accumulation,
    it emits the value of the accumulation by applying the specified binary operator
    to the accumulation and the event, updating the accumulation as the events arrive.
    The usage of the `repeat` and `scan` combinators is illustrated in the following
    program:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序几次。你会注意到，短引语要么立即打印出来，要么在几次重试之后，这取决于引语的随机分布。你可能想知道平均有多少引语比100个字符长。实际上，在Rx中做这个统计很容易。我们引入了两个新的组合器。第一个叫做`repeat`，它与`retry`非常相似。当`Observable`对象失败时，它不是重新订阅`Observable`对象，而是在`Observable`对象完成时重新订阅。第二个组合器叫做`scan`，它与集合上的`scanLeft`操作符类似。给定一个输入`Observable`对象和一个累加的起始值，它通过将指定的二元操作符应用于累加和事件来发出累加的值，随着事件的到达更新累加。`repeat`和`scan`组合器的用法在以下程序中得到了说明：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding example, we use the `Observable` object `quoteMessage` defined
    earlier in order to obtain a short quote or a message `"Retrying..."` followed
    by an exception. We retry quotes that have failed because of being too long, and
    repeat whenever a quote is short enough. We take 100 quotes in total, and use
    the `scan` operator to count the short quotes. When we ran this program, it turned
    out that 57 out of 100 quotes are too long for our book.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用之前定义的`Observable`对象`quoteMessage`来获取一个简短的引语或消息`"Retrying..."`后跟一个异常。我们重试因过长而失败的引语，并在引语足够短时重复。我们总共取了100个引语，并使用`scan`操作符来计数短引语。当我们运行这个程序时，结果显示100个引语中有57个过长，不适合我们的书籍。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `retry` method is used in order to repeat events from failed `Observable`
    objects. Similarly, the `repeat` method is used in order to repeat events from
    completed `Observable` objects.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`retry`方法用于重复失败的`Observable`对象的事件。同样，`repeat`方法用于重复完成的`Observable`对象的事件。'
- en: 'In the examples shown so far, we use the same `Observable` object to re-subscribe
    and emit additional events if that `Observable` object fails. In some cases, we
    want to emit specific events when we encounter an exception, or fall back to a
    different `Observable` object. Recall that this is what we did with `Future` objects
    previously. The Rx methods that replace an exception with an event, or multiple
    events from another `Observable` object, are called `onErrorReturn` and `onErrorResumeNext`,
    respectively. In the following program, we first replace the exception from `status`
    with a string `"exception occurred."`. We then replace the exception with strings
    from another `Observable` object:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在迄今为止显示的示例中，我们使用相同的`Observable`对象进行重新订阅，并在该`Observable`对象失败时发出额外的事件。在某些情况下，我们希望在遇到异常或回退到不同的`Observable`对象时发出特定的事件。回想一下，这是我们之前与`Future`对象所做的那样。用事件替换异常或从另一个`Observable`对象获取多个事件的Rx方法分别称为`onErrorReturn`和`onErrorResumeNext`。在下面的程序中，我们首先将`status`中的异常替换为字符串`"exception
    occurred."`。然后，我们将异常替换为另一个`Observable`对象中的字符串：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Having seen various ways to compose `Observable` objects, we turn to the concurrency
    features of Rx. So far, we did not pay close attention to the thread on which
    an `Observable` object emits events. In the next section, we will study how to
    transfer events between `Observable` objects on different threads, and learn when
    this can be useful.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了多种组合`Observable`对象的方法之后，我们转向Rx的并发特性。到目前为止，我们没有密切关注`Observable`对象发出事件的线程。在下一节中，我们将研究如何在不同的线程上的`Observable`对象之间传递事件，并了解何时这会有用。
- en: Rx schedulers
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rx调度器
- en: At the beginning of this chapter, we observed that different `Observable` objects
    emit events on different threads. A synchronous `Observable` object emits on the
    caller thread when the `subscribe` method gets invoked. The `Observable.timer`
    object emits events asynchronously on threads internally used by Rx. Similarly,
    events in `Observable` objects created from `Future` objects are emitted on `ExecutionContext`
    threads. What if we want to use an existing `Observable` object to create another
    `Observable` object bound to a specific thread?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们观察到不同的`Observable`对象在不同的线程上发出事件。一个同步的`Observable`对象在调用`subscribe`方法时在调用者线程上发出。`Observable.timer`对象在Rx内部使用的线程上异步发出事件。同样，从`Future`对象创建的`Observable`对象中的事件是在`ExecutionContext`线程上发出的。如果我们想使用现有的`Observable`对象创建另一个绑定到特定线程的`Observable`对象，该怎么办呢？
- en: 'To encapsulate the choice of the thread on which an `Observable` object should
    emit events, Rx defines a special class called `Scheduler`. A `Scheduler` class
    is similar to the `Executor` and `ExecutionContext` interfaces we saw in [Chapter
    3](ch03.html "Chapter 3. Traditional Building Blocks of Concurrency"), *Traditional
    Building Blocks of Concurrency*. The `Observable` objects come with a combinator
    called `observeOn`. This combinator returns a new `Observable` object that emits
    events using the specified `Scheduler` class. In the following program, we instantiate
    a `Scheduler` object called `ComputationScheduler`, which emits events using an
    internal thread pool. We then emit events with and without calling the `observeOn`
    combinator:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了封装一个`Observable`对象应该在哪里发出事件的线程选择，Rx定义了一个特殊类，称为`Scheduler`。`Scheduler`类类似于我们在[第3章](ch03.html
    "第3章。并发传统的构建块")中看到的`Executor`和`ExecutionContext`接口，*并发的传统构建块*。`Observable`对象附带一个组合器`observeOn`。这个组合器返回一个新的`Observable`对象，该对象使用指定的`Scheduler`类发出事件。在下面的程序中，我们实例化了一个名为`ComputationScheduler`的`Scheduler`对象，该对象使用内部线程池发出事件。然后，我们使用和未调用`observeOn`组合器的方式发出事件：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'From the output, we can see that the second `subscribe` call uses a thread
    pool:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到第二次`subscribe`调用使用了一个线程池：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `ComputationScheduler` object maintains a pool of threads intended for computational
    tasks. If processing the events blocks or waits for I/O operations, we must use
    the `IOScheduler` object, which automatically spawns new threads when necessary.
    Exceptionally, if processing each event is a very coarse-grained task, we can
    use the `NewThreadScheduler` object, which spawns a new thread for each event.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComputationScheduler`对象维护一个用于计算任务的线程池。如果处理事件阻塞或等待I/O操作，我们必须使用`IOScheduler`对象，该对象在必要时自动创建新线程。异常情况下，如果处理每个事件是一个非常粗粒度的任务，我们可以使用`NewThreadScheduler`对象，该对象为每个事件创建一个新线程。'
- en: Using custom schedulers for UI applications
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在UI应用程序中使用自定义调度器
- en: Built-in Rx schedulers are useful for most tasks, but in some cases we need
    more control. Most UI toolkits only allow you to read and modify UI elements from
    a special thread. This thread is called the **event-dispatching** thread. This
    approach simplifies the design and the implementation of a UI toolkit, and protects
    clients from subtle concurrency errors. Since the UI usually does not usually
    represent a computational bottleneck, this approach has been widely adopted; the
    Swing toolkit uses an `EventDispatchThread` object in order to propagate events.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的Rx调度器对于大多数任务很有用，但在某些情况下我们需要更多的控制。大多数UI工具包只允许你从特殊线程读取和修改UI元素。这个线程被称为**事件分发**线程。这种方法简化了UI工具包的设计和实现，并保护客户端免受微妙的并发错误的影响。由于UI通常不通常代表计算瓶颈，这种方法已被广泛采用；Swing工具包使用`EventDispatchThread`对象来传播事件。
- en: 'The `Observable` objects are particularly useful when applied to UI applications;
    a user interface is all about events. In subsequent examples, we will use the
    Scala Swing library to illustrate the usefulness of Rx in UI code. We start by
    adding the following dependency to our project:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable`对象在应用于UI应用程序时特别有用；用户界面全部关于事件。在随后的示例中，我们将使用Scala Swing库来说明Rx在UI代码中的有用性。我们首先将以下依赖项添加到我们的项目中：'
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We will start by creating a simple Swing application with a single button.
    Clicking on this button will print a message to the standard output. This application
    illustrates how to convert Swing events into an `Observable` object. We will start
    by importing the relevant Scala Swing packages as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个带有单个按钮的简单Swing应用程序。点击此按钮将在标准输出中打印一条消息。此应用程序说明了如何将Swing事件转换为`Observable`对象。我们将首先按照以下方式导入相关的Scala
    Swing包：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To create a Swing application, we need to extend the `SimpleSwingApplication`
    class. This class has a single abstract method, `top`, which needs to return a
    `Frame` object. The Swing's abstract `Frame` class represents the application
    window. We return a new `MainFrame` object, which is a subclass of the `Frame`
    object. In the `MainFrame` constructor, we set the window title bar text to `Swing
    Observables`, and instantiate a new `Button` object with the `Click` text. We
    then set the contents of the `MainFrame` constructor to that button.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个Swing应用程序，我们需要扩展`SimpleSwingApplication`类。这个类有一个抽象方法`top`，它需要返回一个`Frame`对象。Swing的抽象`Frame`类代表应用程序窗口。我们返回一个新的`MainFrame`对象，它是`Frame`对象的一个子类。在`MainFrame`构造函数中，我们将窗口标题栏文本设置为`Swing
    Observables`，并实例化一个新的带有`Click`文本的`Button`对象。然后我们将`MainFrame`构造函数的内容设置为该按钮。
- en: 'So much for the UI elements and their layout; we now want to add some logic
    to this simple application. Traditionally, we would make a Swing application interactive
    by installing callbacks to various UI elements. Using Rx, we instead convert callbacks
    into event streams; we define an `Observable` object called `buttonClicks` that
    emits an event every time the button element is clicked on. We use the `Observable.create`
    method in order to register a `ButtonClicked` callback that calls the `onNext`
    method on the observer. To log clicks to the standard output, we subscribe to
    `buttonClicks`. The complete Swing application is shown in the following code
    snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 关于UI元素及其布局已经讲得够多了；我们现在想给这个简单应用程序添加一些逻辑。传统上，我们会通过安装到各种UI元素的回调来使Swing应用程序交互式。使用Rx，我们相反将回调转换为事件流；我们定义一个名为`buttonClicks`的`Observable`对象，每次按钮元素被点击时都会发出一个事件。我们使用`Observable.create`方法来注册一个`ButtonClicked`回调，该回调在观察者上调用`onNext`方法。为了将点击记录到标准输出，我们订阅`buttonClicks`。完整的Swing应用程序如下代码片段所示：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Running this application opens the window, shown in the following screenshot.
    Clicking on the **Click** button prints a string to the standard output. We can
    see that the events are emitted on the thread called `AWT-EventQueue-0`, which
    is the event-dispatching thread in Swing:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此应用程序将打开以下截图所示的窗口。点击**Click**按钮将在标准输出中打印一个字符串。我们可以看到事件是在名为`AWT-EventQueue-0`的线程上发出的，这是Swing中的事件分发线程：
- en: '![Using custom schedulers for UI applications](img/image_06_007.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![使用自定义调度器进行UI应用程序](img/image_06_007.jpg)'
- en: One downside of single-threaded UI toolkits is that long-running computations
    on the event-dispatching thread block the UI and harm the user experience. If
    we issue a blocking HTTP request each time the user clicks on a button, we will witness
    a noticeable lag after each click. Luckily, this is easy to address by executing
    long-running computations asynchronously.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, we are not content with just starting an asynchronous computation.
    Once the asynchronous computation produces a result, we would like to display
    it in the application. Recall that we are not allowed to do this directly from
    the computation thread; we need to return the control back to event-dispatching
    thread. Swing defines the `invokeLater` method, which schedules tasks on Swing''s
    event-dispatching thread. On the other hand, Rx has a `Schedulers.from` built-in
    method that converts an `Executor` object into a `Scheduler` object. To bridge
    the gap between Swing''s `invokeLater` method and Rx schedulers, we implement
    a custom `Executor` object that wraps a call to `invokeLater`, and we pass this
    `Executor` object to `Schedulers.from`. The custom `swingScheduler` object is
    implemented as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can use the newly-defined `swingScheduler` object in order to send events
    back to Swing. To illustrate this, let''s implement a small web browser application.
    Our browser consists of a `urlfield` address bar and the **Feeling lucky** button.
    Typing into the address bar displays suggestions for the URL, and clicking on
    the button displays the raw HTML of the webpage. The browser is not a trivial
    application, so we separate the implementation of the UI layout from the UI logic.
    We start by defining the `BrowserFrame` class, which describes the layout of the
    UI elements:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Scala Swing was implemented long before the introduction of Rx, so it does
    not come with event streams. We use Scala''s extension method pattern in order
    to enrich the existing UI element classes with `Observable` objects, and add implicit
    classes, `ButtonOps` and `TextFieldOps`, with methods, `clicks` and `texts`, respectively.
    The `clicks` method returns an `Observable` object that emits an event each time
    the corresponding button is clicked on. Similarly, the `texts` method emits an
    event each time the content of a text field changes:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We now have the necessary utilities to concisely define the logic of our web
    browser. We implement the browser logic in a trait called `BrowserLogic`, annotated
    with a self-type `BrowserFrame` object. The type `self` allows you to mix the
    `BrowserLogic` trait only into classes that extend the `BrowserFrame` object.
    This makes sense; the browser logic needs to know about UI events to react to
    them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: There are two main functionalities supported by the web browser. First, the
    browser needs to suggest possible URLs while the user types into the address bar.
    To facilitate this, we define a helper method, `suggestRequest`, which takes a
    term from the address bar and returns an `Observable` object with the possible
    completions. This `Observable` object uses Google's query suggestion service to
    get a list of possible URLs. To cope with network errors, the `Observable` object
    will time-out after 0.5 seconds if there is no reply from the server, and emit
    an error message.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Second, our browser needs to display the contents of the specified URL, when
    we click on the **Feeling lucky** button. To achieve this, we define another helper
    method named `pageRequest`, which returns an `Observable` object with the raw
    HTML of the web page. This `Observable` object times-out after four seconds if
    the page is not loaded by that time.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these helper methods and the UI element `Observable` objects, we can
    encode the browser logic more easily. Each `urlField` text modification event
    maps into a nested `Observable` object with the suggestion. The call to `concat`
    then flattens the nested `Observable` object. The suggestion events transfer back
    to the Swing event-dispatching thread using the `observeOn` combinator. We subscribe
    to the events on the Swing event-dispatching thread in order to modify the contents
    of the `pagefield` text area. We subscribe to `button.clicks` in a similar way:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After defining both the UI layout and the UI logic, we only need to instantiate
    the browser frame in a Swing application:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Running the application opens the browser frame, and we can start surfing in
    our very own Rx-based web browser. The guys at Mozilla and Google will surely
    be impressed when they see the following screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![Using custom schedulers for UI applications](img/image_06_008.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: Although our web browser is very simple, we managed to separate its functionality
    into the UI layout and browser logic layers. The UI layout layer defines `Observable`
    objects such as `urlfield.texts` and `button.clicks` as part of its interface.
    The browser logic layer relies on the functionality from the UI layout layer;
    for example, we could not describe the updates to the `pagefield` UI element without
    referencing the `Observable` object `button.clicks`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: We say that the browser logic depends on the UI layout, but not vice versa.
    For a UI application, this can be acceptable, but other applications require a
    more loosely coupled design, in which different layers do not refer to each other
    directly.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Subjects and top-down reactive programming
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composing `Observable` objects is similar to composing functions, collections,
    or futures. Complex `Observable` objects are formed from simpler parts using functional
    composition. This is a very Scala-idiomatic pattern, and it results in concise
    and understandable programs.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: A not-so-obvious downside of functional composition is that it favors the **bottom-up
    programming style**. An `Observable` object cannot be created without a reference
    to another `Observable` object that it depends on. For instance, we cannot create
    an `Observable` object using the `map` combinator without having an input `Observable`
    object to call the `map` method on. In a bottom-up programming style, we build
    complex programs by implementing the simplest parts first, and then gradually
    working our way up. By contrast, in a **top-down programming style**, we first
    define the complex parts of the system, and then gradually divide them into successively
    smaller pieces. The top-down programming style allows first declaring an `Observable`
    object, and defining its dependencies later.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: To allow building systems in a top-down programming style, Rx defines an abstraction
    called a subject, represented by the `Subject` trait. A `Subject` trait is simultaneously
    an `Observable` object and an `Observer` object. As an `Observable` object, a
    `Subject` trait can emit events to its subscribers. As an `Observer` object, a
    `Subject` trait can subscribe to different input `Observable` objects and forward
    their events to its own subscribers.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Subject` trait is an `Observable` object whose inputs can change after its
    creation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how to use a Subject trait in practice, let''s assume that we are building
    our own operating system. Having witnessed how practical the Rx event streams
    are, we decide to use them throughout our operating system, which we name **RxOS**.
    To make RxOS pluggable, its functionality is divided into separate components
    called kernel modules. Each kernel module might define a certain number of `Observable`
    objects. For example, a `TimeModule` module exposes an `Observable` object named
    `systemClock`, which outputs a string with the system uptime every second:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'System output is an essential part of every operating system. We want RxOS
    to output important system events such as the system uptime. We already know how
    to do this by calling `subscribe` on the `systemClock` object from the `TimeModule`
    module, as shown in the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s say that another team now independently develops another kernel module
    named `FileSystemModule`, which exposes an `Observable` object called `fileModifications`.
    This `Observable` object emits a filename each time a file is modified:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Our core development team now decides that the `fileModifications` objects
    are important system events and wants to log these events as part of the `messageBus`
    subscription. We now need to redefine the singleton object `RxOS`, as shown in
    the following code snippet:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This patch solves the situation, but what if another kernel module introduces
    another group of important system events? With our current approach, we will have
    to recompile the RxOS kernel each time some third-party developer implements a
    kernel module. Even worse, the `RxOS` object definition references kernel modules,
    and thus, depends on them. Developers who want to build custom, reduced versions
    of RxOS now need to tweak the kernel source code.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: This is the classic culprit of the bottom-up programming style; we are unable
    to declare the `messageBus` object without declaring its dependencies, and declaring
    them binds us to specific kernel modules.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'We now redefine the `messageBus` object as an Rx subject. We create a new `Subject`
    instance that emits strings, and we then subscribe to it, as shown in the following
    example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'At this point, the `messageBus` object is not subscribed to any `Observable`
    objects and does not emit any events. We can now define the RxOS boot sequence
    separately from the modules and the kernel code. The boot sequence specifies which
    kernel modules to subscribe with the `messageBus` object, and stores their subscriptions
    into the `loadedModules` list:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The boot sequence first subscribes the `messageBus` object to each of the required
    modules. We can do this because the `messageBus` object is an `Observer` object,
    in addition to being an `Observable` object. The `RxOS` then stays up for 10 seconds
    before calling `unsubscribe` on the modules and shutting down. During this time,
    the system clock emits an event to the `messageBus` object every second. Similarly,
    the `messageBus` object outputs the name of the modified file every time a file
    modification occurs, as shown in the following diagram:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![Subjects and top-down reactive programming](img/image_06_009.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: The difference between the two approaches is shown in the preceding figure.
    In the bottom-up approach, we first need to define all the kernel modules and
    then make RxOS depend on them. In the top-down approach, RxOS does not depend
    on the kernel modules. Instead, it is glued together with them by the boot sequence
    module. The RxOS clients no longer need to tweak or recompile the kernel code
    if they want to add a new kernel module. In fact, the new design even allows hot-plugging
    kernel modules into a running RxOS instance, long after the boot sequence is completed.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use `Subject` instances when you need to create an `Observable` object whose
    inputs are not available when the `Observable` object is created.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: In our example, designing a web browser is a lot like ordering a MacBook. After
    specifying the preferred processor type and the hard disk size, the MacBook is
    assembled, and its components cannot be exchanged easily. Analogously, after implementing
    the browser's UI layout, the event streams that describe the interaction between
    UI components are declared only once, and cannot change if the UI components are
    replaced. On the other hand, building an OS is more like building a desktop computer
    from custom components. After putting the motherboard into the case, we can plug
    in components such as the graphics card or the RAID controller independently.
    Similarly, after declaring the `messageBus` subject, we can plug in any number
    of kernel modules at any time during the execution of the program.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Although the `Subject` interface is more flexible than the `Observable` interface,
    you should not always use the `Subject` instances and rely exclusively on the
    top-down programming style. While declaring the dependencies of an `Observable`
    object at its creation point makes the application less flexible, it also makes
    it more declarative and easier to understand. Modern large-scale applications
    usually combine both bottom-up and top-down approaches.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Rx defines several other types of subject. The type `ReplaySubject` is a `Subject`
    implementation that buffers the events it receives as an `Observer` object. When
    another `Observer` object subscribes to a `ReplaySubject` instance, all the events
    previously buffered by the `ReplaySubject` instance are replayed. In the following
    code snippet, we define a `ReplaySubject` instance called `messageLog` in `RxOS`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `messageLog` object subscribes to the `messageBus` object in order to buffer
    all the system messages. If, for example, we now want to dump all the messages
    into a log file, we can subscribe to the `messageLog` object immediately before
    the application ends, as shown in the following example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Rx also defines two other subjects called `BehaviorSubject` and `AsyncSubject`.
    The `BehaviorSubject` class buffers only the most recent event, and the `AsyncSubject`
    class only emits the event immediately preceding `onComplete`. We will not study
    their exact semantics and use case here, but we refer you to the online documentation
    to find out more about them.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First-class event streams are an extremely expressive tool for modelling dynamic,
    event-based systems with time-varying values. Rx `Observable` objects are an event
    stream implementation designed to build scalable, concurrent, event-based applications.
    In this chapter, we saw how to create Rx `Observable` objects and how to subscribe
    to their events. We studied the `Observable` contract and learned how to compose
    complex `Observable` objects from simple ones. We investigated various ways of
    recovering from failures and saw how to use Rx schedulers to transfer events between
    threads. Finally, we learned how to design loosely coupled systems with Rx subjects.
    These powerful tools together allow us to build a plethora of different applications,
    ranging from web browsers, FTP servers, the music and video players to real-time
    games and trading platforms, and even operating systems.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the increasing popularity of reactive programming, a number of frameworks
    similar to Rx have appeared in the recent years: REScala, Akka Streams, and Reactive
    Collections, to name a few. We did not study the semantics of these frameworks
    in this chapter, but leave it to the readers to explore them on their own.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that `Observable` objects are very declarative in nature, making
    the Rx programming model easy to use and understand. Nevertheless, it is sometimes
    useful to model a system imperatively, using explicit state. In the next chapter,
    we will study software transactional memory, which allows accessing shared program
    state without the risk of deadlocks and race conditions, which we learned about
    in [Chapter 2](ch02.html "Chapter 2. Concurrency on the JVM and the Java Memory
    Model"), *Concurrency on the JVM and the Java Memory Model*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following exercises, you will need to implement different `Observable`
    objects. The exercises show different use cases for `Observable` objects, and
    contrast the different ways of creating `Observable` objects. Also, some of the
    exercises introduce new reactive programming abstractions, such as reactive maps
    and reactive priority queues.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Implement a custom `Observable[Thread]` object that emits an event when it detects
    that a thread was started. The implementation is allowed to miss some of the events.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement an `Observable` object that emits an event every 5 seconds and every
    12 seconds, but not if the elapsed time is a multiple of 30 seconds. Use functional
    combinators on `Observable` objects.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `randomQuote` method from this section in order to create an `Observable`
    object with the moving average of the quote lengths. Each time a new quote arrives,
    a new average value should be emitted.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the reactive signal abstraction, represented with the `Signal[T]`
    type. The type `Signal[T]` comes with the method `apply`, used to query the last
    event emitted by this signal, and several combinators with the same semantics
    as the corresponding `Observable` methods:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, add the method `toSignal` to the type `Observable[T]`, which converts
    an `Observable` object to a reactive signal:'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Consider using Rx subjects for this task.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the reactive cell abstraction, represented with the type `RCell[T]`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: A reactive cell is simultaneously a reactive signal from the previous exercise.
    Calling the `:=` method sets a new value to the reactive cell, and emits an event.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the reactive map collection, represented with the `RMap` class:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `update` method behaves like the update on a regular `Map` collection. Calling
    `apply` on a reactive map returns an `Observable` object with all the subsequent
    updates of the specific key.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the reactive priority queue, represented by the `RPriorityQueue`
    class:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The reactive priority queue exposes the `Observable` object `popped`, which
    emits events whenever the smallest element in the priority queue gets removed
    by calling `pop`.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the `copyFile` method, which copies a file specified with the `src`
    parameter to the destination specified with the `dest` parameter. The method returns
    an `Observable[Double]` object, which emits an event with the file transfer progress
    every 100 milliseconds:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The resulting `Observable` object must complete if the file transfer completes
    successfully, or otherwise fail with an exception.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a custom Swing component, called `RxCanvas`, which exposes mouse events
    using `Observable` objects:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Use the `RxCanvas` component to build your own Paint program, in which you can
    drag lines on the canvas using a brush, and save the contents of the canvas to
    an image file. Consider using nested `Observable` objects to implement dragging.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement a method called `scatterGather` on the type `Observable`, which forwards
    every event to one of the worker threads, performs some work on those threads,
    and emits the computed results on a new `Observable` object. The signature of
    this method is as follows, where type `T` is the type of the events in the original
    `Observable`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Implement the `sorted` method on the type `Observable`, which emits incoming
    events in the sorted order. The events can be emitted only after the original
    `Observable` terminates.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
