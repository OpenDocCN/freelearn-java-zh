<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Validating Web Service Requests"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Validating Web Service Requests</h1></div></div></div><p>Up to this point, we have a RESTful Web Service that produces JSON representations and is also capable of storing and updating contacts. Before we actually store or update a contact's information though, we need to ensure that the provided information is valid and consistent.</p><div class="section" title="Adding validation constraints"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec21"/>Adding validation constraints</h1></div></div></div><p>The first<a id="id166" class="indexterm"/> thing we need to do in order to validate contacts is to define what is considered a valid contact. To do so, we will modify the representation class, adding constraints to its members in the form of Hibernate Validator annotations.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec42"/>How to do it…</h2></div></div></div><p>We have the <code class="literal">Contact</code> class, instances of which must have a first name, a last name, and a phone number in order to be considered valid. Moreover, the length of these values must be within specific limits. Let's go through the required steps in order to apply these constraints.</p><p>Modify the <code class="literal">Contact</code> representation class, adding the appropriate annotations to its members (import <code class="literal">org.hibernate.validator.constraints.*</code> first):</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Update the<a id="id167" class="indexterm"/> declaration of the <code class="literal">firstName</code> variable, adding the necessary annotations in order to indicate that this is a required property (it should not be blank), and its length should be between 2 and 255 characters.<div class="informalexample"><pre class="programlisting">@NotBlank @Length(min=2, max=255)
private final String firstName;</pre></div></li><li class="listitem">In a <a id="id168" class="indexterm"/>similar way, apply the same constraints on the <code class="literal">lastName</code> property.<div class="informalexample"><pre class="programlisting">@NotBlank @Length(min=2, max=255)
private final String lastName;</pre></div></li><li class="listitem">The <code class="literal">phone</code> field should not be longer than 30 digits, so modify the values of the relevant annotation accordingly.<div class="informalexample"><pre class="programlisting">@NotBlank @Length(min=2, max=30)
private final String phone;</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec43"/>How it works…</h2></div></div></div><p>The <a id="id169" class="indexterm"/>declaration of validation constraints is annotation-based. This gives us the flexibility of directly adding the validation rules we want to the members of our representation class.</p><p>Hibernate Validator is a part of the <code class="literal">dropwizard-core</code> module, so we do not need to declare any additional dependencies on our <code class="literal">pom.xml</code>.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec44"/>There's more…</h2></div></div></div><p>The recommended way of validating objects is using the standard <span class="strong"><strong>Bean Validation API</strong></span> (<span class="strong"><strong>JSR 303</strong></span>). For our validation needs, we use <span class="strong"><strong>Hibernate Validator</strong></span>, which is a part of the <code class="literal">Dropwizard-core</code> module, and the reference implementation of JSR 303. Using Hibernate Validator, we can declare field constraints such as <code class="literal">@NotBlank</code> and <code class="literal">@Length</code>, or even create and use our own custom constraints that fit our needs (you may refer to Hibernate Validator's <a id="id170" class="indexterm"/>documentation at <a class="ulink" href="http://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#validator-customconstraints">http://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#validator-customconstraints</a>).</p><div class="section" title="List of constraint annotations"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec19"/>List of constraint annotations</h3></div></div></div><p>The complete list of field constraints is available on the Hibernate Validator package navigator<a id="id171" class="indexterm"/> at <a class="ulink" href="http://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#section-builtin-constraints">http://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#section-builtin-constraints</a>.</p></div></div></div></div>
<div class="section" title="Performing validation"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec22"/>Performing validation</h1></div></div></div><p>We've just<a id="id172" class="indexterm"/> defined what a valid annotation is. Now, we must modify the code of our resource class in order to verify that each POST and PUT request contains a valid <code class="literal">Contact</code> object, based on which a contact is created or updated.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec45"/>How to do it…</h2></div></div></div><p>Let's see what needs to be modified in our resource class by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we <a id="id173" class="indexterm"/>need to import some classes that will help us with the validation.<div class="informalexample"><pre class="programlisting">import java.util.Set;
import javax.validation.ConstraintViolation;
import javax.util.ArrayList;
import javax.validation.Validator;
import javax.ws.rs.core.Response.Status;</pre></div></li><li class="listitem">Add a final member, <code class="literal">validator</code>, and update the constructor method in order to initialize it.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>private final ContactDAO contactDao;  private final Validator validator;</strong></span>
  public ContactResource(DBI jdbi, Validator validator) {
<span class="strong"><strong>    contactDao = jdbi.onDemand(ContactDAO.class);    this.validator = validator;</strong></span>
  }</pre></div></li><li class="listitem">In the <code class="literal">App</code> class, modify<a id="id174" class="indexterm"/> the <code class="literal">#run()</code> method so as to pass the environment's <code class="literal">validator</code> as a parameter to <code class="literal">ContactResource</code> during its initialization, along with jDBI.<div class="informalexample"><pre class="programlisting">// … // Add the resource to the environmente.jersey().register(new ContactResource(jdbi, e.getValidator()));// …</pre></div></li><li class="listitem">Update<a id="id175" class="indexterm"/> the <code class="literal">ContactResource#createContact()</code> method and check that the contact information is valid prior to inserting it in the database.<div class="informalexample"><pre class="programlisting">  @POST
  public Response createContact(Contact contact) throws URISyntaxException {
    // Validate the contact's data
    Set&lt;ConstraintViolation&lt;Contact&gt;&gt; violations = validator.validate(contact);
    // Are there any constraint violations?
    if (violations.size() &gt; 0) {
      // Validation errors occurred
      ArrayList&lt;String&gt; validationMessages = new ArrayList&lt;String&gt;();
      for (ConstraintViolation&lt;Contact&gt; violation : violations) {
validationMessages.add(violation.getPropertyPath().toString() +": " + violation.getMessage());
     }
     return Response
          .status(Status.BAD_REQUEST)
          .entity(validationMessages)
          .build();
    }
    else {
      // OK, no validation errors
      // Store the new contact
      int newContactId = contactDao.createContact(contact.getFirstName(),
        contact.getLastName(), contact.getPhone());
      return Response.created(new URI(String.valueOf(newContactId))).build();
    }
  }</pre></div></li><li class="listitem">Similarly,<a id="id176" class="indexterm"/> update<a id="id177" class="indexterm"/> the <code class="literal">ContactResource#updateContact()</code> method.<div class="informalexample"><pre class="programlisting">  @PUT
  @Path("/{id}")
  public Response updateContact(@PathParam("id") int id, Contact contact) {
    // Validate the updated data
    Set&lt;ConstraintViolation&lt;Contact&gt;&gt; violations = validator.validate(contact);
    // Are there any constraint violations?
    if (violations.size() &gt; 0) {
      // Validation errors occurred
      ArrayList&lt;String&gt; validationMessages = new ArrayList&lt;String&gt;();
      for (ConstraintViolation&lt;Contact&gt; violation : violations) {
validationMessages.add(violation.getPropertyPath().toString() +": " + violation.getMessage());
      }
      return Response
            .status(Status.BAD_REQUEST)
            .entity(validationMessages)
            .build();
    }
    else {
      // No errors
      // update the contact with the provided ID
      contactDao.updateContact(id, contact.getFirstName(),
          contact.getLastName(), contact.getPhone());
      return Response.ok(
          new Contact(id, contact.getFirstName(), contact.getLastName(),
          contact.getPhone())).build();
    }
  }</pre></div></li><li class="listitem">Build<a id="id178" class="indexterm"/> and run the application from the command line in order to do some tests with the validation mechanisms we just implemented.</li><li class="listitem">Using <code class="literal">curl</code>, perform an HTTP POST request to <code class="literal">http://localhost:8080/contact/</code>, sending contact information that is going to trigger validation errors, such as <code class="literal">firstName</code> and <code class="literal">lastName</code> with length less than 2 characters, and an empty value for the <code class="literal">phone</code> field in a JSON string such as the following:<div class="informalexample"><pre class="programlisting">{"firstName": "F", "lastName": "L", "phone": ""}.
#&gt; curl -v -X POST -d '{"firstName": "F", "lastName": "L", "phone": ""}' http://localhost:8080/contact/ --header "Content-Type: application/json"</pre></div><div class="mediaobject"><img src="graphics/9530OS_07_01.jpg" alt="How to do it…"/></div></li></ol></div><p>You will see that the response is an <span class="strong"><strong>HTTP/1.1 400 Bad Request</strong></span> error, and the response payload is a JSON array containing the following error messages:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt; HTTP/1.1 400 Bad Request</strong></span>

<span class="strong"><strong>&lt; Date: Tue, 28 Jan 2014 20:16:57 GMT</strong></span>

<span class="strong"><strong>&lt; Content-Type: application/json</strong></span>

<span class="strong"><strong>&lt; Transfer-Encoding: chunked</strong></span>

<span class="strong"><strong>&lt; </strong></span>

<span class="strong"><strong>* Connection #0 to host localhost left intact</strong></span>

<span class="strong"><strong>* Closing connection #0</strong></span>

<span class="strong"><strong>["phone: length must be between 2 and 30","firstName: length must be between 2 and 255","lastName: length must be between 2 and 255","phone: may not be empty"]</strong></span>
</pre></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec46"/>How it works…</h2></div></div></div><p>In <a id="id179" class="indexterm"/>the <code class="literal">ContactResource#createContact()</code> method, which<a id="id180" class="indexterm"/> is mapped to the POST requests to <code class="literal">/contact</code> URI, we used the environment's instance of <code class="literal">javax.validation.Validator</code> to validate the received <code class="literal">contact</code> object.</p><p>The validator's <code class="literal">#validate()</code> method<a id="id181" class="indexterm"/> returns a <code class="literal">Set&lt;ConstraintViolation&lt;Contact&gt;&gt;</code> instance, which contains the validation error that occurred, if any. We check the list's size to determine if there are any violations. If there are, we will iterate through them, extracting the validation message of each error and adding it to<a id="id182" class="indexterm"/> an <code class="literal">ArrayList</code> instance, which we then return as a response along with <span class="strong"><strong>HTTP Status Code 400 – Bad Request</strong></span>.</p><p>Since our resource class produces a JSON output (already declared with the <code class="literal">@Produces</code> annotation<a id="id183" class="indexterm"/> at the class level), the <code class="literal">ArrayList</code> instance will be transformed to a JSON array thanks to Jackson.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec47"/>There's more…</h2></div></div></div><p>As you saw, in order to test and showcase the POST requests to the endpoint we created, we need an HTTP client. Apart from cURL, there are some really good and useful HTTP client tools available (such as Postman for Google Chrome, available at <a class="ulink" href="https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm">https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm</a>) that can help us with this, and we will also create our own in the next chapter.</p><div class="section" title="The @Valid annotation"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec20"/>The @Valid annotation</h3></div></div></div><p>Instead <a id="id184" class="indexterm"/>of using a <code class="literal">validator</code> object to validate the input object, we could have just annotated the <code class="literal">contact</code> object as <code class="literal">@Valid</code> on the <code class="literal">#createContact</code> method<a id="id185" class="indexterm"/>, as seen in the following line of code:</p><div class="informalexample"><pre class="programlisting">public Response createContact(@Valid Contact contact)</pre></div><p>When an object is annotated with <code class="literal">@Valid</code>, the validation is recursively performed on it. This would have the validation triggered as soon as the method was called. In case the <code class="literal">contact</code> object was found invalid, then a default <span class="strong"><strong>HTTP 422 – Unprocessable entity</strong></span> response will be generated automatically. While the <code class="literal">validator</code> object is more powerful and customizable, the usage of the <code class="literal">@Valid</code> annotation is an alternative, simple, and <a id="id186" class="indexterm"/>straightforward way to validate incoming requests. This prevents the need to return a custom, more descriptive validation error message to the caller, and sends a generic one instead.</p></div></div></div>
<div class="section" title="Cross-field validation"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec23"/>Cross-field validation</h1></div></div></div><p>There are cases where validation should be performed on multiple fields (properties) of an object. We <a id="id187" class="indexterm"/>can achieve this by implementing custom validation annotations that also apply class-level constraints.</p><p>Luckily enough, there's a much simpler way to achieve this. Dropwizard offers the <code class="literal">io.dropwizard.validation.ValidationMethod</code> annotation, which we can use in a <code class="literal">boolean</code> method of our representation class.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec48"/>How to do it…</h2></div></div></div><p>Here are the <a id="id188" class="indexterm"/>steps needed in order to add cross-field validation to a <code class="literal">contact</code> object. We will check that the contact's full name is not John Doe:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a new method in the <code class="literal">Contact</code> class named <code class="literal">#isValidPerson()</code>.<div class="informalexample"><pre class="programlisting">public boolean isValidPerson() {
  if (firstName.equals("John") &amp;&amp; lastName.equals("Doe")) {
    return false;
  }
  else {
    return true;
  }
}</pre></div></li><li class="listitem">Then, we need to ensure that the output of this method will never be included in the output when it is serialized by Jackson. For this, annotate the <code class="literal">#isValidPerson()</code> method<a id="id189" class="indexterm"/> with the <code class="literal">@JsonIgnore</code> annotation (<code class="literal">com.fasterxml.jackson.annotation.JsonIgnore</code>).</li><li class="listitem">Finally, annotate the same method with <code class="literal">@ValidationMethod</code> (<code class="literal">io.dropwizard.validation.ValidationMethod</code>), and also provide an error message in case of validation failure.<div class="informalexample"><pre class="programlisting">@ValidationMethod(message="John Doe is not a valid person!")</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec49"/>How it works…</h2></div></div></div><p>When the validation is triggered, the <code class="literal">#isValidPerson()</code> method is executed along with the custom validation code we've put there. If the method returns true, that means the constraint implied by it is satisfied. If the method returns false, that indicates a constraint violation, <a id="id190" class="indexterm"/>and the validation error message will be the one we specified <a id="id191" class="indexterm"/>along with the <code class="literal">ValidationMethod</code> annotation.</p><p>You can create and have as many cross-field validation methods as you want in your classes. However, note that every custom validation method must be of the return type <code class="literal">boolean</code>, and its name must begin with <code class="literal">is</code>.</p></div></div></body></html>