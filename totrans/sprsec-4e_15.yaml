- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Additional Spring Security Features
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的 Spring Security 功能
- en: 'In this chapter, we will explore several additional `Spring Security` features
    that we have not covered so far in this book, including the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些我们在这本书中尚未涵盖的额外的 `Spring Security` 功能，包括以下主题：
- en: '**Cross-Site** **Scripting** (**XSS**)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨站** **脚本**（**XSS**）'
- en: '**Cross-Site Request** **Forgery** (**CSRF**)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨站请求** **伪造**（**CSRF**）'
- en: Synchronizer token pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步器令牌模式
- en: Clickjacking
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clickjacking
- en: Testing Spring Security Applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 Spring Security 应用程序
- en: Reactive Applications support
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式应用程序支持
- en: 'We will understand how to include various HTTP headers to protect against common
    security vulnerabilities, using the following methods:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将了解如何使用以下方法包括各种 HTTP 标头来防止常见的安全漏洞：
- en: '`Cache-Control`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cache-Control`'
- en: '`Content-Type Options`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Type Options`'
- en: '`HTTP Strict Transport` `Security (HSTS)`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP 严格传输安全`（`HSTS`）'
- en: '`X-Frame-Options`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Frame-Options`'
- en: '`X-XSS-Protection`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-XSS-Protection`'
- en: Before you read this chapter, you should already understand how `Spring Security`
    works. This means you should already be able to set up authentication and authorization
    in a simple web application. If you are unable to do this, you will want to ensure
    you have read up to [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068), *Custom Authentication*,
    before proceeding with this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之前，你应该已经理解了 `Spring Security` 的工作原理。这意味着你应该已经能够在一个简单的网络应用程序中设置身份验证和授权。如果你无法做到这一点，你将想要确保在继续本章之前已经阅读到
    [*第 3 章*](B21757_03.xhtml#_idTextAnchor068)，*自定义身份验证*。
- en: 'This chapter’s code in action link is here: [https://packt.link/aXvKi](https://packt.link/aXvKi).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例链接在此：[https://packt.link/aXvKi](https://packt.link/aXvKi)。
- en: Security vulnerabilities
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全漏洞
- en: In the age of the internet, there is a multitude of possible vulnerabilities
    that can be exploited. A great resource to learn more about web-based vulnerabilities
    is the **Open Web Application Security Project** (**OWASP**), which is located
    at [https://owasp.org](https://owasp.org).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网时代，有无数可能被利用的漏洞。了解更多关于基于 Web 的漏洞的宝贵资源是位于 [https://owasp.org](https://owasp.org)
    的 **开放 Web 应用程序安全项目**（**OWASP**）。
- en: In addition to being a great resource to understand various vulnerabilities,
    OWASP categorizes the top 10 vulnerabilities based on industry trends.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了是理解各种漏洞的宝贵资源外，OWASP 还根据行业趋势对前 10 大漏洞进行了分类。
- en: Cross-Site Scripting
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站脚本
- en: '**Cross-site scripting** or **XSS** attacks involve malicious scripts that
    have been injected into a trusted site.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站脚本**或**XSS**攻击涉及注入到受信任网站中的恶意脚本。'
- en: XSS attacks occur when an attacker exploits a given web application that allows
    unventilated input to be sent to the site, generally in the form of browser-based
    scripts, which are then executed by a different user of the website.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当攻击者利用允许未经过滤的输入发送到网站的特定网络应用程序时，就会发生 XSS 攻击，通常是以基于浏览器的脚本的形式，然后由网站的不同用户执行。
- en: There are many forms that attackers can exploit, based on validated or unencoded
    information provided to websites.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以根据提供给网站验证或未编码的信息采取多种形式。
- en: 'XSS can be described by the following sequence diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 可以通过以下序列图来描述：
- en: '![Figure 15.1 – Cross-Site Scripting (XSS)](img/B21757_15_1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.1 – 跨站脚本（XSS）](img/B21757_15_1.jpg)'
- en: Figure 15.1 – Cross-Site Scripting (XSS)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1 – 跨站脚本（XSS）
- en: At the core of this issue is expecting a user to trust the site’s information
    that is being sent. The end user’s browser has no way of knowing that the script
    should not be trusted because there is implicit trust in the website they’re browsing.
    Because the end user thinks the script came from a trusted source, the malicious
    script can access any cookies, session tokens, or other sensitive information
    retained by the browser and used with that website.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的核心是期望用户信任正在发送的网站信息。最终用户的浏览器无法知道脚本不应该被信任，因为他们在浏览的网站上存在隐含的信任。由于最终用户认为脚本来自受信任的来源，恶意脚本可以访问浏览器保留的任何
    cookies、会话令牌或其他敏感信息，并用于该网站。
- en: Cross-Site Request Forgery
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站请求伪造
- en: '**Cross-site request forgery** (**CSRF**) is an attack that tricks the victim
    into submitting a malicious request. This type of attack inherits or hijacks the
    identity and privileges of the victim and performs unauthorized functions and
    gains access on the victim’s behalf.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站请求伪造**（**CSRF**）是一种欺骗受害者提交恶意请求的攻击。这种攻击继承了或劫持了受害者的身份和权限，并执行未经授权的功能，代表受害者获取访问权限。'
- en: For web applications, most browsers automatically include credentials associated
    with the site, which includes a user session, cookie, IP address, Windows domain
    credentials, and so forth.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Web应用程序，大多数浏览器会自动包含与网站关联的凭据，包括用户会话、cookie、IP地址、Windows域凭据等。
- en: So, if a user is currently authenticated on a site, that given site will have
    no way to distinguish between the forged request sent by the victim and a legitimate
    request.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果用户当前在一个网站上认证，该网站将无法区分受害者发送的伪造请求和合法请求。
- en: CSRF attacks target functionality that causes a state change on the server,
    such as changing the victim’s email address or password, or engaging in a financial
    transaction.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF攻击针对的是在服务器上引起状态变化的函数，例如更改受害者的电子邮件地址或密码，或进行金融交易。
- en: This forces the victim to retrieve data that doesn’t benefit an attacker because
    the attacker does not receive the response; the victim does. Thus, CSRF attacks
    target state-changing requests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这迫使受害者检索对攻击者无益的数据，因为攻击者不会收到响应；受害者会收到。因此，CSRF攻击针对的是会改变状态的请求。
- en: 'The following sequence diagram details how a CSRF attack would occur:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下序列图详细说明了CSRF攻击是如何发生的：
- en: '![Figure 15.2 – CSRF](img/B21757_15_2.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图15.2 – CSRF](img/B21757_15_2.jpg)'
- en: Figure 15.2 – CSRF
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2 – CSRF
- en: There are several different design measures that may be taken to attempt to
    prevent CSRF; however, measures such as secret cookies, `HTTP POST` requests,
    multistep transactions, URL rewriting, and `HTTPS` in no way prevent this type
    of attack.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试防止CSRF攻击，可以采取多种不同的设计措施；然而，诸如秘密cookie、`HTTP POST`请求、多步交易、URL重写和`HTTPS`等措施并不能阻止此类攻击。
- en: Important note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: OWASP’s top 10 security vulnerabilities list details CSRF as the eighth most
    common attack at [https://owasp.org/www-community/attacks/csrf](https://owasp.org/www-community/attacks/csrf).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP的前10大安全漏洞列表将CSRF列为第8大常见攻击，详情请见[https://owasp.org/www-community/attacks/csrf](https://owasp.org/www-community/attacks/csrf)。
- en: In summary, CSRF is the general concept of an attack where a user is tricked
    into performing unintended actions. In the next section, we will explore the `Synchronizer
    Tokens pattern`, which is a specific method used to mitigate CSRF attacks by using
    unique tokens associated with each user session.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，CSRF是一种攻击的通用概念，即用户被诱骗执行非预期行为。在下一节中，我们将探讨`同步器令牌模式`，这是一种通过使用与每个用户会话关联的唯一令牌来减轻CSRF攻击的具体方法。
- en: Synchronizer token pattern
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步器令牌模式
- en: A solution to CSRF is to use the **synchronizer token** pattern. This solution
    ensures that each request requires, in addition to our session cookie, a randomly
    generated token as an HTTP parameter. When a request is submitted, the server
    must look up the expected value for the parameter and compare it to the actual
    value in the request. If the values do not match, the request should fail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF的解决方案是使用**同步器令牌**模式。此解决方案确保每个请求除了我们的会话cookie外，还需要一个随机生成的令牌作为HTTP参数。当请求提交时，服务器必须查找参数的预期值，并将其与请求中的实际值进行比较。如果值不匹配，则请求应失败。
- en: Important note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The *Cross-Site Request Forgery Prevention Cheat Sheet* recommends the `synchronizer
    token` pattern as a viable solution for CSRF attacks: [https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.xhtml#General_Recommendation:_%20Synchronizer_Token_Pattern](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.xhtml#General_Recommendation:_%20Synchronizer_Token_Pattern).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 《跨站请求伪造预防技巧表》建议将`同步器令牌模式`作为CSRF攻击的有效解决方案：[https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.xhtml#General_Recommendation:_%20Synchronizer_Token_Pattern](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.xhtml#General_Recommendation:_%20Synchronizer_Token_Pattern)。
- en: 'Let’s look at how our example would change. Assume the randomly generated token
    is present in an HTTP parameter named `_csrf`. For example, the request to transfer
    money would look as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的示例将如何改变。假设随机生成的令牌存在于名为`_csrf`的HTTP参数中。例如，转账请求看起来如下：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will notice that we added the `_csrf` parameter with a random value. Now,
    the malicious website will not be able to guess the correct value for the `_csrf`
    parameter (which must be explicitly provided on the malicious website), and the
    transfer will fail when the server compares the actual token to the expected token.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们添加了一个具有随机值的 `_csrf` 参数。现在，恶意网站将无法猜测 `_csrf` 参数的正确值（必须在恶意网站上明确提供），当服务器将实际令牌与预期令牌进行比较时，传输将失败。
- en: 'The following diagram shows a standard use case for a `synchronizer` `token`
    pattern:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了 `synchronizer` `token` 模式的标准用例：
- en: '![Figure 15.3 – Synchronizer token pattern](img/B21757_15_3.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图15.3 – 同步器令牌模式](img/B21757_15_3.jpg)'
- en: Figure 15.3 – Synchronizer token pattern
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 – 同步器令牌模式
- en: '`Spring Security` provides `synchronizer token` support that is turned on by
    default. You might have noticed from the previous chapters that in our `SecurityConfig.java`
    file, we disabled CSRF protection, as shown in the following code snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring Security` 默认提供了 `synchronizer token` 支持。你可能已经注意到，在前面的章节中，我们在 `SecurityConfig.java`
    文件中禁用了 CSRF 保护，如下面的代码片段所示：'
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Up to this point in the book, we have disabled `synchronizer token` protection
    so that we can focus on other security concerns.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到本书的这一部分，我们已经禁用了 `synchronizer token` 保护，以便我们可以专注于其他安全关注点。
- en: If we start the application at this point, and there will be no `synchronizer
    token` support added to any of the pages.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在启动应用程序，并且没有任何页面添加 `synchronizer token` 支持。
- en: Important note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the code from `chapter15.00-calendar`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从 `chapter15.00-calendar` 的代码开始。
- en: After exploring the `synchronizer token` pattern, we will explore when to use
    CSRF protection.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了 `synchronizer token` 模式之后，我们将探讨何时使用 CSRF 保护。
- en: When to use CSRF protection
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用 CSRF 保护
- en: It is recommended you use CSRF protection for any request that could be processed
    by a browser or normal users. If you are only creating a service that is used
    by non-browser clients, you will most likely want to disable CSRF protection.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你为任何可能由浏览器或普通用户处理的请求使用 CSRF 保护。如果你只创建了一个仅供非浏览器客户端使用的服务，你很可能希望禁用 CSRF 保护。
- en: CSRF protection and JSON
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSRF 保护与 JSON
- en: 'A common question is, do I need to protect JSON requests made by JavaScript?
    The short answer is, it depends. However, you must be very careful, as there are
    CSRF exploits that can impact JSON requests. For example, a malicious user can
    create a CSRF with JSON using the following form:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的问题是，我是否需要保护由 JavaScript 发起的 JSON 请求？简短的回答是，这取决于。然而，你必须非常小心，因为存在可能影响 JSON
    请求的 CSRF 漏洞。例如，恶意用户可以使用以下表单创建带有 JSON 的 CSRF：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will produce the following JSON structure:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下 JSON 结构：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If an application were not validating the `Content-Type` method, then it would
    be exposed to this exploit. Depending on the setup, a Spring MVC application that
    validates the `Content- Type` method could still be exploited by updating the
    URL suffix to end with `.json`, as shown in the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序没有验证 `Content-Type` 方法，那么它就会暴露于这种漏洞。根据配置，一个验证 `Content-Type` 方法的 Spring
    MVC 应用程序仍然可能通过更新 URL 后缀以 `.json` 结尾而被利用，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this section, we have explored CSRF protection and JSON. In the next section,
    we will cover CSRF and stateless browser applications.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了 CSRF 保护与 JSON。在下一节中，我们将介绍 CSRF 和无状态浏览器应用程序。
- en: CSRF and stateless browser applications
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSRF 和无状态浏览器应用程序
- en: What if your application is stateless? That doesn’t necessarily mean you are
    protected. In fact, if a user does not need to perform any actions in the web
    browser for a given request, they are likely still vulnerable to CSRF attacks.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序是无状态的，这并不一定意味着你是安全的。事实上，如果用户对于某个请求不需要在浏览器中执行任何操作，他们仍然可能容易受到 CSRF 攻击。
- en: For example, consider an application using a custom cookie that contains all
    of the states within it for authentication instead of the `JSESSIONID` cookie.
    When the CSRF attack happens, the custom cookie will be sent with the request
    in the same manner that the `JSESSIONID` cookie was sent in our previous example.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个使用自定义cookie来包含所有状态以进行身份验证而不是 `JSESSIONID` cookie的应用程序。当 CSRF 攻击发生时，自定义cookie将以与我们在上一个示例中发送
    `JSESSIONID` cookie相同的方式随请求发送。
- en: Users using basic authentication are also vulnerable to CSRF attacks, since
    the browser will automatically include the username and password in any requests,
    in the same manner, that the `JSESSIONID` cookie was sent in our previous example.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基本身份验证的用户也容易受到 CSRF 攻击，因为浏览器会自动将用户名和密码包含在任何请求中，就像在我们的上一个例子中发送 `JSESSIONID`
    cookie 一样。
- en: Using Spring Security CSRF protection
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Spring Security CSRF 保护
- en: 'So, what are the steps necessary to use `Spring Security` to protect our site
    against CSRF attacks? The steps for using `Spring Security`’s CSRF protection
    are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，使用 `Spring Security` 保护我们的网站免受 CSRF 攻击所需的步骤是什么？使用 `Spring Security` 的 CSRF
    保护步骤如下：
- en: Use proper HTTP verbs.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正确的 HTTP 动词。
- en: Configure CSRF protection.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 CSRF 保护。
- en: Include the CSRF token.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含 CSRF 令牌。
- en: Let’s understand these steps better now.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更好地理解这些步骤。
- en: Using proper HTTP verbs
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用正确的 HTTP 动词
- en: The first step to protecting against CSRF attacks is to ensure that your website
    uses proper `HTTP` verbs. Specifically, before `Spring Security`’s CSRF support
    can be of use, you need to be certain that your application uses `PATCH`, `POST`,
    `PUT`, and/or `DELETE` for anything that modifies state.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 防止 CSRF 攻击的第一步是确保你的网站使用正确的 `HTTP` 动词。具体来说，在 `Spring Security` 的 CSRF 支持能够发挥作用之前，你需要确定你的应用程序对于任何修改状态的操作都使用了
    `PATCH`、`POST`、`PUT` 和/或 `DELETE`。
- en: This is not a limitation of `Spring Security`’s support but, instead, a general
    requirement for proper `CSRF` prevention. The reason is that including private
    information in an `HTTP GET` method can cause the information to be leaked.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是 `Spring Security` 支持的限制，而是一个正确的 `CSRF` 防止的一般要求。原因是将私人信息包含在 `HTTP GET` 方法中可能会导致信息泄露。
- en: Refer to *RFC 2616, Section 15.1.3*, *Encoding Sensitive Information in URI’s*,
    for general guidance on using `POST` instead of `GET` for sensitive information
    ([https://www.rfc-editor.org/rfc/rfc2616.xhtml#section-15.1.3](https://www.rfc-editor.org/rfc/rfc2616.xhtml#section-15.1.3)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 *RFC 2616，第 15.1.3 节*，*在 URI 中编码敏感信息*，以获取有关使用 `POST` 而不是 `GET` 来处理敏感信息的通用指导
    ([https://www.rfc-editor.org/rfc/rfc2616.xhtml#section-15.1.3](https://www.rfc-editor.org/rfc/rfc2616.xhtml#section-15.1.3))。
- en: Conﬁguring CSRF protection
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置 CSRF 保护
- en: The next step is to include `Spring Security`’s CSRF protection within your
    application. Some frameworks handle invalid CSRF tokens by invaliding the user’s
    session, but this causes its own problems. Instead, by default, `Spring Security`’s
    CSRF protection will produce `HTTP 403 access denied`. This can be customized
    by configuring `AccessDeniedHandler` to process `InvalidCsrfTokenException` differently.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在你的应用程序中包含 `Spring Security` 的 CSRF 保护。一些框架通过使无效的 CSRF 令牌失效用户会话来处理无效的 CSRF
    令牌，但这会带来它自己的问题。相反，默认情况下，`Spring Security` 的 CSRF 保护将产生 `HTTP 403 访问拒绝`。这可以通过配置
    `AccessDeniedHandler` 来处理 `InvalidCsrfTokenException` 的不同方式来自定义。
- en: For passivity reasons, if you are using the `XML` configuration, CSRF protection
    must be explicitly enabled using the `<csrf>` element. Refer to the `<csrf>` element’s
    documentation for additional customizations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于被动性原因，如果你正在使用 `XML` 配置，必须通过 `<csrf>` 元素显式启用 CSRF 保护。有关其他自定义选项，请参阅 `<csrf>`
    元素的文档。
- en: Default CSRF support
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认 CSRF 支持
- en: CSRF protection is enabled by default with Java configuration. Refer to the
    Java documentation of `csrf()` for additional customizations regarding how CSRF
    protection is configured.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Java 配置时，CSRF 保护默认启用。有关 CSRF 保护配置的更多自定义选项，请参阅 `csrf()` 的 Java 文档。
- en: 'Just to be verbose in this configuration, we are going to add the CSRF method
    to our `SecurityConfig.java` file, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个配置更加详细，我们将在 `SecurityConfig.java` 文件中添加 CSRF 方法，如下所示：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To have access to the H2 console, CSRF needs to be disabled, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 H2 控制台，需要禁用 CSRF，如下所示：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After configuring CSRF in the `Spring Security` `SecurityFilterChain` bean,
    we will see how we can enable the support in web forms.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置 `Spring Security` 的 `SecurityFilterChain` bean 中的 CSRF 之后，我们将看到如何启用网页表单中的支持。
- en: Including the CSRF token in the <form> submissions
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 <form> 提交中包含 CSRF 令牌
- en: 'The last step is to ensure that you include the CSRF token in all `PATCH`,
    `POST`, `PUT`, and `DELETE` methods. One way to approach this is to use the `_csrf`
    request attribute to obtain the current `CsrfToken` token. An example of doing
    this with a **Java Server Page** (**JSP**) is shown as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是确保你在所有 `PATCH`、`POST`、`PUT` 和 `DELETE` 方法中包含 CSRF 令牌。一种方法是使用 `_csrf` 请求属性来获取当前的
    `CsrfToken` 令牌。以下是一个使用 **Java Server Page** (**JSP**) 实现此操作的示例：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After including the CSRF token in the `<form>`, we will explore another option
    by including the CSRF token based on `Spring Security` JSP tags.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<form>` 中包含 CSRF 令牌后，我们将通过包含基于 `Spring Security` JSP 标签的 CSRF 令牌来探索另一个选项。
- en: Including the CSRF token using the Spring Security JSP tag library
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Spring Security JSP 标签库包含 CSRF 令牌
- en: If CSRF protection is enabled, the `Spring Security` tag inserts a hidden form
    field with the correct name and value for the CSRF protection token. If CSRF protection
    is not enabled, this tag has no output.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 CSRF 保护已启用，`Spring Security` 标签会插入一个带有正确名称和值的隐藏表单字段用于 CSRF 保护令牌。如果 CSRF 保护未启用，则此标签没有输出。
- en: Normally, `Spring Security` automatically inserts a CSRF form field for any
    `<form:form>` tags you use, but if for some reason you cannot use `<form:form>`,
    `csrfInput` is a handy replacement.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`Spring Security` 会自动为任何 `<form:form>` 标签插入 CSRF 表单字段，但如果由于某些原因您不能使用 `<form:form>`，`csrfInput`
    是一个方便的替代品。
- en: 'You should place this tag within an `HTML <form></form>` block, where you would
    normally place other input fields. Do not place this tag within a Spring `<form:form></form:form>`
    block. `Spring Security` handles Spring forms automatically, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该将此标签放置在 `HTML <form></form>` 块中，您通常会在其中放置其他输入字段。不要将此标签放置在 Spring `<form:form></form:form>`
    块中。`Spring Security` 会自动处理 Spring 表单，如下所示：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Default CSRF token support
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认 CSRF 令牌支持
- en: If you are using the Spring MVC `<form:form>` tag, or `Thymeleaf 2.1+`, and
    you are also using `@EnableWebSecurity`, the `CsrfToken` token is automatically
    included for you (using the `CsrfRequestDataValue` token we have been processing).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用 Spring MVC `<form:form>` 标签，或 `Thymeleaf 2.1+`，并且您还使用了 `@EnableWebSecurity`，则
    CSRF 令牌将自动为您包含（使用我们一直在处理的 `CsrfRequestDataValue` 令牌）。
- en: So, for this book, we have been using *Thymeleaf* for all of our web pages.
    Thymeleaf has CSRF support enabled by default if we enable CSRF support in `Spring
    Security`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于这本书，我们一直在使用 *Thymeleaf* 为我们所有的网页。如果我们在 `Spring Security` 中启用 CSRF 支持，Thymeleaf
    默认启用 CSRF 支持。
- en: 'The `logout` link will not work with CSRF support enabled and needs to be replaced
    by the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`logout` 链接在 CSRF 支持启用的情况下将无法工作，需要替换为以下代码：'
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Important note
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: Your code should now look like `chapter15.01-calendar`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像 `chapter15.01-calendar`。
- en: 'If we start up the JBCP calendar application and navigate to the login page
    at `http://localhost:8080/login.xhtml`, we can view the generated source for the
    `login.xhtml` page, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启动 JBCP 日历应用程序并导航到 `http://localhost:8080/login.xhtml` 上的登录页面，我们可以查看 `login.xhtml`
    页面的生成源，如下所示：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Ajax and JavaScript requests
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ajax 和 JavaScript 请求
- en: 'If you are using JSON, then it is not possible to submit the CSRF token within
    an HTTP parameter. Instead, you can submit the token within an HTTP header. A
    typical pattern would be to include the CSRF token within your `<meta>` HTML tags.
    An example with a JSP is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 JSON，那么在 HTTP 参数中提交 CSRF 令牌是不可能的。相反，您可以在 HTTP 头部中提交令牌。一个典型的模式是在您的 `<meta>`
    HTML 标签中包含 CSRF 令牌。以下是一个使用 JSP 的示例：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Instead of manually creating the meta tags, you can use the simpler `csrfMetaTags`
    tag from the `Spring Security` JSP tag library.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以不手动创建元标签，而是使用 `Spring Security` JSP 标签库中的更简单的 `csrfMetaTags` 标签。
- en: The csrfMetaTags tag
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`csrfMetaTags` 标签'
- en: If CSRF protection is enabled, this tag inserts meta tags containing the CSRF
    protection token form field, header names, and CSRF protection token value. These
    meta tags are useful for employing CSRF protection within JavaScript in your applications.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 CSRF 保护已启用，此标签会插入包含 CSRF 保护令牌表单字段、头部名称和 CSRF 保护令牌值的元标签。这些元标签对于在您的应用程序中实现
    CSRF 保护很有用。
- en: 'You should place the `csrfMetaTags` tag within an HTML `<head></head>` block,
    where you would normally place other meta tags. Once you use this tag, you can
    access the form field name, header name, and token value easily using JavaScript,
    as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该将 `csrfMetaTags` 标签放置在 HTML `<head></head>` 块中，您通常会在其中放置其他元标签。一旦使用此标签，您就可以使用
    JavaScript 容易地访问表单字段名称、头部名称和令牌值，如下所示：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If CSRF protection is not enabled, `csrfMetaTags` outputs nothing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 CSRF 保护未启用，`csrfMetaTags` 不输出任何内容。
- en: jQuery usage
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jQuery 使用
- en: 'You can then include the token within all of your Ajax requests. If you were
    using jQuery, this could be done with the following code snippet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以将令牌包含在所有的 Ajax 请求中。如果您使用 jQuery，可以使用以下代码片段完成此操作：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After exploring the default CSRF configuration, we will conclude with some CSRF
    caveats.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索默认 CSRF 配置之后，我们将以一些 CSRF 注意事项结束。
- en: CSRF caveats
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSRF 注意事项
- en: There are a few caveats when implementing CSRF in `Spring Security` that you
    need to be aware of. Let us see these caveats in the next few sections.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 `Spring Security` 中的CSRF时，有一些需要注意的注意事项。让我们在接下来的几节中看看这些注意事项。
- en: Timeouts
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超时
- en: One issue is that the expected CSRF token is stored in the `HttpSession` method,
    so as soon as the `HttpSession` method expires, your configured `AccessDeniedHandler`
    handler will receive `InvalidCsrfTokenException`. If you are using the default
    `AccessDeniedHandler` handler, the browser will get an `HTTP 403` and display
    a poor error message.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题是预期的CSRF令牌存储在 `HttpSession` 方法中，因此一旦 `HttpSession` 方法过期，您的配置的 `AccessDeniedHandler`
    处理器将收到 `InvalidCsrfTokenException`。如果您使用的是默认的 `AccessDeniedHandler` 处理器，浏览器将得到
    `HTTP 403` 并显示一个错误信息。
- en: Another disadvantage is that by removing the state (the timeout), you lose the
    ability to forcibly terminate the token if something is compromised.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是，通过移除状态（超时），您将失去在令牌被泄露时强制终止令牌的能力。
- en: A simple way to mitigate an active user experiencing a timeout is to have some
    JavaScript that lets the user know their session is about to expire. The user
    can click a button to continue and refresh the session.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一种减轻活跃用户遇到超时的简单方法是通过一些JavaScript让用户知道他们的会话即将过期。用户可以点击一个按钮继续并刷新会话。
- en: 'Alternatively, specifying a custom `AccessDeniedHandler` handler allows you
    to process `InvalidCsrfTokenException` any way you like, as we can see in the
    following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，指定一个自定义的 `AccessDeniedHandler` 处理器允许您以任何您喜欢的方式处理 `InvalidCsrfTokenException`，正如我们可以在以下代码中看到：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Logging in
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 登录
- en: To protect against forged login requests, the login form should be protected
    against CSRF attacks, too. Since the `CsrfToken` token is stored in `HttpSession`,
    this means an `HttpSession` method will be created as soon as the `CsrfToken`
    attribute is accessed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止伪造登录请求，登录表单也应该保护免受CSRF攻击。由于 `CsrfToken` 令牌存储在 `HttpSession` 中，这意味着一旦访问 `CsrfToken`
    属性，就会创建一个 `HttpSession` 方法。
- en: While this sounds bad in a RESTful/stateless architecture, the reality is that
    the state is necessary to implement practical security. Without the state, we
    have nothing we can do if a token is compromised. Practically speaking, the CSRF
    token is quite small in size and should have a negligible impact on our architecture.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在RESTful/无状态架构中这听起来很糟糕，但现实是状态对于实现实际安全是必要的。如果没有状态，如果令牌被泄露，我们就无能为力。实际上，CSRF令牌的大小相当小，应该对我们的架构影响微乎其微。
- en: Important note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: An attacker may forge a request to log the victim into a target website using
    the attacker’s credentials; this is known as login CSRF ([https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests)).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可能伪造一个请求，使用攻击者的凭据将受害者登录到目标网站；这被称为登录CSRF ([https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests))。
- en: Logging out
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注销
- en: Adding CSRF will update the `LogoutFilter` filter to only use `HTTP POST`. This
    ensures that logging out requires a CSRF token and that a malicious user cannot
    forcibly log out your users.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 添加CSRF将更新 `LogoutFilter` 过滤器，使其仅使用 `HTTP POST`。这确保了注销需要CSRF令牌，并且恶意用户无法强制注销您的用户。
- en: One approach to prevent CSRF attacks is to use a `<form>` tag for logout. If
    you want an `HTML` link, you can use JavaScript to have the link perform an `HTTP
    POST` (which can be in a hidden form). For browsers with JavaScript disabled,
    you can optionally have the link take the user to a logout confirmation page that
    will perform the `HTTP POST`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 防止CSRF攻击的一种方法是在注销时使用 `<form>` 标签。如果您想有一个 `HTML` 链接，可以使用JavaScript让链接执行 `HTTP
    POST`（这可以是一个隐藏的表单）。对于禁用了JavaScript的浏览器，您可以选择让链接将用户带到注销确认页面，该页面将执行 `HTTP POST`。
- en: 'If you want to use `HTTP GET` with logout, you can do so, but remember, this
    is generally not recommended. For example, the following Java configuration will
    perform logout when the logout URL pattern is requested with any `HTTP` method:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在注销时使用 `HTTP GET`，您也可以这样做，但请记住，这通常不推荐。例如，以下Java配置将在请求注销URL模式时使用任何 `HTTP`
    方法执行注销：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this section, we’ve discussed CSRF now, let’s delve into securing HTTP response
    headers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经讨论了CSRF，现在让我们深入了解保护HTTP响应头。
- en: Security HTTP response headers
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全HTTP响应头
- en: The following sections discuss `Spring Security`’s support for adding various
    security headers to the response.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节将讨论 `Spring Security` 对添加各种安全头到响应的支持。
- en: '`Spring Security` allows users to easily inject default security headers to
    assist in protecting their applications. The following is a list of the current
    default security headers provided by `Spring Security`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring Security` 允许用户轻松注入默认安全头，以帮助保护他们的应用程序。以下是 `Spring Security` 提供的当前默认安全头的列表：'
- en: Cache-Control
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cache-Control
- en: Content-Type Options
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容类型选项
- en: HTTP Strict Transport Security
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 严格传输安全
- en: X-Frame-Options
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X-Frame-Options
- en: X-XSS-Protection
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X-XSS-Protection
- en: While each of these headers is considered best practice, it should be noted
    that not all clients utilize these headers, so additional testing is encouraged.
    For passivity reasons, if you are using `Spring Security`’s `XML namespace` support,
    you must explicitly enable the security headers. All of the default headers can
    be easily added using the `<headers>` element with no child elements.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个这些头都被认为是最佳实践，但应注意的是，并非所有客户端都使用这些头，因此建议进行额外的测试。出于被动性原因，如果你正在使用 `Spring Security`
    的 `XML 命名空间` 支持，你必须明确启用安全头。所有默认头都可以通过使用没有子元素的 `<headers>` 元素轻松添加。
- en: 'If you are using `Spring Security`’s Java configuration, all of the default
    security headers are added by default. They can be disabled using Java configuration,
    as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 `Spring Security` 的 Java 配置，所有默认安全头都会默认添加。它们可以通过以下方式使用 Java 配置来禁用：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'By default, `Spring Security` instructs browsers to disable the XSS Auditor
    by using `<headers-xss-protection,X-XSS-Protection header>`. You can disable the
    `X-XSS-Protection` header entirely:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Spring Security` 指示浏览器通过使用 `<headers-xss-protection,X-XSS-Protection
    header>` 来禁用 XSS 审计器。你可以完全禁用 `X-XSS-Protection` 头：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can also set the header value:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以设置头值：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As soon as you specify any headers that should be included, then only those
    headers will be included. For example, the following configuration will include
    support for `X-Frame-Options` only:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你指定了应该包含的任何头，那么就只会包含那些头。例如，以下配置将仅包括对 `X-Frame-Options` 的支持：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Cache-Control
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cache-Control
- en: In the past, `Spring Security` required you to provide your own `Cache-Control`
    method for your web application. This seemed reasonable at the time, but browser
    caches have evolved to include caches for secure connections as well. This means
    that a user may view an authenticated page and log out, and then a malicious user
    can use the browser history to view the cached page.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，`Spring Security` 要求你为你的 Web 应用程序提供自己的 `Cache-Control` 方法。在当时这似乎是合理的，但浏览器缓存已经发展到包括安全连接的缓存。这意味着一个用户可能查看了一个认证页面并登出，然后一个恶意用户可以使用浏览器历史记录来查看缓存的页面。
- en: 'To help mitigate this, `Spring Security` has added `Cache-Control` support,
    which will insert the following headers into your response:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助缓解这种情况，`Spring Security` 添加了 `Cache-Control` 支持，这将把以下头插入到你的响应中：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To be secure, `Spring Security` adds these headers by default. However, if your
    application provides its own cache control headers, `Spring Security` will rely
    on your own application headers only. This allows for applications to ensure that
    static resources (such as CSS and JavaScript) can be cached.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，`Spring Security` 默认添加这些头。然而，如果你的应用程序提供了自己的缓存控制头，`Spring Security` 将仅依赖于你自己的应用程序头。这允许应用程序确保静态资源（如
    CSS 和 JavaScript）可以被缓存。
- en: Content-Type Options
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容类型选项
- en: Historically, browsers, including Internet Explorer, would try to guess the
    content type of a request using content sniffing. This allowed browsers to improve
    the user experience by guessing the content type of resources that had not specified
    the content type. For example, if a browser encountered a JavaScript file that
    did not have the content type specified, it would be able to guess the content
    type and then execute it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，包括 Internet Explorer 在内的浏览器会尝试通过内容嗅探来猜测请求的内容类型。这允许浏览器通过猜测未指定内容类型的资源的内容类型来改善用户体验。例如，如果一个浏览器遇到了一个没有指定内容类型的
    JavaScript 文件，它将能够猜测内容类型然后执行它。
- en: Important note
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There are many additional things one should do, such as only displaying the
    document in a distinct domain, ensuring the `Content-Type` header is set, sanitizing
    the document, and so on, when allowing content to be uploaded. However, these
    measures are out of the scope of what `Spring Security` provides. It is also important
    to point out that when disabling content sniffing, you must specify the content
    type for things to work properly.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在允许内容上传时，还有许多其他应该做的事情，例如只在一个特定的域名中显示文档，确保设置了 `Content-Type` 头，清理文档等等，但这些措施超出了
    `Spring Security` 提供的范围。还重要的是指出，在禁用内容嗅探时，你必须指定内容类型才能使事情正常工作。
- en: The problem with content sniffing is that this allows malicious users to use
    *polyglots* (a file that is valid as multiple content types) to execute XSS attacks.
    For example, some sites may allow users to submit a valid PostScript document
    to a website and view it. A malicious user might create a PostScript document
    that is also a valid JavaScript file and execute an XSS attack with it ([http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf](http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf)).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 内容嗅探的问题在于，这允许恶意用户使用 *多语言文件*（一个可以作为多种内容类型有效的文件）来执行 XSS 攻击。例如，一些网站可能允许用户向网站提交一个有效的
    PostScript 文档并查看它。恶意用户可能会创建一个既是有效的 PostScript 文件也是有效的 JavaScript 文件的文档，并使用它执行
    XSS 攻击（[http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf](http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf)）。
- en: 'Content sniffing can be disabled by adding the following header to our response:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加以下头到我们的响应中，可以禁用内容嗅探：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By default, `Spring Security` disables content sniffing by adding this header
    to HTTP responses.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Spring Security` 通过向 HTTP 响应中添加此头来禁用内容嗅探。
- en: HTTP Strict Transport Security
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 严格传输安全
- en: When you type in your bank’s website, do you enter `mybank.example.com`, or
    do you enter `https://mybank.example.com`? If you omit the HTTPS protocol, you
    are potentially vulnerable to `https://mybank.example.com`, a malicious user could
    intercept the initial HTTP request and manipulate the response (redirect to `https://mibank.example.com`
    and steal your credentials).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入你的银行网站时，你是输入 `mybank.example.com`，还是输入 `https://mybank.example.com`？如果你省略了
    HTTPS 协议，你可能会容易受到 `https://mybank.example.com` 的攻击，恶意用户可能会拦截初始的 HTTP 请求并操纵响应（重定向到
    `https://mibank.example.com` 并窃取你的凭证）。
- en: Many users omit the HTTPS protocol, and this is why `HSTS` was created.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 许多用户省略了 HTTPS 协议，这就是为什么需要创建 `HSTS` 的原因。
- en: In accordance with `RFC6797`, the `HSTS` header is only injected into `HTTPS`
    responses. In order for the browser to acknowledge the header, the browser must
    first trust the **certificate authority** (**CA**) that signed the **Secure Sockets
    Layer** (**SSL**) certificate used to make the connection, not just the SSL certificate
    ([https://datatracker.ietf.org/doc/html/rfc6797](https://datatracker.ietf.org/doc/html/rfc6797)).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `RFC6797`，`HSTS` 头仅注入到 `HTTPS` 响应中。为了浏览器能够认可该头，浏览器必须首先信任签发用于建立连接的 **证书颁发机构**（**CA**），而不仅仅是
    SSL 证书（[https://datatracker.ietf.org/doc/html/rfc6797](https://datatracker.ietf.org/doc/html/rfc6797)）。
- en: Once `mybank.example.com` is added as an HSTS host, a browser can know beforehand
    that any request to `mybank.example.com` should be interpreted as `https://mybank.example.com`.
    This greatly reduces the possibility of a **Man-in-the-Middle** (**MitM**) attack
    occurring.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `mybank.example.com` 被添加为 HSTS 主机，浏览器就可以事先知道对 `mybank.example.com` 的任何请求都应解释为
    `https://mybank.example.com`。这大大减少了中间人攻击（**MitM**）发生的可能性。
- en: 'One way for a site to be marked as an HSTS host is to have the host preloaded
    into the browser. Another is to add the `Strict-Transport-Security` header to
    the response. For example, the following would instruct the browser to treat the
    domain as an HSTS host for a year (there are approximately `31,536,000` seconds
    in a year):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网站被标记为 HSTS 主机的方法之一是将主机预先加载到浏览器中。另一种方法是向响应中添加 `Strict-Transport-Security`
    头。例如，以下指令将指导浏览器将域名视为 HSTS 主机一年（一年大约有 `31,536,000` 秒）：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The optional `includeSubDomains` directive instructs `Spring Security` that
    subdomains (such as `secure.mybank.example.com`) should also be treated as an
    HSTS domain.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的 `includeSubDomains` 指令指示 `Spring Security` 将子域名（例如 `secure.mybank.example.com`）也视为
    HSTS 域。
- en: The optional preload directive instructs the browser that the domain should
    be preloaded in the browser as an HSTS domain. For more details on HSTS preload,
    see [hstspreload.org](http://hstspreload.org).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'You can explicitly customize the results. The following example explicitly
    provides HSTS:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: HTTP Public Key Pinning (HPKP)
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Spring Security` provides servlet support for HPKP (see here: [https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-hpkp](https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-hpkp)),
    but it is no longer recommended ([https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-hpkp-deprecated](https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-hpkp-deprecated)).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'You can enable HPKP headers with the following configuration:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: X-Frame-Options
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Allowing your website to be added to a frame can be a security issue. For example,
    through the use of clever CSS styling, users could be tricked into clicking on
    something that they did not intend to.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: For example, a user who is logged in to their bank might click a button that
    grants access to other users. This sort of attack is known as **clickjacking**.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Read more about Clickjacking at [https://owasp.org/www-community/attacks/Clickjacking](https://owasp.org/www-community/attacks/Clickjacking).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Another modern approach to dealing with Clickjacking is using a **Content Security**
    **Policy** (**CSP**).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ways to mitigate Clickjacking attacks. For example, to
    protect legacy browsers from Clickjacking attacks, you can use frame-breaking
    code. While not perfect, frame-breaking code is the best you can do for legacy
    browsers.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'A more modern approach to address Clickjacking is to use the `X-Frame-Options`
    header, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you want to change the value for the `X-Frame-Options` header, then you can
    use an `XFrameOptionsHeaderWriter` instance.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Some browsers have built-in support for filtering out reflected XSS attacks.
    This is by no means foolproof, but it does assist with XSS protection.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Filtering is typically enabled by default, so adding the header just ensures
    that it is enabled and instructs the browser as to what to do when an XSS attack
    is detected. For example, the filter might try to change the content in the least
    invasive way to still render everything. At times, this type of replacement can
    become an XSS vulnerability. Instead, it is best to block the content, rather
    than attempt to fix it. To do this, we can add the following header:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: CSP
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Spring Security` does not add a CSP (https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-csp)
    by default, because a reasonable default is impossible to know without knowing
    the context of the application. The web application author must declare the security
    policy (or policies) to enforce or monitor them for the protected resources.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following security policy:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下安全策略：
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Given the preceding security policy, you can enable the CSP header:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的安全策略基础上，你可以启用CSP头部：
- en: '[PRE28]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To enable the CSP report-only header, provide the following configuration:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用CSP仅报告头部，请提供以下配置：
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Referrer Policy
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Referrer Policy
- en: '`Spring Security` does not add Referrer Policy ([https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-referrer](https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-referrer))
    headers by default. You can enable the `ReferrerPolicy` header by using this configuration:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring Security`默认不添加Referrer Policy ([https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-referrer](https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-referrer))头部。你可以通过以下配置启用`ReferrerPolicy`头部：'
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Feature Policy
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能策略
- en: '`Spring Security` does not add Feature Policy (https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-feature)
    headers by default. Consider the following `Feature-Policy` header:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring Security`默认不添加Feature Policy (https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-feature)头部。考虑以下`Feature-Policy`头部：'
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can enable the preceding feature policy header by using the following configuration:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下配置启用前面的功能策略头部：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Permissions Policy
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 权限策略
- en: '`Spring Security` does not add Permissions Policy ([https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-permissions](https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-permissions))
    headers by default. Consider the following `Permissions-Policy` header:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring Security`默认不添加Permissions Policy ([https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-permissions](https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-permissions))头部。考虑以下`Permissions-Policy`头部：'
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can enable the preceding permissions policy header using the following
    configuration:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下配置启用前面的权限策略头部：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Clear Site Data
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清除站点数据
- en: '`Spring Security` does not add `Clear-Site-Data` (https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-clear-site-data)
    headers by default. Consider the following `Clear-Site-Data` header:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring Security`默认不添加`Clear-Site-Data` (https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-clear-site-data)头部。考虑以下`Clear-Site-Data`头部：'
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can send the preceding header to logout function with the following configuration:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下配置将前面的头部发送到注销功能：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Static headers
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态头部
- en: 'There may be times when you wish to inject custom security headers into your
    application that are not supported out of the box. For example, perhaps you wish
    to have early support for a CSP to ensure that resources are only loaded from
    the same origin. Since support for a CSP has not been finalized, browsers use
    one of two common extension headers to implement the feature. This means we will
    need to inject the policy twice. An example of the headers can be seen in the
    following code snippet:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能希望向你的应用程序注入自定义的安全头部，这些头部不是默认支持的。例如，你可能希望对CSP有早期支持，以确保资源只从同源加载。由于CSP的支持尚未最终确定，浏览器使用两种常见的扩展头部之一来实现该功能。这意味着我们需要注入策略两次。以下代码片段显示了头部的示例：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When using Java configuration, these headers can be added to the response using
    the `header()` method, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Java配置时，这些头部可以通过`header()`方法添加到响应中，如下所示：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The HeadersWriter instance
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HeadersWriter实例
- en: When the namespace or Java configuration does not support the headers you want,
    you can create a custom `HeadersWriter` instance or even provide a custom implementation
    of `HeadersWriter`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当命名空间或Java配置不支持你想要的头部时，你可以创建一个自定义的`HeadersWriter`实例，甚至提供`HeadersWriter`的自定义实现。
- en: 'Let’s look at an example of using a custom instance of `XFrameOptionsHeaderWriter`.
    Perhaps you want to allow the framing of content for the same origin. This is
    easily supported by setting the policy attribute to `SAMEORIGIN`, but let’s look
    at a more explicit example using the `ref` attribute, as shown in the following
    code snippet:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用自定义`XFrameOptionsHeaderWriter`实例的例子。也许你想允许同源内容的框架。这可以通过将策略属性设置为`SAMEORIGIN`轻松实现，但让我们看看使用`ref`属性的一个更明确的例子，如下面的代码片段所示：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The DelegatingRequestMatcherHeaderWriter class
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DelegatingRequestMatcherHeaderWriter类
- en: 'At times, you may want to only write a header for certain requests. For example,
    perhaps you want to only protect your login page from being framed. You could
    use the `DelegatingRequestMatcherHeaderWriter` class to do so. When using Java
    configuration, this can be done with the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能只想为某些请求编写标题。例如，也许您只想保护您的登录页面不被框架化。您可以使用 `DelegatingRequestMatcherHeaderWriter`
    类来实现这一点。当使用 Java 配置时，可以通过以下代码完成：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To summarize this section, you can add `CSRF` protection based on `DelegatingRequestMatcherHeaderWriter`,
    explicit `Clear-Site-Data`, frame options, static headers, and `DelegatingRequestMatcherHeaderWriter`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 总结本节，您可以通过 `DelegatingRequestMatcherHeaderWriter`、显式 `Clear-Site-Data`、框架选项、静态标题和
    `DelegatingRequestMatcherHeaderWriter` 添加 `CSRF` 保护。
- en: Important note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter15.02-calendar`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应类似于 `chapter15.02-calendar`。
- en: Testing Spring Security Applications
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Spring Security 应用程序
- en: In addition to `spring-boot-starter-test`, `Spring Security` provides an artifact
    tailored specifically for testing purposes. Its primary purpose is to provide
    utilities and classes that assist developers in writing tests for applications
    that use `Spring Security` for authentication and authorization.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `spring-boot-starter-test`，`Spring Security` 还提供了一个专门针对测试目的的工件。其主要目的是提供实用工具和类，帮助开发者编写使用
    `Spring Security` 进行身份验证和授权的应用程序的测试。
- en: 'Some of the key functionalities provided by `org.springframework.security:spring-security-test`
    include:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.springframework.security:spring-security-test` 提供的一些关键功能包括：'
- en: '**Mocking Authentication**: It allows you to easily mock authentication and
    authorization contexts during testing, enabling you to simulate different user
    roles and permissions.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟身份验证**：它允许您在测试期间轻松模拟身份验证和授权上下文，使您能够模拟不同的用户角色和权限。'
- en: '**Integration Testing**: It provides support for integration testing by offering
    utilities for setting up security configurations in your test environment, ensuring
    that your security configurations are correctly applied and tested.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：它通过提供设置测试环境中安全配置的实用工具来支持集成测试，确保您的安全配置得到正确应用和测试。'
- en: '`Spring Security` often involves configuring a chain of filters to handle authentication
    and authorization tasks. This module provides utilities to test these filters
    in isolation or as part of the filter chain.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Spring Security` 通常涉及配置一系列过滤器来处理身份验证和授权任务。此模块提供了测试这些过滤器单独或作为过滤器链一部分的实用工具。'
- en: 'To get started, you need to include the following dependencies in your `Spring`
    `Security` project:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，您需要在您的 `Spring` `Security` 项目中包含以下依赖项：
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: By using `spring-security-test`, you can effectively test the security features
    of the applications, ensuring that sensitive resources are properly protected
    and accessible only to authorized users.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `spring-security-test`，您可以有效地测试应用程序的安全功能，确保敏感资源得到适当的保护，并且仅对授权用户可访问。
- en: Reactive Applications Support
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式应用程序支持
- en: Reactive programming revolves around asynchronous and non-blocking interactions,
    characterized by callback and declarative approaches. It incorporates a backpressure
    mechanism to regulate the throughput from the producer, aiding in consumer control.
    In Java, Reactive programming relies on `Streams`, `CompletableFuture`, and backpressure
    controls. There exist numerous relevant use cases where reactive programming proves
    beneficial, including supporting high peak workloads, microservices, contention
    avoidance, IoT and Big Data applications.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程围绕异步和非阻塞交互展开，以回调和声明式方法为特征。它包含一个背压机制来调节生产者的吞吐量，有助于消费者控制。在 Java 中，反应式编程依赖于
    `Streams`、`CompletableFuture` 和背压控制。存在许多相关的用例，其中反应式编程证明是有益的，包括支持高峰工作量、微服务、避免竞争、物联网和大数据应用程序。
- en: Spring relies on the project reactor([https://projectreactor.io/](https://projectreactor.io/))
    that is the f foundation of `Spring` `Webflux` ([https://docs.spring.io/spring-framework/reference/web/webflux.xhtml](https://docs.spring.io/spring-framework/reference/web/webflux.xhtml)).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 依赖于项目 reactor([https://projectreactor.io/](https://projectreactor.io/))，这是
    `Spring` `Webflux` ([https://docs.spring.io/spring-framework/reference/web/webflux.xhtml](https://docs.spring.io/spring-framework/reference/web/webflux.xhtml))
    的基础。
- en: 'To add `Spring Security` reactive support into your Spring Boot project, you
    need to include `spring-boot-starter-security` and `spring-boot-starter-webflux`
    dependencies in your projects:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `Spring Security` 反应式支持添加到您的 Spring Boot 项目中，您需要在项目中包含 `spring-boot-starter-security`
    和 `spring-boot-starter-webflux` 依赖项：
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This table provides an overview of key classes to facilitate the transition
    from the Spring Security Servlet implementation to the Spring Security Reactive
    implementation.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此表概述了关键类，以帮助从 Spring Security Servlet 实现过渡到 Spring Security 反应式实现。
- en: '| **Spring Security****Servlet implementation** | **Spring Security****Reactive
    implementation** |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| **Spring Security****Servlet implementation** | **Spring Security****Reactive
    implementation** |'
- en: '| --- | --- |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `o.s.s.w.SecurityFilterChain` | `o.s.s.w.s.Security WebFilterChain` |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `o.s.s.w.SecurityFilterChain` | `o.s.s.w.s.Security WebFilterChain` |'
- en: '| `o.s.s.c.u.UserDetailsService` | `o.s.s.c.u. ReactiveUserDetailsService`
    |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `o.s.s.c.u.UserDetailsService` | `o.s.s.c.u. ReactiveUserDetailsService`
    |'
- en: '| `o.s.s.c.a.w.b.HttpSecurity` | `o.s.s.c.w.s.ServerHttpSecurity` |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `o.s.s.c.a.w.b.HttpSecurity` | `o.s.s.c.w.s.ServerHttpSecurity` |'
- en: '| `o.s.s.c.c. SecurityContextHolder` | `o.s.s.c.c. ReactiveSecurityContextHolder`
    |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `o.s.s.c.c. SecurityContextHolder` | `o.s.s.c.c. ReactiveSecurityContextHolder`
    |'
- en: '| `o.s.s.a.AuthenticationManager` | `o.s.s.a.ReactiveAuthentication Manager`
    |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `o.s.s.a.AuthenticationManager` | `o.s.s.a.ReactiveAuthentication Manager`
    |'
- en: '| `o.s.s.c.a.w.c.EnableWebSecurity` | `o.s.s.c.a.m.r. EnableWeb``FluxSecurity`
    |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `o.s.s.c.a.w.c.EnableWebSecurity` | `o.s.s.c.a.m.r. EnableWeb``FluxSecurity`
    |'
- en: '| `o.s.s.c.a.m.c. EnableMethodSecurity` | `o.s.s.c.a.m.c.EnableReactive MethodSecurity`
    |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `o.s.s.c.a.m.c. EnableMethodSecurity` | `o.s.s.c.a.m.c.EnableReactive MethodSecurity`
    |'
- en: '| `o.s.s.p.InMemoryUser DetailsManager` | `o.s.s.c.u. MapReactiveUserDetailsService`
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `o.s.s.p.InMemoryUser DetailsManager` | `o.s.s.c.u. MapReactiveUserDetailsService`
    |'
- en: '| `o.s.s.o.c.OAuth2Authorized ClientManager` | `o.s.s.o.c.ReactiveOAuth2 AuthorizedClientManager`
    |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `o.s.s.o.c.OAuth2Authorized ClientManager` | `o.s.s.o.c.ReactiveOAuth2 AuthorizedClientManager`
    |'
- en: '| `o.s.s.o.c. OAuth2Authorized``ClientProvider` | `o.s.s.o.c.ReactiveOAuth2
    AuthorizedClientProvider` |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `o.s.s.o.c. OAuth2Authorized``ClientProvider` | `o.s.s.o.c.ReactiveOAuth2
    AuthorizedClientProvider` |'
- en: '| `o.s.s.o.c.w.DefaultOAuth2Authorized ClientManager` | `o.s.s.o.c.w.DefaultReactiveO
    Auth2AuthorizedClientManager` |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `o.s.s.o.c.w.DefaultOAuth2Authorized ClientManager` | `o.s.s.o.c.w.DefaultReactiveO
    Auth2AuthorizedClientManager` |'
- en: '| `o.s.s.o.c.r.ClientRegistration Repository` | `o.s.s.o.c.r.ReactiveClient
    RegistrationRepository` |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `o.s.s.o.c.r.ClientRegistration Repository` | `o.s.s.o.c.r.ReactiveClient
    RegistrationRepository` |'
- en: '| `o.s.s.o.c.e. OAuth2Access``TokenResponseClient` | `o.s.s.o.c.e.ReactiveOAuth2
    AccessTokenResponseClient` |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `o.s.s.o.c.e. OAuth2Access``TokenResponseClient` | `o.s.s.o.c.e.ReactiveOAuth2
    AccessTokenResponseClient` |'
- en: '| `o.s.s.o.j.JwtDecoder` | `o.s.s.o.j.ReactiveJwtDecoder` |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `o.s.s.o.j.JwtDecoder` | `o.s.s.o.j.ReactiveJwtDecoder` |'
- en: Table 15.1 – Transitioning from Spring Security Servlet to Reactive Implementation
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15.1 – 从 Spring Security Servlet 实现过渡到反应式实现
- en: Important note
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In this section, we provide a fully functional reactive implementation available
    in `chapter15.03-calendar`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们提供了一个在 `chapter15.03-calendar` 中可用的完整功能反应式实现。
- en: 'You will notice the following main changes in to enable reactive support:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你将注意到以下主要变化以启用反应式支持：
- en: 'Configure `Spring Security` to use our custom `ReactiveUserDetailsService`
    object, as follow:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤配置 `Spring Security` 以使用我们的自定义 `ReactiveUserDetailsService` 对象：
- en: '[PRE43]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Use `@EnableWebFluxSecurity` annotation, to enable Spring Security reactive
    support:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `@EnableWebFluxSecurity` 注解，以启用 Spring Security 的反应式支持：
- en: '[PRE44]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Define a `ReactiveAuthenticationManager` bean:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 `ReactiveAuthenticationManager` 实例：
- en: '[PRE45]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create the `SecurityWebFilterChain` bean:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `SecurityWebFilterChain` 实例：
- en: '[PRE46]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Launch the application and try to access it through `http://localhost:8080`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序并尝试通过 `http://localhost:8080` 访问它。
- en: You should be able to log in with the configured users `admin1@example.com/admin1`
    or `user1@example.com/user1` and test the events creation.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够使用配置的用户 `admin1@example.com/admin1` 或 `user1@example.com/user1` 登录并测试事件创建。
- en: Furthermore, creating a new user enables immediate login with the newly created
    credentials.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，创建新用户可以立即使用新创建的凭据登录。
- en: In summary, `Spring Security` also provide a reactive implementation. This implementation
    is best suited for applications that require handling a large number of concurrent
    connections, high scalability, and efficient resource utilization. It’s particularly
    beneficial in scenarios involving non-blocking I/O operations, such as web applications
    with heavy user traffic or real-time data processing.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`Spring Security` 也提供了一个反应式实现。这个实现最适合需要处理大量并发连接、高可扩展性和高效资源利用的应用程序。它在涉及非阻塞
    I/O 操作的场景中特别有益，例如用户流量大的Web应用程序或实时数据处理。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered several security vulnerabilities, as well as employing
    `Spring Security` to circumvent those vulnerabilities. After reading this chapter,
    you should understand the threat of CSRF and the use of *synchronizer token* pattern
    to prevent CSRF.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了几个安全漏洞，以及如何使用 `Spring Security` 来规避这些漏洞。阅读本章后，你应该理解 CSRF 的威胁以及使用 *同步器令牌*
    模式来防止 CSRF 的方法。
- en: You should also know how to include various HTTP headers to protect against
    common security vulnerabilities using the *Cache-Control*, *Content-Type Options*,
    *HSTS*, *X-Frame-Options*, and *X-XSS-Protection* methods.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该了解如何使用 *Cache-Control*、*Content-Type Options*、*HSTS*、*X-Frame-Options* 和
    *X-XSS-Protection* 方法来包含各种 HTTP 头，以防范常见的安全漏洞。
- en: In the next chapter, we will discuss how to migrate to **Spring** **Security
    6.x**.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何迁移到 **Spring Security 6.x**。
