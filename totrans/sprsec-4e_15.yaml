- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Additional Spring Security Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore several additional `Spring Security` features
    that we have not covered so far in this book, including the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cross-Site** **Scripting** (**XSS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-Site Request** **Forgery** (**CSRF**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizer token pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clickjacking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Spring Security Applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive Applications support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will understand how to include various HTTP headers to protect against common
    security vulnerabilities, using the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Cache-Control`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content-Type Options`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP Strict Transport` `Security (HSTS)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Frame-Options`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-XSS-Protection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before you read this chapter, you should already understand how `Spring Security`
    works. This means you should already be able to set up authentication and authorization
    in a simple web application. If you are unable to do this, you will want to ensure
    you have read up to [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068), *Custom Authentication*,
    before proceeding with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter’s code in action link is here: [https://packt.link/aXvKi](https://packt.link/aXvKi).'
  prefs: []
  type: TYPE_NORMAL
- en: Security vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the age of the internet, there is a multitude of possible vulnerabilities
    that can be exploited. A great resource to learn more about web-based vulnerabilities
    is the **Open Web Application Security Project** (**OWASP**), which is located
    at [https://owasp.org](https://owasp.org).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to being a great resource to understand various vulnerabilities,
    OWASP categorizes the top 10 vulnerabilities based on industry trends.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-site scripting** or **XSS** attacks involve malicious scripts that
    have been injected into a trusted site.'
  prefs: []
  type: TYPE_NORMAL
- en: XSS attacks occur when an attacker exploits a given web application that allows
    unventilated input to be sent to the site, generally in the form of browser-based
    scripts, which are then executed by a different user of the website.
  prefs: []
  type: TYPE_NORMAL
- en: There are many forms that attackers can exploit, based on validated or unencoded
    information provided to websites.
  prefs: []
  type: TYPE_NORMAL
- en: 'XSS can be described by the following sequence diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 – Cross-Site Scripting (XSS)](img/B21757_15_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 – Cross-Site Scripting (XSS)
  prefs: []
  type: TYPE_NORMAL
- en: At the core of this issue is expecting a user to trust the site’s information
    that is being sent. The end user’s browser has no way of knowing that the script
    should not be trusted because there is implicit trust in the website they’re browsing.
    Because the end user thinks the script came from a trusted source, the malicious
    script can access any cookies, session tokens, or other sensitive information
    retained by the browser and used with that website.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Request Forgery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-site request forgery** (**CSRF**) is an attack that tricks the victim
    into submitting a malicious request. This type of attack inherits or hijacks the
    identity and privileges of the victim and performs unauthorized functions and
    gains access on the victim’s behalf.'
  prefs: []
  type: TYPE_NORMAL
- en: For web applications, most browsers automatically include credentials associated
    with the site, which includes a user session, cookie, IP address, Windows domain
    credentials, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: So, if a user is currently authenticated on a site, that given site will have
    no way to distinguish between the forged request sent by the victim and a legitimate
    request.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF attacks target functionality that causes a state change on the server,
    such as changing the victim’s email address or password, or engaging in a financial
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: This forces the victim to retrieve data that doesn’t benefit an attacker because
    the attacker does not receive the response; the victim does. Thus, CSRF attacks
    target state-changing requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sequence diagram details how a CSRF attack would occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2 – CSRF](img/B21757_15_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.2 – CSRF
  prefs: []
  type: TYPE_NORMAL
- en: There are several different design measures that may be taken to attempt to
    prevent CSRF; however, measures such as secret cookies, `HTTP POST` requests,
    multistep transactions, URL rewriting, and `HTTPS` in no way prevent this type
    of attack.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: OWASP’s top 10 security vulnerabilities list details CSRF as the eighth most
    common attack at [https://owasp.org/www-community/attacks/csrf](https://owasp.org/www-community/attacks/csrf).
  prefs: []
  type: TYPE_NORMAL
- en: In summary, CSRF is the general concept of an attack where a user is tricked
    into performing unintended actions. In the next section, we will explore the `Synchronizer
    Tokens pattern`, which is a specific method used to mitigate CSRF attacks by using
    unique tokens associated with each user session.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizer token pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution to CSRF is to use the **synchronizer token** pattern. This solution
    ensures that each request requires, in addition to our session cookie, a randomly
    generated token as an HTTP parameter. When a request is submitted, the server
    must look up the expected value for the parameter and compare it to the actual
    value in the request. If the values do not match, the request should fail.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Cross-Site Request Forgery Prevention Cheat Sheet* recommends the `synchronizer
    token` pattern as a viable solution for CSRF attacks: [https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.xhtml#General_Recommendation:_%20Synchronizer_Token_Pattern](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.xhtml#General_Recommendation:_%20Synchronizer_Token_Pattern).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at how our example would change. Assume the randomly generated token
    is present in an HTTP parameter named `_csrf`. For example, the request to transfer
    money would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that we added the `_csrf` parameter with a random value. Now,
    the malicious website will not be able to guess the correct value for the `_csrf`
    parameter (which must be explicitly provided on the malicious website), and the
    transfer will fail when the server compares the actual token to the expected token.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a standard use case for a `synchronizer` `token`
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3 – Synchronizer token pattern](img/B21757_15_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.3 – Synchronizer token pattern
  prefs: []
  type: TYPE_NORMAL
- en: '`Spring Security` provides `synchronizer token` support that is turned on by
    default. You might have noticed from the previous chapters that in our `SecurityConfig.java`
    file, we disabled CSRF protection, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Up to this point in the book, we have disabled `synchronizer token` protection
    so that we can focus on other security concerns.
  prefs: []
  type: TYPE_NORMAL
- en: If we start the application at this point, and there will be no `synchronizer
    token` support added to any of the pages.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter15.00-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: After exploring the `synchronizer token` pattern, we will explore when to use
    CSRF protection.
  prefs: []
  type: TYPE_NORMAL
- en: When to use CSRF protection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is recommended you use CSRF protection for any request that could be processed
    by a browser or normal users. If you are only creating a service that is used
    by non-browser clients, you will most likely want to disable CSRF protection.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF protection and JSON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common question is, do I need to protect JSON requests made by JavaScript?
    The short answer is, it depends. However, you must be very careful, as there are
    CSRF exploits that can impact JSON requests. For example, a malicious user can
    create a CSRF with JSON using the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following JSON structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If an application were not validating the `Content-Type` method, then it would
    be exposed to this exploit. Depending on the setup, a Spring MVC application that
    validates the `Content- Type` method could still be exploited by updating the
    URL suffix to end with `.json`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have explored CSRF protection and JSON. In the next section,
    we will cover CSRF and stateless browser applications.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF and stateless browser applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What if your application is stateless? That doesn’t necessarily mean you are
    protected. In fact, if a user does not need to perform any actions in the web
    browser for a given request, they are likely still vulnerable to CSRF attacks.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider an application using a custom cookie that contains all
    of the states within it for authentication instead of the `JSESSIONID` cookie.
    When the CSRF attack happens, the custom cookie will be sent with the request
    in the same manner that the `JSESSIONID` cookie was sent in our previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Users using basic authentication are also vulnerable to CSRF attacks, since
    the browser will automatically include the username and password in any requests,
    in the same manner, that the `JSESSIONID` cookie was sent in our previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring Security CSRF protection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, what are the steps necessary to use `Spring Security` to protect our site
    against CSRF attacks? The steps for using `Spring Security`’s CSRF protection
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use proper HTTP verbs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure CSRF protection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the CSRF token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s understand these steps better now.
  prefs: []
  type: TYPE_NORMAL
- en: Using proper HTTP verbs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first step to protecting against CSRF attacks is to ensure that your website
    uses proper `HTTP` verbs. Specifically, before `Spring Security`’s CSRF support
    can be of use, you need to be certain that your application uses `PATCH`, `POST`,
    `PUT`, and/or `DELETE` for anything that modifies state.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a limitation of `Spring Security`’s support but, instead, a general
    requirement for proper `CSRF` prevention. The reason is that including private
    information in an `HTTP GET` method can cause the information to be leaked.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to *RFC 2616, Section 15.1.3*, *Encoding Sensitive Information in URI’s*,
    for general guidance on using `POST` instead of `GET` for sensitive information
    ([https://www.rfc-editor.org/rfc/rfc2616.xhtml#section-15.1.3](https://www.rfc-editor.org/rfc/rfc2616.xhtml#section-15.1.3)).
  prefs: []
  type: TYPE_NORMAL
- en: Conﬁguring CSRF protection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next step is to include `Spring Security`’s CSRF protection within your
    application. Some frameworks handle invalid CSRF tokens by invaliding the user’s
    session, but this causes its own problems. Instead, by default, `Spring Security`’s
    CSRF protection will produce `HTTP 403 access denied`. This can be customized
    by configuring `AccessDeniedHandler` to process `InvalidCsrfTokenException` differently.
  prefs: []
  type: TYPE_NORMAL
- en: For passivity reasons, if you are using the `XML` configuration, CSRF protection
    must be explicitly enabled using the `<csrf>` element. Refer to the `<csrf>` element’s
    documentation for additional customizations.
  prefs: []
  type: TYPE_NORMAL
- en: Default CSRF support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CSRF protection is enabled by default with Java configuration. Refer to the
    Java documentation of `csrf()` for additional customizations regarding how CSRF
    protection is configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to be verbose in this configuration, we are going to add the CSRF method
    to our `SecurityConfig.java` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To have access to the H2 console, CSRF needs to be disabled, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After configuring CSRF in the `Spring Security` `SecurityFilterChain` bean,
    we will see how we can enable the support in web forms.
  prefs: []
  type: TYPE_NORMAL
- en: Including the CSRF token in the <form> submissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last step is to ensure that you include the CSRF token in all `PATCH`,
    `POST`, `PUT`, and `DELETE` methods. One way to approach this is to use the `_csrf`
    request attribute to obtain the current `CsrfToken` token. An example of doing
    this with a **Java Server Page** (**JSP**) is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After including the CSRF token in the `<form>`, we will explore another option
    by including the CSRF token based on `Spring Security` JSP tags.
  prefs: []
  type: TYPE_NORMAL
- en: Including the CSRF token using the Spring Security JSP tag library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If CSRF protection is enabled, the `Spring Security` tag inserts a hidden form
    field with the correct name and value for the CSRF protection token. If CSRF protection
    is not enabled, this tag has no output.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, `Spring Security` automatically inserts a CSRF form field for any
    `<form:form>` tags you use, but if for some reason you cannot use `<form:form>`,
    `csrfInput` is a handy replacement.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should place this tag within an `HTML <form></form>` block, where you would
    normally place other input fields. Do not place this tag within a Spring `<form:form></form:form>`
    block. `Spring Security` handles Spring forms automatically, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Default CSRF token support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using the Spring MVC `<form:form>` tag, or `Thymeleaf 2.1+`, and
    you are also using `@EnableWebSecurity`, the `CsrfToken` token is automatically
    included for you (using the `CsrfRequestDataValue` token we have been processing).
  prefs: []
  type: TYPE_NORMAL
- en: So, for this book, we have been using *Thymeleaf* for all of our web pages.
    Thymeleaf has CSRF support enabled by default if we enable CSRF support in `Spring
    Security`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `logout` link will not work with CSRF support enabled and needs to be replaced
    by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter15.01-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we start up the JBCP calendar application and navigate to the login page
    at `http://localhost:8080/login.xhtml`, we can view the generated source for the
    `login.xhtml` page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Ajax and JavaScript requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are using JSON, then it is not possible to submit the CSRF token within
    an HTTP parameter. Instead, you can submit the token within an HTTP header. A
    typical pattern would be to include the CSRF token within your `<meta>` HTML tags.
    An example with a JSP is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Instead of manually creating the meta tags, you can use the simpler `csrfMetaTags`
    tag from the `Spring Security` JSP tag library.
  prefs: []
  type: TYPE_NORMAL
- en: The csrfMetaTags tag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If CSRF protection is enabled, this tag inserts meta tags containing the CSRF
    protection token form field, header names, and CSRF protection token value. These
    meta tags are useful for employing CSRF protection within JavaScript in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should place the `csrfMetaTags` tag within an HTML `<head></head>` block,
    where you would normally place other meta tags. Once you use this tag, you can
    access the form field name, header name, and token value easily using JavaScript,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If CSRF protection is not enabled, `csrfMetaTags` outputs nothing.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can then include the token within all of your Ajax requests. If you were
    using jQuery, this could be done with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After exploring the default CSRF configuration, we will conclude with some CSRF
    caveats.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF caveats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few caveats when implementing CSRF in `Spring Security` that you
    need to be aware of. Let us see these caveats in the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: Timeouts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One issue is that the expected CSRF token is stored in the `HttpSession` method,
    so as soon as the `HttpSession` method expires, your configured `AccessDeniedHandler`
    handler will receive `InvalidCsrfTokenException`. If you are using the default
    `AccessDeniedHandler` handler, the browser will get an `HTTP 403` and display
    a poor error message.
  prefs: []
  type: TYPE_NORMAL
- en: Another disadvantage is that by removing the state (the timeout), you lose the
    ability to forcibly terminate the token if something is compromised.
  prefs: []
  type: TYPE_NORMAL
- en: A simple way to mitigate an active user experiencing a timeout is to have some
    JavaScript that lets the user know their session is about to expire. The user
    can click a button to continue and refresh the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, specifying a custom `AccessDeniedHandler` handler allows you
    to process `InvalidCsrfTokenException` any way you like, as we can see in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Logging in
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To protect against forged login requests, the login form should be protected
    against CSRF attacks, too. Since the `CsrfToken` token is stored in `HttpSession`,
    this means an `HttpSession` method will be created as soon as the `CsrfToken`
    attribute is accessed.
  prefs: []
  type: TYPE_NORMAL
- en: While this sounds bad in a RESTful/stateless architecture, the reality is that
    the state is necessary to implement practical security. Without the state, we
    have nothing we can do if a token is compromised. Practically speaking, the CSRF
    token is quite small in size and should have a negligible impact on our architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: An attacker may forge a request to log the victim into a target website using
    the attacker’s credentials; this is known as login CSRF ([https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests)).
  prefs: []
  type: TYPE_NORMAL
- en: Logging out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding CSRF will update the `LogoutFilter` filter to only use `HTTP POST`. This
    ensures that logging out requires a CSRF token and that a malicious user cannot
    forcibly log out your users.
  prefs: []
  type: TYPE_NORMAL
- en: One approach to prevent CSRF attacks is to use a `<form>` tag for logout. If
    you want an `HTML` link, you can use JavaScript to have the link perform an `HTTP
    POST` (which can be in a hidden form). For browsers with JavaScript disabled,
    you can optionally have the link take the user to a logout confirmation page that
    will perform the `HTTP POST`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use `HTTP GET` with logout, you can do so, but remember, this
    is generally not recommended. For example, the following Java configuration will
    perform logout when the logout URL pattern is requested with any `HTTP` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we’ve discussed CSRF now, let’s delve into securing HTTP response
    headers.
  prefs: []
  type: TYPE_NORMAL
- en: Security HTTP response headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following sections discuss `Spring Security`’s support for adding various
    security headers to the response.
  prefs: []
  type: TYPE_NORMAL
- en: '`Spring Security` allows users to easily inject default security headers to
    assist in protecting their applications. The following is a list of the current
    default security headers provided by `Spring Security`:'
  prefs: []
  type: TYPE_NORMAL
- en: Cache-Control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content-Type Options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP Strict Transport Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X-Frame-Options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X-XSS-Protection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While each of these headers is considered best practice, it should be noted
    that not all clients utilize these headers, so additional testing is encouraged.
    For passivity reasons, if you are using `Spring Security`’s `XML namespace` support,
    you must explicitly enable the security headers. All of the default headers can
    be easily added using the `<headers>` element with no child elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using `Spring Security`’s Java configuration, all of the default
    security headers are added by default. They can be disabled using Java configuration,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `Spring Security` instructs browsers to disable the XSS Auditor
    by using `<headers-xss-protection,X-XSS-Protection header>`. You can disable the
    `X-XSS-Protection` header entirely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also set the header value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you specify any headers that should be included, then only those
    headers will be included. For example, the following configuration will include
    support for `X-Frame-Options` only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Cache-Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the past, `Spring Security` required you to provide your own `Cache-Control`
    method for your web application. This seemed reasonable at the time, but browser
    caches have evolved to include caches for secure connections as well. This means
    that a user may view an authenticated page and log out, and then a malicious user
    can use the browser history to view the cached page.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help mitigate this, `Spring Security` has added `Cache-Control` support,
    which will insert the following headers into your response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To be secure, `Spring Security` adds these headers by default. However, if your
    application provides its own cache control headers, `Spring Security` will rely
    on your own application headers only. This allows for applications to ensure that
    static resources (such as CSS and JavaScript) can be cached.
  prefs: []
  type: TYPE_NORMAL
- en: Content-Type Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Historically, browsers, including Internet Explorer, would try to guess the
    content type of a request using content sniffing. This allowed browsers to improve
    the user experience by guessing the content type of resources that had not specified
    the content type. For example, if a browser encountered a JavaScript file that
    did not have the content type specified, it would be able to guess the content
    type and then execute it.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: There are many additional things one should do, such as only displaying the
    document in a distinct domain, ensuring the `Content-Type` header is set, sanitizing
    the document, and so on, when allowing content to be uploaded. However, these
    measures are out of the scope of what `Spring Security` provides. It is also important
    to point out that when disabling content sniffing, you must specify the content
    type for things to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with content sniffing is that this allows malicious users to use
    *polyglots* (a file that is valid as multiple content types) to execute XSS attacks.
    For example, some sites may allow users to submit a valid PostScript document
    to a website and view it. A malicious user might create a PostScript document
    that is also a valid JavaScript file and execute an XSS attack with it ([http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf](http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Content sniffing can be disabled by adding the following header to our response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By default, `Spring Security` disables content sniffing by adding this header
    to HTTP responses.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Strict Transport Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you type in your bank’s website, do you enter `mybank.example.com`, or
    do you enter `https://mybank.example.com`? If you omit the HTTPS protocol, you
    are potentially vulnerable to `https://mybank.example.com`, a malicious user could
    intercept the initial HTTP request and manipulate the response (redirect to `https://mibank.example.com`
    and steal your credentials).
  prefs: []
  type: TYPE_NORMAL
- en: Many users omit the HTTPS protocol, and this is why `HSTS` was created.
  prefs: []
  type: TYPE_NORMAL
- en: In accordance with `RFC6797`, the `HSTS` header is only injected into `HTTPS`
    responses. In order for the browser to acknowledge the header, the browser must
    first trust the **certificate authority** (**CA**) that signed the **Secure Sockets
    Layer** (**SSL**) certificate used to make the connection, not just the SSL certificate
    ([https://datatracker.ietf.org/doc/html/rfc6797](https://datatracker.ietf.org/doc/html/rfc6797)).
  prefs: []
  type: TYPE_NORMAL
- en: Once `mybank.example.com` is added as an HSTS host, a browser can know beforehand
    that any request to `mybank.example.com` should be interpreted as `https://mybank.example.com`.
    This greatly reduces the possibility of a **Man-in-the-Middle** (**MitM**) attack
    occurring.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way for a site to be marked as an HSTS host is to have the host preloaded
    into the browser. Another is to add the `Strict-Transport-Security` header to
    the response. For example, the following would instruct the browser to treat the
    domain as an HSTS host for a year (there are approximately `31,536,000` seconds
    in a year):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The optional `includeSubDomains` directive instructs `Spring Security` that
    subdomains (such as `secure.mybank.example.com`) should also be treated as an
    HSTS domain.
  prefs: []
  type: TYPE_NORMAL
- en: The optional preload directive instructs the browser that the domain should
    be preloaded in the browser as an HSTS domain. For more details on HSTS preload,
    see [hstspreload.org](http://hstspreload.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can explicitly customize the results. The following example explicitly
    provides HSTS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: HTTP Public Key Pinning (HPKP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Spring Security` provides servlet support for HPKP (see here: [https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-hpkp](https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-hpkp)),
    but it is no longer recommended ([https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-hpkp-deprecated](https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-hpkp-deprecated)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can enable HPKP headers with the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: X-Frame-Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Allowing your website to be added to a frame can be a security issue. For example,
    through the use of clever CSS styling, users could be tricked into clicking on
    something that they did not intend to.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a user who is logged in to their bank might click a button that
    grants access to other users. This sort of attack is known as **clickjacking**.
  prefs: []
  type: TYPE_NORMAL
- en: Read more about Clickjacking at [https://owasp.org/www-community/attacks/Clickjacking](https://owasp.org/www-community/attacks/Clickjacking).
  prefs: []
  type: TYPE_NORMAL
- en: Another modern approach to dealing with Clickjacking is using a **Content Security**
    **Policy** (**CSP**).
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ways to mitigate Clickjacking attacks. For example, to
    protect legacy browsers from Clickjacking attacks, you can use frame-breaking
    code. While not perfect, frame-breaking code is the best you can do for legacy
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more modern approach to address Clickjacking is to use the `X-Frame-Options`
    header, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you want to change the value for the `X-Frame-Options` header, then you can
    use an `XFrameOptionsHeaderWriter` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Some browsers have built-in support for filtering out reflected XSS attacks.
    This is by no means foolproof, but it does assist with XSS protection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Filtering is typically enabled by default, so adding the header just ensures
    that it is enabled and instructs the browser as to what to do when an XSS attack
    is detected. For example, the filter might try to change the content in the least
    invasive way to still render everything. At times, this type of replacement can
    become an XSS vulnerability. Instead, it is best to block the content, rather
    than attempt to fix it. To do this, we can add the following header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: CSP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Spring Security` does not add a CSP (https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-csp)
    by default, because a reasonable default is impossible to know without knowing
    the context of the application. The web application author must declare the security
    policy (or policies) to enforce or monitor them for the protected resources.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following security policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the preceding security policy, you can enable the CSP header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable the CSP report-only header, provide the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Referrer Policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Spring Security` does not add Referrer Policy ([https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-referrer](https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-referrer))
    headers by default. You can enable the `ReferrerPolicy` header by using this configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Feature Policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Spring Security` does not add Feature Policy (https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-feature)
    headers by default. Consider the following `Feature-Policy` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can enable the preceding feature policy header by using the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Permissions Policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Spring Security` does not add Permissions Policy ([https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-permissions](https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-permissions))
    headers by default. Consider the following `Permissions-Policy` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can enable the preceding permissions policy header using the following
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Clear Site Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Spring Security` does not add `Clear-Site-Data` (https://docs.spring.io/spring-security/reference/features/exploits/headers.xhtml#headers-clear-site-data)
    headers by default. Consider the following `Clear-Site-Data` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can send the preceding header to logout function with the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Static headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There may be times when you wish to inject custom security headers into your
    application that are not supported out of the box. For example, perhaps you wish
    to have early support for a CSP to ensure that resources are only loaded from
    the same origin. Since support for a CSP has not been finalized, browsers use
    one of two common extension headers to implement the feature. This means we will
    need to inject the policy twice. An example of the headers can be seen in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When using Java configuration, these headers can be added to the response using
    the `header()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The HeadersWriter instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the namespace or Java configuration does not support the headers you want,
    you can create a custom `HeadersWriter` instance or even provide a custom implementation
    of `HeadersWriter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of using a custom instance of `XFrameOptionsHeaderWriter`.
    Perhaps you want to allow the framing of content for the same origin. This is
    easily supported by setting the policy attribute to `SAMEORIGIN`, but let’s look
    at a more explicit example using the `ref` attribute, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The DelegatingRequestMatcherHeaderWriter class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At times, you may want to only write a header for certain requests. For example,
    perhaps you want to only protect your login page from being framed. You could
    use the `DelegatingRequestMatcherHeaderWriter` class to do so. When using Java
    configuration, this can be done with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: To summarize this section, you can add `CSRF` protection based on `DelegatingRequestMatcherHeaderWriter`,
    explicit `Clear-Site-Data`, frame options, static headers, and `DelegatingRequestMatcherHeaderWriter`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter15.02-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Spring Security Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to `spring-boot-starter-test`, `Spring Security` provides an artifact
    tailored specifically for testing purposes. Its primary purpose is to provide
    utilities and classes that assist developers in writing tests for applications
    that use `Spring Security` for authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the key functionalities provided by `org.springframework.security:spring-security-test`
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mocking Authentication**: It allows you to easily mock authentication and
    authorization contexts during testing, enabling you to simulate different user
    roles and permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration Testing**: It provides support for integration testing by offering
    utilities for setting up security configurations in your test environment, ensuring
    that your security configurations are correctly applied and tested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Spring Security` often involves configuring a chain of filters to handle authentication
    and authorization tasks. This module provides utilities to test these filters
    in isolation or as part of the filter chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get started, you need to include the following dependencies in your `Spring`
    `Security` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: By using `spring-security-test`, you can effectively test the security features
    of the applications, ensuring that sensitive resources are properly protected
    and accessible only to authorized users.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Applications Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive programming revolves around asynchronous and non-blocking interactions,
    characterized by callback and declarative approaches. It incorporates a backpressure
    mechanism to regulate the throughput from the producer, aiding in consumer control.
    In Java, Reactive programming relies on `Streams`, `CompletableFuture`, and backpressure
    controls. There exist numerous relevant use cases where reactive programming proves
    beneficial, including supporting high peak workloads, microservices, contention
    avoidance, IoT and Big Data applications.
  prefs: []
  type: TYPE_NORMAL
- en: Spring relies on the project reactor([https://projectreactor.io/](https://projectreactor.io/))
    that is the f foundation of `Spring` `Webflux` ([https://docs.spring.io/spring-framework/reference/web/webflux.xhtml](https://docs.spring.io/spring-framework/reference/web/webflux.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To add `Spring Security` reactive support into your Spring Boot project, you
    need to include `spring-boot-starter-security` and `spring-boot-starter-webflux`
    dependencies in your projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This table provides an overview of key classes to facilitate the transition
    from the Spring Security Servlet implementation to the Spring Security Reactive
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Spring Security****Servlet implementation** | **Spring Security****Reactive
    implementation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `o.s.s.w.SecurityFilterChain` | `o.s.s.w.s.Security WebFilterChain` |'
  prefs: []
  type: TYPE_TB
- en: '| `o.s.s.c.u.UserDetailsService` | `o.s.s.c.u. ReactiveUserDetailsService`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `o.s.s.c.a.w.b.HttpSecurity` | `o.s.s.c.w.s.ServerHttpSecurity` |'
  prefs: []
  type: TYPE_TB
- en: '| `o.s.s.c.c. SecurityContextHolder` | `o.s.s.c.c. ReactiveSecurityContextHolder`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `o.s.s.a.AuthenticationManager` | `o.s.s.a.ReactiveAuthentication Manager`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `o.s.s.c.a.w.c.EnableWebSecurity` | `o.s.s.c.a.m.r. EnableWeb``FluxSecurity`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `o.s.s.c.a.m.c. EnableMethodSecurity` | `o.s.s.c.a.m.c.EnableReactive MethodSecurity`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `o.s.s.p.InMemoryUser DetailsManager` | `o.s.s.c.u. MapReactiveUserDetailsService`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `o.s.s.o.c.OAuth2Authorized ClientManager` | `o.s.s.o.c.ReactiveOAuth2 AuthorizedClientManager`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `o.s.s.o.c. OAuth2Authorized``ClientProvider` | `o.s.s.o.c.ReactiveOAuth2
    AuthorizedClientProvider` |'
  prefs: []
  type: TYPE_TB
- en: '| `o.s.s.o.c.w.DefaultOAuth2Authorized ClientManager` | `o.s.s.o.c.w.DefaultReactiveO
    Auth2AuthorizedClientManager` |'
  prefs: []
  type: TYPE_TB
- en: '| `o.s.s.o.c.r.ClientRegistration Repository` | `o.s.s.o.c.r.ReactiveClient
    RegistrationRepository` |'
  prefs: []
  type: TYPE_TB
- en: '| `o.s.s.o.c.e. OAuth2Access``TokenResponseClient` | `o.s.s.o.c.e.ReactiveOAuth2
    AccessTokenResponseClient` |'
  prefs: []
  type: TYPE_TB
- en: '| `o.s.s.o.j.JwtDecoder` | `o.s.s.o.j.ReactiveJwtDecoder` |'
  prefs: []
  type: TYPE_TB
- en: Table 15.1 – Transitioning from Spring Security Servlet to Reactive Implementation
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we provide a fully functional reactive implementation available
    in `chapter15.03-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice the following main changes in to enable reactive support:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure `Spring Security` to use our custom `ReactiveUserDetailsService`
    object, as follow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `@EnableWebFluxSecurity` annotation, to enable Spring Security reactive
    support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `ReactiveAuthenticationManager` bean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `SecurityWebFilterChain` bean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Launch the application and try to access it through `http://localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to log in with the configured users `admin1@example.com/admin1`
    or `user1@example.com/user1` and test the events creation.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, creating a new user enables immediate login with the newly created
    credentials.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, `Spring Security` also provide a reactive implementation. This implementation
    is best suited for applications that require handling a large number of concurrent
    connections, high scalability, and efficient resource utilization. It’s particularly
    beneficial in scenarios involving non-blocking I/O operations, such as web applications
    with heavy user traffic or real-time data processing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered several security vulnerabilities, as well as employing
    `Spring Security` to circumvent those vulnerabilities. After reading this chapter,
    you should understand the threat of CSRF and the use of *synchronizer token* pattern
    to prevent CSRF.
  prefs: []
  type: TYPE_NORMAL
- en: You should also know how to include various HTTP headers to protect against
    common security vulnerabilities using the *Cache-Control*, *Content-Type Options*,
    *HSTS*, *X-Frame-Options*, and *X-XSS-Protection* methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how to migrate to **Spring** **Security
    6.x**.
  prefs: []
  type: TYPE_NORMAL
