- en: Testing and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we have covered Reactor in great detail, working with
    its various operators and building examples using them. However, writing code
    is only half of the job. All production code must also be verified with adequate
    unit tests. These tests not only validate our code, but they also enable us to
    make changes faster. If we refactor code, the tests ensure that our change has
    not broken any existing functionality. In this chapter, we will cover the testing
    support offered by Reactor. Testing business code will catch most of the issues,
    but the code will fail in production. In such scenarios, the code needs to be
    debugged in order to find the root cause of the failure. In this chapter, we will
    also cover some basic techniques to debug Reactor pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this final chapter, we will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Test Reactor pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug Reactor streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java Standard Edition, JDK 8 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IntelliJ IDEA IDE 2018.1 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GitHub link for this chapter is [https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Testing Reactor pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unit testing Reactor pipelines is quite hard. This is because Reactor declares
    behaviors rather than states that can be validated. Fortunately, Reactor comes
    with utility classes that can assist in unit testing. The testing utilities are
    bundled in the `reactor-test` component. `reactor-test` provides us with the following
    three components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StepVerifier`: Allows us to validate a pipeline configuration and operators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestPublisher`: Allows us to produce test data to enable testing operators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PublisherProbe`: Enables us to validate an existing publisher'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we proceed, let''s first add `reactor-test` to our `build.gradle`. We
    do not need to specify the version of this as that is defined by the `org.springframework.boot`
    plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's run `./gradlew clean deploy`. After doing this, we should find that
    we have a successful build.
  prefs: []
  type: TYPE_NORMAL
- en: StepVerifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before now, we have tested final outcomes for each Reactive Stream as the complete
    pipeline was created in the test case. This approach is not a good unit test as
    it does not validate the components in isolation. In Reactor, pipelines are declared
    in code. These pipelines are then lazily instantiated and verified. Since a complete
    pipeline is instantiated, it is quite difficult to unit test components in isolation.
    For unit testing, we must have the ability to stub the components of a pipeline,
    leaving behind the component being tested. But in this case, how can we validate
    an existing pipeline for the sequence of operations? Reactor provides the `StepVerifier`
    component to validate the required operations in isolation. This API not only
    defines stubs, but also provides assertions to validate each step. In this section,
    we will work with various examples of validating different Reactor scenarios.
    Let''s start with the simplest use case where, given a publisher, we may want
    to assert the `next` and `completion` events published by it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are validating Fibonacci series operations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We have configured the `take` operator to consume only 10 events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we used the `StepVerifier.Create` API to build an instance of a verfier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `expectNext` API is used to validate published values in the published order.
    This takes a single value or an array of values; we are validating the `0`, `1`,
    and `1` values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expectNextCount` is used to validate the number of published values. Since
    we validate three values, we are left with seven more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `expectComplete` API is used to validate a completion event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end, the `verify` API is used to validate the behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s run the test case. When doing this, we should see a green bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4974ddc7-cb65-41a3-8ecb-2c7105cedbaa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If `expectNext` does not match the published values, the test fails with `java.lang.AssertionError`
    and detailed error text. If the published count differs, then it does not fail
    with `expectNextCount`, but `expectComplete`. In all assertion failures, `StepVerifier`
    throws a `java.lang.AssertionError` with the following detailed message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the following sections, we will discuss the most commonly used methods available
    in `StepVerfier`.
  prefs: []
  type: TYPE_NORMAL
- en: expectError
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed throughout this book, a Reactive Stream terminates with a completion
    or error event. Similarly to `expectComplete`, for a completion event, there is
    the `expectError` API to validate error events. The `expectError` API offers the
    following convenient methods to validate an error message or the exception class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Error name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `expectError()` | The API only validates the occurrence of an error event.
    It does not validate any details about the error. |'
  prefs: []
  type: TYPE_TB
- en: '| `expectError(exceptionClass)` | The API validates the underlying exception
    class wrapped in the error event. |'
  prefs: []
  type: TYPE_TB
- en: '| `expectErrorMessage(errorMessage)` | The API validates the underlying exception
    message wrapped in the error event. |'
  prefs: []
  type: TYPE_TB
- en: '| `expectError(Predicate)` | The API validates the underlying exception using
    the configured predicate. |'
  prefs: []
  type: TYPE_TB
- en: 'In all preceding cases, `StepVerifier` asserts the exception wrapped in the
    error event. If the error does not match, an `assertionError` is thrown by `StepVerifier`.
    `StepVerifier` also provides an `expectErrorSatisfies` API, which can be used
    to configure customs assertions. This API takes a `Consumer` to assert an exception
    underlying the error event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are throwing an exception when the value goes above
    `30`. `expectErrorSatisfies` asserts that the exception thrown is an `IllegalStateException`
    type. Let''s execute the preceding test case to get a green bar for a successful
    test case. This is shown with the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65704bfa-2b8f-48f9-b5ee-0c563835ff9f.png)'
  prefs: []
  type: TYPE_IMG
- en: expectNext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reactor provides multiple methods to assert next values. In the preceding code,
    we matched values using the `expectNext()` overloaded operator. This operator
    is offered in the following variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator**'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; **Description** &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `expectNext(value1,value2.. value6)` &#124; This method verifies the
    published values against the supplied values. The values must be matched in the
    order specified. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `expectNext(value[])` &#124; This method verifies the published values
    against the supplied value array. All values must be matched in the order specified.
    &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `expectNextSequence(Iterator)` &#124; This method verifies the published
    values against values from the configured iterator. All values must be matched
    in the order specified. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `expectNextCount(count)` &#124; This method matches the number of values
    published. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `expectNextMatches(predicate)` &#124; This method validates whether
    or not the next values satisfy the configured predicate. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the preceding methods validate the next published value against a matching
    expectation. This is good for small datasets, but when we are publishing large
    ranges such as the Fibonacci series, we cannot match all values. Sometimes, we
    are just interested in consuming all (or some) next values. This can be accomplished
    by using the `thenConsumeWhile` API. The methods take a predicate and then consume
    all sequenced values matching the predicate. Once the first value mismatches,
    the test case tries to validate the following configured expectation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding test case, the following has occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thenConsumeWhile` has been configured with the `x >= 0` predicate. This should
    match all values except the first negative value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we expect a complete event and then verify it using the `verify` API.
    This is shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/28fb0557-cd81-4d16-912e-cda50dafe8e7.png)We have looked at the `expect`
    methods to validate events generated in a Reactive Stream. If the expectation
    does not match, `StepVerifier` builds a generic message to indicate the failure.
    `StepVerifier` also provides support to build failure-specific and descriptive
    messages. `StepVerifier` provides the `as` method, which can be invoked after
    the `expect` method. The `as` method takes a string, which is displayed when the
    exception does not match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we have provided descriptive messages for each expectation. If
    the expectation does not match, the test fails with a specific error message,
    as shown in the following trace. This helps in debugging test failures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Capture values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are times when we are unable to assert values directly. In such test
    scenarios, we usually capture the invoked values and then assert them separately.
    Reactor provides a `recordWith` API to capture values generated by the publisher
    under test. This method takes a `Supplier` function, which is invoked in order
    to instantiate a Collection for storing values. The recorder collection can then
    be asserted using the `expectRecordedMatches` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Configured `recordWith` to use an `ArrayList` for recording all values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configured `thenConsumeWhile` with the predicate `x >= 0`. This should match
    all values except the first negative value. All matching values are added to the
    record collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we configured `expectRecordedMatches` to assert the record collection
    to have values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we expect a completion event and then verify it using the `verify`
    API as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When running the preceding test case, we should get a green bar for passing
    tests. This is shown in the following screenshot:![](img/8c428c11-7f97-46c9-b734-c8e7ac7d3328.png)As
    well as the `expectRecordWith` method, Reactor also provides a `consumeRecordWith`
    API, which can be invoked for custom assertions. The `consumeRecordWith` method
    takes a Consumer function for the recorded collection. It is important to note
    that a recorded session can only be matched with the next `consumeRecordWith`
    or `expectRecordWith` invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Verify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed previously, the `verify` operator is used to assert the configured
    behavior. The termination event for a publisher must be validated before the `verify`
    call. Alternatively, Reactor provides convenient verify methods to validate the
    termination event and assert the complete configured chain. Similar to `expectError`,
    the API is offered in the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; **Method name** &#124; **Description** &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `verifyComplete()` &#124; This method only validates the occurrence
    of a completion event. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `verifyError()` &#124; This method only validates the occurrence of
    an error event. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `verifyError(exceptionClass)` &#124; This method validates an error
    event and matches an underlying exception class wrapped in the error event. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `verifyError(exceptionMsg)` &#124; This method validates an error event
    and matches an underlying exception message wrapped in the error event. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `verifyError(predicate)` &#124; This method validates an error event
    and matches it against the supplied predicate. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `verfiyErrorSatisfies(assertConsumer)` &#124; This method validates
    an error event and matches the underlying exception for supplied custom assertions.
    &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding test, we can replace `expectComplete` and verify invocations
    with the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will leave the test execution to the reader. Again, a passed test should
    show a green bar. It is important to note that `verify` (and related methods)
    return `Duration`. The duration specifies the actual time the test took to execute.
    This also brings us to discussing the blocking behavior of verify methods. By
    default, the invocation of verify methods is synchronous and blocking. It can
    make the test wait infinitely. The behavior can be changed by specifying a `Duration`
    in the `verify` method call. Alternatively, we can set a default timeout by using
    the `StepVerifier.setDefaultTimeout` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we have made the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Delayed event generation for 1 second by using the `delaySequence` operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removed the `verifyComplete` call, as we cannot specify a duration. Instead,
    we added the `expectComplete` method call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we used the verify call with a timeout duration. The timeout is set
    to 100 milliseconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This test case times out and fails with the following exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the previous sections, we looked at methods that enable us to validate most
    of the operators for a Reactive Stream. We will cover some specific Reactor scenarios
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Validating backpressure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed previously in [Chapter 7](a7dd0f00-77de-4c2b-8b48-72b30d6a6184.xhtml),
    *Flow Control and Backpressure*, backpressure allows a subscriber to control event
    flow. This mechanism is aimed at controlling a fast generating producer. There
    are different configurations for backpressure. These configurations have already
    been discussed in [Chapter 7](a7dd0f00-77de-4c2b-8b48-72b30d6a6184.xhtml), *Flow
    Control and Backpressure*, and we will not cover them here. Fundamentally, backpressure
    skips delivering values to the Subscriber. Consequently, validating it means that
    we must look for values that have not been delivered to the Subscriber. Reactor
    provides the `verifyThenAssertThat` API for the same reason. This method exposes
    assertions that can validate the end state of a publisher. Let''s now work with
    a test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the following occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: We configured a Publisher with `OverflowStrategy.ERROR` using the `Flux.create`
    API. Our Publisher generates 100 events without looking for more requests from
    the Subscriber.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, our `StepVerifier` is configured for only one event, limiting the request
    rate from the Subscriber. This is achieved using the `StepVerifier.create` API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the subscriber is asking for one event and the Publisher is raising 100
    events, this should lead to a backpressure error. In the test case, we configured
    `expectError()` to validate the error raised.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we configured `verfiyThenAssertThat()` to check for dropped elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The preceding test case validates the complete scenario of backpressure, which
    is shown in the following screenshot:![](img/cf16a934-7ab9-4ad2-85f1-af867e9cbb27.png)In
    the preceding test case, we have validated whether or not elements have been dropped.
    Reactor also provides the following assertions to validate various other scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; **Method name** &#124; **Description** &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `hasDroppedElements` &#124; This method verifies whether or not elements
    have been dropped by a Publisher due to overflow. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `hasNotDroppedElements` &#124; This method verifies whether or not any
    elements have been dropped by a Publisher due to overflow. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `hasDroppedExactly` &#124; This method validates the dropped values
    against the ones supplied in the method invocation. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `hasDroppedErrors` &#124; This method verifies whether or not errors
    have been dropped by a Publisher. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `hasOperatorErrors` &#124; This method verifies whether or not operator
    errors have been raised by stream processing. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: Validating time operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Validating time-based operations is a complex task. Traditionally, we used
    `Thread.sleep` or `wait-notify` blocks to simulate the delay in the test case.
    Reactor also provides rich support to validate such operations. This allows us
    to build a virtual clock by using the `Stepverifier.withVirtualTime` method for
    Reactive Streams. The virtual clock can then be manipulated using any of the following
    operations to simulate time drift for the required operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; **Operations** &#124; **Description** &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `thenAwait` &#124; This only pauses the execution for the configured
    time. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `expectNoEvent` &#124; This pauses the execution and validates that
    no event has happened during the configured delay. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that operators must be invoked after injecting the
    virtual clock. Also, the `expectNoEvent` API recognizes subscription as an event.
    If it is used as the first step after injecting the virtual clock, then it will
    fail due to the Subscription event. Let''s now work with the following test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we achieved the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Created a Flux with the virtual clock using `StepVerifier.withVirtualTime`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configured a `delaySequence` operation on the Reactive Stream
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoked `thenAwait` to hold the virtual clock for the configured time
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expected nine values to be published, followed by a completion event
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's now run the test case and verify it as follows:![](img/edb91374-ab59-405c-a7a4-e7ba4139100c.png)
  prefs: []
  type: TYPE_NORMAL
- en: Publisher probe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we used `StepVerifier` to assert the steps executed
    in a reactive chain. However, these are often simple chains that can be validated
    end-to-end in a single test case. There may be scenarios where we need to inject
    a Publisher into a service or a method and verify the published signals. In such
    cases, we can instrument an existing Publisher using the `PublisherProbe` utility.
    The probe keeps track of signals published by the Publisher. In the end, we can
    assert and verify the final state of the probe. The utility helps to unit test
    a service or method executing some specific logic on a Reactive Publisher.A `PublisherProbe`
    can be constructed using either of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PublisherProbe.Of(ExisitingPublisher)`: Instruments an existing Publisher
    and generates a probe from it. The probe sends out signals as generated by the
    original Publisher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PublisherProbe.empty()`: Creates an empty sequence probe. This probe does
    not emit any signals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can get back a Mono or Flux from the `PublisherProbe` by invoking respective
    methods. The Flux/Mono can then be passed to the method/service under test. After
    the invocation, the final state can be verified using the following assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; **Method name** &#124; **Description** &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `assertWasSubscribed` &#124; This method validates that the Publisher
    was subscribed to in the invocation. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `assertWasRequested` &#124; This method validates that the Publisher
    was requested in the invocation. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `assertWasCancelled` &#124; This method validates that the Publisher
    was cancelled in the invocation. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code depicts this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Created a `PublisherProbe` using `fibonacciGenerator`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next we subscribed to the Flux generated by the probe
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the end we validate that the Flux was subscribed, flowed by the request event
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's run the test case and verify it as follows:![](img/cfda1f2c-2f9e-48a1-9748-6e1ca8d58860.png)
  prefs: []
  type: TYPE_NORMAL
- en: Publisher stubs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been creating a `Publisher` along with the operators. As a
    result, we could build end-to-end validations. However, in most business services,
    a `Publisher` will be created in some part of the code and operations will be
    performed in another. In order to unit test the operation service code, we would
    need to generate a dummy `Publisher`. Reactor also provides `TestPublisher` for
    this purpose. We can create a `TestPublisher` using the `create factory` method.
    The generated `TestPublisher` can be converted into a Flux or a Mono. `TestPublisher`
    makes it possible to emit events using any of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; **Method name** &#124; **Description** &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `next(T) / next(T,T...)` &#124; Invokes Publisher `OnNext` with the
    supplied values. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `complete()` &#124; Terminates the Publisher stream with the `OnComplete`
    event. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `error()` &#124; Terminates the Publisher stream with the `OnError`
    event. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `emit(T,T,T .....)` &#124; Invokes Publisher `OnNext` with the supplied
    values, followed by `OnComplete` termination. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s work with sample code. We have the following `PrintService`, which prints
    even numbers to the console as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s build a simple test case. In the test case, we will inject a few
    values and a `StringWriter`. At the end, we will validate whether or not `StringWriter`
    contains all the required values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Generated a `TestPublisher` using the `create` method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiated a `StringWriter` to capture printed values
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we generated `onNext` using some values
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we generated `onComplete` and validated the printed values
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, run the test case. This should show a green bar for a test that has passed:![](img/0244c6dc-0de7-4753-ba1b-41964609c36d.png)`TestPublisher`
    also keeps track of the final state of the `Publisher` stub. The final state can
    be verified using the following assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `assertSubscribers` &#124; This method validates that the Publisher
    was subscribed to by the number of subscribers supplied in the invocation. &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `assertCancelled` &#124; This method validates that the Publisher was
    canceled multiple times, as specified by the number supplied in the invocation.
    &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; `assertRequestOverflow` &#124; This method validates that the Publisher
    raised Overflow conditions by generating more events than asked for by the subscriber.  &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding test case, we built a well-behaved `Publisher` stub. This
    did not send null events or raise more events than requested. The `TestPublisher`
    utility also enables us to instantiate Publisher, which violates the preceding
    conditions. Such a Publisher can be used to validate service/operator behaviors.
    An inconsistent Publisher can be generated using the `createNonCompliant` method.
    This method uses a violation type and generates configured errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Generated a `TestPublisher` using the `createNonCompliant` method. Publisher
    has been configured to produce more than the requested events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subscribed to the publisher with an initial demand of one element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validated the produced element followed by an error termination.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Debugging Reactor streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Debugging Rector streams is not straightforward. This is due to the fact that
    all stream processing in Reactor is asynchronous and non-blocking. In a synchronous
    and blocking system, an error stacktrace points to the root cause of the issue.
    However, in an asynchronous reactor stream, the error is logged in the `Subscriber`
    but has been raised in an operator in stream processing. The error stacktrace
    does not mention the operator. Let''s take a look at the following Reactor stacktrace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding stacktrace, we can observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IllegalStateException` has reached our subscriber'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactor also raises an `ErrorCallbackNotImpletemented`, since the Subscriber
    does not handle the error event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The error is captured while performing `PrintService.printEventNumbers`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding error is raised in our `ReactorDebug.testPublisherStub` test case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This does not help much, but we can clean up the stack trace by first implementing
    an error handler. The simplest approach here is to use the `printstackTrace` method
    of throwable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding change to the `subscribe` method sanitizes the stacktrace of
    the error raised. However, the error operator is still not explained in the trace,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Debug hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reactor provides assembly-time instrumentation capability to debug a stacktrace.
    This capability enables us to intercept all invocations of Flux/Mono operations.
    Each interception then keeps a record of the error thrown with the operation invoked.
    The resultant mapping is then appended to the stacktrace. This record can then
    be used to find the root cause of the issue. Since this is an additional interception,
    which keeps a record mapping, it should only be invoked to debug errors and must
    not be enabled in production systems. Reactor provides a `Hooks.OnOperatorDebug`
    API, which must be invoked before instantiating the Flux/Mono. Let''s invoke `Hooks.OnOperatorDebug`
    in our test case, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run our test case and look at the generated stacktrace, which is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we look at the bottom of the trace, it clearly states that an error
    has been thrown in the `Flux.generate` invocation. To solve this, we can fix this
    bug and rerun our test case.
  prefs: []
  type: TYPE_NORMAL
- en: Checkpoint operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Debug hook discussed in the previous section has a global impact, instrumenting
    all Flux/Mono instances. Consequently, the impact of the debug hook is application-wide.
    Alternatively, Reactor also provides a `checkpoint` operator, which can only alter
    a particular Flux stream. The `checkpoint` operator instruments a Reactor Streams
    after the operator invocation. We can alter our previous test case as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have invoked the `checkpoint()` operator after creating
    the Flux. The modified test case generates the following stacktrace. Since the
    `checkpoint` operator is invoked after `Flux.generate`, the record mapping refers
    to `FluxGenerate` as the point of error. This is shown with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `checkpoint` and the `debug` operators discussed previously have an impact
    on the memory footprint of the application. Both these operators try to save stacktraces,
    which leads to higher memory consumption. Due to this, these operators cannot
    be enabled in production applications without paying an additional cost. But the
    `checkpoint` operator also offers a trimmed down version, which does not save
    any stacktraces. The `checkpoint` operator, when configured with a description
    message, disables stacktrace accumulation. The following stacktrace is generated
    when using checkpoint with a description in our preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding stacktrace, Reactor used the description and prefixed the `identified
    by light checkpoint` message to it. It no longer tries to build a stacktrace of
    operator invocations. The `identified by light checkpoint` message can be in searched
    in application logs. But if the description message is not good enough, Reactor
    allows us to enable stacktrace capturing in order to build informative failure
    traces. This can be accomplished by using the `checkpoint(description,enableStackTrace)`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: Stream logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Logging is one of the most common ways to know what is happening underneath
    method invocations. Reactor uses SLF4J for logging, but it does not log stream
    operations out-of-the-box. Instead, Reactor provides the `log` operator, which
    can be used to selectively enable logging for a particular stream. Let''s modify
    our test case using the log operator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `log()` operator is offered in many variants. By default, the operator
    logs at the `INFO` level. We can configure this to log at the `DEBUG` or other
    levels as well. Furthermore, we can also place a `logback.xml` file to format
    the logged message, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding `logback.xml` file, we have configured a `stdout` appender.
    The appender will be invoked in a synchronous and blocking manner. Reactor also
    provides a `reactor-logback` library, which can be used to log messages in an
    asynchronous manner. The preceding test case now generates the following log message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding logging output clearly shows what events are happening in stream
    processing. We can interpret the log and build the following analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: Each log line outputs the operator invoked. Consequently, we can see that the
    first subscription was raised.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, there was an unbounded request, which started generating events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, the Subscriber raised a request for one element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, there was an `ERROR` event invoked in the generate operator due to
    `IllegalStateException`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consequently, we can see that logging is a powerful mechanism for debugging
    and learning more about application stream processing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on testing and debugging Reactor Streams. Testing Reactor
    Flux/Mono streams is complex, as each stream is evaluated lazily in an async manner.
    We also looked at `StepVerifier`, which can validate individual steps in isolation.
    Next, we looked at a virtual clock to validate time-sensitive operations, such
    as delays. We also looked at the `PublisherProbe` utility used to validate a Publisher's
    end state. Then, in order to unit test Reactive operators and stream business
    logic, we performed stubbing using `TestPublisher`. The next section was about
    debugging Reactor Streams to gain further knowledge about under-the-covers processing.
    Debugging Reactor streams is complex, since the operators are evaluated in an
    asynchronous manner. We looked at the Debug hook and checkpoint operator to generate
    an operator mapped error stacktrace. Finally, we looked at the log operator used
    to generate logs for stream processing.We have also come to the end of our book.
    On this journey, we learned about Reactor, an implementation of the Reactive Streams
    specification. We worked with Flux and Mono Publishers. We built simple applications
    to find out more about the available operators. We came to the conclusion that
    Reactor is a library that can be used in any Java application.On this journey,
    we also discussed SpringWebFlux, a complete web framework using Rector. We developed
    simple web services using it and explored the backpressure behavior offered by
    Reactor. We concluded the journey by looking at various advanced features of Reactor.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which test utility class is available in Reactor to validate the invoked operations
    on a stream?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `PublisherProbe` and `TestPublisher`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How should the virtual clock be configured to validate time-bound operations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `onOperatorDebug` hook and the checkpoint
    operator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we turn on logging for stream processing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
