<html><head></head><body>
		<div id="_idContainer008">
			<h1 id="_idParaDest-29"><em class="italic"><a id="_idTextAnchor036"/>Chapter 2</em>: How Does MicroProfile Fit into Cloud-Native Application Development?</h1>
			<p>This chapter provides you with an overview of <strong class="bold">MicroProfile</strong> and describes the specifications of MicroProfile in terms of fulfilling the requirements of cloud-native applications. In this chapter, we first look at the history of MicroProfile concerning why it was created and for what purpose, and then we will explore the content of MicroProfile. This will give you a high-level understanding of each MicroProfile specification so that you will understand how MicroProfile fits into cloud-native application development and why you should adopt MicroProfile technologies. Finally, we will look at the MicroProfile code generator, <strong class="bold">MicroProfile Starter</strong>, focusing on how to create cloud-native applications. This is useful because it will help you get started with MicroProfile from scratch.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>MicroProfile overview</li>
				<li>MicroProfile specifications</li>
				<li>MicroProfile Starter</li>
			</ul>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor037"/>MicroProfile overview</h1>
			<p>Let's start by <a id="_idIndexMarker050"/>reflecting on the history of MicroProfile, why it was set up, and how it progressed and established its working group. In this section, we look at two different sub-topics: the <em class="italic">history of MicroProfile</em> and the <em class="italic">characteristics of MicroProfile</em>. We'll begin by looking at the history. It is important to understand the release cycle and what is included in various MicroProfile releases so that we can choose which version to use, and that we have a sense of how fast MicroProfile releases new versions.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor038"/>History of MicroProfile</h2>
			<p>Seeing the slowly <a id="_idIndexMarker051"/>advancing pace of Java EE, a few major industry players, including IBM, Red Hat, Payara, Tomitribe, and others, got together in 2016 to discuss how to make server-side Java frameworks move faster and to address the new challenges associated with the new microservice space. As a result of this collaboration, MicroProfile was born in the fall of 2016. It was designed to help Java developers develop cloud-native applications without needing to learn new languages.</p>
			<p>MicroProfile 1.0 was announced in September 2016 at JavaOne. This first release of MicroProfile 1.0 consisted of CDI, JSON-P, and JAX-RS. In December 2016, MicroProfile joined the Eclipse Foundation under the Apache License v2.0 (Alv2.0). MicroProfile 1.1 was released in August 2017 and included the first new MicroProfile specification, MicroProfile Config 1.0. From 2017 to 2019, MicroProfile did three releases per year: in February, June, and October. </p>
			<p>In 2020, following the release of MicroProfile 3.3, MicroProfile was requested by Eclipse Foundation to set up its working group before any further major or minor releases could be performed. It took nearly 1 year for the community to decide whether to set up its own working group or merge with the Jakarta EE working group. Eventually, IBM, Red Hat, and Tomitribe decided to pursue a separate working group. With the working group requirement of a minimum of 5 corporate members, it took the community some time to acquire 2 more corporate members. In October, <strong class="bold">Atlanta Java User Group</strong> (<strong class="bold">AJUG</strong>) and Jelastic <a id="_idIndexMarker052"/>joined forces with IBM, Red Hat, and Tomitribe to form the MicroProfile working group. Finally, in October 2020, the working group charter was approved. Soon afterward, Payara, Oracle, Fujitsu, Garden State JUG, and iJUG joined the MicroProfile working group.</p>
			<p>After the MicroProfile working group was established in October 2020, the MicroProfile community immediately prepared the MicroProfile 4.0 release using the newly established release process. On 23 December, MicroProfile 4.0 was released. The latest MicroProfile version 4.1 got released recently in July 2021. Here is the timeline for MicroProfile releases:</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/B17377_02_01.jpg" alt="Figure 2.1 – MicroProfile release timeline&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 2.1 – MicroProfile release timeline</p>
			<p>As you can <a id="_idIndexMarker053"/>see from <em class="italic">Figure</em> <em class="italic">2.1</em>, MicroProfile has a fast release cadence. As well as this, MicroProfile has other identifying characteristics. In the next section, we will look at them.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor039"/>Characteristics of MicroProfile </h2>
			<p>MicroProfile grew very <a id="_idIndexMarker054"/>quickly thanks to its unique characteristics of openness and diversity. These are detailed as follows:</p>
			<ul>
				<li>Openness and transparency: MicroProfile is open to the public in terms of meetings, projects, contributions, and suchlike. There is no hierarchy, and everyone has the same right to voice their opinions. No one has a veto right. </li>
				<li>Diversity: The community is diverse. Its contributors are made up of many major players, including IBM, Red Hat, Tomitribe, Payara, Java User Groups, and other individuals and groups. Everyone is welcome to join MicroProfile and voice their opinion. The way to join the conversation is via the MicroProfile Google group, accessible via <strong class="bold">Join the Discussion</strong> on <a href="http://microprofile.io">microprofile.io</a>.</li>
				<li>Many <a id="_idIndexMarker055"/>runtime implementations: MicroProfile evolves APIs, specifications, and <strong class="bold">Technology Compatibility Kits</strong> (<strong class="bold">TCKs</strong>). It only <a id="_idIndexMarker056"/>creates APIs, but it does not include implementations. However, there is no lack of implementations. There are around a dozen implementations, as follows:<p>a) Open Liberty (<a href="https://openliberty.io/">https://openliberty.io/</a>)</p><p>b) WebSphere Liberty (<a href="https://www.ibm.com/uk-en/cloud/websphere-liberty">https://www.ibm.com/uk-en/cloud/websphere-liberty</a>)</p><p>c) Quarkus (<a href="https://quarkus.io/">https://quarkus.io/</a>)</p><p>d) Wildfly (<a href="https://www.wildfly.org/">https://www.wildfly.org/</a>)</p><p>e) Payara (<a href="https://www.payara.fish/">https://www.payara.fish/</a>)</p><p>f) TomEE (<a href="https://tomee.apache.org/">https://tomee.apache.org/</a>)</p><p>g) Helidon (<a href="https://helidon.io">https://helidon.io</a>)</p><p>h) Launcher (<a href="https://github.com/fujitsu/launcher">https://github.com/fujitsu/launcher</a>)</p><p>i) KumuluzEE (<a href="https://ee.kumuluz.com/">https://ee.kumuluz.com/</a>)</p><p>j) Piranha Cloud (<a href="https://piranha.cloud/">https://piranha.cloud/</a>)</p><p>k) Apache Geronimo (<a href="https://geronimo.apache.org/">https://geronimo.apache.org/</a>) </p></li>
				<li>Lightweight, iterative processes: MicroProfile establishes a pattern that moves fast and adopts an iterative process. It adapts to changes, allows breaking changes between releases, and adopts a semantic versioning policy, which means a major version release containing breaking changes. However, MicroProfile tries to minimize the number of breaking changes. When there are breaking changes, the changes must be clearly documented in the release notes of the corresponding specifications.</li>
			</ul>
			<p>Due to the aforementioned characteristics of MicroProfile, its adoption rate increased rapidly. As a result, more and more companies started investing in MicroProfile technologies. MicroProfile is <a id="_idIndexMarker057"/>now seen as the standard for developing cloud-native applications. We will take a closer look at each individual MicroProfile specification in the next section.</p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor040"/>MicroProfile specifications</h1>
			<p>At this point, you might be <a id="_idIndexMarker058"/>wondering what MicroProfile consists of. As you may know, MicroProfile <a id="_idIndexMarker059"/>evolves <strong class="bold">Application Programming Interfaces</strong> (<strong class="bold">APIs</strong>) in terms of developing cloud-native applications. MicroProfile has several specifications that offer various capabilities for cloud-native applications. As a cloud-native application developer, it's important to understand these. </p>
			<p>The MicroProfile 4.0 release includes four specifications from Jakarta EE 8 and eight MicroProfile specifications, as follows:</p>
			<p><strong class="bold">Jakarta EE specifications</strong>:</p>
			<ul>
				<li>Jakarta Contexts and Dependency Injection (CDI) 2.0</li>
				<li>Jakarta RESTful Web Services (JAX-RS) 2.1</li>
				<li>Jakarta JSON Binding 1.0 </li>
				<li>Jakarta JSON Processing 1.1</li>
			</ul>
			<p><strong class="bold">MicroProfile specifications</strong>:</p>
			<ul>
				<li>MicroProfile Config 2.0</li>
				<li>MicroProfile Fault Tolerance 3.0</li>
				<li>MicroProfile Health 3.0</li>
				<li>MicroProfile JWT Propagation 1.2</li>
				<li>MicroProfile Metrics 3.0</li>
				<li>MicroProfile OpenAPI 2.0</li>
				<li>MicroProfile OpenTracing 2.0</li>
				<li>MicroProfile Rest Client 2.0</li>
			</ul>
			<p>MicroProfile specifications are <a id="_idIndexMarker060"/>grouped under different release categories. MicroProfile has the concept of <strong class="bold">platform</strong> <strong class="bold">release</strong> and <strong class="bold">standalone</strong> <strong class="bold">release</strong>. In this section, we will cover both concepts in detail. </p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor041"/>Platform release</h2>
			<p>The platform release <a id="_idIndexMarker061"/>consists of 12 specifications, 4 of them <a id="_idIndexMarker062"/>being from Jakarta EE. These specifications can be divided into three subgroups (three layers) based on their usage: </p>
			<ul>
				<li><strong class="bold">Building cloud-native applications</strong>: CDI, JAX-RS, Rest Client, JSON-B, and JSON-P</li>
				<li><strong class="bold">Enhancing cloud-native applications</strong>: Open API, Fault Tolerance, JWT Propagation, and Config</li>
				<li><strong class="bold">Observing and monitoring cloud-native applications</strong>: Open Tracing, Health, and Metrics</li>
			</ul>
			<p>Let's explore each of these groups in turn.</p>
			<h3>Technologies for developing cloud-native applications</h3>
			<p><strong class="bold">Cloud-native applications</strong> can <a id="_idIndexMarker063"/>be developed using <strong class="bold">CDI</strong>, <strong class="bold">JAX-RS</strong>, <strong class="bold">JSON-B</strong>, or<strong class="bold"> JSON-P</strong>. MicroProfile Rest Client is used for connecting cloud-native applications. Coming up next is a quick overview of these technologies. <a href="B17377_04_Final_SB_epub.xhtml#_idTextAnchor068"><em class="italic">Chapter 4</em></a>, <em class="italic">Developing Cloud-Native Applications</em>, will explain them in more detail.</p>
			<h4>CDI – Contexts and Dependency Injection</h4>
			<p><strong class="bold">CDI</strong> (<a href="https://github.com/eclipse-ee4j/cdi">https://github.com/eclipse-ee4j/cdi</a>) is a <a id="_idIndexMarker064"/>Jakarta EE API <a id="_idIndexMarker065"/>specification <a id="_idIndexMarker066"/>that provides a core framework for managing dependencies. It enables loosely coupled cloud-native application development. CDI supports dependency injection and manages the life cycle of the dependencies. The life cycle of a bean is specified via the scope annotations, such as <strong class="source-inline">@ApplicationScoped</strong>, <strong class="source-inline">@RequestScoped</strong>, and <strong class="source-inline">@Dependent</strong>. The <strong class="source-inline">@ApplicationScoped</strong> annotation means only one instance exists per <a id="_idIndexMarker067"/>cloud-native application. The <a id="_idIndexMarker068"/>dependency injection is specified via the <strong class="source-inline">@Inject</strong> annotation, which is defined in the Jakarta injection specification.</p>
			<h4>JAX-RS – Jakarta RESTful Web Services</h4>
			<p><strong class="bold">JAX-RS</strong> (<a href="https://github.com/eclipse-ee4j/jaxrs-api/">https://github.com/eclipse-ee4j/jaxrs-api/</a>) is a <a id="_idIndexMarker069"/>Jakarta EE API specification <a id="_idIndexMarker070"/>that provides mechanisms for <a id="_idIndexMarker071"/>creating RESTful services. In <a href="B17377_01_Final_SB_epub.xhtml#_idTextAnchor021"><em class="italic">Chapter 1</em></a>, <em class="italic">Cloud-Native Application</em>, the sixth factor, <em class="italic">Processes</em>, in <strong class="bold">Twelve-Factor App</strong>, can be fulfilled by JAX-RS. JAX-RS provides many annotations to <a id="_idIndexMarker072"/>transform a <strong class="bold">Plain Old Java Object</strong> (<strong class="bold">POJO</strong>) into a <a id="_idIndexMarker073"/>web resource. These annotations include <strong class="source-inline">@Path</strong>, <strong class="source-inline">@GET</strong>, <strong class="source-inline">@PUT</strong>, <strong class="source-inline">@POST</strong>, <strong class="source-inline">DELETE</strong>, <strong class="source-inline">@Produces</strong>, and <strong class="source-inline">@Consumes</strong>. Let's look at these instances individually:</p>
			<ul>
				<li><strong class="source-inline">@Path</strong> specifies the relative path for a resource or a method.</li>
				<li><strong class="source-inline">@GET</strong>, <strong class="source-inline">@PUT</strong>, <strong class="source-inline">@POST</strong>, and <strong class="source-inline">@DELETE</strong> specify the HTTP request type.</li>
				<li><strong class="source-inline">@Produces</strong> specifies the response media type, such as <strong class="source-inline">MediaType.APPLICATION_JSON</strong>.</li>
				<li><strong class="source-inline">@Consumes</strong> specifies the accepted media type.</li>
				<li>The following is an example of a JAX-RS service. It declares a <strong class="source-inline">GET</strong> operation with the endpoint, such as <strong class="source-inline">http://localhost:9080/system/properties</strong>. When this URL is invoked, the system properties will be returned. Since <strong class="source-inline">@Produces</strong> specifies the <strong class="source-inline">MediaType.APPLICATION_JSON</strong> format, the payload format will be in a <a id="_idIndexMarker074"/>format called <strong class="bold">JavaScript Object Notation </strong>(<strong class="bold">JSON</strong>):</li>
			</ul>
			<p class="source-code">@ApplicationScoped // (1)</p>
			<p class="source-code">@Path("/properties") // (2)</p>
			<p class="source-code">public class PropertyController {</p>
			<p class="source-code">    @GET // (3)</p>
			<p class="source-code">    @Produces(MediaType.APPLICATION_JSON) // (4)</p>
			<p class="source-code">    public Properties getProperties() {</p>
			<p class="source-code">        return System.getProperties();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Let's take a look at <a id="_idIndexMarker075"/>the four <a id="_idIndexMarker076"/>commented lines in this code snippet:</p>
			<ol>
				<li>The <strong class="source-inline">@ApplicationScoped</strong> annotation, defined in the CDI, states that the life cycle of the <strong class="source-inline">PropertyController</strong> resource is singular, with only one instance existing per application. </li>
				<li>The <strong class="source-inline">@Path</strong> annotation specifies the relative path to the <strong class="source-inline">PropertyController</strong> resource to be <strong class="source-inline">/properties</strong>.</li>
				<li>The <strong class="source-inline">@GET</strong> annotation indicates the JAX-RS operation type.</li>
				<li>The <strong class="source-inline">@Produces(MediaType.APPLICATION_JSON)</strong> annotation mandates the payload to be in JSON format.</li>
			</ol>
			<p>By now, you should have a basic understanding of JAX-RS. In the next section, we will take a look at how to connect RESTful services using MicroProfile Rest Client.</p>
			<h4>MicroProfile Rest Client</h4>
			<p><strong class="bold">MicroProfile Rest Client</strong> (<a href="https://github.com/eclipse/microprofile-rest-client">https://github.com/eclipse/microprofile-rest-client</a>) provides a <a id="_idIndexMarker077"/>type-safe approach <a id="_idIndexMarker078"/>to invoke RESTful services <a id="_idIndexMarker079"/>over HTTP. You can use <strong class="source-inline">@RegisterRestClient</strong> to declare a type-safe interface, as shown in the following code snippet. </p>
			<p>The following example defines the type-safe interface for the JAX-RS operation, <strong class="source-inline">PropertyController.getProperties()</strong>, as shown in the previous section:</p>
			<p class="source-code">@RegisterRestClient(baseUri="http://localhost:9081/system")  // (1)</p>
			<p class="source-code">public interface PropertiesClient {</p>
			<p class="source-code">    @GET // (2)</p>
			<p class="source-code">    @Produces(MediaType.APPLICATION_JSON) // (3)</p>
			<p class="source-code">    @Path("/properties") // (4)</p>
			<p class="source-code">    public Properties getProperities();</p>
			<p class="source-code">}</p>
			<p>Let's take a look at the four commented lines in this code snippet:</p>
			<ol>
				<li value="1">The <strong class="source-inline">@RegisterRestClient</strong> annotation registers the <strong class="source-inline">PropertiesClient</strong> interface as a RESTful client.</li>
				<li>The <strong class="source-inline">@GET</strong> annotation indicates that the <strong class="source-inline">getProperties()</strong> method is a <strong class="source-inline">GET</strong> operation.</li>
				<li>The <strong class="source-inline">@Produces(MediaType.APPLICATION_JSON)</strong> annotation specifies the payload format as a JSON format.</li>
				<li>The <strong class="source-inline">@Path</strong> annotation declares the relative path to the <strong class="source-inline">getProperties()</strong> operation.</li>
			</ol>
			<p>The type-safe clients support both CDI and programmatic lookup. The following code snippet demonstrates how to use CDI to inject the <strong class="source-inline">PropertiesClient</strong> RESTful client and then invoke its <strong class="source-inline">getProperties()</strong> method:</p>
			<p class="source-code">@Path("/client")</p>
			<p class="source-code">@ApplicationScoped</p>
			<p class="source-code">public class ClientController {</p>
			<p class="source-code">@Inject @RestClient </p>
			<p class="source-code">private PropertiesClient; // (1)</p>
			<p class="source-code">    @GET </p>
			<p class="source-code">    @Path("/props") </p>
			<p class="source-code">    @Produces(MediaType.APPLICATION_JSON) </p>
			<p class="source-code">    public Properties displayProps() throws       IllegalStateException, RestClientDefinitionException, </p>
			<p class="source-code">        URISyntaxException {</p>
			<p class="source-code">        return propertiesClient.getProperities(); // (2)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Let's take a <a id="_idIndexMarker080"/>look at the <a id="_idIndexMarker081"/>two commented lines in this code snippet:</p>
			<ol>
				<li value="1">The <strong class="source-inline">@Inject</strong> (defined by <strong class="bold">Jakarta Injection</strong>) and <strong class="source-inline">@RestClient</strong> (a CDI qualifier defined by <strong class="bold">MicroProfile Rest Client</strong>) annotations inject an instance of <strong class="source-inline">PropertiesClient</strong> into the <strong class="source-inline">propertiesClient</strong> variable.</li>
				<li>Call the backend operation, <strong class="source-inline">getProperties()</strong>, which is <strong class="source-inline">PropertyController.getProperties()</strong>.</li>
			</ol>
			<p>Alternatively, you can use the <strong class="source-inline">RestClientBuilder</strong> programmatic API to get hold of the client, which will be discussed in <a href="B17377_04_Final_SB_epub.xhtml#_idTextAnchor068"><em class="italic">Chapter 4</em></a>, <em class="italic">Developing Cloud-Native Applications</em>.</p>
			<p>In the preceding example, the response from the JAX-RS service is in JSON format, the most popular response format. We <a id="_idIndexMarker082"/>will look at <a id="_idIndexMarker083"/>JSON in the next section in terms of how to convert to, and from, an object to a JSON object.</p>
			<h4>JSON-B and JSON-P</h4>
			<p>JSON is the <a id="_idIndexMarker084"/>prominent <a id="_idIndexMarker085"/>format for transmitting data in cloud-native applications. JSON supports <a id="_idIndexMarker086"/>two data structures: <strong class="bold">objects</strong> and <strong class="bold">arrays</strong>. The objects <a id="_idIndexMarker087"/>are sets of key-value pairs, enclosed by <a id="_idIndexMarker088"/>curly brackets, while <a id="_idIndexMarker089"/>arrays collect these objects into a set.</p>
			<p>Both <strong class="bold">JSON-B</strong> (<a href="https://github.com/eclipse-ee4j/jsonb-api">https://github.com/eclipse-ee4j/jsonb-api</a>) and <strong class="bold">JSON-P</strong> (<a href="https://github.com/eclipse-ee4j/jsonp">https://github.com/eclipse-ee4j/jsonp</a>) are <a id="_idIndexMarker090"/>Jakarta EE API specifications that convert <a id="_idIndexMarker091"/>POJOs to and from JSON data. The first version of JSON-P was released a few years before JSON-B. JSON-P provides both streaming and data models for JSON processing.</p>
			<p>JSON-B provides a mechanism for converting Java objects to/from JSON messages. It provides several methods to serialize/desterilize a Java object to/from JSON. JSON-B provides a higher-level API than JSON-P. JSON-B works well with JAX-RS and JAX-RS 2.1 mandates the use of JSON-B to automatically convert the returned object to JSON data in the HTTP response. </p>
			<h3>Technologies for enhancing cloud-native applications</h3>
			<p>After building cloud-native applications, the job is not done yet, unfortunately. You will need to think about how to improve the application. The next task is to improve its reliability and maintainability. Do you <a id="_idIndexMarker092"/>want to freely change its config value without recompiling your applications, for example, the port number? Do you want your application to be resilient, functioning all the time no matter what? Do you want your application to be secure, which means unauthorized requests are not permitted? Do you need help to work out what your applications are doing when you have got tens or hundreds of applications? </p>
			<p>If the answer to any of the aforementioned questions is <em class="italic">yes</em>, you will need to add some essential <strong class="bold">Quality of Services</strong>(<strong class="bold">QoS</strong>) , which includes the following:</p>
			<ul>
				<li>Configuration</li>
				<li>Resilience</li>
				<li>Security</li>
				<li>Documentation</li>
			</ul>
			<p><strong class="bold">MicroProfile Config</strong> provides a way to <a id="_idIndexMarker093"/>configure applications without the need for redeployment. <strong class="bold">MicroProfile Fault Tolerance</strong> makes the application more resilient. <strong class="bold">MicroProfile JWT Authentication</strong> secures applications in a portable and simple way, while <strong class="bold">MicroProfile Open API</strong> is used to document applications. Next, we will provide a quick overview of these technologies, and we will go deeper into each of them in <a href="B17377_05_Final_SB_epub.xhtml#_idTextAnchor091"><em class="italic">Chapter 5</em></a>, <em class="italic">Enhancing Cloud-Native Applications</em>.</p>
			<h4>MicroProfile Config</h4>
			<p><strong class="bold">MicroProfile Config</strong> (<a href="https://github.com/eclipse/microprofile-config">https://github.com/eclipse/microprofile-config</a>) defines <a id="_idIndexMarker094"/>an easy and flexible <a id="_idIndexMarker095"/>system to retrieve application configurations. The configurations are <a id="_idIndexMarker096"/>defined in config sources, which can be supplied by applications. There are two ways to retrieve configuration: <strong class="bold">CDI</strong> or <strong class="bold">programmatic lookup</strong>. Let's look at each of these in turn:</p>
			<ul>
				<li><strong class="bold">Injecting configuration via CDI</strong>: Upon looking up a property named <strong class="source-inline">"customer.name"</strong>, the following code snippet can be used to retrieve its value:<p class="source-code"><strong class="source-inline">@Inject @ConfigProperty(name="customer.name") String customerName;</strong></p></li>
				<li><strong class="bold">Programmatic lookup</strong>: A property named <strong class="source-inline">customer.name</strong> can also be looked up programmatically via the following APIs:<p class="source-code">Config = ConfigProvider.getConfig();</p><p class="source-code">String customerName = config.getValue("customer.name",   String.class);</p></li>
			</ul>
			<p>The property defined in the <strong class="source-inline">microprofile-config.properites</strong> file on the classpath, environment variable, and system properties is available to the cloud-native applications automatically. This means that MicroProfile Config can also access the values of fields from Kubernetes <strong class="source-inline">ConfigMaps</strong> or <strong class="source-inline">Secrets</strong> that are mapped to the Pod as environment variables. The following code snippet demonstrates the <strong class="source-inline">customer.name</strong> property defined in <strong class="source-inline">microprofile-config.properties</strong>, in the format of a Java property file:</p>
			<p class="source-code">customer.name=Bob</p>
			<p>MicroProfile Config <a id="_idIndexMarker097"/>enables the <a id="_idIndexMarker098"/>externalization of the configuration. The configuration stored in the environment can be accessed by the cloud-native applications via the Config APIs. This specification fulfills the third factor, <strong class="bold">Configuration</strong>, in <strong class="bold">Twelve-Factor App</strong>, as mentioned in <a href="B17377_01_Final_SB_epub.xhtml#_idTextAnchor021"><em class="italic">Chapter 1</em></a>, <em class="italic">Cloud-Native Application</em>. You have learned how to configure your application. Next, we will briefly discuss how to make your application resilient using MicroProfile Fault Tolerance.</p>
			<h4>MicroProfile Fault Tolerance</h4>
			<p><strong class="bold">MicroProfile Fault Tolerance</strong> (<a href="https://github.com/eclipse/microprofile-fault-tolerance/">https://github.com/eclipse/microprofile-fault-tolerance/</a>) defines a <a id="_idIndexMarker099"/>set of annotations <a id="_idIndexMarker100"/>for making <a id="_idIndexMarker101"/>cloud-native applications resilient. These annotations are as follows:</p>
			<ul>
				<li><strong class="source-inline">@Retry</strong>: Recovers from a brief network glitch. This allows you to define how many times the retry can be performed, what exceptions can trigger the retry, the time duration for the retries, and so on.</li>
				<li><strong class="source-inline">@Timeout</strong>: Defines the maximum allowed response time. This is used for time-critical operations. It defines the maximum time duration for the corresponding operation to respond.</li>
				<li><strong class="source-inline">@CircuitBreaker</strong>: Fails fast and avoids the repeatable indefinite wait or timeout. You can specify the rolling window for a circuit to be checked, the failure ratio for the circuit to open, the exceptions that the circuit breaker considers or ignores, and so on.</li>
				<li><strong class="source-inline">@Bulkhead</strong>: Isolates failures and avoids bringing the whole system down. There are two types of bulkhead. When this annotation is used together with the <strong class="source-inline">@Asynchronous</strong> annotation, this means <strong class="bold">thread isolation</strong>, which means the method with this annotation will be executed on a child thread. Otherwise, it means <strong class="bold">semaphore isolation</strong>, which means the method will be executed on the parent thread.</li>
				<li><strong class="source-inline">@Fallback</strong>: Provides an <a id="_idIndexMarker102"/>alternative solution for a failed execution. You should always use this <a id="_idIndexMarker103"/>annotation to ensure a resilient cloud-native application to respond to all kinds of situations. This annotation provides an alternative operation if the original method returns an exception.</li>
				<li>The aforementioned annotations can be used together, which improves the resilience of your cloud-native applications. Once your application is configurable and resilient, the next step is to think about how to prevent sensitive information from being obtained by irrelevant parties. This is where MicroProfile JWT Propagation comes into play.</li>
			</ul>
			<h4>MicroProfile JWT Propagation</h4>
			<p><strong class="bold">MicroProfile JWT (short for JSON Web Token) Propagation</strong> (<a href="https://github.com/eclipse/microprofile-jwt-auth/">https://github.com/eclipse/microprofile-jwt-auth/</a>) provides a <a id="_idIndexMarker104"/>portable and interoperable way to <a id="_idIndexMarker105"/>secure cloud-native microservices. It is used in conjunction with Jakarta EE Security, which <a id="_idIndexMarker106"/>provides APIs, such as <strong class="source-inline">@RolesAllowed</strong>, to secure JAX-RS endpoints. </p>
			<p>MicroProfile JWT Propagation establishes a way to pass in the user info to the backend so that the backend can determine whether the invocation is allowed. MicroProfile JWT Propagation is built on top of a JWT with a couple of additional claims: <strong class="bold">upn</strong> and <strong class="bold">groups</strong>. It defines an API, <strong class="source-inline">JsonWebToken</strong>, which extends the <strong class="source-inline">java.security.Principal</strong> interface. This API makes a set of claims available via getter accessors.</p>
			<p>JAX-RS applications can <a id="_idIndexMarker107"/>access <strong class="source-inline">JsonWebToken</strong> from <a id="_idIndexMarker108"/>the <strong class="source-inline">SecurityContext</strong> annotation: </p>
			<p class="source-code">@GET</p>
			<p class="source-code">@Path("/getGroups")</p>
			<p class="source-code">public Set&lt;String&gt; getGroups(@Context SecurityContext sec) {</p>
			<p class="source-code">    Set&lt;String&gt; groups = null;</p>
			<p class="source-code">    Principal user = sec.getUserPrincipal();</p>
			<p class="source-code">    if (user instanceof JsonWebToken) {</p>
			<p class="source-code">        JsonWebToken jwt = (JsonWebToken) user;</p>
			<p class="source-code">        groups= = jwt.getGroups();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return groups;</p>
			<p class="source-code">} </p>
			<p>Alternatively, it can also be injected:</p>
			<p class="source-code">@Inject private JsonWebToken jwt;</p>
			<p class="source-code">@Inject @Claim(standard= Claims.raw_token) private String   rawToken;</p>
			<p class="source-code">@Inject @Claim("iat") private Long dupIssuedAt;</p>
			<p class="source-code">@Inject @Claim("sub") private ClaimValue&lt;Optional&lt;String&gt;&gt;   optSubject;</p>
			<p>MicroProfile JWT Authentication also ensures single sign-on and the runtime will automatically reject the requests with insufficient <strong class="bold">access rights</strong> or a lack of the appropriate claims. Once <a id="_idIndexMarker109"/>your application is configurable, resilient, and secure, you then need to think about how to <a id="_idIndexMarker110"/>document your application. You can document your application using MicroProfile OpenAPI.</p>
			<h4>MicroProfile OpenAPI</h4>
			<p><strong class="bold">MicroProfile OpenAPI</strong> (<a href="https://github.com/eclipse/microprofile-open-api/">https://github.com/eclipse/microprofile-open-api/</a>) provides a set of <a id="_idIndexMarker111"/>annotations and models <a id="_idIndexMarker112"/>that automatically <a id="_idIndexMarker113"/>produce OpenAPI v3 documents for JAX-RS applications. A fully processed OpenAPI document is available at <strong class="source-inline">http://myHost:myPort/openapi</strong>, as a <strong class="source-inline">GET</strong> operation. Some MicroProfile Open API implementations such as <a id="_idIndexMarker114"/>Open Liberty (<a href="https://openliberty.io/">https://openliberty.io/</a>) also provide the Swagger UI integration and exposes the endpoint, <strong class="source-inline">http://myHost:myPort/openapi/ui</strong>, which allows the endpoints to be tested out.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">MicroProfile OpenAPI produces a set of Java interfaces and annotations that allow Java developers to produce OpenAPI v3 documents from their JAX-RS. MicroProfile OpenAPI was heavily influenced by OpenAPI v3, but they are not the same.</p>
			<p>As a cloud-native developer, your job is nearly done. You could deploy your application to the cloud. If everything goes well, you will have an easy job. However, if something goes wrong, you might have a difficult time figuring out where the problem lies. In order to help with service, you will need to learn about the technologies for observing and monitoring your applications. Read along to find out what you can do to help with serviceability.</p>
			<h3>Technologies for observing and monitoring cloud-native applications</h3>
			<p>Upon completing the <a id="_idIndexMarker115"/>development of cloud-native applications, the next stage is <strong class="bold">day 2 operation</strong>, where monitoring, maintenance, and troubleshooting come into play. <strong class="bold">MicroProfile Health</strong>, <strong class="bold">MicroProfile Metrics</strong>, and <strong class="bold">MicroProfile Open Tracing</strong> provide support in these areas. Next is a quick overview of these technologies to give you a basic understanding of how these technologies work together to help with day 2 operation. <a href="B17377_06_Final_SB_epub.xhtml#_idTextAnchor123"><em class="italic">Chapter 6</em></a>, <em class="italic">Observing and Monitoring Cloud-Native Applications</em>, will cover this in more detail.</p>
			<h4>MicroProfile Health</h4>
			<p><strong class="bold">MicroProfile Health</strong> (<a href="https://github.com/eclipse/microprofile-health/">https://github.com/eclipse/microprofile-health/</a>) provides readiness and liveness checks <a id="_idIndexMarker116"/>with the <strong class="source-inline">@Readiness</strong> and <strong class="source-inline">@Liveness</strong> annotations, accordingly. The <strong class="source-inline">@Readiness</strong> annotation is <a id="_idIndexMarker117"/>applied to a <strong class="source-inline">HealthCheck</strong> implementation to define a readiness <a id="_idIndexMarker118"/>check procedure, while <strong class="source-inline">@Liveness</strong> is applied to a liveness check procedure. The response of the <strong class="source-inline">HealthCheck</strong> procedure can be either <em class="italic">UP</em> or <em class="italic">DOWN</em>.</p>
			<p>The response of the readiness check determines whether the cloud-native application is ready to serve requests. If the response is <em class="italic">UP</em>, the cloud infrastructure, such as <strong class="bold">Kubernetes</strong>, will route <a id="_idIndexMarker119"/>requests to the Pod it lives in. If the response is <em class="italic">DOWN</em>, Kubernetes will not route requests to the Pod. The response of the liveness check means whether the cloud-native application is still alive. With a response of <em class="italic">DOWN</em>, Kubernetes will destroy the Pod that the cloud-native application lives in and start a new one. </p>
			<p>MicroProfile Health defines the <strong class="source-inline">http://myHost:myPort/health/ready</strong> and <strong class="source-inline">http://myHost:myPort/health/live</strong> endpoints to be exposed by its implementations to represent the status of readiness and liveness of the entire runtime accordingly, which can be used for Kubernetes readiness and liveness checks.</p>
			<h4>MicroProfile Metrics</h4>
			<p><strong class="bold">MicroProfile Metrics</strong> (<a href="https://github.com/eclipse/microprofile-metrics/">https://github.com/eclipse/microprofile-metrics/</a>) defines <a id="_idIndexMarker120"/>a mechanism for <a id="_idIndexMarker121"/>cloud-native applications <a id="_idIndexMarker122"/>to expose metrics for monitoring. It defines three scopes of metrics: <strong class="bold">base</strong>, <strong class="bold">vendor</strong>, and <strong class="bold">application</strong>. MicroProfile Metrics defines a number of APIs for application developers to provide additional application metrics. These metrics can be accessed via the endpoints of <strong class="source-inline">http://myHost:myPort/metrics/base</strong>, <strong class="source-inline">http://</strong> <strong class="source-inline">myHost:myPort/metrics/vendor</strong>, and <strong class="source-inline">http://myHost:myPort/metrics/application</strong>. The endpoint of <strong class="source-inline">http://myHost:myPort/metrics</strong> lists the aggregation of all three scopes of the metrics. The data exposed via <a id="_idIndexMarker123"/>REST over HTTP <a id="_idIndexMarker124"/>can be in JSON format or <strong class="bold">OpenMetrics</strong> text format, which can be consumed by the monitoring <a id="_idIndexMarker125"/>tools such as <strong class="bold">Prometheus</strong> so that the metrics can be represented as a graph in a dashboard.</p>
			<h4>MicroProfile OpenTracing</h4>
			<p><strong class="bold">MicroProfile OpenTracing</strong> (<a href="https://github.com/eclipse/microprofile-opentracing/">https://github.com/eclipse/microprofile-opentracing/</a>) provides <a id="_idIndexMarker126"/>implicit support <a id="_idIndexMarker127"/>for JAX-RS applications to participate in distributed tracing without adding any distributed <a id="_idIndexMarker128"/>tracing code to their cloud-native applications. It provides a mechanism to automatically inject <strong class="source-inline">SpanContext</strong> information into any outgoing JAX-RS request and then start a span for any outgoing JAX-RS request and finish the <strong class="source-inline">Span</strong> when the request completes. MicroProfile OpenTracing adopts <strong class="bold">OpenTracing</strong> (<a href="https://opentracing.io/">https://opentracing.io/</a>) and its implementation <a id="_idIndexMarker129"/>must make <strong class="source-inline">io.opentracing.Tracer</strong> available to each application. </p>
			<p>MicroProfile OpenTracing exposes the trace spans that tracing <a id="_idIndexMarker130"/>tools such as <strong class="bold">Jaeger</strong> or <strong class="bold">Zipkin</strong> can <a id="_idIndexMarker131"/>use to gather the data and graph them in a dashboard.</p>
			<p>You have learned the essential specifications from MicroProfile. However, there are some extra specifications following standalone releases. Let's look at these to see whether you could use some of them in your applications.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor042"/>Standalone releases</h2>
			<p>From 2018, a few <a id="_idIndexMarker132"/>more MicroProfile specifications were released: <strong class="bold">MicroProfile Reactive Streams Operators</strong>, <strong class="bold">MicroProfile Messaging</strong>, <strong class="bold">MicroProfile Context Propagation</strong>, and <strong class="bold">MicroProfile GraphQL</strong>. </p>
			<p>The MicroProfile community <a id="_idIndexMarker133"/>would like to get more feedback before merging these specifications into the umbrella release. As a consequence, they remain as standalone specifications. <a href="B17377_10_Final_SB_epub.xhtml#_idTextAnchor187"><em class="italic">Chapter 10</em></a>, <em class="italic">Reactive Cloud-Native Applications</em>, and <a href="B17377_11_Final_SB_epub.xhtml#_idTextAnchor202"><em class="italic">Chapter 11</em></a>,<em class="italic"> MicroProfile GraphQL</em>, will discuss these specifications in more detail. For now, let's have an overview of each:</p>
			<ul>
				<li><strong class="bold">MicroProfile Reactive Streams Operators</strong> (<a href="https://github.com/eclipse/microprofile-reactive-streams-operators/">https://github.com/eclipse/microprofile-reactive-streams-operators/</a>) defines <a id="_idIndexMarker134"/>an API for <a id="_idIndexMarker135"/>manipulating reactive streams by providing operators such as <strong class="source-inline">map</strong>, <strong class="source-inline">filter</strong>, and <strong class="source-inline">flatMap</strong>. It also provides APIs to be used by MicroProfile Messaging. </li>
				<li><strong class="bold">MicroProfile Messaging</strong> (<a href="https://github.com/eclipse/microprofile-messaging">https://github.com/eclipse/microprofile-messaging</a>/) defines <a id="_idIndexMarker136"/>a messaging <a id="_idIndexMarker137"/>mechanism for declaring CDI beans producing, consuming, and processing messages via the annotations of <strong class="source-inline">@Incoming</strong> for consuming messages and <strong class="source-inline">@Outgoing</strong> for publishing messages.</li>
				<li><strong class="bold">MicroProfile Context Propagation</strong> (<a href="https://github.com/eclipse/microprofile-context-propagation/">https://github.com/eclipse/microprofile-context-propagation/</a>) introduces APIs for <a id="_idIndexMarker138"/>propagating contexts <a id="_idIndexMarker139"/>across units of work that are thread-agnostic. It provides a mechanism for pushing the contexts from the parent thread to the child thread, which allows the asynchronous APIs such as <strong class="source-inline">CompletionStage</strong>, <strong class="source-inline">CompletableFuture</strong>, and <strong class="source-inline">Function</strong>, to work better in cloud-native applications with some associated contexts. MicroProfile Context Propagation enables asynchronous programming to be context-aware because the new threads can inherit some <a id="_idIndexMarker140"/>contexts from parent threads, such as <strong class="source-inline">Security Context</strong>, <strong class="source-inline">CDI Context</strong>, <strong class="source-inline">Application Context</strong>, <strong class="source-inline">Transaction Context</strong>, and other <a id="_idIndexMarker141"/>applications defined in <strong class="source-inline">ThreadContext</strong>.</li>
				<li><strong class="bold">MicroProfile GraphQL</strong> (<a href="https://github.com/eclipse/microprofile-graphql/">https://github.com/eclipse/microprofile-graphql/</a>) provides <a id="_idIndexMarker142"/>a set of APIs for <a id="_idIndexMarker143"/>developing GraphQL-based applications, such as <strong class="source-inline">@Query</strong> and <strong class="source-inline">@Mutuation</strong>, for building GraphQL queries and mutations, accordingly.</li>
			</ul>
			<p>So far, we have learned about all <a id="_idIndexMarker144"/>the MicroProfile specifications <a id="_idIndexMarker145"/>in short order. If you don't understand some of them, don't worry as we will cover them in more depth in the following chapters. </p>
			<p>You might now be wondering how to create a cloud-native application using MicroProfile, and whether there are any tools to help with creating a cloud-native application. We will cover this in the next section.</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor043"/>MicroProfile Starter</h1>
			<p><strong class="bold">MicroProfile Starter</strong> (<a href="https://start.microprofile.io/">https://start.microprofile.io/</a>) is a <a id="_idIndexMarker146"/>code generator for <a id="_idIndexMarker147"/>developing cloud-native applications using MicroProfile. This tool can be accessed via the web, command line, or IDE plugins. In this section, we will learn about the MicroProfile Starter tool for creating cloud-native applications.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor044"/>Accessing MicroProfile Starter via the web</h2>
			<p>The following <a id="_idIndexMarker148"/>screenshot shows the <strong class="bold">User Interface</strong> of MicroProfile Starter, which can be used to create cloud-native applications and then download the ZIP:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B17377_02_02_new.jpg" alt="Figure 2.2 – MicroProfile Starter UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – MicroProfile Starter UI</p>
			<p>In the preceding UI, we can specify the following:</p>
			<ul>
				<li><strong class="bold">groupId</strong>: The generated application's Maven group ID.</li>
				<li><strong class="bold">artifactId</strong>: The generated application's Maven artifact ID.</li>
				<li><strong class="bold">MicroProfile Version</strong>: The version of the MicroProfile release.</li>
				<li><strong class="bold">MicroProfile Runtime</strong>: The selected runtime that supports the chosen MicroProfile release version. In <em class="italic">Figure 2.2</em>, MicroProfile version 3.3 is selected, and then three runtimes that implement MicroProfile version 3.3 are displayed: <strong class="bold">Open Liberty</strong>, <strong class="bold">Wildfly</strong>, and <strong class="bold">Payara Micro</strong>. </li>
				<li><strong class="bold">Java SE Version</strong>: Once <a id="_idIndexMarker149"/>we have chosen our favorite runtime, we can then choose the Java SE version. If a runtime supports multiple Java SE, we can then select which Java SE version you want. For example, Open Liberty supports both Java SE 8 and Java SE 11. Once we have selected Open Liberty, we can then choose either Java SE 8 or Java SE 11.</li>
				<li><strong class="bold">Examples for specifications</strong>: The MicroProfile specifications that the generated applications are going to use. Clicking on the checkbox will select the corresponding MicroProfile specifications and the code sample will include the chosen MicroProfile specifications. If TypeSafe Rest Client or JWT Auth is selected, two cloud-native applications will be generated to demonstrate the client-server architecture. If you want to create a MicroProfile application from scratch, you don't need to choose any of the checkboxes. In this case, you will have the structure set up and you can write your business code straightaway.</li>
			</ul>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor045"/>Accessing MicroProfile Starter via the command line</h2>
			<p>MicroProfile Starter has <a id="_idIndexMarker150"/>command-line support, which is <a id="_idIndexMarker151"/>useful if you want to automatically generate cloud-native applications on the command line or as part of the automation process.</p>
			<p>You can find all information via the following command, where the output displays all of the supported features with the corresponding commands:</p>
			<p class="source-code">curl 'https://start.microprofile.io/api'</p>
			<p>In the output from the aforementioned command, you can find further commands to use for creating a specific cloud-native application for a chosen runtime, MicroProfile version, and so on.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor046"/>Accessing MicroProfile Starter via an IDE plugin</h2>
			<p>MicroProfile Starter <a id="_idIndexMarker152"/>can also be accessed <a id="_idIndexMarker153"/>via IDE plugins, namely, the <strong class="bold">Visual Studio Code MicroProfile extension pack</strong> or <strong class="bold">Intellij IDEA MicroProfile plugin</strong>, which we will look at now.</p>
			<h3>Visual Studio Code plugin</h3>
			<p>The <strong class="bold">Visual Studio Code Extension Pack for MicroProfile</strong> (<a href="https://marketplace.visualstudio.com/items?itemName=MicroProfile-Community.vscode-microprofile-pack">https://marketplace.visualstudio.com/items?itemName=MicroProfile-Community.vscode-microprofile-pack</a>) can be <a id="_idIndexMarker154"/>downloaded and installed <a id="_idIndexMarker155"/>onto <a id="_idIndexMarker156"/>Visual Studio Code (<a href="https://code.visualstudio.com">https://code.visualstudio.com</a>). </p>
			<p>This extension pack also includes <strong class="bold">Language Server Support for MicroProfile</strong>, <strong class="bold">Open Liberty Tools</strong>, <strong class="bold">Quarkus</strong>, and <strong class="bold">Payara Tools</strong>.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor047"/>IntelliJ IDEA plugin</h2>
			<p><strong class="bold">IntelliJ IDEA</strong> (<a href="https://www.jetbrains.com/idea/">https://www.jetbrains.com/idea/</a>) offers a <a id="_idIndexMarker157"/>MicroProfile Starter plugin (<a href="https://plugins.jetbrains.com/plugin/13386-microprofile-starter">https://plugins.jetbrains.com/plugin/13386-microprofile-starter</a>) for you to access MicroProfile Starter <a id="_idIndexMarker158"/>directly from the <a id="_idIndexMarker159"/>Intellij IDE. You can simply install the plugin and start using MicroProfile Starter. When using the plugin, you can input the same fields as shown in <em class="italic">Figure 2.2</em>, and then an application will be created. </p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor048"/>Summary</h1>
			<p>In this chapter, we have learned all of the MicroProfile specifications and discussed how they can help with creating cloud-native applications. We then added various QoS, such as configuration, resilience, security, and monitoring. With this, you will have a basic idea of how to design your cloud-native application with best practices to make it secure, configurable, resilient, intelligent, and monitorable. In the chapters to follow, we will learn these technologies in more depth.</p>
			<p>Furthermore, after going through the MicroProfile specifications, we then introduced MicroProfile Starter, a tool to develop cloud-native applications. This tool can be accessed via the web, command line, Visual Studio plugin, or IntelliJ IDEA plugin. You will be able to use these tools to create your cloud-native applications from scratch.</p>
			<p>In the next chapter, we will introduce a real-world, cloud-native application that utilizes MicroProfile technologies to solve some common problems, and we will also learn how MicroProfile helps with the challenges posed by real-world use cases. </p>
		</div>
	</body></html>