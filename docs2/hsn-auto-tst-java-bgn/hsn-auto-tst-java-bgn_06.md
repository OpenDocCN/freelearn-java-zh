# 第六章：了解有关数组的一切

在本章中，我们将探讨 Java 代码中最重要概念之一：数组。我们将看到不同数组的样式，以及如何初始化和显示它们。我们还将查看一些练习，以帮助我们更好地理解数组的工作原理。

在本章中，我们将涵盖以下主题：

+   数组及其在 Java 程序中的应用

+   初始化数组和分配对象的方法

+   多维数组的逻辑编程

+   练习

# 数组及其在 Java 程序中的应用

我们可能以前遇到过数组的术语，所以让我们通过解释和示例来了解数组是什么。

数组是一个存储多个相同数据类型值的容器。

在以下示例中，我们将了解什么是容器，如何定义该容器，以及我们如何在其中存储值。

如果我们要使用数组，我们通过以下代码为它们分配一些空间来声明它们：

```java
int a[] = new int[];
```

`new`关键字基本上为这个数组中的值分配内存。方括号表示我们将多个值添加到方括号中，`[]`表示数组的术语。为了定义一个数组，我们必须为将要存储在其中的多个值创建空间。在这个例子中，我们有五个整数值，我们计划将它们存储在数组中，这就是为什么我们指定数组数据类型为整数，并且要添加的变量数量在方括号中给出：

```java
int a[] = new int[5];
```

如我们在第三章中观察到的，在*Java 中处理字符串及其函数*，如果值是字符串，我们将指定数组数据类型为`String`。

我们已经声明了一个数组并为值分配了内存，现在我们需要传递这些值。第一个值将放在索引`0`，第二个放在索引`1`，以此类推，直到所有五个值。索引命名从`0`开始，这意味着我们实际上在数组中初始化了值。现在`a`数组包含了我们分配给它的所有值。在我们的例子中，我们为该数组声明了任何随机的值。

现在让我们从数组中检索值。为此，我们在声明数组的值之后，在`main`类中输入以下代码来创建一个`for`循环，并在其后留下一个打印语句：

```java
for(int i=0; i<a.length;i++);
{
    System.out.println(a[i]);
}
```

我们将起点设置在索引`0`，并将限制设置为数组的长度。看看`i<a.length`代码，`length`是一个实际上返回数组大小的方法。

当我们运行代码时，我们会看到分配给数组的所有值依次打印出来。在下一节中，我们将看到一种更简单的方式来声明和初始化所有数组值。

# 初始化数组和分配对象的方法

在上一节中，我们看到了如何声明一个数组；最简单的方式是使用数组字面量形式。让我们用一个例子来解释这一点。

我们通过在先前的例子中输入以下代码行来声明另一个数组：

```java
int b[] = {1,4,3,5,7,8};
```

前一个例子中的声明与我们在本例中进行的声明有什么区别？

在先前的例子中，我们是在分配内存然后赋值。在本例中，我们不是分配内存，而是直接将值传递给数组。在这里，内存是动态分配的，如果我们向数组声明中添加一个值，将自动分配内存并将值传递给它。在大多数情况下，程序员使用这种方法来声明数组值，而不是声明分配然后赋值。

与先前的例子类似，第一个值被分配到索引`0`。如果我们写一个与先前的例子类似的打印语句并运行代码，我们将看到`b`数组的值被显示出来。

这样我们就结束了单维数组的讨论；让我们来谈谈多维数组。

# 多维数组

在*x*轴和*y*轴上传递对象，其实就是一个多维数组。其中*x*轴是行，*y*轴是矩阵中数组值的列。这里的“多”意味着我们从多角度来观察数组；这被称为**多维数组**。以下是我们创建的一个多维数组，用于解释这个概念：

```java
2  4  5
3  4  7
5  2  1
```

这是一个矩阵，它有三行三列。`2`位于零行零列，它旁边的`4`位于零行第一列，其余的值以此类推。所以每个参数都有一个*x*轴和一个*y*轴。

让我们举一个例子来解释这一点。我们将创建另一个类，命名为`Multidimensional.java`，并在其中声明一个多维数组`a`：

```java
int a[][] = new int[2][3];
```

第一个括号代表*x*轴或行，第二个代表*y*轴或列。所以*x*轴有三个值，意味着有三行，而*y*轴有三个列。然后我们为创建的多维数组中的每个元素分配值。以下代码显示了如何为矩阵分配值：

```java
a[0][0]=2;
a[0][1]=4;
a[0][2]=5;
a[1][0]=3;
a[1][1]=4;
a[1][2]=7;
```

这样我们就可以将所有值输入到一个多维数组中。如果我们想显示第二行第一列的值，我们写一个打印语句并给出我们希望显示值的元素位置。在这种情况下，我们想显示第二行第一列，所以打印语句将写成：

```java
System.out.println(a[1][0]);
```

打印语句将显示`3`，这是该位置元素的值。在下一节中，我们将举一个例子，帮助解释我们如何使用所有这些概念来解决编码问题。

我们如何打印出在本例中声明的 a 数组的所有值？在先前的例子中，我们通过简单地创建一个`for`循环，从`0`迭代到数组的长度，然后显示数组。

如果我们想以最简单的格式声明一个多维数组，就像前一个例子中描述的数组`b`一样，我们可以用以下方式编写：

```java
int b[][]= {{2,4,5},{3,4,7},{5,2,1}};
```

数组将假设第一个括号中的值在零索引，第二个在第一个索引，第三个在第二个索引。这是声明多维数组的最简单方式。

# 多维数组的逻辑编程

现在，我们将看看如何打印之前章节中使用的整个多维数组的所有值，即数组`a`。

如果我们分析数组的声明，我们会看到需要两个`for`循环来打印整个数组，一个用于行，一个用于列。

我们希望控制器扫描完整的第一行，然后是第二行，最后是第三行。因此，我们添加一个外部的`for`循环来处理行，并将长度限制设置为数组中的行数，在这种情况下是两行。行的外部`for`循环将如下所示：

```java
for(int i=0;i<2;i++)
```

这个`for`循环实际上将循环两次，因为我们为行设置了`2`的限制。第一个循环将扫描第一行，第二个循环将扫描第二行。现在，对于每个循环，我们需要扫描该特定行中存在的三个列。为此，我们添加一个内部`for`循环来扫描每一列，并将限制设置为数组中的列数，在这个例子中是`3`。列的内部`for`循环将如下代码所示：

```java
for(int j=0;j<3;j++)
```

最后，为了打印数组，我们在内部`for`循环中添加一个打印语句来显示所有值。最终的代码将如下所示：

```java
for(int i=0;i<2;i++) //row
{
    for(int j=0;j<3;j++) //coloumn
    {
        System.out.println(a[i][j]);
    }
}
```

让我们尝试理解我们在这里写的内容。控制将从外部`for`循环开始；这个外部`for`循环执行两次，因为它被设置为小于`2`。第一次进入外部`for`循环后，它进入内部`for`循环；这个循环执行三次，因为`j`被设置为小于`3`。

让我们调试它并查看代码中的几个步骤来更好地理解这些循环。以下是在调试代码时将执行的步骤：

1.  控制器第一次执行外部循环，`i`的值已经被初始化为`0`，这意味着*x*轴的值被设置为`0`。控制器将查看第一行，因为`0`表示正在访问第一行。

1.  它移动到内部`for`循环并执行它，`j`的初始值已经被初始化为`0`；这意味着*Y*轴的值被设置为`0`。控制器将查看第一行和第一列，因为它已经在第一行，这是由于外部循环。内部循环将控制器发送到查看第一列。

1.  `a`将取第一行和第一列的值，因为`i`和`j`的初始值都是`0`，即`a[0][0]`。因此，这次执行的输出将是第一行和第一列，在这个例子中是`2`。

1.  由于`j`被迭代到`1`，小于`3`，因此循环的条件仍然满足，控制器再次进入内`for`循环。这意味着*y*轴的值被设置为`1`，它将访问第二列。由于外循环和内循环已经将控制器置于第一行，控制器将查看第一行和第二列。

1.  `a`将取第一行和第二列的值，因为`i`和`j`的值被设置为`0`和`1`，即`a[0][1]`。因此，这次执行的输出将是第一行和第二列，在这个例子中是`4`。

1.  由于`j`被迭代到`2`，小于`3`，因此循环的条件仍然满足。这意味着*y*轴的值被设置为`2`，它将访问第三列。由于外循环和内循环已经将控制器置于第一行，控制器将查看第一行和第三列。

1.  `a`将取第一行和第三列的值，因为`i`和`j`的值被设置为`0`和`2`，即`a[0][2]`。因此，这次执行的输出将是第一行和第三列，在这个例子中是`5`。

1.  当控制器现在进入内循环时，它将无法执行它，因为`j`再次迭代后值将变为`3`，这并不小于我们为循环设置的极限。因此，控制器退出内`for`循环并返回外循环，迭代`i`的值为`1`；这意味着*x*轴的值被设置为`1`。控制器将查看第二行，因为`1`表示正在访问第二行。

1.  步骤 2、3、4、5、6 和 7 将再次重复，但这次`i`的值，即*x*轴，被设置为`1`；这意味着将访问第二行。根据之前指定的步骤显示第二行中的所有值，直到我们达到矩阵的第三列。

1.  控制器在访问第三列后退出内循环，因为`j`将被迭代到`3`，小于我们为循环设置的极限。因此，控制器再次退出内`for`循环并开始执行外循环。

1.  在外`for`循环中，`i`的值将被迭代到`2`，并且循环将不会执行，因为它不小于我们为其设置的极限`2`。

这就是如何使用两个`for`循环来获取多维数组的值，其中外循环处理行，内循环处理列。

# 练习

让我们尝试一些练习，这些练习将帮助我们理解和处理数组。这些练习在面试时也会解释概念。

# 打印 3 x 3 矩阵中的最小数

让我们为这个练习创建另一个类，命名为`InterviewMinnumber`，并在主块中定义数组。定义代码如下：

```java
int abc[][]={{2,4,5},{3,2,7},{1,2,9}};
```

这段代码声明了一个名为`abc`的 3 x 3 矩阵。现在我们需要遍历矩阵中的每个数字，并寻找其中的最小数。要遍历多维数组中的每个数字，我们需要使用我们在*多维数组上的逻辑编程*部分中使用过的相同概念。

我们在这里使用两个`for`循环：一个外部的`for`循环用于遍历行，一个内部的`for`循环用于遍历列。这两个`for`循环的代码如下：

```java
for(int i=0;i<3;i++)
    {
    for(int j=0;j<3;j++)
    {
    }
}
```

要找到最小的数，我们声明一个变量`min`，并将其赋值为`abc`数组的第一项。我们假设`abc`矩阵中的第一个值是最低的值。

我们在内部`for`循环中添加了一个`if`循环。在这个`if`循环中，我们写的任何内容都会去扫描我们声明的整个矩阵中的每个元素。在`if`循环中，我们添加了一个条件，检查从矩阵中取出的值是否小于`min`值。在`if`循环内部，我们交换`min`和`abc`的值。最终的代码如下：

```java
public class InterviewMinnumber 
{
    public static void main(String[] args) 
    {
        int abc[][]={{2,4,5},{3,2,10},{1,2,9}};
        int min=abc[0][0];
        for(int i=0;i<3;i++)
        {
            for(int j=0;j<3;j++)
            {
                if(abc[i][j]<min)
                {
                    min=abc[i][j];
                }
            }
        }
        System.out.println(min)
    }
}
```

让我们运行代码，看看它是如何找到矩阵中的最小数的。

当循环第一次执行时，矩阵的第一个元素的值与`min`变量的值进行比较，但我们把`min`变量的值设置为第一个元素，即`2`。我们在`if`循环中检查条件，该条件比较矩阵中元素的值和`min`的值。在这里，`2`不小于`2`，所以它不会进入循环，然后它再次回到代码的开始。在循环的下一轮中，元素的值发生变化，因为我们移动到了矩阵中的下一个元素。现在正在比较的元素是`4`，我们再次检查`if`条件，它不会为真，因为`4`不小于`2`，而`2`是当前`min`的值。最后，当它到达第三行第一列的元素时，`1`，那么`if`条件为真，控制器移动到循环内部，并将`1`赋给`min`值。这个过程一直持续到数组矩阵的最后一个元素，其中每个`abc`矩阵的值都与`min`变量进行比较。

如果我们调试代码并观察每一步，我们将更好地理解代码的逻辑和工作原理。

# 显示具有最小数的列中的最大数

在之前的示例中，我们观察了如何从数组矩阵中打印出最小数值。在这个例子中，我们将寻找矩阵中的最小数值，然后是同一列中的最大数值。背后的逻辑是：我们首先找到最小数值，记住它所属的行号，然后提取同一列中的最大数值。

让我们使用之前示例中使用的相同矩阵。在这个矩阵中进行的这个练习的输出将是`4`。以下步骤将用于执行此练习：

1.  在我们声明的矩阵中找到最小值

1.  确定最小数值所在的列

1.  在确定的列中找到最大数值

在之前的示例中，我们已经执行了第 1 步，即找到矩阵中的最小数值，因此我们将使用相同的代码，只需稍作变量更改：

```java
int abc[][]={{2, 4, 5}, {3, 0, 7}, {1, 2, 9}}
```

让我们进入第 2 步。如果我们观察代码，我们会看到`i`代表行号，而`j`代表列号。因此，`j`将取最小数值所在的列的值，我们将这个值赋给一个变量，该变量将调用`mincolumn`。因此，我们在交换命令下编写代码，将`j`的值赋给`mincolumn`。代码将类似于以下内容：

```java
mincoloumn=j;
```

因此，当我们找到矩阵中的最小数值时，我们将它的值赋给`j`，即列号，赋给`mincloumn`。在这种情况下，`mincolumn`的值将是`1`。这完成了第 2 步。

在第 3 步中，我们从包含最小数值的列中寻找最大数值。我们创建一个`while`循环，位于我们为寻找矩阵中最低数值所创建的外部`for`循环之外。我们将条件变量`k`初始化为`0`，并在满足`while`循环条件时迭代它。`while`循环的条件设置为`k`小于`3`；这是因为我们需要遍历三行以寻找其中的最大值。`while`循环的代码将如下所示：

```java
while(k<3)
{
    k++;
}
```

我们声明一个名为`max`的变量，并给它一个初始值行`0`和列`mincolumn`。这使得变量`max`的初始值为`4`，因为`4`是包含矩阵中最小数值的行的第一个元素。声明代码将如下所示：

```java
int max=abc[0][mincoloumn];
```

在`while`循环内，我们添加一个`if`循环，并设置一个条件，比较列中具有最小数值的变量是否大于我们声明的变量`max`。如果条件成立，该数值的值将被分配给`max`变量，控制器在通过`1`迭代`k`后退出`if`循环，并返回到`while`循环。迭代将控制器带到下一行，因为`k`用来表示正在遍历以寻找最大数值的行。

`if`循环的代码将如下所示：

```java
if(abc[k][mincoloumn]>max)
{
    max=abc[k][mincoloumn];
}
```

因此，对于`k`的第一个值，即`0`，我们进入第一行第二列并将值赋给`max`；在这个例子中，值是`4`。在`if`条件中，我们比较第一行第二列的值与`max`的值。在这个例子中，两个值都是相同的，所以`if`循环没有执行，我们迭代`k`并再次进入`while`循环。接下来，我们比较第二行第二列的值与`max`的值；我们移动到第二行，因为`k`的值迭代了`1`，当前`k`的值是`1`。所以，在比较时，我们看到`o`小于`4`，其中`4`是`max`变量的值。条件再次不满足，`if`循环再次被跳过。这也适用于第三行，最终`max`的值是`4`，这是该列中的最大数。最后，我们留下一个打印语句，在最后打印`max`的值。

# 使用/不使用临时变量交换变量

在这个练习中，我们将交换简单数组中元素的位置，并将它们按升序排列。

要做到这一点，我们首先需要理解其工作逻辑。让我们通过一个例子来解释这一点。

我们初始化`a`数组并在其中声明值，如下面的代码所示：

```java
int a[]= {2,6,1,4,9};
```

我们可以使用冒泡排序机制来比较变量彼此，然后按照我们想要的顺序排列它们。对于前面的例子，逻辑的工作方式如下；我们将比较`2`与`6`，`2`与`1`，`2`与`4`，以及`2`与`9`。比较之后的最小数是`1`，我们将它的位置与第一个索引交换，即`2`。所以交换后，`1`将成为新的第一个索引。这意味着`1`是数组中给出的值中的最小数。现在我们移动到第二个索引，我们保留第一个索引不变，因为我们已经比较并宣布`1`为固定的第一个索引，因为它在数组中是最小的数。现在我们取第二个索引的值`6`，并将其与其他数组中的值进行比较。首先我们比较`6`和`2`，由于`2`小于`6`，我们交换它们的位置，所以`2`成为新的第一个索引，`6`成为第二个索引。然后我们比较`2`与`3`；基本上我们是在比较第一个索引与数组中的所有其他值。然后我们比较`2`与`3`，`2`与`4`，以及`2`与`9`；在这里`2`是最小的数。所以`2`成为数组中的固定第二个索引。现在我们剩下四个需要排序的值。我们再次比较`6`与其他值。`6`小于`3`，所以我们交换`6`和`3`的位置。这使得`3`成为数组中的第三个索引，我们比较`3`与其他数字，`3`是给定值中的最小数。所以`3`成为数组中的固定第三个索引。然后我们对最后三个值执行相同的事情，并得出最终排列将是`1`，`2`，`3`，`4`，`6`，`9`。现在我们需要将这个逻辑应用到 Java 程序中并打印它。

我们将决定我们逻辑的算法，并根据该算法，我们将逐步设计我们的代码。我们将编写一个外层`for`循环，该循环移动一个索引并与其余部分进行比较。

我们编写一个外层`for`循环，并将条件设置为不超出数组的长度；这里数组的大小是`5`，所以条件设置为`i`小于`5`。如果`i`是`0`，变量值将比较它和第一个、第二个、第三个和第四个变量。如果`i`是`2`，变量将比较它和第三个和第四个变量。所以无论`i`索引是什么，它都应该从`i`的值开始比较其下一个索引。为此，我们将创建一个内层`for`循环，并将`j`初始化为总是比`i`多一个数字，即`i`加`1`，因为我们将比较它和下一个索引。所以如果`i`等于`0`，`j`将是`1`。所以零索引将从第一个索引开始比较。我们将其与数组的末尾进行比较，所以我们将内层`for`循环的限制设置为`j`，因为它小于数组的长度，在这个例子中是`5`。

我们然后在内部`for`循环中添加一个`if`循环。这个循环将在条件满足时比较索引并交换值。一旦完成第一轮比较，控制器就会退出内部`for`循环，回到外部`for`循环，这时在比较后选择最小的数字，将其推到角落，索引移动到下一个值。

现在，我们回到`if`循环内部，编写代码在比较条件为真时交换值。为了交换变量值，我们需要声明一个`temp`变量并将`a[i]`的数字赋值给`temp`。我们添加以下代码以成功交换变量：

```java
temp=a[i];
 a[i]=a[j];
 a[j]=temp;
```

最后，我们在比较和重新排列值后添加一个打印语句来显示最终的数组。

最终输出将如下所示：

```java
1
2
4
6
9
```

# 摘要

在本章中，我们介绍了数组中的各种概念。我们查看了几种不同类型的数组，以及它们如何初始化和显示。然后我们进行了不同的练习，以了解我们如何在不同的实例中使用数组。

在下一章中，我们将讨论为什么`Date`类和构造函数是 Java 的重要组成部分
