# 7

# GraalVM

在 JVM 的不断演变中，GraalVM 作为一种革命性和多功能的替代品脱颖而出。本章深入探讨了 GraalVM 的复杂性，揭示了其独特的特性，并阐明了其在 JVM 内部世界中的颠覆性角色。由 Oracle Labs 开发的 GraalVM 超越了传统 JVM 的传统边界，提供了一种多语言运行时，支持包括 Java、JavaScript、Python、Ruby 等多种语言。这种灵活性为开发者开辟了新的途径，使他们能够在一个应用程序中无缝集成不同的语言。随着我们翻阅本章的页面，你将全面了解 GraalVM 的架构、其独特的组件以及它在重塑 Java 开发格局中的关键作用。

GraalVM 的架构不仅是对其工程实力的证明，也是其对性能和效率承诺的体现。本章不仅探讨了 GraalVM 的底层架构和组件，还突出了其创新的即时编译器（JIT compiler），这是其效率的核心。理解 GraalVM 架构的细节对于希望利用其力量优化和提升应用程序性能的开发者至关重要。此外，我们还将深入研究实际应用案例，展示 GraalVM 在哪些场景中表现出色以及它解决的独特问题。无论你是希望提高 Java 应用程序的执行速度，还是寻求多语言的无缝集成，GraalVM 都是一个引人注目的解决方案，本章将引导你了解其功能和潜在应用。准备好探索 GraalVM 的前沿特性，并在不断发展的 JVM 内部世界中发现新的可能性维度。

在本章中，我们将探讨以下主题：

+   GraalVM 概述

+   原生镜像（Native Image）

+   创建原生镜像

# 技术要求

对于本章，你需要以下要求：

+   GraalVM 21

+   Git

+   Maven

+   任何首选的集成开发环境（IDE）

+   本章的 GitHub 仓库位于 - [`github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-07`](https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-07)

# GraalVM 概述

在这个启发性的部分，我们将踏上探索 GraalVM 创新领域的开创性旅程，这一创新重新定义了 JVM 的期望。GraalVM 的崛起归功于其令人惊叹的特性，特别强调其高性能编译器、**即时编译**（AOT）和在不同语言运行时管理方面的能力。

GraalVM 卓越性能的核心是其最先进的 JIT 编译器。这个编译器经过精心设计，以优化 Java 应用程序的执行，推动速度和效率的极限。与传统 JVM 不同，GraalVM 的 JIT 编译器拥有先进的技巧和优化，从而实现了更快的启动时间和更小的内存占用。因此，开发者可以体验到应用程序整体性能的显著提升，使 GraalVM 成为追求执行速度卓越的宝贵工具。

GraalVM 通过其 AOT 编译引入了一种范式转变，使开发者能够将他们的程序预编译成原生机器代码。这种方法消除了运行时 JIT 编译的需求，从而实现了更快的启动时间和更低的内存消耗。AOT 编译为 GraalVM 开辟了新的天地，使其成为快速启动和降低延迟至关重要的场景的理想选择。本节将探讨 AOT 编译的复杂性，并指导您如何利用其力量来优化您的应用程序。

GraalVM 通过提供多语言运行环境超越了传统 JVM 的局限。这意味着开发者可以在同一应用程序中无缝集成和执行用多种语言编写的程序。从 Java 和 JavaScript 到 Python、Ruby 等，GraalVM 支持各种语言，培育了一个多语言生态系统。本节将深入探讨多语言能力的含义，展示开发者如何利用这一特性构建超越语言障碍的灵活和高效的应用程序。

虽然 GraalVM 带来了许多创新特性，但任何技术都有其权衡之处。本节旨在阐明这些考虑因素，帮助开发者做出明智的决定，了解何时何地利用 GraalVM 的力量。

在平衡增强的运行时和多语言能力等好处的同时，开发者还必须考虑增加的内存使用量、更长的编译时间和兼容性细节等因素。探讨这些权衡将使开发者能够根据项目需求做出明智的决定。了解这些复杂性能够战略性地应用 GraalVM 的优势，同时减轻特定用例中可能遇到的潜在挑战。

+   **内存开销**：随着 GraalVM 令人印象深刻的性能提升，内存使用量略有增加。高级优化和灵活的语言支持导致内存占用比一些传统 JVM 更大。开发者必须权衡性能优势与对内存资源的潜在影响，特别是在内存约束严格的环境中。

+   **编译时间**：虽然 GraalVM 的 JIT 编译器在运行时性能方面是一大优势，但值得注意的是，与其它 JVM 相比，初始编译时间可能会更长。对于开发短期应用或在快速启动至关重要的场景中工作的开发者，应仔细评估运行时性能的好处是否超过了在应用程序初始化期间较长的编译时间。

+   **兼容性**：虽然 GraalVM 支持多种语言，但某些语言特性或库可能不完全兼容。开发者需要考虑他们项目的具体语言需求，并确保 GraalVM 提供足够的支持。兼容性问题可能需要额外的努力来调整或优化代码，以便与 GraalVM 无缝工作。

确定利用 GraalVM 优势的最佳场景需要对最佳用例进行有针对性的评估。在微服务和无服务器架构中，GraalVM 卓越的性能和减少的内存占用与这些环境的敏捷性需求无缝对接。其多语言能力使其成为涉及多种语言的项目的理想选择，促进了一个统一的运行时环境。高性能计算应用得益于 GraalVM 的高级 JIT 编译，加速了计算密集型任务。此外，云环境中的资源密集型应用可以利用 GraalVM 在资源利用效率上的优势，而不会影响性能。开发者可以通过确定这些用例，有策略地利用 GraalVM 在多样化的应用场景中的优势，以最大化其优势：

+   **微服务和无服务器架构**：GraalVM 令人印象深刻的性能提升和减少的内存占用使其非常适合微服务和无服务器架构。更快的启动时间和高效的资源利用与这些环境中敏捷性和响应性的需求相吻合。

+   **多语言应用**：GraalVM 的多语言能力在应用使用多种编程语言构建的场景中尤为突出。如果你的项目涉及用 Java、JavaScript、Python、Ruby 等多种语言编写的组件，GraalVM 在单个运行时环境中无缝集成这些语言的能力成为决定性的优势。

+   **高性能计算**：专注于高性能计算的应用，如科学模拟或数据处理，可以从 GraalVM 的高级即时编译（JIT）中受益。增强的运行时性能可以显著加速计算密集型任务。

+   **资源密集型应用**：GraalVM 在资源利用效率上的优势使其成为资源密集型应用的绝佳选择，尤其是在基于云的环境下。开发者可以利用 GraalVM 优化资源消耗，同时不牺牲性能。

总之，GraalVM 在各种场景下提供了一个有吸引力的选择，尤其是在权衡与项目的优先级和限制相一致的情况下。通过仔细评估应用程序的具体需求，开发者可以在其优势最耀眼的情况下充分利用 GraalVM 的潜力。

在我们结束对 GraalVM 及其细微考量的探索时，一个明显的结论是，这个创新的 JVM 替代品在 Java 开发的不断演变格局中是一个不容忽视的力量。从其高性能 JIT 编译器到多语言语言运行时，GraalVM 提供了一套引人入胜的功能，可以将应用程序开发提升到新的高度。虽然我们已经讨论了涉及的权衡，但认识到这些考虑是符合特定项目要求做出明智决策的必要组成部分。

此外，我们通过 GraalVM 的最佳用例之旅，揭示了其优势最耀眼的应用场景，从微服务架构到资源密集型云应用。然而，故事还没有结束。通过允许开发者提前将应用程序编译成独立的可执行文件，完全绕过部署时对 JVM 的需求，GraalVM 的本地图像功能将叙事进一步推进。它为深入探讨本地图像奠定了基础，其中 GraalVM 的能力得到扩展，提供了一种更加流畅、高效和资源友好的应用程序部署方法。随着我们揭开 GraalVM 本地图像释放的可能性，我们正在用无与伦比的效率和创新能力重塑 Java 开发格局。

# 本地图像

欢迎参加一个专注于 GraalVM 的启发式研讨会，这是一项颠覆传统 JVM 边界的变革性技术。由 Oracle Labs 开发，GraalVM 作为一个多面手解决方案出现，引入了重新定义应用程序开发格局的革命性功能。本节是您了解 GraalVM 关键方面的入门，从其高性能 JIT 编译器到多语言语言运行时和创新的 AOT 编译。随着我们深入探讨 GraalVM 的架构和能力，您将了解它是如何满足现代应用程序不断变化的需求的。加入我们的 GraalVM 探索之旅，在这里创新与多功能性相遇，发现它是如何赋予开发者创建高效、多语言应用程序的能力，这些应用程序将 Java 生态系统的可能性推向了新的高度。

GraalVM 最显著的特点之一是其原生图像功能，这是一种变革性的能力，将应用程序部署推进到一个新时代。与在 JVM 上运行的常规 Java 应用程序不同，GraalVM 的原生图像功能使开发者能够在部署前将应用程序编译成独立的可执行文件。在部署期间，应用程序被打包成一个自包含的二进制文件，直接与操作系统交互，绕过了需要中间虚拟机的需求。

原生图像方法的关键优势在于其在启动时间和运行时性能方面的效率提升。通过消除 JVM 解释和执行代码的需求，原生图像显著减少了应用程序的启动时间，使其在快速响应至关重要的场景中变得理想。此外，没有 JVM 的存在减少了应用程序的内存占用，提高了资源利用率，使其更适合资源受限的环境。

然而，也应强调，AOT 编译消除了 JIT 编译的精确好处，因为字节码在运行时不再可用，无法根据代码行为的变化来优化代码。在许多应用程序运行时间较长的案例中，快速启动的收益虽然显著，但可能部分被抵消，因为整体性能由于缺乏动态运行时优化而降低。关于 AOT 和 JIT 之间这种权衡的详细探讨，您可以参考这篇有洞察力的演示：[`www.azul.com/blog/jit-performance-ahead-of-time-versus-just-in-time/`](https://www.azul.com/blog/jit-performance-ahead-of-time-versus-just-in-time/)。

虽然 GraalVM 的原生图像功能在启动时间、内存效率和资源利用率方面带来了显著的优势，但它也带来了开发者应仔细考虑的权衡：

+   **构建时间和复杂性**：创建原生图像涉及 AOT 编译，这发生在构建阶段。与在基于 JVM 的应用程序中使用的传统 JIT 编译相比，这个过程更加耗时。此外，配置原生图像构建可能更加复杂，需要开发者管理本地库、反射访问和其他考虑因素，以实现最佳结果。

+   **动态类加载和反射**：原生图像在编译期间需要对应用程序的代码进行静态分析，这可能给那些高度依赖动态类加载或反射的应用程序带来挑战。由于原生图像编译器需要在构建时知道完整的类和方法集，因此动态加载或生成的代码可能需要特殊处理，可能需要调整应用程序代码。

+   **有限的运行时配置文件**：AOT 编译需要全面了解应用程序在构建阶段的行为。对于具有复杂运行时行为或动态适应各种场景的应用程序来说，这可能具有挑战性。在这种情况下，原生图像可能无法捕获完整的运行时配置文件，从而导致潜在的性能权衡。

+   **平台依赖性**：原生图像生成特定平台的二进制文件，可能引入跨平台兼容性的挑战。虽然 GraalVM 提供了一定程度的交叉编译支持，但开发者必须注意潜在的平台依赖性，并在目标平台上彻底测试他们的应用程序。

+   **包含库的占用**：在原生图像中包含某些库可能会增加大小，可能抵消一些内存效率的收益。开发者必须仔细选择和优化包含在原生图像中的依赖项，以在占用和功能之间取得正确的平衡。

在导航应用程序部署的领域中，理解原生图像应用程序和运行在 JVM 上的应用程序之间的基本区别变得至关重要。这种差异在于它们执行和资源利用的方法。通过 GraalVM 的创新 AOT 编译技术制作的原生图像应用程序，以其简化的启动时间和较小的内存占用而突出。它们在部署期间无需 JVM，作为独立的可执行文件直接与操作系统交互。相比之下，基于 JVM 的应用程序具有跨平台的可移植性，可以在任何配备兼容 JVM 的环境上运行。接下来，我们将深入探讨这些差异的细微之处，阐明启动时间、内存效率和应用可移植性等方面的影响。通过揭示这些区别，开发者可以根据项目特定的需求做出明智的选择，实现性能、可移植性和资源利用之间的最佳平衡：

+   **启动时间**：原生图像应用程序在启动时间方面表现出色，因为它们消除了与初始化 JVM 相关的开销。这对于生命周期短的应用程序或微服务来说尤其有利，因为这些场景下快速响应至关重要。相比之下，基于 JVM 的应用程序通常具有较长的启动时间，因为 JVM 需要在运行时解释和编译代码。

+   **内存占用**：与 JVM 对应的原生图像应用程序通常具有更小的内存占用。由于无需 JVM，运行虚拟机的开销被消除，从而实现了更有效的资源利用。这使得原生图像应用程序非常适合对内存约束严格的 环境。

+   **可移植性**：JVM 应用程序以其可移植性而闻名——能够在任何具有兼容 JVM 的平台上运行。另一方面，Native Image 应用程序，由于编译成特定平台的二进制文件，可能存在平台依赖性。虽然 GraalVM 提供了一定程度的交叉编译支持，但在使用 Native Image 时，考虑平台特定的影响是至关重要的。

深入探讨应用程序部署的复杂决策过程，以下比较表揭示了 Native Image 应用程序与在 JVM 上运行的应用程序之间的独特特征。每一列都封装了影响性能、资源利用率和适应性的关键方面。通过 GraalVM 的创新 AOT 编译，Native Image 应用程序具有加速的启动时间和较小的内存占用，特别适合优先考虑效率的场景。相比之下，基于 JVM 的应用程序具有跨平台兼容性和动态适应性的优势，利用 JIT 编译。此表为开发者提供指南，提供简洁而全面的指南，以导航权衡并基于项目的具体需求做出明智的决定：

| **功能** | **Native Image 应用程序** | **基于 JVM 的应用程序** |
| --- | --- | --- |
| **启动时间** | 通常更快 | 可能较慢，取决于 JIT 编译 |
| **内存占用** | 较小 | 较大 |
| **构建时间** | 由于 AOT 编译而较长 | 由于 JIT 编译而较短 |
| **动态** **类加载** | 受限；需要谨慎处理 | 更灵活 |
| **反射** | 受限；需要谨慎处理 | 更灵活 |
| **平台可移植性** | 特定平台的二进制文件 | 兼容 JVM 的跨平台 |
| **资源利用** | 效率较高；开销较低 | 可能具有更高的开销，取决于 JVM |
| **依赖包含** | 需要优化以管理大小 | 使用依赖管理器更容易管理 |
| **对** **运行时变化的适应性** | 动态性较低；需要谨慎处理 | 更适应，利用 JIT 编译 |
| **构建复杂性** | 较高；需要配置 | 较低；通常由 JVM 处理 |

表 7.1：Native Image 与 JVM 对比

此表提供了 Native Image 与基于 JVM 应用程序之间关键差异的高级概述。需要注意的是，选择两者之间的差异取决于具体的项目需求，考虑因素包括启动时间、内存效率、平台可移植性和在动态功能中所需的灵活性。

在探索原生图像应用程序及其对应程序之间的差异时，我们可以清楚地看到，实现最佳应用程序部署的道路是复杂且多层次的。这次比较之旅揭示了两种方法独特的优势和考虑因素，引导开发者做出与项目优先级相一致的有信息量的决策。现在，随着我们对权衡和益处的理解更加丰富，我们站在了实际掌握的门槛上。

在即将到来的会话中，我们将深入探讨使用 GraalVM 创建原生图像的实际领域。我们将揭示 AOT 编译过程的复杂性，揭开将 Java 应用程序转换为独立可执行文件的步骤。从优化依赖项到处理特定平台的考虑因素，这次动手探索将赋予你利用原生图像部署效率提升的能力。请加入我们，在下一节中，我们将踏上解锁原生图像潜力、利用 GraalVM 的开创性能力重塑应用程序部署格局的实际旅程。

# 创建原生图像

在这个沉浸式和动手操作的章节中，我们将深入掌握使用 GraalVM 创建原生图像。在比较探索原生图像应用程序和 JVM 对应程序所获得的见解的基础上，这一章节是你通往应用程序部署效率实际领域的门户。随着我们从理论转向实践，我们的重点现在集中在赋予你运用原生图像编译的变革性能力。准备开始一段旅程，我们将揭开 AOT 编译过程的神秘面纱，提供将 Java 应用程序转换为独立可执行文件的逐步指导。

在本节中，我们将深入探讨优化依赖项、处理特定平台的考虑因素以及释放原生图像部署的完整潜力。无论你是寻求提升应用程序性能的资深开发者，还是渴望探索 GraalVM 技术前沿的热心爱好者，这次动手实践将为你提供将原生图像编译无缝集成到你的开发工具包中的实用技能。让我们深入其中，将理论转化为实践，在导航创建原生图像的过程中，利用 GraalVM 的革命性能力重塑应用程序部署的格局。

在这个动手实践部分，我们将通过一个既简单又富有说明性的 Java 应用程序，深入探索原生图像编译的激动人心世界。`App`类被设计用来向世界打印问候语，并在一个超级愚蠢的转折中，反转一个给定的字符串。当我们探索代码时，你会注意到它并不是典型的“Hello, World!”示例。相反，它引入了一个名为`reverseString`的方法，该方法递归地反转一个给定的字符串。应用程序首先打印一个问候语，然后使用`reverseString`方法反转字符串“Native Image is awesome”。

这个有趣的示例是我们原生图像实验的画布。通过这个练习，我们不仅将见证原生图像的创建，还将深入了解优化过程以及带来的效率提升。所以，系好安全带，随着我们穿越创建原生图像的这个既愚蠢又富有教育意义的 Java 应用程序，让我们将这种奇妙变为现实，并探索与 GraalVM 一起使用原生图像的魔力：

```java
public class App {    public static void main(String[] args) {
        System.out.println("Hello, World! with Native image");
        String str = "Native Image is awesome";
        String reversed = reverseString(str);
        System.out.println("The reversed string is: " + reversed);
    }
    public static String reverseString(String str) {
        if (str.isEmpty())
            return str;
        return reverseString(str.substring(1)) + str.charAt(0);
    }
}
```

设置 GraalVM 是我们掌握原生图像编译旅程中的关键步骤。为了简化这个过程并轻松管理不同的 Java 版本，我们将利用 SDKMan 项目。SDKMan 简化了不同 Java 版本的安装和切换，为开发者提供无缝的体验。

对于手动安装，你可以参考官方的 GraalVM 文档。然而，为了使我们的生活更简单，让我们使用 SDKMan 来安装 GraalVM。在撰写本文时，我们选择的是带有 GraalVM 支持的 21.0.1 版本。在你的终端中执行以下命令：

```java
sdk install java 21.0.1-graal
```

此命令通过 SDKMan 获取并安装 GraalVM 版本 21.0.1。一旦安装完成，你可以将其设置为系统默认的 Java 版本，或者在选择当前终端会话中使用它。如果你希望将其设置为默认版本，请使用以下命令：

```java
sdk use java 21.0.1-graal
```

现在，随着 GraalVM 无缝集成到你的开发环境中，我们已经做好了探索原生图像创建的准备。让我们开始这个动手旅程的下一步，我们将结合 GraalVM 的力量与 SDKMan 的简单性。

创建原生图像是我们探索的关键下一步，这个过程涉及一系列用于编译、打包，最后生成原生图像的命令。让我们将其分解：

1.  **编译 App 类**：

    ```java
       javac -d build src/main/java/expert/os/App.java
    ```

    此命令编译`App`类，并将编译后的文件存储在`build`目录中。

1.  **创建一个** **JAR 文件**：

    ```java
       jar --create --file App.jar --main-class expert.os.App -C build .
    ```

    在这里，我们将编译后的文件打包成一个名为`App.jar`的 JAR 文件，并指定主类为`expert.os.App`。

1.  **创建一个** **原生图像**：

    ```java
       native-image -jar App.jar
    ```

    利用 GraalVM 的`native-image`工具，我们从 JAR 文件生成原生图像。这一步涉及 AOT 编译，生成一个独立的可执行文件。

1.  **执行原生图像**：

    ```java
    ./App
    ```

创建了原生图像后，我们可以运行可执行文件。在执行时，控制台将显示以下输出：

```java
   Hello, World! with Native image   The reversed string is: emosewa si egamI evitaN
```

恭喜！您已成功完成使用 GraalVM 创建原生图像的过程，将我们那看似简单的 Java 应用程序转换成了一个精简的、独立的可执行文件。这次动手实践为探索原生图像编译提供的效率提升和优化可能性奠定了基础。让我们享受这些成果，并继续我们的 GraalVM 动态领域的探索之旅。

在我们使用 GraalVM 创建原生图像的这一节结束时，很明显，我们已经踏上了一段变革性的应用程序部署之旅。通过无缝集成 GraalVM 的力量，我们将一个有趣味的 Java 应用程序转换成了一个独立的可执行文件，解锁了启动时间和资源利用率的效率提升。

通过细致的编译步骤和 AOT 处理的魔力，我们见证了原生图像的诞生。我们的可执行文件的输出不仅回响了熟悉的“Hello, World！”问候，还展示了字符串的奇妙反转——这是 GraalVM 多功能性的证明。

这次动手实践为进一步的探索奠定了坚实的基础。有了原生图像，开发者可以深入研究现实世界应用程序，优化性能并导航高效资源利用的复杂性。然而，旅程并未结束；它延伸到了 GraalVM 能力的动态领域。

在庆祝我们成功执行原生图像的同时，让这成为您继续探索 GraalVM 解锁的可能性和效率的催化剂。冒险仍在继续，下一章等待着，承诺带来对 Java 应用程序开发迷人世界的更深入见解和掌握。

# 摘要

在本章中，我们深入探讨了 GraalVM 的变革能力，从其高性能编译器到原生图像的创建。通过 AOT 编译实现的效率提升标志着重要的里程碑，展示了 GraalVM 在重塑 Java 开发格局方面的多功能性。

在本章结束时，它成为下一章更广泛探索 JVM 生态系统和替代 JVM 的垫脚石。我们将揭示超越传统 JVM 的多样化选项，如 OpenJ9 和 Azul Zing，提供对这些独特功能和它们对不断发展的 Java 生态系统的贡献的见解。请加入我们，在下一章中，我们将根据我们从 GraalVM 探索中获得的知识，在 JVM 领域的多样化路径中导航。

# 问题

回答以下问题以测试您对本章的知识：

1.  GraalVM 的原生图像编译的主要好处是什么？

    1.  增加的内存占用

    1.  较慢的启动时间

    1.  平台可移植性

    1.  语言支持有限

1.  在 GraalVM 本地图像创建过程中，用于编译 **App** 类的命令是什么？

    1.  **compile -****class App**

    1.  **javac -d** **build src/main/java/expert/os/App.java**

    1.  **native-image --****compile App**

    1.  **graalvm-compile App.java**

1.  提供的 Java 应用程序中 **reverseString** 方法的目的是什么？

    1.  连接字符串

    1.  反转一个给定的字符串

    1.  检查回文

    1.  从字符串中删除空白字符

1.  GraalVM 的本地图像在启动时间方面与基于 JVM 的应用程序有何不同？

    1.  本地图像具有较慢的启动时间

    1.  它们都有相似的启动时间

    1.  本地图像具有更快的启动时间

    1.  基于 JVM 的应用程序具有更快的启动时间

1.  在 GraalVM 安装的情况下，SDKMan 的用途是什么？

    1.  管理 Java 版本和安装

    1.  创建本地图像

    1.  调试 Java 应用程序

    1.  管理 Docker 镜像

1.  在 GraalVM 本地图像创建过程中，**native-image** 命令做什么？

    1.  编译 Java 源代码

    1.  生成一个独立的可执行文件

    1.  下载 Java 依赖项

    1.  执行 Java 应用程序

# 答案

这里是本章问题的答案：

1.  C. 平台可移植性

1.  B. **javac -d** **build src/main/java/expert/os/App.java**

1.  B. 反转一个给定的字符串

1.  C. 本地图像具有更快的启动时间

1.  A. 管理 Java 版本和安装

1.  B. 生成一个独立的可执行文件
