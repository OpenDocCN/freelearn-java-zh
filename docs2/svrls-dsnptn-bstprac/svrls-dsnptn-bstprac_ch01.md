# 简介

在软件行业，这是一个激动人心的时刻。在过去的几年里，我们看到了架构模式的演变，从大型单体应用向微服务的重大转变。随着云计算的发展，我们软件开发者可用的系统和服务的数量也在增加。在这个领域最具革命性的工具之一是 lambda 函数，或者更准确地说，是“函数即服务”。它超越了微服务，能够作为一个不同实体运行、管理和部署单个函数，这使我们进入了纳米服务的领域。

当然，本书专注于无服务器计算的设计模式。那么，首先应该从：什么是设计模式，什么是无服务器计算？开始。

如果你刚开始探索无服务器系统和模式的世界，我鼓励你阅读其他资源，以获取更多关于这些和相关主题的详细信息。我们即将进行的讨论旨在为构建具有模式的系统奠定基础，但无需对无服务器平台或其概念进行详尽的解释。

在本章中，我将在深入探讨这些主题之前，首先定义一些相关术语和概念。然后，我将讨论无服务器架构何时或何时不适合。最后，我将解释本书中将要介绍的各类无服务器模式。我假设你，作为读者，对这些大型主题有一定的了解，但绝对精通不是必需的。

在本章结束时，你应该能够做到以下几件事情：

+   用你自己的话描述“无服务器”这个术语

+   了解设计模式与无服务器架构的关系

+   理解无服务器设计模式的一般分类

# 什么是无服务器计算？

让我们先从这两个问题中较简单的一个开始——什么是无服务器计算？虽然可能存在几种定义无服务器计算或更准确地说无服务器架构的方法，但大多数人可以就几个关键属性达成一致。无服务器计算平台共享以下特性：

+   无需配置或管理操作系统

+   按调用付费的计费模式

+   能够根据使用情况自动扩展

+   内置可用性和容错性

尽管无服务器平台具有其他一些属性，但它们都具备这些共同特征。此外，还有一些无服务器系统提供除通用计算能力之外的功能。这些系统的例子包括 DynamoDB、Kinesis 和简单队列服务，它们都属于亚马逊网络服务（AWS）的范畴。尽管这些系统不是按调用付费，但它们属于无服务器类别，因为底层系统的管理委托给了 AWS 团队，扩展只需更改几个设置，容错性是内置的，高可用性是自动处理的。

# 无需管理服务器

毫无疑问，这就是“无服务器”这个术语的来源，也是整个运动的中心。如果我们回顾不久前的时光，我们可以看到当时运维团队必须购买物理硬件，将其安装在数据中心，并对其进行配置。所有这些都是在工程师有机会部署他们的软件之前必须完成的。

当然，云计算彻底改变了这个过程，将其颠倒过来，将个人工程师置于驾驶员的位置。通过几点击或 API 调用，我们现在可以在几分钟内而不是几周或几个月内获得我们自己的**虚拟专用服务器**（**VPS**）。虽然这过去和现在都极大地提高了效率，但设置系统的许多工作仍然存在。以下是一些需要担心的事项的简短列表：

+   更新操作系统

+   保护操作系统

+   安装系统包

+   处理依赖管理

这个列表可以一直继续下去。值得注意的是，在我们可以部署和测试我们的软件之前，可能需要花费数小时进行配置和管理。

为了减轻系统设置的压力，像 Puppet、Chef、SaltStack 和 Ansible 这样的配置软件应运而生。同样，这些工具在过去和现在都极大地提高了效率。一旦你有了你的食谱，配置一个新的虚拟主机，最重要的是，是可重复的，并且可能比手动设置更少出错。在由数百甚至数千个虚拟服务器组成的系统中，一些自动化是必需的，而不仅仅是便利。

尽管这些配置工具非常可爱，但它们确实伴随着高昂的拥有成本，并且开发和维护它们可能非常耗时。通常，迭代这些基础设施即代码工具需要做出更改然后执行它们。启动一个新的虚拟主机比设置物理服务器快得多；然而，我们测量 VPS 启动时间和配置时间以分钟为单位。此外，这些本身就是软件系统，需要专门的团队来学习、测试、调试和维护。在此基础上，你还需要在操作系统任何更改的同时持续维护和更新配置工具和脚本。如果你想要更改基础操作系统，这是可能的，但需要大量的投资和对现有代码的更新。

当 AWS 在 2014 年推出 Lambda 时，一种新的计算和软件管理范式诞生了。与管理和维护虚拟主机相比，AWS Lambda 为开发者提供了在托管环境中部署应用程序代码的能力，而无需自己管理虚拟主机。当然，某处有服务器在运行，由某人运营。然而，这些服务器的细节对我们这些应用程序开发者来说是模糊不清的。我们不再需要直接担心操作系统及其配置。有了 AWS Lambda 和其他函数即服务（FaaS）平台，我们现在可以将 VPS 管理的任务委托给那些平台背后的团队。

FaaS 平台最显著的思想转变是度量单位已从虚拟机缩小到单个函数。

# 按调用付费计费模型

无服务器平台的发明带来的另一个重大变化是按调用付费的模型。在此之前，计费模型通常是按分钟或小时计费。虽然这是弹性计算的基础，但在任何生产环境中使用时，服务器需要保持运行和运行。

在开发时，只为运行中的 VPS 付费是一个很好的模型，因为你可以在一天开始时启动它。

每天开始时启动它，并在结束时停止它。然而，当系统需要始终可用时，无论其 CPU 使用率是 100%还是 0.0001%，你付出的价格几乎是一样的。

另一方面，无服务器平台只在代码执行时计费。它们被设计和优化用于无状态系统和有限、相对较短的时间段。因此，计费通常基于总调用时间。这种模式对于每天可能只收到几个调用或调用的较小系统来说非常有效。在许多平台上，可以运行一个始终可用的生产系统，而且完全免费。在无服务器世界中，没有空闲时间。

# 自动根据使用情况扩展的能力

那些需要为系统配置比通常所需更多的虚拟主机来过度配置系统的日子已经过去了。随着调用数量的增加，底层系统会自动扩展，为你提供已知数量的并发调用。将这个限制提高只是向亚马逊提出支持请求的问题，在 AWS Lambda 的情况下。在此之前，管理横向扩展是系统设计团队的练习。计算资源的横向扩展从未如此简单。

不同的云服务提供商提供了根据各种参数和指标进行扩展或缩减（即弹性）的能力。与使用自动扩展的系统运行系统的 DevOps 人员或工程师交谈，他们会告诉你这不是一件小事，而且很难做对。

# 内置可用性和容错性

服务器，无论是真实的还是虚拟的，都可能失败。由于运行你的代码的主机对你来说现在几乎或根本不重要，所以这是一个不值得担忧的问题。

正如操作系统管理是由你处理的，同样，失败服务器的管理也是由你处理的。你可以保证，当你的应用程序代码应该被调用时，它将会被调用。

# 设计模式

在我们对无服务器计算有了良好的理解之后，让我们将注意力转向设计模式。

如果你花过任何时间与软件打交道，你肯定听说过“设计模式”这个术语，并且可能在一定程度上熟悉它们。稍微退一步，让我们讨论一下什么是设计模式。

我将断言，如果你问 10 个不同的开发者定义“设计模式”这个术语，你会得到 10 个不同的答案。虽然我们可能都有自己的定义，而且这些定义可能并不错误，但相对简单的是，我们可以就软件设计模式的一般精神或理念达成一致。在软件工程背景下，设计模式是应用于频繁出现问题的可重用解决方案或代码组织。例如，模型-视图-控制器模式是为了解决 GUI 应用程序的问题而演变的。模型-视图-控制器模式几乎可以在任何语言中实现，适用于几乎任何 GUI 应用程序。

软件设计模式是为了帮助软件作者通过应用已知和经过验证的模板到他们的应用程序代码中来提高效率而演变的解决方案。同样，架构模式提供了相同的益处，但是在整体系统设计的层面，而不是在代码层面。

在这本书中，我们不会关注软件设计，而是关注无服务器系统中的架构设计。在这方面，值得注意的是，本书的背景是无服务器架构，我们的模式将体现为可重用的解决方案，你可以使用这些解决方案来组织你的函数和其他计算资源，以解决你在所选无服务器平台上的各种类型的问题。

当然，组织你的应用程序代码有无限种方式，你可以使用数百种软件和架构模式。这里的主要焦点是你函数的一般组织或分组，它们如何相互交互，每个函数的角色和责任，以及它们在独立操作时如何运作，但又能共同组成一个更大、更复杂的系统。

随着无服务器系统越来越受欢迎，我预计我们将在本书中讨论的无服务器模式在受欢迎程度和数量上都将增长。

# 何时使用无服务器

许多类型的计算问题都可以用无服务器设计来解决。就我个人而言，由于它们提供的速度、灵活性和适应性，我现在很难不使用无服务器系统。适合无服务器系统的计算问题类别非常广泛。然而，在处理新问题时，仍有一个值得注意的“甜蜜点”。在“甜蜜点”之外，有一些问题并不适合。

# “甜蜜点”

由于无服务器系统基于单个函数运行，因此它们非常适合以下子系统的问题，或者可以将这些问题分解为以下子系统：

+   无状态

+   计算量小且可预测

无服务器函数是短暂的；也就是说，它们有一个已知的生命周期。本身是无状态的计算是 FaaS 平台发光的问题类型。应用程序状态可能存在，函数可以使用数据库或其他类型的数据存储来存储该状态，但函数本身在调用之间不保留任何状态。

在计算资源方面，无服务器函数在内存和总持续时间上都有一个上限。您的软件应该有一个预期或可预测的上限，这个上限应低于您的 FaaS 提供商的上限。在撰写本文时，AWS Lambda 函数的内存上限为 1,536 MB，持续时间上限为 300 秒。Google Compute 宣称的上限为 540 秒。无论实际值如何，只要系统能够在这些限制内可靠地运行，那么这些系统就是迁移到无服务器架构的良好候选者。

一个很好的、尽管是微不足道的例子是数据转换函数——给定一些输入数据，将其转换成不同的数据结构。从这样一个简单的例子中可以清楚地看出，在每次调用之间不需要也不携带任何状态。当然，数据的大小各不相同，但如果您的系统接收到的数据大小可预测，您应该能够在一定时间内处理这些数据。

相比之下，共享状态的长运行过程不适合无服务器。原因是函数在其生命周期结束时死亡，任何内存状态也会随之死亡。想象一下像应用程序服务器处理 WebSocket 连接这样的长运行过程。

根据定义，WebSocket 是有状态的，可以比作电话通话——客户端打开到服务器的连接，只要客户端愿意，这个连接就会保持打开状态。以下两种原因使得这种场景不适合无服务器函数：

+   存在状态（即电话通话的状态是连接还是断开）

+   该过程持续时间长，因为连接可以保持数小时或数天。

每当我遇到一个新问题并开始考虑无服务器时，我都会问自己这两个问题：

+   应用程序代码中是否涉及任何需要跟踪的全局状态？

+   要执行的计算是否超出了我的无服务器平台系统限制？

好消息是，对于这些问题，答案往往是“不”，我可以继续前进并使用无服务器架构构建我的应用程序。

# 无服务器模式类别

在这本书中，我们将讨论四种主要的无服务器设计模式：

+   三层 Web 应用程序模式

+   **提取**、**转换**、**加载**（**ETL**）模式

+   大数据模式

+   自动化和部署模式

# 三层 Web 应用程序模式

基于传统请求/响应周期的 Web 应用程序是服务器无服务系统的理想选择。因为无服务器函数是短暂的，它们非常适合那些本身也是短暂和无状态的問題。我们已经看到有状态系统出现并变得流行，例如 WebSockets；然而，大部分的网页和 Web 应用程序仍然运行在传统的无状态请求/响应周期中。在我们的第一组模式中，我们将构建不同版本的 Web 应用程序 API。

虽然需要涵盖三种不同的 Web 应用程序模式，但它们都将共享一个共同的基础，即三层模型。在这里，层由以下组成：

+   内容分发网络（CDN）用于展示代码/静态资源（HTML、JavaScript、CSS 等）

+   用于持久化的数据库

+   用于应用程序逻辑的无服务器函数

REST API 应该是大多数 Web 开发人员常见且熟悉的工具。在第二章，“使用 REST 的三层 Web 应用程序”，我们将构建一个具有完整功能的 REST API，该 API 将具有经典 REST API 中所有预期的功能——**创建**、**读取**、**更新**、**删除**（**CRUD**）。

虽然 REST API 很常见且易于理解，但它们确实面临一些挑战。在开始使用无服务器 REST API 之后，我们将介绍设计更改的过程，以使相同的 API 在第三章，“带有 GraphQL 的三层 Web 应用程序模式”中作为一个单一的 GraphQL 端点提供相同的功能。

最后，在第四章，“使用代理模式集成遗留 API”，我们将使用代理模式来展示如何完全改变一个 API，但使用遗留 API 后端。这种设计对于那些希望开始将 API 迁移到无服务器平台但需要维护现有 API 的人来说特别有趣。

# ETL 模式

ETL 模式是计算领域另一个非常适合无服务器平台的领域。在较高层面，ETL 作业包括以下三个步骤：

+   从一个数据源提取数据

+   适当地转换数据

+   将处理后的数据加载到另一个数据源

经常用于分析和/或数据仓库的 ETL 任务难以避免。由于这个问题又是短暂的，而且用户可能希望他们的 ETL 任务尽可能快地执行，因此无服务器系统在这个问题领域是一个很好的平台。虽然无服务器计算通常是短暂的，但我们将看到如何设计 ETL 流程以使其长时间运行，以便处理大量数据。

在第五章“使用扇出模式扩展”中讨论的扇出模式中，一个单独的工作单元将被分解成多个更小的单元，并并行处理。这个模式可以用作独立系统或更大系统中的子组件。我们将使用扇出模式构建一个独立的应用程序，但稍后我们将讨论它如何作为一个更大系统中的组成部分工作。

消息模式本身可以是一个完整的模式类别。在我们的上下文中，我们将展示如何使用这个通用模式以已知或固定的处理能力异步处理数据。第六章“使用消息模式进行异步处理”，将介绍这个模式及其变体在无服务器环境中的完整示例。

# 大数据模式

可能会让人困惑的是，*lambda* 可以指 AWS Lambda 函数，也可以指一个模式本身。Lambda 模式源于实时分析大量数据的需求。在此之前，大数据运动中，大型批量作业会运行以计算和重新计算事物，正处于全速运转。这个运动面临的问题是，这些批量作业为了得到最新的结果，需要花费大部分计算资源重新计算未发生变化的数据的指标。

Lambda 模式，我们将在第七章“使用 Lambda 模式进行数据处理”中讨论，创建了两个并行的计算平面，一个批处理层和一个速度层。这些层的命名应该能让你了解它们各自负责的内容。

MapReduce 是另一个众所周知且经过测试的范式，在软件世界中已经流行了一段时间。Hadoop，可以说是最著名的 MapReduce 框架，在 2004 年 Google 原始的 MapReduce 论文发布后，帮助将这个模式推向了前台。

尽管 Hadoop 作为一个软件系统非常出色，但要运行自己的生产级 Hadoop 集群仍然存在许多障碍。因此，像 Amazon 的**弹性 MapReduce**（**EMR**）这样的系统被开发出来，为开发者提供按需的 Hadoop 作业。然而，编写 Hadoop 作业和管理底层计算资源可能并不简单。我们将在第八章 MapReduce 模式中介绍如何编写你的无服务器 MapReduce 系统。

# 自动化和部署模式

我们中的许多人习惯于通过 `ssh` 登录到一台机器，并通过 grep 查找日志文件以查找问题。现在，由于没有服务器可以 SSH 登录，我们的世界已经完全颠倒。幸运的是，有处理错误和获取调试和监控程序所需信息的方法。

在第九章 部署和 CI/CD 模式，我们将重点关注错误处理，以及无服务器系统的一些“应该做”和“不应该做”的事项，以及无服务器世界中的现代最佳实践。当在无服务器平台上构建时，许多开发实践都会发生变化，而且有很多陷阱，如果你不熟悉它们，可能会让你感到惊讶。第九章，*部署和 CI/CD 模式*，将探讨一些如果你是新手可能会遇到的最大问题。

虽然一些工具和技术可能会发生变化，但我们不要忘记，一个健康的软件开发生命周期包括结构良好的代码、**持续集成**（**CI**）、**持续部署**（**CD**）和单元测试。结合众多的托管 CI/CD 平台，运行测试和自动部署代码变得相当轻松，甚至很有趣。第十章，*部署和 CI/CD 模式*，将讨论托管 CI 和 CD 平台的各种选项和示例。我相信你会发现使用无服务器技术发布代码的速度既令人兴奋又具有启发性。

# 无服务器框架

随着无服务器平台的出现，出现了多个框架来帮助我们管理我们的无服务器应用程序。正如 Ruby on Rails、Spring、Django、Express 和其他网络框架有助于创建和管理网络应用程序一样，各种无服务器框架也应运而生，使无服务器应用程序的软件开发生命周期变得更加容易。

服务器框架和无服务器框架之间的一个基本区别是，无服务器框架通常有助于在无服务器平台上管理应用程序代码。相比之下，大多数网络框架提供的帮助都围绕着网络逻辑和以下任务：

+   通过模板引擎生成 HTML 输出

+   通过对象关系映射器（ORM）管理数据库记录

+   验证提交的表单数据

+   处理 HTTP 请求和响应的细节

并非所有在无服务器平台上运行的应用程序都是基于 HTTP 的。因此，无服务器框架不一定具有特定于应用程序的功能，而是具有部署和管理功能。一些框架针对 Web 开发者，并有助于 Web 中心任务；然而，还有几个其他框架并不针对 Web 开发者，而是专注于管理任意应用程序代码。

值得注意的几个流行的无服务器框架如下：

+   Apex

+   无服务器

+   ClaudiaJS

+   Kappa

+   SAM (AWS 的无服务器应用程序模型)

+   Chalice（来自 AWS）

+   Zappa

在整本书中，我将使用无服务器框架来管理应用程序代码以及我们在示例中部署的所有资源堆栈。无服务器与各种编程语言和平台一起工作，例如 AWS、Azure、Google Compute Cloud 和 IBM Open Whisk。我们将使用 AWS 构建所有示例，但讨论的模式应该适用于其他云提供商，除非明确指出否则不适用。由于 Zappa 之类的无服务器框架不提供任何特定的 Web 功能，我们将在第二章，“使用 REST 的分层 Web 应用程序”和第三章，“使用 GraphQL 的分层 Web 应用程序模式”中负责一些较低级别的 Web 应用程序细节。

# 摘要

在本介绍中，我们涵盖了有关无服务器平台的主要观点，并讨论了使一个系统成为无服务器的属性。我们比较了在自管理系统（无论是物理的还是虚拟的）上构建软件与在无服务器平台上构建软件系统之间的主要区别。此外，读者应该对何时无服务器架构是一个好的选择以及何时不是有更清晰的看法。

我们还回顾了本书中我将涵盖的主要设计模式类别，并对每个类别进行了高级概述。最后，我讨论了 Web 和无服务器框架之间的区别，并给出了一些后者的例子。

阶段设置完毕后，我们可以通过一个现实世界的例子来进入我们的第一个模式。到第二章，“使用 REST 的分层 Web 应用程序”结束时，我们将使用无服务器技术构建一个完整的分层 Web 应用程序，使用 REST API。
