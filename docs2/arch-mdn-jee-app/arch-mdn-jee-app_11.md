# 第十一章：结论

我希望这本书中我们所学的所有内容都能为如何构建现代、轻量级、面向业务的企业应用程序提供有价值的见解。也许这本书甚至能消除一些过时的最佳实践。

我们已经看到了现代版本的 Java EE 如何融入一个全新的软件开发世界，它拥抱了容器技术、云平台、自动化、持续交付以及更多。

# 企业开发中的动机

正如我们在本书中多次看到的，工程团队在开发软件时应遵循正确的动机。企业系统的主要焦点应该是其业务动机。在能够为顾客提供价值之前，应用程序的领域和业务用例需要明确。最终，能够完成业务功能的实际工作软件才是产生收入的关键。

开发者可以随着时间的推移问自己一个有用的问题：*我们正在做的事情是否有助于解决业务问题？*

以满足客户需求为目的的软件因此主要关注满足业务用例。满足次要需求的技术，如通信、持久性或分发，则次之。所选解决方案应首先解决业务需求。

因此，技术、编程语言和框架理想情况下应支持在不增加太多开销的情况下实现用例。建议工程师团队选择他们既高效又熟悉的、同时符合这一要求的技术。

# 云和持续交付

我们已经看到了在快速变化的世界中快速行动的必要性。重视敏捷性和对客户需求、上市时间或更好的*生产时间*的响应性非常重要。最好的功能只有在客户手中才能提供价值。

使用有助于实现这一目标的概念和技术是有意义的，例如持续交付、自动化、基础设施即代码和自动软件测试。

这就是现代环境和云技术最大的好处：*快速行动的能力*。使用明确定义的规范，可以在几分钟内创建新项目、功能或测试场景的应用程序环境。特别是，基础设施即代码和容器技术支持这些尝试。软件开发者将环境配置与应用程序代码一起交付，这些代码包含在项目的存储库中。

因此，定义企业软件的所有内容成为整个工程团队的责任。开发人员和运维工程师都希望推出对用户有价值的软件。整个软件团队对实现这一目标负有责任。

这也包括软件质量保证的主题。只有当适当的、自动化的质量验证机制到位时，才能以快速的速度交付功能。需要人工干预且运行不可靠或不够快的测试会阻碍快速流程，并阻止开发者进行更有用的工作。投资于自动化、充分且可靠的测试用例，这些测试用例在构建时考虑到可维护性和代码质量，是必要的。

# Java EE 的相关性

我们已经看到了 Java EE 如何实现这一切。该平台通过允许开发者编写代码而不设置太多约束来支持关注业务需求。可以通过首先遵循领域需求来设计和实现用例。

技术本身并不需要**关注**。在大多数情况下，仅对业务逻辑进行注解就足够了，这会导致应用程序容器添加所需的技术必要性。Java EE 标准的方法，如 JAX-RS、JPA 或 JSON-B，以最小的努力完成所需的技术集成。

Java EE 平台特别使得工程师能够无缝集成多个标准，而无需进行配置工作。考虑到 Java EE 原则编写的 JSR 规范使得这一点成为可能。

现代 Java EE 必须与 J2EE 的旧时代有所不同。实际上，编程模型和运行时与 J2EE 几乎没有关系。

由于平台具有向后兼容的特性，过时的方法仍然可行，但自那时起技术已经取得了很大的进步。编程模型和设计模式已经被重新审视并大大简化。特别是，过去在实现由技术驱动的接口层次和超类时的模式限制已经消失。开发者能够专注于业务领域，而不是技术。

Java EE 标准的性质允许公司实现供应商独立的应用程序。这避免了在技术方面的供应商锁定。开发者也不专门接受针对特定供应商技术的培训。我们已经看到了很多团队，他们只熟悉已经过时的供应商。

Java EE 技术不仅用于服务器端。例如 JAX-RS、JSON-P 或 CDI 这样的标准为 Java SE 应用程序也提供了有价值的益处。使用开发者熟悉的标准化技术实现某些功能，如 HTTP 客户端，是有意义的。

# Java EE 8 中引入的 API 更新

本书专注于使用 Java EE 8 的企业应用程序。

在这个版本的过程中，某些标准已经得到了更新。以下是最重要的新特性和标准。

# CDI 2.0

自 Java EE 8 和 CDI 2.0 以来，事件不仅可以通过同步方式处理。正如我们在本书中之前看到的，CDI 原生支持异步处理事件。实际上，如果事件观察者方法是 EJB 的业务方法，并注解为`@Asynchronous`，在此之前这是唯一可行的方法。

为了发射和处理异步 CDI 事件，发布方使用`fireAsync`方法。观察者方法参数被注解为`@ObservesAsync`。

CDI 2.0 引入的另一个新事件功能是能够对事件观察者进行排序。因此，在事件观察者方法中指定了 Java EE 平台中广为人知的`@Priority`注解：

```java
public void onCarCreated(@Observes @Priority(100) CarCreated event) {
    System.out.println("first: " + newCoffee);
}

public void alsoOnCarCreated(@Observes @Priority(200) CarCreated event) {
    System.out.println("second: " + newCoffee);
}
```

这种方法保证了事件观察者按照指定的顺序被调用，优先级较低的先调用。开发者应该考虑是否需要排序事件处理器会违反松耦合和单一责任原则。

CDI 2.0 最大的特点是集成到企业容器之外，提供了在 Java SE 应用程序中使用 CDI 的可能性。这个想法是 Java SE 应用程序也可以使用复杂的依赖注入标准的特性。这旨在增加 CDI 在 Java EE 世界之外的可接受度。

# JAX-RS 2.1

JAX-RS 2.1 的 2.1 版本主要针对反应式客户端、SSE 以及更好地集成到 JSON-B 等标准。除此之外，还增加了一些小的改进。

反应式编程越来越被广泛使用，特别是客户端获得了新的反应式功能来执行 HTTP 调用并直接返回所谓的反应式类型。这种类型的一个例子是`CompletionStage`类型。这个类型是原生支持的；其他类型和库可以通过扩展添加。

为了进行反应式调用，使用`Invocation.Builder`的`rx()`方法。

正如本书中所示，JAX-RS 2.1 在客户端和服务器端都支持 SSE。SSE 标准代表了一种轻量级、单向的消息协议，它使用 HTTP 上的纯文本消息。

为了与 Java EE 平台的传统方法相匹配，Java EE 8 中添加的 JSON-B 标准被无缝集成到 JAX-RS 中。这意味着，类似于 JAXB，用作请求或响应体的 Java 类型分别隐式映射到 JSON。

类似地，JSON-P 1.1 和 Bean Validation 2.0 的新特性也被包含在 JAX-RS 中。这是可能的，因为规范将特定功能转发到相应的标准。

被整合到 JAX-RS 中的较小更新包括添加了与同名的 HTTP 方法的`@PATCH`注解。尽管在 JAX-RS 之前已经可以支持提供的 HTTP 方法之外的 HTTP 方法，但它简化了需要此功能的开发者的使用。

另一个虽小但确实有用的改进是，在 JAX-RS 客户端中包含了标准化的 HTTP 超时方法。`connectTimeout` 和 `readTimeout` 构建方法处理配置的超时。许多项目都需要这种配置，这以前导致了包含供应商特定的功能。

我们在 第三章，《实现现代 Java 企业应用程序》中看到了这些功能的实现。

# JSON-B 1.0

JSON-B 是一种新的标准，它将 Java 类型映射到 JSON 结构，反之亦然。类似于用于 XML 的 JAXB，它提供了声明式映射对象的功能。

在 Java EE 生态系统内，该标准的最大优势是应用程序不再需要依赖特定的供应商实现。通常，JSON 映射框架阻止企业应用程序以可移植的方式构建。它们增加了与现有框架版本断开运行时依赖的风险。

JSON-B 通过提供标准化的 JSON 映射来解决此问题。不再需要打包自定义映射框架，如 Jackson 或 Johnzon。

# JSON-P 1.1

在 Java EE 7 中引入的 JSON-P 1.0，提供了一个强大的功能，可以编程创建和读取 JSON 结构。版本 1.1 主要包括对常见 JSON 标准的支持。

这些 IETF 标准之一是 **JSON Pointer**（RFC 6901）。它定义了一种查询 JSON 结构和值的语法。通过使用指针，例如 `"/0/user/address"`，JSON 值被引用，类似于 XML 世界中的 **XPath**。

该功能包含在通过 `Json.createPointer()` 方法创建的 `JsonPointer` 类型中，类似于现有的 JSON-P API。

另一个新支持的标准是 **JSON Patch**（RFC 6902）。RFC 6902 定义了所谓的补丁和修改方法，这些方法应用于现有的 JSON 结构。

JSON 1.1 支持通过 `Json.createPatch` 或 `Json.createPatchBuilder` 分别创建 JSON 补丁。相应的 JSON-P 类型是 `JsonPatch`。

第三个支持的 IETF 标准是 **JSON Merge Patch**（RFC 7386）。该标准通过合并现有的 JSON 结构来创建新的结构。JSON-P 通过 `Json.createMergeDiff` 或 `Json.createMergePatch` 分别支持创建合并补丁，结果生成 `JsonMergePatch` 类型。

除了这些支持的 IETF 标准，JSON-P 1.1 还包括一些简化 API 使用的较小功能。一个例子是通过预定义的流收集器，如 `JsonCollectors.toJsonArray()` 方法，支持 Java SE 8 流。另一个小的改进是，通过 `Json.createValue`，可以从 Java 字符串和原始数据类型创建 JSON-P 值类型。

# Bean Validation 2.0

Java EE 8 将 Bean Validation 版本更新到 2.0。除了包括新的预定义约束外，它主要针对对 Java SE 8 的支持。

Java SE 8 的支持包括多个不同配置的验证约束注解。Java 8 日期和时间 API 的类型现在得到支持；例如，通过使用 `@Past LocalDate date`。

容器类型中包含的值也可以通过参数化类型注解单独验证。例如，`Map<String, @Valid Customer> customers`、`List<@NotNull String> strings` 和 `Optional<@NotNull String> getResult()` 就是这样的例子。

Bean Validation 2.0 包含了新的预定义约束。例如，`@Email` 验证电子邮件地址。`@Negative` 和 `@Positive` 验证数值。`@NotEmpty` 确保集合、映射、数组或字符串不为空或 `null`。`@NotBlank` 验证字符串不单纯由空白字符组成。

这些约束是一个有用的默认功能，可以避免手动定义这些约束。

# JPA 2.2

Java EE 8 更新了 JPA 规范到版本 2.2。这个版本主要针对 Java SE 8 的特性。

与 Bean Validation 类似，Java SE 8 的支持包括日期和时间 API。例如，`LocalDate` 或 `LocalDateTime` 类型现在原生支持实体属性。

版本 2.2 使得可以使用 `getResultStream()` 方法返回查询结果，不仅作为 `List<T>`，还可以作为 `Stream<T>`。以下代码片段展示了这一点：

```java
Stream<Car> cars = entityManager
        .createNamedQuery(Car.FIND_TWO_SEATERS, Car.class)
        .getResultStream();
cars.map(...)
```

JPA 2.2 最终添加了对使用 CDI 的 `@Inject` 将管理 Bean 注入属性转换器的支持。这增加了自定义属性转换器的使用和场景数量。类似于 JSON-B 等其他标准，更好的 CDI 集成鼓励 Java EE 组件的重用。

此外，版本 2.2 还增加了可重复注解，例如 `@JoinColumn`、`@NamedQuery` 或 `@NamedEntityGraph`。由于 Java SE 8 允许重复相同的注解类型多次，因此开发者不再需要使用相应的分组注解，如 `@JoinColumns` 来实现这些功能。

# 安全性 1.0

如上一章所述，Security 1.0 旨在简化安全关注点集成到 Java EE 应用程序中。因此，鼓励开发者使用诸如 JASPIC 等强大的功能。

我们在上一章中看到了 HTTP 身份验证机制、身份存储和安全上下文的功能和用法。

# Servlet 4.0

在撰写本书时，HTTP/1.1 是主要使用的 HTTP 版本。HTTP/2 针对过去 Web 应用程序 HTTP 性能的不足。特别是，请求基于 Web 系统的多个资源可能会由于涉及的大量连接而导致性能不佳。HTTP 2 的第二个版本通过多路复用、流水线、压缩头和服务器推送来降低延迟并最大化吞吐量。

与 1.1 相比，HTTP/2 的大多数更改不会影响工程师的工作。Servlet 容器在底层处理 HTTP 关注点。这一例外是服务器推送功能。

服务器推送（Server Push）工作原理是服务器直接发送与客户端请求的资源相关的 HTTP 响应，基于这样的假设：客户端也可能需要这些资源。这允许服务器发送客户端未明确请求的资源。这是一种性能优化技术，在网页中主要涉及样式表、JavaScript 代码和其他资产。

Servlet API 通过使用`PushBuilder`类型支持服务器推送消息，该类型是通过`HttpServletRequest.newPushBuilder()`方法实例化的。

# JSF 2.3

Java 服务器端面（Java Server Faces）是构建以服务器为中心、基于组件的 HTML UI 的传统方式。Java EE 8 附带更新的 JSF 版本 2.3。

版本更新的主要改进包括更好的 CDI、WebSocket 和 AJAX 集成、类级别的 Bean 验证，以及 Java SE 8 的支持。

由于本书的重点显然在后端，因此它不包括太多关于 JSF 的内容。

# JCP 和参与

**Java 社区进程**（**JCP**）定义了构成 Java SE 和 EE 平台的标准，包括 Java EE 总标准本身。这些单独的标准被定义为**Java 规范请求**（**JSR**），每个形成所谓的**专家小组**，由参与企业软件的专家和公司组成。

这个想法是标准化在现实世界项目中证明效果良好的技术。来自这些现实世界项目的公司和个人的经验被汇集起来，形成供应商独立的 Java 企业标准。

对于公司和个人来说，都强烈建议参与 JCP。它提供了形成标准和 Java 技术未来的能力，以及在这个技术中获得知识。JCP 的开放流程使开发者能够了解 Java EE 未来版本将如何呈现。

个人和公司也可以遵循标准化流程，即使他们没有参与 JCP。他们可以审查标准的草案状态并提供对专家小组的反馈。

专家小组确实欢迎在形成规范时收到建设性的反馈。从现实世界项目中获得反馈和经验对于制定更适合行业需求的标准非常有帮助。

我也参与了 Java EE 8 的塑造，是两个专家小组的成员，即 JAX-RS 2.1 和 JSON-P 1.1。在这个过程中，我获得了大量的知识，并鼓励企业 Java 开发者关注 JCP 中的流程。

# MicroProfile

MicroProfile 倡议背后的动机是在 Java EE 标准的基础上构建，创建较小规模的配置文件，针对微服务架构，并尝试与标准化无关的功能。多个应用服务器供应商参与了这一倡议，形成了供应商同意的事实标准。

支持 MicroProfile 的服务器应用程序为运行仅需要较小一组标准的 Java EE 应用程序提供了机会，在第一个版本中这包括 JAX-RS、CDI 和 JSON-P。同样，应用服务器供应商提供了将运行时精简到特定所需标准集的能力。

这些方法的优势在于它们不会向企业项目添加依赖，而是仅仅优化了运行时。开发者仍然使用相同的 Java EE 标准技术编写他们的应用程序。

# Eclipse Enterprise for Java

在 2017 年 9 月，就在出版这本书之前，Java EE 和 JCP 的监护人 Oracle 宣布将 Java EE 平台及其标准转移到开源基金会，这产生了**Eclipse Enterprise for Java**（**EE4J**）。这些计划旨在降低希望贡献的公司和开发者的门槛，并最终使技术更加开放。

无论这些计划的实现看起来如何，重要的是要提到这些计划包括保留平台的本性。本书中提出的方法和技巧将在企业 Java 的未来中依然适用。

我可以重复我过去关于 JCP 内参与的信息。然而，企业 Java 标准化过程的体现，我鼓励工程师和公司关注 Eclipse Enterprise for Java，并参与定义企业标准。集体知识和实际经验有助于塑造 Java EE 的标准，并将有助于未来塑造企业 Java。
