# 5

# 算法效率

专注于确保他们的 Java 应用程序达到高水平的开发者必须考虑单个算法的效率。我们不是通过算法的代码行数来判断其效率；相反，我们在分析测试结果后做出这种判断。

本章旨在帮助你学习如何为任何特定需求选择正确的算法。它还涵盖了时间复杂度的概念，包括降低时间复杂度的策略。我们还将关注简洁高效的代码。本章还强调了算法测试的重要性。

本章涵盖了以下主要主题：

+   算法选择

+   低时间复杂度

+   测试算法的效率

到本章结束时，你应该对算法效率有坚实的理论理解，同时也有创建和修改算法的实践经验。这种经验可以帮助确保你从 Java 应用程序中获得高性能。

# 技术要求

要遵循本章中的示例和说明，你需要能够加载、编辑和运行 Java 代码。如果你还没有设置你的开发环境，请参阅*第一章*。

本章的完整代码可以在以下链接找到：[`github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter05`](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter05)。

# 算法选择

编写软件的最好之处之一是，对于一个问题没有唯一的解决方案。我们可以自由地使用独特的风格，并整合数据结构、库和算法，只要我们获得正确的结果。这有点夸张。我们可以用几乎无限的不同方式编写算法并得到相同的结果。

这种编程灵活性也可能成为一种不利因素，正如低性能算法所证明的那样。所以，尽管我们可以随心所欲地编写算法，但这并不意味着我们应该这样做。我们应该在算法选择和创建上采取战略性的方法，因为它将对我们的 Java 应用程序的整体效率产生重大影响。

在本节中，我们将探讨选择算法的特定过程、案例研究和发展趋势。

## 选择过程

虽然没有行业范围内的官方算法选择流程，但这里有一个六步法：

1.  完全理解需求。这看起来可能很明显，但许多开发者在这方面犯了错误。完全理解需求是至关重要的。这是我们想要算法解决的问题。理解问题涉及学习约束、数据集、输入、输出等等。一旦我们完全理解了需求，我们就可以进行下一步。

1.  在这一第二步中，我们应该熟悉我们的算法将要关联的数据。这可能包括静态数据、数据流，甚至生成数据。这一步是你完全沉浸在与应用程序数据相关的一切中的时候。除了数据熟悉之外，我们还应该开始考虑我们的算法应该使用哪种类型的数据结构。

1.  考虑每个潜在算法的计算复杂度。这里需要考虑的因素包括时间和内存需求。你可以实施基准测试来帮助你做出决定。

在这一步中，你应该确定与处理和内存相关的资源限制。了解这些上限将有助于你的算法决策。

这是你测试你的算法、进行改进并重新测试的地方。这是一个迭代过程，你应该对你的算法进行小的、渐进性的更改，以帮助确定什么是最有效的。

记录你的最终决定以及导致这一决定的所有因素。你的文档越详细，越好。这将在你稍后回顾你的选择时有所帮助。

理想情况下，你应该采取持续的过程改进心态，不要犹豫去质疑之前的决定。即使你选择并改进了一个能够实现最佳性能的算法，它也应该定期进行审查。环境、数据和其他因素可能会随时间变化并影响算法的效率。

现在，让我们通过回顾下一节的案例研究来了解这些步骤如何实施。

## 案例研究

复习案例研究可以帮助我们巩固对算法选择如何显著提高 Java 应用程序性能的理解。本节详细介绍了企业电子商务平台的算法选择。该企业指出，其系统处理搜索请求效率低下，导致用户投诉系统运行缓慢。因此，该企业希望改进搜索功能，从而提高其应用程序的整体性能。

在这个案例中的第一步是确定导致问题的原因。在我们的例子中，电子商务平台实施了一个线性搜索算法，该算法将用户请求与数据库条目相匹配。自初始系统开发以来，搜索算法没有改变，而数据库的规模持续增加。所有搜索结果都缓慢。

我们的第二步是理解数据。因此，开发者审查数据库模式并查看样本数据库记录，以便熟悉系统的数据需求和用途。在接下来的两个步骤中，开发者审查搜索功能的计算复杂度，并确定任何资源限制。

开发者现在可以评估替代算法。在这个示例中，可能的替代方案可能包括二分搜索和其他经过验证的搜索模式。对这些替代方案的审查导致采用倒排索引作为可以优化全文搜索的数据结构。

倒排索引

一种常用于全文搜索的数据结构。索引识别每个独特的术语并列出该术语出现的位置。实现通常包括使用字典或哈希表。

现在的开发者可以根据他们系统的需求来定制他们的选择。接下来，他们将进行多次测试并记录结果。在这个示例案例中，系统的搜索功能现在性能极高。剩下的是记录决策和决策因素。

示例案例向开发者表明，他们需要在应用程序性能和资源利用之间取得平衡。接下来，让我们看看一些算法选择的发展趋势。

## 发展趋势

Java 软件开发是一个动态的领域，我们创建和使用的算法也是如此。关于算法效率有几个趋势，本节描述了其中五个。

+   **人工智能和机器学习**：科技领域的许多人将 2023 年称为**人工智能**（**AI**）之年。人工智能和**机器学习**（**ML**）并不新鲜，但它们的广泛应用和采用从未如此普遍，这得益于 OpenAI 在 2015 年的推出以及**生成式预训练转换器**（**GPTs**），如 ChatGPT 的引入。行业正在经历向与 AI 相关的算法的转变。

    您可以在*第十八章*中了解更多关于利用 AI 进行高性能 Java 应用的信息。

+   **并发**：随着多核处理器的普及，算法需要专注于并行处理的需求增加。幸运的是，Java 对并发提供了强大的支持。

    您可以在*第九章*中了解更多关于并发策略的信息。

+   **云优化**：随着越来越多的应用程序托管在云上，我们需要更新 Java 应用程序以进行云优化的需求增加。云计算要求我们考虑可扩展性和分布式处理等概念。这些考虑对于正在为云开发的新 Java 应用程序以及我们希望迁移到云上的现有应用程序都至关重要。

+   **安全**：在软件开发中，似乎一直保持不变的是我们系统和数据所面临的网络威胁数量不断增加。安全是一种心态，而不是软件开发中的一个步骤。这里的趋势是在整个产品生命周期中对安全的重视程度不断提高。

+   **社区**：在众包算法设计和其他开源贡献领域取得了令人印象深刻的增长。由此产生的系统和算法越来越稳健和多样化。

现在我们已经回顾了算法选择，分享了一个案例研究，并讨论了算法趋势的发展，我们可以看看低时间复杂度与算法效率的关系。

# 低时间复杂度

时间复杂度是指任何给定算法的时间效率的度量。我们希望确定 Java 应用程序的执行时间，并确保我们的算法不会给应用程序增加时间复杂度。总体目标是减少算法执行时间。我们应该使用各种可能的输入和环境来测试我们的算法。

在本节中，我们将探讨具体的策略，以帮助您降低算法的时间复杂度。我们还将讨论与时间复杂度相关的一些常见陷阱。

## 降低时间复杂度的策略

我们可以采用几种策略来帮助我们降低算法的时间复杂度。可能最简单的策略就是确保我们的算法不过于复杂。这需要我们仔细检查我们的算法逻辑，并使用本书中涵盖的优化技术。减少循环中的不必要的计算，尤其是在递归中，是一种很好的优化策略。

有时我们的算法可能看起来过于复杂，我们找不到简化它们的方法。在这些情况下，考虑将算法分解成多个算法，每个算法执行原始指令集的一个子集，是值得考虑的。

## 常见陷阱

当审查与算法时间效率相关的常见陷阱时，我们可以参考前面的章节，并查看即将到来的其他章节。正如您从这里列出的前四个常见陷阱的列表中可以看到，详细信息可以在本书的几个章节中找到：

+   数据结构使用不当(*第二章*)

+   过度使用非标准库(*第十三章*)

+   测试和性能分析不足(*第十四章*)

+   忽视可读性和可维护性(*第十六章*)

此外，我们可能只是忽略了应用程序整体性能的大局。有时，我们可能会陷入代码的细节中，以牺牲整体算法或应用程序效率为代价。

正如我们所见，低时间复杂度既是一个概念也是一个目标。当我们的最终目标是提高 Java 应用程序的性能时，这是一个重要的考虑因素。

# 测试算法的效率

到目前为止，很明显我们需要我们的算法是高效的。本节重点介绍如何根据我们的需求衡量算法效率。我们将从一个关于测试重要性的简短部分开始，然后介绍如何准备测试，如何进行测试，以及测试之后应该做什么。

## 测试的重要性

简而言之，如果我们不对我们的算法进行效率测试，我们就无法确定它们是高效的还是低效的。如果我们不衡量它们对特定算法和整体应用性能的影响，优化就毫无意义。

我们可能会根据我们的经验假设我们知道哪些优化将带来最佳性能。尽管这是基于经验的，但它仍然只是轶事。输入和操作环境的变化可能会挑战我们对算法效率的先前知识，因此我们不应该未经测试就假设。

小贴士：成为一个测试狂热者

关注高性能的优秀程序员致力于这样一个观点：算法效率测试是软件生命周期的一个核心部分。

## 准备算法效率测试

设置测试环境可能需要时间，因此为它制定计划并分配足够的时间在你的开发项目中是很重要的。以下是准备算法效率测试的七个步骤概述：

1.  **识别需求**：在这个第一步，我们需要彻底理解算法旨在做什么，以及你将在测试中使用的**关键性能指标**（**KPIs**）。

1.  **建立测试环境**：我们很少在生产环境中进行测试，因此我们需要在开发环境中复制数据和条件。目标是尽可能接近地反映生产环境。

1.  **工具选择**：在这个步骤中，我们选择我们将使用的分析和基准测试工具。

1.  **获取测试数据**：在这里，我们想要创建一个实时数据的副本，以便我们可以用它进行测试。

1.  **基准测试**：在这个步骤中，我们建立基线，以便我们可以将我们当前的算法与未来的优化版本进行比较。

1.  **详尽的文档**：记录我们的测试计划是很重要的，这样我们就可以在未来复制它们。

1.  **迭代测试**：这一最后步骤本质上是一个调度步骤。为了支持迭代测试的需求，应该安排多次迭代。

现在你已经知道了如何准备测试，让我们看看如何进行测试。

## 进行测试

你现在可以实施你的测试计划了。让我们看看一个简单的 Java 代码示例。

我们的例子将是测试冒泡排序算法的执行时间。以下是我们的冒泡排序算法：

```java
public class EfficiencyTestExample {
  public static void main(String[] args) {
    algorithmEfficiencyTest();
  }
  // Here is our bubble sort algorithm
  public static void ourBubbleSort(int[] array) {
    int nbrElements = array.length;
    int temp;
    for (int i = 0; i < nbrElements; i++) {
      for (int j = 1; j < (nbrElements - i); j++) {
        if (array[j - 1] > array[j]) {
          temp = array[j - 1];
          array[j - 1] = array[j];
          array[j] = temp;
        }
      }
    }
  }
}
```

接下来，我们需要创建一个测试我们的冒泡排序算法执行时间的方法。这将是这样的：

```java
public static void algorithmEfficiencyTest() {
  int[] ourTestArray = new int[30000];
  for (int i = 0; i < ourTestArray.length; i++) {
    ourTestArray[i] = (int) (Math.random() * 30000);
  }
  long startTime = System.nanoTime();
  ourBubbleSort(ourTestArray);
  long endTime = System.nanoTime();
  long duration = (endTime - startTime);
  System.out.println("Execution Time (nanoseconds): " + duration);
}
```

正如你所看到的，我们创建了一个包含 30,000 个元素的测试数组，并用随机数填充它。接下来，我们记录了开始时间，执行了冒泡排序，然后记录了结束时间。有了开始和结束时间，我们就知道算法花费了多长时间。输出可能看起来是这样的：

```java
Execution Time (nanoseconds): 1054427380
```

接下来，让我们看看我们的测试后操作应该是什么。

## 测试后操作

我们的测试完成后，我们的工作并未结束。我们需要执行以下测试后行动：

+   深入分析我们的测试结果

+   根据我们的测试结果优化我们的算法

+   记录算法的更改并记录我们做出更改的原因

+   根据适当情况，与利益相关者分享您的发现和流程

+   当需要时，更新我们的测试环境

+   采用持续过程改进的心态，并持续监控

+   进行事后反思，并记录关于流程及其改进方法的学习内容

当我们彻底分析我们的测试结果并执行其他测试后行动时，我们增加了测试计划得到适当执行并产生有效结果的机会。

# 摘要

本章旨在帮助您学习如何为任何特定需求选择正确的算法，以及如何衡量您的结果。它涵盖了时间复杂度的概念，并包括了降低时间复杂度的策略。我们还强调了算法测试的重要性。您现在应该对算法效率有很强的理论理解，并且有创建和修改算法的实践经验。这种经验可以帮助确保您从 Java 应用程序中获得高性能。

在下一章，*战略对象创建和不可变性*中，我们将介绍以提升我们 Java 应用程序整体性能为目标的对象创建策略。该章节涵盖了最小化对象创建、对象不可变性和垃圾回收。

# 第二部分：内存优化和 I/O 操作

内存管理对于高性能 Java 应用程序至关重要。本部分重点介绍战略对象创建和利用不可变性来优化内存使用。它还涵盖了有效处理字符串对象以及识别和预防内存泄漏。本部分中的章节提供了关于高效管理内存和确保稳健 I/O 操作的实用见解。

本部分包含以下章节：

+   *第六章*，*战略对象创建和不可变性*

+   *第七章*，*字符串对象*

+   *第八章*，*内存泄漏*
