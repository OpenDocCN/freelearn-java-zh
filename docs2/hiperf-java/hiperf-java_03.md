# 3

# 优化循环

循环是基本编程结构，理解或编写它们并不特别困难。我们使用它们来遍历应用程序的数据结构并执行重复性任务。由于它们的简单语法和可读性，我们经常将循环视为理所当然。当性能成为关注点时，循环具有双重性。一方面，循环作为高效数据处理的基本结构。另一方面，未优化的循环可能会引入显著的瓶颈，并降低我们的 Java 应用程序的整体性能。

本章涉及的概念包括循环开销、循环展开、基准测试、循环融合、循环并行化和循环向量化。我们将使用代码示例来提供见解并展示最佳实践。

本章涵盖了以下主要主题：

+   循环类型

+   测试循环的性能

+   嵌套循环

本章探讨了技术、策略和最佳实践，以帮助您从循环中获得最佳性能，并防止无意中引入会削弱运行时性能的严重瓶颈。

# 技术要求

要遵循本章中的示例和说明，您需要能够加载、编辑和运行 Java 代码。如果您尚未设置开发环境，请参阅*第一章*。

本章的完整代码可以在以下位置找到：[`github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter03`](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter03)

# 循环类型

循环是遍历数据结构、控制代码流程和执行重复性任务不可或缺的结构。它们是许多算法和应用的核心。虽然循环可以用来高效地处理数据和执行重复性任务，但当我们关注性能时，它们也可能同样有问题。

理解不同类型的循环、它们的特性和性能影响是很重要的。本节探讨了 Java 中的不同循环类型，包括`for`、`while`、`do`-`while`和`for`-`each`。我们的目标是理解每种循环类型的目的及其对代码可读性和效率的影响。具体来说，我们将涵盖以下主题：

+   循环对性能的影响

+   循环优化基础

+   循环展开

拥有对循环类型的深入理解可以使您能够为特定需求选择正确的循环。

## 循环对性能的影响

为了理解循环对性能的影响，我们必须对不同的循环类型有一个牢固的理解。本节提供了关于每种循环类型的信息，包括用例和优势。使用示例来提供实现细节。

### for 循环

`for`循环是最基本的循环类型。它们具有简洁的语法和定义良好的循环控制。它们是非官方的默认循环，用于遍历一系列项目。让我们看看这些循环的以下组成部分：初始化、条件、迭代和效率。

`for`循环的语法如下：

```java
for (int i = 0; i < 5; i++); {}
{
```

分析之前的语法，我们可以将`int i =0;`识别为`i`，并将其设置为`0`。`i < 5;`表示`i`小于`5`。如果评估结果返回`true`，则循环继续；否则，循环结束。最后一部分是`i++`，在每次迭代的末尾将**控制变量**增加 1。

`for`循环存在一些与性能相关的问题。当我们初始化循环时，应避免在循环外部初始化变量，因为这有时会因循环内的冗余初始化而降低性能。**条件表达式**直接影响循环将执行的迭代次数。使这个表达式过于复杂可能会减慢循环的速度。最后，**迭代表达式**应设计得当，以帮助防止无限循环和不效率。

让我们看看一个低效的例子，然后是一个具有性能改进的第二例子。以下示例计算有多少 corgi 的名字包含字母“`e`”：

```java
Corgi[] corgis = getCorgiArray();
int count = 0;
for (int i = 0; i < corgis.length; i++) {
  if (corgis[i].getName().contains("e")) {
    count++;
  }
}
```

之前的代码有两个低效之处：

+   循环条件在每次迭代中使用`length()`方法进行检查。这意味着，对于数组中的每个 corgi，都会访问数组长度，这可能导致不必要的性能开销。

+   我们的代码片段使用`corgis[i].getName().contains("e")`来检查 corgi 的名字是否包含字母“`e`”。因此，对于每个 corgi 名字，我们都在创建一个新的字符串并执行字符串搜索。这肯定会增加计算成本，尤其是在名字很长的情况下。

考虑到这些低效之处，让我们看看代码的一个修订版块：

```java
Corgi[] corgis = getCorgiArray();
int count = 0;
int corgisLength = corgis.length;
for (int i = 0; i < corgisLength; i++) {
  String name = corgis[i].getName();
  if (name.indexOf('e') != -1) {
    count++;
  }
}
```

此代码片段是一个改进版本，具有以下性能提升：

+   我们通过将数组长度存储在`corgislength`变量中来缓存数组长度。由于我们在循环外部填充该变量，我们避免了在每次迭代中对数组长度的重复访问。这可以大大节省计算工作量。

+   我们不是使用`contains()`方法来检查名字，而是使用`indexof()`方法。这里有一个显著的区别。当我们使用`contains()`方法时，会创建一个新的子字符串并执行完整搜索。使用`indexof()`方法返回“`e`”首次出现的位置索引，如果没有找到，则返回-1。这是一个更有效的方法来检查字符串中字符的存在，而不创建不必要的子字符串。

完成了对`for`循环的探索后，让我们看看如何高效地使用`while`循环。

### `while`循环

`while`循环可能是 Java 中第二常用的循环。它们是基本的流程控制结构，我们可以使用它们来重复执行代码块，只要指定的条件保持`true`。

`while`循环的语法如下：

```java
int count = 0;
int number = 1;
while (number <= 100) {
    count += number;
    number++;
}
```

这些循环不需要初始化，但一旦使用了初始化，应确保其正确性，以防止出现无限循环等意外的应用行为。当条件为`true`时，循环体将被执行。循环在条件为`false`时终止。

条件表达式

我们应该努力创建简单的条件表达式以提高循环效率。过于复杂的条件表达式会增加处理开销，导致性能下降。

让我们来看一个低效的例子，然后是第二个具有性能改进的例子。以下是一个在线订购系统的例子。我们想要检查每个订单 ID 是否以“`OL`”前缀开头。如果不是，则应该添加：

```java
List<String> orderIDs = getOrderIDs();
int index = 0;
while (index < orderIDs.size()) {
  String orderID = orderIDs.get(index);
  if (!orderID.startsWith("OL")) {
    orderID = "OL" + orderID;
    orderIDs.set(index, orderID);
  }
    index++;
}
```

在前面的代码片段中存在两个低效之处。首先，列表的大小被反复访问；它在每次迭代时都会进行检查。这可能导致不必要的性能开销。其次，使用`+`运算符进行字符串连接会创建一个新的字符串，当在循环中重复执行时可能会效率低下。

以下代码片段是修改后的在线订购系统版本：

```java
List<String> orderIDs = getOrderIDs();
int index = 0;
int orderCount = orderIDs.size();
while (index < orderCount) {
  String orderID = orderIDs.get(index);
  if (!orderID.startsWith("OL")) {
    orderIDs.set(index, "OL" + orderID);
  }
  index++;
}
```

前面的更新代码片段由于两个因素而有望提高系统性能。首先，列表大小现在被缓存，其次，我们使用了一种更有效的字符串修改方法。在这里，我们修改字符串而不创建新的字符串对象。

在完成对`while`循环的探索后，让我们看看如何高效地使用`do`-`while`循环。

### do-while 循环

与之前讨论的`do-while`循环一样，`do`-`while`循环是允许在指定条件保持`true`时重复执行代码块的流程控制结构。这种类型循环的独特之处在于，条件是在循环代码块执行之后进行检查的。这确保了循环代码块至少执行一次。

以下示例展示了用于猜数字游戏的简单`do`-`while`循环，用户会继续猜测数字，直到猜对为止：

```java
int secretNumber = generateSecretNumber();
int userGuess;
boolean correctGuess = false;
do {
  userGuess = getUserGuess();
  if (userGuess == secretNumber) {
    correctGuess = true;
  } else {
      System.out.println("Try again!");
    }
  } while (!correctGuess);
  System.out.println("You guessed the secret number: " + 
  secretNumber);
```

正如你在前面的代码片段中所见，我们使用布尔标志来控制我们的循环。该标志在每次迭代时都会被检查。这种方法效率低下，因为它增加了不必要的复杂性和额外的变量。让我们修改代码，使其更加高效：

```java
import java.util.random;
int secretNumber = generateSecretNumber();
int userGuess;
  do {
    userGuess = getUserGuess();
    if (userGuess != secretNumber) {
      System.out.println("Try again!");
    }
  } while (userGuess != secretNumber);
  System.out.println("You guessed the secret number: " + 
  secretNumber);
```

在我们的更新示例中，我们使用`userGuess != secretNumber`作为循环条件，从而消除了对布尔标志的需要。这既简化了我们的代码，也可以使我们的代码更加高效。

### for-each 循环

我们在*第二章*中介绍了`for`-`each`循环，并指出这种类型的循环也被称为增强型`for`循环。当我们想要遍历数据集中的所有元素，而不需要管理迭代器或索引时，我们选择实现这种类型的循环。让我们先看一个初始示例，然后为了更好的性能对其进行优化。

以下代码片段是一个汽车零部件处理应用：

```java
List<String> autoParts = getAutoParts();
for (String part : autoParts) {
  processPart(part);
}
```

上述代码中的低效源于在循环中对每个汽车零部件进行顺序处理。这可能是一个耗时的操作，并可能导致性能不佳。让我们看看一个改进版本：

```java
List<String> autoParts = getAutoParts();
processAutoParts(autoParts);
```

在这个改进版本中，我们实现了一个`processAutoParts()`方法，它接受整个零部件列表作为参数。这允许批量处理零部件，这可以显著提高整体性能。

在我们完成了对循环类型的探索之后，现在让我们回顾一下循环优化的基础。

## 循环优化基础

当我们努力确保我们的 Java 应用程序具有高性能时，我们当然会关注循环优化。循环在 Java 编程中同样无处不在，这使得它们的低效特别成问题。循环效率可能因实现和使用方式而显著不同。本节将探讨循环优化的基本方面，目的是为您提供知识和工具，以提升您的 Java 应用程序的性能。

### 循环开销

循环开销指的是与循环的初始化、实现和终止相关的额外计算成本。虽然循环对于实现各种编程任务至关重要，但它们并非没有计算开销。理解循环开销至关重要，因为过度的开销可能会降低您 Java 应用程序的整体性能。

循环开销的三个主要组成部分是循环初始化、条件评估和迭代。正如之前所展示的，每种类型的循环都可能导致一个或多个这些组件的低效。幸运的是，我们可以采用一些策略来帮助最小化循环开销。首先，我们可以优化循环初始化。这可以通过在循环外部初始化我们的控制变量来实现。所获得的性能提升是由于避免了在循环中的冗余赋值。我们还可以最小化在循环中声明的变量数量。

第二种策略是使用简单高效的条件表达式。我们希望避免在循环中包含复杂的条件。如果我们的循环条件依赖于数据集的长度，那么这个长度应该在循环外部缓存，以防止重复访问。

第三，我们可以简化迭代。为了采用这种策略，我们应该确保迭代被设计为正确且高效地更新循环控制变量。我们还应该以高效和正确的方式使用适当的表达式递增/递减。最后，我们应该考虑针对每套要求选择不同的循环类型。

### 瓶颈

未优化的循环可能导致我们的 Java 应用程序性能出现瓶颈。了解这些瓶颈的原因是避免它们的第一步。正如本章前面所提到的，以下是与 Java 编程中的循环相关的常见性能瓶颈：

+   低效的条件表达式

+   低效的迭代步骤

+   不必要的计算

+   不理想的数据访问模式

+   过多的内存分配

我们应该努力实现针对每种循环类型的特定优化策略，如前几节所述。一般的循环优化策略如下：

+   分析我们的循环以识别性能瓶颈

+   避免过早优化

+   选择合适的数据结构

+   选择合适的算法

此外，正如你将在本章后面学到的那样，分析工具和方法可以帮助我们确定我们的循环中存在哪些瓶颈。

### 基准测试

优化循环超出了本章涵盖的基本策略，需要深入了解它们的性能、特性和测量优化以提升性能的能力。我们通过基准测试来完成这一测量。我们的目标是评估我们的循环优化的有效性。

我们应该建立一个基准测试环境，以便我们可以评估循环性能。这需要我们设置一个一致的环境，便于准确测量和比较分析。每个优化都可以通过基准测试来测试，以确定它是否提高了或降低了应用程序的性能。

要建立基准测试环境，请遵循以下步骤：

1.  选择一个提供测量我们 Java 代码性能工具的基准测试框架或库。我们将在*第十三章*中具体探讨**Java 微基准测试工具**（**JMH**）。

1.  确保你的开发环境配置正确且最新。

1.  编写包含我们想要基准测试的循环的基准测试类。

1.  为我们的基准测试指定设置和参数。这可以包括测量时间、迭代次数和预热迭代次数。

1.  确保涉及的变量在所有测试中都是一致的。

1.  进行预热运行以考虑任何 JVM 特定的预热效果。

1.  测量执行时间。

1.  分析结果。

1.  重复并多次验证以确保你发现的有效性。

1.  解释你的结果并进行优化。

1.  记录你的结果。

通过遵循这些步骤建立基准测试环境，你可以就循环优化做出明智的决定，识别性能瓶颈，并微调你的 Java 应用程序以实现更高的性能。

## 循环展开

循环展开是一种高级优化策略。它是一种我们可以在 Java 中采用的优化技术，以改进我们的循环。这种方法涉及复制或展开循环的代码块多次，以减少所需的迭代次数。更具体地说，我们不是每次迭代执行一次循环的代码块，而是扩展循环，在单个迭代中多次执行代码块。虽然这听起来可能很复杂，但它可以减少由条件检查和更新变量引起的循环开销。

循环展开的好处包括以下内容：

+   减少循环开销

+   改善 CPU 指令缓存使用

+   增强编译器优化

+   并行机会

循环展开有两种类型：手动和自动。让我们看看每种类型的示例。第一个示例是手动循环展开。在这里，我们必须明确重写我们的循环代码以展开它。以下是一个示例：

```java
// Original loop
for (int i = 0; i < 5; i++) {
  // loop's code block
}
// Manual loop unrolling
for (int i = 0; i < 4; i += 2) {
  // loop's code block (iteration 1)
  // loop's code block (iteration 2)
  // ...
}
```

手动循环展开为我们提供了对展开过程的有限控制，但由于它是手动完成的，因此难以维护代码。

通过自动循环展开，我们可以利用编译器优化工具自动展开我们的循环代码。编译器将引用我们指定的编译器标志。以下是一个示例：

```java
// Original loop
for (int i = 0; i < 5; i++) {
    // loop's code block
    // ...
}
// Compiler optimization flags
```

编译器标志

在 Java 中，编译器标志用于在编译时指定非默认设置或选项。我们将标志（例如，`-O`，以在编译时启用优化）传递给`javac`编译器命令。

使用自动展开可以简化优化过程并节省我们的时间。这种方法的缺点是展开的结果可能不是最有效的。随着我们循环的复杂性增加，自动展开的结果效率会降低。

当我们有一个已知且固定的迭代次数时，使用循环展开被认为是一种最佳实践。此外，如果循环开销不是一个重要的问题，那么循环展开可能不是必要的。手动展开的副作用可能是增加内存使用。每次展开循环时，我们都应该对性能优化进行性能分析。

循环展开有一些局限性。首先，并非每个循环都适合展开，例如当数据集大小是可变或动态时。展开的另一个局限性或缺点是它可能导致代码膨胀，增加二进制文件大小，这反过来又可能导致指令缓存错误。最后，自动展开不一定总是产生期望的循环优化。

现在，你应该对 Java 中的循环类型有一个全面的理解，包括它们的优缺点和它们理想的使用场景。你现在可以做出更明智的循环选择决策，这有助于确保你创建的代码既高效又易于维护。

# 测试循环的性能

现在我们已经对不同类型的循环及其优缺点有了牢固的掌握，我们应该有信心做出最佳的循环选择。此外，我们还应该能够实施优化策略。但如何知道我们的循环优化策略是否提高了性能或降低了性能？这就是测试发挥作用的地方，也是本节的重点。

在本节中，我们将涵盖以下概念：

+   分析工具和方法

+   基准测试和测试策略

+   案例研究和示例

我们的目标是获取评估、优化和充分利用 Java 应用程序中循环的全部潜力的所需知识和实践技能。此外，我们希望有一个测试策略，能够告诉我们优化的有效性。

## 分析工具和方法

在我们的 Java 应用程序中编写优化的循环是不够的。我们应该对分析工具和方法有一个清晰的理解。在我们的环境中，分析是分析我们循环执行以深入了解其性能特性的实践。我们可以从分析中获得关于我们的循环需要多少 CPU 时间的关键信息。

### 为什么分析很重要

分析被认为是关注 Java 应用程序性能的开发者使用的诊断工具。分析适用于我们代码的各个部分，在本节中，我们的重点是循环。我们使用分析工具来深入了解代码在运行时的行为。以下是我们可以从分析中获得的一些见解：

+   我们的循环消耗了多少 CPU 时间？

+   是否存在内存泄漏？

+   我们的代码是否导致了过度的内存分配？

+   我们的循环如何与 CPU 缓存交互？

+   我们的循环如何与内存交互？

我们可以用不同的方式编写循环，并使用分析来帮助我们了解哪种方法在整体运行时性能方面最好。

### 分析类型

基本上，有三种基本的分析类型：CPU、内存和线程。在**CPU 分析**中，重点是我们的代码如何使用 CPU。这种分析类型对于识别由我们的循环创建的 CPU 瓶颈特别有用。

**内存分析**让我们深入了解与内存相关的问题。这些问题可能包括过度的内存消耗、内存泄漏以及过度的或低效的对象创建。这是我们关注循环优化时最有用的分析类型之一。

**线程分析**类型有助于识别可能影响我们循环性能的同步问题。

### 分析工具

性能分析工具是帮助我们自动选择性能分析选项的软件应用程序。Java 开发者有许多可用的工具，其中许多是开源的，并且免费使用。这些工具可以分为三类：与 JDK 捆绑的工具、与**集成开发环境**（**IDE**）捆绑的工具，以及商业或第三方工具。

让我们看看两个与 JDK 捆绑提供的性能分析工具的例子。首先，**Java 飞行记录器**（**JFR**）是一个内置工具，可以记录和分析应用程序行为。这个工具因其低处理开销而受到赞誉。**VisualVM**是另一个与 JDK 捆绑提供的性能分析工具。它提供了关于 CPU 使用、内存使用以及线程活动的深刻见解。

### 性能分析方法

性能分析方法本质上是你进行性能分析的方法。这不仅仅是简单地选择一个性能分析器来使用。实际上，你通常会希望在你的方法中使用多个工具。当被问及你的性能分析方法时，考虑一下你的整体方法是什么。

你可能会采用**采样性能分析**方法，定期获取应用程序执行的数据。这种采样方法可以快速查看代码执行行为，并可以提供深入了解哪些可能需要更深入的性能分析。

另一种常见的性能分析方法是**仪器性能分析**。这种方法要求我们在应用程序中添加性能分析代码。虽然这种方法可以提供关于代码执行行为的最高保真度，但它也要求最高的 CPU 开销。

第三种流行的性能分析方法是**持续性能分析**。这种方法在应用程序长时间运行期间收集大量数据。采用这种方法的开发者可以深入了解长期趋势，并更容易地检测性能异常。

识别循环中的热点

在 Java 循环的上下文中，热点是在运行时消耗过多 CPU 时间或内存的循环。我们迫切需要在我们的循环中确定这些热点，以便我们可以优化它们。

在对性能分析的最后一点说明中，我们应该意识到，识别**热点**只是第一步，使用性能分析工具则是另一步。我们需要解决我们发现的这些问题，然后重新应用性能分析工具以确保我们的更改产生预期的效果。开发者应该对他们的循环和其他代码保持持续改进的心态。这需要持续监控和性能分析我们的代码。

## 基准测试和测试策略

我们已经接受，优化循环是确保我们的 Java 应用程序在高水平运行的关键部分。这种高性能需要基准测试和测试策略。本节将探讨这两种策略，并分享最佳实践。

### 基准测试策略

JMH 是用于进行 Java 代码性能测试最常用的工具包。它在处理 Java 性能测试的有限组件方面做得非常出色。正如其名称所暗示的，它是专门为测试 Java 代码而设计的，并且在微级性能测试中得到广泛应用。JMH 的一些特性如下：

+   它测量微基准测试（代码段）的性能特征。对于循环性能测试来说，它特别方便。

+   JMH 支持测量平均时间、样本时间、单次时间和吞吐量。这为开发者提供了极大的灵活性。

+   使用 JMH，开发者可以对测试环境有有限的控制。

+   可以与构建工具（例如，Maven）集成。

+   提供详细的微基准测试结果。

无论我们使用哪种基准测试工具，首先建立基准线都很重要。我们可以通过在未优化的代码上运行我们的工具来完成这项工作。一旦我们有了那个测试的结果，我们就有了基准线。测试优化后的代码可以与基准线进行比较。

### 测试策略

有三种主要的测试策略。第一种是单元测试。这种策略可以帮助我们确保我们对循环所做的任何更改都不会影响预期的代码行为。单元测试还可以帮助我们测试循环的边缘情况，例如使用极端值。

配置文件和热点分析是本章已经介绍过的另一种测试策略。提醒一下，我们使用配置文件工具，如 JFR 或 VisualVM，来帮助我们分析 CPU 和内存使用情况。

最后，我们可以在对应用程序进行更改后使用回归测试来测试我们的循环。这可以帮助确保我们的更改不会对其他任何功能产生负面影响。

无论我们的测试策略如何，我们都应该以迭代的方式处理循环优化测试。这意味着我们应该对我们的循环进行小的、逐步的更改，并在每次更改后进行测试。

## 案例研究和示例

本节涵盖了优化 Java 中循环的实际案例研究和示例。回顾现实场景可以非常强大，因为我们有机会深入了解常见的挑战和解决方案的最佳实践。

### 案例研究

考虑一个案例研究，其中我们需要处理大量数据集并根据业务需求聚合数据。在这个场景中，我们的挑战是聚合循环非常慢。由于我们有大量数据集，我们希望解决慢循环的问题。我们能做什么？我们可以确保使用`ArrayList`而不是`LinkedList`。我们还可以使用 Java 的**Stream API**来实现并行处理。这应该能更好地利用多核 CPU。我们还可以在循环中尽量减少对象创建。考虑到这个场景和提出的解决方案，我们很可能会显著减少聚合循环的操作时间以及循环的复杂性。

让我们看看另一个案例研究。这个案例研究是一个银行应用程序，它在大数据集上计算投资风险指标。在这种情况下，挑战在于我们的主要计算循环效率低下。我们可能采取三管齐下的优化策略。首先，我们将检查我们的算法，看看是否可以改进。接下来，我们将编写我们的代码，使其支持**即时编译**（**JIT**）。最后，我们将查看我们的数据结构，并做出任何必要的更改以最小化内存访问问题。这种三管齐下的方法可以导致应用程序性能显著提高。

### 示例

让我们看看两个现实世界的循环测试和优化应用。

我们的第一个例子是医疗保健分析的数据处理。挑战在于处理大量患者数据以生成分析报告很慢。解决方案是在我们的循环中实现多线程和批量处理，以便我们可以并行处理数据块。这种方法的成果应该是数据处理时间的显著减少。

另一个例子是作为电子商务 Java 应用程序一部分的库存管理。挑战在于优化我们代码中处理库存更新的循环。对于这种情况，我们将假设循环比过去慢，这很可能是由于库存数据集不断增长。解决方案可能是使用高效的数据结构并相应地更改我们的循环结构。这种方法的成果应该是更快的库存处理和更长的响应时间。

本节涵盖了分析工具、分析方法、基准测试、测试策略、案例研究和示例。我们现在可以自信地评估、优化并充分利用 Java 应用程序中的循环，从而实现高运行时性能。

# 嵌套循环

现在，我们将介绍在 Java 应用程序中有效优化嵌套循环所涉及的基本概念、实用优化策略和技术复杂性。在接下来的章节中，我们将探讨嵌套循环的概念，以及它们与高性能 Java 应用程序的关系：

+   嵌套循环简介

+   嵌套循环中的循环融合

+   嵌套循环并行化

+   嵌套循环向量化

理解何时使用嵌套循环以及如何以最优化方式实现它们是很重要的。

## 嵌套循环简介

嵌套循环是指一个循环位于另一个循环内部。这创建了一个复杂的迭代场景。以下是一个简单嵌套循环的语法：

```java
for (int i = 0; i < 10; i++) {          // Outer loop
    for (int j = 0; j < 10; j++) {      // Inner loop
        System.out.println("i = " + i + ", j = " + j);
    }
}
```

如您在先前的语法中看到的那样，外循环运行 10 次，对于每次迭代，内循环也运行三次。这导致总共 10 x 10 = 100 次迭代。

我们可以在嵌套循环中实现有限级别的嵌套。随着每个内部循环的出现，我们的代码变得更加复杂，更难以阅读，也更难以维护。那么，我们何时会使用嵌套循环呢？一个常见的实现是当处理多维数组，如矩阵时。它们也用于在表格上执行操作。

警告

在实现嵌套循环时要小心。它们可能会非常快地变得低效，并使你的应用程序变得缓慢且无响应。

## 嵌套循环中的循环融合

如果我们必须在 Java 应用程序中实现嵌套循环，为了提高效率，我们应该考虑对它们应用循环融合。循环融合本质上是一种算法方法，其中我们将相邻的循环，即对同一数据集执行操作的循环，合并成一个循环。

我们还可以尝试减少冗余计算并提高缓存利用率。当我们合并循环时这是可能的，因为它可以最小化冗余，从而提高缓存的使用。这种技术涉及在相同迭代期间重新使用加载到缓存中的数据。结果通常是更少的缓存未命中。

当使用复杂算法，如矩阵乘法时，循环融合也可能证明是有益的。可能存在一个副作用，即增加了循环的复杂性。这种更大的复杂性导致代码可读性降低，使得代码更难以维护。

## 并行化嵌套循环

要在 Java 中并行化嵌套循环，我们需要重新构建我们的循环，以便它们可以在多个 CPU 核心上并发执行，而不是在单个核心上。正如你所期望的，这是并行计算的一个组成部分，可以显著提高运行时性能。并行化嵌套循环的策略包括将数据集分块，并在单独的线程中处理每个块。

多线程的概念通常与嵌套循环中的并行流一起讨论。比较两者，我们可以了解到多线程提供了额外的控制，但需要我们显式地管理线程和任务。Java 的 **Stream API** 中的并行流提供了一种更简单的方法来并行化操作，但我们对线程模型的控制较少。

最后，在并行化时，我们必须处理同步和线程安全。同步变得至关重要，确保线程安全也同样重要。这在我们处理共享数据结构时尤其如此。

## 嵌套循环向量化

你可能还记得，从本书的*第二章*中，向量化指的是在多个数据点上同时执行单个指令的过程。我们可以利用向量化来提高嵌套循环的计算速度，尤其是在处理复杂的数据操作，如矩阵时。

**单指令多数据**（**SIMD**）在嵌套循环优化中可能是一个重要的概念。SIMD 是向量化中的一个关键概念，正如其名称所暗示的，它对多个数据元素执行单个操作。这对于重复的嵌套循环来说是一种特别有效的技术。向量化的有效性取决于编译器优化和硬件支持。并非所有 CPU 都具有 SIMD 功能。

本节提供了一个结构化的嵌套循环优化概述，旨在提高 Java 应用程序的性能。涵盖了基本概念，以及实用的优化策略，还涉及在 Java 应用程序中有效优化嵌套循环的一些技术复杂性。

# 摘要

本章重点介绍了循环，这是编程的基本结构，以及如何从运行时性能的角度最大限度地利用它们。涵盖的概念包括循环开销、循环展开、基准测试、循环融合、循环并行化和循环向量化。我们通过代码示例提供见解并展示最佳实践。

我们探讨了技术、策略和最佳实践，以帮助您从循环中获得最佳性能，并防止无意中引入重大的瓶颈，从而损害运行时性能。

下一章将专门探讨 Java 对象池，这是一种设计模式，用于管理可重用对象以节省资源并提高应用程序性能。
