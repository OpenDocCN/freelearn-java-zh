

# 第十章：连接池

**连接池** 是软件开发中用于管理数据库连接的技术。这些连接可以在程序执行期间重复使用，传统智慧认为任何可以重复使用的东西都应该一次性创建，并在需要时重复使用。这一直是本书的宗旨，我们努力实现高性能的 Java 应用程序。本章涵盖了连接池的概念，提供了基本原理、实现方法和示例。我们的覆盖范围包括建立连接、管理它们以及在不再需要时终止它们。还将涵盖与连接池相关的最佳实践。

本章涵盖了以下主要主题：

+   连接池概念

+   实现连接池

+   连接池最佳实践

到本章结束时，你应该对连接池有深入的了解，能够实现连接池，并战略性地设计一种利用连接池来提高性能的方法。

# 技术要求

要遵循本章中的示例和说明，你需要具备加载、编辑和运行 Java 代码的能力。如果你还没有设置你的开发环境，请参阅 *第一章*。

本章的完整代码可以在以下位置找到：[`github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter10`](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter10)。

# 连接池概念

大多数现代系统都包含多个数据库，尤其是在实施 **微服务架构** 时。这使得连接池的概念成为高效 Java 应用程序的关键组件。

微服务架构

微服务是软件系统中与特定业务功能相关的独立组件。它们通常拥有自己的数据库，因此可以与主应用程序解耦，并独立于其他微服务进行更新。

关键问题是软件应用程序需要连接到数据库，而这些连接会消耗系统资源。连接池的概念是建立到所需数据库的连接，当它们不再使用时，将它们返回到池中。从池中获取连接比每次数据库操作都需要创建新连接更快，资源消耗也更少。

下面的插图显示了连接池的过程，这也被认为是 **连接池** **生命周期**。

![图 10.1 – 连接池生命周期](img/B21942_10_1.jpg)

图 10.1 – 连接池生命周期

连接池在应用程序最初加载时初始化。初始化的一部分涉及建立连接数量。我们将在本章后面的示例中详细介绍。现在，你应该理解我们将使用**连接池库**来实现。

第二个组件是**连接借用**。每当需要进行数据库操作时，就会从池中获取一个连接。术语“借用”意味着一旦服务不再需要连接，它就会被返回到池中。这就是连接返回组件的生命周期的一部分。未使用的连接被返回到池中，以便再次使用。

## 连接池的优点

连接池有三个主要优点。首先，使用连接池可以提高性能。这种改进是可能的，因为连接被重用，从而加快数据库操作。

在我们的应用程序中实现连接池的另一个优点是我们能更好地优化资源利用。在任何给定时间打开的数据库连接数量减少了，因为未使用的连接在池中。这导致应用程序和数据库服务器开销降低。

连接池的另一个优点是它支持可伸缩性。这是可能的，因为当我们的应用程序使用连接池时，它们可以处理许多同时进行的数据库操作。

## 连接池的挑战

在我们的 Java 应用程序中实施的高性能方法几乎都会带来挑战和关注点。连接池也不例外。有三个主要关注领域。

首先，确定我们连接池的最佳**大小**至关重要。如果我们不允许足够的连接，我们的应用程序可能会变得缓慢或无响应。当我们的连接池过小时，也可能出现瓶颈。另一方面，如果我们的连接池过大，我们可能会过度使用数据库服务器，导致整体系统性能下降。

**连接泄漏**是另一个关注领域。管理连接池的生命周期，重点关注连接借用和返回操作，这一点很重要。当我们未能正确管理这些操作时，可能会发生连接泄漏。

连接泄漏

当我们未能正确地将连接返回到池中时，会发生连接泄漏。这可能导致连接池的资源耗尽。

现在，你应该对连接池及其优点和挑战有一个基础的了解。下一节将介绍实现示例。

# 实现连接池

现在，我们应该理解连接池是什么以及相关的优势和挑战。让我们通过使用 Java 实现连接池来扩展我们的知识。在本节中，我们将查看连接池库，设置连接池，将连接池与应用程序逻辑集成，并探讨如何监控我们的连接池。

## 连接池库

一旦我们决定在一个应用程序中使用连接池，我们需要选择一个合适的连接池库。目前有多个连接池库可供我们使用 Java，我们选择哪一个取决于我们的应用程序需求。让我们来看看三个流行的连接池库。

**Apache Commons 数据库连接池**（**DBCP**）是一个成熟的库，被认为是稳定的，并且具有广泛的应用性。正如其名所示，这是一个来自 Apache 的开源库。虽然这是一个经过验证的库，但它的效率不如更现代的库。

**C3PO**（**基于云的保密性保持连续查询处理**）连接池库是另一个可行的选择。它包括一组强大的功能，包括在无法建立连接时自动重试连接。这个库比 Apache Commons DBCP 库更灵活。

第三个连接池库选项是**Hikari 连接池**（**HikariCP**）。这是一个比前两个更新的库，因其简洁性和性能而受到赞誉。为了提高我们的 Java 应用程序的性能，HikariCP 是连接池的一个很好的选择，也是本章剩余部分所介绍的库。

选择连接池库时应考虑的六个主要因素：

+   **兼容性**：你应该检查库是否与你的 Java 版本以及你计划使用的任何数据库驱动程序或工具兼容。

+   **熟悉度**：如果你和你的开发团队已经熟悉某个特定的连接池库，如果你继续使用你熟悉的库，你可以引入更快的开发和更少的错误。这种做法的缺点可能是你可能会为了开发效率而牺牲功能和运行时性能。

+   **功能**：应审查功能列表，以确保你选择的库可以完成你期望它做的事情。

+   **维护**：我们应该始终倾向于选择可维护的库。

+   **性能**：这是一个至关重要的因素。你希望确保在你选择的库在压力下（高且持续的工作负载）不会表现不佳。这是在正式采用连接池库之前你应该测试的事情。

+   **支持**：检查官方网站以确保有足够的文档。此外，你希望选择一个有强大社区支持的库。这可以在你遇到开发挑战和故障排除时帮助你。

在选择连接池库时，应高度重视整体应用程序的性能。这可能需要尝试多个库并反复试验。审查每个库的功能可以帮助你做出明智的决定。以下表格可以帮助你进行审查。

| **特性** | **Apache DBCP** | **C3P0** | **HikariCP** |
| --- | --- | --- | --- |
| 性能 | 良好 | 良好 | 极佳 |
| 连接超时 | 是 | 是 | 是 |
| 语句缓存 | 是 | 是 | 是 |
| 空闲连接测试/验证 | 是 | 是 | 是 |
| 连接验证 | 是 | 是 | 是 |
| 池大小灵活性 | 良好 | 良好 | 极佳 |
| 文档 | 良好 | 良好 | 极佳 |
| 社区支持 | 良好 | 良好 | 极佳 |
| 配置简便性 | 中等复杂 | 中等复杂 | 简单 |
| 现代框架集成 | 差 | 良好 | 极佳 |

表 10.1 – 库特性

如前表所示，许多特性在所有三个连接库中都有相同的评级。这表明可能需要更深入的研究。此比较仅提供了一个高级概述，并提供了你可能需要进一步研究的领域的见解。

## 设置连接池

现在我们已经选择了连接池库，在我们的例子中是 HikariCP，我们需要遵循几个特定的步骤。让我们通过使用 Maven 作为构建工具的示例来逐步说明：

1.  **将库添加到** **你的项目**：

    我们需要编辑我们的 pom.xml 文件以将 HikariCP 添加到我们的依赖项中。以下是这样做的方法：

    ```java
    <dependency>
        <groupId>com.zaxxer</groupId>
        <artifactId>HikariCP</artifactId>
        <version>2.6.3</version>
    </dependency>
    ```

1.  在`dataSource`中设置几个参数以配置我们的连接池：

    ```java
    import com.zaxxer.hikari.HikariConfig;
    import com.zaxxer.hikari.HikariDataSource;
    public class DatabaseConfig {
      private static HikariDataSource dataSource;
      static {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl( "jdbc:postgresql://localhost:5432/
        myDatabase");
        config.setUsername("databaseUser");
        config.setPassword("databasePassword");
        // Pool configuration
        config.setMaximumPoolSize(10);
        config.setMinimumIdle(5);
        config.setIdleTimeout(600000);
        config.setMaxLifetime(1800000);
        config.setConnectionTimeout(30000);
        dataSource = new HikariDataSource(config);
      }
      public static HikariDataSource getDataSource() {
        return dataSource;
      }
    }
    ```

1.  在`DatabaseConfig`类中的`static`连接池。我们采用这种方法，以便在类加载时初始化并准备好我们的连接池。我们通过`getDataSource()`方法建立了对连接的全局访问点。这便于我们的应用程序方法从池中借用连接。

1.  使用`getDataSource()`方法，我们可以访问连接池并获取连接。以下是一个完成此任务的示例方法。如前所述，这并不是一个完整的应用程序；而是一个代表代码片段，用于展示如何使用连接池：

    ```java
    import java.sql.Connection;
    import java.sql.ResultSet;
    import java.sql.Statement;
    public class DatabaseOperations {
      public void executeQuery(String query) {
        try (Connection conn = DatabaseConfig.getDataSource().
        getConnection();
            Statement stmt = conn.createStatement();
            ResultSet rs = stmt.executeQuery(query)) {
          while (rs.next()) {
            // Here you would process the result set
          }
        } catch (Exception e) {
            e.printStackTrace();
        }
      }
    }
    ```

如前所述，我们实现了`try-with-resources`语句来自动关闭我们的数据库连接，并将连接返回到池中以便再次使用。

## 集成连接池

将连接池集成到我们的 Java 应用程序中需要我们创建代码（如前节所示），以创建、使用和关闭数据库连接。我们强调，我们不再需要在需要数据库连接时每次都打开一个新的数据库连接。相反，我们从池中借用连接，并在使用完毕后归还。

主要集成点如下：

+   管理连接

+   获取连接

+   处理错误

一旦我们设置了连接池，我们需要在运行时对其进行监控，并根据需要调整。让我们在下一节中查看这些任务。

## 监控连接池

连接池是现代软件系统的重要组件，它们可以极大地提高整体系统性能。这强调了在运行时监控它们性能的重要性。我们可以通过审查日志和使用监控工具来完成这项任务。大多数连接池库都附带足够用于此任务的工具。

除了错误之外，我们还应寻找以下情况：

+   连接泄漏

+   长等待时间

+   不适当的池大小

监控连接池的一部分包括建立关键指标的需求。仅仅查看系统日志是不够的；我们需要一套指标或基准来正确衡量我们连接池的成功和性能。

在我们继续监控连接池性能的同时，我们可以做出在应用程序启动时应用的配置更改。对于始终开启的系统，您可能需要重新启动服务或服务器。持续改进性能的心态可以帮助确保我们从连接池中获得最佳性能，并积极影响系统的整体性能。

# 连接池的最佳实践

连接池实现相对简单，就像大多数编程任务一样，您将很快拥有自己的代码库，您可以为后续编程项目重构它。这通常是系统成功的关键组成部分，因为它为您的应用程序访问数据提供了机制。在您的连接池策略中应考虑以下因素。让我们看看主要因素。

## 连接池大小

确保您的连接池大小适当是您应考虑的第一个因素。我们应该努力在性能和资源使用之间找到理想的平衡。如果我们的池太小，访问等待时间可能会增加，这将对性能产生负面影响。过大的连接池可能导致浪费资源，如空闲连接需要系统资源。

挑战在于知道理想的连接池大小。这可能需要一些尝试和错误。最初，我们可以估计我们的应用程序可能一次需要的数据库连接数。对此没有魔法公式，因此在做出初始估计时请考虑以下因素：

+   您的应用程序需要数据库连接以完全功能的服务数量

+   您需要的并发连接数

+   审查使用模式

+   峰值负载条件

以我们之前提到的`HikariCP`为例，我们可以在`DataSourceConfig`类中使用一行代码来设置连接池的大小：

```java
    config.setMaximumPoolSize(10);
    config.setMinimumIdle(5);
```

如您所见，我们将最大连接数设置为`10`，并将池维护的最小空闲连接数设置为`5`。

一旦您做出初始连接池大小的决定，继续监控性能并根据需要调整您的配置。您可以使用连接池库附带的工具，以及外部工具，如**应用性能监控**（**APM**）工具。

## 处理连接泄漏

一旦您的应用程序开始运行，您应该致力于持续监控您的连接池性能。虽然您希望不会遇到连接泄漏，但最佳实践是为此做好准备。提醒一下，当连接不再使用时未将其返回到池中时，就会发生连接泄漏。这可能导致池中可用连接耗尽。最终，这可能导致您的应用程序失败。

处理连接泄漏有两种主要方法，并且可以相互配合使用。

### 超时设置

我们可以为借用连接设置超时时间。如果连接从池中被借用的时间过长，那么我们可以将其回收，或者至少记录一条日志条目以帮助您的监控工作。

让我们回顾一下本章前面代码片段中的池配置部分：

```java
    config.setIdleTimeout(600000);
    config.setMaxLifetime(1800000);
    config.setConnectionTimeout(30000);
```

如前述代码片段所示，我们将连接在池中处于空闲状态的最大时间设置为 60,000 毫秒（约 1 分钟）。第二行代码将连接在池中的最大生命周期设置为大约 30 分钟，第三行设置等待从池中获取连接的时间。

### 连接处理模式

我们应该审查我们的代码，以确保连接始终被关闭。这可以在`finally`块中完成，或者在本章前面使用过的`try-with-resource`语句中完成。让我们看看每个示例。

第一个代码片段仅为了说明目的而采用简化的格式。它演示了我们可以如何确保连接被关闭。在以下示例中，我们假设所有适当的导入语句都将被包含，并且`dataSource`已在应用程序的其他地方初始化。在`finally`块中，我们确保资源被关闭以帮助避免连接泄漏：

```java
// import statements
public class DatabaseUtil {
    private DataSource dataSource;
    public void executeQuery(String query) {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            conn = dataSource.getConnection();
            stmt = conn.createStatement();
            rs = stmt.executeQuery(query);
            // Process the result set
            while (rs.next()) {
                // Handle data
            }
        } catch (Exception e) {
            // Handle exception
        } finally {
            if (rs != null) {
                try {
                    rs.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (conn != null) {
                try {
                    conn.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

在实现`finally`块以帮助确保资源关闭以避免连接泄漏的同时，另一种方法是使用`try-with-resources`语句。以下是该语句的示例：

```java
public void executeQuery(String query) {
    try (Connection conn = dataSource.getConnection();
        Statement stmt = conn.createStatement();
        ResultSet rs = stmt.executeQuery(query)) {
        // Process the result set
        while (rs.next()) {
            // Handle data
        }
    } catch (Exception e) {
        // Handle exception
        e.printStackTrace();
    }
}
```

这种方法导致资源在退出 try-catch 块后自动关闭。退出可以基于正常的程序流程或当捕获到异常时发生。在这两种情况下，资源都将自动关闭。如您所见，这种方法不需要`finally`块，因此是推荐的方法。

## 连接池安全性

连接池使我们能够访问数据库，我们必须始终保护它们。维护数据库连接池可能代表巨大的安全风险。我们可以实施两种保护措施。

首先，我们可以加密我们的配置文件。这些文件包含我们的数据库连接信息，应被视为敏感信息。加密和解密可能会消耗处理时间，从而导致性能略有下降，但这是你应用程序的一个必要组件。

另一种保护措施是使用**最小权限**的概念，只授予应用程序运行所需的最小权限。例如，如果你有一个仅需要搜索客户数据库以显示诸如姓名、电子邮件和账户号码等关键信息的服务，不要授予该服务创建、更新或删除数据库的访问权限。在这种情况下，你只需要授予该服务读取访问权限。

## 高级主题

有几个连接池主题超出了基础知识，在我们旨在优化连接池性能的过程中值得考虑。以下是我们将探讨的四个主题：

+   **云原生**：当我们与基于云的应用程序一起工作时，我们可以利用云环境本地的功能。这可以包括旨在提高弹性、可靠性和可伸缩性的功能。理想情况下，我们的数据库选择将基于云原生数据库服务，以进一步优化连接池。

+   **连接验证**：定期执行一个函数来验证池中的连接是一个好主意。这可以确保它们保持有效，并可以防止代价高昂的问题。

+   **故障转移**：数据库冗余是云计算环境的关键特性。具体到连接池，我们可以实现一个故障转移方案，在第一个数据库失败时切换到备份数据库。

+   **冗余**：为了支持故障转移，作为正常实践的一部分，我们应该实现数据库冗余。利用云计算数据库服务可以使这相对容易配置。

遵循本节中提出的最佳实践可以帮助你以有助于提高 Java 应用程序性能的方式实现连接池。

# 摘要

本章深入探讨了连接池的基础概念和组件，重点关注提高我们 Java 应用程序的性能、弹性、可靠性和可伸缩性。我们还探讨了优化我们连接池使用的实现策略和最佳实践。具体来说，我们强调了连接池的工作原理、它们的优点以及开发人员面临的挑战。我们回顾了多个连接池库的功能，并选择了 HikariCP 库作为我们的代码示例。你应该对连接池有一个牢固的理解，包括为什么我们应该使用它们，以及如何创建、监控和微调它们。

在下一章中，我们将探讨**超文本传输协议**（**HTTP**）。该协议用于传输数据，是网络数据通信的骨干。我们的重点是探讨如何利用 HTTP 让 Java 应用程序与网络浏览器和网络服务器进行通信。本章旨在帮助您学习如何在 Java 网络应用程序中使用 HTTP，同时保持高性能，如何实施有效的 HTTP 使用策略，以及如何使用 HTTP 在 Java 应用程序和 API 之间进行通信。
