# 第十三章：探索软件生命周期

在前面的章节中，我们探讨了 Java 应用程序开发的许多不同方面。从包括需求收集和架构设计在内的**软件开发生命周期**（**SDLC**）开始，我们关注了许多不同的技术方面，包括框架和中间件。

在这一点上，我们需要关注几个横切关注点，无论我们正在构建什么类型的应用程序以及我们选择什么架构风格。

在本章中，我们将探讨这些方面。我们将从诸如源代码维护（包括版本控制和分支策略）等问题开始，一直扩展到与整个 SDLC 相关的核心主题，如部署、**持续集成/持续交付**（**CI/CD**）以及其他相关概念。

在本章中，我们将涵盖以下主题：

+   源代码管理

+   测试

+   部署

+   持续集成/持续交付（及部署）

+   发布

+   维护

我几乎可以肯定，在你的职业生涯中，你已经有机会熟悉这些主题。实际上，这些通常被视为理所当然。

然而，在本章结束时，你将全面了解整个流程，这对于构建和维护一个功能强大且高效的软件工具链将非常有用。

现在，让我们从**源代码管理**（**SCM**）开始。

# 技术要求

你可以在这里找到本章使用的源代码：[`github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java/tree/master/Chapter13`](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-Java/tree/master/Chapter13)。

# 源代码管理

SCM 是一个相当基本的概念，当然，在任何软件项目中（包括非常小的项目）都应该被认为是强制性的。如今，SCM 与 Git 同义（关于这一点，我们很快就会讨论更多）；然而，多年来已经使用了许多替代方案，包括**并发版本系统**（**CVS**）和 Apache **Subversion**（**SVN**）。

SCM（源代码管理）的基本功能包括备份、共享和版本控制源代码。然而，这些功能有许多细微之处。因此，让我们更深入地了解一下 Git。

## Git 简介

Git 是由 Linux OS 的创造者林纳斯·托瓦兹（Linus Torvalds）创建的，作为支持操作系统本身开发的工具。

除了项目历史之外，Git 有许多有趣的特性使其成为事实上的标准：

+   它高度去中心化。使用 Git，每个开发者都可以使用本地仓库进行工作，这有利于文件版本控制、分支以及其他功能，即使在没有远程服务器的情况下（例如在断开连接的环境中）。这也使得它在性能方面具有真正的可扩展性。

+   使用 Git，每个版本都与一个加密哈希 ID 相关联。这样，文件的历史可以很容易地重建，并且使得篡改它们变得困难。

+   Git 依赖于众所周知且经常使用的协议，如 HTTP、SSH 和 FTP。这使得它在现有环境中易于使用。

Git 包含了许多不同的命令和功能；然而，使用它的基本方法如下：

+   `git init [本地文件夹]`：这是用于在本地初始化新仓库的命令。

+   `git clone [仓库]`：这个命令创建现有仓库的本地副本。在认证仓库的情况下，有多种不同的认证方式，包括将用户名和密码作为 URL 的一部分传递（使用类似 git clone: `https://username:password@remote` 的方式）。然而，建议使用更好的选项（如使用令牌）。

+   `git add [要添加的文件]`：这个命令将一组文件添加到暂存区（这基本上是在提交到仓库之前的中间步骤）。

+   `git commit -m [提交信息]`：这个命令将暂存区的文件提交到仓库。

+   `git branch [分支名]`：这个命令创建一个新的分支。**分支**（这是一个许多版本控制系统中常见的概念）是在一个隔离区域存储一组实现的方式，这些实现可能对整个系统（如新的大版本）产生影响。然后，这些发展可以与主要发展合并。

+   `git tag [标签名]`：这个命令创建一个新的标签。**标签**类似于分支，但它基本上是不可变的。它通常用于标记代码中的特定重要事件（如发布），以便更容易地识别在那个特定时刻的代码状态，并可能重新构建它。

+   `git push [远程] [分支]`：这个命令将本地更改推送到指定分支的远程仓库。

这些 Git 命令，尤其是分支和标签的概念，是非常强大的工具。随着时间的推移，它们的使用方式变得越来越结构化，形成了一些特定的工作流程。在接下来的章节中，我们将看到一些关于这方面的想法。

### Git Flow

尽管名字叫 Git Flow（以及其他类似的技术），但这并不是 Git 的先决条件，从理论上讲，也可以使用与 Git 不同的版本控制工具（SCM 工具）来实现。然而，通常与 Git 一起实现这类技术。

Git Flow 是一种管理和发展、创建发布以及总体上结构化代码处理方式的方法。

Git Flow 基于多个分支持续共存，可以手动实现或使用一些创建来支持这种工作方式的工具。

存储代码的核心分支被称为**主**分支。开发者不应该直接在这个分支上工作。相反，从它创建一个**开发**（**Dev**）分支来存储正在进行的工作。为了工作在一个特性上，每个开发者将**Dev**分支复制到一个专门创建的**特性**分支，该分支用于包含特定的特性。当一个特性完成时，它将被合并回**Dev**分支。理论上，由于只开发了少数几个特性，合并操作不应该太难（因为代码变化不大）。以下图表说明了这一点：

![图 13.1 – Git Flow 中的特性开发](img/Figure_13.01_B16354.jpg)

图 13.1 – Git Flow 中的特性开发

如我们所见，最简单的情况是特性一个接一个地开发，因此我们刚刚开发的特性必须合并回。然而，在实际情况下，通常会有多个特性并行开发，因此合并回**Dev**分支可能会稍微困难一些。

当开发足够多的特性（并且已合并到**Dev**分支）时，从**Dev**分支创建一个新的分支，称为**发布**。**发布**分支应该有一种*特性冻结*，这意味着提交到这个分支的所有代码必须只具有发布的目标，而不添加任何新特性。这意味着当对**发布**分支中的代码进行测试时，开发者应该在这个分支中提交（如果有）错误修复。

发布所需的其他文件（例如文档和脚本）可以添加到那里。当发布准备就绪时，分支中的代码将被标记（即，*冻结*到特定版本）。然后，**发布**分支合并回**主**分支和**开发**分支，以便开始为即将到来的版本的开发工作，如图所示：

![图 13.2 – Git Flow 中的发布管理](img/Figure_13.02_B16354.jpg)

图 13.2 – Git Flow 中的发布管理

如我们所见，当进行发布工作时，所有代码都应该在**发布**分支本身中进行修改，以修复阻止该特定发布进入生产的错误。一旦一切准备就绪并且生产发布成功，**发布**分支中的代码（包括该发布的*冻结*代码以及任何错误修复）将被合并回**主**分支和**开发**分支。

如果生产中出现问题，将从一个**主**分支创建一个临时的**热修复**分支，用于生产修复，并尽可能快地合并，如图所示：

![图 13.3 – Git Flow 中的热修复开发](img/Figure_13.03_B16354.jpg)

图 13.3 – Git Flow 中的热修复开发

如图中所示，在热修复的情况下，代码应来自**主**分支，修复必须在**热修复**分支上进行。然后必须将这些更改合并回**主**和**开发**分支。

Git Flow 似乎有点复杂，确实需要很多不同的分支和合并操作。但它也被认为不太适合现代应用程序开发技术，如 CI/CD 和 DevOps。在这种情况下，仓库式开发被认为是一个更好的选择。

### 仓库式开发

**仓库式开发**比 Git Flow 简单得多。基本上，每个开发者都在同一个分支（通常是主分支）上工作。他们被允许为本地开发创建分支，但建议尽可能使这些分支的生命周期短暂，并尽快将它们合并回主分支（至少每天一次）。这样做是为了确保开发的一致性，测试应该通过，并且更改不应该破坏项目中的其他部分。

在这种情况下，仓库式开发通常被视为与 CI/CD（本章后面将详细介绍）的完美搭配。可能（且常见）是自动化流程不断检查主分支的完整性（例如，每次合并后），如果测试失败，则可以撤销更改；或者，团队中的某个人（通常是这些更改的开发者）应专注于修复问题。主分支可以随时在生产环境中发布（携带所有最新的开发成果）。在每次发布之前，代码都会被打上标签，以便进行维护的可追溯性和可重复性。

除了易于实施和维护外，仓库式开发在变更管理方面也要求付出更少的努力，因为合并较小且发生频率较高。

另一方面，它需要每个项目贡献者有丰富的经验和奉献精神，因为它增加了错误或其他不良代码滑入主分支（理论上，进入生产环境）的可能性。与分支策略相关的一个相关主题是版本控制标准。

### 语义版本控制

正如我们所言，在每次发布期间，源代码会被**冻结**（通常使用标签），并为了维护目的进行唯一标识。

然而，关于如何选择版本号的最佳方式，即选择一个唯一的标识符，存在许多不同的理论。

我发现的一种特别优雅且有效的方法是语义版本控制。

**语义版本控制**在开源项目中普遍使用，基本上将每个版本与三个数字关联，形式为*x.y.z*（例如，*1.2.3*）。这些数字的任何变化都有精确的含义：

+   第一个数字（在我们的例子中用*x*表示）被称为**主版本**。主版本的提升意味着主要更新，包括新功能、重构、技术变更，最重要的是，可能包括破坏性更改（包括 API 的变化）。

+   第二个数字（在我们的例子中用*y*表示）被称为**次要版本**。次要版本的升级意味着新的功能，这些功能也可以是非平凡的，但应该是向后兼容的，因此应避免更改公开的 API。

+   第三个数字（在我们的例子中用*z*表示）被称为**补丁版本**。该版本的升级仅意味着修复错误。不应包含新功能（除非非常简单），当然，公开的 API 中不应有破坏性更改。

主版本的增加意味着次要版本和补丁版本都会重置为*0*。因此，如果我们对版本*1.2.3*进行了重大更改（通过破坏 API），下一个发布版本应该是*2.0.0*。

类似地，次要版本的增加会将补丁版本重置为*0*，所以对于版本*1.2.3*，如果有向后兼容的新功能，我们将升级到版本*1.3.0*。不用说，每个版本都可以升级到两位数，而不会影响其他版本。因此，软件版本*1.9.3*中次要版本的升级意味着升级到版本*1.10.0*。

在三个数字组成版本号之后，可以添加一个可选的标签。常见的标签有**RELEASE**（标识已发布到生产的版本）、**ALPHA**（标识预发布版本，不打算用于生产）和**Release Candidate**（**RC**）（这几乎已经准备好用于生产，但可能还需要进行一些测试）。

也将主版本设置为*0*作为识别第一个项目草案（如原型，不打算稳定）的常见约定。

在本节中，我们学习了一些有趣的概念。从事实上的标准 Git 和 SCM 开始，我们了解了几种不同的分支策略，并查看了一种标准的版本发布方式。现在，我们的下一步是考虑一些关于测试的问题。

# 测试

在*第四章*“设计和开发的最佳实践”中，我们了解了**测试驱动开发**（**TDD**），简要地提到了**单元测试**的概念。现在是深入考虑测试概念并回到我们迄今为止已经视为理所当然的一些主题的正确时机。

## 单元测试

**单元测试**是软件质量保证的最基本技术，正如我们所见，是 TDD 背后的工具。

单元测试旨在为可识别的最小软件单元提供测试（通常是自动化的）。在 Java 世界中，这意味着在类和方法级别进行测试。测试涉及使用定义好的输入集调用方法，并检查（使用断言）输出是否符合预期（包括预期的失败）。

其背后的原因是每个方法都是单独测试的，因此测试可以简单且无处不在。这也允许在引入（至少在确切的方法中）的精确位置早期识别错误。这种方法的局限性是它不容易检测由边缘情况或复杂系统之间的交互或与外部系统引起的错误。

在 Java 世界中，单元测试意味着 JUnit，这是一个非常著名的库，广泛用于实现单元测试等。让我们更多地了解它。

### JUnit

**JUnit**是 Java 单元测试的事实标准。撰写本文时的当前版本是**版本 5**。JUnit 提供了一些标准和工具，用于定义单元测试并将它们集成到常见的工具链中，如 Maven 和 Gradle。JUnit 也易于从常见的 IDE，如 IntelliJ 中运行。

Maven 标准定义，测试类必须放置在`src/test/java`文件夹中，而应用程序代码应保留在`src/main/java`文件夹中。

这样，测试类可以与应用程序文件相同的包结构相匹配，在发布阶段，测试类可以被丢弃，不成为发布工件的一部分。

JUnit 自动考虑（并运行）名称以`Test`开头或结尾的类中包含的测试。

每个测试方法都通过`@Test`注解来标识。可以使用`@BeforeAll`和`@BeforeEach`等注解来注解一些在测试之前设置资源的方法。同时，可以使用`@AfterAll`和`@AfterEach`来清理测试后的东西。测试执行可以通过使用`@Order`来控制。

此外，JUnit 提供了一套便利方法，如`AssertEquals`、`AssertTrue`和`AssertFalse`，可用于检查预期的结果。

JUnit 执行通常作为构建链中的一个步骤集成（作为 Maven 构建或更复杂管道的一部分）。你可以持续查看哪些正在工作，哪些失败，通常会有绿色和红色灯的视觉表示来生成报告。

现在，我们有一个如下简单类：

```java
package it.test;
 public class HelloWorld {
     private String who;
     public HelloWorld() {
        this.who="default";
    }
     public String getWho() {
        return who;
    }
     public void setWho(String who) {
        this.who = who;
    }
     public String doIt()
    {
        return "Hello "+ this.who;
    }
 }
```

前一个类基本上有一个带有 getter 和 setter 的字段，以及一个执行经典*hello world*（使用字符串连接）的方法。与前面类相关联的单元测试类如下：

```java
package it.test;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import io.quarkus.test.junit.QuarkusTest;
public class HelloWorldTest {
    HelloWorld hello;
    @BeforeEach
    public void buildHello()
    {
        this.hello= new HelloWorld();
    }
...
```

关于前面测试的一些考虑如下：

+   测试所在的`it.test`包与实现所在的包相同。正如所说，这是可能的，因为实现保持在`src/main/java`文件夹中，而测试保持在`src/test/java`文件夹中。在测试阶段，你可以将前两个文件夹视为源文件夹，而在构建工件时，你可以丢弃测试文件夹。这允许我们访问要测试的类的`protected`字段和方法。

+   类名以 `Test` 结尾。这将向 JUnit 框架暗示该类包含一些测试。

+   `buildHello` 方法使用 `@BeforeEach` 注解，因此它在每个测试方法之前执行。当然，在这个例子中，实现很简单，但在现实世界中，有很多有意义的事情要做，比如初始化模拟数据和连接到外部系统。

你还可以使用 `@BeforeAll`，它在所有测试之前执行一次。值得注意的是，`@AfterEach` 和 `@AfterAll` 也可用于清理需要安全关闭的资源（如数据库连接）或清理必要的数据 ID。

+   每个测试方法都使用 `@Test` 注解，并通过使用 `Assertions.assertEquals` 工具方法对预期输出进行一些断言。其他方法，如 `assertTrue` 和 `assertFalse`，也都可以使用。正如你所看到的，这里测试了一些简单的事情，例如设置器，这些通常可能不太容易出 bug：

    ```java
    ...
      @Test
        public void testConstructor()
        {
            Assertions.assertEquals(this.hello.getWho(), 
              "default");
        }
        @Test
        public void testGetterSetter()
        {
            String name="Giuseppe";
            this.hello.setWho(name);
            Assertions.assertEquals(this.hello.getWho(),
              name);
        }
        @Test
        public void testDoIt()
        {
            String name="Giuseppe";
            String expected="Hello "+name;
            this.hello.setWho(name);
            Assertions.assertEquals(this.hello.doIt(),
              expected);
        }
    }
    ```

通过使用 `Assertions` 的 `static` 导入，可以使之前的代码更易于阅读，然后直接使用该类提供的方法。

当运行这些测试时，你可以轻松地看到测试执行的回顾。例如，通过运行 `mvn clean test` 命令，你应该会看到类似于这个屏幕截图的内容：

![图 13.4 – 命令行中的测试执行](img/Figure_13.04_B16354.jpg)

图 13.4 – 命令行中的测试执行

正如你所见，构建成功，并且有一个执行测试的回顾（这些测试都是成功的）。如果测试失败，默认情况下，构建会失败。如果我们知道有某个测试是故意失败的（例如，方法尚未实现，这在 TDD 方法中很常见），我们可以跳过那个特定的测试（通过使用 `@Disable` 注解）或者完全跳过测试阶段（这通常不建议）。

在大型项目中，通常会将测试结果保存并归档为构建过程的一部分。这可能只是简单地保存构建的控制台输出和测试回顾（如前一个屏幕截图所示）或使用更复杂的技术。通过使用广泛使用的 Maven 插件（`.xml` 或 `.html` 文件，尽管更完整的商业测试套件也能做类似的事情）。

但这仅仅是关于单元测试。为了完整地了解，了解还有更多测试方式是可能的（并且建议）。让我们在接下来的章节中看看它们。

## 超越单元测试

单元测试，实际上可以看作是测试世界中的（基本和必要的）最低级步骤。确实，正如我们之前所说的，单元测试无法捕获一些依赖于类之间更复杂交互的 bug。为了做到这一点，通常会实现更多的测试技术，例如集成测试、端到端测试、性能测试和**用户验收测试**（**UAT**）。

### 集成测试

**集成测试**是单元测试之后的直接下一步。虽然单元测试测试的是软件中最基本的模块，如方法和类，但集成测试侧重于这些模块之间的交互（但不是整个系统）。因此，将这些类组合在一起并相互调用以检查（并实现）更复杂的测试场景。每个测试都涉及多个方法调用，通常来自不同的类。

对于定义每个集成测试的粒度并没有固定的规则，即使有人完全放弃这种测试技术而转向端到端测试（更多内容将在下一节中介绍）。我个人的建议是，至少通过尝试涉及至少两个或三个类来模拟核心功能或至少受更改影响最大的功能进行集成测试（以及问题）。

虽然有专门用于集成测试的库可以实现（例如，`arquillian`），但 JUnit 也可以通过使用与上一节中相同的设施（如断言和设置方法）进行集成测试，并且被广泛使用。当然，而不是为每个方法和类构建测试，更复杂的交互应该通过链式方法调用和将不同的类连接起来来实现。

### 端到端测试

**端到端测试**，也称为**系统测试**，将集成测试的理念进一步扩展。端到端测试包括对每个功能作为一个整体的测试，包括外部系统（如数据库），这些系统通常作为测试工作的一部分进行专门化和维护。功能可以在许多不同的时间定义，但如今通常与 API 的概念重叠。

端到端测试包括通过传递一组已知的输入来调用 API（或以不同的方式触发功能），然后检查预期的输出。这包括 API 响应，同时也会检查预期发生变化的系统状态（如数据库中编辑的内容或需要联系的外部系统，如发送电子邮件）。

这意味着系统随后是从外部进行测试的，与迄今为止看到的其他测试技术相反，这些技术更侧重于源代码（然后更多是从项目的内部进行观察）。

端到端测试提供了对系统整体行为的良好理解，并且它通常比单元测试和集成测试更不稳定，因为任何方法中的微小变化都可能导致许多端到端测试失败（取决于该方法，并且可能未被检测到或对单元测试和集成测试的影响较小）。然而，它也更粗糙，因此可能更难理解问题出在哪里以及为什么会出现这些问题。

有很多端到端测试的工具，既有免费的也有商业的。这类工具通常更像是独立平台，而不是之前看到的工具（如 JUnit），它们更像是库和框架。此外，端到端测试基本上是语言无关的，因此 Java 项目通常不需要任何特定的测试工具，因为测试的入口点是 API 或用户界面。所以，任何能够在这个级别交互的工具都可以使用。

常用的解决方案包括 LoadRunner，这是一个由 HP 最初构建的商业解决方案，现在是 Micro Focus 的一部分，在某些项目中是标准。其他替代方案包括 SmartBear 测试套件和其他免费测试套件，如 JMeter、Cypress、Karate、Gatling 和 Selenium。后两种工具更专注于自动化用户界面交互，这意味着有基本的方法可以自动化程序对网络浏览器的基本使用，模拟真实用户访问 Web 应用程序，检查所有预期的行为。

### 性能测试

**性能测试**是端到端测试的特殊情况。它不是仅专注于测试的每个 API（或功能）的正确实现（这基本上是理所当然的），而是关注系统容量和不同负载下的响应时间。虽然工具可以是（并且通常是）与端到端测试相似的，但最终目标不同。进行性能测试时测量的指标是第六章中描述的，即《探索关键 Java 架构模式》一书中“设计用于大规模采用”部分中的指标，包括吞吐量、响应时间和经过时间。

性能测试可以包括以下场景：

+   **负载测试**，即测量系统在定义的负载下的性能，通常与生产环境中的预期情况相似（或者是一个夸张的情况，例如将预期的并发用户数量加倍）。

+   **峰值测试**，与之前的测试类似（实际上它们经常一起运行），基本上涉及流量负载的突然变化来模拟峰值。这种测试的目的是检查系统的可扩展性和在突然流量增加后恢复所需的时间。换句话说，在流量意外增加后，系统可能会允许出现轻微的减速（因为系统预计会适应这种流量，例如使用自动扩展技术），但值得测量系统在减速后恢复所需的时间。

+   **压力测试**，将之前的测试类型推向极限，旨在通过测量系统能够正确处理的最高流量来基准测试系统。

在性能测试期间，无论工具和目标如何，强烈建议观察系统作为一个整体，包括操作系统参数（如内存、CPU 和网络）以及外部系统，如数据库，以便检查瓶颈并了解系统如何进行微调以更好地运行。

### 用户验收测试

UAT 是测试过程中的关键步骤，可以说在整个软件开发过程中都是如此。从技术角度来说，它与端到端测试非常相似，因为它专注于整体测试功能。然而，也有一些关键的区别。第一个区别是，测试应该由功能分析师、业务人员或项目赞助人负责。

当然，这并不意味着这些人应该亲自运行测试，而是测试结构（包括验收标准和测试功能的优先级）应由这些团队设定，这通常是通过关注最终用户的观点来完成的（因此这个阶段得名）。

人们普遍认为，这部分测试中有一部分是手动完成的，用户直接导航应用程序功能，就像最终用户应该做的那样。更确定性的方法是在使用与端到端测试中使用的类似工具运行 UAT。即使在这种情况，通常仍然会手动执行这一阶段的小部分，通过进行所谓的**烟雾测试**，这种测试不那么结构化，旨在给出应用程序行为的一般印象。

不论是手动执行还是自动化执行，UAT（用户验收测试）与其他测试之间的核心区别在于，测试需要围绕业务能力来设计。实际上，每个测试用例都应该与一个特定的需求相关联，以便证明该需求目前在该特定软件版本中已实现。我们已经在*第二章*《软件需求 – 收集、记录、管理》中讨论了这一点，我们看到了每个软件需求应该如何是可测试的。

这就是那个循环闭合的地方。UAT 的成功执行是生产发布的门户（因此有“验收”这个词）；如果所有测试都成功，当然在生产中发布是安全且被接受的。如果出现任何失败，需要做出选择（通常与扩展团队讨论）。

如果出现小问题，这可能意味着发布仍然会进入生产环境，同时存在几个已知问题。当然，如果情况并非如此，问题太多（或与关键特性相关），那么这些问题需要得到解决，生产发布可能会被取消或推迟。UAT（用户验收测试）基本上是测试的最高级别，但重要的是要理解，围绕迄今为止看到的每一种其他测试技术都需要有一个策略；否则，很可能会得到一个没有完全测试且容易出错的软件。然而，还有一些关于测试的其他考虑因素值得关注。

## 进一步的测试考虑因素

在前面的章节中，我们看到了关于测试的许多有趣的事情，包括不同的测试阶段和技术。然而，还有一些其他值得讨论的考虑因素。

### 与外部系统交互

正如我们所见，在测试的大多数阶段（有时甚至在单元测试中），可能会涉及到外部系统。数据库、邮件服务器和 Web 服务是常见的例子。

在测试阶段处理此类外部系统有许多不同的技术。最简单的一种，更适合某些特定的测试阶段，如单元测试，就是简单地模拟这些系统。这意味着实现特殊的自定义类，这些类简单地模拟与这些系统的交互，而不是仅仅提供虚假值。

Java 中一个非常流行的模拟库是`Mockito`，它提供了一个简单但非常完整的设置，以编程方式实现响应请求的方法，模拟外部系统的行为。

模拟（Mocking）非常方便使用，因为它主要是由代码驱动的，并且需要最少的维护。然而，由于它易于理解，它在测试中提供的有效性有限，因为它只测试交互的一小部分，通常忽略一些方面，例如与外部系统的连接（以及可能在那里出错的事情），总的来说，它并不针对真实（或接近真实）的系统进行测试。

进一步的步骤是有效地在测试中使用外部系统，但使用的是简化的版本。最常见的例子是用 H2（我们在*第七章*，*探索中间件和框架*)代替完整的数据库系统。这样做的原因是，与真实系统相比，它可能更难（且更昂贵）使用，而这样的简化工具通常更容易在测试环境中自动化和使用。

然而，正如我们在 *第九章* 中讨论的，*设计云原生架构*，当谈到 12 因子应用程序时，使用与生产环境不同的外部服务（在该上下文中定义为后端服务）应被视为潜在不稳定性的来源，因为当然，其行为可能与真实系统不同。因此，特别是在端到端测试和 UAT 阶段，强烈建议使用尽可能接近生产环境的系统。这引出了关于临时测试的下一个考虑因素。

### 临时测试

**临时测试** 是一种在需要时创建完整测试环境的技术。这基本上意味着测试所需组件的集合，包括应用程序和外部系统，在每个测试运行之前按需创建，并填充测试执行所需的数据和配置。

这些环境可以在每次测试运行后丢弃，避免在不需要时浪费计算资源。这种范式特别适合于 IaaS 和 PaaS 环境（如在第九章中所述，*设计云原生架构*），因为此类基础设施将促进环境创建和丢弃的脚本化和自动化。IaaS 和 PaaS 还适合重新创建不仅包括应用程序组件，还包括外部服务（如数据库），因此是克服我们在上一节中描述的限制的好方法，特别是与模拟相关。

Testcontainers ([www.testcontainers.org](https://www.testcontainers.org)) 是一个非常适合此类场景的开源框架。它支持 JUnit（以及其他测试框架），并提供测试工具的临时容器化实例（例如常见的数据库、Selenium 浏览器等）。

但拥有所有正确的组件并不是制定有意义且完整的测试策略的唯一考虑因素。

### 代码覆盖率、测试覆盖率和维护

测试的一个关键主题是覆盖率。`if` 条件、循环等至少被一个测试用例命中。

这些指标很难手动测量，实际上通常依赖于外部工具进行计算。这些工具最常用的技术是 **字节码插装**，它利用 JVM 的特殊功能来检查每行代码的执行情况，作为测试运行的结果。用于计算代码覆盖率的一些常见库，如 Cobertura 和 JaCoCo，采用类似的方法。

代码覆盖率是测试完整性的基础：必须定义一个特定的阈值，低于该阈值的覆盖率应被视为不完整的测试，尤其是在创建新功能和模块时。但代码覆盖率并不能保证所有功能都经过测试，也不能保证用于测试的数据是完整且足够变化的。因此，必须引入一个进一步的概念——**测试覆盖率**。

在我看来，测试覆盖率的计算稍微不那么**科学**。虽然代码覆盖率可以通过测试期间执行的代码行数与总代码行数的百分比来精确测量（即使需要工具），但测试覆盖率围绕许多不同的观点。以下是一些常见的观点：

+   **功能覆盖率**，即测试的功能数量与应用程序的总功能数量之比。

+   **需求覆盖率**，即有效测试的需求数量与软件实现的总需求数量之比。

+   **设备覆盖率**，尤其是在 Web 和移动应用程序中特别有意义，它与我们的应用程序测试所针对的不同配置（不同的移动设备、多个操作系统版本、多个浏览器版本等）的数量相关。

+   **数据覆盖率**，与我们的应用程序测试所针对的不同输入和配置相关。这当然是非常难以测试的，因为组合可以是无限的。另一方面，拥有多种测试输入确保了对意外行为的更好保护。

代码覆盖率和测试覆盖率都应该持续测量并可能进行改进。这意味着要覆盖添加的新功能（如果有）的代码，并检查当前软件版本中发现的错误，以便了解是否有方法提高测试覆盖率以检查未来的此类错误。客户报告在这方面特别有用。

我们大多数人对我们使用的应用程序（尤其是在移动应用程序中）的问题都很熟悉，当出现错误消息时，有机会向应用团队发送错误详情。通过这样做，应用团队有机会检查特定错误发生时的特定条件（使用的输入、使用的设备、软件版本），并可能扩展测试套件（因此，测试覆盖率）以检查类似情况，并避免未来出现此类错误。

最后但同样重要的是，了解何时运行何种类型的测试很重要。

由于运行整个测试套件（包括由人工操作员运行的验收测试）可能既昂贵又耗时，因此在不同情况下运行不同的测试套件是一种常见的做法。如果我们正在修复一个小的错误或添加一个小功能，那么我们可能可以承担不测试整个应用程序的风险，而只测试一个子集。

然而，随着测试自动化变得越来越普遍，以及云提供的可丢弃测试环境，建议尽可能多地测试，特别是性能测试。这样，将更容易理解我们正在测试的发布版本是否引入了任何性能问题。这种概念，如果推向极致，被称为**持续测试**，基本上意味着在每次代码或配置更改（即使是微小的更改）之后，以自动化的方式运行完整的测试套件。

在本节中，我们已经看到了不同测试技术和阶段的全貌。从单元测试开始，我们还探讨了集成、端到端和性能测试。

在下一节中，我们将讨论一个与测试（连续且相互依赖）相关的步骤：部署。

# 部署

**软件部署**是一个非常广泛的概念，可以广泛地用来指代整个软件生命周期，从开发到发布到生产。然而，在这个特定的上下文中，我指的是部署阶段，即软件被编译和适当地打包，并应用了正确的配置。然后，软件假定将被运行并准备好供用户访问（这是发布过程的一部分；在接下来的几节中将有更多介绍）。虽然我们已经在本书中提到了一些这些主题，但我希望强调其中的一些，这对本章的目的很有用。

## 构建代码

构建代码的阶段，即编译和打包成可部署的工件（在 Java 的情况下为`.jar`、`.war`和`.ear`），是由 JDK 附带的一些实用工具完成的（特别是`javac`工具）。

然而，此过程通常至少包括依赖项的管理，但在现实世界中，可能还会涉及许多其他步骤，例如代码格式化、资源或配置文件的解析，以及单元测试的执行（如之前所见）。

执行所有这些步骤的一个广泛使用的技术，在本书中多次提及和使用，是 Apache Maven。

虽然我假设你们大多数人已经知道并使用过 Maven，但我认为从架构师的角度来看，强调一些有用的特性是相关的：

+   Maven 使用一种标准方式（`pom.xml`文件）来定义关于构建软件的指令。实际上，`pom`文件收集了依赖项列表（包括仅用于测试目的的依赖项和仅用于开发时间的依赖项）。它还可以指定编译和打包软件所需的步骤，并为每个步骤提供一些配置。

+   它提供了一个基于插件的扩展性系统。因此，您可以找到（或实现）不同的插件，以运行测试、创建文档、生成代码，以及其他在部署时可能有用的步骤。

+   它可以定义不同项目之间的层次结构，并通过设置所谓的`GroupId`（基本上是项目的命名空间或包）、`ArtifactId`（项目的标识名称）和版本来为每个软件工件（也称为 Maven 工件）提供一种唯一的方式来识别。

正如所说，Maven 基本上是 Java 世界中的标准构建技术，尽管它不是唯一的。**Ant**是另一种曾经广泛使用的选项，它更类似于脚本且灵活性较低。由于其冗长性和依赖管理中的许多缺点，它已经被逐渐放弃。

`pom.xml`配置文件）。让我们快速概述一下这个概念。

## 管理工件

软件工件至关重要，既是构建更大组件（作为依赖项）的一部分，也可以直接部署（例如，到生产环境）。虽然可以直接在文件系统文件夹中管理此类内容（在 Java 世界中基本上是`.jar`、`.ear`和`.war`文件），但在优化系统中这样做会更好。这样的系统被称为**工件存储库**。

工件存储库通常提供许多高级功能，包括以下内容：

+   **Web 界面**，简化对工件及其管理的搜索。

+   **基于角色的访问控制和认证访问**，为不同的工件提供差异化的访问。一个常见的例子是，某些工件只能由特定组更改，而其他工件可能只能以只读模式访问，也许还有其他完全无权访问。

+   其他**安全功能**，例如检查代码中已知漏洞（正如我们在*第十二章*，*横切关注点*，讨论安全问题时所看到的）。

+   **依赖项的版本控制**，包括在可配置策略下清理旧版本。

+   **镜像和层次结构**，通过提供通过互联网查询其他工件存储库以查找本地不可用的依赖项的可能性，然后镜像以避免在不需要时下载。互联网上可用的一个非常著名的存储库是**Maven Central**。

Maven 工件存储库的两个非常著名的实现是 JFrog Artifactory 和 Sonatype Nexus。

值得注意的是，容器技术（如在第*第九章*，*设计云原生架构*中讨论的）通常被视为 Java 工件的一个扩展（但不是替代品）。确实，容器镜像包含一个完整的应用程序组件，包括在需要 JVM 和其他中间件的操作系统的级别的依赖项。此外，容器镜像是不可变的，并且可以通过版本和签名唯一标识，因此它与 Java 工件非常相似，并在管理方面提出了类似的需求。

因此，关于 Java 工件仓库提出的思想可以扩展到容器仓库。提到提到的技术（Artifactory 和 Nexus）都有用于处理容器的扩展，这并非偶然。

在线可用的流行容器仓库包括 Docker Hub 和 Quay.io。

## 完成部署

正如我们所看到的，代码编译和工件管理之后，现在是时候完成部署了。这可能包括不同的步骤，最终目的是将工件安装到正确的位置，执行一些配置，并运行软件。这些步骤的细节可能因所使用的技术而大大不同：

+   在传统的 Java 世界中，根据所使用的应用程序服务器（如第七章中提到的 WildFly，见*第七章*，*探索中间件和框架*），有自定义的方式来使用 Java 应用程序服务器。常见的方法是将应用程序工件复制到特定文件夹或调用命令行实用程序以触发部署过程。可能还需要更多配置步骤（如数据库连接），通常涉及配置文件的更改或发出的命令。

+   当在非容器化环境中使用胖`.jar`应用程序（如 Spring Boot 或 Quarkus）时，部署过程通常仅涉及将胖`.jar`文件复制到指定位置并使用命令运行它。这可以通过 shell 脚本完成，然后可以处理其他相关步骤，例如清理旧版本和配置文件的更改。

+   在容器化环境中，部署基本上涉及复制容器（Kubernetes 和 Docker 通常配置为访问远程容器仓库）并执行一系列命令以使其运行。在 Kubernetes 中，这几乎完全是通过使用`kubectl`来完成的。

正如我们所看到的，不同的技术需要略微不同的方式来完成部署并有效地分发和运行软件包。如果你考虑可能需要更多步骤，包括配置外部系统（如数据库和 IaaS 或 PaaS 系统），那么以统一的方式编排这些步骤通常是一个好主意。这是 CI/CD 的一个特点。

# 持续集成/持续交付（和部署）

CI/CD 是一个自动化大多数已看到的步骤（有时还有一些更多）的过程，以便简化流程并全面了解它。由于该过程包括许多以大部分顺序执行步骤，因此提供该工具的工具通常被称为**管道**。

典型的 CI 管道包括以下步骤，通常按顺序执行：

1.  构建代码（如前几节所示）。

1.  测试，通常限于静态代码测试、单元测试和一些有限的集成测试。由于尚未部署，此阶段无法进行端到端测试。

CD 包括一些针对部署的进一步步骤（在这种情况下，通常按顺序执行）：

1.  在存储库中对软件工件进行版本控制。

1.  将存储库中的工件部署到测试环境，包括所有必要的配置。这可以在短暂的（如前几节所见）环境中完成。

1.  在此类环境中进行端到端测试。

1.  在其他非生产环境中部署，目的是用户验收和/或性能测试。

这里是一个简化的示例管道：

![Figure 13.5 – 一个示例管道]

![img/Figure_13.05_B16354.jpg]

图 13.5 – 一个示例管道

在前面的图中，你可以看到一个简化的管道示例。有几个步骤（**自动化测试**和**工件存档**）是并行执行的。此外，在**预发布部署**和**生产部署**之间，可能发生一些操作，例如 UAT 和手动批准。

CD 被视为管道的进一步扩展，基本上包括在生产环境中部署环境。这可能完全自动化（无需人工干预），或者可能需要发布经理的手动批准（在更传统的环境中）。

当然，任何步骤的失败通常意味着管道停止，发布失败。也值得注意，生产环境中的部署并不一定意味着软件已发布并可供用户使用，正如我们很快就会看到的那样。但首先，值得看看广泛使用的管道实现。

## 常见的 CI/CD 软件实现

在不提及 Jenkins 的情况下几乎不可能谈论 CI/CD。

Jenkins 是一个完整的自动化服务器，基本上是 CI/CD 管道的同义词。

它是用 Java 编写的，并在 servlet 容器（通常是 Tomcat）中部署。在 Jenkins 中可以使用领域特定语言定义管道，该语言用所需的参数描述每个步骤。通过插件系统，Jenkins 中的步骤可以执行许多不同的事情，包括使用 Maven 进行编译、执行 SSH 命令和执行测试套件。

然后，Jenkins 可以显示管道执行结果，归档它们，并可选地发送通知（例如，在构建失败的情况下）。

虽然仍然被广泛使用，但现在的 Jenkins 以其单体架构（尽管某些步骤可以委托给代理）和资源密集型而闻名。

尝试创建具有更现代设计和在云环境中表现更佳的替代管道软件正在进行中。其中最著名的是 Jenkins X 和 Tekton。

这两种软件类型，虽然使用不同的语言和框架创建，但都共享在容器中实现每个步骤的概念，从而提高了横向扩展和可重用性。

其他著名的 CI/CD 能力实现包括 Travis、GitLab，以及最近的一些云替代方案，如 GitHub Actions。

正如我们所说的，无论实现方式如何，CI/CD 过程都可以自动化步骤直到生产部署。然而，为了使软件可供最终用户使用，该过程需要一些最终步骤。

# 发布

**发布**通常是完整 CI/CD 管道的最后一步。在简单环境中，该过程可以与生产部署一起执行。

然而，如今，将部署和发布分成两个不同的步骤是很常见的，这允许更复杂（并且通常更安全）的方式向最终用户发布软件版本。要做到这一点，最基本的成分是在生产环境中同时提供软件的不同版本，并通过不同的标准将用户路由到每个版本（这是通过在网络级别操作完成的，将每个请求路由到所需的目标版本）。让我们看看这种技术带来的某些场景：

+   **蓝绿部署**：在生产环境中发布两个版本的生成环境（包括数据库和其他外部系统）。这包括我们想要发布的版本（标识为蓝色或绿色）和上一个版本（通过颜色标识，因此是绿色或蓝色）。然后可以在真实环境中测试候选发布版本。如果一切按预期工作，则网络流量随后被路由到新版本。任何时间都可以轻松回滚。在下一个版本中，执行相同的操作，用下一个版本替换上一个版本，并更改颜色编码。以下图表说明了这一点：

![图 13.6 – 蓝绿部署](img/Figure_13.06_B16354.jpg)

图 13.6 – 蓝绿部署

+   **滚动发布**：这意味着我们的应用程序组件在一组相同的实例上提供（托管在 VM 或容器上）。当发布发生时，**新版本**被安装在一个新实例上，并且流量也开始发送到这些新实例。然后，关闭一个**旧实例**（可选地排空所有挂起的连接）。这个过程会一直进行，直到所有实例都在新版本上运行，如图所示：

![图 13.7 – 滚动发布](img/Figure_13.07_B16354.jpg)

图 13.7 – 滚动发布

在前面的图表中，每个*圆圈*代表一个实例（例如 VM 或应用程序实例）。这两个步骤被表示为一个示例，但你可以想象**新版本**从一个实例开始，增加到两个，依此类推，而**旧版本**则是逐个实例逐步关闭。

虽然这可能与蓝绿部署有细微的差别，但滚动发布可以被看作是一种旨在减少发布中断时间的技术技巧，但如果需要回滚，它提供的保证较少。此外，由于旧实例和新实例共存一段时间，可能会在应用程序和外部系统（如数据库）上出现问题。

+   **金丝雀发布**：基本上，这是蓝绿部署的一种变体。新版本仍然与旧版本一起提供，但不是整个流量切换，而是逐步进行，例如路由 1%的用户，然后是 2%，依此类推，直到所有用户都在运行新版本。这种技术允许更平滑的发布，并使得在存在问题时（可选地回滚）更容易识别，而不影响整个客户群，如图所示：

![图 13.8 – 金丝雀发布](img/Figure_13.08_B16354.jpg)

图 13.8 – 金丝雀发布

在前面的图中，我们可以看到仅有的两个示例阶段，其中我们开始将**90%**的流量路由到**旧版本**，**10%**路由到**新版本**，还有一个表示将**1%**的流量路由到**旧版本**和**99%**的流量路由到**新版本**。当然，在实际情况中，你可以想象流量从 1%到 100%以及相反方向的持续流动。*金丝雀*这个名字指的是矿工用来识别气体泄漏的金丝雀。以类似的方式，通过一小部分用户可以更早地识别出 bug，并且可以在影响更多用户之前停止发布。

+   **A/B 测试**：技术上，这与蓝绿部署相同。最重要的区别在于，在这种情况下，我们正在评估两个替代版本。这两个版本不应被视为前一个和下一个，而应被视为业务想要对真实用户进行测试的同一软件的两个略有不同的变体。以下图表展示了这一点：

![图 13.9 – A/B 测试](img/Figure_13.09_B16354.jpg)

图 13.9 – A/B 测试

这样的变体通常是用户界面或其他功能的小幅改动，业务的目标是衡量这些改动在现实世界中的表现。最常见的例子是在在线商店中，业务愿意检查购买过程（颜色、按钮位置和步骤数量）的改动是否提高了商业性能。

在 A/B 测试中，通常性能较差的版本会被丢弃。也值得注意，路由到每个版本的用户的选取可以是随机的，按百分比分配（例如每个版本 50%），或者根据特定标准（如果可用）选择，例如用户的地理位置或年龄。

+   **流量影子化**：这种做法比其他替代方案要少一些。它意味着软件的新版本在生产环境中发布，而用户继续使用旧版本，同时新版本获取所有生产流量：

![图 13.10 – 流量影子化![图 13.10 – 流量影子化](img/Figure_13.10_B16354.jpg)

图 13.10 – 流量影子化

在重大版本发布的情况下，这对于负载测试非常有用，但在某些特定场景中可能不起作用，了解任何特定用例的影响是必要的。例如，如果发送通知（如通过电子邮件），我们应该确保它们不是由旧系统和新系统同时发送，以最小化对用户的影响。

值得注意的是，这些类型的发布技术（尤其是简单的那些）并不是什么新鲜事，在现代云和微服务架构出现之前就已经可能了。然而，要在传统环境中使用它们，可能需要与外部团队（如管理网络的团队）协调，而现代架构（如基于公共云、IaaS 或 PaaS 的架构）提供了更多的灵活性，允许动态创建新实例，并改变软件定义网络偏好的网络配置。在下一节中，我们将通过查看有关软件维护的一些考虑因素来完善我们对软件生命周期的看法。

# 维护

**软件维护**通常是软件生命周期的重要组成部分。在我的专业经验中，一个项目在几年内完全活跃（有很多新功能和开发发生）后，接着是多年的维护，重点是修复错误并保持产品活力（不发布任何新功能）。

毫无疑问，维护期可能比项目构建更昂贵。此外，但这是一个纯粹从经济角度的考虑，企业往往发现更容易获得构建新应用程序的预算（这被视为盈利或至少与业务倡议相关），而不是维护和现代化旧应用程序（这被视为 IT 为 IT，这意味着这是一个没有业务影响的项目，因此，纯粹是成本）。

话虽如此，对现有应用程序的维护活动可以大致分为以下几种类型：

+   **错误修复**解决软件中的缺陷，这些缺陷可能是代码中的现有问题，或者由于外部不可预见的情况导致代码表现不佳。

+   **增强请求**（**RFEs**），它们针对的是覆盖最初未计划的新用例。

当然，这两种类型的活动都可能产生影响和努力，这可能有助于确定实施优先级。

软件维护过程随后进一步分为四种类型，独立于前两种类型：

+   **纠正性维护**，这是对发生的问题和报告的问题的反应而必须执行的操作。想想看，一个经典的错误修复活动就是应用程序行为不正确的结果。

+   **适应性维护**，旨在使软件在变化的环境中正确运行。想想看，应用程序需要适应 JVM 的新版本，或者适应新浏览器的发布。

+   **完善性维护**，旨在使我们的应用程序在性能、资源使用、可维护性或其他增强（如更好的用户体验）方面变得更好。这通常被忽视，因为它是一种主动活动，而且如果未执行，短期内通常不会发生任何事情。然而，它可能产生巨大的积极影响（在节省方面也是如此），因为它当然可以预防未来的问题。此外，避免完善性维护可能意味着所谓的*技术债务*会不断增加，这意味着越来越多的任务（如微调、重构和增强测试覆盖率）会积累起来，变得越来越难以管理（并且处理成本越来越高）。

+   **预防性维护**，这实际上与上一个类似，但围绕的是在这些问题（如已知的错误）成为实际问题之前修复它们。根据前面的观点，如果处理不当，它可能会被忽视，并可能导致技术债务。

除了有直接成本（因为有人需要做）之外，所有维护类别都可能有多重影响。实际上，这些活动通常涉及软件发布或配置更改，这可能会影响应用程序的可用性（并对建立的**服务水平协议**（**SLA**）产生负面影响）。甚至可能有法律协议将维护活动限制在明确的时间框架内，或者只允许解决高严重性问题。

此外，软件维护可能产生间接影响，因为活动（包括增强和错误修复）可能会改变应用程序的行为，在某些情况下，甚至会使 API 暴露，因此，迫使用户适应这些变化或开发者计划实现向后兼容性。

话虽如此，应用程序维护绝不能被忽视。相反，它应该从项目的开始就进行规划（并融资），并且随着时间的推移不断进行调整。确实，一个维护不当的项目可能会引起安全问题或客户不满，或者简单地失去市场吸引力。这将使所有为设计和实施项目所做的努力都化为乌有。

这是本章的最后一个主题。现在让我们看看我们学到了什么的一个总结。

# 摘要

在本章中，我们概述了软件生命周期许多关键阶段。

从 SCM 开始，我们简要讨论了 Git，它是 SCM 的事实标准。这使得我们能够理解开发模型，重点关注基于主干的开发，这在 CI/CD 和基于 DevOps 的项目中很常见。

我们还简要讨论了语义版本化，这是一种根据发布版本号来识别预期变更的方法。

然后，我们进入了测试阶段，从单元测试开始（以及 JUnit 的不可避免描述，它是 Java 测试的标准）。从单元测试，我们转向其他测试技术，包括集成、端到端和 UAT。

部署是下一步。我们讨论了编译软件和运行软件所需的步骤，包括 Apache Maven 和工件管理的概述。下一个主题是 CI/CD 和管道，其中考虑了自动化本章中看到的多数步骤。

然后，我们专注于发布过程，这个过程是将部署的软件提供给最终用户，我们看到了许多不同的选项，包括蓝绿发布和金丝雀发布。最后但同样重要的是，我们对维护活动（包括错误修复和增强）进行了概述，并说明了为什么它们对我们项目的整体成功至关重要。

在下一章中，我们将讨论监控和跟踪，这些是确保我们的软件在生产中表现良好的核心概念，并且能够持续理解和控制正在发生的事情。

# 进一步阅读

+   Richard E. Silverman: *Git 口袋指南*

+   Konrad Gadzinowski: *基于主干开发与 Git Flow 对比* ([`www.toptal.com/software/trunk-based-development-git-flow`](https://www.toptal.com/software/trunk-based-development-git-flow))

+   Hardik Shah: *为什么测试覆盖率是软件测试的重要部分？* ([`www.simform.com/blog/test-coverage/`](https://www.simform.com/blog/test-coverage/))

+   Himanshu Sheth: *代码覆盖率与测试覆盖率——哪个更好？* ([`dzone.com/articles/code-coverage-vs-test-coverage-which-is-better`](https://dzone.com/articles/code-coverage-vs-test-coverage-which-is-better))

+   Sten Pittet: *持续集成与持续交付与持续部署对比* ([`www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment`](https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment))

+   Michael T. Nygard: *发布它！设计和部署生产就绪软件*

+   Martin Fowler: *蓝绿部署* ([`martinfowler.com/bliki/BlueGreenDeployment.html`](https://martinfowler.com/bliki/BlueGreenDeployment.html))
