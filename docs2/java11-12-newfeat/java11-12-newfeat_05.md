# JDK 10 的其他改进

在 Java 9 之前，Java 的新版本每三年（平均）发布一次。Java 9 的发布时间表发生了变化，采用了六个月的发布周期。Java 10 在 Java 9 发布后的六个月内发布。我们已经在前三章中介绍了 Java 10 的主要功能；第一章，*类型推断*，第二章，*AppCDS*，和第三章，*垃圾收集器优化*。

在本章中，我们将涵盖 Java 10 剩余的添加或更新，其中大部分与 JDK 或其实现的变化有关。我们还将涵盖对 Java API 的一些添加和修改。

在本章中，我们将涵盖以下主题：

+   线程局部握手

+   基于时间的发布版本号

+   将 JDK 森林合并为一个单一存储库

+   在替代内存设备上进行堆分配

+   额外的 Unicode 语言标记扩展

+   根证书

+   基于实验性 Java 的 JIT 编译器

+   移除原生头生成工具

# 技术要求

本章将概述与 JDK 或其实现相关的 JDK 10 功能。本章将不包括任何供您使用的代码。

由于本章涵盖了 Java 10 的多个功能，让我们快速将功能与其**JDK 增强提案**（**JEP**）编号和范围进行关联。

# 将 JDK 10 功能与范围和 JEP 关联

下表列出了本章将涵盖的 JDK 10 功能，功能的对应 JEP 编号以及它们的范围：

| **JEP No.** | **Scope** | **Description** |
| --- | --- | --- |
| 296 | 实现 | 将 JDK 森林合并为一个单一存储库 |
| 312 | JDK | 线程局部握手 |
| 313 | JDK | 移除原生头生成工具(`javah`) |
| 314 | SE | 额外的 Unicode 语言标记扩展 |
| 316 | JDK | 在替代内存设备上进行堆分配 |
| 317 | JDK | 基于实验性 Java 的 JIT 编译器 |
| 319 | JDK | 根证书 |
| 322 | SE | 基于时间的发布版本号 |

让我们从第一个功能开始。

# 将 JDK 森林合并为一个单一存储库

到 Java 9 为止，JDK 的代码库使用了多个存储库（Java 9 中有八个存储库——`root`，`corba`，`hotspot`，`jaxp`，`jaxws`，`jdk`，`langtools`和`nashorn`）。合并 JDK 森林的目标是将 JDK 使用的多个存储库合并为一个单一存储库。

随着 JDK 代码库多年来的增长，它故意存储在单独的存储库中，以实现关注点的分离。然而，随着 JDK 的发展，代码库在不同存储库之间也发展出了相互依赖性。

这些多个仓库提供的优势已经超过了它们的维护劣势。对于相互依赖的变更集，你无法对仓库执行单个提交。有些情况下，即使是单个（且简单的）错误修复的代码也跨越了多个仓库。在这种情况下，提交无法原子化执行。一种常见的方法是在多个仓库中使用相同的 bug ID。但这并不是强制性的，因为使用相同的 bug ID 不是强制性的，不同仓库中相同 bug 的提交可以使用不同的 bug ID。这可能导致跟踪错误修复的困难。

此外，各个仓库没有独立的发展轨道和发布周期。Java 有一个主要的发布周期，包括所有这些仓库的变化。因此，将 JDK 代码库集成到一个仓库中，以简化其维护，已经势在必行。

这是一个维护功能，不会影响你编写代码的方式。

# Thread-local handshakes

假设你需要暂停一个特定的线程，并在其上执行回调。在 thread-local handshakes 之前，没有方法可以做到这一点。通常的做法是执行全局 VM safepoint，这将暂停所有正在执行的线程（如果你只想暂停一个线程，这无疑是一种浪费）。有了 thread-local handshakes，可以停止单个线程。

通过旨在减少全局 VM safepoints，thread-local handshakes 将减少 JVM 延迟并提高其效率。

Thread-local handshakes 是 JVM 实现的一个特性，开发者不能直接使用。

# 移除 Native-Header 生成工具（javah）

JEP 的这个版本已经从 JDK 附带工具中移除了`javah`工具。

假设你需要你的类的实例在 C 的本地代码中被引用。开发者们使用`javah`工具从 Java 类生成 C 的头文件和源文件。生成的代码用于使本地代码（比如用 C 编写的代码）能够访问你的 Java 类的实例。`javah`工具创建一个`.h`文件，它定义了一个`struct`，类似于你的类的结构。对于源文件中的多个类，`javah`工具会生成单独的`.h`文件。

移除`javah`并不意味着你的 Java 类在本地代码中的使用量有所下降。

在 Java 8 中，`javah`被增强以承担生成 C 头文件和源代码文件的责任。经过两个版本的测试后，`javah`将从 Java SE 10 中移除。

`javah`工具的移除由`javac`中的高级编译选项所补偿，这些选项可以用来生成 C 头文件和源文件。

# 额外的 Unicode 语言标签扩展

此功能增强了`java.util.Locale`及其相关 API，以实现 BCP 47 语言标签的附加 Unicode 扩展。对 BCP 47 语言的支持添加到了 JDK 7。然而，在 JDK 7 中，对 Unicode 区域扩展的支持仅限于日历和数字。此功能允许向区域添加扩展。JDK 9 添加了对`ca`和`nu`标签的支持，这些标签来自 BCP 47。

JDK 10 添加了对以下扩展的支持：

+   `cu`（货币类型）

+   `fw`（一周的第一天）

+   `rg`（区域覆盖）

当你指定一个区域扩展，如数字或货币类型时，并不能保证底层平台支持所请求的扩展。Unicode 标签扩展是一种语言特性，开发者可以直接使用。

# 在替代内存设备上的堆分配

当 JVM 耗尽其堆内存时，你的应用程序会因`OutOfMemoryException`而崩溃。想象一下，如果你能配置你的 JVM 使用替代内存设备，比如一个**非易失性双列内存模块**（**NV-DIMM**）。

随着处理大量数据的应用程序对内存需求的不断增长，以及低成本 NV-DIMM 内存的可用性，能够使用替代内存设备进行堆分配是一种幸福。这也导致了使用异构内存架构的系统。

此增强针对具有与**动态随机存取存储器**（**DRAM**）相同语义的替代内存设备，以便它们可以替代 DRAM 使用，而无需对现有应用程序代码进行任何更改。所有其他内存结构，如栈、代码堆等，将继续使用 DRAM。

在我们继续前进之前的一个快速细节——NV-DIMM 与 DRAM 相比，访问延迟更高。但与 DRAM 相比，NV-DIMM 具有更大的容量且成本更低。因此，低优先级的过程可以使用 NV-DIMM，而高优先级的过程可以使用 DRAM 内存。

堆分配是 JVM 实现细节，开发者不能直接使用。

# 实验性的基于 Java 的 JIT 编译器

你至今所使用的 Java 编译器通常是用 C/C++编写的。你会怎么想一个用 Java 编写的 Java 编译器？

Graal，一个基于 Java 的**即时编译器**（**JIT**），在 Java 9 中引入。Java 10 使 Linux/x64 平台上的 Graal 作为实验性 JIT 编译器可用。最终，Oracle 将探索使用 Graal 作为基于 Java 的 JIT 编译器用于 JDK 的可能性。

Graal 使用 JDK 9 中引入的 JVM 编译器接口。Graal 的目标不是与现有的 JIT 编译器竞争。它是 Metropolis 项目的一部分，该项目探索和孵化 HotSpot（JVM 的开放 JDK 实现）的 Java-on-Java 实现技术。

由于 Graal 是用 Java 编写的，使用 Graal 的担忧与应用程序较低的启动性能和增加的堆使用量有关。

以下命令行编译器选项可用于启用 Graal 作为您的 JIT 编译器：

```java
-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler
```

Graal 是一个实验性的 JIT 编译器，可以通过命令行选项进行配置以供使用。

# 根证书

想象一下在云存储服务提供商上配置一个账户，使用您的系统。云接口可以请求证书及其值存储在您的系统中。当重新连接到云服务时，您的系统会自动使用证书对其进行身份验证。

使用 JDK，此类证书存储在 `cacerts` 密钥库中。证书文件 `cacerts` 位于 JDK 安装目录的安全目录中，代表适用于系统级密钥库的 **认证机构**（**CA**）证书，如下所示：

+   Windows：`JAVA_HOME\lib\security`

+   Linux、Solaris 和 macOS X：`JAVA_HOME/lib/security`

根证书用于在各个安全协议中建立对证书链的信任。问题是 `cacerts` 密钥库在 JDK 源代码中没有任何证书，这对于 OpenJDK 构建中安全组件（如 TLS）的默认功能是必需的。

使用根证书，Oracle 计划弥合 OpenJDK 构建与 OracleJDK 构建之间的差距。用户必须将一组根证书填充到 `cacerts` 密钥库中，以弥合这一差距。

计划在 JDK 中提供一组默认的根 CA 证书，并将 Oracle 的 Java SE Root CA 程序中的根证书开源。

根证书可以由 Oracle 的 Java SE Root CA 程序的 CA 发布。

根证书是 JDK 的一个功能。

# 基于时间的发布版本控制

基于时间的发布版本控制功能修订了 JDK SE 平台的版本字符串方案，适用于当前和未来的基于时间的发布版本。

建议的格式如下：

```java
$FEATURE.$INTERIM.$UPDATE.$PATCH
```

以下是在前述字符串中使用的元素详情：

+   `$FEATURE`：由于新的（且严格的）六个月发布节奏，此值每六个月增加一次。2018 年 3 月发布的 JDK 版本是 10，2018 年 9 月发布的版本是 JDK 11。2019 年 3 月发布了 JDK 12，以此类推。

+   `$INTERIM`：由于六个月一次的发布节奏，没有临时发布。然而，此元素保留以供未来潜在的使用场景。

+   `$UPDATE`：此元素表示更新，用于兼容更新发布，以修复安全漏洞、回归和新功能中的错误。此值在 `$FEATURE` 增量后一个月增加，之后每三个月增加一次。

+   `$PATCH`：此元素表示紧急补丁发布计数器，用于针对关键错误的紧急发布。

# 摘要

在本章中，您浏览了 JDK 10 的各种新增和修改，但排除了其主特性，如类型推断、应用程序类数据共享和垃圾收集器优化。

本章中介绍的大部分功能都与 JDK 的变化有关，包括通过线程局部握手减少全局 VM 安全点、移除 `javah`、使用替代内存设备进行堆分配、Graal 和根证书。它包含较少的 SE 功能——额外的 Unicode 语言标签扩展和基于时间的发布版本编号。将 JDK 森林合并为单个存储库更多是一个日常维护细节。

在下一章中，我们将探讨 JDK 11 的新增功能和修改。我非常兴奋，也希望你们也是一样！
