# JDK 12 中的其他改进

Java 12 是 Oracle 发布的最新 **短期支持**（**STS**）版本。然而，行业仍在逐渐接受迁移到 Oracle 的最新 **长期支持**（**LTS**）Java 版本，即 Java 11。

JDK 12 中的显著特性是 Shenandoah 垃圾回收器和 `switch` 表达式的添加。我们在第十一章 Switch Expressions 中介绍了 `switch` 表达式。由于对 Shenandoah 垃圾回收器的详细覆盖超出了本书的范围，我在本章中介绍了它，包括对 Java 12 的剩余添加和更新。

在本章中，我们将涵盖以下主题：

+   Shenandoah – 一种低暂停时间的垃圾回收器

+   微基准测试套件

+   **Java 虚拟机**（**JVM**）常量 API

+   一个 AArch64 端口，而不是两个

+   默认 CDS 归档

+   G1 可中止的混合收集

+   G1 及时返回未使用的已提交内存

# 技术要求

要使用本章中包含的功能，您应该在您的系统上安装 JDK 12 或更高版本。

由于本章涵盖了 Java 12 中的多个功能，让我们快速将功能与其 **JDK 增强提案**（**JEP**）编号和范围进行映射。

# 映射 JDK 12 范围和 JEP 的功能

下表列出了本章中涵盖的 JDK 12 功能、它们对应的 JEP 编号和它们的范围：

| **JEP** | **范围** | **描述** |
| --- | --- | --- |
| 189 | 实现 | Shenandoah – 一种低暂停时间的垃圾回收器 |
| 230 | JDK | 微基准测试套件 |
| 334 | SE | JVM 常量 API |
| 340 | JDK | 一个 AArch64 端口，而不是两个 |
| 341 | JDK | 默认 CDS 归档 |
| 344 | 实现 | G1 可中止的混合收集 |
| 346 | 实现 | G1 及时返回未使用的已提交内存 |

让我们从第一个功能开始。

# Shenandoah – 一种低暂停时间的垃圾回收器

由 Red Hat 的工程师提出并开发，Shenandoah 垃圾回收器承诺具有显著低的暂停时间。它是一种基于区域的垃圾回收器，以并行和并发的方式收集垃圾。值得注意的是，暂停时间与应用程序的存活数据无关。

随着硬件工程和成本的降低，服务器比以往任何时候都有更多的内存和计算能力。现代应用程序越来越需要更低的暂停时间——对于保证 10 到 500 毫秒响应时间的 **服务级别协议**（**SLA**）应用程序。为了满足这个范围的低端，垃圾回收器应该能够完成多个任务，包括以下内容：

+   使用能够使程序在给定内存上执行的算法

+   保持暂停时间低（即低于 10 毫秒）

这是否可行，比如说，一个使用 200 GB 内存的 Java 应用程序？使用压缩算法是不可能的，即使是压缩 10%的内存，也会超过 10 毫秒的限制。Shenandoah 使用了一种算法，在 Java 线程运行的同时并发压缩内存。在这种情况下，对象在并发 GC 周期中移动，并且所有引用对象都立即访问新的副本。

并发压缩并不简单。当 GC 移动一个活动对象时，它必须**原子性地**更新所有指向该对象的引用，指向新对象。然而，为了找到所有引用，整个堆都应该被扫描；这听起来不可行。为了解决这个问题，Shenandoah GC 为每个对象添加了一个**转发指针**，每次使用该对象时都会通过该指针。这简化了移动对象的过程。Shenandoah GC 线程或应用程序线程可以复制一个对象并使用比较和交换来更新转发指针。在竞争的情况下，只有一个比较和交换会成功。通过添加转发指针，Shenandoah GC 比其他 GC 算法使用更多的空间。

每个 Shenandoah GC 周期由四个阶段组成。Shenandoah GC 周期从**初始标记**开始，此时它会**停止世界**并扫描根集。在第二阶段，即**并发标记**阶段，它会并发地标记活动对象并更新引用。在第三阶段，**最终标记**阶段，它会**停止世界**并再次扫描根集，复制并更新根集到更新的副本。最后一个阶段，**并发压缩**，将活动对象从目标区域中移除。

Shenandoah 是基于区域的 GC。它不是一个关注收集最年轻对象的代际 GC。这是基于这样一个假设：大多数对象都是年轻时死亡的。然而，具有缓存的应用程序会长时间保留对象，因此代际 GC 算法无法与它们一起工作。为了解决这个问题，Shenandoah 使用了**最近最少使用**（**LRU**）缓存基准测试，这使得它能够保持其暂停时间很低。

Shenandoah 永远不会压缩巨型对象（即无法适应一个区域且需要多个区域的对象）。如果 Shenandoah GC 周期确定一个巨型对象不再活动，其区域将立即被回收。

Shenandoah GC 的主要目标是通过降低 GC 周期的数量和持续时间来提高 JVM 的响应性。

# 微基准测试套件

基于**Java Microbenchmark Harness**（**JMH**），此功能向 JDK 源代码添加了一组基本的微基准测试，以下为建议的目录结构：

```java
jdk/jdk
    .../make/test
    .../test
       .../micro/org/openjdk/bench
           .../java
                .../vm
```

由于微基准测试套件将位于 JDK 源代码中，这将使开发者更容易定位和运行现有的微基准测试，并创建新的测试。当现有功能被更新或从 JDK 版本中删除时，更新微基准测试将变得简单。此外，当开发者运行微基准测试时，他们可以使用 JMH 强大的过滤功能来运行选定的基准测试。

尽管微基准测试套件及其构建将与 JDK 及其构建系统集成，但它将有一个单独的目标。开发者需要指定额外的参数来执行它，以保持正常 JDK 的构建时间低。

如其名所示，通过基准测试，你可以比较构建或发布版本。因此，微基准测试支持新 JDK 的 JDK (*N*) 和旧版本的 JDK (*N-1*)。基准测试依赖于 JMH，就像单元测试依赖于 TestNG 或`jtreg`一样。JMH 在构建过程中使用，并被打包为结果 JAR 文件的一部分。

# JVM 常量 API

这个 JEP 引入了一个 API 来标准化类常量的描述和加载。

每个 Java 类都有一个常量池。它存储简单的值，如字符串和整数，或者表示类或方法的值。类常量池值用作**ldc**（**加载常量**）字节码指令的操作数值。这些常量也可以由**invokedynamic**字节码指令使用——在启动方法的静态参数列表中。

当执行 ldc 或 invokedynamic 指令时，它将常量值表示为 Java 数据类型值、一个类、一个整数或一个字符串。到目前为止，建模字节码指令和加载常量的责任在于想要操作类文件的类。这通常会使这些类的业务逻辑焦点转移到如何建模字节码指令和加载类常量的具体细节上。这显然是一个很好的候选者，可以将关注点分离并定义用于处理*如何*部分的 API。

此外，类本身实现此功能并不容易，因为对于非字符串和非整数值，加载类常量不是一个简单的过程。类加载是一个复杂的过程，有多个故障点。类加载依赖于宿主环境，包括类的存在、访问它们的能力以及它们的相应权限。类加载也可能在链接过程中失败。

缺乏一个标准化的库来处理这些加载常量的功能，也导致了程序之间期望的不匹配。

JDK 12 定义了一个新的包，`java.lang.invoke.constant`，它定义了一组基于值的符号引用类型。它可以用来描述所有可加载的常量。符号常量使用名义形式，本质上排除了常量从其加载或可访问性上下文。该包包括如`ClassDesc`、`MethodTypeDesc`、`MethodHandleDesc`和`DynamicConstantDes`等类型来描述各种常量。数据类型如`String`、`Integer`、`Long`、`Float`和`Double`也用于表示简单的类常量。

该包有多种用途。需要解析或生成字节码的库需要以符号方式描述类和方法句柄。invokedynamic 的引导将变得更加简单，因为它们将能够与符号表示一起工作，而不是与活生生的类和方法句柄一起工作。对于编译器和离线转换器来说，描述无法加载到运行**虚拟机**（**VM**）中的类及其成员将变得更加简单。编译器插件，如注解处理器，也需要以符号术语描述使用类及其成员。

# 一个 AArch64 版本，而不是两个

直到版本 12，JDK 有两个 64 位 ARM 版本，尽管两者都产生 AArch64 实现。作为一个维护特性，这个 JEP 删除了与 64 位 ARM 平台相关的所有源代码，并保留了 64 位 ARM AArch64 版本。这将防止维护两个版本的工作重复。在这个过程中，还将从 JDK 中移除构建此版本的选择。它还将验证 32 位 ARM 版本是否按预期继续工作，并且这些更改不会影响它。

# 默认 CDS 存档

要了解 JDK 12 对 CDS 存档的增强，让我们快速回顾一下 CDS 是什么以及它如何影响您的应用程序。我在第二章，“AppCDS”中简要介绍了这一点。

# 什么是 CDS？

自 Java 8 以来，CDS 是 Oracle JVM 的一项商业功能，它有助于减少 Java 应用程序的启动时间和内存占用。当您与多个 JVM 一起工作时，这一点尤为明显。

在启动时，JVM 为执行准备环境。这包括字节码加载、验证、链接和核心类和接口的初始化。这些类和接口被整理到 JVM 的运行状态中，以便它们可以执行。它还包括方法区域和常量池。

这些核心类和接口只有在您更新 JVM 时才会改变。因此，每次您启动 JVM，它都会执行相同的步骤来为执行准备环境。想象一下，您可以将结果导出到一个文件中，该文件可以在 JVM 启动时被读取。随后的启动可以跳过加载、验证、链接和初始化的中间步骤；欢迎来到 CDS。

当你安装 JRE 时，CDS 会从系统 JAR 文件中预定义的类集合创建一个共享存档文件。在类可以使用之前，它们会被类加载器验证，这个过程适用于所有类。为了加快这个过程，安装过程将这些类加载到内部表示中，然后将该表示转储到`classes.jsa`——共享存档文件。当 JVM 启动或重启时，共享存档文件会被内存映射以节省加载这些类的过程。

当 JVM 的元数据在多个 JVM 进程之间共享时，它会导致更小的内存占用。从已填充的缓存中加载类比从磁盘加载它们更快；它们也部分经过验证。这个特性对启动新 JVM 实例的 Java 应用程序也有益。

使用 CDS 存档据报道在 JDK 11 中使基本程序（如`HelloWorld`）的应用程序启动时间减少了 30%以上。在许多 64 位平台上，这个数字甚至更高。

# 增强 CDS

经常，开发者由于疏忽而未能使用本可以提升其应用程序性能的功能——仅仅是因为遗漏了一步。或者我们应该称之为可用性问题吗？

目前，尽管 JDK 包含默认的类列表，但它可以用以下命令使用：

```java
java -Xshare:dump
```

尽管这种行为有文档记录，但开发者忽略了阅读文档，因此无法使用这个特性。

JDK 12 修改了构建过程。它在将`java -Xshare:dump`命令链接到类列表之后运行。为了确保 CDS 存档文件是 JDK 镜像的一部分，共享存档文件被放置在`lib/server`目录中。

在应用程序启动时，共享存档文件会**自动**使用，因为`-Xshare:auto`是 JDK 11 中服务器虚拟机的默认选项。所以，除非使用`-Xshare:off`选项将其明确关闭，否则开发者和应用程序将继续使用它，而无需执行任何额外的命令或设置。

CDS 包含来自核心 Java API 的预定义类和接口列表。为了包含特定的 API 或应用程序类，或者为了特定的 GC 行为，开发者可以创建并使用自定义存档文件。

# G1 的可中止混合收集

开发者越来越要求 GC 有更明确的行为。例如，你难道不希望使用一个保证其暂停时间上限的 GC 来执行你的应用程序吗？

当在 Java 12 中使用 G1 GC 时，如果混合收集超过了你指定的限制，你可以中止它们。请注意，你不能中止 G1 GC 暂停的所有类别。

混合集合包括 G1 清理的 *年轻* 和 *旧* 内存区域。分析系统选择一组区域，统称为 **集合集**，供 G1 GC 处理。在 JDK 12 之前，当集合集太大、包含太多旧区域或包含具有 *陈旧* 数据的区域时，G1 GC 可能会超过最大暂停时间。

使用 JDK 12 时，当 G1 从混合集合中收集活动对象时，它可以以增量方式执行，这样就不会超过最大暂停时间。这个过程将集合集分为强制性和可选性部分。在 G1 完成从强制性集合收集活动对象后，如果时间允许，它将收集可选集合中的对象。

# 从 G1 中及时返回未使用的已提交内存

G1 GC 的一个附加增强功能——在空闲时将 Java 堆内存返回到 **操作系统**（**OS**）。这个增强功能最有可能由用于在 JVM 上运行应用程序的容器环境数量的增加而触发。

在 Java 12 之前，G1 在两种情况下从 Java 堆中返回内存——在执行完全 GC 或在并发周期期间。然而，这两种情况都不太常见。实际上，G1 将完全 GC 作为其最后手段来释放内存。并发周期受到 Java 堆分配和占用的影响。

这种 GC 行为具有多个缺点——即使在容器环境中以高效的方式使用内存，组织也需要为内存支付更多费用，并且服务提供商未能充分利用其资源。在这个增强功能中，JVM 确定应用程序的 *空闲* 时间并将内存返回给操作系统。这很有意义，因为应用程序的使用在每周的每一天或每天的每个小时都是不同的。当组织将应用程序部署到提供资源作为服务的环境中时，这个增强功能可以节省组织大量的费用。

# 摘要

在本章中，我们浏览了 JDK 12 的各种新增和修改，但排除了其预览语言特性之一的 `switch` 表达式。

本章中涵盖的功能大多与 JDK 及其实现相关。我们涵盖了增长中的 GC 家族中最新添加的一个——Shenandoah。Shenandoah 是一个并发 GC，它承诺为现代 Java 应用程序提供超低暂停时间，无论其内存大小如何。提到的其他两个 GC 功能——G1 的可中止混合集合和从 G1 中及时返回未使用的已提交内存——也增强了现有的 G1 GC。

JVM 常量 API 引入了一个新的包和类来以符号方式表示类约束。除了简化其在库和类之间的使用外，JVM 常量 API 还将标准化常量。默认 CDS 存档提高了存档文件创建的过程。移除 AArch64 ARM 端口的源代码更多与维护相关。

在下一章中，我们将深入了解 Project Amber 的细节和特性。
