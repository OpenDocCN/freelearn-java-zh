# 前言

有时候，通过代码解决问题和表达我们的想法是具有挑战性的。在我们心中看似明显的解决方案，在别人看来可能显得过于复杂。但如果我们愿意接受新想法和观点，那就没问题，因为当我们持有坚持不懈的态度，愿意接受一切时，我们就把心思放在学习意料之外的事物上了。

我最初接触到六边形架构时，并没有预料到。

我记得在一个公司工作，那里的大部分软件都是由顾问开发的。这些人来了，交付了他们的代码，然后离开了。尽管我和我的团队试图建立特定的标准来确保我们负责的应用程序的一致性，但残酷的现实是我们需要更多的知识来正确维护我们的应用程序。鉴于系统的数量以及构建它们所采用的不同方法和架构，维护和添加新功能需要大量的工作。就在那时，一个队友告诉我关于六边形架构以及它如何帮助我们解决难以维护的软件问题。

那时候，关于六边形架构的书籍并不多。大部分资源都散布在互联网上，通过视频课程和文章解释了某人如何实现六边形架构。资源的缺乏是一个相当大的障碍，但使用能够提高软件可维护性的架构对我来说非常吸引人。因此，我继续在自己的工作中研究和实验这些想法，这最终导致我撰写了这本书的第一版。

我很幸运有机会撰写关于六边形架构这样迷人主题的第一版，现在已经是第二版了。第二版让我能够使用更近期的 Java 和 Quarkus 版本来应用六边形架构的思想。这一版保留了前一版的基本内容，同时探索了现代 Java 的新酷特性。此外，这一版还探讨了如何将六边形架构与广受赞誉的 SOLID 原则相结合，以及它与广泛使用的分层架构的关系。

将诸如端口、适配器和用例等概念与**领域驱动设计**（**DDD**）元素，如实体和价值对象相结合，提供了一本深入指南，解释了如何将这些概念组装起来，以解开使用六边形架构设计高度可变应用这一激动人心的难题。考虑到当今大多数企业开发所遵循的当代云原生实践，我们深入研究了 Quarkus，学习如何将六边形架构的思想与云原生开发相结合，这使我们能够创建适用于任何主要云提供商的企业级六边形应用程序。

因此，我鼓励你们保持持之以恒的态度，并愿意接受一切到来之物，与我一同踏上探索六边形架构这一迷人旅程。

# 本书面向的对象

这本书适合 Java 架构师和高级及中级 Java 开发者阅读。读者应具备面向对象语言原理的先验知识，并熟悉 Java 编程语言。此外，建议读者具备一定的 Java 专业经验，因为本书关注的是在 Java 企业级软件开发项目中通常会遇到的问题。

# 本书涵盖的内容

*第一章*，*为什么选择六边形架构？*，首先讨论了软件如果组织不当且缺乏良好的架构原则，虽然可能运行良好，但会存在很高的技术债务风险。随着新功能的添加，软件往往变得难以维护，因为没有共同的基础来指导功能的添加或更改。基于这个问题，本章解释了为什么六边形架构通过建立一种将业务代码与技术代码解耦的方法来帮助解决技术债务问题，允许前者在没有依赖后者的前提下进行演变。

*第二章*，*将业务规则封装在领域六边形内*，遵循领域驱动的方法，描述了领域实体是什么，它们在六边形架构中扮演什么角色，以及它们如何将业务规则和数据封装在简单的 Java POJO 中。它解释了为什么领域实体是代码中最重要的一部分，以及为什么它们不应该依赖于除其他领域实体之外的其他任何事物。最后，它解释了如何在领域实体内部使用规范设计模式实现业务规则。

*第三章*，*使用端口和用例处理行为*，涵盖了用例是什么，解释说它们用于使用接口定义软件意图，接口描述了软件可以执行的事情。然后，它解释了输入端口是什么以及实现用例接口的类，并具体说明了如何实现软件意图。它讨论了输出端口及其在抽象定义需要从软件外部获取数据的操作行为中的作用。最后，本章解释了用例和端口是如何组合成所谓的应用六边形的。

*第四章*，*创建适配器以与外部世界交互*，展示了适配器如何使软件能够与不同的技术集成。它解释说，同一个端口可以有多个适配器。绑定到输入端口的输入适配器，使应用程序能够通过不同的通信协议（如 REST、gRPC 或 WebSocket）暴露其功能。绑定到输出端口的输出适配器，允许应用程序与不同的数据源进行通信，无论是数据库还是消息队列或其他应用程序。最后，本章展示了所有适配器如何被分组在框架六边形中。

*第五章*，*探索驱动和被驱动操作的本质*，解释了驱动操作通过启动其公开的某个功能来驱动软件行为。它详细说明了驱动操作的生命周期，展示了如何通过输入适配器在框架六边形上捕获请求，然后将其传递到应用程序六边形的输入端口，直到达到领域六边形的实体。它展示了当软件需要从外部获取数据时，用例从应用程序六边形开始驱动操作，从输出端口到输出适配器，以满足用例需求。

*第六章*，*构建领域六边形*，展示了如何通过首先创建领域六边形作为 Java 模块来开始开发电信网络的拓扑库存应用程序。然后，本章展示了业务规则和数据如何映射到领域实体类和方法。业务规则以不同的算法排列，目的是实现规范设计模式。最后，它展示了如何对领域六边形进行单元测试。

*第七章*，*构建应用程序六边形*，首先将应用程序六边形添加为应用程序的第二个 Java 模块。然后，它解释了如何创建用例接口，该接口描述了软件的操作以管理网络和拓扑库存。它展示了如何通过输入端口实现用例，详细说明了代码应该如何排列。它详细说明了输出端口接口的创建及其在从外部来源获取数据中的作用。最后，它解释了如何测试应用程序六边形。

*第八章*，*构建框架六边形*，首先将框架六边形添加为应用程序的第三个 Java 模块。然后，它教你如何创建输入适配器，以及它将通过输入端口执行其操作。之后，通过实现输出端口创建输出适配器。输出适配器将展示如何从外部来源获取数据，并将其转换为在领域六边形术语中处理的数据。最后，本章解释了如何测试框架六边形。

*第九章*, *使用 Java 模块应用依赖反转*，简要介绍了 Java 模块，解释了为什么它们对于强制执行与依赖反转相关的六边形架构原则很重要。它解释说 Java 模块不允许循环依赖，因此没有方法让两个模块同时依赖于对方。你将学习如何在六边形应用程序中配置模块描述符。

*第十章*, *将 Quarkus 添加到模块化的六边形应用程序中*，简要介绍了 Quarkus 框架及其主要功能。然后，它进一步展示了如何将 Quarkus 添加到前几章中开发的六边形应用程序中。它介绍了创建一个名为 Bootstrap 的第四个模块，该模块用于启动应用程序，并用于将领域、应用程序和框架模块分组。

*第十一章*, *利用 CDI Bean 管理端口和用例*，解释了如何将已开发的端口和用例转换为 CDI Bean，利用企业 Java 在六边形架构中的力量。它首先解释了 CDI Bean 是什么，然后展示了如何在输入和输出端口上实现它们。最后，本章描述了如何调整应用程序框架测试以使用 Quarkus CDI Bean 测试功能。

*第十二章*, *使用 RESTEasy Reactive 实现输入适配器*，首先比较了用于 REST 端点的反应式和命令式方法，详细说明了为什么反应式方法表现更好。它解释了如何通过解释如何添加正确的注解和注入适当的依赖项来调用输入端口，使用 Quarkus RESTEasy Reactive 功能实现输入适配器。为了公开六边形应用程序 API，本章解释了如何添加 OpenAPI 和 Swagger UI。最后，它展示了如何使用 Quarkus 测试工具测试反应式输入端口。

*第十三章*, *使用输出适配器和 Hibernate Reactive 持久化数据*，讨论了 Hibernate Reactive 及其如何帮助 Quarkus 提供数据持久化的反应式能力。它解释了如何创建一个反应式输出适配器以将数据持久化到 MySQL 数据库。最后，它展示了如何使用 Quarkus 测试工具测试反应式输出适配器。

*第十四章*, *设置 Dockerfile 和 Kubernetes 对象以进行云部署*，解释了如何为基于 Quarkus 的六边形应用程序创建 Dockerfile。它详细解释了如何将所有模块和依赖项打包在一个单独的 Docker 镜像中。然后，它展示了如何为六边形应用程序创建 Kubernetes 对象，如 Deployment 和 Service，并在 minikube 本地 Kubernetes 集群中测试它们。

*第十五章*，*比较六边形架构与分层架构*，描述了分层架构，并探讨了层如何处理特定的系统责任，如持久性和表示。然后，我们使用分层架构原则开发了一个应用程序。最后，为了突出分层架构和六边形架构之间的差异，我们将之前基于层的应用程序重构为六边形架构。

*第十六章*，*使用六边形架构与 SOLID 原则*，首先回顾 SOLID 原则，并观察每个原则如何帮助构建具有改进可维护性的应用程序。然后，它探讨了 SOLID 原则如何应用于使用六边形架构开发的系统。最后，它介绍了在构建六边形系统时可以使用的常见设计模式。

*第十七章*，*为您的六边形应用程序制定良好设计实践*，讨论了在创建应用程序的每个六边形时可以采用的一些良好实践。从领域六边形开始，我们关注领域驱动设计（DDD）方面，以明确应用程序应该解决的业务问题。然后，我们继续讨论在应用程序六边形中设置用例和端口的替代方法。最后，我们讨论了维护多个适配器的后果。

# 要充分利用本书

提供的示例基于 Java 17，但您应该能够使用更近期的 Java 版本运行它们。构建示例项目需要 Maven 3.8。还需要 Docker 来运行在容器内运行应用程序的示例。

| **本书涵盖的软件/硬件** | **操作系统要求** |
| --- | --- |
| Maven 3.8 | Windows、macOS 或 Linux |
| Java 17 SE 开发工具包 | Windows、macOS 或 Linux |
| Docker | Windows、macOS 或 Linux |
| Postman | Windows、macOS 或 Linux |
| Newman | Windows、macOS 或 Linux |
| Kafka | macOS 或 Linux |

您将需要 Postman、Newman 和 Kafka 来运行 *第五章* 中的示例。

**如果您使用的是本书的数字版，我们建议您亲自输入代码或从本书的 GitHub 仓库（下一节中提供链接）获取代码。这样做将帮助您避免与代码复制粘贴相关的任何潜在错误。**

# 下载示例代码文件

您可以从 GitHub 下载本书的示例代码文件，网址为 [`github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition`](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition)。如果代码有更新，它将在 GitHub 仓库中更新。

我们还有其他来自我们丰富的书籍和视频目录的代码包，可在[`github.com/PacktPublishing/`](https://github.com/PacktPublishing/)找到。查看它们！

# 使用的约定

本书使用了多种文本约定。

`文本中的代码`：表示文本中的代码单词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 昵称。以下是一个示例：“将下载的`WebStorm-10*.dmg`磁盘映像文件作为系统中的另一个磁盘挂载。”

代码块设置如下：

```java
public interface RouterNetworkUseCase {
    Router addNetworkToRouter(RouterId,
    Network network);
    Router getRouter(RouterId routerId);
}
```

当我们希望您注意代码块中的特定部分时，相关的行或项目将以粗体显示：

```java
function getRouter() {
    const routerId = document.
    getElementById("routerId").value;
    var xhttp = new XMLHttpRequest();
    xhttp.onreadystatechange = function() {
        console.log(this.responseText);
        if (this.readyState == 4 && this.status == 200) {
            const json = JSON.parse(this.responseText)
            createTree(json)
        }
```

任何命令行输入或输出都如下所示：

```java
java -jar target/topology-inventory-1.0-SNAPSHOT-jar-with-dependencies.jar rest
REST endpoint listening on port 8080...
Topology & Inventory WebSocket started on port 8887...
```

**粗体**：表示新术语、重要单词或您在屏幕上看到的单词。例如，菜单或对话框中的单词以**粗体**显示。以下是一个示例：“从**管理**面板中选择**系统信息**。”

提示或重要注意事项

看起来是这样的。

# 联系我们

我们始终欢迎读者的反馈。

**一般反馈**：如果您对本书的任何方面有疑问，请通过 customercare@packtpub.com 给我们发邮件，并在邮件主题中提及书名。

**勘误表**：尽管我们已经尽最大努力确保内容的准确性，但错误仍然可能发生。如果您在这本书中发现了错误，我们将非常感激您能向我们报告。请访问[www.packtpub.com/support/errata](http://www.packtpub.com/support/errata)并填写表格。

**盗版**：如果您在互联网上以任何形式遇到我们作品的非法副本，我们将非常感激您能提供位置地址或网站名称。请通过 copyright@packt.com 与我们联系，并提供材料的链接。

**如果您有兴趣成为作者**：如果您在某个主题上具有专业知识，并且您有兴趣撰写或为书籍做出贡献，请访问[authors.packtpub.com](http://authors.packtpub.com)。

# 分享您的想法

一旦您阅读了《使用 Java 设计六边形架构，第二版》，我们非常乐意听到您的想法！请[点击此处直接转到此书的亚马逊评论页面](https://packt.link/r/1837635110)并分享您的反馈。

您的评论对我们和科技社区非常重要，并将帮助我们确保我们提供高质量的内容。

# 下载此书的免费 PDF 副本

感谢您购买此书！

您喜欢在路上阅读，但又无法携带您的印刷书籍到处走吗？

您购买的电子书是否与您选择的设备不兼容？

不要担心，现在，每购买一本 Packt 书籍，您都可以免费获得该书的 DRM 免费 PDF 版本。

在任何地方、任何设备上阅读。直接从您喜欢的技术书籍中搜索、复制并粘贴代码到您的应用程序中。

优惠不仅限于此，您还可以获得独家折扣、时事通讯和丰富的免费内容，每天直接发送到您的邮箱

按照以下简单步骤获取好处：

1.  扫描二维码或访问以下链接

![](img/B19777_QR_Free_PDF.jpg)

[`packt.link/free-ebook/9781837635115`](https://packt.link/free-ebook/9781837635115)

1.  提交您的购买证明

1.  就这样！我们将直接将免费 PDF 和其他好处发送到您的邮箱

# 第一部分：架构基础

在本部分，您将深入了解六边形架构元素：领域实体、用例、端口和适配器。从讨论为什么我们会将六边形架构原则应用于我们的项目开始，我们通过学习如何使用领域驱动设计技术组织问题域代码来逐步推进我们的探索。

然后，我们探讨用例和端口在表达系统行为中的重要作用。接下来，我们探索适配器如何使六边形系统与不同的协议和技术兼容。最后，我们通过讨论驱动和被驱动操作如何影响六边形系统的行为来结束本部分。

本部分包含以下章节：

+   *第一章*, *为什么选择六边形架构?*

+   *第二章*, *将业务规则包裹在领域六边形内*

+   *第三章*, *使用端口和用例处理行为*

+   *第四章*, *创建适配器以与外部世界交互*

+   *第五章*, *探索驱动和被驱动操作的本质*
