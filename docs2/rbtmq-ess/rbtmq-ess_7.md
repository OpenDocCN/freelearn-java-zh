# 第七章：最佳实践和代理监控

本书的前几章专注于使用 RabbitMQ 在示例公司**Complete Car**（**CC**）中设置成功的微服务架构。虽然包括了众多 RabbitMQ 功能，但任何系统如果没有对其实施的最佳实践的理解都是不完整的。与所有生产系统一样，适当的监控和警报也是必要的，以便保持对事物的掌控。

CC 的集群稳定，没有性能问题。本章总结了从 CC 的系统中学到的关键要点，包括队列、路由、交换、消息处理等方面的最佳实践和建议。

本章探讨了以下主题：

+   如何避免丢失消息

+   保持队列和代理清洁

+   路由最佳实践

+   通过连接和通道进行网络通信

+   探索关键要点

+   监控 - 查询 REST API

当使用 RabbitMQ 设置基础设施时，本章是一个理想的参考指南。在将 RabbitMQ 投入生产时，请回顾本章中的关键要点、最佳实践和监控技巧，以获得宝贵的见解。

# 如何避免丢失消息

通过遵循本节中的最佳实践可以避免消息丢失。大部分情况下，CC 遵循了最佳实践，即**保持队列短小高效**。包含太多消息的队列会对代理的性能产生负面影响。已识别的**高 RAM 使用**可能表明队列中的消息数量迅速增加。

以下是关于如何在 RabbitMQ 中不丢失消息的最佳实践建议：

+   在 RabbitMQ 集群中使用至少三个节点，并使用**法定多数队列**类型将消息传播到不同的节点。

+   如果绝对必要确保所有消息都被处理，则将队列声明为**持久**的，并将消息投递模式设置为**持久**，如第二章中所述，*创建出租车应用程序*。队列、交换和消息需要能够处理可能发生的任何重启、崩溃或硬件故障。

以下是关于 RabbitMQ 中消息处理的澄清：

+   理解持久性带来的权衡是设计耐用系统架构时的关键。**懒队列**虽然使用临时消息，但对性能的影响类似。

+   使用临时消息与持久队列结合可以创造速度，而不会丢失配置，但可能会导致消息丢失。

如果遵循了所有这些最佳实践，消息仍然有丢失的风险，那么下一节将介绍死信交换，这样那些可能永远消失的消息就有地方等待，直到它们可以被处理。

## 使用死信交换

即使使用持久队列和持久消息，也可能出现导致未处理消息的问题。可以设置 TTL，队列长度可能已超过，或者消息可能被消费者否定确认。作为最佳实践，消息的路由键应指定`x-dead-letter-routing-key`，以确保消息永远不会丢失。将队列附加到交换机并按程序管理消息。尽量避免将消息发送到同一交换机，因为这可能导致无限递归。有些消息可能难以处理，并不断进入交换机。确保在编程逻辑中处理这些错误。

在队列的声明中设置`x-dead-letter-routing-key`属性。这有助于提高性能，并使架构中的组件能够分别处理错误，如第四章中所述，调整消息传递。

对于经常受到消息峰值冲击的应用程序，建议设置队列最大长度。队列最大长度通过丢弃队列头部的消息来保持队列较短。最大长度可以设置为消息数量，或固定字节数。

## 处理确认和确认

在连接失败的情况下，传输中的消息可能会丢失。如果需要重新传输消息，确认会向服务器和客户端提供警报。客户端可以在收到消息时或处理完消息后确认消息。然而，重要的是要记住，消费重要消息的应用程序应在处理后再确认，这样未处理的来自崩溃或异常的消息就不会丢失。发布者确认需要服务器确认已从发布者接收消息。

确认也可能影响系统性能，但如果发布者必须至少处理一次消息，则它们是必需的。

## 消息处理最佳实践

队列和客户端处理它们的负载——消息。为了进一步提高性能，微调消息和消息处理。

### 限制消息大小

每秒发送的消息数量比消息本身的大小更令人担忧。然而，发送大消息不是最佳实践，发送过小的消息也不是，因为 AMQP 会给所有发送的消息添加一个小数据包开销。

检查消息，看是否可以将其拆分并发送到不同的队列，如下所示：

+   将可迭代数据拆分为块，每条消息发送一个小块。

+   将大文件存储在分布式存储中，如 Hadoop 或网络附加存储。

+   将架构拆分为更多模块化组件，每个组件一个队列。

+   将适当的元数据卸载到键值存储中。

尽管可以避免发送大消息，但带宽、架构和故障转移限制是需要考虑的因素。消息的大小取决于应用程序，但应尽可能小。

### 使用消费者和预取

设置预取值可以在系统内均匀地分配工作负载。RabbitMQ 允许预取，但重要的是要记住，只有在所有消费者都忙碌时，预取才是有效的。

RabbitMQ 必须管理跨队列和消费者的消费。预取值过低会使消费者空闲，等待消息到达，这反过来会减慢代理处理请求的能力。设置预取值过高会使一个消费者忙碌，而其余的消费者保持空闲，如*第三章，向多个出租车司机发送消息*中所述。

如果处理时间低且网络稳定，则可以增加预取值。在这种情况下，可以通过将总往返时间除以处理时间来确定预取值。

如果有多个消费者和较长的处理时间，预取值会趋于较低。如果处理时间足够长，可以将预取限制设置为 1。

随着需求增加，队列变得更加繁忙，系统资源消耗也更多。保持队列和代理的清洁对于良好的性能至关重要，这将在下一节中介绍。

# 保持队列和代理的清洁

清洁的代理是高效的代理。为了保持功率和空间在最佳水平，确保队列和代理清洁是很容易的。RabbitMQ 提供了自动删除消息和队列以保持空间空闲的机制。这包括设置**存活时间**（**TTL**）和自动删除未使用的队列，这些将在以下章节中详细介绍。

## 为消息设置 TTL 或队列的最大长度

为长时间运行的过程提供消息支持的队列可能会变得非常大。过大的队列可能会影响代理的性能。设置 **TTL** 允许在一段时间后从队列中删除消息。如果指定，这些消息将进入死信交换。这可以保存更多消息，甚至处理潜在问题而不会丢失数据。

在声明队列时，使用 `x-message-ttl` 属性设置合理的 **TTL**。请确保提供 `x-dead-letter-exchange` 和 `x-dead-letter-routing-key` 以避免完全丢失消息。

对于经常受到消息高峰冲击的应用程序，建议设置队列最大长度。队列最大长度通过丢弃队列头部的消息来保持队列短小。最大长度可以设置为消息数量，或字节数量。

## 自动删除未使用的队列

除了防止队列变得过大之外，还可以根据使用情况删除队列。

自动删除未使用队列有三种方法，如下所示：

1.  使用声明中的`x-expires`属性为队列设置过期策略，当未使用时，只保持队列活跃数毫秒。

1.  在声明中将`auto-delete`队列属性设置为`true`。这意味着在以下情况下队列将被删除：

+   建立了初始连接。

+   最后一个消费者关闭。

+   通道/连接被关闭或队列失去了与服务器之间的**传输控制协议**（**TCP**）连接。

1.  在队列声明中将独占属性设置为`true`，这样结构就属于声明连接，并在连接关闭时被删除。

有时，消息队列中的旅程本身就会造成低效。为了确保消息走的是最佳路径，请遵循下一节中找到的路由最佳实践。

# 路由最佳实践

作为最佳实践，直接交换是使用最快的。即使在使用直接交换时，具有多个绑定也需要更多时间来计算消息必须发送的位置。在路由方面还有一些额外的最佳实践需要考虑。

## 考虑路由设计系统

每个端点都是一个服务或应用程序。与 CC 不同，CC 在汽车和大部分单一应用层之间运行，而许多微服务架构通过数十个服务传递消息。

CC 围绕小型服务设计了他们的系统架构。他们结合了有意义的操作。在设计了较小的系统之后，他们考虑了额外的交换或队列可能有益的地方。这保持了整体设计足够小，同时不会限制处理能力。

# 通过连接和通道进行网络通信

数千个连接对 RabbitMQ 服务器来说是一个沉重的负担，导致其内存耗尽并崩溃。大量连接和通道也可能由于处理大量性能指标而负面影响 RabbitMQ 管理界面。为了避免这种情况，请为每个应用程序配置创建极少数量的连接——如果可能的话，1 个。而不是使用多个连接，为每个线程建立一个通道。每个连接应该是长久的，并且应根据应用程序结构考虑以下最佳实践。

记住，即使新的硬件提供了数百个线程，也只能建立设置的通道数，并且这个数字不应过大。由于一些客户端没有使通道线程安全，最好不要在线程之间共享通道。这样做可能会创建竞争条件，这可能导致应用程序完全崩溃。

重复打开和关闭连接和通道也会损害系统性能。这样做会增加延迟，因为更多的 TCP 数据包通过网络发送。

## 使用 TLS 和 AMQPS 进行安全

RabbitMQ 可以通过 AMQPS 连接，即 TLS 包装的 AMQP 协议。通过网络传输的数据被加密，但需要考虑性能影响。为了最大化性能，请使用 VPC 或 VPN 对等连接，因为它们为流量提供了一个私有、隔离的环境，并且不直接涉及 AMQP 客户端和服务器。

不要在前端暴露后端。CC 示例被简化了。在现实中，很可能在未知用户和代理之间添加一个应用层。

## 分离的连接

默认情况下，RabbitMQ 会降低发布速度过快的连接速度，以便队列能够跟上。RabbitMQ 简单地对 TCP 连接应用反向压力，将其置于流量控制状态。流量控制的连接在管理 UI 和 HTTP API 响应中显示流量状态。这意味着连接每秒经历多次阻塞和解阻塞，以保持消息流率在一个服务器和队列都能处理的水准。

当发布者使用与消费者相同的 TCP 连接时，在回复代理时可能会阻塞消息。服务器可能无法从客户端收到确认，这将对其速度产生负面影响，并可能导致其过载。因此，通过为发布者和消费者使用单独的连接来实现更高的吞吐量是最佳选择。

## 在不同的核心上分割队列

CC 基础设施运行在多个核心上。为了获得更好的性能，队列被分散在不同的核心和节点之间。RabbitMQ 中的队列绑定到它们首次声明的节点。即使对于集群代理也是如此，因为所有路由到特定队列的消息都发送到队列所在的节点。RabbitMQ 中的一个队列每秒可以处理高达 50,000 条消息。因此，当队列在不同核心和节点之间分割，并在多个队列之间分散时，可以获得更好的性能。

可以手动在节点之间均匀分割队列，但这可能难以记住。或者，有两个插件可以帮助组织多个节点或单个节点集群的多核。这些是**一致性哈希交换**和**RabbitMQ 分片**插件。

### RabbitMQ 分片

分片使得在不同节点上的队列之间分配消息变得容易。一个队列可以分散到多个实际队列中。一旦交换被定义为分片，支持队列将自动在每个集群节点上启动，消息相应地分散，如下所示：

![图片](img/284071c3-7926-4dae-8b99-dca7de34ec89.png)

图 7.1：队列间的分片

路由键确保消息在队列之间均匀分布。插件期望你为每个分片运行一个消费者，新节点会自动纳入。请注意，从所有队列中消费是很重要的。插件提供了一个集中位置来发送消息，并通过在集群中添加队列来跨节点负载均衡消息。更多关于 RabbitMQ 分片插件的详细信息请参阅：[`github.com/rabbitmq/rabbitmq-sharding`](https://github.com/rabbitmq/rabbitmq-sharding)。

### 一致性哈希交换

RabbitMQ 提供了一个插件，可以帮助通过一致性哈希交换来负载均衡消息。基于路由键，此交换中**绑定**的队列会均匀地发送消息。这优化了具有多个核心的集群的使用，因为插件会创建路由键的哈希，并确保在交换绑定的队列之间均匀分配消息，确保在集群的多个核心上优化使用。

更多关于一致性哈希交换插件的详细信息请参阅：[`github.com/rabbitmq/rabbitmq-consistent-hash-exchange`](https://github.com/rabbitmq/rabbitmq-consistent-hash-exchange)。

# 探索关键要点

为了简化，优化可以分为两种形式，鉴于本书中汽车是一个热门话题，让我们继续这个主题。

**法拉利** **–** **快速平稳**：如果系统必须具有快速性能和高吞吐量，则使用单个节点。尽可能保持队列最短，如果可能的话，设置最大长度或 TTL。不要设置懒队列策略以保持检索时间短。出于相同的原因，使用临时消息而不是持久消息。利用多个队列和消费者的使用，提供最大吞吐量。为了实现最快的吞吐量，应禁用手动确认。始终努力使用最新的稳定 RabbitMQ 版本。

**沃尔沃** **–** **稳定可靠**：一个必须高度可用且不能丢失消息的系统应该有耐用的队列并发送持久消息。队列仍然应该保持较短。

建议通过法定队列来设置集群。如果已经使用镜像队列，添加懒队列策略以获得更稳定的设置。确保系统中使用三个或五个节点以实现高可用性。在设置 RabbitMQ 集群时，使用一致性哈希交换或分片插件在不同核心和不同节点之间分割队列，以保持一切运行顺畅和高效。始终努力使用最新的稳定 RabbitMQ 版本。

既然最佳实践提示已经介绍完毕，现在是时候考虑如果出现问题应该发生什么了。监控集群和设置警报策略是任何生产环境的重要收尾工作。

# 监控 – 查询 REST API

监控 RabbitMQ 代理时，检索实时信息有两种主要方式：一种是通过`rabbitmqctl`命令行工具，另一种是通过管理控制台通过 HTTP 公开的**REST API**。

任何监控系统都可以使用这些工具来收集指标并将它们报告给日志、分析、报告和警报框架。例如，可以将信息推送到外部日志服务进行进一步分析。

自从 CC 安装了管理控制台，如第一章*《Rabbit Springs to Life》*中所述，团队选择使用丰富、文档齐全的 API 而不是命令行。RabbitMQ 在任何安装了管理插件的节点上提供`http://localhost:15672/` API 的文档。虽然如此，也可以通过命令行检索相同的原始指标，但缺乏图形界面。

请记住，管理控制台由 API 支持，因此浏览器内看到的任何操作都可以通过 API 完成。

RabbitMQ 公开了各种不同的指标类型以供收集，如前文所述。这些包括但不限于以下内容：

+   **节点状态**：测试 RabbitMQ 的性能涉及执行一系列命令来声明一个存活性测试队列，然后发布和消费它。如果命令返回`0`（没有消费消息），则通过适当的请求设置一个警报：

```java
curl -s http://cc-admin:******@localhost:15672/api/aliveness-test/cc-prod-vhost | grep -c "ok"
```

+   **集群大小**：测试集群大小对于发现网络分区很有用。如果集群大小低于预期，则设置一个警报：

```java
curl -s http://cc-admin:******@localhost:15672/api/nodes | grep -o "contexts" | wc -l
```

CC 使用`bash`脚本和 Python 发送错误，当节点数量低于预期时。

+   **联邦状态**：由于重启或其他问题，联邦队列可能会解耦。请检查中央日志聚合代理上的活动上游链接，如果其数量小于最佳大小（在 CC 的情况下为`3`），则发出警报，如下所示：

```java
curl -s http://cc-admin:******@localhost:15672/api/federation-links/cc-prod-vhost | grep -o "running" | wc -l
```

+   **队列的高水位**：基于云的代理有时以低成本提供扩展，但有限制消息。在其他情况下，消息延迟是一个问题。确保队列中可用的消息数量低于某个阈值：

```java
curl -s -f http://cc-admin:******@localhost:15672/api/queues/cc-prod-vhost/taxi-dlq | jq '.messages_ready'
```

在 CC 的情况下，他们想验证`taxi-dlq`队列中的消息少于 25 条。否则，他们发出警报，表明存在瓶颈。如果队列不存在，脚本需要处理优雅的失败。

+   **整体消息吞吐量**：监控特定代理上的消息流量强度可以使资源根据需要增加或减少。使用以下命令收集消息速率：

```java
curl -s http://cc-admin:******@localhost:15672/api/vhosts/cc-prod-vhost | jq '.messages_details.rate'
```

当 CC 的吞吐量阈值超过其代理可以承受的上限时，CC 会添加一个警报。

一些指标具有严格的最高限制，其值也通过 API 提供。建议在达到上限 80%的阈值时发出警报。以下脚本在必须发出警报时返回 false。这些指标包括以下内容：

+   **文件描述符**：许多操作系统都有文件描述符限制。如果可用的描述符不足，磁盘上消息持久化的性能可能会受到影响。使用的文件描述符数量可以与可用文件描述符的数量进行比较：

```java
curl -s http://cc-admin:******@localhost:15672/api/nodes/rabbit@${host} | jq '.fd_used<.fd_total*.8'
```

在 macOS X 和 Linux 上，可以增加可用的文件描述符数量。文件描述符用于访问其他文件。如果超过这个限制，检查吞吐量也是一个好主意。

+   **套接字描述符**：套接字描述符维护对单个套接字的连接句柄。如果这些描述符耗尽，RabbitMQ 将停止接受新的连接，这是大型集群中常见的问题：

```java
curl -s http://cc-admin:******@localhost:15672/api/nodes/rabbit@${host} | jq '.sockets_used<.sockets_total*.8'
```

Linux 使用文件描述符来处理套接字，可以通过`ulimit`命令调整计数。遵循最佳实践，使用更多通道和更少的连接可以帮助处理这个问题。

+   **Erlang 进程**：Erlang 虚拟机创建的进程数量有一个上限。尽管通常接近 100 万进程，但每个进程都需要资源来运行。使用的 Erlang 进程数量可以与 Erlang 进程限制进行比较：

```java
curl -s http://cc-admin:******@localhost:15672/api/nodes/rabbit@${host} | jq '.proc_used<.proc_total*.8
```

操作系统不会为每个进程创建线程。尽管如此，每个进程都使用轻量级栈，并且需要时间来调度和维护。

+   **内存和磁盘空间**：如果内存或磁盘空间耗尽，RabbitMQ 将无法正常工作——例如，可能会触发流控制。请确保有足够的资源，并相应地调整硬件。

    应该使用的总内存量应小于内存使用量高水位线的 80%：

```java
curl -s http://cc-admin:******@localhost:15672/api/nodes/rabbit@${host} | jq '.mem_used<.mem_limit*.8'curl -s
```

磁盘可用空间限制应与当前可用磁盘空间进行比较：

```java
http://cc-admin:******@localhost:15672/api/nodes/rabbit@${host} | jq '.disk_free_limit<.disk_free*.8'
```

除了指标外，一个运行实例还会运行以下程序：

+   `rabbitmq-server`：这是显而易见的，但不应被遗忘！

+   `epmd`：Erlang 端口映射器守护进程`epmd`在集群和网络中起着关键作用。建议设置脚本以检查这些服务是否正在运行。在 Linux 或 macOS X 上使用`ps`列出程序，在 Windows 上使用`Get-Process`。

主日志文件中的`ERROR REPORT`条目揭示了系统中的问题。在 Linux 中，RabbitMQ 将日志文件存储在`/var/log/rabbitmq/rabbit@<hostname>.log`。有关更多信息，请检查配置文件[`www.rabbitmq.com/logging.html#log-file-location`](https://www.rabbitmq.com/logging.html#log-file-location)。

# 摘要

本章通过考察最佳实践和监控，总结了基于 RabbitMQ 构建的微服务的研究。本书经历了 CC 应用的应用流程，从基本服务到扩展。新功能和流程轻松添加，且没有中断 CC 应用。随着时间的推移，CC 的开发团队创建了一个全面、实用、可靠、长期运行的应用。为了避免可能导致不良用户体验或甚至数据丢失的故障，CC 团队实施了一个监控策略。在 CC 形成警报计划的过程中，概述了收集、记录、分析和报告指标。最后，通过 RabbitMQ 管理控制台设置了警报参数。

恭喜您完成了这本书的阅读之旅！拥有了足够的 RabbitMQ 驯服技能后，下一步是为您自己创建一个实例。开始使用 RabbitMQ 的一个简单方法是通过世界上最大的 RabbitMQ 集群托管服务提供商 CloudAMQP。
