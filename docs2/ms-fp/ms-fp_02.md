# 第二章：函数与 Lambda 表达式

函数式编程范式与声明式编程范式有很多共同特征。函数式语言和声明式编程的一个定义特征是广泛使用函数。本章将更详细地讨论函数是什么以及它们在不同范式中的意义。我们将探讨如何使用函数以及它们在现代编程语言中的角色。

在本章中，我们将涵盖以下主题：

+   函数作为行为

+   函数式编程中的函数

+   高阶函数

+   Lambda 表达式

+   不同编程语言中函数的概念

# 函数作为行为

那么，什么是函数？我们可以将它们定义为**参数化**、命名的代码块。这意味着它们是可以从程序的任何其他部分通过其名称调用的代码块。参数化意味着你可以用某些参数来调用它们。使用不同参数执行的不同调用通常会导致不同的结果。

函数背后的动机是什么？答案是工程的基本原则——抽象出重复的部分。在第一章《声明式编程风格》中，我们看到了循环中的类似情况。然而，循环是内置的控制结构。这意味着它们在语言级别上定义。当我们需要在语言用户级别上定义某些逻辑，并且这种逻辑在项目的不同部分中重复时，函数就派上用场了。

我们可以将函数的概念追溯到过程式编程。在过程式编程中，函数是抽象的一个单元。这意味着函数封装了重复的逻辑。在面向对象编程中，我们对函数的理解有所发展。函数通常在对象或类的上下文中被看待。在这种情况下，它们扮演着对象行为的作用。

例如，如果你有一个名为汽水机的对象，这个对象可能与其关联某些行为，例如将硬币投入机器，或者按按钮从机器中获取一听汽水。

# 函数式编程中的函数

在命令式编程中，函数用于表示对象的行为。在面向对象编程中，行为通常意味着副作用。为了本书的目的，我们可以将副作用理解为以下内容——当一个函数修改其自身主体之外的环境时，它就是有副作用的。例如，它可以修改其父对象的全局变量，它可以向文件系统写入文件，或者函数可以在网络上执行某些 Web API 调用。

在函数式编程中，对函数的理解相当不同。在函数式编程中，我们重视纯净性和引用透明性。纯净性意味着没有副作用。引用透明性意味着函数计算出的结果值可以替换函数调用，而程序执行的语义将保持不变。

考虑以下示例。你有一个模拟饮料机的应用程序。它的行为是将硬币插入饮料机并从饮料机中取回饮料罐。饮料机由数据组成：机器中存在的钱和饮料罐的数量。每次插入硬币时，就会卖出一个饮料罐。

我们如何以命令式风格表达这种行为？我们可以创建一个单独的对象，称为饮料机，并在该对象中创建一个分发罐子的方法。每当这个方法被调用时，其中的硬币数量就会增加一个，而饮料罐的数量就会减少一个。此外，我们还想从该方法返回一个名为`SodaCan`的对象。

在面向对象编程的精神下，我们可以将饮料机表示为一个具有一些内部状态的对象：

```java
public class ImperativeSodaMachine {
 private int coins = 0;
 private int cans  = 0;
 public ImperativeSodaMachine(int initialCans) {
   this.cans = initialCans;
 }
```

我们也可以定义一些机器上的行为：插入硬币并取回饮料罐时需要发生的行为。如果机器中还有饮料罐，我们就减少一个饮料罐的数量，增加一个硬币的数量，并返回一个`饮料罐`对象给用户。如果没有饮料罐了，我们抛出一个异常：

```java
 public SodaCan insertCoin() {
   if (cans > 0) {
     cans--;
     coins++;
     return new SodaCan();
   }
   else throw new RuntimeException("Out of soda cans!");
 }
}
```

最后，`SodaCan`对象被定义为以下内容：

```java
public class SodaCan {
 public void drink() {
   System.out.println("You have drunk a can of soda.");
 }
}
```

在饮料机中存在的罐子和钱数是饮料机的变量。它们不属于函数体。这就是为什么改变其自身作用域之外变量的函数构成了一个有副作用的函数。

虽然命令式方法被概念化为有副作用的操作，但函数式风格的函数被概念化为计算某些值的计算。在函数式世界中，副作用是不受欢迎的。让我们以前面程序的方式表达纯函数式的程序。我们将有一个没有行为的饮料机，因为行为是有副作用的。在函数式世界中，副作用通常是不好的，正如我们在后续章节中将学到的。而不是那种行为，你将有一个计算饮料机新状态的函数。这是一个从旧饮料机对象生成的新饮料机对象。这样的饮料机对象是一个不可变对象，这意味着它只包含无法修改的值。这有助于消除副作用，因为现在，定义在饮料机上的函数不能修改其作用域之外的变量。每次我们想要得到一个新的罐子时，我们也需要计算罐子分发后的饮料机新状态，然后从这个机器中返回一个罐子：

```java
case class SodaMachine(cans: Int, coins: Int = 0)
def insertCoin(sm: SodaMachine): (SodaMachine, SodaCan) =
 if (sm.cans > 0) (SodaMachine(sm.cans - 1, sm.coins + 1), new SodaCan)
 else throw new RuntimeException("Out of soda cans!")
```

以这种方式表达的计算不会影响其自身作用域之外的环境。我们不再修改某些外部变量，也不会与函数作用域之外的世界交互。我们只是根据函数的输入计算结果值。这是函数式编程世界中函数的理解。本书稍后我们将讨论这种理解在行为方面比原始的方法理解更有益。

函数式风格的唯一特征不是副作用的存在。接下来我们要看的是高阶函数——接受其他函数作为输入的函数。

# 高阶函数

函数式编程中出现的另一个重要概念是高阶函数。高阶函数是接受一个函数作为参数的函数。一个可能非常有用的简单例子是控制结构。例如，一个`while`循环可以用函数式的方式表示为一个接受循环体和谓词作为参数的高阶函数。

循环体可以表示为一个不接受任何参数但计算一些副作用的功能。其工作方式是，我们有一个函数接受一个`0-参数`函数和一个谓词，当谓词为真时，我们递归地调用相同的`loop`函数。

我们可以将新的控制结构命名为`whileDiy`，它可以定义为如下：

```java
@annotation.tailrec
def whileDiy(predicate: => Boolean)(body: => Unit): Unit =
  if (predicate) {
    body
    whileDiy(predicate)(body)
  }
}
```

`whileDiy`构造接受一个谓词和一个体。谓词将在每次函数调用时被评估，如果为真，我们将运行体并再次递归调用`whileDiy`构造。注意，在方法顶部的`@annotation.tailrec`注解上，它表明该方法将以尾递归方式调用，这意味着即使它是递归的，也没有机会导致`StackOverflowError`。这是因为它将重用其初始调用的框架进行所有后续递归调用。

我们可以这样使用新的构造：

```java
var j = 0
whileDiy (j < 5) {
  println(s"Printing from custom while loop. Iteration: $j")
  j += 1
}
```

将其与内置的`while`循环的使用方式进行比较：

```java
var i = 0
while (i < 5) {
  println(s"Printing from built-in while loop. Iteration: $i")
  i += 1
}
```

使用方式几乎相同。这说明了高阶函数可以用来定义与语言内建的控制结构非常接近的控制结构。

# 理解 lambda 函数

大多数函数式语言都有一个 lambda 函数的概念。它是一个定义在行内的匿名函数。如果需要，它可以被分配给一个变量。例如，考虑在一个 Web 应用程序的上下文中，我们需要一个接受带有用户会话数据的 cookie 的函数。它的任务是向用户打印标准输出的问候语。然而，在打印之前，我们需要以某种方式装饰用户的姓名。更复杂的是，我们还有一个拥有博士学位的用户数据库，如果他们有，我们需要称他们为 Dr.以下是在 Scala 中如何实现它的示例：

1.  我们为示例定义了一个虚拟的`Cookie`类：

```java
case class Cookie(name: String, gender: String)
```

1.  我们定义了`greeting`方法。该方法的工作是从`cookie`对象中提取数据，并根据用户的性别应用修改器到用户的名字。

1.  然后，问候用户。此方法不知道如何确切地修改名字。`modifier`逻辑被抽象化，我们依赖于调用者指定如何进行此操作：

```java
def greeting(cookie: Cookie)(modifier: (String, String) => String): Unit = {
     val name         = cookie.name
     val gender       = cookie.gender
     val modifiedName = modifier(name, gender)
     print(s"Hello, $modifiedName")
}
```

1.  最后，这是调用此方法的方式：

```java
def isPhd(name: String): Boolean = name == "Smith"
val cookie = Cookie("Smith", "male")
greeting(cookie) { (name, gender) =>
  if (isPhd(name)) s"Dr $name"
  else gender match {
    case "male"   => s"Mr $name"
    case "female" => s"Mrs $name"
  }
}
```

`greeting`函数接受一个字符串和一个修改这个字符串的函数。注意，在调用此函数时，我们如何内联指定修改字符串的函数。我们不需要在传递给`greeting`函数之前定义该函数。

这就是 lambda 函数背后的理念。在使用某些高阶函数之前，你不需要先定义一个函数。相反，你可以使用 lambda 语法内联定义这样的函数。显然，这种方法在处理高阶函数的上下文中特别有用。它允许你使用高阶函数，而无需首先定义它们的参数。

嵌套函数的概念在大多数函数式语言中都有体现，包括 Scala、Haskell 和 Python。

# 不同编程语言中函数的概念

函数存在于许多编程语言中。有些语言对纯函数式风格的支持更好，而有些则更倾向于声明式风格。这就是为什么，例如，使用 Scala 而不是 Java 可以给你带来巨大的优势，因为你可以更容易地在其他函数内部声明函数，你可以声明接受其他函数（高阶函数）的函数，并且你可以声明匿名 lambda 函数（从 Java 8 开始，Java 也提供了这种功能）。这大大增加了你的抽象能力，创建控制结构的能力，从而使得你的应用程序能够以更**DRY**（**不要重复自己**）的方式表达。

# 摘要

在本章中，我们看到了函数是什么以及它们是如何从编程的早期发展到今天的。我们看到了函数最初是如何被视为常见逻辑的抽象的。之后，在面向对象编程中，它们代表了某些对象的行为。面向对象程序员试图将一切视为对象。因此，函数开始从由对象组成的世界中看待。在这种情况下，函数最好被视为这些对象的行为。

在函数式编程中，函数可以从不同的角度来理解。现在，最好的方式是将函数视为数学计算。它们以纯方式从输入中计算出一些值，这意味着没有任何副作用。这种想法是将它们视为数学函数。

函数式编程接近声明式编程，因此其函数也经常根据那种风格的需求进行定制。这种方式，在函数式语言中，存在高阶函数、匿名 lambda 函数和部分函数的概念。从工程角度来看，这很有用，因为它极大地增强了你的抽象能力。

在编程中，数据结构无处不在。当采用函数式风格时，迟早你会遇到如何在函数式方式下处理数据结构的问题。在下一章中，我们将看到这个问题是如何被解决的。

# 问题

1.  函数在面向对象编程的上下文中是如何被解释的？

1.  函数在纯函数式编程的上下文中是如何被解释的？

1.  高阶函数是什么？

1.  高阶函数为什么有用？
