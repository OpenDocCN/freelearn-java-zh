# 效果类型 - 抽象化副作用

在上一章中，我们看到了副作用可能成为麻烦的来源。我们还简要讨论了效果类型。效果类型是函数式编程的一种技术，它允许抽象副作用。

在本章中，我们将探讨这是如何工作的。我们将了解模式背后的哲学。我们还将看到如何按顺序组合被效果类型捕获的副作用。

在本章中，我们将涵盖以下主题：

+   将效果转换为数据

+   使用 Monads 的效果类型顺序组合——`map` 和 `flatMap` 函数

# 将效果转换为数据

将编写程序的过程与建模和描述特定现实进行比较是可能的。例如，当你编写仓库管理应用程序时，你正在将在线商店的概念、其库存、库存存储的地方以及库存可以进出仓库的规则编码到逻辑规则中。这是你编写应用程序的业务领域现实。我们可以说，作为程序员，你的目标是模拟你的业务领域，即使用你的编程语言将其编码为特定的逻辑规则——定义信息存储、转换和交互的方式。

然而，在执行过程中，程序会创造出自己的现实。正如仓库、在线商店和用户都是业务领域现实的成员一样，一些元素是程序执行领域的成员。同样，你可以在你的业务领域中定义某些现象，例如库存短缺或用户从你的商店购买，你可以在编写和运行程序的世界中定义某些现象。

现实是你处于某个抽象级别工作时心中的想法。当你处于业务领域级别工作时，你心中想的是一类事物。然而，当你创建程序时，你心中想的是完全不同的事物。这两组不同的概念和现象可以理解为你在其中工作的不同现实。

例如，错误存在于程序执行的现实之中。错误的生命周期也是程序执行的现实。错误可以在调用栈中传播。当它们被处理时，它们会停止传播。它们在发生的地方破坏程序。

延迟也是程序执行的现实。当你执行数据库操作、输入输出操作或等待服务器的响应时，你正在处理延迟。

并发、模块化、类层次结构——这些都是你编程现实中的元素。编程现实是你编写程序时所关注的理念和现象。然而，这种现实并不关乎你的老板，他生活在业务领域的现实中。

为了简单起见，让我们将业务域现实称为一级现实，将编程现实称为二级现实。这样的命名是因为业务域现实是你立即关心的事情。你的程序的现实是在解决业务域问题的过程中产生的，即一级现实。

有时候，程序员只关注一级现实。他们可能不关心代码的质量或它如何处理二级现实。他们的主要关注点是描述一级现实和解决业务任务。这种情况可能源于程序员缺乏经验，或者源于缺乏能够让他们快速处理二级现实的基础设施。在紧迫的截止日期下，有时不得不在完成任务和代码质量之间做出权衡。

忽视编程现实为什么是危险的？好吧，因为它本身就是一种现实，独立于业务中可能发生的现实。无论你是否关注它，这种现实都仍然存在。而且，如果你不关注它，它可能会在复杂性上升级，尤其是在大型代码库中。

例如，如果有太多的异步计算，你可能会发现自己陷入回调地狱的情况。在回调的上下文中，很难追踪程序的执行流程。回调地狱是指你的程序过度依赖回调，以至于开始难以追踪其行为。

当你处理并发程序和多线程计算时，如果你不小心，你可能会陷入竞态条件的情况。或者，你可能会遇到死锁或系统活跃度问题。如果没有特定的技术来处理这些问题，例如 actor 系统，它们可能会产生特别难以调试的 bug。

如果你不在意何时抛出异常和从方法中返回 null，你几乎可以预期每个方法都会抛出异常或返回 null。仅仅通过滥用异常和 null 本身不应该导致有害的 bug，但这仍然会给你带来头疼。

最后，突变是你将要面对的另一个现实。在前几章中，我们讨论了突变如何增加你的心理负担。

之前讨论的几个编程情况展示了我们在前几章中广泛讨论过的心理负担。这是程序运行和编写时的二级现实。程序应该模拟其业务域的现实。然而，当你解决、运行或编写程序时，你会遇到一个完全不同的现实。如果你忽略这个现实，它将用复杂性压倒你，并导致心理超负荷。

考虑以下我们在前几章中遇到的除法函数的例子：

```java
def imperativeDivision(n1: Double, n2: Double): Double =
  if (n2 == 0) throw new RuntimeException("Division by zero!")
  else n1 / n2
```

这里的第一阶现实是算术。这是我们试图建模的业务领域。确切地说，我们模拟了一个数除以另一个数的操作。这就是我们的第一阶现实。

然而，当我们开始编写代码时，我们很快就会遇到第二阶现实。也就是说，除以零的可能性以及需要在程序中处理这种情况的必要性。现在，我们从一个数学世界和我们的主要业务任务转向编程的世界。

处理这种现实的一种天真方式是在除以零的情况下抛出一个异常。然而，如果你没有足够关注第二阶现实，它将产生我们已经讨论过的心理负担。没有任何东西可以警告你错误的可能性。没有任何东西可以强迫你处理它。因此，你需要自己记住所有这些，这增加了你需要记住的程序复杂性。你需要记住的事情越多，做这件事就越困难，出错的可能性就越大。

一个更复杂的程序员在设计程序时会同时考虑第一阶和第二阶现实。他们不仅会建模业务领域；他们还会设计程序，使其执行复杂性不会阻碍可扩展性。可扩展性意味着代码库的大小不会增加单个组件编程的复杂性。

要开发一个高质量的程序，程序员需要特定的工具和方法。函数式编程提供了一种方法。

函数式编程遵循工程的基本原则——抽象出重复的部分。第二阶现实有重复的现象。因此，函数式编程设计了它自己的抽象来处理它们。

同时学习如何描述两种现实比仅学习描述第一阶现实要困难。因此，像 Python 这样的语言比 Java 等语言更容易学习。尽管 Java 不是一种函数式语言，但它也提供了一种基础设施和方法来处理编程的复杂性。同时，Python 专注于速度和原型设计的简便性。此外，Java 比 Scala 简单得多，因为 Scala 提供了更多的抽象以及控制程序两种现实的方法。

虽然学习允许更高质量编程的语言更困难，但它的价值是值得其价格的。你学会了控制第二阶现实的影响。你不仅能够描述你的直接业务领域，还能够描述你的程序是如何运行的。控制复杂性以实现可扩展性和无错误编程的方法是掌握复杂性。

让我们重新审视除以零的例子，但考虑到第二阶现实：

```java
def functionalDivision(n1: Double, n2: Double): Try[Double] =
  if (n2 == 0) Failure(new RuntimeException("Division by zero!"))
  else Success(n1 / n2)
```

首先要注意的是，错误的二阶现实效果用`Try`数据结构来建模。错误处理的概念通过分析`Try`数据结构来建模。它由编译器强制执行——除非你分析数据结构以查找错误，否则你不能访问结果值。因此，复杂性降低了。

在函数式编程中，我们检测到二阶现实的具体现象并创建一个数据结构来封装（具体化）它的模式是典型的。在这本书中，我们将称封装二阶现实现象的数据结构为**效果类型**。

本节的主要目的是从广泛的角度审视副作用，以了解其抽象背后的通用模式。如果你只关注你的业务领域，而忽略了程序的技术现实，后者将创造一个沉重的心理负担。一个复杂的程序员会平等地关注这两种现实。函数式编程允许你充分地处理它们。

# 使用 Monads 的效果序列组合

分析前面的数据结构很麻烦。与分析函数数据结构相关的代码最终发现很难阅读。

然而，在函数式世界中，分析数据结构是一种模式。模式在编程中被抽象出来。

在本节中，我们将查看一些常见的抽象，作为函数式程序员，当与效果类型一起工作时，你将处理这些抽象。

# 引入 map 函数

假设我们需要在自定义除法函数的先前示例的基础上构建另一个函数。该函数由一个参数`x`参数化，并计算表达式`2 / x + 3`。

我们如何用自定义的除法函数来表达它？一种方法是在执行除法后，分析其结果，如果不是错误，则继续进行加法。然而，如果是错误，则返回该错误：

```java
def f1(x: Double): Try[Double] =
divide(2, x) match {
  case Success(res) => res + 3
  case f: Failure   => f
}
```

当我们有一个返回效果类型的计算，并且我们需要用另一个返回未封装在效果类型中的原始值的计算来继续它时，这是函数式编程中的一种常见模式。模式是分析计算返回的结构，提取结果，然后应用第二个计算到这个结果上。

这种模式封装在`map`方法中。大多数效果类型都有在它们上面定义的`map`方法。以下是如何使用`map`方法实现前面示例的示例：

```java
def f1Map(x: Double): Try[Double] =
 divide(2, x).map(r => r + 3)
```

让我们尝试培养对`map`方法的直觉。首先，你可以将`map`方法视为以下高阶函数——`(A => B) => (Try[A] => Try[B])`。这是一个接受`A => B`函数并输出`Try[A] => Try[B]`函数的高阶函数。

这意味着如果你有一个将`A`类型的值转换为`B`类型的值的函数，你也可以有一个将`Try[B]`类型的值转换为`Try[B]`类型的值的函数。你可以将`map`函数视为一个提升，它允许你从在原始值上工作的函数中产生在`Try`效果类型下工作的函数。

# 介绍`flatMap`函数

`flatMap`函数是封装函数式编程模式的一个函数的另一个例子。想象我们需要创建一个函数来计算以下数学表达式：`(2 / x) / y + 3`。让我们尝试使用我们之前定义的除法函数来做这件事：

```java
def f2Match(x: Double, y: Double): Try[Double] =
  divide(2, x) match {
    case Success(r1) => divide(r1, y) match {
      case Success(r2) => Success(r2 + 3)
      case f@Failure(_) => f
    }
    case f@Failure(_) => f
  }
```

代码在这里变得像意大利面一样。首先，我们分析除以`2`的结果。如果成功，我们会将其除以`y`。然后我们分析那个除法的结果，如果没有错误，我们会将`3`加到结果上。

在这里，我们不能再使用`map`函数，因为除以`y`会返回另一个尝试。`map`是一个用于返回原始值的函数的提升，而不是`Try`。如果你觉得这个逻辑很晦涩，鼓励你尝试使用`map`函数实现前面的例子，以查看问题。

`flatMap`函数专门用于这种情况。你可以将其视为一个具有`(A => Try[B]) => (Try[A] => Try[B])`签名的更高阶函数。你可以这样理解它。如果你有一个产生值包裹在`Try`结构中的函数`A => Try[B]`，你可以将其转换成另一个函数`Try[A] => Try[B]`，该函数将原始函数的`A`域提升到`Try[A]`域。这意味着如果原始的`A => Try[B]`函数可以在`A`原始值上使用，新的`Try[A] => Try[B]`函数可以用于`Try[A]`作为其输入。

让我们看看它是如何使用`flatMap`实现的：

```java
def f2FlatMap(x: Double, y: Double): Try[Double] =
  divide(2, x).flatMap(r1 => divide(r1, y))
   .map(r2 => r2 + 3)
```

我们需要从计算`2/x`后得到的`Try`数据结构中提取原始结果，并需要对这个结果进行另一个计算。这个计算，即结果除以`y`，也会产生`Try`。借助`flatMap`，我们可以将`Int => Try[Int]`计算提升为`Try[Int] => Try[Int]`。换句话说，一旦我们计算了`2/x`，我们就可以将其结果除以`y`。

因此，`flatMap`用于需要继续另一个计算的情况，并且这个延续将产生一个`Try`作为其结果。与`map`函数的情况相比，`map`函数要求延续产生一个原始值。`map`和`flatMap`的相应版本也存在于其他效果类型中，例如 Option 或 Future。

在我们分析过的 `map` 和 `flatMap` 签名方面，这里可能有一点令人困惑。签名是函数。它们接受一个函数作为输入，并返回另一个函数作为输出。然而，我们在 `Try` 对象上调用的 `map` 和 `flatMap` 方法并不返回函数，而是返回 `Try` 对象。然而，正如我们之前讨论的，我们的 `map` 和 `flatMap` 签名都返回一个 `Try[A] => Try[B]` 函数。

在函数式编程的世界里，我们脱离面向对象编程的上下文来看待函数。Scala 是一种方便的语言，因为它结合了面向对象和函数式编程方法。因此，像 `flatMap` 或 `map` 这样的函数被定义为 `Try` 类的方法。然而，在函数式编程中，通过脱离面向对象编程的上下文，我们能更好地理解函数的本质。在函数式编程中，它们不被视为任何类的成员。它们是转换数据的方式。

假设你有一个定义为某个 `Dummy` 类成员的函数：

```java
class Dummy(val id: Int) {
  val f: Int => String = x => s"Number: $x; Dummy: $id"
}
```

函数 `f` 接受一个 `Int` 类型的参数，并输出一个 `String` 类型的结果。它的签名是 `Int => String`。这个签名是函数在 `Dummy` 类内部定义时的签名。然而，请注意，由于它是在 `Dummy` 对象内部定义的，因此该对象的上下文总是隐含的。我们可以在函数内部执行计算时使用封装对象的的数据。

如果我们决定将这个函数移出类的范围，会发生什么？`Int => String` 签名是否仍然反映了函数的本质？我们能否以这种方式实现它？考虑以下：

```java
// val f: Int => String = x => s"Number: $x; Dummy: $id"  // No `id` in scope, does not compile
```

答案是否定的，因为我们现在没有所需的类上下文。前面的代码会产生编译时错误。如果我们将函数移出类的范围，我们需要用 `Dummy => (Int => String)` 签名来定义它。也就是说，如果我们有一个 `Dummy` 对象，我们可以定义一个从 `Int` 到 `String` 的函数，并在这个对象上下文中实现它：

```java
val f1: Dummy => (Int => String) = d => (x => s"Number: $x; Dummy: ${d.id}")
```

注意，也可以以另一种方式实现，`Int => (Dummy => String)`，而不影响语义：

```java
val f2: Int => (Dummy => String) = x => (d => s"Number: $x; Dummy: ${d.id}")
```

这个想法在分析 `map` 和 `flatMap` 签名时得到了应用。

# 摘要

在本章中，我们学习了副作用背后的哲学。我们发现，在解决业务领域问题的过程中，程序员最终会进入一个与业务逻辑不同的现实。你编写程序和运行时发生的现象构成了一个自己的现实。如果你忽略它，后者的现实可能会变得复杂，这会导致心理负担。

函数式编程通过提供将现象具体化为效果类型并在数据结构和纯函数的语言中定义它们行为的技巧，允许你通过解决二阶现实问题。

效果类型减轻了你的心理负担，因为它们消除了记住程序中发生的所有现象的必要性，即使这些现象超出了你当前可能正在查看的代码的作用域。

效果类型也会迫使编译器让你处理这类现象。使用效果类型很快就会变得相当冗长。因此，存在像`map`和`flatMap`这样的函数来抽象处理涉及效果类型的常见场景。

# 问题

1.  编程时，程序员需要考虑哪些现实？

1.  纯函数式编程如何解决二阶现实中的复杂性问题？

1.  在我们的程序中考虑二阶现实有哪些好处？
