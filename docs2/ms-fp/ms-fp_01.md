# 声明式编程风格

声明式编程与函数式编程紧密相连。现代函数式语言更喜欢将程序表达为代数而不是算法。这意味着函数式语言中的程序是某些原语与运算符的组合。通过指定要做什么而不是如何做来表达程序的技术被称为声明式编程。我们将探讨为什么声明式编程出现以及它可以在哪里使用。

在本章中，我们将涵盖以下主题：

+   声明式编程原理

+   声明式与命令式集合的比较

+   其他语言中的声明式编程

# 技术要求

要运行本书中的示例，您需要以下软件以及对其基本使用方法的理解：

+   Docker 版本 18.06 或更高：[`www.docker.com/`](https://www.docker.com/)

+   Git 版本 2.18.0 或更高：[`git-scm.com/`](https://git-scm.com/)

要运行示例：

1.  在您的机器上克隆 [`github.com/PacktPublishing/Mastering-Functional-Programming`](https://github.com/PacktPublishing/Mastering-Functional-Programming) 仓库。

1.  从其根目录开始，运行 `docker-compose.yml` 中指定的 Docker 镜像集。如果您在 Linux/Mac 机器上，可以运行 `./compose.sh` 来完成此步骤。如果您在 Windows 上，请在文本编辑器中打开 `compose.sh` 并手动从终端运行每个命令。

1.  在名为 `mastering-functional-programming_backend_1` 的 Docker 服务上运行 Shell（Bash）。您可以通过在 Linux/Mac 机器上的单独终端窗口运行 `./start.sh` 来完成此步骤。如果您在 Windows 机器上，请运行 `docker exec -ti mastering_backend bash`。然后 `cd Chapter1` 以访问第一章的示例，或 `cd ChapterN` 以访问第 N 章的示例。

1.  `cpp` 文件夹包含 C++ 源代码。您可以从该目录使用 `./run.sh <源代码名称>` 来运行它们。

1.  `jvm` 文件夹包含 Java 和 Scala 源代码。您可以从该目录运行 `sbt run` 来运行它们。

注意，在 Docker 下运行示例是必要的。某些章节的示例会针对实时数据库运行，该数据库由 Docker 管理，因此请确保上述步骤正常工作。

本书中的代码可在以下网址找到：[`github.com/PacktPublishing/Mastering-Functional-Programming`](https://github.com/PacktPublishing/Mastering-Functional-Programming)

# 声明式编程原理

为什么是声明式编程？它是如何出现的？要理解声明式编程，我们首先需要了解它与命令式编程的不同之处。长期以来，命令式编程一直是事实上的行业标准。是什么促使人们开始从命令式风格转向函数式风格？

在命令式编程中，你依赖于语言提供的一组原语。你以某种方式将它们组合起来，以实现你需要的功能。我们可以在原语下理解不同的事物。例如，这些可以是循环控制结构，或者，在集合的情况下，特定的集合操作，如创建集合和向集合中添加或删除元素。

在声明式编程中，你也依赖于原语。你使用它们来表达你的程序。然而，在声明式编程中，这些原语与你的领域更接近。它们可以接近到语言本身可以被视为**领域特定语言**（**DSL**）。通过声明式编程，你可以在进行过程中创建原语。

在命令式编程中，你通常不会创建新的原语，而是依赖于语言为你提供的原语。让我们通过一些例子来了解声明式编程的重要性。

# 示例 – `go-to`与循环的比较

通过例子最好地理解命令式如何转变为声明式。你很可能已经知道`go-to`语句。你听说过使用`go-to`语句是不良的做法。为什么？考虑一个循环的例子。可以使用仅使用`go-to`语句来表达循环：

```java
#include <iostream>
using namespace std;
int main() {
  int x = 0;    
  loop_start:
   x++;
  cout << x << "\n";
  if (x < 10) goto loop_start;
  return 0;
}
```

从前面的例子中，想象你需要表达一个`while`循环。你有一个变量`x`，你需要通过循环每次增加一，直到它达到`10`。在现代语言如 Java 中，你将能够使用`while`循环来完成这个操作，但也可以使用`go-to`语句来完成。例如，可以在`increment`语句上有一个标签。在它之后的条件语句将检查变量是否达到了必要的值。如果没有，我们将执行`go-to`到增加变量的代码行。

为什么在这种情况下`go-to`是不良风格？循环是一个模式。模式是在你的代码中重复出现在不同程序位置的逻辑元素的排列。在我们的情况下，模式是循环。为什么它是模式？首先，它由三个部分组成：

1.  第一部分是标签，它是循环体的入口点——你从循环的末尾跳转回来重复循环的点。

1.  第二部分是循环必须满足的条件，以便循环可以重复执行。

1.  第三部分是重申这是一个循环的语句。它是循环体的结束。

除了由三个部分组成之外，它还描述了编程中普遍存在的动作。这个动作是重复执行代码块多次。循环在编程中的普遍性无需解释。

如果你每次需要循环模式时都重新实现它，事情可能会出错。由于这个模式由多个部分组成，它可能会因为误用其中一个部分而损坏，或者你可能在将部分组合成一个整体时出错。你可能会忘记命名要跳转的标签，或者错误地命名它。你也可能忘记定义保护跳转到循环开始处的`predicate`语句。或者，你可能在`q`语句本身中漏掉或拼写错误要跳转的标签。例如，在以下代码中，我们忘记了指定谓词保护：

```java
int main() {
 int x = 0;
 loop_start:
  x++;
 cout << x << "\n";
 goto loop_start;
 return 0;
}
```

# 示例 - 嵌套循环

要在这样一个简单的例子中出错是非常困难的，但考虑一个嵌套循环。例如，你有一个矩阵，你想要将其输出到控制台。这可以通过一个`嵌套`循环来完成。你有一个循环来遍历二维数组的每个条目。另一个嵌套在这个循环中的循环检查外层循环当前正在处理的行。它遍历该行的每个元素并将其打印到控制台。

这些也可以用`go-to`语句来表示。因此，你将有一个标签来表示大循环的入口点，另一个标签来表示小循环的入口点，你将在每个循环的末尾调用`go-to`语句以跳转到相应循环的开始。

让我们看看如何做到这一点。首先，让我们定义一个二维数组如下：

```java
 int rows = 3;
 int cols = 3;
 int matrix[rows][cols] = {
   { 1, 2, 3 },
   { 4, 5, 6 },
   { 7, 8, 9 }
 };
```

现在，我们可以这样遍历它：

```java
 int r = 0;
 row_loop:
 if (r < rows) {
  int c = 0;
   col_loop:
   if (c < cols) {
  cout << matrix[r][c] << " ";
     c++;
     goto col_loop;
   }
   cout << "\n";
   r++;
   goto row_loop;
 } return 0;}
```

你已经可以看到复杂性在这里有所增加。例如，你可以从内循环的末尾跳转到外循环的开始。这样，只有每一列的第一个条目会收到输出。程序变成了一个无限循环：

```java
 int r = 0;
 row_loop:
 if (r < rows) {
   int c = 0;
  col_loop:
  if (c < cols) {
    cout << matrix[r][c] << " ";
     c++; 
    goto row_loop;
  }
  cout << "\n";
   r++;
   goto row_loop;
 }
```

# 不要重复自己 (DRY)

工程学的基本规则之一是为重复的逻辑创建抽象。循环的模式无处不在。你几乎可以在任何程序中体验到它。因此，进行抽象是合理的。这就是为什么当代语言，如 Java 或 C++，都有自己的内置循环机制。

它带来的不同之处在于，现在整个模式只由一个组件组成，即必须与特定语法一起使用的关键字：

```java
#include <iostream>
using namespace std;
int main() {
  int rows = 3;
  int cols = 3;
  int matrix[rows][cols] = {
    { 1, 2, 3 },
    { 4, 5, 6 },
    { 7, 8, 9 }
  };
  for (int r = 0; r < rows; r++) {
    for (int c = 0; c < cols; c++) cout << matrix[r][c] << " ";
    cout << "\n";
  }
}
```

这里发生的事情是我们给这个模式起了一个名字。每次我们需要这个模式时，我们不需要从头开始实现它。我们通过它的名字来调用这个模式。

这种通过名字调用是声明式编程的主要原则：实现只重复一次的模式，给这些模式命名，然后在我们需要的地方通过名字来引用它们。

例如，`while` 或 `for` 循环是循环的模式。它们被抽象出来，并在语言级别上实现。程序员可以在需要循环时通过它们的名称来引用它们。现在，犯错的几率大大降低，因为编译器知道这个模式。它将在编译时检查你是否正确地使用了这个模式。例如，当你使用 `while` 语句时，编译器将检查你是否提供了一个合适的条件。它将为你执行所有的跳转逻辑。

因此，你无需担心是否跳到了正确的标签，或者是否完全忘记了跳转。因此，你不可能从内循环的末尾跳转到外循环的开始。

你在这里看到的是从命令式到声明式的转变。你需要理解的概念是，我们使编程语言意识到某个模式。编译器被迫在编译时验证模式的正确性。我们指定了一次模式。我们给它一个名字。我们使编程语言对使用这个名称的程序员施加某些约束。同时，编程语言负责模式的实现，这意味着程序员不需要关心实现模式所使用的所有算法。

因此，在声明式编程中，我们指定需要做什么，而不指定如何做。我们注意到模式并给它们命名。我们实现这些模式一次，并在需要使用它们时通过名称调用它们。实际上，现代语言，如 Java、Scala、Python 或 Haskell，都没有 `go-to` 语句的支持。看起来，用 `go-to` 语句表达的大多数程序都可以转换成一系列模式，如循环，这些模式抽象掉了 `go-to` 语句。程序员被鼓励通过名称使用这些高级模式，而不是自己使用低级的 `go-to` 原语来实现逻辑。接下来，让我们通过声明式集合的例子来看这个想法是如何进一步发展的，以及它们与命令式集合有何不同。

# 声明式与命令式集合

声明式风格如何工作的另一个很好的例子可以在集合框架中看到。让我们比较命令式编程语言和函数式编程语言的集合框架，例如，Java（命令式）集合和 Scala（函数式）集合。

为什么需要一个集合框架？在任何编程项目中，集合无处不在。当你处理一个由数据库支持的应用程序时，你正在使用集合。当你编写一个网络爬虫时，你正在使用集合。实际上，当你处理简单的文本字符串时，你也在使用集合。大多数现代编程语言都将集合框架的实现作为其核心库的一部分提供给你。这是因为你几乎需要它们来完成任何项目。

我们将在下一章更深入地探讨命令式集合与声明式集合的不同之处。然而，为了概述的目的，让我们简要地讨论命令式和声明式集合方法之间的一项主要差异。我们可以通过过滤的例子看到这种差异。过滤是一个无处不在的操作，你很可能经常会这样做，所以让我们看看这两种方法之间的差异。

# 过滤

Java 是一个非常命令式编程方法的经典例子。因此，在其集合中，你会遇到典型的命令式编程操作。例如，假设你有一个字符串数组。它们是你公司员工的姓名。你想要创建一个单独的集合，只包含那些以字母 `'A'` 开头的员工姓名。在 Java 中你该如何做？

```java
// Source collection
List<String> employees = new ArrayList<String>();
employees.add("Ann");
employees.add("John");
employees.add("Amos");
employees.add("Jack");
// Those employees with their names starting with 'A'
List<String> result = new ArrayList<String>();
for (String e: employees)
  if (e.charAt(0) == 'A') result.add(e);
   System.out.println(result);
```

首先，你需要创建一个单独的集合来存储你的计算结果。因此，我们创建一个新的字符串 `ArrayList`。之后，你需要检查每个员工的姓名，以确定它是否以字母 `'A'` 开头。如果是，将这个姓名添加到新创建的数组中。

可能会出什么问题？第一个问题是你要存储结果的集合。你需要调用 `result.add()` 来添加到集合中——但如果你有几个集合，你可能会添加到错误的集合中？在那个代码行，你可以自由地添加到任何集合，所以可以想象你会添加到错误的集合——而不是你专门为过滤员工而创建的集合。

这里可能出现的另一个问题是，你可能会忘记在大型循环中编写 `if` 语句。当然，在这样一个简单的例子中，这种情况不太可能发生，但请记住，大型项目可能会膨胀，代码库可能会变得很大。在我们的例子中，循环体少于 10 行。但如果你有一个代码库，其中的 `for` 循环长达 50 行，例如？在那里，你不会忘记编写你的谓词，或者将字符串添加到任何集合中，这一点并不明显。

这里的要点是我们有与`loop`与`go-to`示例中相同的情况。我们在代码库中有一个在集合上执行的操作模式，这个模式可能会重复。模式是由多个元素组成的，其过程如下。首先，我们创建一个新的集合来存储我们计算的结果。其次，我们有一个循环，它遍历我们集合中的每个元素。最后，我们有一个谓词。如果它是真的，我们将当前元素保存到结果集合中。

我们可以想象同样的逻辑也可以在其他上下文中执行。例如，我们可以有一个数字集合，并希望只取那些大于`10`的数字。或者，我们可以有一个包含我们网站所有用户的列表，并希望取那些在特定年份访问网站的用户的年龄。

我们刚才讨论的特定模式被称为过滤模式。在 Scala 中，每个集合都支持一个定义在其上的方法，该方法抽象了过滤模式。这是通过以下方式实现的：

```java
// Source collection
val employees = List(
  "Ann"
, "John"
, "Amos"
, "Jack")
// Those employees with their names starting with 'A'
val result = employees.filter ( e => e(0) == 'A' )
println(result)
```

注意，操作保持不变。我们需要创建一个新的集合，然后根据某些谓词将旧集合中的元素合并到新集合中。然而，在纯 Java 解决方案的情况下，我们需要执行三个单独的操作来得到期望的结果。然而，在 Scala 声明式风格的情况下，我们只需要指定一个动作：模式的名称。模式是在语言内部实现的，我们不需要担心它是如何实现的。我们有一个精确的关于它是如何工作以及它做了什么的说明，并且我们可以依赖它。

这里的优势不仅在于代码变得更易于阅读，因此也更容易推理。它还增加了可靠性和运行时性能。原因是这里的过滤模式是 Scala 核心库的一个成员。这意味着它经过了良好的测试。它已经在许多其他项目中使用过。在这种情况下可能存在的微妙错误很可能已经被捕捉并修复。

还要注意，匿名 lambda 的概念在这里被引入了。我们将一个 lambda 作为参数传递给`filter`方法。它们是内联定义的函数，没有通常繁琐的方法语法。匿名 lambda 是函数式语言的一个常见特性，因为它们增加了你抽象逻辑的灵活性。

# 其他语言中的声明式编程

在其他现代语言中，如 Haskell 或 Python，类似的声明式功能也是现成的。例如，你可以在 Python 中执行过滤操作——它是语言的一部分，并且在 Haskell 中有一个特殊的功能来执行相同的过滤操作。此外，Python 和 Haskell 的函数式特性使得自己实现相同的控制结构（如过滤）变得容易。Haskell 和 Python 都支持 lambda 函数和高阶函数的概念，因此它们可以用来实现声明式控制结构。

通常，你可以通过查看语言提供的功能来识别一个语言是否适合声明式编程。你可以寻找的一些特性包括匿名函数、函数作为一等公民和自定义操作符指定。

匿名 lambda 函数给你带来了很大的优势，因为你可以直接将函数传递给其他函数，而不必先定义它们。这在指定控制结构时尤其有用。以这种方式表达的功能，首先和最重要的是，用于指定一个将输入转换为输出的转换。

你可以在编程语言中寻找的另一个特性是支持函数作为一等公民。这意味着你能够将一个函数赋值给一个变量，通过该变量的名称引用函数，并将该变量传递给其他函数。将函数视为普通变量可以使你达到一个新的抽象层次。这是因为函数是转换；它们将输入值映射到某些输出值。而且，如果语言不允许你将转换传递给其他转换，这将是灵活性的限制。

你可以从声明式语言中期待的一个特性是，它们允许你创建自定义操作符；例如，Scala 中可用的合成糖允许你非常容易地定义新的操作符，就像类中的方法一样。

# 摘要

声明式风格是一种编程风格，其中你通过名称调用你想要执行的操作，而不是通过编程语言提供的底层原语以算法方式描述如何执行它们。这自然符合 DRY 原则。如果你有一个重复的操作，你想要将其抽象化，然后在以后通过名称引用它。换句话说，你需要声明该操作有一个特定的名称。而且，每次你想使用它时，你都需要声明你的意图，而不直接指定它应该如何实现。

现代函数式编程与声明式风格相辅相成。函数式编程为你提供了一个更好的抽象层次，可以用来抽象化重复的操作。

在下一章中，我们将看到函数作为一等公民的支持如何对声明式编程风格有益。

# 问题

1.  声明式编程背后的原则是什么？

1.  DRY 代表什么？

1.  为什么使用`goto`是坏风格？
