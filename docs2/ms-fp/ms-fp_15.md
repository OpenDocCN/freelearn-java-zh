# 第十五章：评估

# 第一章

1.  指定你想做什么，而不指定如何确切地做。

1.  不要重复自己。

1.  Goto 是一个较低级的原语，用于构建高级逻辑。所有可以用 goto 实现的逻辑都可以用循环和其他控制结构实现。声明你想要一段代码循环执行，排除了如果你尝试通过 goto 实现该循环时可能出现的错误。

# 第二章

1.  作为它们对象的行为。

1.  作为数学函数。基于一些输入值计算值而不产生副作用。

1.  接受其他函数作为输入的函数。

1.  一个应用是编写控制结构。

# 第三章

1.  你使用在命令式集合中定义的低级操作来指定需要算法执行的任务。

1.  你使用在函数式集合中定义的高级操作将你的程序指定为一个表达式。

1.  你可能需要的所有算法都已经在前端框架中实现。你只需要在需要时按名称调用它们。你可能想要编写的所有程序都可以表达为框架中实现的高级操作的组合。

1.  将程序视为一个数学表达式，而不是一个算法。表达式是一个由操作符（行为）连接的操作数（数据）的结构。

1.  对程序员心智的负担更小。代数程序通常从方程中移除副作用，如错误或时间。因此，你不需要考虑它们。这与命令式程序形成对比，在命令式程序中，副作用是自由发生的，你需要记住所有这些副作用。

1.  它们具体化了副作用。具体化意味着将现象转化为数据。例如，我们可以在方法中返回一个包含异常对象的数据结构，而不是抛出异常（现象）。

# 第四章

1.  对于这本书，副作用被定义为对当前逻辑单元（函数）作用域之外的环境的修改和交互。

1.  是可以被程序改变的数据。

1.  它们会在你的脑海中增加额外的认知负担，这可能导致错误。与副作用和可变状态相关的事情还有很多需要记住。你的注意力范围必须远远超出你目前正在工作的逻辑部分。

1.  是一个不产生任何副作用的函数。

1.  能够在代码中用函数调用的结果替换对函数的调用，而不改变代码的语义。

1.  减少你面临的认知负担。因此，减少出现错误的可能性。

1.  错误、结果缺失、延迟竞争、日志记录、输入输出操作。

1.  是的，是这样的。在纯函数式风格中编程只是理解副作用的概念，理解它们是如何有害的，能够看到代码中的副作用及其危害，以及如何抽象它们的知识。在现代命令式编程语言中，可以编写用于副作用抽象的抽象。

1.  它是支持你的基础设施的存在。你可能需要的绝大多数抽象在语言中已经存在。大多数库都是函数式的。社区也倾向于函数式风格。

# 第五章

1.  第一阶现实是他们业务领域的现实。业务领域的现实是编程解决他们业务任务的现实。第二阶现实是编写和运行程序的现实。

1.  它提供了一套技术来抽象掉第二阶现实的现象。首先，你需要识别一个重复的现象。然后，你需要创建一个数据结构来抽象掉这个现象。想法是通过描述它们来抽象掉现象，而实际上并不让它们发生。

1.  对程序运行方式和代码库结构的控制。如果缺乏控制，第二阶现实的复杂性可能会压倒你，造成心理负担。

# 第六章

1.  异步计算。

1.  Try 将错误情况表示为异常。在函数式环境中，异常可能并不总是期望的，因为它们只有在我们要抛出它们时才有意义。函数式编程不鼓励抛出异常，因为它们是副作用。因此，我们有一个更通用的类型叫做 Either，它能够表示两个值之间的替代。

1.  函数式编程中表示依赖注入的一种方式是通过 Reader 类型。它是对这样一个事实的抽象：一个计算依赖于某些值，没有它无法执行。Reader 基本上是一个函数。然而，它有一个更简洁的签名，并且将 flatmap 的概念应用于它，就像应用于任何其他效果类型一样。

1.  Flatmap 允许你按顺序组合使用效果类型表示副作用的效果计算。

# 第七章

1.  在 Scala 中，Rich Wrapper 是一种模式，允许你模拟将方法注入到类中。

1.  该模式在 Scala 中使用隐式转换机制实现。每次你尝试在缺少该方法的类上调用方法时，编译器都会尝试将该类的实例转换为具有该方法的另一个类的实例。

1.  请参阅第七章直觉部分的解释。

1.  类型类模式背后的动机是将效果类型与其行为分离，以便能够根据执行函数式编程时出现的不同场景定义新的行为并将它们注入到现有的类型类中。

1.  是的，命令式语言确实有类型类。然而，通常它们缺乏方便使用的机制。

# 第八章

1.  类型类在项目之间重复。因此，将它们统一到库中是有意义的。

1.  `foldLeft`, `foldRight`, `traverse`.

1.  一系列有影响计算的组合。

1.  `flatMap`、`pure`、`tailRecM`。

1.  两个计算的顺序组合，其中一个依赖于另一个的结果。

1.  核心包包含类型类，`syntax` 包包含丰富的包装器，可以将语法注入到效果类型中，`instances` 包包含某些效果类型的类型类实现，`data` 包包含用于函数式编程的效果类型。此外，Cats 还有一些用于书中未讨论的更具体任务的辅助包。请参阅 Cats 文档了解这些信息。

# 第九章

1.  阻塞计算在需要等待某些事件发生时将阻塞它们所使用的线程。非阻塞计算在不需要时释放线程。释放的线程可以被其他任务重用。

1.  你需要异步编程，以便线程可以利用进行有用的工作，而不是等待事件发生。

1.  你可以将业务逻辑与并发执行策略分开。

1.  `IO` 是一种封装延迟计算副作用的效果类型。它使用计算作为值的方法，因此是对要执行的计算的规范。

1.  使用 `start` 从单调流异步启动 `IO`。使用 `flatMap` 顺序组合 `IO`。请参阅 `IO` 的 API 文档以获取完整列表。

# 第十章

1.  Monad Transformers 用于将两种效果类型组合成一种。

1.  无标签最终允许延迟选择效果类型，并使用该效果类型必须具备的能力来组合程序。

1.  类型级计算允许在编译时识别更多错误，从而提高编译时安全性。

# 第十一章

1.  每当线程需要访问非线程安全资源时，它都会对这个资源采取监视器。监视器保证只有拥有这个监视器的线程可以与其资源一起工作。

1.  死锁是一种情况，当两个线程依赖于另一个线程的进度，并且它们中的任何一个都不能在没有另一个线程之前进展。因此，两个线程都停滞不前。请参阅第十一章了解死锁如何发生的一个示例。

1.  一个 actor 是一个并发原语。它有一个邮箱，它可以接受来自其他 actor 的消息。它可以向其他 actor 发送消息。它是在其他 actor 的消息反应的术语中定义的。一个 actor 一次只能处理一个消息。保证如果一个 actor 拥有非线程安全资源，则不允许其他 actor 拥有它。

1.  由于只有一个 actor 控制一个非线程安全资源，因此不存在竞态条件或死锁的危险。每当其他 actor 需要访问相关资源时，它们会通过请求拥有该资源的 actor 来访问。操作由资源的所有者 actor 间接执行，资源本身永远不会暴露给外部世界。

# 第十二章

1.  使用 Actor 进行封装——可变状态只能从一个 actor 或一个线程中访问。Actor 以层次结构组织，父母监督子女以实现容错性。

1.  我们通过扩展`Actor`类并实现`receive`方法来实现这一点。

1.  我们通过在`ActorSystem`或`ActorContext`上调用`actorOf`方法来实现这一点。

1.  在`ActorRef`上使用`!`运算符——`targetActor ! message`。

1.  `!`运算符实现了`fire-and-forget`类型的消息发送。它发送消息后立即返回。询问模式涉及使用`?`运算符发送消息，该运算符返回一个`Future[Any]`，该`Future`将在目标 actor 响应后完成——`val futureMessage: Future[Any] = targetActor ? message`。

1.  管道模式指示`Future`在`Future`的计算完成后向 actor 发送消息——`future pipeTo targetActor`。
