# 副作用的难题

纯函数编程全部关于移除副作用和突变。我们这样做是有原因的。在本章中，我们将看到共享可变状态和有副作用的函数如何引起问题，以及为什么最好减少它们。

讨论的主题如下：

+   副作用

+   可变状态

+   纯函数

+   通常遇到的副作用

+   不同编程语言中的纯函数范式

# 副作用

那么，副作用究竟是什么，为什么应该避免它们？为了这次讨论，我们可以将副作用定义为函数代码中的一些指令，这些指令修改了函数作用域之外的环境。最常见的副作用例子是程序抛出的异常。抛出异常是一种副作用，因为如果你不处理它，它将破坏函数作用域之外程序的行为。所以程序将在这一点上崩溃，并停止执行。

以上一章中的*碳酸饮料机*示例为例。模拟投币功能的函数如果投币机中没有碳酸饮料罐，则会抛出异常。所以如果你尝试在一个空碳酸饮料机上调用这个函数，你的程序将永远不会通过函数调用点，因为会抛出异常。除非你在同一个调用点使用`try`语句来处理这个异常。注意，这会把处理副作用的责任放在客户端，这可能不是我们想要做的。

你还会遇到另一个副作用，即函数返回 null。例如，你有一个用户数据库。你可以添加一个函数，该函数查询数据库并根据 ID 返回用户：

```java
case class User(name: String)
def getUser(id: Int): User =
 if (Set(1, 2, 3).contains(id)) User(s"User-$id")   
 else null
```

有时这个函数会被调用，传入的用户 ID 在数据库中不存在。对于数据不存在的问题，传统的 Java 解决方案是返回 null。快速返回 null 会迅速产生问题。它违反了调用此函数的程序员对结果的预期。函数的返回类型被设置为`User`。程序员有理由期望从这个函数中得到一个`User`类型的对象。因此，他们可能会尝试调用该对象的某些`User`方法：

```java
println(getUser(1 ).name)  // User-1
println(getUser(10).name)  // NullPointerException
```

在 null 对象上调用`User`类型的方法会导致空指针异常，除非你首先验证该对象不是 null。

这里的问题之一是副作用在函数的签名中没有任何体现。此外，它们的处理也不是由编译器强制执行的。当然，在 Java 中，你需要在它们的签名中声明函数抛出的某些异常。然而，这已被证明是一个糟糕的设计决策，并且大多数语言都不要求这种声明。此外，即使在 Java 中，也没有声明指定函数可以返回 null。除非程序员记得程序中存在这样的副作用，否则他们可能不会处理它们。所以除非他们处理了副作用，否则程序可能会出错。

这里主要的问题是给程序员带来了额外的心理负担。他们需要不断地记住他们函数可能产生的所有副作用。因为如果不这样做，他们也可能忘记正确处理它们。因此，他们的代码可能会引入错误。这个问题是由编译器不强制处理副作用造成的。副作用是代码在运行时产生的一些现象。这些现象是局部函数在未在函数类型中明确声明的情况下，影响或被外部环境影响的结果。这些影响可能由函数代码生成，这取决于它在运行时接收到的输入值。编译器对此一无所知。例如，函数返回 null 的现象，或者异常发生导致程序在那个点中断。这些事情发生在运行时。在编译时，编译器不会检查它们是否得到了适当的处理。

# 可变状态

简单来说，可变状态是可以更改的数据。例如，在某个时间点，你可能会读取某个变量，*x*，并发现它指向某些数据。在另一个时间点，你可能会从同一个变量读取不同的值。值的不同是因为变量是可变的，程序的其他部分对其进行了修改。

让我们来探讨为什么可变状态并不理想。想象一下你有一个在线游戏。它依赖于多个线程，所选择的并发架构是演员模型。你有一个演员，其任务是跟踪当前游戏中存在的用户。跟踪可以通过在演员内部实现一个可变集合来完成。用户通过向这个演员发送消息来登录和退出游戏。因此，每次登录消息到达演员时，用户就会被添加到已登录用户列表中。当用户想要退出时，他们就会被从列表中移除：

```java
class GameState(notifications: ActorRef) extends Actor {
  val onlineUsers = collection.mutable.ListBuffer[User]()
  def receive = {
    case Connect   (u) => onlineUsers += u
    case Disconnect(u) => onlineUsers -= u
    case Round         => notifications ! RewardWinners(onlineUsers)
  }
}
```

现在，想象一下你想找到达到特定分数的用户，并通过电子邮件通知他们。你可能想在每一轮结束时（假设这是一个基于轮次的游戏）这样做，这可以通过发送另一个消息到`GameState`演员来实现。实现这一目标的一种方法是将所有用户的列表发送到一个单独的通知演员，由它来完成这项工作：

```java
case Round => notifications ! RewardWinners(onlineUsers)
```

让我们假设查找和通知用户的工作需要一段时间才能完成。我们可以通过`Thread.sleep(1000)`语句来模拟延迟。这个语句在调用它的那一行暂停当前线程的执行，持续 1,000 毫秒或 1 秒。让我们看看它是如何工作的：

```java
class NotificationsActor extends Actor {
  def receive = {
    case RewardWinners(users) =>
     Thread.sleep(1000)
    val winners = users.filter(_.score >= 100)
    if (winners.nonEmpty) winners.foreach { u =>
      println(s"User $u is rewarded!") }
    else println("No one to reward!")
  }
}
```

通信协议定义如下：

```java
sealed trait Protocol
case class   Connect (user : User      ) extends Protocol
case class   Disconnect (user : User      ) extends Protocol
case class   RewardWinners(users: Seq[User]) extends Protocol
case object  Round                    extends Protocol
```

现在，让我们假设以下环境：

```java
val system = ActorSystem("GameActors")
val notifications = system.actorOf(Props[NotificationsActor], name = "notifications")
val gameState     = system.actorOf(Props(classOf[GameState], notifications), name = "gameState")
val u1 = User("User1", 10)
val u2 = User("User2", 100)
```

我们有一个演员系统，一个用于游戏状态的演员和一个用于通知的演员。此外，我们有两个用户。第二个用户`User2`是一个*获胜*用户，因为他们的分数`>= 100`。考虑一下，如果一个*获胜*用户在完成回合后立即注销会发生什么：

```java
gameState ! Connect(u1)
gameState ! Connect(u2)
gameState ! Round
gameState ! Disconnect(u2)
```

这样的用户将不会收到通知。问题出在这里，因为我们发送给负责通知的演员的集合是可变的。它被`GameState`演员和`NotificationActor`共享。这意味着一旦用户注销，他们就会被`GameState`演员从集合中移除，这也意味着它也将从`NotificationActor`的集合中被移除，因为它们是同一个集合。

上述示例演示了共享可变状态在实际操作中存在的问题。再次强调，这给程序员带来了额外的心理负担。如果你有一个与其他线程共享的对象，你不能再仅在一个线程的范围内进行推理。你必须扩大你的推理范围，涵盖所有拥有此对象的所有线程。因为就你所知，共享的可变对象可以随时被更改。演员模型旨在帮助你像你的程序是单线程的且没有其他线程存在一样进行推理。然而，如果你继续使用共享可变状态，它将不会有所帮助。

管理共享可变状态的传统方法是用锁和监视器。其背后的原理是，正在对对象进行修改的线程应该在一些监视器上获取锁，这样在它处理对象时，其他人将无法执行修改。然而，这并没有从程序员的心理负担中解脱出来。你仍然需要考虑除了你当前正在编写的线程之外的其他线程。在实践中，调试涉及并发和共享可变状态的程序是困难的。

# 纯函数

在前面的章节中，我们向您展示了突变和副作用如何使代码更难阅读和编写。在本节中，我们将介绍纯函数的概念，即不产生副作用的函数。这是纯函数式编程的核心。函数式范式规定，你应该使用不产生任何副作用的函数来表达你的程序。你将如何使用纯函数来模拟需要抛出异常的情况？以熟悉的*饮料机*示例为例。

这是我们在之前关于副作用讨论中遇到的*Soda Machine*示例的略微简短版本：

```java
var cans = 0
def insertCoin(): SodaCan =
  if (cans > 0) { cans -= 1; new SodaCan }
  else throw new RuntimeException("Out of soda cans!")
println(insertCoin())
```

我们可以通过返回另一个数据结构包装的结果来避免从函数中抛出异常：

```java
def insertCoin(): Try[SodaCan] = Try {
  if (cans > 0) { cans -= 1; new SodaCan }
  else throw new RuntimeException("Out of soda cans!")
}
```

在我们的例子中，我们不是返回一个纯结果，而是以`Try`的结果形式返回一个封装的结果。`Try`的行为是在其体内捕获抛出异常的可能性以进行进一步处理。正如前几章所讨论的，`Try`是一个可以包含值或异常的数据结构。因此，如果自动售货机没有罐装饮料了，我们不再抛出异常。我们从函数中返回一个错误已发生的消息。

与比较分析相比，这里的优势如下。在这个函数中不再会有意外的副作用发生。一个可能发生的错误不再会中断整个程序的流程。此外，函数的调用站点用户必须处理错误才能访问结果。因为结果被包装进数据结构中，除非我们首先解包它所包装的数据结构，否则我们无法访问那个结果。

我们可以通过分析返回的确切内容来访问结果。如果它是一个值，我们知道没有发生错误。如果它是一个异常，我们知道我们需要处理它。在这个时候，我们可以这样说，编译器强制处理错误。错误可能发生的事实反映在函数的返回类型中。因此，在返回后直接使用返回值不再可行。如果你试图在不首先处理错误可能性的情况下直接使用它，你将得到一个编译时错误。因为你将尝试使用`Try`数据结构，就像它是它所包装的类型一样。

纯函数编程的另一个特点是它避免了使用可变数据结构。让我们再次看看演员之间交换数据的例子。如果我们不是交换一个可变数据结构，而是交换一个不可变数据结构，比如不可变列表，会怎样？看看下面的例子：

```java
class GameState(notifications: ActorRef) extends Actor {
  var onlineUsers = List[User]()
  def receive = {
    case Connect   (u) => onlineUsers :+= u
    case Disconnect(u) => onlineUsers = onlineUsers.filter(_ != u)
    case Round         => notifications ! RewardWinners(onlineUsers)
  }
}
```

如你所回忆的，在前一个例子中，我们遇到了`NotificationActor`试图使用列表时列表被另一个线程修改的问题。现在，如果我们用不可变列表代替可变列表，由于不可变数据结构不能被修改，因此从另一个线程的修改问题就会自行消失。一个不可变的数据结构是自动线程安全的。你可以保证没有任何东西会修改数据结构。因此，你可以自由地与其他任何线程共享它。

这个论点可以通过与其他方法交换数据来扩展。想象一下，你有一些可变的数据结构和一些`blackBox`方法：

```java
val listMutable  : Seq[Int] = collection.mutable.ListBufferInt
def blackBox(x: Seq[Int]): Unit = ???
blackBox(listMutable)  // Anything could happen to listMutable here, because it is mutable
```

在这些`blackBox`方法在这个数据结构上运行之后，你怎么知道现在它确切包含什么内容？除非你知道黑盒方法中确切发生了什么，否则你无法对可变数据结构有任何保证。现在，考虑一个不可变列表的例子和同样的情况，即在这个列表上调用黑盒方法：

```java
val listImmutable: Seq[Int] = List(1, 2, 3)
def blackBox(x: Seq[Int]): Unit = ???
blackBox(listImmutable) // No matter what happens, listImmutable remains the same, because it is immutable
```

在黑盒方法完成其工作后，你对这个列表中包含的内容有任何保证吗？你有，因为列表是不可变的。没有任何东西可以修改这个列表。所以你可以自由地传递它，不仅传递给其他线程，还可以传递给同一线程内的其他方法，并且可以确信它不会被修改。

这种方法的优点是，你不再需要将你的推理范围扩展到当前局部范围之外。如果你在一个不可变数据结构上调用黑盒方法，你不需要确切知道这个方法中发生了什么。这个方法永远不会修改不可变数据结构，知道这一点就足够了。所以，如果你在一个多线程环境中工作，或者你只使用不可变数据结构，你不再需要担心诸如同步或获取锁等问题。你知道你的不可变数据结构不会被任何线程更改。

到目前为止，我们已从直观的角度讨论了纯净性的属性。现在让我们看看一种更科学的方式来定义它——引用透明性的概念。

# 引用透明性

不可变性和无副作用的概念被术语**引用透明性**所包含。具有引用透明性的函数，你可以用其返回的结果替换函数调用，而不会改变程序的语义。

让我们看看它在例子上的工作方式。考虑另一种类型的副作用——日志记录。该函数返回具有给定 ID 的用户名称，但它也将该名称写入日志——在这种情况下是标准输出：

```java
def getUserName(id: Int): String = {
  val name = s"User-$id"
  println(s"LOG: Requested user: $name")
  name
}
val u = getUserName(10)
```

我们能否用函数计算出的结果替换先前的函数调用，而不丢失程序的语义？让我们试试：

```java
val u = "User-10"
```

在这种情况下，语义将不会相同。原始程序将日志打印到标准输出。当前的程序没有这样做。这是因为标准输出发生在我们用其计算结果替换的函数中，作为一个副作用。

现在，让我们考虑另一个程序：

```java
def getUserNamePure(id: Int): (List[String], String) = {
  val name = s"User-$id"
  val log  = List(s"LOG: Requested user: $name")
  (log, name)
}
val u = getUserNamePure(10)
```

函数做的是同样的事情，但它不是产生日志记录的副作用，而是将副作用应该发生的信息包含到所有应该被记录的消息列表中。现在我们可以返回包含消息的列表以及函数的结果。

我们能否在不丢失程序语义的情况下用函数计算出的结果替换它们的函数调用？查看以下内容：

```java
val u = (List("LOG: Requested user: User-10"), "User-10")
```

现在答案是肯定的。原始函数计算了它产生的所有消息的列表，并连同它计算出的值一起返回，而没有实际产生任何副作用。由于在过程中没有产生任何副作用，我们可以用函数的返回值替换函数调用，而不改变程序的语义。该函数是引用透明的。

如前例所示，在引用透明的函数中，所有的副作用都反映在返回类型中，通常由特定的数据结构表示。这种风格可能一开始看起来冗长且难以阅读，因为你从函数中返回了一个包含额外内容的对。然而，不要忘记工程学的一个主要原则是抽象。所以，如果你有适当的抽象，这里看到的难以阅读的代码可以被抽象掉。这样做的过程中不会失去我们已经获得的好处。这些好处包括减轻程序员的认知负担、能够局部解释你的程序，以及能够将副作用排除在等式之外。

这样的抽象已经被发明出来。像 Scala 或 Haskell 这样的语言对这种抽象提供了出色的支持。在本书的后面部分，我们将更深入地探讨它们是如何工作的，以及如何使用它们来编写程序。

# 通常遇到的副作用

在本节中，我们将更详细地讨论程序中常见的一些副作用。其中一些我们已经介绍过，而其他一些你可能已经从日常编程中了解到了。然而，对你来说，特别注意这些副作用至关重要，因为这样，你才能学会在普通程序中区分它们。

当编写程序（以及当我们一般地生活时），我们往往对某些事情习以为常，甚至没有注意到它们。某些事情可能成为头痛和问题的来源，解决这些问题的第一步是命名导致它们的原因。

由于函数式编程旨在消除副作用，因此我们合理地命名了一些导致痛苦的副作用。

# 错误

我们将要讨论的第一个效果是错误的效果。当你的程序中出现问题时，会产生错误。在命令式语言中，它通常由异常来建模。异常是由程序中的一行产生的现象，它在该点中断了程序的执行流程。通常，它沿着调用栈向上传播，也会中断其父调用栈的执行。如果未得到处理，异常会传播到最顶层的调用栈帧，程序将会崩溃。

考虑一个除以零的例子：

```java
def division(n1: Double, n2: Double): Double =
  if (n2 == 0) throw new RuntimeException("Division by zero!")
  else n1 / n2
```

我们有一个除法函数，它会检查其分母是否为零。如果是，该函数会抛出异常。现在，考虑如下调用此函数：

```java
division(1, 0)
println("This line will never be executed")
```

主程序的执行将不会超过我们尝试调用除法函数的行，该函数的第二个参数为零。这是因为错误将在函数中发生，并最终传播到堆栈中，最终导致程序崩溃。

# 结果缺失

考虑一种情况，我们有一个应该执行数据库查询的函数。具体来说，我们在数据库中有用户，我们希望有一个函数可以通过 ID 检索用户。现在，当数据库中没有给定 ID 的用户时会发生什么？考虑以下情况：

```java
def getUser(id: Int): User =
  if (Set(1, 2, 3).contains(id)) User(s"User-$id")
  else null
```

命令式语言的解决方案是从函数返回 null。在第三章，“函数式数据结构”中，我们看到了这是多么危险。编译器不知道函数可以返回 null。更准确地说，它甚至不知道这是一个可能性。编译器允许函数返回`null`，并且不会警告我们可能存在 null 返回值。命令式风格接受了这种可能性。因此，在命令式语言中，可能每个返回对象的函数也可能返回 null。如果我们不检查该函数的结果是否为 null，我们可能会遇到错误。并且为了检查函数的结果，我们需要记住它可能返回 null 的可能性。这又是一个额外的心理负担。

# 延迟和异步计算

想象一下你的程序执行了一个 HTTP 调用。例如，它试图从一个 Web API 中检索一些 JSON 对象。这可能需要一些时间；甚至可能需要几秒钟才能完成。

假设你希望在函数内进行一些竞争，并根据 API 请求的结果返回一些值。你在这里会遇到问题，因为 API 调用的结果并没有立即可用。你需要等待一个特定的长时间运行的操作完成，这也是一个副作用。

你可以在这个长时间运行的操作上阻塞，一旦结果到达就继续你的竞争。然而，这个函数也会阻塞调用它的任何函数。在性能关键的环境中，这可能会成为一个问题。例如，考虑一个 Web 服务器。它有多个线程来处理所有传入的请求。如果它的操作完成时间过长，它会很快耗尽线程。并且一些请求最终会在队列中等待很长时间，等待一个空闲的线程。

因此，你始终需要记住，你的一些函数是阻塞的，需要时间来返回。这是一条需要记住的额外信息。这给你带来了额外的心理负担。延迟计算的副作用导致了这一切。

现代网络服务器使用的解决方案是使你的服务器异步。这意味着你永远不会等待长运行的操作。你指定接下来要做什么，使用回调，一旦结果就绪，就根据该回调继续。这可能导致一种称为回调地狱的情况。问题是当你过度使用回调时，程序的执行流程变得相当晦涩。

通常，当程序中的某件事不明显时，这表明需要抽象。因此，抽象回调可能是一个好主意。

函数式编程也有一种方法来抽象长运行的计算。有了它，你可以编写代码，就像它们立即返回一样。`Future`数据类型存在于 Scala 和 Java 中，也存在于许多现代编程语言中。它**精确地**服务于抽象长运行计算的目的。

# 日志

在本章“引用透明性”部分的例子中，我们看到了日志也可以是副作用。日志可以使用单独的登录框架来完成，或者它可能只是简单地写入标准输出。

当你在不熟悉的环境中工作时，日志可能会变得复杂。例如，如果是在你的桌面电脑环境中，一切都很简单。你从终端运行程序，它将所有输出都输出到终端。然而，如果是一个网络服务器呢？通常，你需要将日志输出到单独的文件中，以便之后可以阅读。或者，如果你正在编写一个移动应用程序呢？程序在单独的设备上运行，并不总是打印语句会导致输出到终端。你可能需要使用一些特定于系统的日志 API，这些 API 是本地化的，适用于你正在工作的环境。

现在想象一下，你有一个程序，其中几乎到处都有`print`语句。你突然开始理解，一些函数在记录日志时试图与作用域之外的环境进行交互。具体来说，是与你在工作环境中特定的日志 API。现在你需要修改这个日志调用，以匹配环境的期望。

一个写入日志的函数与作用域之外的环境进行交互。这意味着我们可以根据定义将这些调用视为副作用。由于你在不同环境中工作时需要关注这些复杂性，因此可以说它们增加了你的心理负担。

# 输入输出操作

我们在这里要讨论的最后一个副作用是与文件系统或网络的输入输出（**IO**）操作。我们可以将这些操作称为副作用，因为它们在很大程度上依赖于环境。

在文件系统上的 IO 操作中，操作的成功取决于文件系统是否包含指定的文件或文件是否可读。当执行网络操作时，操作取决于我们是否有可靠的互联网连接或任何防火墙。

当调试 IO 程序时，许多移动部件会吸引我们的注意力。我们是否有权访问所需的文件系统？我们正在尝试读取或写入的文件的所有权如何？当前用户有什么权限？不同操作系统的文件系统如何？Linux 和 Windows 在文件系统结构上有非常不同的方法，那么我们如何将我们的应用程序从一个系统移植到另一个系统？我们有一个可靠的互联网连接吗？我们是否在防火墙后面？我们的 DNS 服务器是否工作正常？我们正在尝试监听的端口在这个特定系统上是否可用？

这对你来说是一个额外的心理负担，因为你需要考虑很多事情。因此，你可以将 IO 视为副作用和额外的心理负担。

# 但我们如何消除副作用呢？

如果你来自纯命令式背景，你可能会在这个时候感到非常困惑。纯函数式编程认为你需要消除所有的副作用。但你能否想象一个没有日志记录的程序？如果一个无法连接到网络的 Web API 有什么用呢？如果我们不能抛出异常，我们如何指定程序的错误行为？

之前指定的副作用对于大多数现代应用程序都是必不可少的，通常无法想象一个没有副作用的合理程序。

因此，说纯函数式编程完全从你的程序中消除副作用是不正确的。相反，更精确的说法是它从你的业务逻辑中消除副作用。它将副作用推离应用程序中重要的部分。以纯函数式风格通常工作的方式是，你的业务逻辑，涵盖了 90%的代码，确实是纯函数式的。

你没有之前指定所有的副作用。然而，每当业务逻辑需要执行副作用时，它不会直接执行。相反，它创建一个数据结构来指定需要执行哪些副作用，而实际上并不执行它们。函数式应用程序通常有一个完整的特定领域语言来描述副作用。每当一段逻辑需要执行副作用时，它就用这种语言表达其需求。需要执行的操作的指定和执行该指定的行为是分开的。

函数式应用程序通常有一个薄层，负责执行在应用程序的效果语言中表达的外部效应。这种方法的优点是，大多数时候你都在处理业务逻辑，这 90%的代码。而且这段代码是引用透明的和纯的。这意味着其中所有通常存在的副作用都被分离出来。我们之前讨论的所有心理负担都消失了。这意味着，大多数时候，你都是在没有额外心理负担的情况下，局部地工作，不考虑全局范围。

确实，你还需要编写你副作用的解释器。这是你选择的效果语言中表达的外部效应的 10%的代码。然而，它与你的业务逻辑是分开的。你可以单独测试你的效果解释器。一旦编写并部署，你就可以忘记它，并以纯的方式编写你的业务逻辑。

到目前为止，我们还没有深入探讨如何实现它。本节的目的在于给你一个关于如何解决副作用应用程序中纯度问题的概念。在本书的后面部分，我们将精确地看到函数式编程如何促进这种技术，以及它究竟提供了什么来以这种风格编写程序。

# 不同语言中的纯函数式范式

编程时不需要任何特定的基础设施来采用纯函数式风格。你所需要的是能够在代码中看到副作用，注意到它们何时在你的脑海中增加额外的心理负担，并需要你同时记住更多的事物。当然，你需要知道如何抽象它们，如何让这种心理负担消失。大多数现代编程语言都是为了工程师而构建的。这就是为什么它们提供了出色的抽象能力，包括像 C 或 Java 这样的命令式语言。这就是为什么，如果你知道如何抽象以及如何做，你应该能够在这些语言中实现抽象。而且如果你确切地知道命令式风格如何伤害你，你可以保护自己免受麻烦。

此外，某些命令式编程语言提供了一种特定的基础设施，直接促进了纯函数式风格的实现。例如，在 Java 中，你有`final`关键字。使用这个关键字声明的变量是不可变的。一旦在 Java 中为`final`变量赋值，你就无法修改它。此外，在 Java 中，不可变集合是其核心基础设施的一部分。

尽管你可以在命令式语言中应用函数式风格，但在函数式语言中这样做要容易得多。当你将这种风格应用于命令式语言时可能会遇到麻烦。一个问题可能是你遇到的所有库都是命令式的。在这种条件下编写纯函数式代码可能很困难，因为你将在一个命令式框架内工作。这可能会产生一定的惯性，可能很难克服。因此，在命令式语言中工作在函数式风格可能并不实用。然而，如果你被复杂性压倒，它可能被用作最后的手段。

纯函数式语言的优点，例如 Scala 或 Haskell，在于它们为你提供了一个优秀的框架来编写函数式代码。Haskell 是一种强制使用函数式风格的编程语言。使用该语言时，你几乎别无选择，只能采用这种风格。因此，你将在这种语言中使用的库也都是纯函数式的。你可以在纯函数式框架下工作。在某种程度上，Scala 是一种更为自由的编程语言。它是面向对象和函数式风格的混合体。因此，使用它来在纯命令式和纯函数式风格之间进行转换非常方便。这是因为你有选择风格的空间。如果你不知道如何以纯函数式的方式实现某些功能，而且截止日期即将到来，你总是可以求助于熟悉的命令式风格。

这种命令式和函数式风格的结合在现代编程语言中相当普遍。例如，在 Python 中，你可能会遇到这两种风格。一些库相当命令式，但同时也很好地支持纯函数式风格。Java 在这个意义上比 Python 更为保守。它似乎非常严格地遵循命令式、算法范式，尽管在过去十年左右，人们投入了巨大的努力使函数式风格在 Java 中更加自然。

总的来说，本节的重点是函数式风格并不关乎语言本身。语言可以提供一些动力，这体现在其现有的基础设施和社区的方法论上。这种动力可以是双向的——要么对你有利，要么对你不利。然而，如果你理解了函数式方法，你应该能够在任何使用它的语言中进行编程。但你应该始终意识到风向——社区的气氛如何，其库遵循的哲学是什么。你应该意识到语言为你提供的动力，以及它是帮助你还是阻碍你。

# 摘要

传统的命令式方法严重依赖于在运行时产生某些现象的算法——副作用。编译器通常对这些现象不太了解，或者了解得不够。我们可以将本书中的副作用定义为修改其直接作用域之外环境的指令。副作用通常是不受欢迎的，因为它们给程序员的思维增加了额外的负担。

传统命令式风格的另一个问题是突变。可变数据结构不是线程安全的。而且，即使在同一线程内，它们也无法安全地在逻辑片段之间传递。

函数式编程旨在解决这些问题并减轻你的心理负担。这种风格通过抽象出副作用来实现，这样你就可以编写程序而无需显式执行它们或修改当前作用域之外的内容。

# 问题

1.  副作用是什么？

1.  什么是可变数据？

1.  副作用和可变数据可能会引起什么问题？

1.  纯函数是什么？

1.  什么是引用透明性？

1.  使用纯函数式风格有什么好处？

1.  常见的一些副作用有哪些？

1.  在像 Java 这样的命令式语言中，是否可以以纯函数式风格进行编程？

1.  使用函数式编程语言而不是命令式编程语言进行纯函数式编程有什么好处？
