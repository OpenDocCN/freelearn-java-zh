# *第一章*: 云原生应用

当谈论**云原生应用**时，重要的是对云原生意味着什么有一个共同的理解。通常有一个假设，即云原生和微服务是同一件事，但实际上，微服务只是构建云原生应用时可以使用的*一种*架构模式。这引出了以下问题：什么是云原生应用，构建它们的最佳实践是什么？这将是本章的重点。

尤其是我们将涵盖以下主要主题：

+   什么是云原生应用？

+   介绍分布式计算

+   探索云原生应用架构

+   云原生开发最佳实践

本章将为理解本书的其余部分提供一些基础，同时帮助你在构建云原生应用时取得成功。

# 什么是云原生应用？

回到 2010 年，Paul Freemantle 写了一篇关于云原生的早期博客文章([`pzf.fremantle.org/2010/05/cloud-native.html`](http://pzf.fremantle.org/2010/05/cloud-native.html))，并使用了试图在 6 车道高速公路上驾驶马车类比。无论高速公路作为道路有多好，马车能运输的货物和运输速度都是有限的。你需要为高速公路设计的车辆。应用也是如此。

设计在传统数据中心运行的应用程序与专门设计以利用云的能力的应用程序相比，在云上运行效果不佳。换句话说，云原生应用是专门设计以利用云提供的功能的。来自*第八章*的**股票交易员**应用程序，*构建和测试云原生应用*，就是这样一个应用的例子。微服务的真实世界例子是 Netflix。

也许在核心上，云的承诺是能够按需获取计算资源，几分钟或几秒钟而不是几天或几周，并且根据增量使用量而不是潜在使用量进行收费——尽管，对于许多人来说，吸引力仅仅是不再需要管理和维护多个数据中心。云提供的计算资源商品化导致了对应用的设计、规划和设计有非常不同的思考方式，这些差异显著影响了应用。应用设计中的一个关键变化是应用的分布式程度。

# 介绍分布式计算

大多数云原生架构涉及将应用程序拆分为几个离散的服务，这些服务通过网络链接而不是进程内方法调用进行通信。这使得云原生应用隐式地成为分布式应用，尽管**分布式计算**并不是什么新鲜事物，但它确实增加了理解分布式计算优势和陷阱的需求。在构建分布式应用时，重要的是要考虑和理解分布式计算的八个谬误。这些如下：

+   网络是可靠的。

+   延迟为零。

+   带宽是无限的。

+   网络是安全的。

+   拓扑不会改变。

+   只有一个管理员。

+   传输成本为零。

+   网络是同质的。

从本质上讲，这些谬误意味着网络调用比调用 Java 方法或 C 过程要慢，安全性更低，可靠性更差，更难修复。在创建云原生应用时，需要仔细考虑以确保这些谬误得到正确考虑，否则，应用将会运行缓慢、不可靠、不安全，且难以调试。

由多个服务通过网络交互组成的程序可以产生许多好处，例如能够单独扩展和更新服务，但必须注意设计服务以最小化实现最终商业解决方案所需的网络交互次数。

因此，可以使用几种云原生架构来构建云原生应用，这些架构在分布式计算的优势和挑战之间提供了不同的权衡。

# 探索云原生应用架构

自 2019 年以来，关于微服务作为**云原生应用架构**的优缺点在业界引发了越来越多的讨论。这主要是由于许多与微服务相关的失败，因此，人们现在正在讨论是否有些应用使用不同的架构会更好。甚至有关于重建单体应用的复兴开始出现，在过去的几年里，这类应用被视为反模式。

虽然将云原生视为仅仅是技术选择很有吸引力，但了解开发流程、组织结构和文化如何影响云原生应用的演变、系统架构以及任何最终的成功是很重要的。康威定律指出以下内容：

*任何设计系统的组织都会产生一个结构，其结构与组织的沟通结构相匹配。*

将这种想法简单化的一种方式是，如果你的开发组织在构建单体应用方面很成功，那么在没有某种重组的情况下，它不太可能成功构建微服务。这并不意味着每个想要进行云原生开发的团队都应该出去重组；这意味着在决定采用什么架构时，你应该了解自己的优势和劣势。如果需要，你也应该开放地考虑重组。

本节讨论了目前一些更受欢迎的云原生应用架构及其优缺点。让我们从微服务开始。

## 微服务

虽然 Netflix 并没有发明微服务的概念，但他们对该架构的使用确实使其流行起来。单个微服务被设计用来做一件事情。尽管名字上听起来服务很小或轻量级，但实际上并不一定如此——一个单独的微服务可能有*数百万*行代码，但微服务中的代码具有高度的凝聚力。微服务永远不会处理 ATM 取款和出售电影票。确定将云原生应用程序设计成一系列精心设计的微服务的最佳方式并不是一个简单的任务；不同的人可能会有不同的观点，认为银行账户的存取是否需要单个微服务或两个。

微服务通常通过 REST 接口或消息系统相互集成，尽管 gRPC 和 GraphQL 越来越受欢迎。面向 Web 的微服务可能会使用 REST 或 GraphQL 接口，但内部微服务更有可能使用 Apache Kafka 等消息系统。消息系统通常对网络问题具有很强的容错能力，因为一旦消息系统接受了消息，它就会存储该消息，直到它可以成功处理。

基于微服务的架构的关键承诺是每个微服务都可以独立部署、更新和扩展，允许拥有不同微服务的团队并行工作，无需协调即可进行更新。这可能是在微服务架构中最大的挑战。有良好意愿的开发者开始构建微服务时，最终可能会构建一个分布式单体，这种情况相对常见。这通常是由于服务之间定义不明确和文档不充分，以及验收测试不足，导致在更新单个微服务时缺乏对其他服务的信任。这被称为*分布式单体*，因为最终你得到了单体和微服务的所有缺点，却失去了它们的优点。

在理想的世界里，一个构建微服务的开发组织会将微服务与单个开发团队对齐。如果微服务的数量超过开发团队的数量，这可能很困难。随着一个团队管理的微服务数量增加，将会有更多的时间用于管理服务而不是演进服务。

## 单体应用

**单体应用**与云前的应用架构紧密相关，被认为是云原生应用的反模式。因此，在讨论云原生架构时，这似乎有些奇怪。然而，有一些原因包括它们在内。

第一点实际上只是现实，即单体应用是构建最简单的一种应用。虽然单个服务不能独立扩展，但只要单体应用设计得可以扩展，这可能不是问题。

第二点是，现在有很多单体应用，许多企业正在将它们迁移到云端。**MicroProfile**提供了额外的 API，可以将许多云原生行为重构到现有应用程序中。

单体应用的技巧是确保尽管服务位于单个部署工件中，但单体应用可以快速启动，以便在应用程序失败时启用动态扩展和重启。

通常，小型开发组织会从单体应用中受益，因为只有一个应用程序需要构建、部署和管理。

## 宏服务

**宏服务**位于单体应用和微服务架构之间，也被称为*模块化单体应用*。在宏服务中，服务被组合成少量单体应用，它们以与一系列微服务相同的方式交互操作。

这提供了许多微服务的好处，但显著简化了操作环境，因为要管理的事物更少。如果一个宏服务编写得很好，那么其中的单个服务如果从独立的生命周期中受益，就可以将其拆分出来。一个著名的宏服务例子是**Stack Overflow**。Stack Overflow ([`www.infoq.com/news/2015/06/scaling-stack-overflow/`](https://www.infoq.com/news/2015/06/scaling-stack-overflow/)) 众所周知是一个单体应用，除了标签功能，由于性能需求不同，该功能由另一个应用程序处理。这种拆分使其从纯单体应用转变为宏服务领域（尽管 Stack Overflow 使用术语*monolith-plus*）。

当开发组织被组织成比服务数量更少的团队时，这种架构可以特别有效。

## 函数即服务

**函数即服务**（**FaaS**），通常被称为*无服务器*，是一种服务创建为在事件发生时运行的函数的架构。该函数旨在快速启动和快速执行，可以通过诸如 HTTP 请求或接收到的消息等事件触发。FaaS 承诺你可以将函数部署到云中，并由事件触发器启动和执行，而不是必须让函数一直运行以备不时之需。通常，支持 FaaS 的公共云提供商只对函数运行时间收费。如果事件相对不常见，这非常吸引人，因为没有在罕见事件发生时让系统运行的经济成本。

这种架构的挑战在于，你的函数需要能够快速启动，并且通常也需要快速执行完成；因此，它不适合长时间运行的过程。它也没有移除服务器；服务器仍然存在。相反，它只是将成本从开发者转移到了云服务提供商。如果云服务提供商是公共云，那么这是他们的问题，因为他们会根据函数运行时间收费，但如果你部署到私有云，这就会成为你的问题，从而消除了部分好处。

## 事件溯源

通常，我们认为服务提供 REST 端点，并且服务会调用它们。实际上，十二要素应用（在下一节中讨论）的第 VII 要素*明确*指出这一点。这种方法的缺点是，REST 调用是隐式同步的，如果服务提供者运行缓慢或失败，则容易出现问题。

当为移动应用或网页浏览器提供外部 API 时，REST API 通常是最佳选择。然而，对于企业内部的服务，使用如 Kafka 的消息系统以及使用**异步****事件**有许多好处。能够保证消息将被传递的消息系统允许客户端和服务解耦，这样服务提供者的问题不会阻止请求的发生；只是意味着它会被稍后处理。一对一的事件系统使得单个服务通过简单的消息发送就能触发多个不同的动作。不同的服务可以通过接收消息副本采取不同的动作，如果需要新的行为，额外的服务可以接收相同的消息，而无需更改发送服务。一个简单的例子可能是，一个订购商品的订单事件可以被支付服务、调度服务、补货服务和基于过去购买提供推荐的服务处理。

云原生应用程序的一个趋势是数据从集中的数据存储移动到更靠近单个服务的地方。每个服务都操作它持有的数据，因此如果某个服务的数据存储变慢，它不会对其他服务产生连锁反应。这意味着需要新的机制来确保数据一致性。使用事件来处理数据更新有助于这一点，因为单个事件可以被分发到每个需要独立处理更新的服务。即使服务在更新触发时处于关闭状态，更新也可以生效。这种方法的另一个优点是，如果数据存储失败，可以通过重放所有事件来重建它。

在选择了构建你的云原生应用程序的架构（或架构）之后，下一步是开始构建它，为此，了解一些关于云原生应用程序开发的行业最佳实践是个好主意。

# 云原生开发最佳实践

有许多最佳实践，如果遵循这些实践，将提高你的云原生应用程序成功的可能性。遵循这些最佳实践并不能保证成功，正如忽视它们并不能保证失败一样，但它们确实编码了已被证明可以增加成功机会的关键实践。最著名的最佳实践集合是**十二要素应用**。

## 十二要素应用

十二要素应用([`12factor.net`](https://12factor.net))是一套 12 个最佳实践，如果遵循这些实践，可以显著提高构建云原生应用程序成功的可能性。其中一些因素对于许多软件开发者来说可能很显然，即使是在云原生之外，但综合起来，它们形成了一种构建云原生应用程序的流行方法。以下是 12 个要素：

+   代码库

+   依赖项

+   配置

+   后端服务

+   构建、发布、运行

+   进程

+   端口绑定

+   并发

+   可丢弃性

+   开发/生产一致性

+   日志

+   管理进程

### I – 代码库

第一个要素指出，云原生应用程序由一个单一的**代码库**组成，该代码库在版本控制系统（如 Git）中跟踪，并且该代码库将被部署多次。部署可能是在测试、预发布或生产环境中。这并不意味着这些环境中的代码将是相同的；显然，测试环境将包含尚未被证明对生产环境安全但被提出的代码更改，但仍然是一个代码库。

### II – 依赖项

对于 Java 应用程序来说，使用存储在 Maven 仓库（如 Maven Central）中的**依赖项**作为常见的开发实践已经有一段时间了。例如，Maven 和 Gradle 工具要求你表达你的依赖项，以便针对它们进行构建。虽然这种做法绝对需要这样做，但它不仅限于构建时的依赖项，还包括运行时的依赖项。12 因素应用程序将依赖项打包到应用程序中，以确保单个开发工件可以在任何合适的环境中可靠地部署。这意味着管理员在文件系统上的知名位置提供库是不可接受的，因为总是有可能管理员部署的库与应用程序所需的库不兼容。

在考虑这种实践时，明确决定云原生应用程序的定义非常重要，因为最终应用程序提供的内容和部署环境提供的内容之间将会有所分离。这个因素促使企业 Java 从`WAR`文件转向可执行的`JAR`文件，因为许多人认为应用程序服务器是一个隐含的依赖。然而，这仅仅是将隐含的依赖降低了一个级别；它并没有消除它。现在，隐含的依赖是 Java。在某种程度上，容器化解决了这个问题，同时消除了围绕可执行`JAR`文件重新架构的需求。

### III – 配置

由于 12 因素应用程序可能有多个部署，并且每个部署可能连接到不同的系统，使用不同的凭证，因此将**配置**外部化到环境中至关重要。在媒体上关于开发者意外将凭证检查到版本控制系统中导致的安全问题也很常见，如果配置存储在代码库外部，这种情况就不会发生。

虽然这个因素表明配置存储在环境变量中，但许多人对于在环境变量中存储安全敏感的配置感到不安。这里的关键是要以简单的方式外部化配置，以便在生产环境中提供。

### IV – 后端服务

**后端服务**被视为附加资源。应该能够通过简单的配置更改从一种数据库切换到另一种数据库。

### V – 构建、发布、运行

所有应用都会经历某种**构建、发布、运行**的过程，但 12 因子应用在这三个阶段之间有严格的分离。构建阶段涉及将应用源代码转换为应用工件。发布阶段将应用工件与配置结合，以便可以部署。运行阶段是实际执行的时候。这种严格的分离意味着运行阶段永远不会进行配置更改，因为没有方法可以将其回滚到发布阶段。相反，如果需要配置更改，则创建一个新的发布并运行。如果需要代码更改，也是如此。没有通过构建和运行来更改正在运行中的代码。这确保了你始终知道正在运行什么，并且可以轻松地重现问题或回滚到先前的版本。

### VI – 进程

一个 12 因子应用由一个或多个**无状态进程**组成。这并不意味着每个请求都映射到一个单独的进程；在 Java 中，一个 JVM 同时处理多个请求是完全合理的。这意味着应用不应该依赖于某个进程在请求之间保持可用。如果一个客户端发送了 20 个请求，必须假设每个请求都是由一个独立的进程处理的，且进程之间不保留任何状态。将服务器端与用户关联的状态存储为一个常见模式。这个状态应该始终持久化到外部数据存储中，这样如果后续请求发送到不同的进程，就不会对客户端产生影响。

### VII – 端口绑定

应用通过**端口绑定**导出服务。这意味着 HTTP 应用不应该依赖于被安装到 Web 容器中，而应该声明对 HTTP 服务器的依赖，并在启动时打开一个端口。这导致许多人认为 12 因子 Java 应用必须构建为一个 uber-jar，但这只是构建单个部署工件并绑定端口的想法之一。一个替代方案并且更有用的一种解释是使用容器；容器在很大程度上是围绕端口绑定的概念构建的。应该注意的是，这种做法并不总是适用；例如，由 Kafka 消息驱动的微服务就不会绑定到端口。此外，许多 FaaS 平台不提供端口绑定的 API。

### VIII – 并发

Java 中的**并发**通常是通过增加分配给进程的资源来实现的，以便可以创建更多的线程。在 12 因素中，你增加的是实例数量而不是计算能力。向单台机器添加计算能力是有限的，但添加一个等效大小的新的虚拟机相对容易。这种做法与第 VI 个因素相关，因此它们相互补充和加强。尽管这可能被解读为建议每个请求一个进程的模型，但基于 Java 的应用程序完全能够比 1:1 的进程与请求比例更有效地运行多个线程。

### IX – 可丢弃性

每个应用程序都应被视为**可丢弃的**。这意味着确保进程快速启动、迅速关闭并能够处理终止。采用这种方法可以使应用程序很好地扩展并快速扩展，同时也能抵御意外的故障，因为可以从最后发布版本快速且轻松地重新启动进程。

### X – 开发/生产一致性

许多应用问题都源于**开发和预发布环境**之间的差异。在过去，这是因为安装和启动所有下游软件都很困难，但随着容器技术的出现，这一体验得到了显著简化，使得许多系统可以在更早的环境中运行。这种做法的优势在于，你不再会因为你的开发数据库与预发布环境对 SQL 的解释不同而遇到问题。

### XI – 日志

应用程序应编写遵循进程输出而不是日志文件的`log`函数。

### XII：管理进程

**管理进程**应作为独立于应用程序的一次性进程运行，并且不应与应用程序启动同时进行。这些应用程序进程的代码应与主应用程序一起管理，以便可以使用用于正常流程的发布来执行管理任务。这确保了应用程序和管理代码不会出现分歧。

## 其他最佳实践

12 因素应用的概念已经存在了一段时间；在任何方法论中，重要的是要记住，对某些人有效的方法可能对其他人无效，有时方法论需要随着我们对如何成功理解的演变而发展。因此，通常还会添加一些其他最佳实践到之前讨论的 12 个因素中。最常见的一个是关于描述服务 API 及其测试方法的重要性，以确保对某个服务的更改不需要客户端服务的协调部署。

### API 和合同测试

虽然 12 因素方法详细介绍了创建和执行云原生应用程序的大量有用实践，但它很少讨论应用程序服务如何交互以及如何确保更改一个服务不会导致另一个服务需要更改。设计良好且文档清晰的**API**对于确保服务更改不会影响客户端至关重要。

仅对 API 有文档是不够的；还必须确保服务提供商的更改不会对客户端产生负面影响。由于任何错误修复都可能引起更改，因此提供商可能认为更改是安全的，并意外地破坏客户端。这就是**契约测试**可以发挥作用的地方。契约测试的优势在于，每个系统（客户端和服务器）都可以进行测试，以确保对任一方的更改不会违反契约。

### 安全性

12 因素方法中最明显的差距之一是关于安全性的最佳实践的缺乏。从某个角度来看，这是因为已经存在一套用于保护应用程序的最佳实践，这些最佳实践同样适用于云原生应用程序和传统应用程序。例如，关于配置地址的第三项实践，至少部分地解决了如何通过外部化来保护凭证（或其他机密信息）的问题。然而，这个因素并没有讨论如何安全地将机密信息注入环境以及它们是如何被存储和保护的，这取决于部署环境。这在*第七章*，“使用 Open Liberty、Docker 和 Kubernetes 的 MicroProfile 生态系统”中进行了更详细的讨论。

将系统分解为微服务会增加额外的复杂性，这在单体架构中并不适用。在单体架构中，你可以信任应用程序的各个组件，因为它们通常在相同的过程空间中共同部署。然而，当单体被分解为微服务并使用网络连接时，需要使用其他机制来维持信任。使用**JSON Web Tokens**（JWTs）就是这样一种在微服务之间管理和建立信任的机制。这在*第五章*，“增强云原生应用程序”中进行了更详细的讨论。

### GraphQL

在许多云原生思想中存在一个默认假设，即暴露的 API 是基于 REST 的。然而，这可能导致网络调用增加和通过网络发送的数据过多。**GraphQL**是一种相对较新的创新，它允许服务客户端通过 HTTP 连接从数据存储请求所需的确切信息。传统的 REST API 必须提供有关资源的所有数据，但通常只需要一部分。当使用 RESTful API 时，由于提供了客户端不使用的数据，网络带宽和客户端数据处理通常会被浪费。GraphQL 通过允许客户端向服务发送查询，请求他们确切需要的数据，而不需要更多数据，从而解决了这个问题。这减少了传输和从后端数据存储检索的数据量。MicroProfile 提供了一个基于 Java 的 API 来编写 GraphQL 后端，这使得编写为客户端提供基于查询的 API 的服务变得容易。

# 摘要

在本章中，我们学习了什么是云原生应用，并了解了一些构建它们的架构。我们还学习了构建云原生应用的一些最佳实践以及它们存在的原因，这样我们就可以确定何时以及如何应用它们。这为将本书中剩余部分所学内容应用于构建和部署云原生应用提供了良好的基础。

在下一章中，我们将探讨 MicroProfile 是什么以及如何用它来构建云原生应用。
