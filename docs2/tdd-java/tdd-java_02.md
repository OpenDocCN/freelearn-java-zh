

# 第二章：使用 TDD 创建好代码

我们已经看到，糟糕的代码是坏消息：对商业不利，对用户不利，对开发者也不利。**测试驱动开发**（**TDD**）是一种核心的软件工程实践，它帮助我们避免将糟糕的代码引入我们的系统。

本章的目标是了解 TDD 如何帮助我们创建经过良好工程设计的、正确的代码，以及它是如何帮助我们保持这种状态的。到本章结束时，我们将理解好代码背后的基本原理以及 TDD 如何帮助我们创建它。了解 TDD 为什么有效对我们来说很重要，这样我们可以激励自己，并且能够向同事们解释为什么我们也推荐他们使用它。

在本章中，我们将涵盖以下主要主题：

+   设计高质量代码

+   揭示设计缺陷

+   预防逻辑缺陷

+   防止未来缺陷

+   记录我们的代码

# 设计高质量代码

高质量代码不是偶然发生的。它是故意的。它是成千上万个小决策的结果，每个决策都塑造了我们的代码的可读性、可测试性、可组合性和可变更性。我们必须在快速且草率的解决方案和更稳健的方法之间做出选择，后者让我们有信心，无论用户如何误用我们的代码，它都会按预期工作。

每一行源代码至少涉及这些决策中的一个。这需要我们做出大量的决策。

你会注意到我们之前没有提到 TDD。正如我们将看到的，TDD 不会为你设计代码。它不会移除将需求转化为代码所必需的工程敏感性和创造性输入。坦白说，我很感激这一点——这是我享受的部分。

然而，这确实会在 TDD 中导致很多早期失败，这是值得注意的。期望在不提供自己的设计输入的情况下实现 TDD 流程并获得高质量代码的想法将根本行不通。正如我们将看到的，TDD 是一种允许你对这些设计决策获得快速反馈的工具。你可以在代码仍然便宜且易于更改时改变主意并适应，但它们仍然是你的设计决策，正在发挥作用。

那么，什么是好的代码？我们追求的是什么？

对我来说，好的代码就是可读性。我追求清晰。我想通过编写清晰且易于工作的代码来善待未来的自己和那些长期忍受的同事们。我想创建清晰且简单的代码，其中不包含隐藏的陷阱。

虽然关于什么使代码好的建议有很多，但基本原理是直接的：

+   说你所想，想你所言

+   在私下里注意细节

+   避免意外的复杂性

值得快速回顾一下我所说的这些内容。

## 说你所想，想你所言

这里有一个有趣的实验。取一段源代码（任何语言都可以），移除所有不属于语言规范的部分，然后看看你是否能弄清楚它是做什么的。为了使事情更加突出，我们将所有方法名称和变量标识符替换为符号`???`。

这里有一个快速示例：

```java
public boolean ??? (int ???) {
    if ( ??? > ??? ) {
        return ???;
    }
    return ???;
}
```

你有什么想法这个代码做什么吗？不，我也没有。我一点线索都没有。

我可以通过它的形状判断出它是一种某种**评估**方法，它接收一些内容并返回`true`/`false`。也许它实现了一个阈值或限制。它使用多路径返回结构，我们在检查某些内容后，一旦我们知道答案，就立即返回一个答案。

虽然代码的形状和语法告诉我们一些信息，但它并没有告诉我们太多。这绝对不够。我们关于代码做什么的几乎所有信息都是我们选择的自然语言标识符的结果。名称对于良好的代码至关重要。它们是至关重要的。它们是全部。它们可以揭示意图，解释结果，并描述为什么某些数据对我们很重要，但如果我们选择名称不当，它们就不能做到这些。

我使用两个命名指南，一个用于命名活动代码——方法和函数——另一个用于变量：

+   **方法** – 说明它做什么。结果是什么？我为什么要调用它？

+   **变量** – 说明它包含的内容。我为什么要访问它？

方法命名的一个常见错误是描述它内部是如何工作的，而不是描述结果是什么。一个名为`addTodoItemToItemQueue`的方法让我们承诺采用一种特定的方法实现，而我们并不真正关心。要么是这样，要么是误导信息。我们可以通过将其命名为`add(Todo item)`来改进名称。这个名称告诉我们为什么我们应该调用这个方法。它让我们有自由在以后修改它的编码方式。

变量命名的一个经典错误是说明它们是由什么构成的。例如，变量名`String string`对任何人都没有帮助，而`String firstName`清楚地告诉我这个变量是某人的名字。它告诉我为什么我想读取或写入这个变量。

也许更重要的是，它告诉我们不应该在那个变量中写什么。在同一个作用域内让一个变量承担多个功能确实是个头疼的问题。我经历过，已经做了，再也不想回头了。

结果表明代码就是**讲故事**，纯粹而简单。我们向人类程序员讲述我们正在解决的问题以及我们是如何决定解决它的。我们可以把任何旧代码扔进编译器，计算机就会让它工作，但如果我们想让人类理解我们的工作，我们必须更加小心。

## 在私下里注意细节

在私下里注意细节是描述计算机科学概念**抽象**和**信息隐藏**的简单方法。这些是基本思想，使我们能够将复杂系统分解成更小、更简单的部分。

我认为抽象的方式与我请电工为我修理房子的方式相同。

我知道我的电热水器需要修理，但我不想知道如何修理。我不想学习如何修理。我不想弄清楚需要哪些工具并购买它们。我只想完全不参与这件事，只要在我需要的时候完成即可。所以，我会打电话给电工，让他们来修理。只要我不需要亲自做，我非常乐意支付一笔不错的费用。

这就是抽象的含义。电工抽象了我的热水器修理工作。复杂的任务会根据我的简单请求来完成。

抽象在优秀的软件中无处不在。

每当你使某种细节变得不那么重要时，你就进行了抽象。一个方法有一个简单的签名，但其中的代码可能很复杂。这是算法的抽象。一个局部变量可能被声明为`String`类型。这是对每个文本字符的内存管理和字符编码的抽象。一个将折扣券发送给一段时间未访问过我们网站的顶级客户的微服务是对业务流程的抽象。抽象在编程中无处不在，跨越所有主要范式——**面向对象编程**（**OOP**）、**过程式**和**函数式**。

将软件拆分成组件的想法，每个组件都为我们处理一些事情，这是一个巨大的质量驱动因素。我们集中决策，这意味着我们不会在重复的代码中犯错误。我们可以独立彻底地测试一个组件。我们只需编写一次并拥有一个易于使用的接口，就可以通过编写它来*设计出*由难以编写的代码引起的问题。

## 避免意外的复杂性

这是我个人最喜欢的优秀代码的破坏者——那些根本不需要存在的复杂代码。

编写一段代码总是有无数种方法。其中一些使用复杂的特性或绕弯子；它们使用复杂的动作链来完成简单的事情。所有版本的代码都能得到相同的结果，但有些版本却意外地以更复杂的方式完成。

我对代码的目标是首先一眼就能看出我在解决什么问题，而将关于我是如何解决它的细节留给更深入的分析。这与我最初学习如何编码的方式大不相同。我选择强调**领域**而不是**机制**。这里的领域意味着使用与用户相同的语言，例如，用业务术语表达问题，而不仅仅是原始的计算机代码语法。如果我正在编写一个银行系统，我希望看到金钱、账簿和交易出现在最前面。代码所讲述的故事必须是关于银行的。

实现细节，如消息队列和数据库，虽然很重要，但仅限于它们描述我们今天是如何解决问题的。它们可能需要稍后更改。无论它们是否更改，我们仍然希望主要的故事是关于 *交易进入账户*，而不是 *消息队列与 REST 服务通信*。

随着我们的代码越来越擅长讲述我们正在解决的问题的故事，我们使其更容易编写替换组件。用另一个供应商的产品替换数据库变得简单，因为我们确切地知道它在我们的系统中扮演着什么角色。

这就是我们所说的隐藏细节。在某种程度上，看到我们是如何连接数据库的很重要，但只有在我们看到为什么我们最初需要它之后。

为了给您一个具体的例子，这里有一段代码，它与我在生产系统中找到的一些代码类似：

```java
public boolean isTrue (Boolean b) {
    boolean result = false;
    if ( b == null ) {
        result = false;
    }
    else if ( b.equals(Boolean.TRUE)) {
        result = true;
    }
    else if ( b.equals(Boolean.FALSE)) {
        result = false;
    }
    else {
        result = false;
    }
    return result;
}
```

您在这里可以看到问题。是的，确实需要这样的方法。这是一个低级机制，它将 Java 的 `true`/`false` 对象转换为等效的基本类型，并且是安全的。它涵盖了与 `null` 值输入相关的所有边缘情况，以及有效的 `true`/`false` 值。

然而，它有问题。这段代码很杂乱。它不必要地难以阅读和测试。它具有很高的 **循环复杂度 (CYC**)。CYC 是一个基于代码段中可能存在的独立执行路径数量的客观度量代码复杂性的指标。

之前的代码不必要地冗长且过于复杂。我相当肯定它有一个 `else`。

从所需的逻辑来看，只有三个有趣的输入条件：`null`、`true` 和 `false`。它当然不需要所有那些 `else/if` 链来解码。一旦你处理完那个 *null-to-false* 转换，你实际上只需要检查一个值，然后你就可以完全决定返回什么。

更好的等效代码如下：

```java
    public boolean isTrue (Boolean b) {
        return Boolean.TRUE.equals(b);
    }
```

这段代码以更少的麻烦做同样的事情。它不具有先前代码相同的偶然复杂性。它读起来更好。它更容易测试，需要测试的路径更少。它具有更好的循环复杂度指标，这意味着隐藏错误的地方更少。它更好地讲述了这个方法存在的原因。坦白说，我甚至可能会通过内联来重构这个方法。我不确定这个方法是否为实现添加了任何有价值的额外解释。

这个方法只是一个简单的例子。想象一下，如果把它扩展到数千行复制粘贴、略有变化的代码，您就能理解为什么偶然的复杂性是一个杀手。这种冗余随着时间的推移而积累，并以指数级增长。一切变得难以阅读，也难以安全地更改。

是的，我看到了。每当我看到它时，我都会感到非常难过。我们可以做得比这更好。作为专业的软件工程师，我们真的应该做到这一点。

本节对**良好设计**的基本原则进行了闪电般的巡礼。这些原则适用于所有编程风格。然而，如果我们能正确地做事，我们也能做错事。在下一节中，我们将探讨 TDD 测试如何帮助我们预防不良设计。

# 揭示设计缺陷

不良设计确实很糟糕。它是软件难以更改和难以工作的根本原因。你永远无法完全确定你的更改是否会起作用，因为你永远无法完全确定一个糟糕的设计真正在做什么。改变这种代码令人恐惧，通常会被推迟。整个代码段可能会被遗弃，只留下一个`/* Here be dragons! */`注释作为证明。

TDD 的第一个主要好处是它迫使我们考虑组件的设计。我们在考虑如何实现它之前就做这件事。通过按这种顺序做事，我们不太可能不小心陷入一个糟糕的设计。

我们首先考虑设计的方式是思考组件的公共接口。我们思考该组件将被如何使用，以及它将被如何调用。我们还没有考虑我们如何使任何实现真正工作。这是**从外向内**的思考。我们在考虑任何内部实现之前，先考虑代码从外部调用者的使用。

这对我们中的许多人来说是一种相当不同的方法。通常，当我们需要代码做某事时，我们首先编写实现。之后，我们将根据方法签名中需要的内容进行扩展，而不考虑调用点。这是**从内向外**的思考。当然，它有效，但它通常会导致复杂的调用代码。它使我们陷入不重要的实现细节中。

**从外向内**的思考意味着我们可以为用户梦想出完美的组件。然后，我们将调整实现以适应我们希望在调用点使用的代码。最终，这比实现本身更重要。这当然是抽象在实践中的应用。

我们可以提出以下问题：

+   是否容易设置？

+   是否容易要求它做某事？

+   结果是否容易处理？

+   是否难以以错误的方式使用它？

+   我们对它是否做出了任何错误的假设？

通过提出正确的问题，我们可以得到正确的结果。

通过先编写测试，我们涵盖了所有这些问题。我们提前决定如何设置我们的组件，可能为对象决定一个清晰的构造函数签名。我们决定如何使调用代码看起来如何，以及调用点将是什么。我们决定如何消费任何返回的结果，或者它将对协作组件产生什么影响。

这就是软件设计的核心。TDD 不会为我们做这件事，也不会强迫我们做得很好。我们仍然可以为所有这些问题想出糟糕的答案，然后简单地编写一个测试来锁定那些糟糕的答案。我也在现实代码中多次看到这种情况发生。

TDD 提供了早期反思我们决策的机会。在我们甚至还没有考虑代码如何工作之前，我们实际上已经在为我们的代码编写第一个可执行调用点的第一个示例。我们完全专注于这个新组件将如何融入更大的画面中。

测试本身立即提供了关于我们的决策效果如何的反馈。它给出了三个明显的信号，表明我们可以也应该改进。我们将把细节留到后面的章节，但测试代码本身清楚地显示了当你的组件难以设置、难以调用或其输出难以处理时的情况。

## 分析在生成代码之前编写测试的好处

你可以在三个时间点选择编写测试：在代码之前，在代码之后，或者永远不写。

显然，从不编写任何测试会将我们带回到开发的黑暗时代。我们在盲目行动。我们编写代码假设它将工作，然后将其全部留给后续的手动测试阶段。如果我们幸运的话，我们将在客户之前发现功能错误。

在完成一小块代码后立即编写测试是一个更好的选择。我们得到了更快的反馈。我们的代码不一定更好，因为我们编写代码的心态与没有测试实现时的心态相同。同样类型的功能错误仍然存在。好消息是，我们将编写测试来揭示它们。

这是一项很大的改进，但这还不是黄金标准，因为它导致了一些微妙的问题：

+   缺少的测试

+   泄露的抽象

### 缺少的测试 – 未检测到的错误

缺少的测试是由于人类的天性造成的。当我们忙于编写代码时，我们的大脑中同时有很多想法。我们专注于特定的细节，而忽略了其他方面。我总是发现，在写完一行代码后，我心理上会很快地“继续前进”。我只是假设它将会没问题。不幸的是，当我开始编写测试时，这意味着我已经忘记了某些关键点。

假设我最终编写了一些这样的代码：

```java
public boolean isAllowed18PlusProducts( Integer age ) {
    return (age != null)  && age.intValue() > 18;
}
```

我可能很快就开始了`> 18`的检查，然后心理上“继续前进”并记得年龄可能是`null`。我将添加`And`子句来检查它是否是或不是。这很有道理。我的经验告诉我，这段特定的代码需要做的不仅仅是进行基本的、健壮的检查。

当我编写测试时，我会记得编写一个测试来处理传入`null`的情况，因为这一点在我脑海中很清晰。然后，我将为更高的年龄编写另一个测试，比如*21*。再次，很好。

很可能我会忘记为年龄值为`18`的边缘情况编写测试。这里真的很重要，但我的注意力已经从那个细节转移开了。只需要同事的一条关于午餐的 Slack 消息，我很可能就会忘记那个测试，开始编写下一个方法。

前面的代码中有一个微妙的错误。它应该对任何`18`岁或以上的年龄返回`true`。它没有。它只对`19`岁或以上的年龄返回`true`。应该使用大于等于符号，但我忽略了这个细节。

不仅我在代码中忽略了细微差别，我还遗漏了一个重要的测试。我写了两个重要的测试，但我需要三个。

因为我自己写了其他测试，所以我对此没有任何警告。你没有得到一个你没有写的失败的测试。

我们可以通过为每段代码编写失败的测试，然后只添加足够的代码来使测试通过来避免这种情况。这种工作流程更有可能引导我们思考四个测试，以排除`null`处理和与年龄相关的三个边界情况。当然，它不能保证这一点，但它可以引导正确的思考方式。

### 泄漏的抽象——暴露无关的细节

泄漏的抽象是另一个问题。这是我们如此关注方法内部，以至于忘记了考虑我们的**梦想调用点**。我们只是随意地传播最容易编码的内容。

我们可能正在编写一个存储`UserProfile`对象的接口。我们可能先从代码开始，选择我们喜欢的`JDBC`库，编写方法，然后发现它需要一个数据库连接。

我们可以简单地添加一个`Connection`参数来解决这个问题：

```java
interface StoredUserProfiles {
    UserProfile load( Connection conn, int userId );
}
```

初看之下，似乎没有什么大问题。然而，看看第一个参数：它是特定的`JDBC`连接对象。我们已经将我们的接口锁定为必须使用`JDBC`。或者至少，必须作为第一个参数提供一些与`JDBC`相关的东西。我们甚至没有打算这样做。我们只是没有彻底考虑。

如果我们考虑理想的抽象，它应该为给定的`userId`加载相应的`UserProfile`对象。它**不应该**知道它是如何存储的。不应该有特定的`JDBC`连接参数。

如果我们从外部考虑并先考虑设计再考虑实现，我们就不太可能走这条路。

这种泄漏的抽象会创建意外的复杂性。它们通过迫使未来的读者思考为什么我们坚持使用`JDBC`，而实际上我们从未打算这样做，使得代码更难理解。我们只是忘记设计它出来。

先编写测试有助于防止这种情况。它引导我们首先考虑理想的抽象，这样我们就可以为它们编写测试。

一旦我们编写了那个测试，我们就已经锁定了代码的使用决策。然后，我们可以找出如何在不泄露任何不想要的细节的情况下实现它。

之前解释的技术很简单，但涵盖了良好设计的绝大部分基础。使用清晰的名称。使用简单的逻辑。使用抽象来隐藏实现细节，这样我们就可以强调我们正在解决的问题，而不是我们是如何解决问题的。在下一节中，让我们回顾 TDD 最明显的益处：预防我们逻辑中的缺陷。

# 预防逻辑错误

当我们谈论测试时，逻辑错误的观念可能是每个人首先想到的：*它**工作正确了吗*？

我在这里不能不同意——这真的很重要。就用户、收入、我们的 Net Promoter Score®™和市场增长而言，如果你的代码不能正确工作，它就不会销售。就是这么简单。

### 理解手动测试的局限性

我们从痛苦的教训中知道，最简单的逻辑错误往往是最容易创建的。我们可以联想到的例子是那些一次性的错误，比如从未初始化的变量中产生的`NullPointerException`，以及那些未在文档中提到的库抛出的异常。它们都是如此简单和微小。似乎对我们来说，意识到我们犯了这些错误应该是显而易见的，但我们都知道它们往往是最难发现的。当我们人类专注于代码的大局时，有时这些关键细节就会被人忽视。

我们知道手动测试*可以*揭示这些逻辑错误，但我们也知道从经验中得知手动测试计划是脆弱的。可能会遗漏步骤或匆忙中错过重要的错误。我们可能会简单地假设在这个版本中*不需要测试这个代码部分*，因为我们没有更改那个代码部分。你猜对了——这并不总是对我们有利。如果某些基本假设发生了变化，代码中的某些部分可能会出现与错误完全无关的 bug。

手动测试需要花钱，而这些钱现在不能用来添加闪亮的新功能。

手动测试还受到推迟发货日期的指责。现在，这对我们的手动测试同事来说是非常不公平的。显然，开发团队——显然没有编写 TDD 测试的代码——直到发货前只有几天时间，才会遇到自己的 bug。然后，我们将代码交给测试人员，他们必须在几乎没有时间的情况下运行大量的测试文档。他们有时会因*推迟发布*而受到责备，尽管真正的原因是开发时间比预期要长。

然而，我们从未真正发布过。如果我们把发布定义为包括经过测试的代码，我们应该这样做，那么很明显，必要的测试从未发生。如果你不知道代码是否工作，你就不应该道德地发布代码。如果你这样做，你的用户会很快提出投诉。

没有 wonder，一些测试同事在冲刺结束时变得如此烦躁。

### 通过自动化测试解决问题

TDD 完全解决了这个问题。这些逻辑错误根本不可能出现，这听起来像是一个幻想，但这是真的。

在你编写任何生产代码之前，你已经编写了一个失败的测试。一旦你添加了新的代码，你重新运行测试。如果你输入了逻辑错误，测试仍然会失败，你立刻就会知道。这里的魔法就在这里：你的错误发生了，但立刻就被突出显示出来。这使得你可以在它还新鲜在你的脑海中时修复它。这也意味着你不能忘记稍后修复它。

你通常可以直接找到出错的行并做出更改。这只需要 10 秒钟的工作，而不是等待几个月，直到测试隔离区开始工作并填写一个*JIRA*错误报告票。

我们所讨论的单元测试也运行得非常快——非常快。其中许多测试在毫秒内完成。与编写整个测试计划文档、运行整个应用程序、设置存储数据、操作**用户界面**（**UI**）、记录输出，然后编写错误报告票相比，这要好得多，不是吗？

你可以看到这如何是一种消除错误的超级能力。我们在代码-测试-调试周期中节省了大量的时间。这降低了开发成本并提高了交付速度。这对我们的团队和用户来说都是巨大的胜利。

每次你在代码之前编写测试时，你都已经将错误排除在了那个代码之外。你遵循了最基本的规则，即不检查失败的测试代码。你使它们通过。

不需要说，你也不应该通过删除它、忽略它或使用某种技术手段使其“总是通过”来欺骗那个失败的测试。然而，我之所以说这些，是因为我确实在真实代码中看到了这种行为。

我们已经看到先编写测试如何帮助我们预防在新的代码中添加错误，但 TDD（测试驱动开发）甚至比这更好：它帮助我们预防在未来添加代码时引入错误，这一点我们将在下一节中讨论。

# 防御未来缺陷

当我们通过先编写测试来扩展代码时，我们总是可以简单地删除每个通过后的测试。我曾看到一些学生在教他们 TDD 时这样做，因为我还没有解释过我们还不应该这样做。无论如何，一旦测试通过，我们不会删除它们。我们保留所有测试。

测试逐渐发展成为大型回归测试套件，自动测试我们构建的代码的每个功能。通过频繁运行所有测试，我们在整个代码库中获得安全感和信心。

当团队成员向这个代码库添加功能时，保持所有测试通过表明没有人意外地破坏了某些东西。在软件中，你可能在某个地方添加了一个完全无辜的更改，结果发现一些看似无关的事情现在停止工作了。这将是由于我们之前没有理解的那两个部分之间的关系。

这些测试现在让我们对我们的系统和我们的假设有了更多的了解。它们防止了缺陷被写入代码库。这两者都是巨大的好处，但更大的图景是，我们的团队能够有信心安全地做出改变，并且知道有测试自动地照顾着它们。

这才是真正的敏捷，改变的自由。敏捷从来不是关于 JIRA 工单和冲刺。它始终是关于在不断变化的需求景观中快速、有信心地移动的能力。拥有数以万计的快速运行的自动化测试可能是我们最大的启用实践。

测试能够给予团队成员快速、有效地工作的信心，这是 TDD 的一个巨大好处。你可能听说过“快速行动，打破事物”的短语，这是来自 Facebook 早期的一个著名说法。TDD 允许我们快速行动，*不*打破事物。

正如我们所看到的，测试在提供关于设计和逻辑正确性的快速反馈以及提供对未来错误的防御方面非常出色，但一个巨大的额外好处是，测试记录了我们的代码。

# 记录我们的代码

每个人都喜欢有帮助、清晰的文档，但不是当它过时且与当前代码库无关时。

在软件中有一个普遍的原则，即两个相关想法之间的分离越多，它们带来的痛苦就越大。作为一个例子，想想一些读取一些鲜为人知的文件格式的代码。只要你在读取那个旧格式的文件，一切都会正常工作。然后你升级了应用程序，那个旧文件格式不再被支持，一切都会崩溃。代码与那些旧文件中的数据内容分离了。文件没有改变，但代码改变了。我们甚至没有意识到发生了什么。

文档也是如此。最糟糕的文档通常包含在光泽最亮的生产中。这些是在代码创建很长时间后由具有不同技能集的团队编写的工件——文案写作、图形设计等等。当时间紧迫时，文档更新通常是首先被放弃的事情。

解决方案是将文档与代码更接近。让它由更接近代码、详细了解其工作原理的人来生成。让它由需要直接与该代码工作的人来阅读。

就像极限编程（XP）的所有其他方面一样，最明显的主要胜利是让它与代码如此接近，以至于它就是代码。这包括使用我们良好的设计原则来编写清晰的代码，我们的测试套件也扮演着关键角色。

我们的 TDD 测试是代码，而不是手动测试文档。它们通常与主代码库使用相同的语言和仓库编写。它们将由编写生产代码的同一个人编写——开发者。

测试是可执行的。作为一种文档形式，你知道可以运行的东西必须是最新的。否则，编译器会抱怨，代码将无法运行。

测试也完美地展示了如何使用我们的生产代码。它们清楚地定义了它应该如何设置，它有什么依赖项，它有哪些有趣的方法和函数，它的预期效果是什么，以及它将如何报告错误。关于该代码的任何你想知道的信息都在测试中。

起初可能会令人惊讶。测试和文档通常不会被混淆。由于 TDD 的工作方式，两者之间有很大的重叠。我们的测试是对我们的代码应该做什么以及我们如何让它为我们做到这一点的详细描述。

# 摘要

在本章中，我们了解到 TDD 帮助我们创建良好的设计，编写正确的逻辑，预防未来的缺陷，并为我们的代码提供可执行的文档。理解 TDD 对我们项目的作用对于有效地使用它以及说服我们的团队使用它非常重要。TDD 有很多优点，但在现实世界的项目中并没有像应该的那样经常使用。

在下一章中，我们将探讨一些常见的对 TDD 的反对意见，了解为什么它们不成立，以及我们如何帮助我们的同事克服它们。

# 问题和答案

1.  测试和干净代码之间有什么联系？

没有直接的路径，这就是为什么我们需要了解如何编写干净的代码。TDD（测试驱动开发）增加价值的地方在于，它迫使我们在我们编写代码之前和最容易清理的时候去思考代码的用途。它还允许我们重构代码，改变其结构而不改变其功能，并确信我们没有破坏那个功能。

1.  测试能否替代文档？

编写得好的测试可以替代一些但不是所有的文档。它们成为我们代码的详细和最新的可执行规范。它们无法替代的是用户手册、操作手册或公共**应用程序编程****接口**（**API**）的合同规范等文档。

1.  在测试之前编写生产代码有什么问题？

如果我们先编写生产代码，然后添加测试，我们更有可能面临以下问题：

+   在条件语句上遗漏了破坏性的边缘情况

+   通过接口泄露实现细节

+   忘记重要的测试

+   存在未测试的执行路径

+   创建难以使用的代码

+   在设计缺陷在后期过程中被揭示时，迫使进行更多的返工

# 进一步阅读

可以在维基百科链接中找到循环复杂性的正式定义。基本上，每个条件语句都会增加复杂性，因为它创建了一个新的可能的执行路径：

[`en.wikipedia.org/wiki/Cyclomatic_complexity`](https://en.wikipedia.org/wiki/Cyclomatic_complexity)
