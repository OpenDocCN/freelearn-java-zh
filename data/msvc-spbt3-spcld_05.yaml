- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Adding an API Description Using OpenAPI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenAPI 添加 API 描述
- en: The value of an API, such as a RESTful service, depends to a large extent on
    how easy it is to consume. Good and easily accessible documentation is an important
    part of whether an API is useful. In this chapter, we will learn how we can use
    the **OpenAPI Specification** to document APIs that we can make externally accessible
    from a microservice landscape.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 API（如 RESTful 服务）的价值在很大程度上取决于其消费的难易程度。良好的、易于访问的文档是 API 是否有用的一个重要部分。在本章中，我们将学习如何使用
    **OpenAPI 规范**来记录我们可以从微服务景观外部访问的 API。
- en: As we mentioned in *Chapter 2*, *Introduction to Spring Boot*, the OpenAPI Specification,
    previously known as the Swagger specification, is one of the most commonly used
    specifications when it comes to documenting RESTful services. Many of the leading
    API gateways have native support for the OpenAPI Specification. We will learn
    how to use the open source project **springdoc-openapi** to produce such documentation.
    We will also learn how to embed an API documentation viewer, **Swagger UI viewer**,
    which can be used both to inspect the API documentation and also to make requests
    to the API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *第2章*，*Spring Boot 简介* 中提到的，OpenAPI 规范（以前称为 Swagger 规范）是记录 RESTful 服务时最常用的规范之一。许多领先的
    API 网关都原生支持 OpenAPI 规范。我们将学习如何使用开源项目 **springdoc-openapi** 来生成此类文档。我们还将学习如何嵌入
    API 文档查看器，**Swagger UI 查看器**，它可以用来检查 API 文档并发出 API 请求。
- en: By the end of this chapter, we will have OpenAPI-based API documentation for
    the external API that’s exposed by the `product-composite-service` microservice.
    The microservice will also expose a Swagger UI viewer that we can use to both
    visualize and test the API.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将拥有由 `product-composite-service` 微服务暴露的基于 OpenAPI 的 API 文档。该微服务还将暴露一个
    Swagger UI 查看器，我们可以用它来可视化并测试 API。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to using springdoc-openapi
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: springdoc-openapi 的使用介绍
- en: Adding springdoc-openapi to the source code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 springdoc-openapi 添加到源代码中
- en: Building and starting the microservice landscape
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和启动微服务景观
- en: Trying out the OpenAPI documentation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用 OpenAPI 文档
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For instructions on how to install the tools used in this book and how to access
    the source code for this book, refer to:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何安装本书中使用的工具以及如何访问本书源代码的说明，请参阅：
- en: '*Chapter 21* installation instructions for mac OS'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第21章* 为 mac OS 安装说明'
- en: '*Chapter 22* installation instructions for Microsoft Windows with WSL 2 and
    Ubuntu'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第22章* 使用 WSL 2 和 Ubuntu 为 Microsoft Windows 安装说明'
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter05`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例全部来自 `$BOOK_HOME/Chapter05` 中的源代码。
- en: If you want to view the changes that were applied to the source code in this
    chapter, that is, see what it took to create OpenAPI-based API documentation using
    springdoc-openapi, you can compare it with the source code for *Chapter 4*, *Deploying
    Our Microservices Using Docker*. You can use your favorite `diff` tool and compare
    the two folders, that is, `$BOOK_HOME/Chapter04` and `$BOOK_HOME/Chapter05`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看对本章源代码所做的更改，即查看使用 springdoc-openapi 创建基于 OpenAPI 的 API 文档所需要的内容，您可以将其与
    *第4章*，*使用 Docker 部署我们的微服务* 的源代码进行比较。您可以使用您喜欢的 `diff` 工具比较两个文件夹，即 `$BOOK_HOME/Chapter04`
    和 `$BOOK_HOME/Chapter05`。
- en: Introduction to using springdoc-openapi
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: springdoc-openapi 的使用介绍
- en: Using springdoc-openapi makes it possible to keep the documentation of the API
    together with the source code that implements the API. With springdoc-openapi,
    you can create the API documentation on the fly at runtime by inspecting Java
    annotations in the code. To me, this is an important feature. If the API documentation
    is maintained in a separate life cycle from the Java source code, they will diverge
    from each other over time. In many cases, this will happen sooner than expected
    (based on my own experience).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 springdoc-openapi 使得将 API 的文档与实现 API 的源代码保持在一起成为可能。通过 springdoc-openapi，您可以在运行时通过检查代码中的
    Java 注解来动态创建 API 文档。对我来说，这是一个重要的功能。如果 API 文档与 Java 源代码分开维护，它们最终会相互分离。根据我的经验，这种情况往往比预期的要早发生。
- en: Before springdoc-openapi was created, another open source project, **SpringFox**
    ([http://springfox.github.io/springfox/](http://springfox.github.io/springfox/)),
    provided similar features. Over recent years, the SpringFox project has not been
    actively maintained and, as a reaction to that, the springdoc-openapi project
    was created. A migration guide for SpringFox users can be found at [https://springdoc.org/#migrating-from-springfox](https://springdoc.org/#migrating-from-springfox).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在springdoc-openapi创建之前，另一个开源项目**SpringFox**([http://springfox.github.io/springfox/](http://springfox.github.io/springfox/))提供了类似的功能。近年来，SpringFox项目没有积极维护，作为对此的反应，创建了springdoc-openapi项目。SpringFox用户的迁移指南可以在[https://springdoc.org/#migrating-from-springfox](https://springdoc.org/#migrating-from-springfox)找到。
- en: As always, it is important to separate the interface of a component from its
    implementation. In terms of documenting a RESTful API, we should add the API documentation
    to the Java interface that describes the API, and not to the Java class that implements
    the API. To simplify updating the textual parts of the API documentation (for
    example, longer descriptions), we can place the descriptions in property files
    instead of in the Java code directly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，将组件的接口与其实现分离是很重要的。在记录RESTful API方面，我们应该将API文档添加到描述API的Java接口中，而不是添加到实现API的Java类中。为了简化更新API文档的文本部分（例如，较长的描述），我们可以将描述放在属性文件中，而不是直接放在Java代码中。
- en: Added to creating the API specification on the fly, springdoc-openapi also comes
    with an embedded API viewer called Swagger UI. We will configure the `product-composite-service`
    service to expose Swagger UI for its API.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了动态创建API规范之外，springdoc-openapi还附带了一个名为Swagger UI的嵌入式API查看器。我们将配置`product-composite-service`服务以暴露Swagger
    UI来查看其API。
- en: Even though Swagger UI is very useful during development and test phases, it
    is typically not exposed in public for APIs in a production environment, for security
    reasons. In many cases, APIs are exposed publicly using an API gateway. Today,
    most API gateway products support exposing API documentation based on an OpenAPI
    document. So instead of exposing Swagger UI, the API’s OpenAPI documentation (generated
    by springdoc-openapi) is exported to an API Gateway that can publish the API documentation
    in a secure way.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Swagger UI在开发和测试阶段非常有用，但由于安全原因，通常不会在生产环境中的API上公开。在许多情况下，API通过API网关公开。今天，大多数API网关产品都支持基于OpenAPI文档公开API文档。因此，而不是公开Swagger
    UI，API的OpenAPI文档（由springdoc-openapi生成）被导出到一个可以安全发布API文档的API网关。
- en: If APIs are expected to be consumed by third-party developers, a developer portal
    can be set up containing documentation and tools, used for self-registration,
    for example. Swagger UI can be used in a developer portal to allow developers
    to learn about the API by reading the documentation and also trying out the APIs
    using a test instance.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果预期API将由第三方开发者使用，可以设置一个包含文档和工具的开发者门户，例如用于自我注册。Swagger UI可以在开发者门户中使用，允许开发者通过阅读文档并使用测试实例尝试API来了解API。
- en: In *Chapter 11*, *Securing Access to APIs*, we will learn how to lock down access
    to APIs using OAuth 2.1\. We will also learn how to configure the Swagger UI component
    to acquire OAuth 2.1 access tokens and use them when the user tries out the APIs
    through Swagger UI.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11章“保护API访问”中，我们将学习如何使用OAuth 2.1锁定对API的访问。我们还将学习如何配置Swagger UI组件以获取OAuth 2.1访问令牌，并在用户通过Swagger
    UI尝试API时使用这些令牌。
- en: 'The following screenshot is an example of what Swagger UI looks like:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是Swagger UI的一个示例：
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_05_01.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B19825_05_01.png)'
- en: 'Figure 5.1: Swagger UI example'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：Swagger UI示例
- en: Some, for now, unimportant parts of the screenshot have been replaced by “**…**”
    in the preceding figure. We will get back to these details later on in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，一些目前不重要的截图部分已被替换为“**…**”。我们将在本章的后面部分回到这些细节。
- en: To enable springdoc-openapi to create the API documentation, we need to add
    some dependencies to our build files and add some annotations to the Java interfaces
    that define the RESTful services. As mentioned above, we will also place the descriptive
    parts of the API documentation in a property file.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用springdoc-openapi创建API文档，我们需要在我们的构建文件中添加一些依赖项，并在定义RESTful服务的Java接口中添加一些注解。如上所述，我们还将API文档的描述部分放在属性文件中。
- en: If parts of the documentation have been placed in property files to simplify
    updating the API documentation, it is important that the property files are handled
    in the same life cycle and under the same version control as the source code.
    Otherwise, there is a risk that they will start to diverge from the implementation,
    that is, become out of date.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文档的部分内容已经放置在属性文件中以简化API文档的更新，那么重要的是属性文件必须与源代码在相同的生命周期和版本控制下处理。否则，存在它们开始与实现脱节的风险，即变得过时。
- en: With springdoc-openapi introduced, let’s see how we can start using it by making
    the required changes in the source code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍了springdoc-openapi之后，让我们看看如何通过在源代码中进行必要的更改来开始使用它。
- en: Adding springdoc-openapi to the source code
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将springdoc-openapi添加到源代码中
- en: 'To add OpenAPI-based documentation regarding the external API that’s exposed
    by the `product-composite-service` microservice, we need to change the source
    code in two projects:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加关于由`product-composite-service`微服务公开的外部API的基于OpenAPI的文档，我们需要更改两个项目的源代码：
- en: '`product-composite-service`: Here, we will set up a configuration of springdoc-openapi
    in the Java application class, `ProductCompositeServiceApplication`, and add some
    general information pertaining to the API.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product-composite-service`：在这里，我们将设置Java应用程序类`ProductCompositeServiceApplication`中的springdoc-openapi配置，并添加一些与API相关的一般信息。'
- en: '`api`: Here, we will add annotations to the Java interface, `ProductCompositeService`,
    describing each RESTful service and its operations. At this stage, we only have
    one RESTful service with one operation, accepting HTTP GET requests to `/product-composite/{productId}`,
    which is used for requesting composite information regarding a specific product.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api`：在这里，我们将向Java接口`ProductCompositeService`添加注解，描述每个RESTful服务和其操作。在这个阶段，我们只有一个RESTful服务和一个操作，接受对`/product-composite/{productId}`的HTTP
    GET请求，用于请求有关特定产品的组合信息。'
- en: The actual texts that are used to describe the API operation will be placed
    in the default property file, `application.yml`, in the `product-composite-service`
    project.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 用于描述API操作的实际文本将被放置在`product-composite-service`项目的默认属性文件`application.yml`中。
- en: Before we can start using springdoc-openapi, we need to add it as a dependency
    in the Gradle build files. So, let’s start with that!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用springdoc-openapi之前，我们需要将其添加到Gradle构建文件中的依赖项。所以，让我们从这里开始吧！
- en: Adding dependencies to the Gradle build files
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将依赖项添加到Gradle构建文件中
- en: 'The springdoc-openapi project is divided into a number of modules. For the
    `api` project, we only need the module that contains the annotations we will use
    to document the API. We can add it to the `api` project’s build file, `build.gradle`,
    as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: springdoc-openapi项目被划分为多个模块。对于`api`项目，我们只需要包含我们将用于文档化的API注解的模块。我们可以将其添加到`api`项目的构建文件`build.gradle`中，如下所示：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `product-composite-service` project requires a more fully featured module
    that contains both the Swagger UI viewer and support for Spring WebFlux. We can
    add the dependency to the build file, `build.gradle`, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`product-composite-service`项目需要一个功能更全面的模块，该模块包含Swagger UI查看器和Spring WebFlux的支持。我们可以在构建文件`build.gradle`中添加依赖项，如下所示：'
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That is all the dependencies that need to be added; now for the configuration.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 需要添加的所有依赖项都已添加；现在让我们进行配置。
- en: Adding OpenAPI configuration and general API documentation to the ProductCompositeService
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将OpenAPI配置和一般API文档添加到ProductCompositeService
- en: To enable springdoc-openapi in the `product-composite-service` microservice,
    we have to add some configuration. To keep the source code compact, we will add
    it directly to the application class, `ProductCompositeServiceApplication.java`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`product-composite-service`微服务中启用springdoc-openapi，我们必须添加一些配置。为了保持源代码紧凑，我们将直接将其添加到应用程序类`ProductCompositeServiceApplication.java`中。
- en: If you prefer, you can place the configuration of springdoc-openapi in a separate
    Spring configuration class.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，可以将springdoc-openapi的配置放置在单独的Spring配置类中。
- en: 'First, we need to define a Spring bean that returns an `OpenAPI` bean. The
    source code looks like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义一个Spring Bean，它返回一个`OpenAPI` Bean。源代码看起来是这样的：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'From the preceding code, we can see that the configuration contains general
    descriptive information about the API, such as:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到配置包含有关API的一般描述性信息，例如：
- en: The name, description, version, and contact information for the API
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API的名称、描述、版本和联系方式
- en: Terms of usage and license information
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条款和许可信息
- en: Links to external information regarding the API, if any
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有的话，有关API的外部信息链接
- en: 'The `api` variables that are used to configure the `OpenAPI` bean are initialized
    from the property file using Spring `@Value` annotations. These are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 用于配置`OpenAPI` bean的`api`变量是通过Spring `@Value`注解从属性文件初始化的。具体如下：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The actual values are set in the property file, `application.yml`, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 实际值在属性文件`application.yml`中设置，如下所示：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The property file also contains some configuration for springdoc-openapi:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 属性文件还包含一些针对springdoc-openapi的配置：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The configuration parameters have the following purposes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 配置参数有以下目的：
- en: '`springdoc.swagger-ui.path` and `springdoc.api-docs.path` are used to specify
    that the URLs used by the embedded Swagger UI viewer are available under the path
    `/openapi`. Later on in this book, when we add different types of edge servers
    in front and address security challenges, this will simplify the configuration
    of the edge servers used. Refer to the following chapters for more information:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`springdoc.swagger-ui.path` 和 `springdoc.api-docs.path` 用于指定嵌入的Swagger UI查看器使用的URL在路径`/openapi`下可用。在本书的后续内容中，当我们添加不同类型的边缘服务器并解决安全挑战时，这将简化边缘服务器的配置。有关更多信息，请参阅以下章节：'
- en: '*Chapter 10*, *Using Spring Cloud Gateway to Hide Microservices behind an Edge
    Server*'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第10章*，*使用Spring Cloud Gateway在边缘服务器后面隐藏微服务*'
- en: '*Chapter 11*, *Securing Access to APIs*'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第11章*，*保护API访问*'
- en: '*Chapter 17*, *Implementing Kubernetes Features to Simplify the System Landscape*,
    the *Replacing the Spring Cloud Gateway* section'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第17章*，*通过实现Kubernetes功能简化系统景观*，*替换Spring Cloud Gateway*部分'
- en: '*Chapter 18*, *Using a Service Mesh to Improve Observability and Management*,
    the *Replacing Kubernetes Ingress controller with Istio Ingress Gateway* section'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第18章*，*使用服务网格提高可观察性和管理*，*用Istio Ingress Gateway替换Kubernetes Ingress控制器*部分'
- en: '`springdoc.packagesToScan` and `springdoc.pathsToMatch` control where in the
    code base springdoc-openapi will search for annotations. The narrower the scope
    we can give springdoc-openapi, the faster the scan will be performed.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`springdoc.packagesToScan` 和 `springdoc.pathsToMatch` 控制springdoc-openapi在代码库中搜索注解的位置。我们能够给springdoc-openapi提供的范围越窄，扫描的速度就越快。'
- en: For details, refer to the application class `ProductCompositeServiceApplication.java`
    and the `application.yml` property file in the `product-composite-service` project.
    We can now proceed to see how to add API-specific documentation to the Java interface
    `ProductCompositeService.java` in the `api` project.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 详细信息请参阅`product-composite-service`项目中的应用程序类`ProductCompositeServiceApplication.java`和`application.yml`属性文件。现在我们可以继续了解如何在`api`项目中的Java接口`ProductCompositeService.java`中添加API特定文档。
- en: Adding API-specific documentation to the ProductCompositeService interface
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向ProductCompositeService接口添加API特定文档
- en: To document the actual API and its RESTful operations, we will add an `@Tag`
    annotation to the Java interface declaration in `ProductCompositeService.java`
    in the `api` project. For each RESTful operation in the API, we will add an `@Operation`
    annotation, along with `@ApiResponse` annotations on the corresponding Java method,
    to describe the operation and its expected responses. We will describe both successful
    and error responses.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了记录实际的API及其RESTful操作，我们将在`api`项目中的`ProductCompositeService.java`接口声明上添加一个`@Tag`注解。对于API中的每个RESTful操作，我们将在相应的Java方法上添加一个`@Operation`注解，以及`@ApiResponse`注解，以描述操作及其预期的响应。我们将描述成功和错误响应。
- en: As well as reading these annotations at runtime, springdoc-openapi will also
    inspect Spring annotations, such as the `@GetMapping` annotation, to understand
    what input arguments the operation takes and what the response will look like
    if a successful response is produced. To understand the structure of potential
    error responses, springdoc-openapi will look for `@RestControllerAdvice` and `@ExceptionHandler`
    annotations. In *Chapter 3*, *Creating a Set of Cooperating Microservices*, we
    added a utility class, `GlobalControllerExceptionHandler.java`, in the `util`
    project.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在运行时读取这些注解外，springdoc-openapi还会检查Spring注解，例如`@GetMapping`注解，以了解操作所接受的输入参数以及如果产生成功响应，响应将呈现什么样子。为了了解潜在错误响应的结构，springdoc-openapi将寻找`@RestControllerAdvice`和`@ExceptionHandler`注解。在第3章*创建一组协作微服务*中，我们在`util`项目中添加了一个实用类，`GlobalControllerExceptionHandler.java`。
- en: This class is annotated with `@RestControllerAdvice`. See the *The global REST
    controller exception handler* section for details. The exception handler takes
    care of `404` (`NOT_FOUND`) and `422` (`UNPROCESSABLE_ENTITY`) errors. To allow
    springdoc-openapi to also correctly document `400` (`BAD_REQUEST`) errors that
    Spring WebFlux generates when it discovers incorrect input arguments in a request,
    we have also added an `@ExceptionHandler` for `400` (`BAD_REQUEST`) errors in
    `GlobalControllerExceptionHandler.java`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类被注解为 `@RestControllerAdvice`。有关详细信息，请参阅 *全局 REST 控制器异常处理器* 部分。异常处理器负责处理 `404`
    (`NOT_FOUND`) 和 `422` (`UNPROCESSABLE_ENTITY`) 错误。为了允许 springdoc-openapi 正确记录
    Spring WebFlux 在发现请求中的不正确输入参数时生成的 `400` (`BAD_REQUEST`) 错误，我们还在 `GlobalControllerExceptionHandler.java`
    中添加了一个 `@ExceptionHandler` 用于 `400` (`BAD_REQUEST`) 错误。
- en: 'The documentation of the API on the resource level, corresponding to the Java
    interface declaration, looks as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 资源级别的 API 文档，对应于 Java 接口声明，如下所示：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For the API operation, we have extracted the actual text used in the `@Operation`
    and `@ApiResponse` annotations to the property file. The annotations contain property
    placeholders, like `${name-of-the-property}`, that springdoc-openapi will use
    to look up the actual text from the property file at runtime. The API operation
    is documented as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 API 操作，我们将 `@Operation` 和 `@ApiResponse` 注解中使用的实际文本提取到了属性文件中。注解包含属性占位符，如
    `${name-of-the-property}`，springdoc-openapi 将在运行时使用这些占位符从属性文件中查找实际文本。API 操作的文档如下所示：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'From the preceding source code, springdoc-openapi will be able to extract the
    following information about the operation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的源代码中，springdoc-openapi 将能够提取以下关于操作的信息：
- en: The operation accepts HTTP GET requests to the URL `/product-composite/{productid}`,
    where the last part of the URL, `{productid}`, is used as an input parameter to
    the request.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该操作接受对 URL `/product-composite/{productid}` 的 HTTP GET 请求，其中 URL 的最后一部分 `{productid}`
    被用作请求的输入参数。
- en: A successful response will produce a JSON structure corresponding to the Java
    class, `ProductAggregate`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功的响应将生成与 Java 类 `ProductAggregate` 对应的 JSON 结构。
- en: In the event of an error, an HTTP error code of either `400`, `404`, or `422`
    will be returned together with error information in the body, as described by
    `@ExceptionHandler` in the Java class `GlobalControllerExceptionHandler.java`
    in the `util` project, as described above.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发生错误的情况下，将返回 HTTP 错误代码 `400`、`404` 或 `422`，并在响应体中包含错误信息，如 Java 类 `GlobalControllerExceptionHandler.java`
    中的 `@ExceptionHandler` 所描述的，如上所述。
- en: 'For the values specified in the `@Operation` and `@ApiResponse` annotations,
    we can use property placeholders directly, without using Spring `@Value` annotations.
    The actual values are set in the property file, `application.yml`, like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `@Operation` 和 `@ApiResponse` 注解中指定的值，我们可以直接使用属性占位符，而无需使用 Spring `@Value`
    注解。实际值在属性文件 `application.yml` 中设置，如下所示：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'From the preceding configuration, we can learn the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的配置中，我们可以了解以下内容：
- en: 'A property placeholder such as `${api.responseCodes.ok.description}` will be
    translated to `OK`. Note the hierarchical structure of the YAML-based property
    file:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，属性占位符 `${api.responseCodes.ok.description}` 将被翻译为 `OK`。注意基于 YAML 的属性文件的层次结构：
- en: '[PRE9]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A multi-line value starts with `|` like the one for the property `api.get-composite-product.description.notes`.
    Also note that springdoc-openapi supports the provision of a multi-line description
    using **Markdown** syntax.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多行值以 `|` 开头，例如属性 `api.get-composite-product.description.notes` 的值。此外，请注意 springdoc-openapi
    支持使用 **Markdown** 语法提供多行描述。
- en: For details, see the service interface class `ProductCompositeService.java`
    in the `api` project and the property file, `application.yml`, in the `product-composite-service`
    project.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有关详细信息，请参阅 `api` 项目中的服务接口类 `ProductCompositeService.java` 和 `product-composite-service`
    项目中的属性文件 `application.yml`。
- en: 'If you want to find out more about how a YAML file is constructed, view the
    specification: [https://yaml.org/spec/1.2/spec.html](https://yaml.org/spec/1.2/spec.html).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 YAML 文件结构的信息，请查看规范：[https://yaml.org/spec/1.2/spec.html](https://yaml.org/spec/1.2/spec.html)。
- en: Building and starting the microservice landscape
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 和 启动 微服务环境
- en: Before we can try out the OpenAPI documentation, we need to build and start
    the microservice landscape!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试 OpenAPI 文档之前，我们需要构建并启动微服务环境！
- en: 'This can be done with the following commands:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下命令完成：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You may run into an error message regarding port `8080` already being allocated.
    This will look as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到一个关于端口 `8080` 已经被分配的错误消息。这看起来如下：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If this is the case, you might have forgotten to bring down the microservice
    landscape from the previous chapter. To find out the names of the executing containers,
    run the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，你可能忘记从上一章拉取微服务景观。要找出正在运行的容器的名称，请运行以下命令：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A sample response when a microservice landscape from the previous chapter is
    still running is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当上一章的微服务景观仍在运行时的一个示例响应如下：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you find containers from other chapters in the output from the command,
    for example, from *Chapter 4*, *Deploying Our Microservices Using Docker*, as
    in the preceding example, you need to jump over to the source code folder for
    that chapter and bring down its containers:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在命令输出中发现了来自其他章节的容器，例如，来自 *第 4 章*，*使用 Docker 部署我们的微服务*，就像前面的例子中那样，你需要跳转到该章节的源代码文件夹并拉取其容器：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, you can bring up the missing container for this chapter:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以启动本章缺失的容器：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note that only the missing container, `product-composite`, is started by the
    command since the other ones were already started successfully:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于其他容器已经成功启动，命令仅启动了缺失的容器 `product-composite`：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To wait for the microservice landscape to start up and verify that it works,
    you can run the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要等待微服务景观启动并验证其是否正常工作，你可以运行以下命令：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that the test script, `test-em-all.bash`, has been extended with a set
    of tests that verifies that the Swagger UI endpoints work as expected:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，测试脚本 `test-em-all.bash` 已扩展，包含一组测试，以验证 Swagger UI 端点按预期工作：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With the successful startup of the microservices, we can move on and try out
    the OpenAPI documentation exposed by the `product-composite` microservice using
    its embedded Swagger UI viewer.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务成功启动后，我们可以继续尝试使用其嵌入的 Swagger UI 查看器测试 `product-composite` 微服务暴露的 OpenAPI
    文档。
- en: Trying out the OpenAPI documentation
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试 OpenAPI 文档
- en: 'To browse the OpenAPI documentation, we will use the embedded Swagger UI viewer.
    If we open the [http://localhost:8080/openapi/swagger-ui.html](http://localhost:8080/openapi/swagger-ui.html)
    URL in a web browser, we will see a web page that looks something like the following
    screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要浏览 OpenAPI 文档，我们将使用嵌入的 Swagger UI 查看器。如果我们在一个网络浏览器中打开 [http://localhost:8080/openapi/swagger-ui.html](http://localhost:8080/openapi/swagger-ui.html)
    URL，我们将看到一个类似于以下截图的网页：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_05_02.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B19825_05_02.png)'
- en: 'Figure 5.2: OpenAPI documentation with the Swagger UI viewer'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：带有 Swagger UI 查看器的 OpenAPI 文档
- en: 'Here, we can ascertain the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以确认以下内容：
- en: The general information we specified in the springdoc-openapi `OpenAPI` bean
    and a link to the actual OpenAPI document, **/openapi/v3/api-docs**, pointing
    to `http://localhost:8080/openapi/v3/api-docs`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 springdoc-openapi `OpenAPI` bean 中指定的通用信息以及指向实际 OpenAPI 文档的链接，**/openapi/v3/api-docs**，指向
    `http://localhost:8080/openapi/v3/api-docs`。
- en: Note that this is the link to the OpenAPI document that can be exported to an
    API Gateway, as discussed in the *Introduction to using springdoc-openapi* section
    above.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这是可以导出到 API 网关的 OpenAPI 文档链接，如上节 *springdoc-openapi 使用介绍* 中所述。
- en: A list of API resources; in our case, the **ProductComposite** API.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API 资源列表；在我们的例子中，是 **ProductComposite** API。
- en: At the bottom of the page, there is a section where we can inspect the schemas
    used in the API.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面底部，有一个我们可以检查 API 中使用的模式的区域。
- en: Proceed with the examination of the API documentation as follows.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照以下步骤进行 API 文档的检查。
- en: Click on the **ProductComposite** API resource to expand it. You will get a
    list of operations that are available on the resource. You will only see one operation,
    **/product-composite/{productId}**.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **ProductComposite** API 资源以展开它。您将获得该资源上可用的操作列表。您将只看到一个操作，**/product-composite/{productId}**。
- en: 'Click on it to expand it. You will see the documentation of the operation that
    we specified in the `ProductCompositeService` Java interface:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击它以展开。您将看到我们指定在 `ProductCompositeService` Java 接口中的操作文档：
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_05_03.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序  自动生成的描述](img/B19825_05_03.png)'
- en: 'Figure 5.3: ProductComposite API documentation'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：ProductComposite API 文档
- en: 'Here, we can see the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到以下内容：
- en: The one-line description of the operation.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作的一行描述。
- en: A section with details regarding the operation, including the input parameters
    it supports. Note how the Markdown syntax from the `notes` field in the `@ApiOperation`
    annotation has been nicely rendered!
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含操作细节的章节，包括它支持的输入参数。注意 `@ApiOperation` 注解中 `notes` 字段中的 Markdown 语法已经被很好地渲染了！
- en: If you scroll down the web page, you will also find documentation regarding
    the expected responses and their structure, both for a normal **200** (**OK**)
    response…
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向下滚动网页，你也会找到有关预期响应及其结构的文档，包括正常 **200**（OK）响应的文档…
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_05_04.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，自动生成的描述](img/B19825_05_04.png)'
- en: 'Figure 5.4: Documentation for a 200 response'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：200 响应的文档
- en: '…and the various 4xx error responses we defined earlier, as shown in the following
    screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: …以及我们之前定义的各种 4xx 错误响应，如下面的截图所示：
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_05_05.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，自动生成的描述](img/B19825_05_05.png)'
- en: 'Figure 5.5: Documentation for 4xx responses'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：4xx 响应的文档
- en: For each documented potential error response, we can learn about its meaning
    and the structure of the response body.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个文档化的潜在错误响应，我们可以了解其含义和响应体的结构。
- en: 'If we scroll back up to the parameter description, we will find the **Try it
    out** button. If we click on the button, we can fill in actual parameter values
    and send a request to the API by clicking on the **Execute** button. For example,
    if we enter `123` in the **productId**field, we will get the following response:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向上滚动到参数描述，我们会找到 **尝试一下** 按钮。如果我们点击该按钮，我们可以填写实际的参数值，并通过点击 **执行** 按钮向 API
    发送请求。例如，如果我们将在 **productId** 字段中输入 `123`，我们将得到以下响应：
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_05_06.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，自动生成的描述](img/B19825_05_06.png)'
- en: 'Figure 5.6: Response after sending a request for an existing product'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：发送现有产品请求后的响应
- en: We will get an expected **200** (OK) as the response code and a JSON structure
    in the response body that we are already familiar with!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到预期的 **200**（OK）作为响应代码，以及我们已熟悉的 JSON 结构在响应体中！
- en: 'If we enter an incorrect input, such as `-1`, we will get a proper error code
    as the response code, **422**, and a corresponding JSON-based error description
    in the response body:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们输入一个错误的输入，例如 `-1`，我们将得到一个适当的错误代码作为响应代码，**422**，以及响应体中的基于 JSON 的错误描述：
- en: '![Graphical user interface, application, Teams  Description automatically generated](img/B19825_05_07.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，自动生成的描述](img/B19825_05_07.png)'
- en: 'Figure 5.7: Response after sending a request with invalid input'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：发送无效输入后的响应
- en: 'Note that the **message** field in the response body clearly points out the
    problem: **“Invalid productId: -1”**.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '注意响应体中的 **message** 字段清楚地指出了问题：**“Invalid productId: -1”**。'
- en: 'If you want to try calling the API without using the Swagger UI viewer, you
    can copy the corresponding `curl` command from the **Responses** section and run
    it in a Terminal window, as shown in the preceding screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在不使用 Swagger UI 查看器的情况下尝试调用 API，你可以从 **响应** 部分复制相应的 `curl` 命令，并在终端窗口中运行它，如前一个截图所示：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Great, isn’t it?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，不是吗？
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Good documenting of an API is essential for its acceptance, and OpenAPI is one
    of the most commonly used specifications when it comes to documenting RESTful
    services. springdoc-openapi is an open source project that makes it possible to
    create OpenAPI-based API documentation on the fly at runtime by inspecting Spring
    WebFlux and Swagger annotations. Textual descriptions of an API can be extracted
    from the annotations in the Java source code and placed in a property file for
    ease of editing. springdoc-openapi can be configured to bring an embedded Swagger
    UI viewer into a microservice, which makes it very easy to read about APIs that
    have been exposed by the microservice and also try them out from the viewer.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的 API 文档对于其接受至关重要，而 OpenAPI 是在文档化 RESTful 服务时最常用的规范之一。springdoc-openapi 是一个开源项目，它通过检查
    Spring WebFlux 和 Swagger 注解，使得在运行时动态创建基于 OpenAPI 的 API 文档成为可能。API 的文本描述可以从 Java
    源代码中的注解中提取出来，并放置在属性文件中以方便编辑。springdoc-openapi 可以配置为将内嵌的 Swagger UI 查看器引入微服务中，这使得阅读微服务公开的
    API 以及从查看器中尝试它们变得非常容易。
- en: Now, what about bringing some life to our microservices by adding persistence,
    that is, the capability to save those microservices’ data in a database? To do
    this, we will need to add some more APIs so that we can create and delete the
    information that’s handled by the microservices. Head over to the next chapter
    to find out more!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于通过添加持久性来给我们的微服务带来活力，也就是说，将那些微服务的数据保存到数据库中的能力，我们该怎么办？为此，我们需要添加一些更多的API，以便我们可以创建和删除由微服务处理的信息。前往下一章了解更多！
- en: Questions
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does springdoc-openapi help us create API documentation for RESTful services?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Springdoc-openapi是如何帮助我们为RESTful服务创建API文档的？
- en: What specification for documenting APIs does springdoc-openapi support?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Springdoc-openapi支持哪种API文档规范？
- en: What is the purpose of the springdoc-openapi `OpenAPI` bean?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: springdoc-openapi的`OpenAPI` bean的用途是什么？
- en: Name some annotations that springdoc-openapi reads at runtime to create the
    API documentation on the fly.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举一些springdoc-openapi在运行时读取的注解，以动态创建API文档。
- en: 'What does the code “`: |`" mean in a YAML file?'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在YAML文件中，代码“`: |`"代表什么意思？'
- en: How can you repeat a call to an API that was performed using the embedded Swagger
    UI viewer without using the viewer again?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在不再次使用查看器的情况下重复调用使用嵌入式Swagger UI查看器执行的API调用？
- en: Join our community on Discord
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussion with the author and other
    readers:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/SpringBoot3e](https://packt.link/SpringBoot3e)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SpringBoot3e](https://packt.link/SpringBoot3e)'
- en: '![](img/QR_Code1849216352344398875.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1849216352344398875.png)'
