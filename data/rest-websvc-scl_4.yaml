- en: Chapter 4. An Easy REST Service Using Scalatra
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：使用Scalatra创建简单的REST服务
- en: In the previous chapters, you learned how to create REST services using frameworks
    that use a functional, Scala language-like approach. Finch used a very functional
    programming-based approach, and Unfiltered used pattern matching. In this chapter,
    we explore a Scala framework, Scalatra, whose main goal is simplicity.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您学习了如何使用使用函数式、类似Scala语言的方法的框架来创建REST服务。Finch使用了一种非常基于函数式编程的方法，而Unfiltered使用模式匹配。在本章中，我们将探索一个Scala框架，Scalatra，其主要目标是简单性。
- en: 'In this chapter, we''ll explain Scalatra''s functionality using the following
    examples:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过以下示例解释Scalatra的功能：
- en: '**First Scalatra service**: We''ll create a simple Scalatra service that shows
    how you can get up and running.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一个Scalatra服务**：我们将创建一个简单的Scalatra服务，展示您如何快速启动。'
- en: '**Verb and path handling**: Scalatra provides a number of constructs you can
    use to define a route. A route can match a specific HTTP verb and path and on
    a match, it will return a specific response.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动词和路径处理**：Scalatra提供了一系列构造，您可以使用它们来定义路由。一个路由可以匹配特定的HTTP动词和路径，并在匹配时返回特定的响应。'
- en: '**Add support for futures and simple validation**: In its standard configuration,
    Scalatra works synchronously. In this part, we''ll show you how you can add support
    for futures and also add some basic validation.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加对未来的支持和简单验证**：在其标准配置中，Scalatra是同步工作的。在本部分，我们将向您展示如何添加对未来的支持，并添加一些基本的验证。'
- en: '**Convert to and from JSON and support advanced validations**: In the last
    part of this chapter, we''ll look at JSON support and explain how Scalatra supports
    a more advanced way of validating incoming requests.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换到和从JSON，并支持高级验证**：在本章的最后部分，我们将探讨JSON支持，并解释Scalatra如何支持更高级的验证传入请求的方式。'
- en: First, though, let's have a quick look at what Scalatra is, and what it aims
    to do.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们快速了解一下Scalatra是什么，以及它的目标是什么。
- en: Introduction to Scalatra
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scalatra简介
- en: Scalatra is a small Scala web framework which tries to keep things simple. It
    provides a set of guidelines and helper classes to create complete web applications.
    In this chapter, we'll focus on the support it provides to create REST services.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Scalatra是一个小巧的Scala Web框架，它试图保持简单。它提供了一套指南和辅助类，用于创建完整的Web应用程序。在本章中，我们将重点关注它为创建REST服务提供的支持。
- en: 'Scalatra is built with a number of principles in mind (from the Scalatra home
    page):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Scalatra在设计时考虑了多个原则（来自Scalatra主页）：
- en: '*Start small, build upwards: Start with a small core, and have lots of easy
    integrations for common tasks.*'
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*从小处着手，逐步构建：从一个小的核心开始，并为常见任务提供大量易于集成的功能。*'
- en: ''
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Freedom: Allow the user freedom to choose whatever structure and libraries
    make the most sense for the application being built.*'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*自由：允许用户自由选择对正在构建的应用程序最有意义的结构和库。*'
- en: ''
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Solid, but not stolid: Use solid base components. For instance, servlets aren''t
    cool, but they are extremely stable and have a huge community behind them. At
    the same time, work to advance the state of web application development by using
    new techniques and approaches.*'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*坚实但不过于僵化：使用坚实的基组件。例如，servlets可能不是酷的，但它们非常稳定，并且有一个庞大的社区支持。同时，通过使用新技术和方法来推进Web应用程序开发的状态。*'
- en: ''
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Love HTTP: Embrace HTTP and its stateless nature. People get into trouble
    when they fool themselves into thinking things which aren''t true - fancy server-side
    tricks to give an illusion of statefulness aren''t for us.*'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*热爱HTTP：拥抱HTTP及其无状态特性。当人们自欺欺人地认为一些不真实的事情时，他们会陷入麻烦 - 花哨的服务器端技巧来营造状态性的错觉并不适合我们。*'
- en: As you'll see in this chapter, the main goal of Scalatra is to keep things simple.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在本章中看到的，Scalatra的主要目标是保持简单。
- en: Your first Scalatra service
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的第一个Scalatra服务
- en: 'To get our first Scalatra service up and running, we need to take a couple
    of extra steps. The reason is that Scalatra is designed to run in a servlet container
    (for example, Tomcat or Jetty). While this works great for test and production
    environments, it doesn''t allow us to do some quick prototyping or easily run
    from SBT or an IDE. Luckily, you can also start the Jetty servlet container programmatically
    and run your Scalatra service from there. So, in this section, we''ll:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的第一个Scalatra服务运行起来，我们需要采取一些额外的步骤。原因是Scalatra被设计为在servlet容器（例如Tomcat或Jetty）中运行。虽然这对于测试和生产环境来说效果很好，但它不允许我们进行快速原型设计或轻松地从SBT或IDE中运行。幸运的是，您也可以以编程方式启动Jetty
    servlet容器，并从那里运行Scalatra服务。因此，在本节中，我们将：
- en: Start by showing you the dependencies required to run Scalatra
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先展示运行 Scalatra 所需的依赖项
- en: Setting up Jetty in such a way that it can run our Scalatra REST service
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以这种方式设置 Jetty，使其能够运行我们的 Scalatra REST 服务
- en: Creating a simple Scalatra service that responds to a specific `GET` request
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的 Scalatra 服务，以响应特定的 `GET` 请求
- en: 'First, let''s look at the dependencies for Scalatra. You can find these in
    the `Dependencies.scala` file in the `project` directory of the `sources` directory.
    For Scalatra (and Jetty), we define the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看 Scalatra 的依赖项。你可以在 `sources` 目录下的 `project` 目录中的 `Dependencies.scala`
    文件中找到这些依赖项。对于 Scalatra（以及 Jetty），我们定义以下内容：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first dependency in this `Seq` pulls in all the required Scalatra libraries,
    the second one allows us to define how and what Jetty will log, and the final
    dependency is needed so that we can start Jetty programmatically from our project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `Seq` 中的第一个依赖项引入了所有必需的 Scalatra 库，第二个依赖项允许我们定义 Jetty 的日志记录方式和内容，最后一个依赖项是必需的，这样我们才能从我们的项目中以编程方式启动
    Jetty。
- en: 'With these dependencies defined, we can create an embedded Jetty server, which
    we can use to serve our REST services. The code for this launcher can be found
    in the `chapter4/package.scala` file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这些依赖项之后，我们可以创建一个嵌入式的 Jetty 服务器，我们可以使用它来提供我们的 REST 服务。这个启动器的代码可以在 `chapter4/package.scala`
    文件中找到：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We'll not dive too much into this code since it isn't really related to Scalatra.
    The main thing to understand here is that we've defined a function called `launch`,
    which takes the name of a bootstrap class as a parameter (more on this later)
    and that we've added a `ScalatraListener` instance using the `addEventListener`
    function. Once the Jetty server has finished starting up, the `ScalatraListener`
    will be called and start the Scalatra service using the provided `bootstrapClass`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨这段代码，因为它实际上与 Scalatra 并无太大关联。这里要理解的主要是，我们定义了一个名为 `launch` 的函数，它接受一个启动类名称作为参数（稍后会有更多介绍），并且我们使用
    `addEventListener` 函数添加了一个 `ScalatraListener` 实例。一旦 Jetty 服务器启动完成，`ScalatraListener`
    将被调用，并使用提供的 `bootstrapClass` 启动 Scalatra 服务。
- en: 'Now that we''ve created a way to launch our Scalatra service, let''s look at
    the most basic example (source can be found in the `HelloScalatra.scala` file):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一种启动我们的 Scalatra 服务的方法，让我们看看最基础的示例（源代码可以在 `HelloScalatra.scala` 文件中找到）：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's walk through this file from top to bottom. At the top, we define an object
    called `ScalatraRunner`. With this object, we start our REST service by calling
    launch on the `JettyLauncher` we saw previously. We also pass the name of the
    `ScalatraBootstrap` class to the launcher so that the `ScalatraListener` we saw
    earlier can call the ScalatraBootstrap's `init` method when Jetty has finished
    starting up. In the `ScalatraBootstrap` class, we implement the `init` method
    and use that to instantiate our REST service (in this example, it is called `HelloScalatra`)
    and make it available to the outside world by calling mount. For each of the examples
    in this chapter, we'll use this same approach. In the `HelloScalatra` class, we
    finally see our REST service definition. In this case, we define a route which
    returns `Hello from scalatra` when it receives a `GET` request on the `/` path.
    If no route matches, the `notFound` function is triggered which returns a `404`
    message stating `route not found`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从头到尾浏览这个文件。在顶部，我们定义了一个名为 `ScalatraRunner` 的对象。通过这个对象，我们通过调用之前看到的 `JettyLauncher`
    上的 `launch` 方法来启动我们的 REST 服务。我们还向启动器传递了 `ScalatraBootstrap` 类的名称，这样我们之前看到的 `ScalatraListener`
    就可以在 Jetty 启动完成后调用 ScalatraBootstrap 的 `init` 方法。在 `ScalatraBootstrap` 类中，我们实现了
    `init` 方法，并使用它来实例化我们的 REST 服务（在这个例子中，它被称为 `HelloScalatra`），并通过调用 mount 使其对外界可用。在本章的每个示例中，我们都会使用这种方法。在
    `HelloScalatra` 类中，我们最终看到了 REST 服务的定义。在这种情况下，我们定义了一个路由，当它收到 `/` 路径上的 `GET` 请求时，返回
    `Hello from scalatra`。如果没有路由匹配，`notFound` 函数将被触发，返回一个 `404` 消息，表明“路由未找到”。
- en: 'All that is left to do is test these two scenarios. From the sources directory,
    run `sbt runCH04-HelloScalatra`. This should show an output similar to this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是测试这两个场景。从源代码目录中，运行 `sbt runCH04-HelloScalatra`。这应该会显示类似于以下内容的输出：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At this point, we can press *Enter* to stop the server or fire up Postman and
    test our service. In Postman, you''ll find a collection of requests for this chapter;
    let''s just test the request (`hello scalatra`), which returns our `Hello from
    scalatra` message so that we know everything is working as it should be:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以按 *Enter* 键停止服务器，或者启动 Postman 来测试我们的服务。在 Postman 中，你会找到一个针对本章的请求集合；让我们只测试这个请求（`hello
    scalatra`），它返回我们的 `Hello from scalatra` 消息，这样我们就可以知道一切是否按预期工作：
- en: '![Your first Scalatra service](img/00028.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![您的第一个Scalatra服务](img/00028.jpeg)'
- en: As we can see in the preceding screenshot, the response from Scalatra is as
    we expected, so our basic Scalatra setup is working correctly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，Scalatra的响应正如我们所期望的，因此我们的基本Scalatra设置工作正确。
- en: Verb and path handling
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动词和路径处理
- en: 'Now that we''ve got our basic Scalatra REST service running, let''s look at
    a more elaborate example, which we''ll use to explore some more features of Scalatra.
    Before we look at the code, let''s make a request from Postman. First, start the
    server by calling `sbt runCH04-runCH04Step1` from the console, which shows something
    similar to this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了基本的Scalatra REST服务，让我们看看一个更复杂的例子，我们将用它来探索Scalatra的一些更多功能。在我们查看代码之前，让我们从Postman发起一个请求。首先，通过控制台调用`sbt
    runCH04-runCH04Step1`来启动服务器，它将显示类似以下内容：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, open up Postman and from the folder, `chapter-04`, select `request Step
    01 – Update Task` and send it to the server. This request will simulate creating
    a new task and will respond by echoing some of the information it has received:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开Postman，从文件夹`chapter-04`中选择`request Step 01 – Update Task`并发送到服务器。这个请求将模拟创建一个新的任务，并通过回显它接收到的部分信息来响应：
- en: '![Verb and path handling](img/00029.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![动词和路径处理](img/00029.jpeg)'
- en: 'As you can see from the preceding screenshot, our server is up and running,
    and responds with a message containing the updated task. Next, we''ll walk through
    the code of this Scalatra service:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，我们的服务器正在运行，并返回包含更新任务的消息。接下来，我们将逐步分析这个Scalatra服务的代码：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we mentioned in the previous section, we need to call `JettyLauncher` and
    define a `ScalatraBootstrapStep1` class to run our service. The interesting code
    in this example is located in the `ScalatraStep1` class, which defines a number
    of routes that we can call from our REST client.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，我们需要调用`JettyLauncher`并定义一个`ScalatraBootstrapStep1`类来运行我们的服务。在这个例子中，有趣的代码位于`ScalatraStep1`类中，它定义了我们可以从REST客户端调用的多个路由。
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When you look at the routes in this chapter, you'll notice that the more generic
    routes are at the top of the `ScalatraServlet` class. The reason is that Scalatra
    tries to match incoming requests starting from the bottom and from there, it moves
    up. So when defining routes, take care that you place the most generic routes
    at the top and the most specific ones at the bottom.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看本章中的路由时，你会注意到更通用的路由位于`ScalatraServlet`类的顶部。原因是Scalatra试图从底部开始匹配传入的请求，然后向上移动。因此，在定义路由时，请注意将最通用的路由放在顶部，最具体的路由放在底部。
- en: 'In the `ScalatraStep1` class, we define a number of routes. Let''s look at
    a couple of these:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ScalatraStep1`类中，我们定义了多个路由。让我们看看其中的一些：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we see two routes. The `get("/tasks/:id")` matches `GET` HTTP requests
    made on a URL, which looks similar to `/tasks/12`. When the request is made, we
    use the `params` function to get the value of the path segment and try and convert
    it to an integer. If this is successful, we just return a string, and if not,
    we return the HTTP error, `BadRequest`. The `put("tasks/:id")` route matches `PUT`
    HTTP requests and always returns a string, which contains the provided ID using
    the `params` function, and also shows the sent message body that can be accessed
    through the `request.body` value. Besides the `params` function, Scalatra also
    provides a `multiParams` function. With the `multiParams` function, you don't
    get a single string, but a `Seq[String]` instance. This is especially useful if
    you want to access request parameters that have multiple values. For instance,
    if we match on `/task/search?status=new,old`, we can get a `Seq[String]` containing
    new and old by calling `multiParams("status")`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到两个路由。`get("/tasks/:id")`匹配类似`/tasks/12`的URL上的`GET` HTTP请求。当请求被发送时，我们使用`params`函数获取路径段值，并尝试将其转换为整数。如果成功，我们只返回一个字符串；如果不成功，我们返回HTTP错误`BadRequest`。`put("tasks/:id")`路由匹配`PUT`
    HTTP请求，并始终返回一个字符串，该字符串包含使用`params`函数提供的ID，并显示通过`request.body`值可以访问的发送的消息体。除了`params`函数外，Scalatra还提供了一个`multiParams`函数。使用`multiParams`函数，你不会得到一个单独的字符串，而是一个`Seq[String]`实例。如果你想要访问具有多个值的请求参数，这特别有用。例如，如果我们匹配`/task/search?status=new,old`，我们可以通过调用`multiParams("status")`来获取包含new和old的`Seq[String]`。
- en: 'Besides matching directly on a path element, Scalatra also supports a number
    of other ways to match an HTTP request. The following table shows how you can
    match specific HTTP verbs and routes in Scalatra:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了直接匹配路径元素外，Scalatra还支持多种匹配HTTP请求的方式。下表显示了如何在Scalatra中匹配特定的HTTP动词和路由：
- en: '| Construct | Description |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 构建 | 描述 |'
- en: '| --- | --- |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `get("/")`, `post("/")`, `put("/")`, `delete("/")` and the other HTTP verbs.
    | Scalatra allows you to match a specific HTTP verb. Scalatra supports the following
    HTTP verbs, which you can directly use in your route definition: `options`, `get`,
    `head`, `post`, `put`, `delete`, `trace`, `connect`, and `patch`. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `get("/")`, `post("/")`, `put("/")`, `delete("/")` 和其他 HTTP 动词。 | Scalatra
    允许您匹配特定的 HTTP 动词。Scalatra 支持以下 HTTP 动词，您可以直接在路由定义中使用：`options`、`get`、`head`、`post`、`put`、`delete`、`trace`、`connect`
    和 `patch`。 |'
- en: '| `get("/full/path")` | The most basic way to match a request on a specific
    path is by specifying the full path to match on. This will only match if the provided
    path matches exactly. In this case, `"/full/path"` will match, while `"/full/path/something"`
    won''t. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `get("/full/path")` | 匹配特定路径上的请求的最基本方法是指定要匹配的完整路径。这只会匹配提供的路径完全匹配的情况。在这种情况下，`"/full/path"`将匹配，而`"/full/path/something"`则不会匹配。
    |'
- en: '| `get("/path/:param")` | As we''ve seen in the examples, you can also extract
    variables from the path by prefixing a path segment with a `:`. This will match
    paths such as `"/path/12"` and `"path/hello"`. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `get("/path/:param")` | 如示例所示，您还可以通过在路径段前加冒号来从路径中提取变量。这将匹配类似于`"/path/12"`和`"path/hello"`的路径。
    |'
- en: '| `get("""^\/tasks\/(.*)""".r)` | You can also use a regular expression to
    match a specific path in Scalatra. To access the groups that match, you can either
    use the `params("splat")` call or through the `multiParams("splat")` function
    call. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `get("""^\/tasks\/(.*)""".r)` | 您还可以使用正则表达式在 Scalatra 中匹配特定路径。要访问匹配的组，您可以使用`params("splat")`调用或通过`multiParams("splat")`函数调用。
    |'
- en: '| `get("/*/*")` | Scalatra also support the use of wildcards. You can access
    the parameters that match either through the `params("splat")` call or through
    the `multiParams("splat")` function call. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `get("/*/*")` | Scalatra 还支持使用通配符。您可以通过`params("splat")`调用或通过`multiParams("splat")`函数调用来访问匹配的参数。
    |'
- en: '| `get("/tasks", condition1, condition2)` | You can further fine-tune the matching
    by supplying conditions. A condition is a function that returns either `True`
    or `False`. If all conditions return `True`, the route matches, and is executed.
    For example, you can use something similar to `post("/tasks", request.getHeader("headername")
    == "headerValue")`. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `get("/tasks", condition1, condition2)` | 您可以通过提供条件来进一步微调匹配。条件是一个返回`True`或`False`的函数。如果所有条件都返回`True`，则路由匹配并执行。例如，您可以使用类似`post("/tasks",
    request.getHeader("headername") == "headerValue")`的代码。 |'
- en: 'Before we move on to the next section, let''s have a quick look at how you
    can access all the attributes of a request. So far, we''ve seen `params`, `multiParams`,
    and `request.body` to access certain parts. Scalatra also exposes the other parts
    of a request. The following table shows a complete overview of the helper functions
    and request properties exposed by Scalatra (note that you can easily use these
    request properties as conditions in your routes):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节之前，让我们快速了解一下如何访问请求的所有属性。到目前为止，我们已经看到了`params`、`multiParams`和`request.body`来访问某些部分。Scalatra
    还公开了请求的其他部分。以下表格显示了 Scalatra 公开的辅助函数和请求属性的完整概述（请注意，您可以将这些请求属性轻松用作路由中的条件）：
- en: '| Function | Description |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `requestPath` | This returns the path against which the route is matched.
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `requestPath` | 这返回与路由匹配的路径。 |'
- en: '| `multiParams(key)` | This returns the value of a request parameter (or match
    path segment) as a `Seq[String]`. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `multiParams(key)` | 这返回请求参数（或匹配路径段）的值作为 `Seq[String]`。 |'
- en: '| `Params(key)` | This returns the value of a request parameter (or match path
    segment) as a string. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `Params(key)` | 这返回请求参数（或匹配路径段）的值作为字符串。 |'
- en: '| `request.serverProtocol` | This returns an `HttpVersion` object, which is
    either `Http11` or `Http10`. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `request.serverProtocol` | 这返回一个`HttpVersion`对象，可以是`Http11`或`Http10`。 |'
- en: '| `request.uri` | This is the URI of the request as a `java.net.URI`. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `request.uri` | 这是以 `java.net.URI` 形式的请求 URI。 |'
- en: '| `request.urlScheme` | This returns a `Scheme` object, either `Http` or `Https`.
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `request.urlScheme` | 这返回一个 `Scheme` 对象，可以是 `Http` 或 `Https`。 |'
- en: '| `request.requestMethod` | This returns an `HttpMethod`, for example, `Get`,
    `Post`, or `Put`. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `request.requestMethod` | 这返回一个`HttpMethod`对象，例如`Get`、`Post`或`Put`。 |'
- en: '| `request.pathInfo` | This returns the path info from the request or an empty
    string if no pathinfo is available. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `request.pathInfo` | 这返回请求的路径信息，如果没有路径信息则返回空字符串。 |'
- en: '| `Request.scriptName` | This returns the servlet path part of the request
    as a string. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `Request.scriptName` | 这返回请求的servlet路径部分作为字符串。 |'
- en: '| `Request.queryString` | This returns the query string of the request or an
    empty string if no query string is present. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `Request.queryString` | 这返回请求的查询字符串，如果没有查询字符串则返回空字符串。|'
- en: '| `Request.multiParameters` | This returns a map of all the parameters of this
    request as a `MultiMap`. This contains the parameters from the query string and
    any posted form data. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `Request.multiParameters` | 这返回一个映射，包含此请求的所有参数作为`MultiMap`。这包含查询字符串中的参数和任何已提交的表单数据。|'
- en: '| `request.headers` | This returns all the headers as a `Map[String, String]`
    object. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `request.headers` | 这返回所有头部作为`Map[String, String]`对象。|'
- en: '| `request.header(key)` | This gets a specific header from the request and
    returns an `Option[String]`. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `request.header(key)` | 从请求中获取特定的头部并返回一个`Option[String]`。|'
- en: '| `request.characterEncoding` | This returns, if present, the character encoding
    of the request and an `Option[String]`. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `request.characterEncoding` | 如果存在，这返回请求的字符编码和一个`Option[String]`。|'
- en: '| `request.contentType` | This gets the content-type of the request if present
    and returns an `Option[String]`. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `request.contentType` | 如果存在，这获取请求的内容类型并返回一个`Option[String]`。|'
- en: '| `request.contentLength` | This gets the length of the content and returns
    an `Option[Long]`. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `request.contentLength` | 这获取内容的长度并返回一个`Option[Long]`。|'
- en: '| `request.serverName` | This returns the server name part of the complete
    path and a string. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `request.serverName` | 这返回完整路径的服务器名称部分和一个字符串。|'
- en: '| `request.serverPort` | This returns the port of the server as an integer.
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `request.serverPort` | 这返回服务器端口号作为整数。|'
- en: '| `request.referrer` | This tries to get the referrer from the request and
    returns an `Option[String]`. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `request.referrer` | 这尝试从请求中获取引用并返回一个`Option[String]`。|'
- en: '| `request.body` | This returns the body of the request as a string. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `request.body` | 这返回请求的正文作为字符串。|'
- en: '| `request.isAjax` | This checks whether the request is an AJAX request. It
    does this by checking the presence of an `X-Requested-With` header. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `request.isAjax` | 检查请求是否为AJAX请求。它通过检查`X-Requested-With`头部的存在来完成此操作。|'
- en: '| `request.isWrite` | Checks whether the request is not safe (see RFC 2616).
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `request.isWrite` | 检查请求是否不是安全请求（参见RFC 2616）。|'
- en: '| `request.multiCookie` | This returns a map of all the cookies of this request
    as a `MultiMap`. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `request.multiCookie` | 这返回一个映射，包含此请求的所有cookie作为`MultiMap`。|'
- en: '| `request.cookies` | This returns all the cookies as a `Map[String, String]`.
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `request.cookies` | 这返回所有cookie作为`Map[String, String]`。|'
- en: '| `request.inputStream` | This gets the `inputStream` of the request, which
    can be used to read the body. Note that this `inputStream` is already consumed
    when you call `request.body`. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `request.inputStream` | 这获取请求的`inputStream`，可以用来读取正文。注意，当你调用`request.body`时，这个`inputStream`已经被消耗了。|'
- en: '| `request.remoteAddress` | This tries to get the clients IP address and returns
    it as a string. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `request.remoteAddress` | 这尝试获取客户端的IP地址，并以字符串形式返回。|'
- en: '| `request.locale` | This returns the `Locale` value from the request. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `request.locale` | 这返回请求中的`Locale`值。|'
- en: As you can see, Scalatra wraps all the normal request properties and attributes
    you'd expect and makes them easily available either through some helper functions
    or as properties on the available request value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Scalatra封装了所有你期望的正常请求属性和属性，并通过一些辅助函数或作为可用请求值上的属性使它们易于访问。
- en: Now that we've explored the basic functionality of Scalatra and seen how we
    can match HTTP verbs and paths, we'll look at some more advanced features in the
    next section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了Scalatra的基本功能，并看到了我们如何匹配HTTP动词和路径，接下来我们将查看下一节中的一些更高级的功能。
- en: Add support for futures and simple validation
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加对future和简单验证的支持
- en: 'In this section, we''ll add support for futures to Scalatra and show a couple
    of first steps to validate incoming requests. To work asynchronously, Scalatra
    needs some additional dependencies. The complete list of dependencies required
    for this examples are the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为Scalatra添加对future的支持，并展示验证传入请求的一些初步步骤。为了异步工作，Scalatra需要一些额外的依赖项。本示例所需的依赖项完整列表如下：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see from the dependencies, Scalatra uses Akka ([http://akka.io](http://akka.io))
    to handle requests asynchronously. However, you don''t need to know much about
    Akka to get everything up and running. In the following code fragment, we show
    you the basic glue that is required to connect all the moving parts:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如从依赖关系中所见，Scalatra使用Akka ([http://akka.io](http://akka.io))来异步处理请求。然而，你不需要了解太多关于Akka的知识就可以让一切正常运行。在下面的代码片段中，我们展示了连接所有移动部件所需的基本粘合剂：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this code fragment, we use the JettyLauncher we''ve already seen to start
    the Jetty server and specify the Scalatra bootstrap class that we want to start
    when Jetty is started. In the bootstrap for this example, we take a couple of
    additional steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们使用之前看到的 JettyLauncher 来启动 Jetty 服务器，并指定当 Jetty 启动时要启动的 Scalatra 引导类。在这个示例的引导中，我们采取了一些额外的步骤：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When this class is instantiated, we create a new Akka, `ActorSystem`, which
    is required by Akka. We pass this system to the constructor of our Scalatra route
    (`ScalatraStep2`) so that we can use it from there. In this bootstrap class, we
    also override the `destroy` function. When the Jetty server is shut down, this
    will neatly close the `ActorSystem` and clean up any open resources.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个类被实例化时，我们创建一个新的 Akka，`ActorSystem`，这是 Akka 所必需的。我们将这个系统传递给我们的 Scalatra 路由（`ScalatraStep2`）的构造函数，这样我们就可以从那里使用它。在这个引导类中，我们还重写了
    `destroy` 函数。当 Jetty 服务器关闭时，这将优雅地关闭 `ActorSystem` 并清理任何打开的资源。
- en: 'Before we look at the code that handles our routes, we''ll first make some
    calls from Postman to better understand what our routes need to do. So, start
    the server for this part with `sbt runCH04-runCH04Step2`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看处理路由的代码之前，我们首先使用 Postman 进行一些调用，以便更好地理解我们的路由需要做什么。因此，使用 `sbt runCH04-runCH04Step2`
    命令启动这部分的服务器：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now create a number of tasks by using the **Step 02 – Create Task** request
    from this chapter:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过使用本章的 **Step 02 – Create Task** 请求创建多个任务：
- en: '![Add support for futures and simple validation](img/00030.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![添加对 futures 和简单验证的支持](img/00030.jpeg)'
- en: 'To get an overview of all the tasks that have been stored, use the **Step 02
    – Get All Tasks** request:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有已存储任务的概览，请使用 **Step 02 – Get All Tasks** 请求：
- en: '![Add support for futures and simple validation](img/00031.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![添加对 futures 和简单验证的支持](img/00031.jpeg)'
- en: 'As you can see from the two screenshots, this time we store the tasks, and
    you can retrieve them through other REST calls. The code for these two routes,
    and a route to delete a task based on an ID, is shown next:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从两个截图中所见，这次我们存储了任务，您可以通过其他 REST 调用来检索它们。这两个路由的代码，以及基于 ID 删除任务的路由代码，将在下面展示：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s walk through this code fragment and see what is happening. Let''s start
    with the definition of the class that holds the routes and the first statement
    inside the class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遍历这个代码片段，看看发生了什么。让我们从包含路由的定义和类中的第一个语句开始：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This time, besides extending from `ScalatraServlet`, we also mix in the `FutureSupport`
    trait. When we mix in this trait, we add support for futures to Scalatra. This
    trait also requires us to define an `ExecutionContext` instance. In this example,
    we use the default, `ExecutionContext`, provided by Akka. You can, of course,
    also define and configure one yourself.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，除了从 `ScalatraServlet` 继承之外，我们还混合了 `FutureSupport` 特质。当我们混合这个特质时，我们为 Scalatra
    添加了对 futures 的支持。这个特质还要求我们定义一个 `ExecutionContext` 实例。在这个例子中，我们使用了 Akka 提供的默认 `ExecutionContext`。当然，您也可以定义并配置一个自己的。
- en: Tip
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: An `ExecutionContext` is used by programs to execute logic asynchronously and
    for the developer to gain a finer control of threading. You could, for instance,
    execute a piece of code by passing a `Runnable` instance to the `execute` method.
    Scalatra and Akka hide all the details of how the `ExecutionContext` is used,
    but it is up to the developer to specify which `ExecutionContext` to use and how
    it is configured.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecutionContext` 被程序用来异步执行逻辑，并让开发者能够更精细地控制线程。例如，您可以通过将一个 `Runnable` 实例传递给
    `execute` 方法来执行一段代码。Scalatra 和 Akka 隐藏了 `ExecutionContext` 的所有使用细节，但是开发者需要指定要使用哪个
    `ExecutionContext` 以及如何配置它。'
- en: 'Now that we''ve configured the last part, we can look at running calls asynchronously.
    The first route we''ll look at is the `get("/tasks")` route:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了最后一部分，我们可以查看异步运行的调用。我们将首先查看的路线是 `get("/tasks")` 路由：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This route is very simple. It calls the `TaskService.all` function, which returns
    a `Future[List[Task]]` and we transform this to a `Future[String]` through the
    `map` function. Internally, Scalatra will run this request on top of Akka, and
    wait, non-blocking, for the `Future` to finish. Once it is finished, Scalatra
    will return the string to the client. The great thing is that you don''t have
    to do anything yourself. Just return a `Future` object, and Scalatra knows how
    to handle everything since we added `FutureSupport`. In this sample, we just return
    a string inside the `Future`. Scalatra also supports a number of other return
    types you can use:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由非常简单。它调用 `TaskService.all` 函数，该函数返回一个 `Future[List[Task]]`，我们通过 `map` 函数将其转换为
    `Future[String]`。内部，Scalatra 将在此请求之上运行 Akka，并等待，非阻塞地等待 `Future` 完成。一旦完成，Scalatra
    将将字符串返回给客户端。好事是，你不需要做任何事情。只需返回一个 `Future` 对象，Scalatra 就知道如何处理一切，因为我们添加了 `FutureSupport`。在这个示例中，我们只是在
    `Future` 中返回一个字符串。Scalatra 还支持许多其他你可以使用的返回类型：
- en: '| Type | Description |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ActionResult` | An `ActionResult` type is a class where you can set the
    status, body, and headers which are returned. Scalatra comes with a large number
    of standard `ActionResult` you can use—`OK`, `Created`, `Accepted`, and so on.
    For a complete overview, look at the source for the `ActionResult.scala` file.
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `ActionResult` | `ActionResult` 类型是一个类，你可以设置返回的状态、主体和头部。Scalatra 提供了大量标准
    `ActionResult`，你可以使用——`OK`、`Created`、`Accepted` 等等。要查看完整概述，请查看 `ActionResult.scala`
    文件的源代码。|'
- en: '| `Array[Byte]` | The content-type of the response (if not set) is set to application/octet-stream,
    and the byte array is returned. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `Array[Byte]` | 如果未设置，响应的内容类型将被设置为 application/octet-stream，并且返回字节数组。|'
- en: '| `NodeSeq` | The content-type of the response (if not set) is set to `text/HTML`
    and the `NodeSeq` instance is converted to a string and is returned. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `NodeSeq` | 如果未设置，响应的内容类型将被设置为 `text/HTML`，并且 `NodeSeq` 实例将被转换为字符串并返回。|'
- en: '| `Unit` | If you don''t specify anything, Scalatra assumes you''ve set the
    correct values in the response object yourself. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `Unit` | 如果你没有指定任何内容，Scalatra 假设你已经自己设置了响应对象中的正确值。|'
- en: '| `Any` | The content-type of the response (if not set) is set to `text/plain`
    and the `toString` method is called on the object and the result is returned.
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `Any` | 如果未设置，响应的内容类型将被设置为 `text/plain`，并且将在对象上调用 `toString` 方法，然后返回结果。|'
- en: Note that you can override this functionality, or add new functionality, by
    overriding the `renderResponse` function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以通过覆盖 `renderResponse` 函数来覆盖此功能或添加新功能。
- en: 'Now let''s look at the `delete("/tasks/:id")` route:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 `delete("/tasks/:id")` 路由：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `TaskService.delete` service returns a `Future[Option[Task]]`, which we
    transform to a `Future[String]`, just like we did in the previous code fragment.
    The main difference here is that we don't directly return a `Future`, but wrap
    the block inside an `AsyncResult` object. The reason why we need to do this is
    that we access values from the request. We use `params("id")` to get the value
    from the URL path. If you access any information from the request, you need to
    wrap it in an `AsyncResult` object to avoid timing issues and strange exceptions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskService.delete` 服务返回一个 `Future[Option[Task]]`，我们将其转换为 `Future[String]`，就像我们在之前的代码片段中所做的那样。这里的主要区别是我们不直接返回一个
    `Future`，而是将代码块包裹在一个 `AsyncResult` 对象中。我们需要这样做的原因是我们从请求中访问值。我们使用 `params("id")`
    从 URL 路径中获取值。如果你从请求中访问任何信息，你需要将其包裹在一个 `AsyncResult` 对象中，以避免时序问题和奇怪的异常。'
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'When working with futures or when adding new complex routes, it is often practical
    to add some logging to see what is happening before and after the request has
    been processed. Scalatra supports this through the `before("path")` and `after("path")`
    functions you can define in your class. In this example, we, for instance, log
    every request by specifying a `before(/*)` function and log some additional information
    afterward for the request made to a specific path defined by a regular expression:
    `after(""""^\/tasks\/(.*)"""".r).`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理 futures 或添加新的复杂路由时，通常在实际操作中添加一些日志来查看请求处理前后的情况是非常有用的。Scalatra 通过你可以在类中定义的
    `before("path")` 和 `after("path")` 函数来支持这一点。在这个例子中，我们通过指定一个 `before(/*)` 函数来记录每个请求，并在对由正则表达式定义的特定路径发出的请求之后记录一些附加信息：`after(""""^\/tasks\/(.*)"""".r).`
- en: 'Now let''s move on to some simple validations. Look at the following code from
    the `POST` method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续一些简单的验证。看看以下来自 `POST` 方法的代码：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What you see here is that we can use `getOrElse` on the parameters to check
    whether it is provided, and if not, we can either throw an error or add a default
    value.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里看到的是我们可以使用 `getOrElse` 在参数上检查它是否提供，如果没有提供，我们可以抛出一个错误或者添加一个默认值。
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that we've used a special construct here from Scalatra—`halt`. When this
    function is called, Scalatra will immediately stop processing the request and
    return the specified HTTP response. Besides halt, Scalatra also provides a `pass`
    function which can be used to stop processing inside the current route and instead
    try to see if there are other routes that might match.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里使用了 Scalatra 的一个特殊构造——`halt`。当这个函数被调用时，Scalatra 将立即停止处理请求并返回指定的 HTTP
    响应。除了 `halt` 之外，Scalatra 还提供了一个 `pass` 函数，它可以用来在当前路由内部停止处理，并尝试查看是否有其他可能匹配的路由。
- en: This is just some basic simple validation. In the next section, we'll look at
    the more advanced ways of adding validation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一些基本的简单验证。在下一节中，我们将探讨添加验证的更高级方法。
- en: Advanced validation and JSON support
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级验证和 JSON 支持
- en: For the final example, we're going to add JSON support to the service and some
    more advanced validations. To test the examples in this section, run `sbt runCH04-runCH04Step3`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后的示例，我们将向服务添加 JSON 支持和一些更高级的验证。要测试本节中的示例，请运行 `sbt runCH04-runCH04Step3`。
- en: Add JSON support
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 JSON 支持
- en: 'Let''s start by adding JSON support. First off, add the following dependencies
    to the SBT build file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加 JSON 支持开始。首先，将以下依赖项添加到 SBT 构建文件中：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Adding JSON support only takes a couple of simple steps. First, change the
    class definition of our route to the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 JSON 支持只需要几个简单的步骤。首先，将我们路由的类定义更改为以下内容：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With the `JacksonJsonSupport` trait added, we next need to add the following
    line to enable automatic JSON parsing:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了 `JacksonJsonSupport` 特性之后，我们接下来需要在配置文件中添加以下行以启用自动 JSON 解析：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we only need to inform the routes that we want to work with JSON. For this,
    we use the `before()` function, where we set the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要通知路由我们想要使用 JSON。为此，我们使用 `before()` 函数，并设置以下内容：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'At this point, we can just return our case classes, and Scalatra will automatically
    convert them to JSON. For instance, for the get all tasks service, it looks similar
    to this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们只需返回我们的案例类，Scalatra 将自动将它们转换为 JSON。例如，对于获取所有任务的服务，它看起来像这样：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Before we look at Postman and see the requests, we need to take one final step
    so that we can also store the incoming JSON messages. Let''s look at the `post("/tasks")`
    function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看 Postman 并查看请求之前，我们需要采取最后一步，以便我们也可以存储传入的 JSON 消息。让我们看看 `post("/tasks")`
    函数：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s see this in action. Open Postman and, using the **Step 03 – Add Task**
    request, add some tasks:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际效果。打开 Postman，使用 **Step 03 – Add Task** 请求添加一些任务：
- en: '![Add JSON support](img/00032.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![添加 JSON 支持](img/00032.jpeg)'
- en: 'As you can see, the body we sent is a JSON message describing the task. Retrieving
    the messages works in pretty much the same way. In Postman, you can use the **Step
    03 – Get All Tasks** request for this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们发送的正文是一个描述任务的 JSON 消息。检索消息的方式基本上相同。在 Postman 中，你可以使用 **Step 03 – Get
    All Tasks** 请求来做这件事：
- en: '![Add JSON support](img/00033.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![添加 JSON 支持](img/00033.jpeg)'
- en: And here, you can see that the tasks you just added are returned.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到你刚刚添加的任务被返回。
- en: Advanced validations
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级验证
- en: 'Now that we''ve got JSON support added, let''s look at the final part of this
    chapter and explore how you can add more advanced validations to your Scalatra
    routes. The first thing we need to do is add one more dependency to our `sbt`
    build file (`scalatra-commands`). At this point, our dependencies should look
    similar to this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了 JSON 支持，让我们看看本章的最后一部分，并探讨如何向 Scalatra 路由添加更高级的验证。首先，我们需要在我们的 `sbt`
    构建文件中添加一个额外的依赖项（`scalatra-commands`）。到这一点，我们的依赖项应该看起来像这样：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Through the use of commands, we can add more complex validations to our input
    parameters. For this, we need to change a couple of things in our route. The first
    thing we need to do is add `CommandSupport` to our route:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用命令，我们可以向输入参数添加更复杂的验证。为此，我们需要在我们的路由中更改一些设置。首先，我们需要在我们的路由中添加 `CommandSupport`：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This allows us to process incoming requests using commands. Next, we need to
    specify which types of command our service should process. Since we only use a
    single command in this case, we set the `CommandType` to `SearchTaskCommand` (more
    on this file later):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们使用命令来处理传入的请求。接下来，我们需要指定我们的服务应该处理哪些类型的命令。由于在这种情况下我们只使用一个命令，我们将`CommandType`设置为`SearchTaskCommand`（关于这个文件的内容稍后讨论）：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s look a bit closer at the commands and validations we''ll use in this
    example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看在这个例子中我们将使用的命令和验证：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At the bottom of this object, we define a `SearchTasksCommand` class. This command
    will process the incoming parameters (since we extend from `ParamsOnlyCommand`)
    and check whether the incoming parameters are valid. In this case, we don't validate
    the text parameter, but expect the `status` parameter to validate against the
    `notBlank`, `minLength`, and the custom `validStatus` validators. In this object,
    we also define an implicit conversion between the `SearchTaskCommand` class and
    the `SearchParams` case class, which we can use in our service. This makes the
    code in our route more clean, as we'll see later.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个对象的底部，我们定义了一个`SearchTasksCommand`类。这个命令将处理传入的参数（因为我们扩展了`ParamsOnlyCommand`），并检查传入的参数是否有效。在这种情况下，我们不验证文本参数，但期望`status`参数通过`notBlank`、`minLength`和自定义的`validStatus`验证器进行验证。在这个对象中，我们还定义了`SearchTaskCommand`类和`SearchParams`案例类之间的隐式转换，我们可以在我们的服务中使用它。这使得我们的路由中的代码更加简洁，正如我们稍后将会看到的。
- en: We also define a custom validator in this object—the `ValidStatusValidations`
    class. This class takes a `FieldDescriptor` as its input and defines a `validStatus`
    function. In the `validStatus` function, we use the `validateWith` function of
    the `FieldDescriptor` to validate the value of the parameter. We can write this
    ourselves or use the `PredicateValidator`, as we did in this example. Once the
    validation is defined, we make it available in our command by defining the `implicit
    def statusValidator` conversion.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在这个对象中定义了一个自定义验证器——`ValidStatusValidations`类。这个类接受一个`FieldDescriptor`作为输入，并定义了一个`validStatus`函数。在`validStatus`函数中，我们使用`FieldDescriptor`的`validateWith`函数来验证参数的值。我们可以自己编写这个函数，或者像在这个例子中那样使用`PredicateValidator`。一旦定义了验证，我们通过定义`implicit
    def statusValidator`转换使其在我们的命令中可用。
- en: 'Scalatra comes with a large set of validators out of the box, which you can
    use in the manner explained here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Scalatra自带了一组大量的验证器，您可以使用这里解释的方式使用它们：
- en: '| Name | Description |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `notEmpty` | This checks whether the provided field contains a value |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `notEmpty` | 这检查提供的字段是否包含值 |'
- en: '| `greaterThan` | This tries to convert value to a number and checks whether
    it is greater than the provided value |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `greaterThan` | 这尝试将值转换为数字，并检查它是否大于提供的值 |'
- en: '| `lessThan` | This tries to convert value to a number and checks whether it
    is less than the provided value |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `lessThan` | 这尝试将值转换为数字，并检查它是否小于提供的值 |'
- en: '| `greaterThanOrEqualTo` | This tries to convert value to a number and checks
    whether it is greater than or equal to the provided value |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `greaterThanOrEqualTo` | 这尝试将值转换为数字，并检查它是否大于或等于提供的值 |'
- en: '| `lessThanOrEqualTo` | This tries to convert value to a number and checks
    whether it is less than or equal to the provided value |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `lessThanOrEqualTo` | 这尝试将值转换为数字，并检查它是否小于或等于提供的值 |'
- en: '| `notBlank` | This removes any spaces and checks whether the provided field
    still contains a value |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `notBlank` | 这删除任何空格，并检查提供的字段是否仍然包含值 |'
- en: '| `validEmail` | This checks whether the value is a valid e-mail value |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `validEmail` | 这检查值是否是有效的电子邮件值 |'
- en: '| `validAbsoluteUrl` | This checks whether the value is a valid absolute URL
    |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `validAbsoluteUrl` | 这检查值是否是有效的绝对URL |'
- en: '| `validUrl` | This checks whether the value is a valid URL |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `validUrl` | 这检查值是否是有效的URL |'
- en: '| `validForFormat` | This checks the value against the provided regular expression
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `validForFormat` | 这将值与提供的正则表达式进行比较 |'
- en: '| `minLength` | This validates whether the value''s length is at least a specific
    amount of characters |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `minLength` | 这验证值的长度是否至少是特定数量的字符 |'
- en: '| `maxLength` | This validates whether the value''s length is less than a specific
    amount of characters |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `maxLength` | 这验证值的长度是否小于特定数量的字符 |'
- en: '| `enumValue` | This checks whether the value is one of the provided values
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `enumValue` | 这检查值是否是提供的值之一 |'
- en: 'Now, we can finally use the command in our route:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于可以在我们的路由中使用这个命令了：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The syntax might be a bit rough, but the following steps happen here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 语法可能有点粗糙，但以下步骤在这里发生：
- en: '`Command[SearchTasksCommand] >>` means that we execute the command specified
    in the `SearchTasksCommand` class and call the function to the right of `>>`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Command[SearchTasksCommand] >>`意味着我们执行`SearchTasksCommand`类中指定的命令，并调用`>>`右侧的函数'
- en: The provided function in this case is `TaskServiceWrapper.wrapSearch()`
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下提供的函数是`TaskServiceWrapper.wrapSearch()`
- en: The result of this service is a `ModelValidation[T]` on which we can call `fold`
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个服务的结果是一个`ModelValidation[T]`，我们可以调用`fold`
- en: If our validation returns errors, we halt the call and return the errors
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的验证返回错误，我们将停止调用并返回错误
- en: If our validation returns tasks, we just return those
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的验证返回任务，我们就直接返回那些任务
- en: 'Since we need to return a `ModelValidation[T]` instance, we have created a
    simple wrapper service around the `TaskService`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要返回一个`ModelValidation[T]`实例，我们在`TaskService`周围创建了一个简单的包装服务：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: At this point, when we call the `/tasks/search` URL, Scalatra will create the
    command, execute the validations, and if successful, call the `WrapSearch` function
    and return a set of tasks. If errors occur during validations, those will be returned
    instead.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，当我们调用`/tasks/search` URL时，Scalatra将创建命令，执行验证，如果成功，将调用`WrapSearch`函数并返回一组任务。如果在验证过程中发生错误，将返回这些错误。
- en: 'You can easily test this with Postman. First, add some tasks through the **Step
    03 – Add Task** request. Now when you call **Step 03 – Search Tasks**, you''ll
    just get a set of valid results:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用Postman轻松测试这个。首先，通过**步骤 03 – 添加任务**请求添加一些任务。现在当你调用**步骤 03 – 搜索任务**时，你将只得到一组有效结果：
- en: '![Advanced validations](img/00034.jpeg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![高级验证](img/00034.jpeg)'
- en: 'If, on the other hand, you call **Step 03 – Search Tasks – Invalid**, you''ll
    see an error message:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你调用**步骤 03 – 搜索任务 – 无效**，你会看到一个错误信息：
- en: '![Advanced validations](img/00035.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![高级验证](img/00035.jpeg)'
- en: In this section, we saw some of the possibilities Scalatra commands provide
    for validation. You can do much more with commands than shown in this section;
    for more information, refer to the Scalatra commands documentation at [http://www.scalatra.org/2.3/guides/formats/commands.html](http://www.scalatra.org/2.3/guides/formats/commands.html).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了Scalatra命令为验证提供的可能性。你可以使用命令做更多的事情，比本节中展示的还要多；对于更多信息，请参阅Scalatra命令文档[http://www.scalatra.org/2.3/guides/formats/commands.html](http://www.scalatra.org/2.3/guides/formats/commands.html)。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use Scalatra to create a REST service. We
    saw that you need a custom Jetty launcher to run Scalatra standalone since it's
    been created to run inside servlet containers. Once you've got Scalatra running,
    you can just add routes to a class, and they will be automatically picked up when
    you run Scalatra. Remember, though, that routes are matched starting from the
    bottom and going up. Scalatra also provides easy access to all the properties
    of a request and some basic validations through the use of Options. For more advanced
    validations, you can use the `scalatra-commands` module, where you can automatically
    parse incoming parameters and validate against a large set of validators. Finally,
    adding JSON support to Scalatra is very easy. All you have to is add the correct
    modules to your build and import the conversions classes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用Scalatra创建REST服务。我们看到了你需要一个自定义Jetty启动器来运行Scalatra独立，因为它被创建为在servlet容器内运行。一旦Scalatra运行起来，你只需将路由添加到一个类中，它们在运行Scalatra时将被自动拾取。记住，但是，路由是从底部开始匹配并向上进行的。Scalatra还通过使用Options提供对请求所有属性的轻松访问和一些基本验证。对于更高级的验证，你可以使用`scalatra-commands`模块，其中你可以自动解析传入的参数并验证一大组验证器。最后，将JSON支持添加到Scalatra非常简单。你只需要将正确的模块添加到你的构建中并导入转换类。
- en: In the next chapter, we'll show you how to use the Spray-based DSL from Akka
    HTTP to create REST services.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向你展示如何使用基于Spray的Akka HTTP DSL创建REST服务。
