- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: gRPC API Development and Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC API 开发和测试
- en: You will learn how to implement gRPC-based APIs in this chapter. You will learn
    how to write the gRPC server and client along with writing APIs based on gRPC.
    In the later part of this chapter, you will be introduced to microservices and
    see how they can help you to design modern, scalable architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何实现基于 gRPC 的 API。您将学习如何编写 gRPC 服务器和客户端，以及基于 gRPC 编写 API。在本章的后期部分，您将介绍微服务，并了解它们如何帮助您设计现代、可扩展的架构。
- en: You will also go through the implementation of two services – the gRPC server
    and the gRPC client. gRPC-based APIs are more popular and preferred over REST
    APIs for service-to-service communication in a microservice-based system. Hence,
    gRPC development skills are important in the API space.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将通过实现两个服务 – gRPC 服务器和 gRPC 客户端。基于 gRPC 的 API 在基于微服务的系统中比 REST API 更受欢迎和首选，因此
    gRPC 开发技能在 API 领域非常重要。
- en: After completing this chapter, you will be well versed in the gRPC server and
    client development, gRPC-based API testing automation, and microservice concepts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将精通 gRPC 服务器和客户端开发、基于 gRPC 的 API 测试自动化以及微服务概念。
- en: 'You will explore the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将探索以下主题：
- en: Writing an API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 API
- en: Developing the gRPC server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 gRPC 服务器
- en: Handling errors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误
- en: Developing the gRPC client
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 gRPC 客户端
- en: Learning microservice concepts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习微服务概念
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter contains a great deal of theory on gRPC. However, you will also
    undertake the development and testing of gRPC-based web services, for which you
    will need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含大量关于 gRPC 的理论。然而，您还将承担基于 gRPC 的 Web 服务的开发和测试，为此您需要以下内容：
- en: Any Java IDE, such as NetBeans, IntelliJ, or Eclipse
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何 Java IDE，例如 NetBeans、IntelliJ 或 Eclipse
- en: '**Java Development Kit** (**JDK**) 17'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 开发工具包**（**JDK**）17'
- en: An internet connection to clone the code and download the dependencies and Gradle
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到互联网以克隆代码并下载依赖项和 Gradle
- en: Postman/cURL (for API testing)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Postman/cURL（用于 API 测试）
- en: 'Please visit the following link to check the code: [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请访问以下链接以检查代码：[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11)
- en: So, let’s begin!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Writing an API
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 API
- en: In this section, we will write the API using **Protocol Buffer** (**Protobuf**)
    for a payment service. If you recall, this is the piece that you haven’t yet implemented
    in the sample e-commerce app.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 **Protocol Buffer**（**Protobuf**）为支付服务编写 API。如果您还记得，这是在示例电子商务应用中尚未实现的部分。
- en: Before writing the API, let’s set up the Gradle project.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 API 之前，让我们设置 Gradle 项目。
- en: Setting up the project
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'The code for this chapter will contain three projects under the `Chapter11`
    directory – the API, server, and client:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码将在 `Chapter11` 目录下包含三个项目 – API、服务器和客户端：
- en: '`.proto` file and its generated Java classes packaged in a JAR file. This project
    will generate the `payment-gateway-api-0.0.1.jar` library artifact, which you
    will publish in a local repository. This library will then be used in both the
    server and client projects.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.proto` 文件及其打包在 JAR 文件中的生成的 Java 类。此项目将生成 `payment-gateway-api-0.0.1.jar`
    库工件，您将在本地仓库中发布它。此库将在服务器和客户端项目中使用。'
- en: '**Server**: This project represents the gRPC server, which will implement the
    gRPC services and serve the gRPC requests.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器**: 此项目代表 gRPC 服务器，它将实现 gRPC 服务并处理 gRPC 请求。'
- en: '**Client**: This project contains the gRPC client, which will call the gRPC
    server. To kick off the inter-service communication between the gRPC server and
    client applications, you are going to implement a REST call, which will call the
    gRPC server internally to serve the HTTP request.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户**: 此项目包含 gRPC 客户端，它将调用 gRPC 服务器。为了启动 gRPC 服务器和客户端应用程序之间的服务间通信，您将实现一个 REST
    调用，该调用将内部调用 gRPC 服务器以处理 HTTP 请求。'
- en: Let’s first create the server and client projects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建服务器和客户端项目。
- en: Creating the gRPC server and client projects
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 gRPC 服务器和客户端项目
- en: 'Either you can clone the [*Chapter 11*](B19349_11.xhtml#_idTextAnchor250) code
    from the Git repository ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11))
    or you can start by creating the new Spring project from scratch using `api` library
    project separately):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择从Git仓库克隆[*第11章*](B19349_11.xhtml#_idTextAnchor250)代码（[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11)）或者您可以从创建单独的`api`库项目开始，从头创建新的Spring项目：
- en: '`Gradle -` `Groovy`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gradle -` `Groovy`'
- en: '`Java`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Java`'
- en: '`3.0.8`.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3.0.8`.'
- en: The preferred version is *3.0+*. Please choose the version that is available.
    You can modify it manually in the `build.gradle` file later too.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的版本是*3.0+*。请选择可用的版本。您也可以稍后在`build.gradle`文件中手动修改它。
- en: '`com.packt.modern.api`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.packt.modern.api`'
- en: '`chapter11`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter11`'
- en: '`Chapter11`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chapter11`'
- en: '`Chapter 11 code of book Modern API Development with Spring and Spring Boot`
    `Ed 2`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《现代Spring和Spring Boot API开发》第11章代码 第2版
- en: '`com.packt.modern.api`.*   `Jar`.*   `17`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.packt.modern.api`.*   `Jar`.*   `17`.'
- en: 'You can opt for any new version, such as *20*. It can be modified in the `build.gradle`
    file later too, as shown in the following code block:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择任何新版本，例如*20*。您也可以稍后在`build.gradle`文件中修改它，如下面的代码块所示：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`Spring Web`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Spring Web`.'
- en: Then, you can click on **GENERATE** and download the project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以点击**生成**并下载项目。
- en: The downloaded project can be used to create both the server and the client.
    Then, create separate `server` and `client` directories under the `Chapter11`
    directory. After creating the directories, copy the extracted content from the
    downloaded zipped project into them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下载的项目可以用来创建服务器和客户端。然后，在`Chapter11`目录下创建单独的`server`和`client`目录。创建目录后，将下载的压缩项目中的提取内容复制到它们中。
- en: You can configure the server and client projects later. Let’s first create the
    gRPC API library project as this library is going to be used in both the server
    and client projects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以稍后配置服务器和客户端项目。让我们首先创建gRPC API库项目，因为这个库将在服务器和客户端项目中使用。
- en: Creating the gRPC API library project
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建gRPC API库项目
- en: 'Create a new directory, called `api`, in the `Chapter11` directory. Then, use
    Gradle to create a new Gradle project using the following command executed from
    the `Chapter11` directory. It will ask for a few options. The following block
    is executed after setting the `JAVA_HOME` environment variable to Java 17 and
    adding Java 17 to the path. You may find the order of questions a bit different
    in some systems. You should select the options highlighted in the following terminal
    interface output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter11`目录下创建一个新的目录，命名为`api`。然后，使用Gradle从`Chapter11`目录执行以下命令来创建一个新的Gradle项目。它将要求选择一些选项。以下块是在设置`JAVA_HOME`环境变量为Java
    17并将Java 17添加到路径后执行的。您可能会在某些系统中发现问题的顺序略有不同。您应该选择以下终端界面输出中突出显示的选项：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The project is bootstrapped by Gradle. Next, you will configure the `api` project.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 项目由Gradle引导。接下来，您将配置`api`项目。
- en: Configuring the gRPC API library project
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置gRPC API库项目
- en: 'Here, you will configure the `plugins` section in `api/libs/build.gradle` with
    the Protobuf and Maven Publish plugins. These plugins and setting their configuration
    are key steps. Let’s do this as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将在`api/libs/build.gradle`中的`plugins`部分配置Protobuf和Maven Publish插件。这些插件及其配置是关键步骤。让我们按以下方式操作：
- en: 'Modify `api/settings.gradle` in the project’s root directory:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改项目根目录下的`api/settings.gradle`：
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: plugins {    id 'java'    id 'maven-publish'    id "com.google.protobuf" version
    "0.9.2"}
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: plugins {    id 'java'    id 'maven-publish'    id "com.google.protobuf" version
    "0.9.2"}
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Maven Publish plugin will be used to publish the generated `Jar` artifact
    to the local Maven repository.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用Maven Publish插件将生成的`Jar`工件发布到本地Maven仓库。
- en: 'Add the group name, version, and source compatibility in `api/libs/build.gradle`,
    as shown in the following code block. The group and version will be used by the
    Maven Publish plugin to name the published artifact:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`api/libs/build.gradle`中添加组名、版本和源兼容性，如下面的代码块所示。组和版本将由Maven Publish插件用于命名发布的工件：
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, add the following dependencies, which are required for Protobuf and gRPC
    (check the highlighted part). You can remove the existing dependencies added while
    generating the project using the `gradlew init` command and keep the dependencies
    mentioned next:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加以下依赖项，这些依赖项对于 Protobuf 和 gRPC 是必需的（检查突出显示的部分）。你可以删除使用 `gradlew init` 命令生成项目时添加的现有依赖项，并保留下一节中提到的依赖项：
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: protobuf {  protoc {    artifact = "com.google.protobuf:protoc:3.22.2"  }  plugins
    {    grpc {      artifact = "io.grpc:protoc-gen-grpc-java:1.54.0"    }  }  generateProtoTasks
    {    all()*.plugins {      grpc { }    }  }}
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: protobuf {  protoc {    artifact = "com.google.protobuf:protoc:3.22.2"  }  plugins
    {    grpc {      artifact = "io.grpc:protoc-gen-grpc-java:1.54.0"    }  }  generateProtoTasks
    {    all()*.plugins {      grpc { }    }  }}
- en: '[PRE6]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, you have configured the artifact used by the Protobuf
    compiler (`protoc`) and its Java plugin (`protoc-gen-grpc-java`), which will generate
    the Java code based on `.``proto` files.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你已配置了 Protobuf 编译器（`protoc`）及其 Java 插件（`protoc-gen-grpc-java`），它将根据
    `.proto` 文件生成 Java 代码。
- en: When you run the `gradlew` `build` command for the first time, Gradle will download
    the `protoc` and `protoc-gen-grpc-java` executables based on the OS.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次运行 `gradlew build` 命令时，Gradle 将根据操作系统下载 `protoc` 和 `protoc-gen-grpc-java`
    可执行文件。
- en: 'The Protobuf Gradle plugin works with the configuration shared hitherto in
    this subsection. It works when you run the `build` command from the command line.
    However, the IDE may give a compilation error if you don’t add the following block
    to the `api/libs/build.gradle` file to add the generated source files to `sourceSets`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Protobuf Gradle 插件与该子节中迄今为止共享的配置一起工作。当你从命令行运行 `build` 命令时，它会工作。然而，如果你不将以下块添加到
    `api/libs/build.gradle` 文件中，以将生成的源文件添加到 `sourceSets`，IDE 可能会给出编译错误：
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, you will add the following block to configure the Maven Publish plugin:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你需要在配置 Maven Publish 插件时添加以下块：
- en: '[PRE8]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, you have configured the `api` project. You can find more information about
    the Protobuf Gradle plugin at [https://github.com/google/protobuf-gradle-plugin](https://github.com/google/protobuf-gradle-plugin).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你已经配置了 `api` 项目。你可以在 [https://github.com/google/protobuf-gradle-plugin](https://github.com/google/protobuf-gradle-plugin)
    找到有关 Protobuf Gradle 插件更多信息。
- en: Now that the `api` project setup is done, we are ready to write the service
    definitions using Protobuf in the next subsection. You haven’t yet implemented
    the payment functionality for our sample e-commerce app. This is because it needs
    to be integrated with a payment gateway service such as Stripe or PayPal. Therefore,
    you are going to write the sample payment gateway service definition using gRPC
    in the next section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经完成了 `api` 项目的设置，我们准备在下一小节中使用 Protobuf 编写服务定义。你还没有实现我们示例电子商务应用的支付功能。这是因为它需要与
    Stripe 或 PayPal 等支付网关服务集成。因此，你将在下一节中编写使用 gRPC 的示例支付网关服务定义。
- en: Writing the payment gateway functionalities
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写支付网关功能
- en: Before you write the payment gateway service definition, let’s first understand
    the basic functionality of the payment gateway system in easy terms.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写支付网关服务定义之前，让我们首先以简单的方式了解支付网关系统的基本功能。
- en: The payment gateway provides a way to capture and transfer a payment from a
    customer to online sellers and then returns Accepted/Declined as a response to
    the customer. It performs various other actions here, such as verification, security,
    encryption, and communication with all participants.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 支付网关提供了一种从客户到在线卖家的支付捕获和转移方式，然后向客户返回接受/拒绝作为响应。它在此执行各种其他操作，例如验证、安全、加密以及与所有参与者的通信。
- en: 'The following are the actors who participate in this transaction:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在此交易中参与的参与者：
- en: '**Payment gateway**: A web interface that allows the processing of online payments
    and coordinates with all other actors. This is very similar to physical **point-of-sale**
    (**POS**) terminals.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支付网关**：一个允许处理在线支付并与其他所有参与者协调的网页界面。这与物理 **销售点**（**POS**）终端非常相似。'
- en: '**Merchant**: Merchants are online sellers or service providers, such as Amazon,
    Uber, and Airbnb.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**商家**：商家是在线卖家或服务提供商，例如亚马逊、优步和爱彼迎。'
- en: '**Customer**: This is you, the customer, who performs the buy/pay transaction
    for products or services and uses credit/debit cards, digital wallets, or online
    banking.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户**：这是你，作为客户，为产品或服务执行购买/支付交易，并使用信用卡、数字钱包或在线银行。'
- en: '**Issuing bank**: The party that provides the functionality to perform online
    money transfers, such as Visa, Mastercard, AmEx, PayPal, Stripe, or traditional
    banks.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发卡行**：提供执行在线货币转账功能的当事人，例如Visa、Mastercard、AmEx、PayPal、Stripe或传统银行。'
- en: '**Acquirer or acquiring bank**: The institution that holds the merchant account.
    It passes the transaction to the issuing bank to receive payment.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收购方或收购银行**：持有商户账户的机构。它将交易传递给发卡行以接收付款。'
- en: You are going to create two gRPC services – `ChargeService` and `SourceService`
    – as part of the payment gateway service. Don’t get confused with the web service,
    which is an executable/deployable artifact. `ChargeService` and `SourceService`
    are part of the service component of Protobuf’s `EmployeeService` example in the
    last chapter (the *How gRPC uses Protobuf* section of [*Chapter 10*](B19349_10.xhtml#_idTextAnchor233),
    *Getting Started with gRPC*). Both services are inspired by Stripe public REST
    APIs.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您将创建两个gRPC服务——`ChargeService`和`SourceService`——作为支付网关服务的一部分。不要与可执行/可部署的web服务混淆，它是可执行/可部署的工件。`ChargeService`和`SourceService`是上一章（*第10章*的*如何使用Protobuf*部分，*开始使用gRPC*）中Protobuf的`EmployeeService`示例的服务组件的一部分。这两个服务都受到Stripe公共REST
    API的启发。
- en: Let’s understand the transaction flow before we jump into creating the service
    components of a gRPC-based payment gateway service.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们跳入创建基于gRPC的支付网关服务组件之前，让我们先了解交易流程。
- en: Online payment workflow steps
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在线支付工作流程步骤
- en: 'The following steps are performed when an online transaction takes place:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行在线交易时，将执行以下步骤：
- en: First, the customer should have a payment source (read method) created before
    initiating the payment. If not, then the customer creates a source, such as their
    card details.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，客户应在启动付款之前创建一个支付源（读取方法）。如果没有，则客户将创建一个源，例如他们的卡详情。
- en: Payment is initiated by creating a charge against the payment source (read method).
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对支付源创建收费（读取方法）来启动付款。
- en: The payment gateway performs all the necessary validation and verification steps
    and then allows the charge to be captured. These steps trigger the fund transfer
    from the issuing bank to the merchant account.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支付网关执行所有必要的验证和验证步骤，然后允许捕获收费。这些步骤触发了从发卡行到商户账户的资金转移。
- en: You can observe that there are two objects (resources) involved in this workflow
    (aka source and charge). Therefore, you are going to write two services that function
    around these two objects. There are various other functionalities performed by
    the payment gateway, such as disputes, refunds, and payouts. However, you are
    going to implement only two services, charge and source, in this chapter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以观察到在这个工作流程（即源和收费）中涉及两个对象（资源）。因此，您将编写两个围绕这两个对象工作的服务。支付网关还执行各种其他功能，例如争议、退款和支付。然而，在本章中，您将只实现两个服务，即收费和源。
- en: Writing the payment gateway service definitions
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写支付网关服务定义
- en: 'Writing a Protobuf-based IDL is very similar to the way you defined the OpenAPI
    Specification for REST APIs. In REST, you define the models and API endpoints,
    whereas in gRPC, you define the messages and RPC procedures wrapped in the service.
    Let’s write our payment gateway service IDL using the following steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Protobuf编写的IDL编写方式与您定义REST API的OpenAPI规范非常相似。在REST中，您定义模型和API端点，而在gRPC中，您定义封装在服务中的消息和RPC过程。让我们按照以下步骤编写我们的支付网关服务IDL：
- en: First, let’s create a new file, `PaymentGatewayService.proto`, in the `api/lib/src/main/proto`
    directory under the root directory of the `api` project.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在`api`项目的根目录下的`api/lib/src/main/proto`目录中创建一个新的文件，名为`PaymentGatewayService.proto`。
- en: 'After creating a new file, you can add the metadata, as shown in the following
    code block:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建新文件后，您可以添加元数据，如下面的代码块所示：
- en: '[PRE9]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s understand the preceding code in detail:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细理解前面的代码：
- en: Line *1* tells the compiler to use version 3 of Protobuf by using the syntax
    specifier. If you don’t specify this, then the compiler will use version 2 of
    Protobuf.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*行1*告诉编译器使用语法指定符使用Protobuf的版本3。如果您不指定此信息，则编译器将使用版本2的Protobuf。'
- en: '*Line 2* uses the optional package specifier to attach the namespace to message
    types. This prevents name clashes among message types. We must postfix it with
    a package version that allows us to create new versions of APIs with backward
    compatibility.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*行2*使用可选的包指定符将命名空间附加到消息类型。这防止了消息类型之间的名称冲突。我们必须以允许我们创建具有向后兼容性的API新版本的包版本后缀。'
- en: '*Line 3* uses the `java_package` option specifier. This specifies the Java
    package to be used in the generated Java files. If you don’t use this option specifier
    and declare the `package` specifier, then the value of `package` will be used
    as a Java package in the generated Java files instead.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第3行*使用了`java_package`选项指定符。这指定了在生成的Java文件中使用的Java包。如果您不使用此选项指定符并声明`package`指定符，则`package`的值将用作生成的Java文件中的Java包。'
- en: '*Line 4* declares the `java_multiple_files` option specifier, which is a Boolean
    option. It is set to `false` by default. If it is set to `true`, then it generates
    separate Java files for each top-level message type, enumeration (`enum`), and
    service.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第4行*声明了`java_multiple_files`选项指定符，这是一个布尔选项。默认情况下设置为`false`。如果设置为`true`，则为每个顶级消息类型、枚举（`enum`）和服务生成单独的Java文件。'
- en: 'Next, let’s add the `ChargeService` service, which contains the operations
    required for charge functionality denoted by `rpc` (as shown in the following
    code block). Charge objects get created for charging the card, bank account, or
    digital wallet. Let’s add the charge service to the Protobuf (`.``proto`) file:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加包含所需收费功能的操作的`ChargeService`服务，这些操作由`rpc`表示（如下面的代码块所示）。为收费创建`Charge`对象，用于对卡、银行账户或数字钱包进行收费。让我们将收费服务添加到Protobuf（`.proto`）文件中：
- en: '[PRE10]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/api/lib/src/main/proto/PaymentGatewayService.proto
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/api/lib/src/main/proto/PaymentGatewayService.proto
- en: 'Each of these procedures in `ChargeService` will perform the following operations:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChargeService`中的每个这些过程都将执行以下操作：'
- en: '`Charge` object.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Charge`对象。'
- en: '`Charge` object based on the given charge ID that was previously created.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于先前创建的给定收费ID的`Charge`对象。
- en: '`Charge` object identified by the given charge ID by setting the values of
    the parameters passed. Any parameters not provided will be left unchanged.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设置传递的参数的值来识别给定收费ID的`Charge`对象。任何未提供的参数将保持不变。
- en: '`capture` option set to `false`. Uncaptured payments expire precisely seven
    days after they are created. If they are not captured by that point in time, they
    will be marked as refunded and capture will no longer be allowed.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`capture`选项设置为`false`。未捕获的支付在创建后恰好七天到期。如果在此时间点之前未被捕获，它们将被标记为已退款，并且将不再允许捕获。'
- en: '**RetrieveAll**: This procedure returns the list of charges that belong to
    the given customer ID.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RetrieveAll**: 此过程返回属于给定客户ID的收费列表。'
- en: Empty request or response type
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 空请求或响应类型
- en: 'You can use `google.protobuf.Empty` for void/empty request and response types.
    This can be used in `.proto` files. You just must place the following `import`
    statement before any message/service is defined:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`google.protobuf.Empty`作为void/empty请求和响应类型。这可以在`.proto`文件中使用。只需在定义任何消息/服务之前放置以下`import`语句：
- en: '`import "google/protobuf/timestamp.proto";`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`import "google/protobuf/timestamp.proto";`。'
- en: 'Then, you can use it as shown next:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用它，如下所示：
- en: '`rpc delete(SourceId) returns (``google.protobuf. Empty);`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`rpc delete(SourceId) returns (google.protobuf.Empty);`。'
- en: 'The amount is charged to a source, which could be a card, bank account, or
    digital wallet. A variety of payment methods can be used by the customer using
    a `Source` object. Therefore, you need a service that will allow you to perform
    operations on the `source` resource. Let’s add the `Source` service and its operations
    to the Protobuf (`.``proto`) file:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 金额将记入源，这可能是一张卡、银行账户或数字钱包。客户可以使用`Source`对象使用各种支付方式。因此，你需要一个允许你对`source`资源执行操作的服务。让我们将`Source`服务及其操作添加到Protobuf（`.proto`）文件中：
- en: '[PRE11]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Each of these procedures in `SourceService` will perform the following operations:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`SourceService`中的每个这些过程都将执行以下操作：'
- en: '`Source` object.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Source`对象。'
- en: '`Source` object based on the given source ID.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据给定的源ID创建`Source`对象。
- en: '`Source` object passed using the `UpdateSourceReq` object. Any field that is
    not part of `UpdateSourceReq` will remain unchanged.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`UpdateSourceReq`对象传递的`Source`对象。任何不属于`UpdateSourceReq`的字段将保持不变。
- en: '`Source` object to the customer. The `AttachOrDetachReq` parameter contains
    the IDs of both the source and the customer. However, the `Source` object should
    be in the `CHARGEABLE` or `PENDING` state to perform the attached operation.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Source`对象分配给客户。`AttachOrDetachReq`参数包含源和客户的ID。然而，`Source`对象必须处于`CHARGEABLE`或`PENDING`状态才能执行附加操作。
- en: '`Source` object from the customer. It will also change the state of the `Source`
    object to `consumed` and it can no longer be used to create the charge. The `AttachOrDetachReq`
    parameter contains the IDs of both the source and the customer.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自客户的`Source`对象。它还将改变`Source`对象的状态为`consumed`，并且它不能再用来创建费用。`AttachOrDetachReq`参数包含源和客户的ID。
- en: The recommended approach for defining the request and response types
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 定义请求和响应类型的推荐方法
- en: It is recommended to always use the wrapper request and response types. This
    allows you to add another field to the request or response types.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 建议始终使用包装请求和响应类型。这允许您向请求或响应类型添加另一个字段。
- en: 'Now that the service definitions are done, you can define the given parameters
    and the returned types of these procedures. Let’s first define the parameters
    and returned types of `ChargeService`. First, you will define the `Charge` message
    type, as shown in the following code block:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在服务定义已完成，您可以定义这些过程的给定参数和返回类型。首先，让我们定义`ChargeService`的参数和返回类型。首先，您将定义`Charge`消息类型，如下面的代码块所示：
- en: '[PRE12]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, the `Charge` message contains the following fields:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Charge`消息包含以下字段：
- en: '`id`: The unique identifier of the `Charge` object.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`: `Charge`对象的唯一标识符。'
- en: '`amount`: The amount is a positive number or zero, referring to the amount
    of the payment.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`amount`: 金额是一个正数或零，指代支付金额。'
- en: '`amountCaptured`: This is the captured amount (a positive number or zero).
    It can be less than the value of the `amount` field if a partial capture is made.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`amountCaptured`: 这是已捕获的金额（一个正数或零）。如果进行了部分捕获，它可能小于`amount`字段的值。'
- en: '`amountRefunded`: The amount refunded (a positive number or zero). It can be
    less than the value of the `amount` field if a partial refund is issued.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`amountRefunded`: 已退还的金额（一个正数或零）。如果发出部分退款，它可能小于`amount`字段的值。'
- en: '`balanceTransactionId`: The ID of the balance transaction, which describes
    the impact of this charge on your account balance (not including refunds or disputes).'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`balanceTransactionId`: 平衡交易的ID，描述了此费用对您的账户余额的影响（不包括退款或争议）。'
- en: '`billingDetails`: The object of the `BillingDetails` message type, which contains
    billing information associated with the payment method at the time of the transaction.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`billingDetails`: `BillingDetails`消息类型的对象，包含与交易时支付方式关联的账单信息。'
- en: '`calculatedStatementDescriptor`: The statement description that is passed to
    card networks and is displayed on your customers’ credit card and bank statements.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculatedStatementDescriptor`: 传递给卡网络并显示在您的客户信用卡和银行对账单上的账单描述。'
- en: '`captured`: A Boolean field that represents whether a charge has since been
    captured. (It is possible to create a charge without capturing the charge details.
    Therefore, this field is added, which determines whether a charge will be captured
    or not.)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`captured`: 一个布尔字段，表示费用是否已被捕获。（可能创建一个不捕获费用详情的费用。因此，添加了此字段，以确定费用是否将被捕获。）'
- en: '`created`: The timestamp (measured in seconds since the Unix epoch) at which
    the object was created.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created`: 对象创建的时间戳（以自Unix纪元以来的秒数衡量）。'
- en: '`currency`: The three-letter ISO currency code.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currency`: 三字母的ISO货币代码。'
- en: '`customerId`: The ID of the customer owning the charge.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customerId`: 拥有该费用的客户的ID。'
- en: '`description`: A description of the charge displayed to the user.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`: 显示给用户的费用描述。'
- en: '`disputed`: A Boolean field that represents whether the charge has been disputed.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disputed`: 一个布尔字段，表示该费用是否已被争议。'
- en: '`failureCode`: The error code of the failure.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failureCode`: 失败的错误代码。'
- en: '`failureMessage`: A description of the failure. The reason may be stated if
    this option is available.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failureMessage`: 失败的描述。如果此选项可用，可能还会说明原因。'
- en: '`invoiceId`: The ID of the invoice this charge is for.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invoiceId`: 此费用对应的发票ID。'
- en: '`orderId`: The ID of the order this charge is for.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orderId`: 此费用对应的订单ID。'
- en: '`paid`: The Boolean value represents whether the charge succeeded or was successfully
    authorized for subsequent capture.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paid`: 布尔值表示费用是否成功或已成功授权进行后续捕获。'
- en: '`paymentMethodId`: The ID of the payment method.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paymentMethodId`: 支付方式的ID。'
- en: '`paymentMethodDetails`: The object that contains the details of the payment
    method.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paymentMethodDetails`: 包含支付方式详细信息的对象。'
- en: '`receiptEmail`: The email where receipt of the charge will be sent.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`receiptEmail`: 费用收据将被发送的电子邮件地址。'
- en: '`receiptNumber`: This represents the transaction number in the charge receipt
    that was sent by email. It should remain null until a charge receipt is sent.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`receiptNumber`：这代表通过电子邮件发送的费用收据中的交易号码。它应该在发送费用收据之前保持为null。'
- en: '`refunded`: A Boolean field that represents whether the charge was refunded.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`refunded`：一个布尔字段，表示费用是否已退款。'
- en: '`refunds`: This contains the list of refunds that have been issued. The `repeated`
    keyword is used to create a list of `Refund` objects.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`refunds`：此列表包含已发放的退款。使用`repeated`关键字创建`Refund`对象的列表。'
- en: '`statementDescriptor`: The description of a charge for a card.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`statementDescriptor`：卡片费用的描述。'
- en: '`status`: An object of the `Status` enumeration type (`SUCCEEDED`, `PENDING`,
    or `FAILED`) that represents the status of the charge.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`：表示费用状态的`Status`枚举类型对象（`SUCCEEDED`、`PENDING`或`FAILED`）。'
- en: '`sourceId`: ID of the `Source` object.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sourceId`：`Source`对象的ID。'
- en: The UInt32 and string scalar types were discussed in the *How gRPC uses Protobuf*
    subsection under the *How does gRPC work?* section in the previous chapter ([*Chapter
    10*](B19349_10.xhtml#_idTextAnchor233), *Getting Started with gRPC*). You can
    refer to it for further information.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章的*如何gRPC使用Protobuf*小节下*如何gRPC工作？*部分中讨论了`UInt32`和字符串标量类型（[*第10章*](B19349_10.xhtml#_idTextAnchor233)，*开始使用gRPC*）。您可以参考它以获取更多信息。
- en: Predefined well-known types
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义的已知类型
- en: Apart from scalar types, Protobuf also provides predefined types such as `Empty`
    (which we saw earlier in *step 3*), `Timestamp`, and `Duration`. You can find
    the complete list at https://developers.google.com/protocol-buffers/docs/reference/google.protobuf.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标量类型外，Protobuf还提供了预定义类型，如`Empty`（我们在*步骤3*中已看到）、`Timestamp`和`Duration`。您可以在https://developers.google.com/protocol-buffers/docs/reference/google.protobuf找到完整的列表。
- en: 'Now, you can define the remaining message types of the other parameters (`CreateChargeReq`,
    `ChargeId`, `UpdateChargeReq`, `CaptureChargeReq`, and `CustomerId`) and return
    the `ChargeList` type of `ChargeService`, as shown in the following code block:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以定义其他参数的剩余消息类型（`CreateChargeReq`、`ChargeId`、`UpdateChargeReq`、`CaptureChargeReq`和`CustomerId`），并返回`ChargeService`的`ChargeList`类型，如下面的代码块所示：
- en: '[PRE13]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the `CreateChargeReq` type contains the required attribute’s charge amount
    (`amount`) and `currency`. It also contains several optional attributes – `customerId`,
    `receiptEmail`, `source`, and `statementDescriptor`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`CreateChargeReq`类型包含所需的属性费用金额（`amount`）和`currency`。它还包含几个可选属性——`customerId`、`receiptEmail`、`source`和`statementDescriptor`。
- en: '`UpdateChargeReq` contains all the optional attributes – `customerId`, `description`,
    and `receiptEmail`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateChargeReq`包含所有可选属性——`customerId`、`description`和`receiptEmail`。'
- en: '`CaptureChargeReq` contains all the optional attributes – `amount`, `receiptEmail`,
    and `statementDescriptor`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`CaptureChargeReq`包含所有可选属性——`amount`、`receiptEmail`和`statementDescriptor`。'
- en: Less well-known Google common types
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 较不为人知的Google常见类型
- en: '`Money` and `Date` (not `Timestamp`) are less commonly known types that can
    be used. However, you must copy the definitions instead of importing them (unlike
    what you do for `Empty` and `Timestamp`). You can copy the definitions from the
    following links: `Money` from https://github.com/googleapis/googleapis/blob/master/google/type/money.proto
    and `Date` from https://github.com/googleapis/googleapis/blob/master/google/type/date.proto.
    Other common types that you can use are also available in the repository.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Money`和`Date`（不是`Timestamp`）是较少为人所知的类型，可以用来。但是，您必须复制定义而不是导入它们（与您对`Empty`和`Timestamp`所做的不一样）。您可以从以下链接复制定义：`Money`来自https://github.com/googleapis/googleapis/blob/master/google/type/money.proto和`Date`来自https://github.com/googleapis/googleapis/blob/master/google/type/date.proto。您还可以在存储库中找到其他可用的常见类型。'
- en: Now, you can define the parameters and return the `SourceService` types. First,
    let’s define the `Source` message type, as shown in the following code.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以定义参数并返回`SourceService`类型。首先，让我们定义`Source`消息类型，如下面的代码所示。
- en: 'The source uses a `Flow` value, which could be either `REDIRECT`, `RECEIVER`,
    `CODEVERIFICATION`, or `NONE`. Similarly, the `Usage` value could be `REUSABLE`
    or `SINGLEUSE`. Therefore, let’s first create the `Flow` and `Usage` enumerations
    using `enum`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 源使用`Flow`值，可以是`REDIRECT`、`RECEIVER`、`CODEVERIFICATION`或`NONE`。同样，`Usage`值可以是`REUSABLE`或`SINGLEUSE`。因此，让我们首先使用`enum`创建`Flow`和`Usage`枚举：
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, you can use this `Flow` enum in the `Source` message:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在`Source`消息中使用此`Flow`枚举：
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, you can define the remaining message types for the other parameters of
    `SourceService` – `CreateSourceReq`, `UpdateSourceReq`, `AttachOrDetachReq`, and
    `SourceId` – as shown in the following code block:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以定义 `SourceService` 的其他参数的剩余消息类型，例如 `CreateSourceReq`、`UpdateSourceReq`、`AttachOrDetachReq`
    和 `SourceId`，如下所示：
- en: '[PRE16]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The other message types used in these messages can be referred to in the payment
    gateway definition file, located at https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/api/lib/src/main/proto/PaymentGatewayService.proto.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这些消息中使用的其他消息类型可以在支付网关定义文件中查阅，该文件位于 https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/api/lib/src/main/proto/PaymentGatewayService.proto。
- en: Multiple .proto files
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 多个 `.proto` 文件
- en: You can also create a separate definition file for each service, such as `ChargeService.proto`
    and `SourceService.proto`, for modularity. You can then import these files into
    another Protobuf file using `import "SourceService.proto";`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为每个服务创建一个单独的定义文件，例如 `ChargeService.proto` 和 `SourceService.proto`，以提高模块化。然后你可以使用
    `import "SourceService.proto";` 将这些文件导入另一个 Protobuf 文件中。
- en: You can find more information about importing at https://protobuf.dev/programming-guides/proto3/#importing-definitions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 https://protobuf.dev/programming-guides/proto3/#importing-definitions 找到更多关于导入的信息。
- en: You are now done with the payment gateway service definitions in the Protobuf
    file. Now, you can use this file to generate the gRPC server interface and stubs
    for the gRPC client.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经完成了 Protobuf 文件中的支付网关服务定义。现在，你可以使用此文件来生成 gRPC 服务器接口和 gRPC 客户端的存根。
- en: Next, you will publish the Java classes generated from the Protobuf file packaged
    in the `Jar` file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将发布从打包在 `Jar` 文件中的 Protobuf 文件生成的 Java 类。
- en: Publishing the payment gateway service gRPC server, stubs, and models
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布支付网关服务 gRPC 服务器、存根和模型
- en: 'You can use the following command, which should be executed from the `api`
    project’s root directory:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令，该命令应在 `api` 项目的根目录下执行：
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With the preceding command, you are setting the file encoding to UTF-8 first
    because we are using the UTF characters in Java files. Then, you are performing
    clean, build, and publish operations. The second command will first remove the
    existing files. Then, it will generate the Java files (the `generateProto` Gradle
    task) from the Protobuf file, build it (the `build` Gradle task), and publish
    the artifact to your local Maven repository (the `publishToMavenLocal` Gradle
    task).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命令，你首先设置文件编码为 UTF-8，因为我们正在使用 Java 文件中的 UTF 字符。然后，你执行清理、构建和发布操作。第二个命令将首先删除现有文件。然后，它将从
    Protobuf 文件生成 Java 文件（`generateProto` Gradle 任务），构建它（`build` Gradle 任务），并将工件发布到你的本地
    Maven 仓库（`publishToMavenLocal` Gradle 任务）。
- en: 'The `generateProto` Gradle task will generate the two types of Java classes
    in two directories, as shown next:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`generateProto` Gradle 任务将在两个目录中生成两种类型的 Java 类，如下所示：'
- en: '`/api/lib/build/generated/source/proto/main/java` directory, such as `Card.java`
    or `Address.java`. This directory will also contain the Java files of request
    and response objects used in operation contracts, such as `CreateChargeReq`, `CreateSourceReq`,
    `Charge.java`, and `Source.java`.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/lib/build/generated/source/proto/main/java` 目录，例如 `Card.java` 或 `Address.java`。此目录还将包含用于操作合同的请求和响应对象的
    Java 文件，例如 `CreateChargeReq`、`CreateSourceReq`、`Charge.java` 和 `Source.java`。'
- en: '`ChargeServiceGrpc.java` and `SourceServiceGrpc .java`) in the `/api/lib/build/generated/source/proto/main
    /grpc` directory. Each of these gRPC Java files contains a base class, stub classes,
    and methods for each operation defined in the service descriptor for the `Charge`
    and `Source` services.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChargeServiceGrpc.java` 和 `SourceServiceGrpc .java`) 位于 `/api/lib/build/generated/source/proto/main/grpc`
    目录。这些 gRPC Java 文件包含一个基类，以及为 `Charge` 和 `Source` 服务描述符中定义的每个操作的方法的存根类。'
- en: 'The following key static classes are defined in `ChargeServiceGrpc`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下关键静态类在 `ChargeServiceGrpc` 中定义：
- en: '`ChargeServiceImplBase` (abstract base class)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChargeServiceImplBase` (抽象基类)'
- en: 'Stubs: `ChargeServiceStub`, `ChargeServiceBlockingStub`, and `ChargeServiceFutureStub`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Stubs: `ChargeServiceStub`, `ChargeServiceBlockingStub`, 和 `ChargeServiceFutureStub`'
- en: 'Similarly, the following key static classes are defined in `SourceServiceGrpc`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，以下关键静态类在 `SourceServiceGrpc` 中定义：
- en: '`SourceServiceImplBase` (abstract base class)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SourceServiceImplBase` (抽象基类)'
- en: 'Stubs: `SourceServiceStub`, `SourceServiceBlockingStub`, and `SourceServiceFutureStub`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Stubs: `SourceServiceStub`, `SourceServiceBlockingStub`, 和 `SourceServiceFutureStub`'
- en: The abstract base classes described earlier contain the operations defined in
    the service block in the Protobuf file. You can use these base classes to implement
    the business logic for operations offered by these services, just like you implemented
    the REST endpoints from the Swagger-generated API Java interfaces.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的抽象基类包含了在Protobuf文件中的服务块中定义的操作。您可以使用这些基类来实现这些服务提供的业务逻辑，就像您从Swagger生成的API
    Java接口实现REST端点一样。
- en: These abstract classes should be implemented to provide the business logic implementations
    to the services offered by the gRPC server. Let’s develop the gRPC server next.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这些抽象类应该被实现，以向gRPC服务器提供业务逻辑实现。让我们接下来开发gRPC服务器。
- en: Developing the gRPC server
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发gRPC服务器
- en: You need to configure the `server` project before implementing these abstract
    classes. Let’s configure the server project first.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现这些抽象类之前，您需要配置`server`项目。让我们首先配置服务器项目。
- en: 'The `server` project directory structure will look like the following. The
    project root directory contains the `build.gradle` and `settings.gradle` files:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`server`项目目录结构将如下所示。项目根目录包含`build.gradle`和`settings.gradle`文件：'
- en: '[PRE18]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `resources` directory will contain the `application.properties` file.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources`目录将包含`application.properties`文件。'
- en: Using the Sprint Boot gRPC starters
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Boot gRPC启动器
- en: 'There are two Spring Boot starter projects that you can use. However, we’ll
    stick to the libraries provided by gRPC for a simplified solution and to aid understanding
    of the gRPC concepts. These libraries are available at the following links: https://github.com/LogNet/grpc-spring-boot-starter
    and https://github.com/yidongnan/grpc-spring-boot-starter.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用两个Spring Boot启动器项目。然而，我们将坚持使用gRPC提供的库来简化解决方案并帮助理解gRPC概念。这些库可在以下链接找到：https://github.com/LogNet/grpc-spring-boot-starter
    和 https://github.com/yidongnan/grpc-spring-boot-starter。
- en: 'Let’s perform the following steps to configure the project:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来配置项目：
- en: 'First, you need to modify the project name in the `Chapter11/server/ settings.gradle`
    file to represent the server, as shown here:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要修改`Chapter11/server/settings.gradle`文件中的项目名称，以表示服务器，如下所示：
- en: '[PRE19]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, you can add the dependencies required for `server` projects to the `Chapter11/server/build.gradle`
    file:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您可以将`server`项目所需的依赖项添加到`Chapter11/server/build.gradle`文件中：
- en: '[PRE20]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: repositories {  mavenCentral()  mavenLocal()}
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: repositories {  mavenCentral()  mavenLocal()}
- en: '[PRE21]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You are done with the Gradle configuration! Now, you can write the gRPC server.
    However, before writing the server, you need to implement the base abstract classes
    generated by Protobuf. Once the source and charge services (using base classes)
    are implemented, you can write the gRPC server code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经完成了Gradle配置！现在，您可以编写gRPC服务器。然而，在编写服务器之前，您需要实现由Protobuf生成的基抽象类。一旦源服务和计费服务（使用基类）被实现，您就可以编写gRPC服务器代码。
- en: Implementation of the gRPC server
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gRPC服务器实现
- en: You are going to use the same layered architecture that you used in the REST
    implementation – persistence store > repository layer > service layer > API endpoint.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用与REST实现中相同的分层架构 – 持久化存储 > 仓库层 > 服务层 > API端点。
- en: First, you need a persistence store where you can save the data, aka the first
    layer. You are going to use in-memory persistence (`ConcurrentHashMap`) for storing
    and retrieving the data. If you want, you can use the external database the way
    it is used in REST web services. This is done to keep the focus on gRPC server
    implementation.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要一个持久化存储，您可以在其中保存数据，也就是第一层。您将使用内存持久化（`ConcurrentHashMap`）来存储和检索数据。如果您愿意，您可以使用与REST
    Web服务中相同的方式使用外部数据库。这样做是为了保持对gRPC服务器实现的关注。
- en: 'First, create the in-memory persistence store for both the charge and source
    data stores. Create a new file, `server/src/main/java/com/packt/modern/api/server/
    repository/DbStore.java`, and add code, as shown in the following code block:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为计费和源数据存储创建内存持久化存储。创建一个新文件，`server/src/main/java/com/packt/modern/api/server/repository/DbStore.java`，并添加如下代码块中的代码：
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/
    server/repository/DbStore.java
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/
    server/repository/DbStore.java
- en: Here, you create two `ConcurrentHashMap` objects for storing the `Charge` and
    `Store` objects, respectively. You create two seed objects of each of these in
    the constructor using the `builder` and store them in their respective hash maps.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您创建了两个`ConcurrentHashMap`对象，分别用于存储`Charge`和`Store`对象。您在每个构造函数中使用`builder`创建了这些对象的两个种子实例，并将它们存储在其各自的哈希表中。
- en: According to the operations defined in the service contract, you create the
    methods in the database store to perform the operations. These operations are
    implemented with basic business logic to keep the flow and logic concise and to
    the point.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 根据服务合约中定义的操作，您在数据库存储中创建方法以执行这些操作。这些操作使用基本业务逻辑实现，以保持流程和逻辑简洁明了。
- en: 'Let’s now add the `createSource()` method to implement the `create()` contract
    of `SourceService` defined in the Protobuf file, as shown in the following code
    block:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加`createSource()`方法来实现Protobuf文件中定义的`SourceService`的`create()`合约，如下面的代码块所示：
- en: '[PRE23]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method creates a `source` object from the values received from the request
    object (`CreateSourceReq`). This newly created `Source` object is then saved in
    a hash map called `sourceEntities` and returned to the caller. You can enhance
    this method by adding validation that would validate the request object (`req`).
    Owner and receiver objects (highlighted in the code) should be retrieved from
    the request object. To keep the program simple, we have hardcoded these values
    here.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法从请求对象（`CreateSourceReq`）接收到的值创建一个`source`对象。然后，这个新创建的`Source`对象被保存在一个名为`sourceEntities`的哈希表中，并返回给调用者。您可以通过添加验证来增强此方法，该验证将验证请求对象（`req`）。所有者对象和接收者对象（在代码中突出显示）应从请求对象中检索。为了使程序简单，我们在这里硬编码了这些值。
- en: Similarly, you can implement other contract methods for `source` and `charge`
    along with their persistence. You can find the full source code of this class
    at https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/DbStore.java.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您可以为`source`和`charge`及其持久化实现其他合约方法。您可以在以下链接找到该类的完整源代码：https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/DbStore.java。
- en: Now, you have the in-memory persistence store – `DbStore`. Next, let’s use this
    store in repository classes.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经有了内存持久化存储——`DbStore`。接下来，让我们在仓库类中使用这个存储。
- en: Writing repository classes
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写仓库类
- en: 'Now, you can implement the next layer – the repository layer. The in-memory
    persistence store (`DbStore`) can be consumed in the `ChargeRepositoryImpl` repository
    class to interact, as shown here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以实现下一层——仓库层。内存持久化存储（`DbStore`）可以在`ChargeRepositoryImpl`仓库类中被消费，如下所示：
- en: '[PRE24]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/ChargeRepositoryImpl.java
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/ChargeRepositoryImpl.java
- en: '`ChargeRepositoryImpl` implements the `ChargeRepository` interface and makes
    use of `DbStore` to perform the operations. The code of this repository interface
    is available at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/ChargeRepository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/ChargeRepository.java).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChargeRepositoryImpl`实现了`ChargeRepository`接口，并使用`DbStore`来执行操作。该仓库接口的代码可在以下链接找到：[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/ChargeRepository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/ChargeRepository.java)。'
- en: 'Similarly, you can create the `SourceRepositoryImpl` class, which implements
    `SourceRespository`, as shown here:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以创建`SourceRepositoryImpl`类，该类实现了`SourceRespository`，如下所示：
- en: '[PRE25]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/SourceRepositoryImpl.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/SourceRepositoryImpl.java)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/SourceRepositoryImpl.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/SourceRepositoryImpl.java)'
- en: Like `ChangeRepositoryImpl`, `SourceRepositoryImpl` too makes use of a persistence
    store to persist the data. You can find the code for the `SourceRepository` interface
    at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/SourceRepository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/SourceRepository.java).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ChangeRepositoryImpl`类似，`SourceRepositoryImpl`也使用持久化存储来持久化数据。您可以在[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/SourceRepository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/SourceRepository.java)找到`SourceRepository`接口的代码。
- en: Methods of the `Source` and `Charge` repository classes are consumed by the
    service classes. Service base classes are generated by gRPC (part of the `api`
    project). Service classes implement these abstract-generated base classes (service
    base classes).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`Source`和`Charge`存储库类的方法被服务类消费。服务基类由gRPC（`api`项目的一部分）生成。服务类实现了这些抽象生成的基类（服务基类）。'
- en: Let’s write the service layer next.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写服务层。
- en: Implementing service classes
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现服务类
- en: Now you have the underlying implementation ready in the form of repository and
    database store classes, which can be used to implement the gRPC service’s base
    classes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了以存储库和数据库存储类形式存在的底层实现，可以用来实现gRPC服务的基础类。
- en: 'Let’s implement the `Source` service first, as shown next:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先实现`Source`服务，如下所示：
- en: Create a new file, `SourceService.java`, in the `server/src/main/com/packt/modern/api/server/service`
    directory.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`server/src/main/com/packt/modern/api/server/service`目录下创建一个新的文件，名为`SourceService.java`。
- en: 'Add the implementations to operations defined in the `SourceService` abstract
    base class, as shown next:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实现添加到定义在`SourceService`抽象基类中的操作中，如下所示：
- en: '[PRE26]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/service/SourceService.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/service/SourceService.java)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/service/SourceService.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/service/SourceService.java)'
- en: Here, the `SourceServiceImplBase` abstract class is autogenerated by the Protobuf
    plugin, which contains the contract methods of the `Source` service. A unique
    part of the method signature generated is the second argument, `StreamObserver`.
    `StreamObserver` receives notifications from observable streams. It is being used
    here for service implementation. Similarly, it is also used in the client stubs.
    The gRPC library provides the `StreamObserver` argument for outgoing messages.
    However, you also must implement it for incoming messages.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`SourceServiceImplBase`抽象类是由Protobuf插件自动生成的，它包含了`Source`服务的合约方法。生成的方法签名中独特的一部分是第二个参数，`StreamObserver`。`StreamObserver`接收可观察流的通知。在这里它被用于服务实现。同样，它也被用于客户端存根。gRPC库为出站消息提供了`StreamObserver`参数。然而，您还必须为入站消息实现它。
- en: '`StreamObserver` arguments are not thread-safe, so you must take care of multithreading
    and should use synchronized calls.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamObserver`参数不是线程安全的，因此您必须注意多线程问题，并应使用同步调用。'
- en: 'There are three primary methods of `StreamObserver`:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StreamObserver`有三个主要方法：'
- en: '`onNext()`: This method receives the value from the stream. It can be called
    multiple times. However, it should not be called after `onCompleted()` or `onError()`.
    Multiple `onNext()` calls are required for streams when multiple datasets are
    sent to clients.'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onNext()`：此方法接收来自流的值。它可以多次调用。然而，它不应在`onCompleted()`或`onError()`之后调用。当向客户端发送多个数据集时，需要多个`onNext()`调用。'
- en: '`onCompleted()`: This marks the completion of the stream and no further method
    calls are allowed after that. It can only be called once.'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCompleted()`：这标志着流的完成，之后不允许进行任何方法调用。它只能调用一次。'
- en: '`onError()`: This method receives the termination error from the stream. Like
    `onCompleted()`, it can only be called once and no further method calls are allowed.'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError()`：此方法接收来自流的终止错误。与`onCompleted()`一样，它只能调用一次，之后不允许进行任何方法调用。'
- en: Similarly, you can implement the other methods of an abstract class.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，你可以实现抽象类中的其他方法。
- en: 'Next, you can implement the `Charge` service in the same way you have implemented
    the `Source` service. Let’s do it:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以像实现`Source`服务一样实现`Charge`服务。让我们来做这件事：
- en: Create a new file, `ChargeService.java`, in the `server/src/main/com/packt/modern/api/server/service`
    directory.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`server/src/main/com/packt/modern/api/server/service`目录下创建一个新的文件`ChargeService.java`。
- en: 'Add the implementations to operations defined in the `ChargeService` abstract
    base class, as shown here:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实现添加到`ChargeService`抽象基类中定义的操作，如下所示：
- en: '[PRE27]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/service/ChargeService.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/service/ChargeService.java)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/service/ChargeService.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/service/ChargeService.java)'
- en: This is along the same lines as the way the `SourceService` `create` method
    was implemented.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`SourceService`的`create`方法实现方式类似。
- en: Similarly, you can implement the other methods of the abstract class. Please
    refer to the link to the source code after the preceding code block for the complete
    code implementation.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，你可以实现抽象类中的其他方法。请参考代码块后面的源代码链接以获取完整的代码实现。
- en: Now, you have the service layer implementation ready. Let’s implement the API
    layer (gRPC server) next.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好了服务层的实现。接下来，让我们实现API层（gRPC服务器）。
- en: Implementation of the gRPC server class
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gRPC服务器类的实现
- en: 'The Spring Boot application runs on its own server. However, we want to run
    the gRPC server, which internally uses the Netty web server. Therefore, we first
    need to modify the Spring Boot configuration to stop running its web server. You
    can do that by modifying the `server/src/main/resources/application.properties`
    file, as shown in the following code block:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot应用程序在其自己的服务器上运行。然而，我们希望运行gRPC服务器，它内部使用Netty网络服务器。因此，我们首先需要修改Spring
    Boot配置以停止其网络服务器的运行。你可以通过修改`server/src/main/resources/application.properties`文件来实现，如下面的代码块所示：
- en: '[PRE28]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/resources/application.properties](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/resources/application.properties)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/resources/application.properties](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/resources/application.properties)'
- en: Next, let’s create the gRPC server. It will have three methods – `start()`,
    `stop()`, and `block()` – for starting up the server, stopping the server, and
    serving requests until a termination request is received, respectively.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建gRPC服务器。它将包含三个方法——`start()`、`stop()`和`block()`——分别用于启动服务器、停止服务器以及接收终止请求前服务请求。
- en: 'Create a new file, `GrpcServer.java`, in the `server/src/main/com/packt/ modern/api/server`
    directory and the code, as shown in the following code block:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server/src/main/com/packt/ modern/api/server`目录下创建一个新的文件`GrpcServer.java`，并编写如下代码块所示的代码：
- en: '[PRE29]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/GrpcServer.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/GrpcServer.java)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/GrpcServer.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/GrpcServer.java)'
- en: The server library of gRPC provides the server builder for building the server.
    You can see that both services are added to the server. The builder also allows
    you to add interceptors that can intercept the incoming request and response.
    We are going to use the interceptor in the *Coding for handling* *errors* section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 的服务器库提供了用于构建服务器的服务器构建器。您可以看到，两个服务都被添加到了服务器中。构建器还允许您添加拦截器，可以拦截传入的请求和响应。我们将在
    *编码处理* *错误* 部分使用拦截器。
- en: The `GrpcServer start()` method has also added a shutdown hook that calls the
    `stop()` method, which internally calls the `server.shutdown()` method.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`GrpcServer start()` 方法还增加了一个关闭钩子，该钩子调用 `stop()` 方法，该方法内部调用 `server.shutdown()`
    方法。'
- en: The server code is ready. Now, you need an interface to start the server. You
    are going to use the `CommandLineRunner` function interface to run the server.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器代码已经准备好了。现在，您需要一个接口来启动服务器。您将使用 `CommandLineRunner` 函数接口来运行服务器。
- en: 'Create a new file, `GrpcServerRunner.java`, in the same directory where you
    created the `GrpcServer.java` file and add the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在您创建 `GrpcServer.java` 文件的同目录下创建一个新的文件，命名为 `GrpcServerRunner.java`，并添加以下代码：
- en: '[PRE30]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/GrpcServerRunner.java
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/GrpcServerRunner.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/GrpcServerRunner.java)'
- en: Here, you override the `CommandLineRunner` `run()` method and call the `start`
    and `block` methods. Therefore, when you execute the `jar` file, `GrpcServerRunner`
    will be executed using its `run()` method and will start the gRPC server.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您重写了 `CommandLineRunner` 的 `run()` 方法并调用了 `start` 和 `block` 方法。因此，当您执行 `jar`
    文件时，`GrpcServerRunner` 将使用其 `run()` 方法执行并启动 gRPC 服务器。
- en: Another thing to remember is that you have marked the `GrpcServerRunner` class
    with the `@Profile` annotation with the `"!test"` value, which means that when
    the test profile is active, this class won’t be loaded, and hence not executed.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要记住的事情是，您已经用 `@Profile` 注解标记了 `GrpcServerRunner` 类，并设置为 `"!test"` 值，这意味着当测试配置文件激活时，这个类不会被加载，因此也不会被执行。
- en: You are now done with both service and server implementation, so let’s test
    the gRPC server in the next subsection.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经完成了服务和服务器实现，接下来让我们在下一小节测试 gRPC 服务器。
- en: Testing the gRPC server
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 gRPC 服务器
- en: 'First of all, you need to set the active profile to `test` in your `test` classes
    because doing so will disable `GrpcServerRunner`. Let’s do this and test it, as
    shown in the following code block:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要在 `test` 类中将活动配置文件设置为 `test`，因为这样做将禁用 `GrpcServerRunner`。让我们这样做并测试它，如下面的代码块所示：
- en: '[PRE31]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/test/java/com/packt/modern/api/ServerAppTests.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/test/java/com/packt/modern/api/ServerAppTests.java)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/test/java/com/packt/modern/api/ServerAppTests.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/test/java/com/packt/modern/api/ServerAppTests.java)'
- en: The `beanGrpcServerRunnerTest()` method tests the loading of the `GrpcServer`
    class and `GrpcServerRunner` and the test should pass if the profile is set correctly.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`beanGrpcServerRunnerTest()` 方法测试 `GrpcServer` 类和 `GrpcServerRunner` 的加载，如果配置文件设置正确，测试应该通过。'
- en: Now, let’s move on to test the gRPC services.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续测试 gRPC 服务。
- en: The gRPC test library provides a special class, `GrpcCleanupRule`, that manages
    the shutdown of registered servers and channels gracefully. You need to annotate
    it with the JUnit `@Rule` to make it effective. The gRPC test library also provides
    the `InProcessServerBuilder` builder class, which allows you to build the server,
    and the `InProcessChannelBuilder` builder class, which allows you to build the
    channel. These three classes are all you need to build and manage the server and
    channel.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 测试库提供了一个特殊的类，`GrpcCleanupRule`，它以优雅的方式管理注册的服务器和通道的关闭。你需要用 JUnit 的 `@Rule`
    注解它以使其生效。gRPC 测试库还提供了一个 `InProcessServerBuilder` 构建类，它允许你构建服务器，以及一个 `InProcessChannelBuilder`
    构建类，它允许你构建通道。这三个类就是你构建和管理服务器和通道所需的所有。
- en: Therefore, you first need to declare the required instances and then set up
    the method so that the execution environment is available before you fire the
    requests to the gRPC `Source` service.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你首先需要声明所需的实例，然后设置方法，以便在向 gRPC `Source` 服务发送请求之前，执行环境可用。
- en: 'Let’s add the required class instances and test the `setup()` method in the
    following code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加所需的类实例，并在以下代码中测试 `setup()` 方法：
- en: '[PRE32]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, the `setup` method creates the server and channel with the `Source` service.
    Let’s understand each of the lines mentioned in the `setup()` method:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`setup` 方法使用 `Source` 服务创建服务器和通道。让我们理解 `setup()` 方法中提到的每一行：
- en: '*Line 1* generates the unique name of the server.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 1 行* 生成服务器的唯一名称。'
- en: '*Line 2* registers the newly created server and adds the `Source` service and
    server interceptor to it. We’ll discuss `ExceptionInterceptor` in the *Coding
    for handling errors* section. Then, it starts the server for serving requests.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 2 行* 注册了新创建的服务器，并将 `Source` 服务和服务器拦截器添加到其中。我们将在 *处理错误编码* 部分讨论 `ExceptionInterceptor`。然后，它启动服务器以处理请求。'
- en: '*Line 3* creates the blocking stub, which will be used as a client for making
    the calls to the server. Here again, `GrpcCleanUpRule` is used to create the client
    channel.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 3 行* 创建阻塞存根，它将被用作向服务器发出调用的客户端。在这里，再次使用 `GrpcCleanUpRule` 创建客户端通道。'
- en: 'Once the setup is executed, it provides us with the environment to carry out
    the tests. Let’s test our first request, as shown in the following code block:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置执行，它为我们提供了执行测试的环境。让我们测试我们的第一个请求，如下面的代码块所示：
- en: '[PRE33]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: All the complex aspects of the `setup()` method are complete. These tests now
    look pretty simple. You just use the blocking stub to make a call. You create
    the request object and use the stub to call the server. Finally, validate the
    server responses.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup()` 方法的所有复杂方面都已完成。现在这些测试看起来相当简单。你只需使用阻塞存根进行调用。你创建请求对象，并使用存根调用服务器。最后，验证服务器响应。'
- en: 'Similarly, you can test the validation error, as shown in the following code
    block:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以测试验证错误，如下面的代码块所示：
- en: '[PRE34]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can also test for the valid response for source retrieval, as shown in
    the following code block:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以测试源检索的有效响应，如下面的代码块所示：
- en: '[PRE35]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is the way in which you can write the test for the gRPC server and test
    the exposed RPC calls. You can use the same approach to write the rest of the
    test cases. After writing the test, you may have an idea of how the client is
    going to send the request to the server.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可以为 gRPC 服务器编写测试并测试公开的 RPC 调用的方式。你可以使用相同的方法编写其余的测试用例。在编写测试后，你可能会有一个想法，了解客户端将如何向服务器发送请求。
- en: We have not yet discussed the exception interceptor that we have used in both
    the server code and test. Let’s discuss this in the next section.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论我们在服务器代码和测试中使用的异常拦截器。让我们在下节中讨论这个问题。
- en: Coding for handling errors
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误编码
- en: You may have already gone through the theory-based *Handling errors and error
    status codes* section in [*Chapter 10*](B19349_10.xhtml#_idTextAnchor233), *Getting
    Started with gRPC*, where `google.rpc.Status` and gRPC status codes were discussed.
    You may want to revisit that section before going through this section as here
    you are going to write the actual code.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经阅读了基于理论的 *处理错误和错误状态码* 部分，在 [*第 10 章*](B19349_10.xhtml#_idTextAnchor233)，*开始使用
    gRPC*，其中讨论了 `google.rpc.Status` 和 gRPC 状态码。在阅读本节之前，你可能想回顾一下那个部分，因为在这里你将编写实际的代码。
- en: '`io.grpc.ServerInterceptor` is a thread-safe interface for intercepting incoming
    calls that can be used for cross-cutting calls, such as authentication and authorization,
    logging, and monitoring. Let’s use it to write `ExceptionInterceptor`, as shown
    in the following code block:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.grpc.ServerInterceptor` 是一个线程安全的接口，用于拦截传入的调用，可用于跨切面调用，如身份验证和授权、日志记录和监控。让我们使用它来编写
    `ExceptionInterceptor`，如下面的代码块所示：'
- en: '[PRE36]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/interceptor/ExceptionInterceptor.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/interceptor/ExceptionInterceptor.java)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/interceptor/ExceptionInterceptor.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/interceptor/ExceptionInterceptor.java)'
- en: Here, `RQT` represents the request type, and `RST` represents the response type.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`RQT` 代表请求类型，而 `RST` 代表响应类型。
- en: 'We are going to use it for exception intercepting. An interceptor will pass
    the call to the server listener (`ExceptionHandlingServerCallListener`). `ExceptionHandlingServer``     CallListener` is a private class in `ExceptionInterceptor` that extends the `ForwardingServerCallListener.
    SimpleForwardingServerCallListener` abstract class.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用它来进行异常拦截。拦截器将调用传递给服务器监听器（`ExceptionHandlingServerCallListener`）。`ExceptionHandlingServerCallListener`
    是 `ExceptionInterceptor` 中的一个私有类，它扩展了 `ForwardingServerCallListener` 抽象类 `SimpleForwardingServerCallListener`。
- en: The private listener class has overridden events, `onHalfClose()` and `onReady()`,
    which will catch the exception and pass the call to the `handleException()` method.
    The `handleException()` method will use the `ExceptionUtils` method to trace the
    actual exception and respond with error details. `ExceptionUtils` returns `StatusRuntimeException`,
    which is used to close the server call with an error status.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 私有监听器类已重写事件 `onHalfClose()` 和 `onReady()`，这将捕获异常并将调用传递给 `handleException()`
    方法。`handleException()` 方法将使用 `ExceptionUtils` 方法来追踪实际的异常并以错误详情响应。`ExceptionUtils`
    返回 `StatusRuntimeException`，用于以错误状态关闭服务器调用。
- en: 'Let’s see how this flow looks in code in the next code block:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一个代码块中的代码是如何展示这个流程的：
- en: '[PRE37]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/interceptor/ExceptionInterceptor.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/interceptor/ExceptionInterceptor.java)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/interceptor/ExceptionInterceptor.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/interceptor/ExceptionInterceptor.java)'
- en: Let’s write the `ExceptionUtils` class next to complete the exception-handling
    core components. Then, you can use these components in a service implementation
    to raise the exceptions.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写 `ExceptionUtils` 类以完成异常处理的核心组件。然后，你可以在服务实现中使用这些组件来抛出异常。
- en: 'The `ExceptionUtils` class will have two types of overloaded methods:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExceptionUtils` 类将有两种类型的重载方法：'
- en: '`observerError()`: This method will use `StreamObserver` to raise the `onError()`
    event'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`observerError()`: 这个方法将使用 `StreamObserver` 来触发 `onError()` 事件'
- en: '`traceException()`: This method will trace the error from `Throwable` and return
    the `StatusRuntimeException` instance'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traceException()`: 这个方法将追踪 `Throwable` 中的错误并返回 `StatusRuntimeException` 实例'
- en: 'You can use the following code to write the `ExceptionUtils` class:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码来编写 `ExceptionUtils` 类：
- en: '[PRE38]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/exception/ExceptionUtils.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/exception/ExceptionUtils.java)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/exception/ExceptionUtils.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/exception/ExceptionUtils.java)'
- en: 'Here, you can see that the `observerError()` method is also calling `traceException()`
    internally for `onError` events. Let’s write the last overloaded method, `traceException()`,
    next:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 `observerError()` 方法也在内部为 `onError` 事件调用 `traceException()`。让我们接下来编写最后一个重载方法
    `traceException()`：
- en: '[PRE39]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, `SocketException` is shown by way of an example. You can add a check for
    another kind of exception here. You may notice that here we are using `com.google
    .rpc.Status` to build the status. Then, this instance of `Status` is passed to
    `toStatusRuntimeException()` of `StatusProto`, which converts the status to `StatusRuntimeException`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，以 `SocketException` 为例。你可以在这里添加对另一种异常的检查。你可能注意到，在这里我们使用 `com.google.rpc.Status`
    来构建状态。然后，将这个 `Status` 实例传递给 `StatusProto` 的 `toStatusRuntimeException()`，它将状态转换为
    `StatusRuntimeException`。
- en: 'Let’s add the validation error in the `DbStore` class to make use of these
    exception-handling components, as shown in the following code block:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `DbStore` 类中添加验证错误，以便使用这些异常处理组件，如下面的代码块所示：
- en: '[PRE40]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/DbStore.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/DbStore.java)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/DbStore.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/DbStore.java)'
- en: You can similarly raise `StatusRuntimeException` in any part of the service
    implementation. You can also use the `addDetails()` method of `com.google.rpc.Status`
    to add more details to the error status, as shown in the `traceException(Throwable
    e, T` `defaultInstance)` code.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在服务实现的任何部分类似地引发 `StatusRuntimeException`。你还可以使用 `com.google.rpc.Status` 的
    `addDetails()` 方法向错误状态添加更多详细信息，如 `traceException(Throwable e, T defaultInstance)`
    代码所示。
- en: 'Finally, you can capture the error raised by the `retrieve()` method of `SourceService`
    in the `Service` implementation class, as shown next:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在 `Service` 实现类中捕获由 `SourceService` 的 `retrieve()` 方法引发的错误，如下所示：
- en: '[PRE41]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/service/SourceService.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/service/SourceService.java)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/service/SourceService.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/service/SourceService.java)'
- en: Exception handling is explained simply and constructively in this chapter. You
    can enhance it more as per your application requirements.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简单而建设性地解释了异常处理。你可以根据应用程序的需求进一步增强它。
- en: Now, let’s write the gRPC client in the next section.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在下一节中编写 gRPC 客户端。
- en: Developing the gRPC client
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 gRPC 客户端
- en: 'A client project’s directory structure will look as follows. The project root
    directory contains the `build.gradle` and `settings.gradle` files, as shown in
    the following directory tree structure:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端项目的目录结构将如下所示。项目根目录包含 `build.gradle` 和 `settings.gradle` 文件，如下面的目录树结构所示：
- en: '[PRE42]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `resources` directory will contain the `application.properties` file.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources` 目录将包含 `application.properties` 文件。'
- en: 'Let’s perform the following steps to configure the project:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来配置项目：
- en: 'First, you need to modify the project name in the `Chapter11/client/ settings.gradle`
    file to represent the server, as shown here:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要修改 `Chapter11/client/settings.gradle` 文件中的项目名称，以表示服务器，如下所示：
- en: '[PRE43]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, you can add the dependencies required for client projects to the `Chapter11/client/build.gradle`
    file. The `grpc-stub` library provides the stubs-related APIs, and `protobuf-java-util`
    provides the utility methods for Protobuf and JSON conversions:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以在 `Chapter11/client/build.gradle` 文件中添加客户端项目所需的依赖项。`grpc-stub` 库提供了与存根相关的
    API，而 `protobuf-java-util` 提供了 Protobuf 和 JSON 转换的实用方法：
- en: '[PRE44]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/build.gradle)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/build.gradle)'
- en: 'The `payment-gateway-api` dependency is published in the local Maven repository.
    Therefore, you need to add the local Maven repository to the `repositories` section,
    as shown in the following code block:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`payment-gateway-api`依赖项已发布在本地Maven仓库中。因此，你需要将本地Maven仓库添加到`repositories`部分，如下面的代码块所示：'
- en: '[PRE45]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You are done with the Gradle configuration. Now, you can write the gRPC client.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了Gradle配置。现在，你可以编写gRPC客户端。
- en: Implementing the gRPC client
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现gRPC客户端
- en: 'As you know, the Spring Boot application runs on its own server. Therefore,
    the client’s application port should be different from the gRPC server port. Also,
    we need to provide the gRPC server host and port. These can be configured in `application.properties`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Spring Boot应用程序在自己的服务器上运行。因此，客户端的应用程序端口应该与gRPC服务器端口不同。此外，我们还需要提供gRPC服务器的主机和端口。这些可以在`application.properties`中进行配置：
- en: '[PRE46]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/resources/application.properties](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/resources/application.properties)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/resources/application.properties](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/resources/application.properties)'
- en: Next, let’s create the gRPC client. This client will be used to configure the
    gRPC service stubs with the channel. The channel is responsible for providing
    the virtual connection to a conceptual endpoint in order to perform gRPC calls.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建gRPC客户端。这个客户端将用于使用通道配置gRPC服务存根。通道负责提供虚拟连接到概念上的端点，以便执行gRPC调用。
- en: 'Create a new file, `GrpcClient.java`, in the `client/src/main/com/packt/modern/api/client`
    directory and add the code shown in the following code block:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在`client/src/main/com/packt/modern/api/client`目录下创建一个新文件，命名为`GrpcClient.java`，并添加以下代码块中的代码：
- en: '[PRE47]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/java/com/packt/modern/api/client/GrpcClient.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/java/com/packt/modern/api/client/GrpcClient.java)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/java/com/packt/modern/api/client/GrpcClient.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/java/com/packt/modern/api/client/GrpcClient.java)'
- en: Here, `start()` is the key that initialized the `Source` and `Charge` service
    stubs. `ManagedChannelBuilder` is used to build `ManagedChannel`. `ManagedChannel`
    is a channel that also provides life cycle management. This managed channel is
    passed to stubs.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`start()`是初始化`Source`和`Charge`服务存根的关键。使用`ManagedChannelBuilder`构建`ManagedChannel`。`ManagedChannel`是一个提供生命周期管理的通道。这个管理通道被传递给存根。
- en: You are using plain-text communication. However, it also provides encrypted
    communication.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在使用纯文本通信。然而，它也提供了加密通信。
- en: We are now done with the client’s code. Now, we need to call the `start()` method.
    You are going to implement `CommandLineRunner` the way it was implemented for
    the `GrpcServerRunner` class.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了客户端的代码。现在，我们需要调用`start()`方法。你将按照为`GrpcServerRunner`类实现的方式实现`CommandLineRunner`。
- en: 'It can be implemented as shown here:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以按照以下方式实现：
- en: '[PRE48]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/java/com/packt/modern/api/client/GrpcClientRunner.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/java/com/packt/modern/api/client/GrpcClientRunner.java)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/java/com/packt/modern/api/client/GrpcClientRunner.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/java/com/packt/modern/api/client/GrpcClientRunner.java)'
- en: This will initiate the stub instantiation following the start of the application.
    You can then call the stub methods.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在应用程序启动后启动存根实例化。然后你可以调用存根方法。
- en: Now, to call the stub methods, let’s add a simple REST endpoint. This will demonstrate
    how to use the charge service stub to call its `retrieve` method.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了调用存根方法，让我们添加一个简单的REST端点。这将演示如何使用费用服务存根调用其`retrieve`方法。
- en: 'You can create a new `ChargeController.java` file for the REST controller in
    the `src/main/java/com/packts/modern/api/controller` directory and add the code
    as shown here:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`src/main/java/com/packts/modern/api/controller`目录中创建一个新的`ChargeController.java`文件，并将代码添加如下所示：
- en: '[PRE49]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/java/com/packt/modern/api/controller/ChargeController.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/java/com/packt/modern/api/controller/ChargeController.java)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/java/com/packt/modern/api/controller/ChargeController.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/java/com/packt/modern/api/controller/ChargeController.java)'
- en: Here, we have created a REST endpoint, `/charges`. This uses the `GrpcClient`
    instance to call the `retrieveAll()` RPC method of the `Charge` gRPC service using
    `ChargeServiceStub`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个REST端点，`/charges`。它使用`GrpcClient`实例通过`ChargeServiceStub`调用`Charge`
    gRPC服务的`retrieveAll()` RPC方法。
- en: Then, the response is converted into a JSON-formatted string using the `JsonFormat`
    class from the `protobuf-java-util` library and returned as a response. Generated
    JSON-formatted strings will also contain the fields with default values.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用来自`protobuf-java-util`库的`JsonFormat`类将响应转换为JSON格式的字符串，并作为响应返回。生成的JSON格式的字符串也将包含具有默认值的字段。
- en: We are done with our development. Let’s now test the complete flow in the next
    subsection.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的开发工作已经完成。现在让我们在下一小节中测试整个流程。
- en: Testing the gRPC service
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试gRPC服务
- en: 'Make sure that your gRPC server is up and running before testing the client.
    It is assumed that the gRPC `api` project has been built and that its latest artifacts
    have been published to the local Maven repository:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试客户端之前，请确保您的gRPC服务器正在运行。假设`api`项目已经构建，并且其最新工件已发布到本地Maven仓库：
- en: 'First, make sure that your `api` project library is published in the local
    Maven repository because it is required by both the `server` and `client` projects.
    Skip to *step 2* if you have already published the library. Java should be set
    to version 17\. Execute the following commands from the `api` root project directory:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，请确保您的`api`项目库已发布到本地Maven仓库，因为它被`server`和`client`项目都需要。如果您已经发布了库，请跳转到*步骤2*。Java应设置为版本17。从`api`项目的根目录执行以下命令：
- en: '[PRE50]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'client project’s root directory (Java should be set to version 17):'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 客户端项目的根目录（Java应设置为版本17）：
- en: '[PRE51]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '// calls the client service''s charges API endpoint$ curl http://localhost:8081/charges{  "charge":
    [{    "id": "cle9e9oam6gajkkeivjof5pploq89ncp",    "amount": 1000,    "amountCaptured":
    0,    …    "created": "1679924425",    "currency": "USD",    "customerId": "ab1ab2ab3ab4ab5",    "description":
    "Charge Description",    …    "receiptEmail": "receipt@email.com",    …    "status":
    "SUCCEEDED",    "sourceId": "0ovjn4l6crgp9apr79bhpefme4dok3qf"  }]}'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '// 调用客户端服务的费用API端点$ curl http://localhost:8081/charges{  "charge": [{    "id":
    "cle9e9oam6gajkkeivjof5pploq89ncp",    "amount": 1000,    "amountCaptured": 0,    …    "created":
    "1679924425",    "currency": "USD",    "customerId": "ab1ab2ab3ab4ab5",    "description":
    "费用描述",    …    "receiptEmail": "receipt@email.com",    …    "status": "SUCCEEDED",    "sourceId":
    "0ovjn4l6crgp9apr79bhpefme4dok3qf"  }]}'
- en: '[PRE52]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: A REST endpoint is used for demonstration purposes only. Similarly, you can
    use the gRPC client to call other services and their methods. gRPC is often used
    for inter-service communication, which is essential for microservice-based applications.
    However, it can also be used for web-based communication.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了演示目的，使用了REST端点。同样，您可以使用gRPC客户端调用其他服务和它们的方法。gRPC通常用于服务间通信，这对于基于微服务的应用程序至关重要。然而，它也可以用于基于Web的通信。
- en: Let’s learn a bit about microservices in the next section.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们了解一下微服务。
- en: Understanding microservice concepts
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解微服务概念
- en: Microservices are self-contained lightweight processes that communicate over
    a network. Microservices provide narrowly focused APIs to their consumers. These
    APIs can be implemented using REST, gRPC, or events.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是自包含的轻量级进程，通过网络进行通信。微服务为其消费者提供专注于特定功能的API。这些API可以使用REST、gRPC或事件来实现。
- en: Microservices are not new—they have been around for many years. For example,
    *Stubby*, a general-purpose infrastructure based on RPC, was used in Google data
    centers in the early 2000s to connect several services with and across data centers.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务并不新鲜——它们已经存在很多年了。例如，基于RPC的通用基础设施*Stubby*，在21世纪初被用于谷歌数据中心，以连接几个服务和数据中心。
- en: They have seen a recent rise in popularity and visibility. Before microservices
    became popular, monolithic architectures were mainly used for developing on-premises
    and cloud-based applications.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 它们最近在流行度和可见度上有所上升。在微服务变得流行之前，单体架构主要用于开发本地和基于云的应用程序。
- en: A monolithic architecture allows the development of different components, such
    as presentation, application logic, business logic, and **data access objects**
    (**DAOs**), and then you either bundle them together in an **enterprise archive**
    (**EAR**) or **web archive** (**WAR**) or store them in a single directory hierarchy
    (such as Rails or Node.js).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构允许开发不同的组件，例如表示层、应用逻辑、业务逻辑和**数据访问对象**（**DAOs**），然后你可以将它们打包在一起形成一个**企业存档**（**EAR**）或**Web存档**（**WAR**），或者将它们存储在单个目录层次结构中（例如Rails或Node.js）。
- en: Many famous applications, such as Netflix, have been developed using a microservices
    architecture. Moreover, eBay, Amazon, and Groupon have evolved from monolithic
    architectures into microservices architectures. Nowadays, microservices-based
    application development is very common. The gRPC server that we have developed
    in this chapter could be called a microservice (obviously if you keep the scope
    of the server to either the `Source` service or `Charge` server).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 许多著名的应用程序，如Netflix，都是使用微服务架构开发的。此外，eBay、Amazon和Groupon已经从单体架构演变为微服务架构。如今，基于微服务的应用程序开发非常普遍。我们在本章中开发的gRPC服务器可以被称为微服务（显然，如果你将服务器的范围限制在`Source`服务或`Charge`服务器）。
- en: Let’s have a look at simple monolithic and microservices application designs
    in the next subsection.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一小节中看看简单的单体和微服务应用设计。
- en: In this section, we will take a look at the different system designs, which
    are designed using a monolithic design, an SOA monolithic design, and a microservices
    design. Let’s discuss each of these in turn.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨不同的系统设计，这些设计采用单体设计、SOA单体设计和微服务设计。让我们依次讨论这些设计。
- en: Traditional monolithic design
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统单体设计
- en: 'The following diagram depicts the traditional monolithic application design.
    This design was widely used before SOA became popular:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了传统的单体应用程序设计。这种设计在SOA变得流行之前被广泛使用：
- en: '![Figure 11.1 – Traditional monolithic application design](img/Figure_11.1_B19349.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 传统单体应用设计](img/Figure_11.1_B19349.jpg)'
- en: Figure 11.1 – Traditional monolithic application design
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 传统单体应用设计
- en: In a traditional monolithic design, everything is bundled in the same archive
    (all the presentation code is bundled in with the presentation archive, the application
    logic goes into the application logic archive, and so on), regardless of how it
    all interacts with the database files or other sources.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的单体设计中，所有内容都打包在同一个存档中（所有表示层代码都打包在表示层存档中，应用逻辑放入应用逻辑存档中，等等），无论它们如何与数据库文件或其他源进行交互。
- en: Monolithic design with services
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有服务的单体设计
- en: 'After SOA, applications started being developed based on services, where each
    component provides services to other components or external entities. The following
    diagram depicts a monolithic application with different services; here, services
    are being used with a presentation component. All services, the presentation component,
    or any other components are bundled together:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在SOA之后，应用程序开始基于服务进行开发，其中每个组件为其他组件或外部实体提供服务。以下图展示了具有不同服务的单体应用程序；在这里，服务与表示组件一起使用。所有服务、表示组件或任何其他组件都打包在一起：
- en: '![Figure 11.2 – Monolithic design with services](img/Figure_11.2_B19349.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 带有服务的单体设计](img/Figure_11.2_B19349.jpg)'
- en: Figure 11.2 – Monolithic design with services
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 带有服务的单体设计
- en: So, everything is bundled together in the form of EAR with a modules approach.
    A few SOA services may be deployed separately, but overall, it will be monolithic.
    However, the database is shared across the services.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有内容都以模块化的方式打包成EAR。一些SOA服务可能被单独部署，但总体上，它将是单体的。然而，数据库是在服务之间共享的。
- en: Microservices design
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务设计
- en: The following diagram depicts the microservices design. Here, each component
    is autonomous. Each component can be developed, built, tested, and deployed independently.
    Here, even the application’s UI component could also be a client and consume the
    microservices. For our example, the layer designed is used within the microservice.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图展示了微服务设计。在这里，每个组件都是独立的。每个组件都可以独立开发、构建、测试和部署。在这里，应用程序的UI组件也可以是一个客户端并消费微服务。在我们的例子中，设计的层是在微服务中使用的。
- en: '![Figure 11.3 – Microservices design](img/Figure_11.3_B19349.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3 – 微服务设计](img/Figure_11.3_B19349.jpg)'
- en: Figure 11.3 – Microservices design
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – 微服务设计
- en: The API gateway provides an interface where different clients can access the
    individual services and solve various problems, such as what to do when you want
    to send different responses to different clients for the same service. For example,
    a booking service could send different responses to a mobile client (minimal information)
    and a desktop client (detailed information), providing different details to each,
    before providing something different again to a third-party client.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: API网关提供了一个接口，不同的客户端可以访问单个服务并解决各种问题，例如当你想为同一服务向不同的客户端发送不同响应时应该怎么做。例如，预订服务可以向移动客户端（最少信息）和桌面客户端（详细信息）发送不同的响应，为每个客户端提供不同的详细信息，然后再向第三方客户端提供不同的内容。
- en: A response may require the fetching of information from two or more services.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 响应可能需要从两个或更多服务中获取信息。
- en: Each API service will be developed and deployed as a separate process and communication
    among these will happen based on exposed APIs.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 每个API服务都将作为一个独立的过程开发和部署，并且这些服务之间的通信将基于公开的API进行。
- en: 'For a sample e-commerce app, you can divide the application based on domains
    and bounded context and then develop a separate microservice for each of the domains.
    The following is a brief list of the provided microservices:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个示例电子商务应用，你可以根据领域和边界上下文来划分应用程序，然后为每个领域开发一个独立的微服务。以下是一个提供的微服务的简要列表：
- en: Customers
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户
- en: Orders
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单
- en: Billing
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计费
- en: Shipping
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发货
- en: Invoicing
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开票
- en: Inventory
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库存
- en: Payment collection
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收款
- en: You can develop each of these separately and use inter-process (inter-service)
    communication to stitch the solution together.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以分别开发这些功能，并使用进程间（服务间）通信来整合解决方案。
- en: Summary
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you explored Protobuf and gRPC-based service implementation.
    You developed the gRPC server and then consumed its services by developing a gRPC
    client. You learned about unit-testing the gRPC server and handling exceptions
    for gRPC-based services, and you also learned about the basic concepts of microservices.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你探索了基于Protobuf和gRPC的服务实现。你开发了gRPC服务器，然后通过开发gRPC客户端来消费其服务。你学习了如何对gRPC服务器进行单元测试，以及如何处理基于gRPC服务的异常，你还学习了微服务的基本概念。
- en: You now have the skills to develop gRPC-based services (servers) and clients
    by defining the services using Protobuf.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有了使用Protobuf定义服务来开发基于gRPC的服务（服务器）和客户端的技能。
- en: In the next chapter, you will learn about distributed logging and tracing in
    web services.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于在Web服务中的分布式日志和跟踪。
- en: Questions
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why should you use gRPC for binary large object transfers via HTTP/2?
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你应该使用gRPC通过HTTP/2进行二进制大对象传输？
- en: You have implemented exception handling using `com.google.rpc.Status`. Can you
    do so without using this?
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你已经使用`com.google.rpc.Status`实现了异常处理。你能否不使用它来完成？
- en: What is the difference between `com.google.rpc.Status` and `io.grpc.Status`?
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`com.google.rpc.Status`和`io.grpc.Status`之间的区别是什么？'
- en: Answers
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Because, unlike HTTP libraries, gRPC libraries also provide the following features:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为，与HTTP库不同，gRPC库还提供了以下功能：
- en: Interaction with flow control at the application layer
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与应用层流量控制的交互
- en: Cascading call cancellation
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级联调用取消
- en: Load balancing and failover
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡和故障转移
- en: 'Yes, you can. You can use the metadata shown in the following code block. However,
    making use of `com.google.rpc.Status` allows you to use the `details` (with a
    type of `Any`) object, which can capture more information:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，你可以。你可以使用以下代码块中显示的元数据。然而，使用`com.google.rpc.Status`允许你使用`details`（类型为`Any`）对象，它可以捕获更多信息：
- en: '[PRE54]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`com.google.rpc.Status` can include details of the `Any` type, which can be
    used to provide more error details. `io.grpc.Status` does not have a field that
    contains the error details. You must rely on another class’s metadata to provide
    the error-related details, which may or may not contain only error specific information.'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`com.google.rpc.Status`可以包含`Any`类型的详细信息，这可以用来提供更多的错误详情。`io.grpc.Status`没有包含错误详情的字段。你必须依赖另一个类的元数据来提供与错误相关的详情，这些详情可能或可能不包含仅错误特定的信息。'
- en: Further reading
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Protobuf version 3 documentation: [https://developers.google.com/protocol-buffers/docs/proto3](https://developers.google.com/protocol-buffers/docs/proto3)'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Protobuf版本3文档：[https://developers.google.com/protocol-buffers/docs/proto3](https://developers.google.com/protocol-buffers/docs/proto3)
- en: 'Protobuf’s well-known types: [https://developers.google.com/protocol-buffers/docs/reference/google.protobuf](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Protobuf的已知类型：[https://developers.google.com/protocol-buffers/docs/reference/google.protobuf](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf)
- en: '*Practical* *gRPC*: [https://www.packtpub.com/in/web-development/practical-grpc](https://www.packtpub.com/in/web-development/practical-grpc)'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实用* *gRPC*：[https://www.packtpub.com/in/web-development/practical-grpc](https://www.packtpub.com/in/web-development/practical-grpc)'
