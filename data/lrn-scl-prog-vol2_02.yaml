- en: Shaping our Scala Program
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 塑造我们的 Scala 程序
- en: '"I conclude that there are two ways of constructing a software design: One
    way is to make it so simple that there are obviously no deficiencies and the other
    way is to make it so complicated that there are no obvious deficiencies. The first
    method is far more difficult."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '"我得出结论，构建软件设计有两种方式：一种方式是让它如此简单，以至于显然没有缺陷；另一种方式是让它如此复杂，以至于没有明显的缺陷。第一种方法要困难得多。"'
- en: '- C. A. R. Hoare'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- C. A. R. 霍尔'
- en: A program is a solution specific to a problem. The solution we write is broken
    down to different tasks. Tasks can be specific to a step or a part of the solution.
    While coding for such tasks, we use constructs as tools to make them easier, readable,
    and performant. These tools make it possible to shape up your program at hand.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 程序是对特定问题的解决方案。我们编写的解决方案被分解为不同的任务。任务可以是特定于一个步骤或解决方案的一部分。在为这样的任务编码时，我们使用构造作为工具来使它们更容易、更易读、更高效。这些工具使您能够塑造手中的程序。
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Looping
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环
- en: '`for`, `while`, and `do while` loops'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`、`while` 和 `do while` 循环'
- en: 'The `for` expressions: a quick go-through'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 表达式：快速浏览'
- en: Recursion
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归
- en: Conditional statements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件语句
- en: '`if`, and `if else`'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` 和 `if else`'
- en: Pattern matching
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Looping
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: Standing in front of a printer, you give it an instruction to print pages with
    indexes 2 to 16 from your book. The printer, which is programmed to do so, uses
    an algorithm to print pages for you; it checks for the document and the number
    of pages you asked to print. It sets the starting point as 2 and the last point
    as 16, and it starts printing till the last point is reached. Printing pages we
    can call repetitive, thus printing each page from your document can be well programmed
    using a looping construct. As in any other language, Scala supports `for`*,* `while`,
    and `do while` loops.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 站在打印机前，你给它一个指令，让它从你的书中打印索引为 2 到 16 的页面。这个被编程来这样做打印机，使用一个算法为你打印页面；它检查你请求打印的文档和页数。它将起始点设置为
    2，最后一个点设置为 16，然后开始打印，直到达到最后一个点。打印页面我们可以称之为重复性的，因此，使用循环结构来编程打印你的文档中的每一页是很好的。就像任何其他语言一样，Scala
    支持 `for`、`while` 和 `do while` 循环。
- en: 'Take a look at the following program:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下程序：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have created an object named `PagePrinter`. We use the syntax `/* ... */`
    to declare multi-line comments and `//` for single line comments in Scala. We
    declared three methods, which are supposed to do what the comment says. These
    methods are yet to be defined and we have communicated that to the Scala compiler,
    how? Using the syntax "???", that is, three question mark symbols, we tell the
    Scala compiler we're yet to define the method.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `PagePrinter` 的对象。我们使用 `/* ... */` 语法来声明多行注释，并在 Scala 中使用 `//` 来声明单行注释。我们声明了三个方法，这些方法应该执行注释中所述的操作。这些方法尚未定义，并且我们已经通过使用语法
    "???"（即三个问号符号）通知 Scala 编译器我们尚未定义该方法。
- en: Let's come back to our methods. The first one takes a document, the number of
    pages to print as arguments, and prints pages up to the passed index. The second
    one takes the start and end indexes of pages to print and does so. The third method
    can take random indexes to print and prints pages from those indexes. In the third
    method, we've used an asterisk `*` to make our Int argument a vararg, that is,
    a variable argument. Now, the task is to define these methods. We can also see
    that to define what a document is, we have used a case class—we'll learn about
    case classes when we go deeper into Scala's object-oriented part in the next few
    chapters. For now, it'll be helpful to know that a case class let's you create
    a class with all the boilerplate code already available for you; it means you
    can access the members, in our case, `numOfPages` and `typeOfDoc`. Well, there's
    a lot to know about case classes, but we'll go through it later. We'll use our
    looping constructs to define our `PagePrinter`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的方法。第一个方法接受一个文档和要打印的页数作为参数，并打印到传递的索引页。第二个方法接受要打印的页面的起始和结束索引，并执行打印。第三个方法可以接受随机索引来打印，并从这些索引打印页面。在第三个方法中，我们使用星号
    `*` 将我们的 Int 参数作为可变参数，即变量参数。现在，任务是定义这些方法。我们还可以看到，为了定义什么是文档，我们使用了案例类——我们将在下一章深入探讨
    Scala 的面向对象部分时学习案例类。现在，了解案例类将很有帮助，它允许您创建一个带有所有样板代码的类；这意味着您可以访问成员，在我们的例子中，是 `numOfPages`
    和 `typeOfDoc`。嗯，关于案例类有很多东西要了解，但我们稍后再谈。我们将使用我们的循环结构来定义我们的 `PagePrinter`。
- en: Let's take a look at our looping constructs. We'll first go through the `for`
    loop.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的循环结构。我们首先将了解 `for` 循环。
- en: The for loop
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: for 循环
- en: 'In Scala, a `for` loop, also called `for` comprehension takes a sequence of
    elements, and performs an operation on each of them. One of the ways we can use
    them is:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，`for`循环，也称为`for`推导式，接受一系列元素，并对它们中的每一个执行操作。我们可以使用它们的一种方式是：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We defined a list named stocks with a few stock names. Then we used a simple
    `for` loop to print out each stock from that list. Take a look at the syntax:
    we have `stock <- stocks` that represents a single value from the list at the
    left-hand side of the generator sign `<-` and the list or sequence at the right-hand
    side. Then finally, we can provide any operation to be performed, in our case
    we printed the names. Now that we''ve seen how to write a simple `for` loop, let''s
    define our set of `printPages` methods:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`stocks`的列表，其中包含一些股票名称。然后我们使用一个简单的`for`循环来打印出列表中的每个股票。看看语法：我们有`stock
    <- stocks`，它表示在生成器符号`<-`左侧列表中的一个单一值，以及右侧的列表或序列。然后最终，我们可以提供任何要执行的操作，在我们的例子中我们打印了名称。现在我们已经看到了如何编写一个简单的`for`循环，让我们定义我们的`printPages`方法集：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is the output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have a utility `print` method, which does nothing but print a simple string
    with index numbers, you're free to imagine a real printer printing the pages though.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`print`的实用方法，它只是打印一个带有索引数字的简单字符串，尽管你可以自由想象一个真正的打印机打印页面。
- en: Our definition for `printPages` method version 1 merely consists of a condition
    check that the document consists of the pages to be printed. That's done via an
    `if` conditional statement. More on `if` statements later in this chapter. After
    the conditional statement, there's a loop on indexes which ranges from 1 to the
    `lastIndex` passed. The same way the other method version 2 is also defined that
    takes `startIndex` and `lastIndex` and prints pages for you. For the last method
    version 3 of `printPages`*,* we're looping on the indexes passed and we have a
    condition guard that starts with an `if` statement*.* This checks whether the
    page index is less than the number of pages in the document passed as an argument,
    and prints it. Finally, we got the result expected from our methods.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`printPages`方法版本1的定义仅仅包括一个条件检查，即文档是否包含要打印的页面。这是通过一个`if`条件语句完成的。关于`if`语句的更多内容将在本章后面介绍。在条件语句之后，有一个循环遍历索引，范围从1到传递的`lastIndex`。同样，其他方法版本2也是定义的，它接受`startIndex`和`lastIndex`并为你打印页面。对于`printPages`的最后一个方法版本3，我们正在遍历传递的索引，并且有一个以`if`语句开始的条件保护器。这检查页面索引是否小于作为参数传递的文档中的页面数，并打印它。最后，我们得到了从我们的方法中期望的结果。
- en: The while Loop
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: while循环
- en: 'Like in most other languages, the `while` loop is another looping construct
    used. The `while` loop can do any repetitive task until a condition is satisfied.
    It means that the condition provided has to be true for the code execution to
    stop. Generic syntax for the `while` loop is:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在大多数其他语言中一样，`while`循环是另一种循环结构。`while`循环可以在满足条件之前执行任何重复任务。这意味着提供的条件必须为真，代码执行才能停止。`while`循环的通用语法是：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The condition to be checked is going to be a Boolean expression. It gets terminated
    when the condition is `false`. One of the ways we can use them is:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 需要检查的条件将是一个布尔表达式。当条件为`false`时，它将终止。我们可以使用它们的一种方式是：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We've used our list of stocks with a few stock names. Then we called the `iterator`
    method on the list to get an iterator for our sequence. Here `iteraatorForStocks`
    of `Type Iterator[String]` is a non-empty iterator that we can use to iterate
    over the list. Iterators have `hasNext` methods to check if there's a component
    remaining in sequence. Calling `next` on the iterator gives the resulting element.
    We've printed by iterating over the elements of our stock list. Let's take a look
    at `do while` loops.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用我们的股票列表和一些股票名称。然后我们在列表上调用`iterator`方法来获取我们序列的迭代器。在这里，`iteraatorForStocks`是`Type
    Iterator[String]`的非空迭代器，我们可以用它来遍历列表。迭代器有`hasNext`方法来检查序列中是否还有剩余的组件。在迭代器上调用`next`将给出结果元素。我们通过迭代股票列表的元素来打印。让我们看看`do
    while`循环。
- en: The do while loop
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: do while循环
- en: 'The `do while` loop does not differ a lot from the `while` loop. Generic syntax
    for `do while` loop is:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`do while`循环与`while`循环没有太大区别。`do while`循环的通用语法是：'
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `do while` loop ensures that the code in block gets executed at least once
    and then checks for the condition defined in a `while` expression:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`do while`循环确保代码块至少执行一次，然后检查在`while`表达式中定义的条件：'
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is the result:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结果：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It's a simple example where our statement is getting printed just once before
    the condition passed to the `while` loop is `false`*.* This is how we can use
    `do while` loops in Scala.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，我们的声明在`while`循环的条件变为`false`之前只打印了一次。这就是我们如何在Scala中使用`do while`循环的方式。
- en: You may want to try out the `PagePrinter` example using the `while` and `do
    while` loops.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想尝试使用`while`循环和`do while`循环的`PagePrinter`示例。
- en: The for expressions
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`for`表达式'
- en: 'We''ve seen the `for` loops, and how simple it is to use them in Scala. There''s
    much more we can do with the `for` syntax. Here''s an example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`for`循环，以及如何在Scala中使用它们是多么简单。我们可以用`for`语法做更多的事情。以下是一个例子：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the result:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, we used a generator, definitions, and filters in the
    `for` expression. We used a `for` expression on a list of persons. We proposed
    a gift hamper for a person whose name starts with `A` and who is older than 20
    years of age.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在`for`表达式中使用了生成器、定义和过滤器。我们在人员列表上使用了一个`for`表达式。我们为名字以`A`开头且年龄超过20岁的人提出了一个礼品篮。
- en: 'The first expression in `for` is a generator expression which generates a new
    person from the persons list and assigns to person. Second is age and name definitions.
    Then finally we apply filters using the `if` statement to put conditions for our
    winner:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`中的第一个表达式是一个生成器表达式，它从人员列表中生成一个新的个人，并将其分配给`person`。第二个是年龄和名字的定义。然后最后，我们使用`if`语句应用过滤器来为我们的获胜者设置条件：'
- en: '![](img/00016.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00016.jpeg)'
- en: The for expressions
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`表达式'
- en: What if we want a couple more prizes for our people. In that case we may want
    to get a sub list of winners. That's possible by introducing `yield`*.*
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为我们的员工增加一些奖品，那么我们可能想要获取获胜者的子列表。通过引入`yield`*.*这是可能的。
- en: The for yield expressions
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`for yield`表达式'
- en: 'Here''s an example of a `for yield` expression where we''re listing the names
    of winners. The criteria for winning a prize is the age, which should be more
    than 20:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`for yield`表达式的例子，我们在这里列出了获胜者的名字。获奖的条件是年龄，应该超过20岁：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The following is the result**:**
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是**：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, `yield` does the trick and results in a list of people with satisfying
    criteria. That's how `for yield` expressions work in Scala.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`yield`起到了作用，并产生了一个满足条件的个人列表。这就是`for yield`表达式在Scala中的工作方式。
- en: But these iterations are not what Scala or any other functional programming
    language recommends. Let's check out why this is and the alternative to iterative
    loops.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些迭代并不是Scala或其他任何函数式编程语言所推荐的。让我们来看看为什么是这样，以及迭代循环的替代方案。
- en: Recursion
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: 'Recursion is a function''s call to itself. In simple words, a recursive function
    is a function which calls itself. Functional programming recommends use of recursion
    over the use of iterative looping constructs. For the same obvious reasons, Scala
    also recommends use of **recursion**. Let''s first take a look at a recursive
    function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一个函数对自己的调用。简单来说，递归函数是一个调用自身的函数。函数式编程推荐使用递归而不是迭代循环结构。出于同样的明显原因，Scala也推荐使用**递归**。让我们首先看看一个递归函数：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following is the result:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We've defined a function `power2toN` which expects an integer `n`, checks for
    `n` value and if it's not 0, the function calls itself, decrementing `n` integer's
    value till the number `n` becomes `0`. Then comes multiplying the value with 2
    with each recursive call to get the desired result.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`power2toN`的函数，它期望一个整数`n`，检查`n`的值，如果它不是0，则函数会调用自身，递减`n`整数的值，直到`n`变为0。然后，在每次递归调用中，将值乘以2，以获得所需的结果。
- en: 'Consider the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Scala compiler gives an error stating `Recursive method power2N needs result
    type`*.* This is a required condition by the Scala compiler. We have to explicitly
    define the response type of a recursive function—that's the reason we have to
    give the return type with the method definition.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Scala编译器会报错，指出`Recursive method power2N needs result type`*.*这是Scala编译器的一个必要条件。我们必须显式地定义递归函数的响应类型——这就是为什么我们必须在方法定义中给出返回类型的原因。
- en: Why recursion over iteration?
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么递归比迭代更好？
- en: 'Given the statement *functional programming recommends recursion over iteration*,
    let''s discuss why this is the case. If you take a closer look at our definition:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 根据声明*函数式编程推荐递归而不是迭代*，让我们讨论一下为什么是这样。如果你仔细看看我们的定义：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The function definition consists of some conditional statement and finally a
    call to itself. There's no mutation of states for any variables. Functional programming
    recommends pure functions, which means functions with no side effects. Side effects
    can be mutating a state of a variable, performing I/O operations. This is not
    possible in iteration. Iteration, consists of mutation of its counter/index variable
    mutating over repetitions. Recursion, on the other hand, can be done without performing
    any such state changes. This makes it powerful and usable in functional languages.
    Operations via recursive functions can be performed with all the power of multiple
    cores executing them without the worry of the same variable state change by different
    threads. Hence recursion is recommended. But there's a glitch in recursion.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义由一些条件语句和最终对自身的调用组成。没有任何变量状态的突变。函数式编程推荐纯函数，这意味着没有副作用。副作用可能包括突变一个变量的状态，执行I/O操作。这在迭代中是不可能的。迭代由其计数器/索引变量的突变组成，在重复中突变。另一方面，递归可以在不执行任何此类状态变化的情况下完成。这使得它强大且在函数式语言中使用。通过递归函数执行的操作可以使用所有多核执行它们的强大功能，而不用担心不同线程会改变相同的变量状态。因此，递归是推荐的。但递归中有一个问题。
- en: Limitations of recursion
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归的限制
- en: With smaller repetitions or fewer levels of calling functions, recursion is
    considered to be ok, but with more levels it ends up  filling the stack. What's
    that?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在较小的重复次数或较少的函数调用级别时，递归被认为是可行的，但随着级别的增加，最终会导致栈被填满。那是什么意思？
- en: A function call in a program adds a new element to call a stack. A call stack
    keeps track of information about the function call. For each recursive call, a
    new call gets added to a stack, hence it works fine for a smaller number of recursive
    calls. But as the level goes deeper for recursive calls, the call stack reaches
    its limits and the program gets terminated. That's something unintended and breaks
    our program. So, shall we avoid *recursion* or use it?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的函数调用会在调用栈中添加一个新的元素来调用。调用栈跟踪函数调用的信息。对于每次递归调用，都会在栈中添加一个新的调用，因此对于较少的递归调用来说，它运行良好。但随着递归调用级别的加深，调用栈达到其极限，程序会终止。这是意料之外的事情，破坏了我们的程序。那么，我们应该避免递归还是使用它？
- en: The ideal way to write recursive functions
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写递归函数的理想方式
- en: 'The complication with *recursion* is filling up the space of the call stack.
    If we find a way which can free up the current stack for each recursive call and
    use it for all subsequent recursive calls, we can somewhat optimize the use of
    a call stack and that can result in better performance of recursive functions.
    Let''s try to understand it this way: we have the definition of our recursive
    function `power2N`*:*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 递归的复杂性在于调用栈空间的填充。如果我们找到一种方法，可以在每次递归调用中释放当前栈，并用于所有后续的递归调用，我们可以在一定程度上优化调用栈的使用，这可以导致递归函数性能的更好。让我们这样理解：我们有我们的递归函数`power2N`的定义：*
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As shown in the definition, after a call to itself, `power2toN` needs to keep
    track of its call stack, because the result of it needs to get multiplied by 2
    to finalize the step and get the desired result. To avoid this and make an efficient
    use of the call stack, we can define a helper function as the very last step to
    be executed in the recursive function. In other words, if we make our function
    call a tail call, we will be able to optimize the use of call stack, hence resulting
    in better recursion. This phenomenon is called tail call optimization:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如定义所示，在对自己进行调用之后，`power2toN`需要跟踪其调用栈，因为它的结果需要乘以2以完成步骤并得到期望的结果。为了避免这种情况并有效地使用调用栈，我们可以在递归函数的最后一个步骤中定义一个辅助函数。换句话说，如果我们使我们的函数调用成为尾调用，我们将能够优化调用栈的使用，从而实现更好的递归。这种现象称为尾调用优化：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following is the result:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果是：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Above is the *tail optimized* version of our method `power2toN`*.* The annotation
    used here `@tailrec` is to explicitly tell the Scala compiler to recognize a tail
    recursive function and optimize accordingly. What's different here is the use
    of a nested, `helper` method, that's recursive and contains a tail call. After
    a call to `helper(n-1, currentVal * 2)`, there's no further need for that call
    stack. Hence, the Scala compiler is free to optimize accordingly. More on tail
    recursion and tail call optimization in [Chapter 9](part0181.html#5CJLQ0-921a8f8dca2a47ea817d3e6755fa0e84),
    *Using Powerful Functional Constructs.*
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的是我们方法 `power2toN` 的 *尾部优化* 版本。这里使用的注解 `@tailrec` 是为了明确告诉 Scala 编译器识别一个尾部递归函数并相应地进行优化。这里的不同之处在于使用了嵌套的、递归的
    `helper` 方法，它包含尾部调用。在调用 `helper(n-1, currentVal * 2)` 之后，就不再需要这个调用栈了。因此，Scala
    编译器可以自由地进行优化。更多关于尾部递归和尾部调用优化的内容请参阅 [第 9 章](part0181.html#5CJLQ0-921a8f8dca2a47ea817d3e6755fa0e84)，*使用强大的函数式构造*。
- en: This is the preferred way of writing recursive functions in Scala. It takes
    more effort in understanding the requirement and writing one than simply writing
    an iterative version of your method. But it's worth it in the functional world.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Scala 中编写递归函数的首选方式。理解需求并编写一个递归版本比简单地编写方法的迭代版本要费劲得多。但在函数式世界中，这是值得的。
- en: Conditional statements
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句
- en: We've already used conditionals many times. It's hard to have your program make
    sense without a conditional or logical statement. These statements help keep the
    flow of the program intact. Moreover, logic implementation is also easier with
    the use of these. Scala supports `if` and `else` conditional statements.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次使用条件了。没有条件或逻辑语句，程序很难有意义。这些语句有助于保持程序的流程。此外，使用这些语句实现逻辑也更容易。Scala 支持 `if`
    和 `else` 条件语句。
- en: The if else conditional expression
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if else 条件表达式
- en: 'In Scala, you can use `if else` to control program flow. The generic syntax
    for an `if else` statement goes as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，你可以使用 `if else` 来控制程序流程。`if else` 语句的通用语法如下：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Above, we defined a variable `age` with value 17\. In the next line, we checked
    a condition `age > 18`. If age is greater than 18 then we printed some string.
    You''re now a responsible adult, or some other string. Instead of just printing
    out strings, we can perform any operation as part of the control flow. In Scala,
    we can also declare and assign a value to our variables using `if else` expressions:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上文，我们定义了一个值为 17 的变量 `age`。在下一行，我们检查了一个条件 `age > 18`。如果年龄大于 18，则打印一些字符串。你现在是一个负责任的成年人，或者其他的字符串。我们不仅可以打印字符串，还可以将任何操作作为控制流程的一部分执行。在
    Scala 中，我们还可以使用 `if else` 表达式声明和赋值变量：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here we assigned a value to a variable `performance` on the fly using conditional
    expressions. We checked if marks are greater than 90, or in between 60 to 90,
    or less than 90 and based on that assigned the value for performance. This happens
    because in Scala, conditionals are expressions—the result of an `if` statement,
    is an expression.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用条件表达式即时给变量 `performance` 赋值。我们检查分数是否大于 90，或者介于 60 到 90 之间，或者小于 90，并根据这个条件为性能分配值。这是因为
    Scala 中的条件是表达式——`if` 语句的结果是一个表达式。
- en: There's another way to control the flow of our program in Scala that uses matching
    of an expression or construct to a value and evaluation of a corresponding block
    of code on a successful match. We call it pattern matching in Scala.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，还有另一种控制程序流程的方法，它使用表达式或结构的匹配到一个值，并在成功匹配后评估相应的代码块。我们称之为模式匹配。在 Scala
    中。
- en: Pattern matching
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Pattern matching is more like Java's `switch` statements with a few differences.
    With one expression/value to match against several case statements, whenever a
    match happens, the corresponding block of code is executed. This gives more than
    one option for our program flow to follow. Java's switch is a fall-through statement,
    which means it executes all the statements after the very first match until it
    confronts a `break` statement. In Scala, there's no `break` statement. Also, there's
    no default case in Scala's pattern matching. Instead, a wildcard "_" is used that
    matches against any other case that has not been covered in previous `case` statements.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配更像是Java的`switch`语句，但有一些不同。有一个表达式/值要匹配多个case子句，每当发生匹配时，相应的代码块就会被执行。这为我们程序的流程提供了多个选择。Java的`switch`是一个穿透语句，这意味着它执行第一个匹配之后的所有语句，直到遇到`break`语句。在Scala中，没有`break`语句。此外，Scala的模式匹配中没有默认情况。相反，使用通配符“_”来匹配之前`case`子句中没有涵盖的其他情况。
- en: 'Let''s have a look at the syntactical difference between Java''s switch and
    Scala''s pattern matching statements:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Java的`switch`语句和Scala的模式匹配语句在语法上的差异：
- en: '![](img/00017.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00017.jpeg)'
- en: The difference is obvious, as we already discussed. In Scala, we have to provide
    a case matching to our expression, otherwise the compiler will throw an error, `MatchError`*:*
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 差异很明显，正如我们之前讨论的那样。在Scala中，我们必须为我们的表达式提供一个case匹配，否则编译器将抛出一个错误，`MatchError`*：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following is the result:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的结果是：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding example, we didn''t cover all cases possible so the compiler
    gave this error back. To cover all the cases, we can add the wildcard "_" as the
    last `case` clause. This will work fine. Let''s try that:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们没有涵盖所有可能的情况，因此编译器返回了这个错误。为了涵盖所有情况，我们可以在最后一个`case`子句中添加通配符“_”。这将工作得很好。让我们试试：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following is the result:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的结果是：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After covering every `case` clause, pattern matching works a charm. We got a
    response; for value 1 we got a corresponding `One`, and for 5 we got `Not in Range
    1 to 4`. There's more to pattern matching in Scala. We'll go through pattern matching
    in detail and learn several constructs to match against in [Chapter 9](part0181.html#5CJLQ0-921a8f8dca2a47ea817d3e6755fa0e84),
    *Using Powerful Functional Constructs*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在覆盖完每一个`case`子句后，模式匹配表现得非常出色。我们得到了响应；对于值1，我们得到了相应的`One`，而对于5，我们得到了`Not in Range
    1 to 4`。Scala中的模式匹配还有很多内容。我们将在[第9章](part0181.html#5CJLQ0-921a8f8dca2a47ea817d3e6755fa0e84)“使用强大的函数式构造”中详细讲解模式匹配，并学习几个匹配构造。
- en: Summary
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We can conclude our chapter; let''s go through what we have learned. We started
    learning about looping constructs in Scala. We discussed native looping constructs
    such as `for`*,* `while`*,* and `do while` loops. After that, we saw `for` expressions*,*
    along with `for yield` expressions. Then we understood alternatives to iteration,
    that is, *recursion.* We wrote a few recursive functions as well. Finally, we
    looked at `if else` conditional statements and pattern matching. We know there''s
    much more to come, but with these concepts we''re on our way to understanding
    Scala language constructs better. We''ll continue doing that in our next chapter.
    There we''ll take a look at the core of functional programming: functions. We
    will see how functions are defined and used. It''ll show the variety of functional
    constructs we have available in Scala. We''ll try to give meaning to our programs
    using functions*.*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以总结本章内容；让我们回顾一下我们所学到的。我们从学习Scala中的循环结构开始。我们讨论了原生的循环结构，如`for`*、* `while`*、*和`do
    while`循环。之后，我们看到了`for`表达式*，以及`for yield`表达式。然后我们理解了迭代的替代方案，即*递归*。我们也编写了一些递归函数。最后，我们研究了`if
    else`条件语句和模式匹配。我们知道还有更多内容要学习，但有了这些概念，我们正在更好地理解Scala语言结构。我们将在下一章继续这样做。在那里，我们将探讨函数式编程的核心：函数。我们将看到函数是如何定义和使用的。它将展示Scala中可用的各种函数式构造。我们将尝试通过函数*为我们的程序赋予意义。
