- en: Chapter 4. Developing Reactive Backing Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 开发反应式后端服务
- en: In the previous chapter, you learned how to Bootstrap your application using
    Activator, and we developed our web application using Scala and the Play framework.
    Now we will enter into the reactive world of RxJava and RxScala.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何使用Activator引导你的应用程序，我们使用Scala和Play框架开发了我们的Web应用程序。现在我们将进入RxJava和RxScala的反应式世界。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Reactive programming principles and the Reactive Manifesto
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式编程原则和反应式宣言
- en: Understanding the importance of non-blocking IO
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解非阻塞I/O的重要性
- en: Observables, functions, and error handling with Rx
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观测性、函数和Rx中的错误处理
- en: Refactoring our controllers and models to call our services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构我们的控制器和模型以调用我们的服务
- en: Adding RxScala to our services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将RxScala添加到我们的服务中
- en: Adding logging
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加日志
- en: Getting started with reactive programming
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用反应式编程
- en: 'Building applications today is harder than it was before. Everything now is
    more complex: we have to use more cores in processors, and we have cloud-native
    applications with hundreds of machines for a single service. Concurrent programming
    has always been hard, and it will always be so, because it is difficult to model
    time. In order to address this, we need to have a reactive style of architecture.
    In order to be able to handle more users and scale our applications, we need to
    leverage Async and non-blocking IO. To help us with this task, we can rely on
    RxJava and RxScala. Being reactive is not only about code but also about architectural
    principles.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建应用程序比以前更难。现在的一切都更加复杂：我们必须在处理器中使用更多的核心，并且我们有了数百台机器的单个服务云原生应用程序。并发编程一直很难，而且它将始终如此，因为建模时间很困难。为了解决这个问题，我们需要有一个反应式架构风格。为了能够处理更多用户并扩展我们的应用程序，我们需要利用异步和非阻塞I/O。为了帮助我们完成这项任务，我们可以依赖RxJava和RxScala。反应式不仅关乎代码，也关乎架构原则。
- en: The Reactive Manifesto captures these principles very well, and there are a
    couple of technologies that follow these principles in order to be fully reactive.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式宣言很好地捕捉了这些原则，并且有一些技术遵循这些原则以实现完全的反应式。
- en: 'The Reactive Manifesto can be shown as in the following diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式宣言可以表示如下图：
- en: '![Getting started with reactive programming](img/image00266.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用反应式编程](img/image00266.jpeg)'
- en: For more information, you can visit [http://www.reactivemanifesto.org/](http://www.reactivemanifesto.org/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，您可以访问[http://www.reactivemanifesto.org/](http://www.reactivemanifesto.org/)。
- en: 'The Reactive Manifesto describes what this reactive architecture/system looks
    like. Basically, there are the following four core principles underlining the
    reactive idea:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式宣言描述了这种反应式架构/系统看起来是什么样子。基本上，以下是支撑反应式理念的四个核心原则：
- en: '**Responsive**: The system should respond in a timely manner. In other words,
    the system should detect problems quickly, and deal with them effectively, apart
    from providing rapid and consistent response time.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应性**：系统应能够及时响应。换句话说，系统应能够快速检测问题，并有效地处理它们，除了提供快速和一致的反应时间。'
- en: '**Resilient**: The system should stay responsive even after failure. This is
    done via replication containment, isolation, and delegation ([https://en.wikipedia.org/wiki/Delegation_pattern](https://en.wikipedia.org/wiki/Delegation_pattern)).
    Containment and isolation are ideas that come from the naval industry, and are
    defined by the bulkhead pattern ([https://en.wikipedia.org/wiki/Bulkhead_(partition)](https://en.wikipedia.org/wiki/Bulkhead_(partition))).
    Failures are contained at each component. Doing so makes sure that one system''s
    failure does not affect other systems. Recovery is delegated to another system,
    and not to the client.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：系统即使在失败后也应保持响应。这是通过复制、隔离和委托（[https://en.wikipedia.org/wiki/Delegation_pattern](https://en.wikipedia.org/wiki/Delegation_pattern)）来实现的。隔离和隔离的想法来自海军工业，并由舱壁模式（[https://en.wikipedia.org/wiki/Bulkhead_(partition)](https://en.wikipedia.org/wiki/Bulkhead_(partition)））定义）。故障被包含在每个组件中。这样做可以确保一个系统的故障不会影响其他系统。恢复委托给另一个系统，而不是客户端。'
- en: '**Elastic**: The ability to increase and decrease resources for the system.
    This requires you design your system without **Single Point Of Failure** (**SPOF**),
    and design using shards and replication. Reactive systems are predictive and cost-effective.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：系统应能够增加和减少系统资源。这要求你设计系统时不要有**单点故障**（**SPOF**），并且使用分片和复制进行设计。反应式系统是预测性和成本效益的。'
- en: '**Message-driven**: Reactive systems rely on asynchronous message passing to
    ensure loose coupling, isolation, and location transparency. By doing so, we can
    delegate failures as messages. This gives us elasticity, load management, and
    flow control. It''s even possible to apply back-pressure (also known as throttling)
    when needed. All this should be done with non-blocking communication for better
    resource utilization.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息驱动**：反应式系统依赖于异步消息传递以确保松散耦合、隔离和位置透明性。通过这样做，我们可以将故障作为消息进行委派。这为我们提供了弹性、负载管理和流量控制。在需要时，甚至可以应用反向压力（也称为节流）。所有这些都应该通过非阻塞通信来完成，以实现更好的资源利用。'
- en: Alright, let's use these principles practically in our application with RxScala.
    RxScala is just a Scala wrapper for RxJava, but it is better to use because it
    makes the code more functional, and you don't need to create objects such as `Action1`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们在应用中使用RxScala将这些原则付诸实践。RxScala只是RxJava的Scala包装器，但使用它更好，因为它使代码更具有函数式，而且你不需要创建像`Action1`这样的对象。
- en: 'In our application, we have three major resources: products, reviews, and images.
    All products must have a price, so we will built a fully reactive price generator
    with the Play framework, RxScala, and Scala right now.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，我们有三个主要资源：产品、评论和图片。所有产品都必须有一个价格，所以我们将使用Play框架、RxScala和Scala现在构建一个完全反应式的价格生成器。
- en: So first of all, we will play with RxScala in our Play application, then we
    will create a separate microservice, make reactive calls to that microservice,
    and retrieve our price suggestion for that service. All data flow transformations
    are using observables.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在我们的Play应用中玩转RxScala，然后我们将创建一个独立的微服务，对该微服务进行反应式调用，并检索该服务的价格建议。所有数据流转换都使用可观察对象。
- en: 'Let''s create the routes for this controller at `ReactiveWebStore/conf/routes` ,
    as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`ReactiveWebStore/conf/routes`创建这个控制器的路由，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have two routes here: one for a regular action, and another for an Async
    action that will return a Scala Future. Let''s create a new controller called
    `Rx Controller.scala`. This controller needs to be located at `ReactiveWebStore/app/controller`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '这里有两个路由：一个用于常规操作，另一个用于异步操作，它将返回一个Scala Future。让我们创建一个新的控制器，称为`Rx Controller.scala`。这个控制器需要位于`ReactiveWebStore/app/controller`。 '
- en: 'Let''s have a look at `RxController`, which is our reactive RxScala simple
    controller:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`RxController`，这是我们反应式的RxScala简单控制器：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, in the very first method called `prices`, we return a regular Play framework
    Action. We receive `IPriceService` via dependency injection. This `IPriceService`
    is a reactive service, because it uses observables. So we call a method, `generatePrices`,
    which will return `Observable[Double]`. This will be our source observable, that
    is, the data source of our computation. Moving forward, we create a new observable
    subscribing into the source observable, and then we apply some transformation.
    For instance, we take just one element, and then we can perform transformation
    using `flatMap`. For this case, we do not really apply transformations. We use
    `flatMap` to simply print what we got, and then continue the chain. The next step
    is to call `toBlocking`, which will block the thread until the data is back. Once
    the data is back, we get the first element, which will be a double, and we return
    `Ok`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在第一个名为`prices`的方法中，我们返回一个常规的Play框架Action。我们通过依赖注入接收`IPriceService`。这个`IPriceService`是一个反应式服务，因为它使用了可观察对象。所以我们调用一个方法，`generatePrices`，它将返回`Observable[Double]`。这将是我们计算的数据源，即我们的数据源。继续前进，我们创建一个新的可观察对象，订阅到源可观察对象，然后应用一些转换。例如，我们只取一个元素，然后我们可以使用`flatMap`进行转换。在这个案例中，我们实际上并没有应用转换。我们使用`flatMap`简单地打印我们得到的内容，然后继续链式操作。下一步是调用`toBlocking`，这将阻塞线程直到数据返回。一旦数据返回，我们得到第一个元素，它将是一个double类型，然后我们返回`Ok`。
- en: Blocking sounds bad and we don't want that. Alternatively, we can use the `async`
    controller in the Play framework, which won't block the thread and return a Future.
    So that's the second method, called `pricesAsync`. Here we have similar observable
    code. However, in the end, we return a Future which is not blocking. However,
    we call `toBlocking` from the observable that will block the call, thus making
    it the same as the previous method. To be clear, Action is not bad. By default,
    everything is Async in Play, because even if you don't return an explicit Future,
    the Play framework creates a promise for `y` and makes you code Async. Using HTTP,
    you will block the thread at some point. If you want to be 100% non-blocking from
    end to end, you need to consider a different protocol such as web sockets.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞听起来很糟糕，我们不希望这样。作为替代，我们可以在Play框架中使用`async`控制器，它不会阻塞线程并返回一个Future。所以这是第二种方法，称为`pricesAsync`。这里我们有类似的可观察对象代码。然而，最后我们返回一个非阻塞的Future。然而，我们调用可观察对象的`toBlocking`，这将阻塞调用，因此使其与之前的方法相同。为了清楚起见，Action并不坏。默认情况下，Play框架中一切都是异步的，因为即使你没有返回一个明确的Future，Play框架也会为`y`创建一个promise，并使你编写异步代码。使用HTTP，你会在某个点阻塞线程。如果你想要从头到尾100%非阻塞，你需要考虑一个不同的协议，例如web
    sockets。
- en: Let's take a look at the service now. This service, and other services, need
    to be located at `ReactiveWebStore/apps/services`. First we will create `trait`
    to define the service behavior.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看这个服务。这个服务以及其他服务都需要位于`ReactiveWebStore/apps/services`。首先，我们将创建`trait`来定义服务行为。
- en: IPriceService - Scala trait
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPriceService - Scala trait
- en: 'As you can see in the following code, we defined `IPriceService` with just
    one operation, that is, `generatePrices`, which returns `Observable[Double]`.
    The next step now is to define the service implementation. This code needs to
    be located in the same services folder as the previous trait:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示，我们只定义了一个操作`IPriceService`，即`generatePrices`，它返回`Observable[Double]`。现在的下一步是定义服务实现。这段代码需要位于与之前trait相同的services文件夹中：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: PriceService - RxScala PriceService implementation
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PriceService - RxScala PriceService实现
- en: First we create `PublishSubject`, which is a way to generate data into observables.
    Scala has a nice way of generating infinite sequences using `Stream.continually`.
    So we pass a function which generates double random numbers from 0 to 1,000\.
    This will happen forever and, because this is an expensive computation, we run
    it into a Future. The right thing to do will be to use a method after `Stream`,
    because this will finish the computation. For the sake of the exercise, we will
    keep it this way for now.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建`PublishSubject`，这是一种将数据生成到可观察对象中的方法。Scala有一个很好的方法，使用`Stream.continually`生成无限序列。因此，我们传递一个函数，该函数从0到1,000生成双随机数。这将永远发生，因为这个计算很昂贵，所以我们将其运行在Future中。正确的方法是在`Stream`之后使用一个方法，因为这将完成计算。为了练习的目的，我们暂时保持这种方式。
- en: Each double random number is published into `PublishSubject` by the `onNext`
    method. Now let's move to the `generatePrices` method, which uses three observables
    to generate the number for us. To be clear, of course we could do a simpler solution
    here. However, we are doing it this way to illustrate the power of observables,
    and how you can use them in practice.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个双随机数都通过`onNext`方法发布到`PublishSubject`。现在让我们转到`generatePrices`方法，该方法使用三个可观察对象为我们生成数字。为了清楚起见，当然我们可以在这里做一个更简单的解决方案。然而，我们这样做是为了展示可观察对象的力量以及如何在实践中使用它们。
- en: We have `Even` and `Odd` observables, both subscribing to `PublishSubject`,
    so they will receive infinite double numbers. There is a `flatMap` operation to
    add `10` to the number. Keep in mind that everything you do needs to be in an
    observable. So when you do transformations with `flatMap`, you always need to
    return an observable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`Even`和`Odd`可观察对象，它们都订阅了`PublishSubject`，因此它们将接收到无限的双随机数。有一个`flatMap`操作来给数字加`10`。记住，你做的每一件事都需要在可观察对象中完成。所以当你用`flatMap`进行转换时，你总是需要返回一个可观察对象。
- en: Finally, we apply the filter function to get only even numbers on the `Even`
    observable and only odd numbers on the `Odd` observable. All this happens in parallel.
    `Even` and `Odd` observables do not wait for each other.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`Even`可观察对象上应用过滤函数以获取偶数，在`Odd`可观察对象上获取奇数。所有这些都在并行发生。`Even`和`Odd`可观察对象不会互相等待。
- en: The next step is to merge both observables. We create a third observable that
    starts empty and then merges the infinite doubles from the `Even` observable with
    the infinite doubles from the `Odd` observable. Now is the time to limit the computation
    to only 10 numbers. We don't know how many odd or how many even numbers will be
    there because of Async. If you wish to control the number of odds and evens, you
    need to apply the `take` function on each observable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将两个可观察量合并。我们创建一个空的第三个可观察量，然后将来自`Even`可观察量的无限双数与来自`Odd`可观察量的无限双数合并。现在是将计算限制在只有10个数字的时候了。由于异步操作，我们不知道会有多少奇数或偶数。如果你希望控制奇数和偶数的数量，你需要在每个可观察量上应用`take`函数。
- en: Finally, we apply `foldLeft` to sum all the numbers and get a total. However,
    when we do that, we get only 90% of the numbers. This last observable is what
    is returned to the controller. Nothing is blocked here, and it's all Async and
    reactive.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应用`foldLeft`来求和所有数字并得到总数。然而，当我们这样做时，我们只得到了90%的数字。这个最后的可观察量是返回给控制器的。这里没有任何阻塞，一切都是异步和反应式的。
- en: 'You maybe wondering why `Stream.Continuously` generates different values all
    the time. That happens because we use a Call-by-Name function in Scala. We import
    the `nextDouble` function, and pass a function instead of the value of the function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么`Stream.Continuously`总是生成不同的值。这是因为我们在Scala中使用了一个按名调用（Call-by-Name）函数。我们导入了`nextDouble`函数，并传递一个函数而不是函数的值：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We need to register this service in Guice in `Module.scala` located in the default
    package at `ReactiveWebStore/app`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`Module.scala`中注册这个服务，`Module.scala`位于`ReactiveWebStore/app`默认包中。
- en: Guice Injection - Module.scala
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Guice 注入 - Module.scala
- en: 'Your `Module.scala` file should look something like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`Module.scala`文件应该看起来像这样：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In order to compile and run the preceding code, we need to add an extra SBT
    dependency. Open `build.sbt`, and add RxScala. We will also add another dependency,
    which is ws, a play library to make web service calls. We will use it later in
    this chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译和运行前面的代码，我们需要添加一个额外的SBT依赖项。打开`build.sbt`，并添加RxScala。我们还将添加另一个依赖项，即ws，这是一个用于进行Web服务调用的Play库。我们将在本章的后面使用它。
- en: 'Your `build.sbt` should look something like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`build.sbt`应该看起来像这样：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now we can compile and run this code using `activator run`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`activator run`编译并运行这段代码。
- en: We can call this new route now using a CURL call. If you prefer, you can just
    open your browser and do it there.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用CURL调用调用这个新的路由。如果你愿意，你也可以直接在浏览器中完成。
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will see the following result:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下结果：
- en: '![Guice Injection - Module.scala](img/image00267.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Guice 注入 - Module.scala](img/image00267.jpeg)'
- en: Great! We have RxScala working with the Play framework. Now we will refactor
    our code to make it even more interesting. So we will create a microservice using
    the Play framework, and we will externalize this random number generator to the
    microservice.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们已经让RxScala与Play框架一起工作。现在，我们将重构我们的代码，使其更加有趣。所以我们将使用Play框架创建一个微服务，并将这个随机数生成器外部化到微服务中。
- en: 'We need to create a new Play framework application. We will pick the option
    number `6) play-scala` application template. Open your console, and then type
    the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的Play框架应用程序。我们将选择选项号`6) play-scala`应用程序模板。打开你的控制台，然后输入以下命令：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will see this result:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下结果：
- en: '![Guice Injection - Module.scala](img/image00268.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Guice 注入 - Module.scala](img/image00268.jpeg)'
- en: 'Let''s create the routes on `ng-microservice`. We won''t have any UI here,
    since this will be a microservice. We need to add a route at `ng-microservice/conf/routes`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`ng-microservice`上创建路由。这里不会有任何UI，因为这将是一个微服务。我们需要在`ng-microservice/conf/routes`中添加一个路由：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now let's define the controller. This is not a regular controller, because this
    one won't serve UI views. Instead, it will serve JSON to the microservice consumers.
    Here we will have just one consumer, which will be `ReactiveWebStore`. However,
    it is possible to have as many consumers as you wish such as other microservices
    or even mobile applications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义控制器。这不是一个常规控制器，因为这个控制器不会提供UI视图。相反，它将为微服务消费者提供JSON。这里我们只有一个消费者，它将是`ReactiveWebStore`。然而，你可以有任意多的消费者，比如其他微服务或甚至是移动应用程序。
- en: NGServiceEndpoint
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NGServiceEndpoint
- en: 'For this controller, we just have two routes. The routes are `double` and `doubles`.
    The first route returns a double from the service, and the second one returns
    a list of doubles generated in a batch. For the second method, we get a list of
    doubles and transform that list in JSON using the Play framework utility library
    called `Json`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个控制器，我们只有两个路由。这些路由是`double`和`doubles`。第一个路由从服务返回一个双精度浮点数，第二个路由返回一个批量生成的双精度浮点数的列表。对于第二个方法，我们获取一个双精度浮点数的列表，并使用Play框架的实用库`Json`将这个列表转换为JSON格式：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The next step is create `trait` for the microservice. This trait is also the
    service contract in **Service Oriented Architecture** (**SOA**) terms, that is,
    the capabilities that the microservice offers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为微服务创建`trait`。在**面向服务架构**（**SOA**）的术语中，这个`trait`也是服务合同，即微服务提供的功能。
- en: 'The `NGContract.scala` file should look something like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`NGContract.scala`文件应类似于以下内容：'
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s look at the Service implementation of this microservice:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个微服务的服务实现：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This service implementation does not have any RxScala code. However, it is very
    functional. We have two methods implemented here. The methods are `generateDouble`
    and `generateDoubleBatch`, which receive, through parameters, the number of doubles
    you want it to generate for you. For the first operation (`generateDouble`), we
    use `Stream.continually` to generate infinite random doubles, then we multiply
    these numbers by 1,000, and then take just 1 and return it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务实现没有使用任何RxScala代码。然而，它非常函数式。我们在这里实现了两个方法。这些方法是`generateDouble`和`generateDoubleBatch`，它们通过参数接收你希望它为你生成的双精度浮点数的数量。对于第一个操作（`generateDouble`），我们使用`Stream.continually`生成无限随机双精度浮点数，然后我们将这些数字乘以1,000，然后只取1并返回它。
- en: The second operation is very similar. However, we have to add some validations
    to make sure that the numbers of double are present. There are a couple of ways
    to do it. One way use the assert method in Scala. The second way is the pattern
    matcher, which is nice because we don't need to write an `if` statement.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个操作非常相似。然而，我们必须添加一些验证以确保双精度浮点数的数量存在。有几种方法可以做到这一点。一种方法是在Scala中使用assert方法。第二种方法是模式匹配器，它很棒，因为我们不需要编写`if`语句。
- en: This technique is very common in the Scala community. So we create an option
    that takes the number, and then we pattern-match it. If there is a number present,
    the case `Some` method will be triggered, otherwise, the case `None` will be called.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在Scala社区中非常常见。因此，我们创建了一个选项，它接受一个数字，然后进行模式匹配。如果有数字存在，将触发`Some`方法，否则将调用`None`。
- en: 'After these validations, we can use `Stream` to generate as many numbers as
    requested. Before we run the code, we need to define the Guice injections. This
    file is located in the default package at `ng-microservice/app/`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些验证后，我们可以使用`Stream`生成所需数量的数字。在我们运行代码之前，我们需要定义Guice注入。此文件位于默认包`ng-microservice/app/`中：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now its time to compile and run our microservice. Since we already have a play
    application called `ReactiveWebStore` running on `port 9000`, you will have trouble
    if you simply run the microservice. To fix this, we need to run it on a different
    port. Let''s use `9090` for the microservice. Open the console, and execute the
    command `$ activator` followed by `$ run 9090`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是编译并运行我们的微服务的时候了。由于我们已经在`9000`端口上运行了一个名为`ReactiveWebStore`的Play应用程序，如果你直接运行微服务，你会遇到麻烦。为了解决这个问题，我们需要在不同的端口上运行它。让我们为微服务使用`9090`端口。打开控制台，执行命令`$
    activator`后跟`$ run 9090`：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can test our microservice by calling the two operations that we have. So
    let's open the web browser and do it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用我们拥有的两个操作来测试我们的微服务。所以让我们打开网页浏览器并执行它。
- en: 'The double microservice call at `http://localhost:9090/double` looks as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`http://localhost:9090/double`的`double`微服务调用如下：
- en: '![NGServiceEndpoint](img/image00269.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![NGServiceEndpoint](img/image00269.jpeg)'
- en: 'Every time you call this operation, you''ll see a different random double number.
    Now we can try out the next operation: the one you pass for the number of doubles
    you want. This operation will return a list of doubles in the JSON format.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用此操作时，你都会看到一个不同的随机双精度浮点数。现在我们可以尝试下一个操作：传递给数字的数量。此操作将返回一个包含双精度浮点数的JSON格式的列表。
- en: 'The call for double in batches microservice at `http://localhost:9090/doubles/100`
    looks like the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`http://localhost:9090/doubles/100`的批量`double`微服务调用如下所示：
- en: '![NGServiceEndpoint](img/image00270.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![NGServiceEndpoint](img/image00270.jpeg)'
- en: It works! We have 100 doubles here. Now that we have a microservice working,
    we can go back to our `ReactiveWebStore` and change our RxScala code. We will
    create new controllers. We will also update the existing code for products to
    call our new code, and suggest a price for the user on the UI, all in a reactive
    manner. Keep in mind that you need to have `ng-microservice` running; otherwise,
    `ReactiveWebStore` won't be able to retrieve doubles.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 它工作了！这里有100个双精度浮点数。现在我们有一个微服务正在运行，我们可以回到我们的`ReactiveWebStore`并更改我们的RxScala代码。我们将创建新的控制器。我们还将更新现有代码以调用我们的新代码，并在UI上为用户建议价格，所有这些都在反应式方式下完成。请记住，你需要让`ng-microservice`运行；否则，`ReactiveWebStore`将无法检索双精度浮点数。
- en: Play framework and high CPU usage
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Play框架和高CPU使用率
- en: 'If you notice your CPU usage going higher than it should, do not worry; there
    is a fix for it. Actually, the issue is related to SBT. Just make sure that, when
    you run Activator, you pass the following parameter:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到你的CPU使用率高于应有的水平，不要担心；有一个修复方法。实际上，这个问题与SBT有关。只需确保在运行Activator时，你传递以下参数：
- en: '`$ activator -Dsbt.task.forcegc=false`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ activator -Dsbt.task.forcegc=false`。'
- en: 'Going back to `ReactiveWebStore`, let''s create new routes. Open `ReactiveWebStore/conf/routes`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`ReactiveWebStore`，让我们创建新的路由。打开`ReactiveWebStore/conf/routes`：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once we have the new routes, we need to create the new controller. This controller
    needs to be located with the other controllers at `ReactiveWebStore/app/controllers`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了新的路由，我们需要创建新的控制器。这个控制器需要与其他控制器一起位于`ReactiveWebStore/app/controllers`。
- en: RndDoubleGeneratorController
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RndDoubleGeneratorController
- en: 'The `RndDoubleGeneratorController` class file should look like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`RndDoubleGeneratorController`类文件应该看起来像这样：'
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All methods in the preceding controller call the service `IRndService`. All
    operations in `RndService` call `ng-microservice`. Here we have some flavors of
    operations, which will be covered in great detail next when we explore the service
    implementation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的控制器中，所有方法都调用服务`IRndService`。`RndService`中的所有操作都调用`ng-microservice`。这里有一些操作变体，我们将在探索服务实现时详细讨论。
- en: 'There are some interesting things here: for instance, for the second operation
    called `rndCall`, we see `Action.async` in use, which means our controller will
    return a Future, and this Future comes from the service. We also execute a `Map`
    to transform the result into an `Ok`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有趣的事情：例如，对于第二个操作`rndCall`，我们看到使用了`Action.async`，这意味着我们的控制器将返回一个Future，而这个Future来自服务。我们还执行了一个`Map`来将结果转换为`Ok`。
- en: The last operation called `rxScalaCallBatch` is the most interesting, and the
    one we will be using for our UI. However, you can use the other one if you wish,
    since they all return doubles, and that's good.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个名为`rxScalaCallBatch`的操作是最有趣的，也是我们将用于我们的UI的操作。然而，如果你愿意，你也可以使用其他的，因为它们都返回双精度浮点数，这是很好的。
- en: IRndService.scala - Scala trait
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IRndService.scala - Scala trait
- en: 'Let''s look at the service definition. First of all, we need to define a trait
    for the service that will define the operations we need:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看服务定义。首先，我们需要为服务定义一个特质，该特质将定义我们需要的操作：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: RndService.scala - RndService implementation
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RndService.scala - RndService实现
- en: 'Now we can move to the real service implementation. This needs to be located
    at `ReactiveWebStore/app/services`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以转向真正的服务实现了。这需要位于`ReactiveWebStore/app/services`：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In order to call our microservice (`ng-microservice`), we need to inject a special
    Play framework library called `ws`, a utility library to call web services. We
    inject it by adding the code (`ws:WSClient`) into the class definition.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调用我们的微服务（`ng-microservice`），我们需要注入一个特殊的Play框架库`ws`，这是一个用于调用Web服务的实用库。我们通过在类定义中添加代码（`ws:WSClient`）来注入它。
- en: When you call something with `ws`, it returns a Future. We need to have the
    Future executors in place. That's why the import `defaultContext` is very important,
    and you cannot skip it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`ws`调用某个东西时，它返回一个Future。我们需要有Future执行器。这就是为什么`defaultContext`的导入非常重要，你不能跳过它。
- en: For the method, as you can see, we next call our microservice at `http://localhost:9090/double`
    to get a single double. We map this result, and get the body of the result, which
    will be the double itself.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个方法，正如你所看到的，我们接下来调用我们的微服务`http://localhost:9090/double`以获取一个单独的双精度浮点数。我们映射这个结果，并获取结果的主体，这将是我们需要的双精度浮点数本身。
- en: For this method, we use `Await.result`, which will block and wait for the result.
    If the result is not back in five seconds, this code will fail.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个方法，我们使用`Await.result`，这将阻塞并等待结果。如果结果在五秒内没有返回，这段代码将失败。
- en: The second method called `call` does the same, but the main difference is that
    we are not blocking the service; instead, we are returning a Future to the controller.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法名为 `call`，它执行相同的操作，但主要区别是我们没有阻塞服务；相反，我们向控制器返回一个 Future。
- en: 'Finally, the last method called `rxScalaCall` does the same: it calls our microservice
    using the `ws` library. However, we return an observable. Observables are great
    because they can used as a Future.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一个方法名为 `rxScalaCall`，它执行相同的操作：使用 `ws` 库调用我们的微服务。然而，我们返回一个可观测对象。可观测对象很棒，因为它们可以用作
    Future。
- en: 'Now it is time to go check out the final operation and the most interesting
    one. For this same class, we need to add another method such as this one:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候检查最终操作和最有趣的操作了。对于这个相同的类，我们需要添加另一个方法，如下所示：
- en: 'The method `rxScalaCallBatch` in `RndService.scala` is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`RndService.scala` 中的 `rxScalaCallBatch` 方法如下：'
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So, first we create `PublishSubject` in order to be able to produce data for
    the observables. Then we make the `ws` call to our microservice. The main difference
    now is that we call the batches operation and order 10 doubles. This code happens
    in a future, so it is non-blocking.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先我们创建 `PublishSubject` 以便能够为可观测对象生成数据。然后我们调用微服务的 `ws` 方法。现在的主要区别是我们调用批处理操作并排序
    10 个双精度浮点数。这段代码发生在 Future 中，所以它是非阻塞的。
- en: We then use the `Map` function to transform the result. The `ng-microservice`
    function will return JSON, so we need to deserialize this JSON into Scala objects.
    Finally, we run a pattern matcher in the Future result. If the result is a success,
    it means everything is good. So, for each double, we publish into the observables
    using `PublishSubject`. If the service is down or we have a problem, we publish
    an error to the observables downstream.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用 `Map` 函数来转换结果。`ng-microservice` 函数将返回 JSON，因此我们需要将此 JSON 反序列化为 Scala
    对象。最后，我们在 Future 结果中运行模式匹配器。如果结果是成功的，这意味着一切正常。因此，对于每个双精度浮点数，我们使用 `PublishSubject`
    将其发布到可观测对象中。如果服务已关闭或我们遇到问题，我们将错误发布到下游的可观测对象中。
- en: 'Next we create three observables: one for odd numbers, one for even numbers,
    and a third one which will merge the other two and do extra computation. The way
    we did the conversion between Future and Observable is ideal, because it is non-blocking.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们创建三个可观测对象：一个用于奇数，一个用于偶数，第三个将合并前两个并执行额外的计算。我们在 Future 和可观测对象之间进行转换的方式是理想的，因为它是非阻塞的。
- en: Here we have code very similar to what we had before for the Rx controller.
    The main difference is that we have error handling, because `ng-microservice`
    might never return, as it may be down or just not working. So we need to start
    working with fallbacks. Good fallbacks are key to error handling for Reactive
    applications. Fallbacks should be sort of static; in other words, they should
    not fail at all.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有与之前 Rx 控制器相似的代码。主要区别是我们有错误处理，因为 `ng-microservice` 可能永远不会返回，因为它可能已经关闭或根本不起作用。因此，我们需要开始使用回退。良好的回退对于反应式应用程序的错误处理至关重要。回退应该是某种静态的；换句话说，它们不应该失败。
- en: 'We provided two fallback methods: one for the `Odd` Observable and the other
    for the `Even` Observable. These fallbacks are done by setting the method `OnErrorReturn`.
    So for the even one, the fallback is static and the value is 2, and for the odd
    one the value is 1\. This is great, because even with failure our application
    continues to work.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了两种回退方法：一个用于 `Odd` 可观测对象，另一个用于 `Even` 可观测对象。这些回退是通过设置 `OnErrorReturn` 方法完成的。所以对于偶数，回退是静态的，值为
    2，而对于奇数，值为 1。这很好，因为即使出现故障，我们的应用程序仍然可以继续工作。
- en: You might realize we are not using the take function this time. So will this
    code run forever? No, because `ng-microservice` just returns 10 doubles. Finally,
    we merge the observables into a single observable, add all the numbers, get 90%
    of the value, and return an observable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会意识到这次我们没有使用 `take` 函数。那么这段代码会永远运行吗？不会的，因为 `ng-microservice` 只返回 10 个双精度浮点数。最后，我们将可观测对象合并成一个单一的可观测对象，将所有数字相加，获取值的
    90%，然后返回一个可观测对象。
- en: Module.scala - Guice Injections
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Module.scala - Guice 注入
- en: 'Now hook this new service in Guice. Let''s change the Guice `Module.scala`
    located at `ReactiveWebStore/apps/Module.scala`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将这个新服务连接到 Guice。让我们更改位于 `ReactiveWebStore/apps/Module.scala` 的 Guice `Module.scala`：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next we need to create a JQuery function in JavaScript to call our new controller.
    This function needs to be located at `ReactiveWebStore/public/javascripts`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要在 JavaScript 中创建一个 jQuery 函数来调用我们新的控制器。这个函数需要位于 `ReactiveWebStore/public/javascripts`。
- en: 'The following is `price.js`, the JQuery function that calls our controller:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是 `price.js`，这是一个调用我们控制器的 jQuery 函数：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We just have a single function called `loadPrice`, which receives a document.
    We use the `JQuery.get` method to call our controller, and parse the response,
    adding to the HTML text box called `price`. If something goes wrong, we alert
    the user that it was not possible to load a price.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有一个名为 `loadPrice` 的函数，它接收一个文档。我们使用 `JQuery.get` 方法调用我们的控制器，并解析响应，将其添加到名为
    `price` 的 HTML 文本框中。如果出现问题，我们会通过 alert 弹窗通知用户无法加载价格。
- en: main.scala.html
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: main.scala.html
- en: 'We need to change our `main.scala` code located at `ReactiveWebStore/app/views/main.scala.html`
    in order to import a new JavaScript function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改位于 `ReactiveWebStore/app/views/main.scala.html` 的 `main.scala` 代码，以便导入一个新的
    JavaScript 函数：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: product_details.scala.html
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: product_details.scala.html
- en: 'Finally, we need to change our product view in order to add a button to load
    the price from the controller. Let''s change the `product_details` view at `ReactiveWebStore/app/views/product_details.scala.html`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更改我们的产品视图，以便添加一个从控制器加载价格的按钮。让我们更改 `product_details` 视图，位于 `ReactiveWebStore/app/views/product_details.scala.html`：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Great! Now we have a button that loads the data from the controller using JQuery.
    You can realize that the button `Load Rnd Price` has an `onClick` property, which
    calls our JavaScript function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们有一个按钮，使用 JQuery 从控制器加载数据。你可以看到按钮 `Load Rnd Price` 有一个 `onClick` 属性，它调用我们的
    JavaScript 函数。
- en: Now you need to open your console and type `$ activator run` to compile and
    run the changes as we did to `ReactiveWebStore`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要打开你的控制台，并输入 `$ activator run` 来编译和运行更改，就像我们对 `ReactiveWebStore` 做的那样。
- en: 'This command will give the following result:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将产生以下结果：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So open you browser at `http://localhost:9000`, and go to the product page to
    see our need feature integrated and working like a charm. Keep in mind that you
    need to have `ng-microservice` working in another console window; otherwise, our
    application will use static fallbacks.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，打开你的浏览器到 `http://localhost:9000`，并转到产品页面以查看我们的需求功能集成并完美运行。请记住，你需要在一个另一个控制台窗口中让
    `ng-microservice` 运行；否则，我们的应用程序将使用静态回退。
- en: 'The new product feature will be shown at `http://localhost:9000/product/add`
    as seen in the following screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 新的产品功能将在 `http://localhost:9000/product/add` 上显示，如下面的截图所示：
- en: '![product_details.scala.html](img/image00271.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![product_details.scala.html](img/image00271.jpeg)'
- en: 'So if you click on the **Load Rnd Price** button, you will see something like
    this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你点击 **Load Rnd Price** 按钮，你会看到类似以下的内容：
- en: '![product_details.scala.html](img/image00272.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![product_details.scala.html](img/image00272.jpeg)'
- en: 'If you take a look at the application log in the activator console, you will
    see something similar to this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 activator 控制台中的应用程序日志，你会看到类似以下的内容：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Alright, that's it. We have everything working!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就完成了。一切都在运行中！
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the core principles of reactive application guided
    by the Reactive Manifesto. You also learned how to create reactive applications
    using RxScala. We then explained how to call other internal and external web services
    using the ws library. Then you learned to serialize and deserialize JSON using
    the `Json` Library. Moving on, you learned how to create simple microservices
    using the Play framework support.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了由 Reactive Manifesto 引导的响应式应用程序的核心原则。你还学习了如何使用 RxScala 创建响应式应用程序。然后我们解释了如何使用
    ws 库调用其他内部和外部 Web 服务。然后你学习了如何使用 `Json` 库序列化和反序列化 JSON。继续前进，你学习了如何使用 Play 框架支持创建简单的微服务。
- en: In the next chapter, we will continue building our application, and learn how
    to test our application with JUnit and ScalaTest.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续构建我们的应用程序，并学习如何使用 JUnit 和 ScalaTest 测试我们的应用程序。
