- en: Presentation Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 呈现模式
- en: 'In this chapter, we''ll cover each topic by explaining the concept and showing
    examples of implementations. After reading this chapter, you will know about these
    concepts and will be able to implement them using Java EE 8\. Here are the topics
    that are covered in upcoming sections:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过解释概念并展示实现示例来涵盖每个主题。阅读本章后，您将了解这些概念，并能够使用Java EE 8来实现它们。以下是即将在后续章节中涵盖的主题：
- en: Explaining the presentation tier
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释呈现层
- en: Explaining the intercepting filter pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释拦截器过滤模式
- en: Implementing the intercepting filter pattern using Java EE 8
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java EE 8实现拦截器过滤模式
- en: Explaining the front controller pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释前端控制器模式
- en: Implementing the front controller pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现前端控制器模式
- en: Explaining the application controller pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释应用控制器模式
- en: Implementing the application controller pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现应用控制器模式
- en: Explaining the presentation tier
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释呈现层
- en: The Java EE platform is a distributed multitiered application model that has
    three widely used common tiers. These tiers are the presentation tier (or web
    tier), the business tier, and the integration tier (or EIS tier).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE平台是一个分布式多层应用模型，有三个广泛使用的通用层。这些层是呈现层（或Web层）、业务层和集成层（或EIS层）。
- en: 'The presentation tier, also known as the web tier, contains the components
    that create a web application. This tier has many components that use the HTTP
    protocol, construct views and interfaces for users, and provide a web service.
    These components are called web components. There are two types of presentation
    tier:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 呈现层，也称为Web层，包含创建Web应用的组件。这一层有许多使用HTTP协议、构建用户视图和界面以及提供Web服务的组件。这些组件被称为Web组件。呈现层有两种类型：
- en: '**Presentation-oriented tier**: This type of presentation tier contains the
    components to construct an interactive web page and dynamic content using HTML
    and XHTML. These components are JavaServer Faces technology, Java Servlet technology,
    and JavaServer Page technology, which allow us to construct an interactive web
    page.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向呈现的层**：这种类型的呈现层包含使用HTML和XHTML构建交互式网页和动态内容的组件。这些组件是JavaServer Faces技术、Java
    Servlet技术和JavaServer Page技术，它们允许我们构建交互式网页。'
- en: '**Server-oriented tier**: This contains the components to construct an endpoint
    of a web service. These components are JAX-RS and JAX-WS.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向服务的层**：这一层包含构建Web服务端点的组件。这些组件是JAX-RS和JAX-WS。'
- en: 'The presentation-oriented tier is generally used on web applications using
    component-based specifications such as **JavaServer Face**s technology, or web
    applications using action-based Java Servlet technology as well as **JavaServer
    Pages** technology. The server-oriented tier is generally used on web applications
    that create a REST API or web service that is consumed by the client running on
    a mobile platform or browser. In the following diagram, we can see how the presentation
    tier works:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 呈现层通常用于使用基于组件的规范，如**JavaServer Faces**技术，或者使用基于动作的Java Servlet技术和**JavaServer
    Pages**技术的Web应用。面向服务的层通常用于创建REST API或Web服务，这些服务由运行在移动平台或浏览器上的客户端消费。在下面的图中，我们可以看到呈现层是如何工作的：
- en: '![](img/aeb967fa-baf8-48e7-98f6-19fece1ff59c.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aeb967fa-baf8-48e7-98f6-19fece1ff59c.png)'
- en: As shown in the preceding diagram, the **Client** sends a **Request** to the
    server; the **Presentation Tier** processes the request and sends it to the **Business
    Tier**; the **Business Tier** then sends a response to the **Presentation Tier** if
    the request is not asynchronous, and finally the **Presentation Tier** processes
    and sends the response to the **Client**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，**客户端**向服务器发送**请求**；**呈现层**处理请求并将其发送到**业务层**；如果请求不是异步的，**业务层**随后向**呈现层**发送响应，最后**呈现层**处理并发送响应到**客户端**。
- en: Because the **Presentation Tier** is responsible for promoting HTTP communications
    and connections with external users, this tier fulfills many interactions and
    communications between web components. Numerous tasks need to be performed for
    this to work well. These tasks include validating the data sent by a client, formatting
    it, sending it to the correct business component or class, and filtering the data
    and requests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**呈现层**负责促进与外部用户的HTTP通信和连接，因此这一层满足了Web组件之间的许多交互和通信。为了使这些工作良好，需要执行许多任务。这些任务包括验证客户端发送的数据、格式化它、将其发送到正确的业务组件或类，以及过滤数据和请求。
- en: Explaining intercepting filter pattern
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释拦截过滤器模式
- en: 'When a client sends a request to the server, the server sometimes processes
    this request/response to perform the following tasks:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端向服务器发送请求时，服务器有时会处理这个请求/响应以执行以下任务：
- en: Validating authentication
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证认证
- en: Generating log
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成日志
- en: Validating constraints
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证约束
- en: Verifying the browser of the client
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证客户端的浏览器
- en: Checking the duration between the request and response; calculating the response
    time
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查请求和响应之间的持续时间；计算响应时间
- en: Setting a cookie
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置cookie
- en: However, we don't want to put these tasks within the logic of processing the
    main request. Consequently, creating a pre-process and/or post-process to do these
    tasks is a good method for decoupling the main logic from the complementary logic.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不想将这些任务放在处理主要请求的逻辑中。因此，创建一个预处理和/或后处理来执行这些任务是解耦主要逻辑和补充逻辑的好方法。
- en: 'The intercepting filter pattern is the pattern that solves problems when we
    want to insert a logic that is not part of the main logic but we want to keep
    the two logics separated and decoupled. Merging the new logic with the main logic
    is a bad practice because these become coupled. This pattern creates a filter
    to pre-process and post-process the request, permitting the creation of a logic
    block to solve some problems that are not part of the main problem, and thus decoupling
    both pieces of logic. Using this pattern, we can create a pluggable solution without
    modifying the main logic. Take a look at the model of the intercepting filter
    pattern in the following diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截过滤器模式是在我们想要插入不是主要逻辑一部分的逻辑但希望保持两种逻辑分离和松耦合时解决的问题的模式。将新逻辑与主要逻辑合并是一种不良实践，因为这些会变得耦合。此模式创建一个过滤器来预处理和后处理请求，允许创建一个逻辑块来解决不是主要问题的某些问题，从而解耦这两部分逻辑。使用此模式，我们可以创建一个可插入的解决方案，而无需修改主要逻辑。请查看以下图中拦截过滤器模式的模型：
- en: '![](img/a97fc373-2329-4de7-b919-f73cd0e92d23.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a97fc373-2329-4de7-b919-f73cd0e92d23.png)'
- en: In the preceding diagram, we have a **Client**, **FilterManager**, **FilterChain**,
    **FilterOne**, **FilterTwo**, **FilterThree**, and **Target**. The client sends
    a request to the server; the FilterManager creates a **FilterChain** with its
    filters ordered and initiates the processing; the **FilterChain** is an ordered
    collection of independent filters; **FilterOne**, **FilterTwo**, and **FilterThree**
    are the filters in the **FilterChain**, which can include N filters; Target is
    the resource that contains the main logic. The order of filter execution is important
    because some filters often need to be executed first. An example of filter priority
    is the task of validating authentication, which generally needs to be executed
    first because some tasks are executed after client authentication only.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们有**客户端**、**FilterManager**、**FilterChain**、**FilterOne**、**FilterTwo**、**FilterThree**和**目标**。客户端向服务器发送请求；FilterManager创建一个按顺序排列的**FilterChain**并启动处理；**FilterChain**是有序的独立过滤器集合；**FilterOne**、**FilterTwo**和**FilterThree**是**FilterChain**中的过滤器，可以包括N个过滤器；目标是包含主要逻辑的资源。过滤器执行的顺序很重要，因为某些过滤器通常需要首先执行。过滤器优先级的一个例子是验证认证的任务，这通常需要首先执行，因为一些任务仅在客户端认证之后执行。
- en: Implementing the intercepting filter pattern using Java EE 8
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java EE 8实现拦截过滤器模式
- en: To implement this pattern with the best practices of Java EE 8, we will use
    the servlet filter from the Java Servlet specification. With the servlet filter,
    we can create an ordered request interceptor to treat the requests and responses.
    These interceptors are mapped by the URL pattern or servlet name. The servlet
    filter can be configured with XML (on `web.xml`) or annotation. In our case, we
    will imagine that we want to create a log of all the requests that are sent to
    the server. We will also have two filters—one to log the access time and another
    to log the information about the browser that the client is using. To log the
    access time, we will create a filter called `LogAccessFilter`, and to log the
    browser information we will create a filter called `LogBrowserFilter`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Java EE 8的最佳实践来实现此模式，我们将使用Java Servlet规范中的servlet过滤器。通过servlet过滤器，我们可以创建一个有序的请求拦截器来处理请求和响应。这些拦截器通过URL模式或servlet名称进行映射。servlet过滤器可以通过XML（在`web.xml`中）或注解进行配置。在我们的案例中，我们将假设我们想要创建一个记录所有发送到服务器的请求的日志。我们还将有两个过滤器——一个用于记录访问时间，另一个用于记录客户端使用的浏览器信息。为了记录访问时间，我们将创建一个名为`LogAccessFilter`的过滤器，为了记录浏览器信息，我们将创建一个名为`LogBrowserFilter`的过滤器。
- en: Implementing LogAccessFilter
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现LogAccessFilter
- en: 'Here, we have the implementation of `LogAccessFilter`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有`LogAccessFilter`的实现：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we can see in the code, to create one servlet filter, we need to create
    a class that extends `javax.servlet.Filter` and puts the `@WebFilter` annotation with
    `filterName` and `urlPatterns` parameters, which define the filter name and the
    URLs to filter, before the definition of class. The following is a snippet of
    code that demonstrates how to do that:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，要创建一个servlet过滤器，我们需要创建一个继承自`javax.servlet.Filter`的类，并在类定义之前使用带有`filterName`和`urlPatterns`参数的`@WebFilter`注解，这些参数定义了过滤器名称和要过滤的URL。以下是一个演示如何做到这一点的代码片段：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that the servlet filter uses the chain of responsibility pattern to walk
    throughout the filters (objects that are servlet filter). The following is a snippet of
    code that uses a chain of responsibility pattern:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，servlet过滤器使用责任链模式遍历过滤器（servlet过滤器对象）。以下是一个使用责任链模式的代码片段：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding line of code, we established the filter name as `LogAccess`
    through the `filterName` parameter. This will filter all requests, because the `urlPatterns` parameter
    has the `"/*"` value. If we filter according to servlet name, we need to use the
    following annotation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，我们通过`filterName`参数将过滤器名称设置为`LogAccess`。这将过滤所有请求，因为`urlPatterns`参数的值是`"/*"`。如果我们根据servlet名称进行过滤，我们需要使用以下注解：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `doFilter` method is responsible for pre-processing and post-processing
    and establishes when to follow the request to the next filter or servlet (main
    logic). To follow the request to the next filter or servlet, the following code
    needs be executed:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`doFilter`方法负责预处理和后处理，并确定何时将请求传递给下一个过滤器或servlet（主逻辑）。要传递请求到下一个过滤器或servlet，需要执行以下代码：'
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When the preceding code is executed, the current filter executes only the next
    line when the other filters and servlets finish their processing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当前面的代码执行时，当前过滤器只有在其他过滤器和servlet完成其处理之后才会执行下一行。
- en: Implementing LogBrowserFilter
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现LogBrowserFilter
- en: 'The implementation of `LogBrowserFilter` is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogBrowserFilter`的实现如下：'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding filter, we get the client IP and browser information and log
    them. The `LogBrowserFilter` operation is similar to that of `LogAccessFilter`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的过滤器中，我们获取客户端IP和浏览器信息并将它们记录下来。`LogBrowserFilter`的操作与`LogAccessFilter`类似。
- en: 'To define the order of filter execution, we need to configure the `web.xml`
    and add the filter mapping information. Here, we can see `web.xml` with its configuration:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义过滤器执行的顺序，我们需要配置`web.xml`并添加过滤器映射信息。在这里，我们可以看到`web.xml`及其配置：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The configurations defined in `web.xml` override the annotation configurations.
    Thus, if we put the `urlPattern` configuration on `web.xml`, then the configuration
    considered is `web.xml`'s configuration. We don't put the filter mapping information on `web.xml`
    because this is already on the annotation configuration in the code. The `web.xml` configuration
    defines the order—`LogBrowserFilter` will be called first, followed by `LogAccessFilter`,
    and then the main logic (servlet).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在`web.xml`中定义的配置会覆盖注解配置。因此，如果我们把`urlPattern`配置放在`web.xml`中，那么考虑的配置就是`web.xml`的配置。我们不需要在`web.xml`上放置过滤器映射信息，因为这在代码中的注解配置上已经存在了。`web.xml`配置定义了顺序——`LogBrowserFilter`将首先被调用，然后是`LogAccessFilter`，最后是主逻辑（servlet）。
- en: Deciding filter mapping
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定过滤器映射
- en: Defining the mapping method is crucial to implementing the intercepting filter
    pattern. This is because a bad method for mapping can impact the project directly and
    cause rework. We have two filter mapping types—`UrlPattern` and servlet name.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 定义映射方法是实现拦截过滤器模式的关键。这是因为不良的映射方法可能会直接影响项目并导致返工。我们有两种过滤器映射类型——`UrlPattern`和servlet名称。
- en: 'The use of `UrlPatterns` is indicated when we want to filter the HTTP Requests
    to non-specific resources or files, but we also want to filter various unknown resources. Here
    are some examples of this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要过滤HTTP请求到非特定资源或文件，但又想过滤各种未知资源时，会使用`UrlPatterns`。以下是一些示例：
- en: '`*.jsp`: This filters all requests to JSP pages. If one JSP page is added to
    the server, then the filter will filter the new JSP page without making any modifications.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*.jsp`：这个过滤器会过滤所有对JSP页面的请求。如果服务器上添加了一个JSP页面，那么过滤器将过滤新的JSP页面，而无需进行任何修改。'
- en: '`/*`: This filters all requests to all resources or files on the server. If
    one resource or file is added to the server, then the filter will filter this
    new resource or file without performing any modifications.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/*`: 这将过滤服务器上所有资源或文件的请求。如果服务器上添加了一个资源或文件，则过滤器将过滤此新资源或文件，而无需进行任何修改。'
- en: '`/user/*`: This filters all requests to all resources or files on the server
    that have a URI beginning with `/user`. If one resource or file that is accessed
    by a URI beginning with `/user` is added on servlet, then the filter will filter
    this new resource or file without performing any modifications.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/user/*`: 这将过滤以 `/user` 开头的URI的所有请求到服务器上的所有资源或文件。如果添加了一个以 `/user` 开头的URI访问的资源或文件到servlet，则过滤器将过滤此新资源或文件，而无需进行任何修改。'
- en: 'The servlet name used to map the filter indicates when you want to filter a
    specific servlet, independent of its `urlPattern`. This way of mapping allows
    us to modify one `urlPattern` of the mapped servlet without performing any modifications
    on the filter. Here are some examples:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 用于映射过滤器的servlet名称表示当您想要过滤特定servlet时，独立于其 `urlPattern`。这种映射方式允许我们修改映射servlet的一个
    `urlPattern`，而无需对过滤器进行任何修改。以下是一些示例：
- en: '`{servlet1}`: This only maps the servlet named as `servlet1`. If the `urlPatterns`
    of `servlet1` are modified, then the filter doesn''t need to be modified.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{servlet1}`: 这只映射名为 `servlet1` 的servlet。如果修改 `servlet1` 的 `urlPatterns`，则不需要修改过滤器。'
- en: '`{servlet1,servlet2}`: This maps two servlets named `servlet1` and `servlet2`.
    Its behavior is similar to the previous example shown, in which only one servlet
    was mapped.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{servlet1,servlet2}`: 这将两个名为 `servlet1` 和 `servlet2` 的servlet进行映射。其行为类似于前面展示的示例，其中只映射了一个servlet。'
- en: Explaining the FrontController pattern
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释FrontController模式
- en: In the Java EE world, we commonly work with complex projects that have similar
    functionalities and processes. Sometimes, using various controllers to handle
    a request is a bad practice because it needs to be configured at multiple endpoints and
    incurs a large cost of creation and maintenance. Consequently, creating a central
    point to treat a request is a very good solution, as it creates one point to manage
    all or a group of requests and then sends this request to the correct process.
    We can then treat all points that are common to all functionalities and send the
    request to a process to treat the questions that are not common to all but are
    specific to one functionality. Some configurations, such as session configuration, the
    maximum size limit of a request, cookie, and header, are common to all requests
    and can be configured from a central point.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java EE世界中，我们通常处理具有相似功能和流程的复杂项目。有时，使用各种控制器来处理请求是一种不良做法，因为它需要在多个端点进行配置，并产生大量创建和维护成本。因此，创建一个处理请求的中心点是一个非常好的解决方案，因为它创建了一个管理所有或一组请求的点，然后将此请求发送到正确的处理过程。然后我们可以处理所有对所有功能都通用的点，并将请求发送到处理特定于一个功能的问题的过程。一些配置，如会话配置、请求的最大大小限制、cookie和header，对所有请求都是通用的，并且可以从中央点进行配置。
- en: 'The `FrontController` pattern is a pattern that creates a central manager to
    treat all requests or a request group of an application and then sends the requests
    to one specific process, which is generally a command. This pattern is rarely
    used on common projects because today we have some ready-made solutions, and implementing
    this pattern is generally unnecessary. This pattern is used by frameworks such
    as JSF, Spring MVC, and struts. The following diagram depicts this pattern:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrontController` 模式是一种创建中央管理器来处理应用程序的所有请求或请求组的模式，然后将请求发送到特定的一个处理过程，这通常是一个命令。由于今天我们有现成的解决方案，因此这种模式在普通项目中很少使用，实现这种模式通常是不必要的。此模式被JSF、Spring
    MVC和struts等框架使用。以下图表展示了此模式：'
- en: '![](img/ff229c63-0c7a-40f5-93b2-40bd5ed7fa5c.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff229c63-0c7a-40f5-93b2-40bd5ed7fa5c.png)'
- en: In the preceding diagram, we have **FrontController**, **AbstractCommand**,
    **Command1**, and **Command2**. **FrontController** receives all requests, treats some
    common points of the request, and sends this request to the matching command.
    **AbstractCommand** is the `abstract` class of command. **Command1** and **Command2**
    are the subclasses of command, which implement its correspondent logic.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们有 **FrontController**、**AbstractCommand**、**Command1** 和 **Command2**。**FrontController**
    接收所有请求，处理请求的一些通用点，并将此请求发送到匹配的命令。**AbstractCommand** 是命令的 `abstract` 类。**Command1**
    和 **Command2** 是命令的子类，它们实现了相应的逻辑。
- en: In our case, we will have two pages—a homepage and a login page. If the user
    is logged in at the moment that a request is sent, then the application will launch
    the login page, and then the homepage.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将有两个页面——主页和登录页。如果用户在发送请求时已经登录，那么应用程序将启动登录页面，然后是主页。
- en: Implementing FrontController
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现前端控制器
- en: 'Here, we have an implementation of `MyAppController`, which is a `FrontController`
    to treat all the requests of an application:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`MyAppController`的实现，它是一个处理应用程序所有请求的前端控制器：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When we implement this pattern, it is very important to pay attention to the
    use of attributes on servlets, because all the class attributes on a servlet are
    shared with all threads or all requests.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现这个模式时，非常重要的是要注意servlet上的属性的使用，因为servlet上的所有类属性都与所有线程或所有请求共享。
- en: 'All `GET` requests or `POST` requests are sent to the `processRequest` method,
    which implements the logic to send the request to the respective command and executes
    the respective logic. After the correct command is set, the respective command
    is executed and the page is dispatched. Here, we have the line that executes the
    command and dispatches the request to the correct page:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`GET`请求或`POST`请求都发送到`processRequest`方法，该方法实现了将请求发送到相应命令并执行相应逻辑的逻辑。在设置正确的命令后，相应的命令被执行，页面被分发。在这里，我们有一条执行命令并将请求分发到正确页面的代码行：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Dispatching the request to the corresponding page:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将请求分发到相应的页面：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Implementing the commands
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现命令
- en: 'Here, we have `AbstractCommand`, which is an `abstract` class with one `execute` method.
    This is the `abstract` command, and the `execute` method is implemented on the
    subclasses:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`AbstractCommand`，它是一个包含一个`execute`方法的`abstract`类。这是抽象命令，`execute`方法在子类中实现：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we have the `LoginCommand` subclass, which is the implementation of `AbstractCommand`.
    The `execute()` method returns the path to the login page (`/login.jsp`):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`LoginCommand`子类，它是`AbstractCommand`的实现。`execute()`方法返回登录页面的路径（`/login.jsp`）：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The application controller pattern
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序控制器模式
- en: Some web applications have a complex logic for defining the correct view, content,
    or action to invoke. The MVC controller can be used to make this decision and
    get the correct view, content, or action. However, sometimes the logic to define
    a decision is very hard, and using the MVC controller to do this can cause duplication
    of a lot of code. To solve this, we need to centralize the logic at one point
    to permit an easy maintenance and a central logic point.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Web应用在定义正确的视图、内容或要调用的操作时具有复杂的逻辑。可以使用MVC控制器来做出这个决定并获取正确的视图、内容或操作。然而，有时定义决策的逻辑非常困难，使用MVC控制器来做这件事可能会导致大量代码的重复。为了解决这个问题，我们需要将逻辑集中在一个点上，以便于维护和集中逻辑点。
- en: 'The application controller pattern is the pattern that permits the centralization
    of all view logic and promotes a unique process to define the flow of pages. This
    pattern is used together with `FrontController`, discussed earlier, and is an
    intermediary between `FrontController` and `Command`. Using this pattern, we will
    promote the decoupling between view treatment and request treatment. The following
    diagram represents this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序控制器模式是一种允许集中所有视图逻辑并促进定义页面流程的唯一过程的模式。这种模式与前面讨论的`FrontController`一起使用，是`FrontController`和`Command`之间的中介。使用此模式，我们将促进视图处理和请求处理的解耦。以下图表表示了这一点：
- en: '![](img/639d81e1-6970-4ef2-878b-3f7ce96a3c2d.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/639d81e1-6970-4ef2-878b-3f7ce96a3c2d.png)'
- en: In the preceding diagram, we can see the **ApplicationController** between **FrontController**
    and **AbstractController**. When the client sends a request, the **FrontController**
    receives this and treats points about the request. The **FrontController** then
    sends this request to **ApplicationController**, which treats points about the
    view and flow and defines the correct **Command** to execute.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们可以看到位于**FrontController**和**AbstractController**之间的**ApplicationController**。当客户端发送请求时，**FrontController**接收这个请求并处理与请求相关的点。然后**FrontController**将这个请求发送到**ApplicationController**，它处理与视图和流程相关的点，并定义正确的**Command**来执行。
- en: In our example scenario, we want to create one point to download a file on our
    server, and this point can only be accessed by a logged-in user. As well as this,
    we will only accept PDF downloads and JPG files. In this example, we will create
    one class called `DownloadFrontController` to receive the request. We will also
    create a class called `DownloadApplicationController` to process the logic of
    view and content choice. `AbstractCommand` is the `abstract` class for commands.
    In addition to this, we will create `PdfCommand`, which is an implementation of
    `AbstractCommand` that processes the logic to download one PDF file. Finally,
    we will create `JpgCommand`, which is an implementation of `AbstractCommand` that
    processes the logic to download one JPG file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例场景中，我们希望在服务器上创建一个下载文件的点，并且这个点只能由登录用户访问。此外，我们只接受 PDF 下载和 JPG 文件。在这个例子中，我们将创建一个名为
    `DownloadFrontController` 的类来接收请求。我们还将创建一个名为 `DownloadApplicationController` 的类来处理视图和内容选择逻辑。`AbstractCommand`
    是命令的 `abstract` 类。此外，我们还将创建 `PdfCommand`，它是 `AbstractCommand` 的一个实现，用于处理下载单个 PDF
    文件的逻辑。最后，我们将创建 `JpgCommand`，它是 `AbstractCommand` 的一个实现，用于处理下载单个 JPG 文件的逻辑。
- en: Implementing DownloadFrontController
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 DownloadFrontController
- en: 'Here, we have the implementation of `DownloadFrontController`, which is a Servlet
    used to download files:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们实现了 `DownloadFrontController`，这是一个用于下载文件的 Servlet：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding block of code, we have the `DownloadFrontController` class with
    the logic to process a request. This class is a servlet that responds to all requests
    sent to `/download/*` using the following line of code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们有 `DownloadFrontController` 类，其中包含处理请求的逻辑。这个类是一个 servlet，它使用以下代码行响应对
    `/download/*` 发送的所有请求：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'All `GET` requests or `POST` requests are sent to the `processRequest` method,
    inside which we have the code to send the request to `DownloadApplicationController`.
    The following line of code does just that:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `GET` 请求或 `POST` 请求都发送到 `processRequest` 方法，其中包含将请求发送到 `DownloadApplicationController`
    的代码。以下代码行正是这样做的：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Implementing DownloadApplicationController
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 DownloadApplicationController
- en: 'Here, we have the implementation of `DownloadApplicationController`, which
    is responsible for deciding the correct command to send the request. The process
    for deciding the correct command can be carried out in several ways, with reflections
    and annotations, using switch cases and maps, among others. In our example, we
    use a map to help us:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们实现了 `DownloadApplicationController`，它负责决定发送请求的正确命令。决定正确命令的过程可以通过多种方式执行，包括反射和注解、使用
    switch 案例和映射等。在我们的例子中，我们使用映射来帮助我们：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A new instance of the command is then created using the `newInstance()` method :'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 `newInstance()` 方法创建命令的新实例：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The command is then executed, passing `request` and `response` as parameters:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行命令，传递 `request` 和 `response` 作为参数：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Implementing commands
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 commands
- en: 'Here, we have the `abstract` class `AbstractCommand`, which includes the abstract `execute` method.
    All implementations of this command extend `AbstractCommand`, which is an `abstract`
    class:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有 `abstract` 类 `AbstractCommand`，它包括抽象的 `execute` 方法。所有此命令的实现都扩展了 `AbstractCommand`，它是一个
    `abstract` 类：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the following block of code, we have the `PdfCommand` class. This is a subclass
    of `AbstractCommand` that implements the logic to download a PDF file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，我们有 `PdfCommand` 类。这是一个 `AbstractCommand` 的子类，实现了下载 PDF 文件的逻辑：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code block, we have the `execute()` method, which processes
    the logic to download a PDF file. At this point, all the processes and main validations of
    requests were executed, and the `execute()` method needs only to execute the download
    process.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们有 `execute()` 方法，该方法处理下载 PDF 文件的逻辑。在此阶段，所有请求的处理和主要验证都已经执行，`execute()`
    方法只需要执行下载过程。
- en: 'Here, we have the `JpgCommand` class, which is a subclass of `AbstractCommand`
    that implements the logic to download a JPG file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有 `JpgCommand` 类，它是一个 `AbstractCommand` 的子类，实现了下载 JPG 文件的逻辑：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code block, we have the `execute()` method, which processes
    the logic to download a JPG file. At this point, all request and main validation processes have
    already been done.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们有 `execute()` 方法，该方法处理下载 JPG 文件的逻辑。在此阶段，所有请求和主要验证过程都已经完成。
- en: The difference between the application controller and front controller patterns
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用控制器和前端控制器模式之间的区别
- en: The application controller and front controller patterns are quite similar and
    can create confusion for some users. The problem that the application controller
    pattern and front controller patterns solve are similar because both are used
    to centralize the logic at one point. As well as that, both work together using
    the design pattern command.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 应用控制器模式和前端控制器模式非常相似，可能会让一些用户感到困惑。应用控制器模式和前端控制器模式解决的问题相似，因为两者都用于在一点集中逻辑。此外，两者都使用设计模式命令协同工作。
- en: The main difference between the application controller and the front controller is
    that the application controller works to solve the complexity of view and flow
    page logic, and the front controller works to solve the complexity of the requests
    and the configurations of them. When the view and flow logic is simple, all logic
    is sometimes inserted into the front controller, and the application controller
    is not then used. However, when the logic within the view and flow page is complex,
    it is recommended to use the application controller in order to decouple the view
    and flow logic and organize the code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 应用控制器和前端控制器之间的主要区别在于，应用控制器旨在解决视图和页面流程逻辑的复杂性，而前端控制器旨在解决请求及其配置的复杂性。当视图和页面流程逻辑简单时，所有逻辑有时会插入到前端控制器中，而应用控制器则不再使用。然而，当视图和页面流程中的逻辑复杂时，建议使用应用控制器，以便解耦视图和页面流程逻辑并组织代码。
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the presentation tier and looked at the intercepting
    filter pattern, front controller patterns, and application controller pattern
    as well as how to implement them. In the real world, we rarely need to implement
    these patterns because some frameworks, APIs, and specifications already implement
    them for us. However, it is very important to know about these patterns in order
    to improve our understanding of the frameworks, APIs, and specifications that
    implement them. As well as this, we sometimes need to implement some components
    outside of the framework. Consequently, it is a good idea to use this pattern.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了表示层，并探讨了拦截过滤器模式、前端控制器模式和应用程序控制器模式，以及如何实现它们。在现实世界中，我们很少需要实现这些模式，因为一些框架、API和规范已经为我们实现了它们。然而，了解这些模式对于提高我们对实现这些模式的框架、API和规范的理解非常重要。此外，我们有时需要实现框架之外的某些组件。因此，使用这种模式是个好主意。
- en: The next chapter will address the business tier and its patterns. Here, we will
    cover the patterns that act on the business tier. Knowing about these patterns will
    complement our knowledge of the concepts and implementations of enterprise patterns
    as well as how these patterns promote the use of good tools to solve common problems
    in a business environment.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论业务层及其模式。在这里，我们将涵盖作用于业务层的模式。了解这些模式将补充我们对企业模式的概念和实现以及这些模式如何促进在业务环境中使用良好工具来解决常见问题的知识。
