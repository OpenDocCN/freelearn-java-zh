- en: Concurrent and Multithreaded Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发和多线程编程
- en: 'Concurrent programming has always been a difficult task. It might sound easy,
    but it is a source of many hard-to-solve problems. In this chapter, we will show
    you different ways of incorporating concurrency and some best practices, such
    as immutability, which will help in creating better, concurrent applications.
    We will also discuss the implementation of some commonly used patterns, such as
    divide-conquer and publish-subscribe, using the constructs provided by Java. We
    will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程一直是一项艰巨的任务。它可能听起来很简单，但它却是许多难以解决的问题的来源。在本章中，我们将向您展示不同的并发实现方式以及一些最佳实践，例如不可变性，这将有助于创建更好的并发应用程序。我们还将讨论使用Java提供的构造实现一些常用模式，例如分而治之和发布-订阅。我们将涵盖以下食谱：
- en: Using the basic element of concurrency - thread
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并发的基本元素——线程
- en: Different synchronization approaches
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的同步方法
- en: Immutability as a means to achieve concurrency
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性作为实现并发的手段
- en: Using concurrent collections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并发集合
- en: Using the executor service to execute async tasks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用执行器服务执行异步任务
- en: Using fork/join to implement divide-and-conquer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用fork/join实现分而治之
- en: Using flow to implement the publish-subscribe pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流实现发布-订阅模式
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Concurrency--the ability to execute several procedures in parallel--becomes
    increasingly important as big data analysis moves into the mainstream of modern
    applications. Having CPUs or several cores in one CPU helps increase the throughput,
    but the growth rate of data volume will always outpace hardware advances. Besides,
    even in a multiple CPU system, one still has to structure the code and think about
    resource sharing to take advantage of the available computational power.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 并发——并行执行多个程序的能力——随着大数据分析进入现代应用的主流，变得越来越重要。拥有CPU或一个CPU中的多个核心有助于提高吞吐量，但数据量的增长速度将始终超过硬件的进步。此外，即使在多CPU系统中，仍然需要结构化代码并考虑资源共享，以充分利用可用的计算能力。
- en: In the previous chapters, we demonstrated how lambdas with functional interfaces
    and parallel streams made concurrent processing a part of the toolkit of every
    Java programmer. One can easily take advantage of this functionality with minimal
    guidance, if at all.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们展示了如何使用具有函数式接口的lambda表达式和并行流将并发处理变成每个Java程序员工具箱的一部分。如果需要的话，人们可以很容易地利用这一功能，几乎不需要任何指导。
- en: In this chapter, we will describe some other--old (that existed before Java
    9) and new--Java features and APIs that allow more control over concurrency. The
    high-level concurrency Java API has been around since Java 5\. The JDK Enhancement
    Proposal (JEP) 266, *More Concurrency Updates,* introduced *an interoperable publish-subscribe
    framework, enhancements to the CompletableFuture API, and various other improvements* to
    Java 9 in the `java.util.concurrent` package. But before we dive into the details
    of the latest additions, let's review the basics of concurrent programming in
    Java and see how to use them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将描述一些其他——旧（在Java 9之前存在）和新——Java特性和API，它们允许对并发有更多的控制。高级并发Java API自Java
    5以来一直存在。JDK增强提案（JEP）266，“更多并发更新”，在`java.util.concurrent`包中引入了“一个可互操作的发布-订阅框架，CompletableFuture
    API的增强以及各种其他改进”。但在我们深入探讨最新添加的细节之前，让我们回顾一下Java并发编程的基本知识，并看看如何使用它们。
- en: 'Java has two units of execution: process and thread. A process usually represents
    the whole JVM, although an application can create another process using `ProcessBuilder`.
    But since the multiprocess case is outside the scope of this book, we will focus
    on the second unit of execution, that is, a thread, which is similar to a process
    but less isolated from other threads and requires fewer resources for execution.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Java有两种执行单元：进程和线程。进程通常代表整个JVM，尽管应用程序可以使用`ProcessBuilder`创建另一个进程。但由于多进程的情况超出了本书的范围，我们将专注于第二个执行单元，即线程，它类似于进程，但与其他线程的隔离性较低，并且执行所需的资源较少。
- en: A process can have many threads running and at least one thread called the main
    thread. Threads can share resources, including memory and open files, which allows
    better efficiency, but comes with a price of higher risk of unintended mutual
    interference and even blocking of the execution. This is where programming skills
    and an understanding of the concurrency technique are required. And this is what
    we are going to discuss in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程可以有多个线程运行，至少有一个称为主线程。线程可以共享资源，包括内存和打开的文件，这可以提高效率，但也会带来更高的风险，即意外的互斥干扰甚至执行阻塞。这就是需要编程技能和对并发技术的理解的地方。这也是本章将要讨论的内容。
- en: Using the basic element of concurrency - thread
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并发的基本元素——线程
- en: In this chapter, we will look at the `java.lang.Thread` class and see what it
    can do for concurrency and program performance in general.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨`java.lang.Thread`类，并了解它可以为并发性和程序性能带来什么。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: A Java application starts as the main thread (not counting system threads that
    support the process). It can then create other threads and let them run in parallel
    (sharing the same core via time slicing of having a dedicated CPU for each thread).
    This can be done using the `java.lang.Thread` class that implements the `Runnable`
    functional interface with only one `run()` method.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Java应用程序以主线程的形式启动（不包括支持进程的系统线程）。然后它可以创建其他线程，并让它们并行运行（通过时间切片共享同一核心，或者为每个线程分配一个专用的CPU）。这可以通过实现`Runnable`功能接口的`java.lang.Thread`类来完成，该接口只有一个`run()`方法。
- en: 'There are two ways of creating a new thread: creating a subclass of `Thread`
    or implementing the `Runnable` interface and passing the object of the implementing
    class to the `Thread` constructor. We can invoke the new thread by calling the
    `start()` method of the `Thread` class (which, in turn, calls the `run()` method
    that we implemented).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新线程有两种方式：创建`Thread`的子类或实现`Runnable`接口并将实现类的对象传递给`Thread`构造函数。我们可以通过调用`Thread`类的`start()`方法来启动新线程（它反过来调用我们实现的`run()`方法）。
- en: Then, we can either let the new thread run until its completion or pause it
    and let it continue again. We can also access its properties or intermediate results,
    if needed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以让新线程运行直到其完成，或者暂停它并再次让它继续。如果需要，我们还可以访问其属性或中间结果。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'First, we create a class called `AThread` that extends `Thread` and override
    its `run()` method:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`AThread`的类，它继承自`Thread`并重写其`run()`方法：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, we wanted the thread to generate a stream of integers in a
    certain range. Then, we peeked into each emitted integer (the method `peek()` cannot
    change the stream element) and called the static method `doSomething()` of the
    main class in order to make the thread busy for some time. Refer to the following
    code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们希望线程生成一定范围内的整数流。然后，我们检查每个发出的整数（方法`peek()`不能改变流元素）并调用主类的静态方法`doSomething()`，以便让线程忙碌一段时间。参考以下代码：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, this method generates another stream of integers in the range
    of `i` and `99999`, then converts the stream into a stream of doubles, calculates
    the square root of each of the stream elements, and finally calculates an average
    average of the stream. We discard the result and return the passed-in parameter
    (as a convenience that allows us to keep the fluent style in the stream pipe of
    the thread, which ends up printing out each element). Using this new class, we
    can now demonstrate the concurrent execution of the three threads:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此方法生成另一个范围在`i`和`99999`之间的整数流，然后将流转换为双流，计算流中每个元素的平方根，并最终计算流的平均平均值。我们丢弃结果并返回传入的参数（作为一个便利，允许我们在线程的流管道中保持流畅的样式，最终打印出每个元素）。使用这个新类，我们现在可以演示三个线程的并发执行：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first thread generates the integers `1`, `2`, and `3`, the second generates
    the integers `11`, `12`, and `13`, and the third thread (main one) generates `21`,
    `22`, and `23`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个线程生成整数`1`、`2`和`3`，第二个线程生成整数`11`、`12`和`13`，第三个线程（主线程）生成`21`、`22`和`23`。
- en: 'As mentioned before, we can rewrite the same program by creating and using
    a class that could implement the `Runnable` interface:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以通过创建和使用一个可以实现`Runnable`接口的类来重写相同的程序：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, you can run the same three threads like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以这样运行相同的三个线程：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also take advantage of `Runnable` being a functional interface and avoid
    creating an intermediate class by passing in a lambda expression instead:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以利用`Runnable`是一个函数式接口的优势，通过传递lambda表达式而不是创建中间类来避免创建中间类：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Which implementation is better depends on your goal and style. Implementing
    `Runnable` has an advantage (and in some cases, the only possible option) that
    it allows the implementation to extend from another class. It is particularly
    helpful when you would like to add thread-like behavior to an existing class.
    You can even invoke method `run()` directly, without passing the object to the
    `Thread` constructor.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个实现更好取决于你的目标和风格。实现`Runnable`有一个优点（在某些情况下，是唯一可能的选择），即它允许实现从另一个类扩展。当你想向现有类添加类似线程的行为时，这尤其有用。你甚至可以直接调用`run()`方法，而不需要将对象传递给`Thread`构造函数。
- en: 'Using a lambda expression wins over `Runnable` implementation when only method `run()` implementation
    is needed, no matter how big it is. If it is too big, you can have it isolated
    in a separate method:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当只需要`run()`方法的实现时，使用lambda表达式胜过`Runnable`实现，无论它有多大。如果它太大，你可以将它隔离在单独的方法中：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: One would be hard pressed to come up with a shorter implementation of the same
    functionality.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 很难想出一个更短的实现相同功能的方法。
- en: 'If we run any of the preceding versions, we will get something like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的任何版本，我们将会得到类似这样的结果：
- en: '![](img/a7d8b2a4-7c0d-453a-bfb6-e27ee4448308.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a7d8b2a4-7c0d-453a-bfb6-e27ee4448308.png)'
- en: As you can see, the three threads print out their numbers in parallel, but the
    sequence depends on the particular JVM implementation and underlying operating
    system. So, you will probably get different output. Besides, it also changes from
    run to run.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，三个线程并行打印出它们的数字，但顺序取决于特定的JVM实现和底层操作系统。因此，你可能会得到不同的输出。此外，它还会在每次运行时发生变化。
- en: 'The `Thread` class has several constructors that allow you to set the thread
    name and the group it belongs to. Grouping of threads helps manage them in case
    there are many threads running in parallel. The class also has several methods
    that provide information about the thread''s status and properties and allow you
    to control its behavior. Add these two lines to the preceding example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类有几个构造函数，允许你设置线程名称和它所属的组。线程分组有助于在并行运行多个线程时管理它们。该类还有几个方法，可以提供有关线程状态和属性的信息，并允许你控制其行为。将这两行添加到前面的示例中：'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You''ll get something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会得到类似这样的结果：
- en: '![](img/6bc78a6a-ddb4-4594-a619-de660561eb1c.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6bc78a6a-ddb4-4594-a619-de660561eb1c.png)'
- en: 'Next, say, you add names to the threads:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，比如，你给线程添加名称：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this case, the output will show the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出将显示以下内容：
- en: '![](img/f5d7fac4-bd4b-4ff9-bac0-95c654d2c7d4.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f5d7fac4-bd4b-4ff9-bac0-95c654d2c7d4.png)'
- en: 'The thread''s `id` is generated automatically and cannot be changed, but it
    can be reused after the thread is terminated. The thread name, on the other hand,
    can be shared by several threads. Priority can be set programmatically with a
    value between `Thread.MIN_PRIORITY` and `Thread.MAX_PRIORITY`. The smaller the
    value, the more time the thread is allowed to run (which means it has higher priority).
    If not set, priority value defaults to `Thread.NORM_PRIORITY`. The state of a
    thread can have one of the following values:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的`id`是自动生成的，不能更改，但在线程终止后可以重用。另一方面，线程名称可以被多个线程共享。可以通过在`Thread.MIN_PRIORITY`和`Thread.MAX_PRIORITY`之间设置值来程序化地设置优先级。值越小，线程被允许运行的时间越长（这意味着它有更高的优先级）。如果没有设置，优先级值默认为`Thread.NORM_PRIORITY`。线程的状态可以有以下之一：
- en: '`NEW`: When a thread has not yet started'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NEW`: 当一个线程尚未启动'
- en: '`RUNNABLE`: When a thread is being executed'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUNNABLE`: 当一个线程正在执行'
- en: '`BLOCKED`: When a thread is blocked and is waiting for a monitor lock'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BLOCKED`: 当一个线程被阻塞并正在等待监视器锁时'
- en: '`WAITING`: When a thread is waiting indefinitely for another thread to perform
    a particular action'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WAITING`: 当一个线程无限期地等待另一个线程执行特定操作时'
- en: '`TIMED_WAITING`: When a thread is waiting for another thread to perform an
    action for up to a specified waiting time'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMED_WAITING`: 当一个线程等待另一个线程执行操作，最长等待指定的时间'
- en: '`TERMINATED`: When a thread has exited'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TERMINATED`: 当一个线程已退出'
- en: We will talk about the `BLOCKED` and `WAITING` states in one of our recipes
    later.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的某个菜谱中讨论`BLOCKED`和`WAITING`状态。
- en: 'The `sleep()` method can be used to suspend the thread execution for a specified
    (in milliseconds) period of time. The complementary method `interrupt()` sends
    `InterruptedException` to the thread that can be used to wake up the *sleeping*
    thread. Let''s work this out in the code and create a new class:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleep()`方法可以用来暂停线程执行指定的时间（以毫秒为单位）。互补的方法`interrupt()`向线程发送`InterruptedException`，可以用来唤醒*睡眠*的线程。让我们在代码中实现这一点，并创建一个新的类：'
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code produces intermediate results, which are stored in the property
    `result`. Each time a new result is produced, the thread sleeps for one second.
    In this specific example, written for demonstration purposes only, the code does
    not do anything particularly useful.  It just iterates over a set of values and
    considers each of them a result. In a real-world code, you would do some calculations
    here based on the current state of the system or something and assign the calculated
    value to the property `result`. Now let''s use this class:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生中间结果，这些结果存储在`result`属性中。每次产生新的结果时，线程会暂停一秒钟。在这个仅用于演示的具体示例中，代码并没有做特别有用的事情。它只是迭代一组值，并将每个值视为一个结果。在实际代码中，您会根据系统的当前状态或其他东西进行一些计算，并将计算值分配给`result`属性。现在让我们使用这个类：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding program generates a stream of integers: 21, 22, ..., 28\. After
    each integer is generated, the main thread interrupts the `thr1` thread and lets
    it generate the next result, which is then accessed via the `getCurrentResult()`
    method and analyzed. If the current result is an even number, the filter allows
    the generated number flow to be printed out. If not, it is skipped. Here is a
    possible result:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序生成一系列整数：21, 22, ..., 28。在生成每个整数之后，主线程中断`thr1`线程，并让它生成下一个结果，然后通过`getCurrentResult()`方法访问并分析。如果当前结果是偶数，过滤器允许生成的数字流被打印出来。如果不是，则跳过。以下是一个可能的结果：
- en: '![](img/47552ae2-9a12-4c4a-88b4-e35729ad770c.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/47552ae2-9a12-4c4a-88b4-e35729ad770c.png)'
- en: 'It will be different if the program is run on different computers, but you
    get the idea: this way, one thread can control the output of another thread.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在不同的计算机上运行程序，结果可能会有所不同，但您应该明白：这样，一个线程可以控制另一个线程的输出。
- en: There's more...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are two other important methods that allow threads to cooperate. First
    is the `join()` method that allows the current thread to wait until another thread
    is terminated. Overloaded versions of `join()` accept the parameters that define
    how long the thread has to wait before it could do something else.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两种其他重要方法允许线程协作。首先是`join()`方法，它允许当前线程等待直到另一个线程终止。`join()`的重载版本接受定义线程等待多长时间才能做其他事情的参数。
- en: The `setDaemon()` method terminates the thread automatically after all the non-daemon
    threads are terminated. Usually, it is used for background and supporting processes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`setDaemon()`方法在所有非守护线程终止后自动终止线程。通常，它用于后台和支持进程。'
- en: See also
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes in this chapter:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中的以下食谱：
- en: Different synchronization approaches
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的同步方法
- en: Immutability as a means to achieve concurrency
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性作为实现并发的手段
- en: Using concurrent collections
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并发集合
- en: Using the executor service to execute async tasks
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用执行器服务执行异步任务
- en: Using fork/join to implement divide-and-conquer
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用fork/join实现分而治之
- en: Using flow to implement the publish-subscribe pattern
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流实现发布-订阅模式
- en: Different synchronization approaches
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的同步方法
- en: 'In this recipe, you will learn about the two most popular and basic methods
    of managing concurrent access to common resources in Java: a `synchronized` method
    and a `synchronized` block.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将了解Java中管理对公共资源并发访问最流行和基本的方法：一个`synchronized`方法和一个`synchronized`块。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Two or more threads modifying the same value while other threads reading it
    is the most general description of a problem of concurrent access. Subtler problems include
    *thread interference* and *memory consistency errors*, both producing unexpected
    results in seemingly benign fragments of code.  We are going to demonstrate such
    cases and ways to avoid them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 两个或更多线程修改相同的值，而其他线程正在读取它，这是并发访问问题最一般的描述。更微妙的问题包括*线程干扰*和*内存一致性错误*，两者都会在看似良性的代码片段中产生意外的结果。我们将演示这些情况以及避免它们的方法。
- en: 'At first glance, it seems quite straightforward: just allow only one thread
    at a time to modify/access the resource and that''s it. But if the access takes
    a long time, then it creates a bottleneck that might eliminate the advantage of
    having many threads working in parallel. Or, if one thread blocks access to one
    resource while waiting for access to another resource and the second thread blocks
    access to the second resource while waiting for access to the first one, then
    it creates a problem called a deadlock. These are two very simple examples of
    the possible challenges a programmer has to tackle while dealing with multiple
    threads.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，这似乎非常简单：只需允许一次只有一个线程修改/访问资源，就是这样。但如果访问需要很长时间，那么它就会创建一个瓶颈，可能会消除多个线程并行工作的优势。或者，如果一个线程在等待访问另一个资源时阻塞了对一个资源的访问，而第二个线程在等待访问第一个资源时阻塞了对第二个资源的访问，那么它就会创建一个称为死锁的问题。这些都是程序员在处理多个线程时必须应对的可能挑战的两个非常简单的例子。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we''ll check out a problem caused by concurrency. Let''s create a `Calculator`
    class that has the `calculate()`: method:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将检查由并发引起的问题。让我们创建一个具有`calculate()`方法的`Calculator`类：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This method assigns an input value to a property and then calculates its square
    root. We also inserted code that generates a stream of 10 values. We did this
    in order to keep the method busy for some time. Otherwise, everything is done
    so quickly that there will be little chance for any concurrency to occur. Also,
    we wanted the return value to be obviously the same all the time, so we did not
    complicate it by having calculations and made the method busy by an unrelated
    activity. Now we are going to use it in the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将输入值分配给一个属性，然后计算其平方根。我们还插入了一段生成10个值的代码。我们这样做是为了让方法忙碌一段时间。否则，一切完成得太快，几乎没有并发发生的可能性。此外，我们希望返回值始终明显相同，所以我们没有通过计算复杂化它，而是通过无关的活动使方法忙碌。现在我们将在以下代码中使用它：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Even for a novice, it will be obvious that two threads accessing the same object
    will have a good chance of stepping on each other's toes. As you can see, the
    `Random` interface implementation prints out the sum of the same three numbers,
    that is, 1, 2, and 3, after each one of them is processed by the `calculate()` method
    of the object of `Calculator`. Inside `calculate()`, each number is multiplied
    by two and then pushed through the square root extraction process. The operation
    is so simple that we can even calculate it by hand in advance. The result is going
    to be `5.863703305156273`. And again, to the first thread, we have added the `peek()`
    operator with 10 double-generating code to make it run a bit slower to give concurrency
    a better chance to happen. If you run these examples on your computer and do not
    see the effect of concurrency, try to increase the number of doubles by replacing
    `10` with `100`, for example.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对于一个新手来说，很明显，两个线程访问同一个对象有很大可能会相互干扰。正如你所看到的，`Random`接口实现打印出相同的三个数字之和，即1、2和3，在`Calculator`对象的`calculate()`方法处理每个数字之后。在`calculate()`内部，每个数字都乘以2，然后通过开方提取过程。这个操作非常简单，我们甚至可以提前手动计算出结果。结果将是`5.863703305156273`。再次，为了使第一个线程运行得慢一些，以便给并发更好的机会，我们在`peek()`操作符中添加了10个双精度生成代码。如果你在自己的电脑上运行这些示例而没有看到并发效果，尝试增加双精度数字的数量，例如将`10`替换为`100`。
- en: 'Now run the code. Here is one of the possible results:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行代码。这里是一个可能的结果：
- en: '![](img/1f97f474-3cce-45e2-ad94-0bf99e8a72b5.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1f97f474-3cce-45e2-ad94-0bf99e8a72b5.png)'
- en: One thread got the correct result, while the other did not. Apparently, in the
    period between setting the value of the `prop` property and then using it to return
    the result of the `calculate()` method, the other thread managed to assign its
    (smaller) value to `prop`. This is the case of thread interference.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一个线程得到了正确的结果，而另一个没有。显然，在设置`prop`属性的值和使用它来返回`calculate()`方法的结果之间，另一个线程设法将其（较小的）值分配给了`prop`。这是线程干扰的情况。
- en: 'There are two ways to protect code from such a problem: using a `synchronized`
    method or a `synchronized` block; these help include lines of code that are always
    executed as an atomic operation without any interference from another thread.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以保护代码免受此类问题的影响：使用`同步`方法或`同步`块；这些有助于包含始终作为原子操作执行且不受其他线程干扰的代码行。
- en: 'Making a `synchronized` method is easy and straightforward:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`同步`方法既简单又直接：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We just add the `synchronized` keyword in front of the method definition. Now,
    no matter how big a stream of doubles is generated, the result of our program
    is always going to be as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是在方法定义前添加了`synchronized`关键字。现在，无论生成的双精度流有多大，我们程序的结果始终如下：
- en: '![](img/abd436e8-31d5-4436-aea3-a1a1d0fff1b7.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/abd436e8-31d5-4436-aea3-a1a1d0fff1b7.png)'
- en: 'This is because another thread cannot enter the `synchronized` method until
    the current thread (the one that has entered the method already) has exited it.
    This approach may cause performance degradation if the method takes a long time
    to execute, so many threads might be blocked, waiting for their turn to use the
    method. In such cases, a `synchronized` block can be used to wrap several lines
    of code in an atomic operation:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为另一个线程无法进入`synchronized`方法，直到当前线程（已经进入方法的那个线程）退出它。如果该方法执行时间较长，这种方法可能会导致性能下降，因此许多线程可能会被阻塞，等待它们的轮次使用该方法。在这种情况下，可以使用`synchronized`块来包装几行代码，以执行原子操作：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Alternatively, you can do this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以这样做：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can do this because by studying the code, we have discovered that we can
    rearrange it such that the synchronized portion will be much smaller, thus having
    fewer chances to become a bottleneck.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样做是因为通过研究代码，我们发现我们可以重新排列它，使得同步部分将小得多，因此有更少的可能性成为瓶颈。
- en: 'A `synchronized` block acquires a lock on an object, any object for that matter.
    It could be, for example, a dedicated one:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`synchronized`块会锁定一个对象，任何对象都一样。例如，它可能是一个专用的对象：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The advantage of a dedicated lock is that you can be sure that such a lock will
    be used for accessing a particular block only. Otherwise, the current object (`this`)
    might be used to control access to another block; in a huge class, you might not
    notice this while writing your code. A lock can also be acquired from a class,
    which is even more susceptible to sharing for unrelated purposes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 专用锁的优势在于你可以确信这样的锁只会用于访问特定的块。否则，当前对象（`this`）可能会被用来控制对另一个块的访问；在一个庞大的类中，你可能不会在编写代码时注意到这一点。锁也可以从类中获取，这甚至更容易用于无关的共享目的。
- en: 'We did all these examples just for demonstrating synchronization approaches.
    If they were to be real code, we would just let each thread create its own `Calculator`
    object:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做所有这些例子只是为了演示同步方法。如果它们是真正的代码，我们就会让每个线程创建自己的`Calculator`对象：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This would be in line with the general idea of making lambda expressions independent
    of the context in which they are created. This is because in a multithreaded environment,
    one never knows how the context would look during their execution. The cost of
    creating a new object every time is negligible unless a large amount of data has
    to be processed, and testing ensures that the object creation overhead is noticeable.
    Making the `calculate()` method (and the property) static (which is tempting as
    it avoids object creation and preserves the fluent style) would not eliminate
    the concurrency problem because one shared (at the class level this time) value
    of the property would still remain in place.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将与使lambda表达式独立于它们创建的上下文的一般思想一致。这是因为在一个多线程环境中，在执行期间，没有人知道上下文会是什么样子。每次创建新对象的开销是可以忽略不计的，除非需要处理大量数据，并且测试确保对象创建的开销是可察觉的。将`calculate()`方法（和属性）设为静态（这很有吸引力，因为它避免了对象创建并保留了流畅的风格）并不能消除并发问题，因为属性的一个共享（这次是在类级别）值仍然会保留。
- en: Memory consistency errors can have many forms and causes in a multithreaded
    environment. They are well discussed in the Javadoc of the `java.util.concurrent` package.
    Here we will mention only the most common case caused by lack of visibility. When
    one thread changes a property value, the other might not see the change immediately,
    and you cannot use `synchronized` keyword for a primitive type. In such a situation,
    consider using the `volatile` keyword for such a property; it guarantees its read/write
    visibility between different threads.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程环境中，内存一致性错误可能具有多种形式和原因。它们在`java.util.concurrent`包的Javadoc中得到了很好的讨论。在这里，我们只提及由可见性不足引起的最常见情况。当一个线程更改属性值时，另一个线程可能不会立即看到这个变化，而且你不能为原始类型使用`synchronized`关键字。在这种情况下，考虑为这样的属性使用`volatile`关键字；它保证其在不同线程之间的读写可见性。
- en: There's more...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Different types of locks for different needs and with different behavior are
    assembled in the `java.util.concurrent.locks` package.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.locks`包中组装了不同类型和不同行为的锁，以满足不同的需求。'
- en: The `java.util.concurrent.atomic` package provides support for lock-free, thread-safe
    programming on single variables.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.atomic` 包为单变量上的无锁、线程安全编程提供了支持。'
- en: 'The following classes provide synchronization support too:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类也提供了同步支持：
- en: '`Semaphore`: This restricts the number of threads that can access some resource'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Semaphore`: 这限制了可以访问某些资源的线程数量'
- en: '`CountDownLatch`: This allows one or more threads to wait until a set of operations
    being performed in other threads are completed'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CountDownLatch`: 这允许一个或多个线程等待其他线程中正在执行的操作完成'
- en: '`CyclicBarrier`: This allows a set of threads to wait for each other to reach
    a common barrier point'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CyclicBarrier`: 这允许一组线程等待其他线程到达一个共同的屏障点'
- en: '`Phaser`: This provides a more flexible form of barrier that may be used to
    control phased computation among multiple threads'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Phaser`: 这提供了一种更灵活的屏障形式，可用于在多个线程之间控制分阶段计算'
- en: '`Exchanger`: This allows two threads to exchange objects at a rendezvous point
    and is useful in several pipeline designs'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchanger`: 这允许两个线程在 rendezvous 点交换对象，并在多个管道设计中非常有用'
- en: Each object in Java is inherited from the base object's `wait()`, `notify()`,
    and `notifyAll()` methods; these can also be used to control threads' behavior
    and their access to and release from locks.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的每个对象都继承自基对象的 `wait()`, `notify()`, 和 `notifyAll()` 方法；这些也可以用来控制线程的行为以及它们对锁的访问和释放。
- en: 'The `Collections` class has methods that make various collections synchronized.
    However, this means that only the modifications of the collection could become
    thread-safe, not the changes to the collection members. Also, while traversing
    the collection via its iterator, it has to be protected too because an iterator
    is not thread-safe. Here is a Javadoc example of the correct usage of a synchronized
    map:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections` 类有使各种集合同步的方法。然而，这意味着只有集合的修改可以成为线程安全的，而不是集合成员的更改。此外，在通过其迭代器遍历集合时，也需要保护，因为迭代器不是线程安全的。以下是一个同步映射的正确使用
    Javadoc 示例：'
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To add more to your plate as a programmer, you have to realize that the following
    code is not thread-safe:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了作为程序员增加你的负担，你必须意识到以下代码不是线程安全的：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is because although `List l` is synchronized, in multithreaded processing,
    it is quite possible that some other code would add more elements to the list
    (then the intended last does not reflect the reality) or remove an element (then
    the code fails with `IndexOutOfBoundException`).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为虽然 `List l` 是同步的，但在多线程处理中，完全有可能其他代码会向列表中添加更多元素（那么预期的最后一个元素就不会反映现实）或者移除一个元素（那么代码会因
    `IndexOutOfBoundException` 而失败）。
- en: The ones described here are a few of the most often encountered concurrency
    problems. These problems are not easy to solve. That is why it is not surprising
    that more and more developers now take a more radical approach. They avoid managing
    the state. Instead, they prefer writing non-blocking code for asynchronous and
    parallel processing data in a set of stateless operations. We saw similar code
    in the chapter about stream pipelines. It seems that Java and many modern languages
    and computer systems are evolving in this direction.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的是一些最常见的并发问题。这些问题并不容易解决。这就是为什么越来越多的开发者现在采取更激进的策略并不令人惊讶。他们避免管理状态。相反，他们更愿意编写非阻塞代码，以在一系列无状态操作中对异步和并行处理数据进行处理。我们在关于流管道的章节中看到了类似的代码。这似乎表明
    Java 和许多现代语言和计算机系统正在向这个方向发展。
- en: See also
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes in this chapter:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中的以下菜谱：
- en: Immutability as a means to achieve concurrency
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性作为实现并发的手段
- en: Using concurrent collections
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并发集合
- en: Using the executor service to execute async tasks
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用执行器服务执行异步任务
- en: Using fork/join to implement divide-and-conquer
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 fork/join 实现分而治之
- en: Using flow to implement the publish-subscribe pattern
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流程实现发布-订阅模式
- en: Immutability as a means to achieve concurrency
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性作为实现并发的手段
- en: In this recipe, you will learn how to use immutability against problems caused
    by concurrency.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何使用不可变性来对抗由并发引起的问题。
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: A concurrency problem most often occurs when different threads modify and read
    data from the same shared resource. Decreasing the number of modifying operations
    diminishes the risk of concurrency issues. This is where immutability--the condition
    of read-only values--enters the stage.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 并发问题最常发生在不同的线程修改和从同一共享资源读取数据时。减少修改操作的数量可以降低并发问题的风险。这就是不可变性——只读值条件——介入的阶段。
- en: Object immutability means an absence of means to change its state after the
    object has been created. It does not guarantee thread safety but helps to increase
    it significantly and provide sufficient protection from concurrency problems in
    many practical applications.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对象不可变性意味着在对象创建后没有改变其状态的手段。它不保证线程安全，但有助于显著提高线程安全并提供足够的保护，以防止许多实际应用中的并发问题。
- en: Creating a new object instead of reusing an existing one (by changing its state
    via setters and getters) is often perceived as an expensive approach. But with
    the power of modern computers, there has to be a huge number of object creations
    done for performance to be affected in any significant way. And even if that is
    the case, programmers often prefer some performance degradation as the price for
    getting more reliable results.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新对象而不是重用现有对象（通过setter和getter更改其状态）通常被认为是一种昂贵的做法。但是，随着现代计算机的强大，必须进行大量的对象创建，以便在性能上产生任何显著的影响。即使如此，程序员通常更愿意以牺牲一些性能为代价来获得更可靠的结果。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here is a very basic class that produces mutable objects:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个非常基本的类，它产生可变对象：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To make it immutable, we need to remove the setter and add the `final` keyword
    to its only property and the class itself:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其不可变，我们需要移除setter并添加`final`关键字到其唯一的属性和类本身：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Adding the `final` keyword to a class prevents it from being extended, so its
    methods cannot be overridden. Adding `final` to a private property is not as obvious.
    The motivation is somewhat complex and has to do with the way the compiler reorders
    the fields during object construction. If the field is declared `final`, it is
    treated by the compiler as synchronized. That is why adding `final` to a private property
    is necessary to make the object completely immutable.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将`final`关键字添加到类中可以防止其被扩展，因此其方法不能被重写。将`final`添加到私有属性并不那么明显。动机相对复杂，与编译器在对象构造期间重新排序字段的方式有关。如果字段被声明为`final`，编译器会将其视为同步的。这就是为什么将`final`添加到私有属性对于使对象完全不可变是必要的。
- en: 'The challenge mounts up if the class is composed of other classes, especially
    mutable ones. When this happens, the injected class might bring in code that would
    affect the containing class. Also, the inner (mutable) class, which is retrieved
    by references via the getter, could then be modified and propagate the change
    inside the containing class. The way to close such holes is to generate new objects
    during the composition of the object retrieval. Here is an example of this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类由其他类组成，特别是可变的类，那么挑战就会增加。当这种情况发生时，注入的类可能会引入会影响包含类的代码。此外，通过getter通过引用检索的内部（可变）类，然后可以被修改并在包含类内部传播更改。关闭这种漏洞的方法是在对象检索的组成期间生成新对象。以下是一个示例：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There's more...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In our examples, we used very simple code. If more complexity is added to any
    of the methods, especially with parameters (and especially when some of the parameters
    are objects), it is possible you''ll get concurrency issues again:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用了非常简单的代码。如果任何方法增加了更多的复杂性，特别是与参数（尤其是当一些参数是对象时）相关，那么你可能会再次遇到并发问题：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Even if this method belongs to `ImmutableClass` and does not affect the state
    of the `ImmutableClass` object, it is still a subject of the thread's race and
    has to be analyzed and protected as needed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这种方法属于`ImmutableClass`且不影响`ImmutableClass`对象的状态，它仍然是线程竞争的主题，需要根据需要进行分析和保护。
- en: The `Collections` class has methods that make various collections unmodifiable.
    It means that the modification of the collection itself becomes read only, not
    the collection members.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections`类有使各种集合不可变的方法。这意味着集合本身的修改变为只读，而不是集合成员。'
- en: See also
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes in this chapter:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中的以下食谱：
- en: Using concurrent collections
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并发集合
- en: Using the executor service to execute async tasks
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用执行器服务执行异步任务
- en: Using fork/join to implement divide-and-conquer
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用fork/join实现分而治之
- en: Using flow to implement the publish-subscribe pattern
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流来实现发布-订阅模式
- en: Using concurrent collections
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并发集合
- en: In this recipe, you will learn about the thread-safe collections of the `java.util.concurrent` package.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将了解`java.util.concurrent`包中的线程安全集合。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: A collection can be synchronized if you apply one of the `Collections.synchronizeXYZ()` methods
    to it; here, we have used XYZ as a placeholder that represents either `Set`, `List`,
    `Map`, or one of the several collection types (see the API of the `Collections`
    class). We have already mentioned that the synchronization applies to the collection
    itself, not to its iterator or the collection members.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对集合应用了`Collections.synchronizeXYZ()`方法之一，则该集合可以同步；在这里，我们使用XYZ作为占位符，代表`Set`、`List`、`Map`或`Collections`类中的几种集合类型（参见`Collections`类的API）。我们已经提到，同步应用于集合本身，而不是其迭代器或集合成员。
- en: Such synchronized collections are also called **wrappers** because all of the
    functionality is still provided by the collections passed as parameters to the `Collections.synchronizeXYZ()` methods,
    so the wrappers provide only thread-safe access to them. The same effect could
    be achieved by acquiring a lock on the original collection. Obviously, such a
    synchronization incurs a performance overhead in a multithreading environment causing
    each thread to wait for its turn to access the collection.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的同步集合也被称为**包装器**，因为所有功能仍然由传递给`Collections.synchronizeXYZ()`方法的集合提供，所以包装器只为它们提供线程安全的访问。通过在原始集合上获取锁也可以达到相同的效果。显然，这种同步在多线程环境中会带来性能开销，导致每个线程都要等待其轮到访问集合。
- en: A well-tuned application for performance implementation of thread-safe collections
    is provided by the `java.util.concurrent` package.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent`包提供了一个针对性能实现的线程安全集合的优秀应用。'
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Each of the concurrent collections of the `java.util.concurrent` package implements
    (or extends, if it is an interface) one of the four interfaces of the `java.util`
    package: `List`, `Set`, `Map`, or `Queue`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent`包中的每个并发集合都实现了`java.util`包中的四个接口之一（或扩展，如果它是接口）：`List`、`Set`、`Map`或`Queue`：'
- en: 'The `List` interface has only one implementation: the `CopyOnWriteArrayList` class.
    According to the Javadoc of this class, *all mutative operations (add, set, and
    so on) are implemented by making a fresh copy of the underlying array.... The
    "snapshot" style iterator method uses a reference to the state of the array at
    the point that the iterator was created. This array never changes during the lifetime
    of the iterator, so interference is impossible and the iterator is guaranteed
    not to throw ConcurrentModificationException. The iterator will not reflect additions,
    removals, or changes to the list since the iterator was created. Element-changing
    operations on iterators themselves (remove, set, and add) are not supported. These
    methods throw UnsupportedOperationException.* To demonstrate the behavior of the `CopyOnWriteArrayList` class,
    let''s compare it with `java.util.ArrayList` (which is not a thread-safe implementation
    of `List`). Here is the method that adds an element to the list while iterating
    on the same list:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`List`接口只有一个实现：`CopyOnWriteArrayList`类。根据该类的Javadoc，*所有可变操作（添加、设置等）都是通过创建底层数组的副本来实现的....“快照”风格的迭代器方法使用迭代器创建时的数组状态引用。这个数组在迭代器的整个生命周期中都不会改变，因此干扰是不可能的，迭代器保证不会抛出`ConcurrentModificationException`。迭代器不会反映自创建以来列表的添加、删除或更改。不支持迭代器本身的元素更改操作（删除、设置和添加）。这些方法会抛出`UnsupportedOperationException`。为了演示`CopyOnWriteArrayList`类的行为，让我们将其与`java.util.ArrayList`（它不是`List`的线程安全实现）进行比较。以下是向列表添加元素的同时迭代同一列表的方法：'
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Consider the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we execute this code, the result would be as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行这段代码，结果将如下所示：
- en: '![](img/9d3be92f-49be-46b4-82f2-572566dfa397.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9d3be92f-49be-46b4-82f2-572566dfa397.png)'
- en: As you can see, `ArrayList` throws `ConcurrentModificationException` when the
    list is modified while being iterated (we used the same thread for simplicity
    and because it leads to the same effect, as in the case of another thread modifying
    the list). The specification, though, does not guarantee that the exception will
    be thrown or the list modification applied (as in in our case), so a programmer
    should not base the application logic on such behavior. The `CopyOnWriteArrayList` class,
    on the other hand, tolerates the same intervention; however, notice that it does
    not add a new element to the current list because the iterator was created from
    a snapshot of the fresh copy of the underlying array.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`ArrayList`在遍历列表时修改列表会抛出`ConcurrentModificationException`（我们为了简单起见使用了相同的线程，并且因为它会导致相同的效果，就像另一个线程修改列表的情况一样）。然而，规范并不保证会抛出异常或应用列表修改（就像在我们的案例中一样），因此程序员不应将应用程序逻辑建立在这样的行为之上。另一方面，`CopyOnWriteArrayList`类容忍相同的干预；然而，请注意，它不会向当前列表添加新元素，因为迭代器是从底层数组的最新副本的快照中创建的。
- en: 'Now let''s try to remove a list element concurrently while traversing the list,
    using this method:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试在遍历列表的同时并发地删除列表元素，使用此方法：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Consider the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we execute this, we will get the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行此操作，我们将得到以下结果：
- en: '![](img/a6bf9320-f196-4fa3-b905-1b1d9e2c1608.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6bf9320-f196-4fa3-b905-1b1d9e2c1608.png)'
- en: The behavior is similar to the previous example. The `CopyOnWriteArrayList` class
    tolerates the concurrent access to the list but does not modify the current list's
    copy.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 其行为与上一个例子类似。`CopyOnWriteArrayList`类容忍对列表的并发访问，但不会修改当前列表的副本。
- en: 'We knew `ArrayList` would not be thread-safe for a long time, so we used a
    different technique to remove an element from the list while traversing it. Here
    is how this was done before the Java 8 release:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`ArrayList`在很长时间内都不会是线程安全的，所以我们使用不同的技术来在遍历列表时删除元素。以下是Java 8发布之前是如何做到这一点的：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s try this and run the code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试运行此代码：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The result will be as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/7617419e-7428-4f5d-a99c-784f45e87586.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7617419e-7428-4f5d-a99c-784f45e87586.png)'
- en: 'This is exactly what Javadoc warned about: "*Element-changing operations on
    iterators themselves (remove, set, and add) are not supported. These methods throw
    UnsupportedOperationException."* We should remember this when upgrading an application
    to make it work in a multithreaded environment: just changing from `ArrayList()`
    to `CopyOnWriteArrayList` would not be enough if we use an iterator to remove
    a list element.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是Javadoc所警告的：“*迭代器本身的元素更改操作（remove、set和add）是不支持的。这些方法会抛出UnsupportedOperationException。*
    我们在升级应用程序以使其在多线程环境中工作时应记住这一点：如果我们使用迭代器删除列表元素，仅仅从`ArrayList()`更改为`CopyOnWriteArrayList`是不够的。
- en: 'Since Java 8, we have a better way to remove an element from a collection using
    a lambda, which we can and should use from now on (leaving plumbing details to
    the library):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java 8以来，我们有了使用lambda从集合中删除元素的一种更好的方法，我们现在可以使用它（将管道细节留给库）：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So let''s do this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们这样做：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The result of the preceding code is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果如下：
- en: '![](img/6896d051-ab90-460b-a691-cb94a0459c97.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6896d051-ab90-460b-a691-cb94a0459c97.png)'
- en: It is short and has no problem with any of the collections and in line with
    the general trend of having a stateless parallel computation that uses streams
    with lambdas and functional interfaces.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 它很短，与任何集合都没有问题，并且符合使用带有lambda和函数式接口的无状态并行计算的一般趋势。
- en: 'Also, after we upgrade an application to use the `CopyOnWriteArrayList` class, we
    can take advantage of a simpler way of adding a new element to the list (without
    first checking whether it is already there):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在我们将应用程序升级到使用`CopyOnWriteArrayList`类之后，我们可以利用一种更简单的方法向列表中添加新元素（无需首先检查它是否已经存在）：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With `CopyOnWriteArrayList`, this can be done as an atomic operation, so one
    does not need to synchronize this block of code: if-not-present-then-add.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CopyOnWriteArrayList`，这可以作为一个原子操作来完成，因此不需要同步此代码块：if-not-present-then-add。
- en: Now let's review the concurrent collections of the `java.util.concurrent` package
    implementing the `Set` interface. There are three such implementations: `ConcurrentHashMap.KeySetView`,
    `CopyOnWriteArraySet` , and `ConcurrentSkipListSet`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们回顾实现`Set`接口的`java.util.concurrent`包中的并发集合。这里有三种这样的实现：`ConcurrentHashMap.KeySetView`、`CopyOnWriteArraySet`和`ConcurrentSkipListSet`。
- en: The first one is just a view of the keys of `ConcurrentHashMap`. It is backed
    up by `ConcurrentHashMap` (can be retrieved by the `getMap()` method). We will
    review the behavior of  `ConcurrentHashMap` later.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个只是一个 `ConcurrentHashMap` 的键的视图。它由 `ConcurrentHashMap` 支持（可以通过 `getMap()`
    方法检索）。我们将在稍后回顾 `ConcurrentHashMap` 的行为。
- en: The second implementation of `Set` in the `java.util.concurrent` package is
    the `CopyOnWriteArraySet` class. Its behavior is similar to the `CopyOnWriteArrayList` class.
    In fact, it uses the `CopyOnWriteArrayList` class's implementation under the hood.
    The only difference is that it does not allow duplicate elements in the collection.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent` 包中 `Set` 的第二个实现是 `CopyOnWriteArraySet` 类。其行为类似于 `CopyOnWriteArrayList`
    类。实际上，它底层使用的是 `CopyOnWriteArrayList` 类的实现。唯一的区别是它不允许集合中有重复的元素。'
- en: 'The third (and the last) implementation of `Set` in the `java.util.concurrent` package
    is `ConcurrentSkipListSet`; it implements a subinterface of `Set` called `NavigableSet`.
    According to the Javadoc of the `ConcurrentSkipListSet` class, insertion, removal,
    and access operations are safely executed concurrently by multiple threads*.* There
    are some limitations described in Javadoc too:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent` 包中 `Set` 的第三个（也是最后一个）实现是 `ConcurrentSkipListSet`；它实现了
    `Set` 的一个子接口，称为 `NavigableSet`。根据 `ConcurrentSkipListSet` 类的 Javadoc，插入、删除和访问操作可以由多个线程安全地并发执行。Javadoc
    中也描述了一些限制：'
- en: It does not permit the use of `null` elements.
  id: totrans-198
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不允许使用 `null` 元素。
- en: The size of the set is calculated dynamically by traversing the collection,
    so it may report inaccurate results if this collection is modified during the
    operation.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合的大小是通过遍历集合动态计算的，因此如果在操作期间修改此集合，可能会报告不准确的结果。
- en: The operations `addAll()`, `removeIf()`, or `forEach()` are not guaranteed to
    be performed atomically. The `forEach()` operation, if concurrent with an `addAll()`
    operation for example, *might observe only some of the added elements* (as stated
    in the Javadoc).
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作 `addAll()`、`removeIf()` 或 `forEach()` 不保证原子执行。例如，如果与 `addAll()` 操作并发，`forEach()`
    操作*可能只能观察到部分添加的元素*（如 Javadoc 中所述）。
- en: 'The implementation of class  `ConcurrentSkipListSet` is based on the `ConcurrentSkipListMap` class,
    which we will discuss shortly. To demonstrate the behavior of the `ConcurrentSkipListSet` class,
    let''s compare it with the `java.util.TreeSet` class (non-concurrent implementation
    of `NavigableSet`). We start with removing an element:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentSkipListSet` 类的实现基于我们稍后将讨论的 `ConcurrentSkipListMap` 类。为了演示 `ConcurrentSkipListSet`
    类的行为，让我们将其与 `java.util.TreeSet` 类（`NavigableSet` 的非并发实现）进行比较。我们首先尝试删除一个元素：'
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Of course, this code is not very efficient; we''ve removed the same element
    many times without checking its presence. We have done this just for demo purposes.
    Besides, since Java 8, the same method `removeIf()` works for `Set` just fine.
    But we would like to bring up the behavior of the new class `ConcurrentSkipListSet`, so
    let''s execute this code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这段代码效率不高；我们没有检查其存在就多次删除了相同的元素。我们这样做只是为了演示目的。此外，自从 Java 8 以来，相同的 `removeIf()`
    方法对 `Set` 也能正常工作。但我们要提出新类 `ConcurrentSkipListSet` 的行为，所以让我们执行以下代码：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output will be as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![](img/ce19ea45-db92-4768-807c-1da31f1a4669.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce19ea45-db92-4768-807c-1da31f1a4669.png)'
- en: 'As expected, the `ConcurrentSkipListSet` class handles the concurrency and
    even removes an element from the current set, which is helpful. It also removes
    an element via an iterator without an exception. Consider the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，`ConcurrentSkipListSet` 类处理并发，甚至可以从当前集合中删除元素，这很有帮助。它还通过迭代器删除元素而不抛出异常。考虑以下代码：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run this for `TreeSet` and  `ConcurrentSkipListSet`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `TreeSet` 和 `ConcurrentSkipListSet` 运行此操作：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We''ll not get any exception:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会得到任何异常：
- en: '![](img/1f1522f2-e50d-4343-9240-286bf57739fa.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f1522f2-e50d-4343-9240-286bf57739fa.png)'
- en: 'This is because, according to the Javadoc, the iterator of `ConcurrentSkipListSet`
    is weakly consistent, which means the following (according to Javadoc):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，根据 Javadoc，`ConcurrentSkipListSet` 的迭代器是弱一致的，这意味着以下（根据 Javadoc）：
- en: They may proceed concurrently with other operations
  id: totrans-214
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能与其他操作并发进行
- en: They will never throw `ConcurrentModificationException`
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们永远不会抛出 `ConcurrentModificationException`
- en: They are guaranteed to traverse elements as they existed upon construction exactly
    once, and may (but are not guaranteed to) reflect any modifications subsequent
    to construction (from Javadoc).
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们保证按构造时存在的元素顺序恰好遍历一次，并且可能（但不保证）反映构造之后（从 Javadoc 中）的任何修改。
- en: This not guaranteed part is somewhat disappointing, but it is better than getting
    an exception, like with `CopyOnWriteArrayList`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分并不保证，但比抛出异常要好，例如使用`CopyOnWriteArrayList`时。
- en: 'Adding to a `Set` class is not as problematic as to a `List` class because
    `Set` does not allow duplicates and handles the necessary checks internally:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 向`Set`类添加内容不像向`List`类添加那样有问题，因为`Set`不允许重复，并且内部处理必要的检查：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Consider the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE38]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If we run this, we''ll get the following result:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个，我们会得到以下结果：
- en: '![](img/f66129c3-7a84-4265-ac8b-72b758f97cee.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f66129c3-7a84-4265-ac8b-72b758f97cee.png)'
- en: As before, we observe that the concurrent `Set` version handles concurrency
    better.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们观察到并发`Set`版本在处理并发方面表现更好。
- en: 'Now we turn to the `Map` interface that has two implementations in the java.util.concurrent package:
    `ConcurrentHashMap` and `ConcurrentSkipListMap`.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们转向`Map`接口，它在`java.util.concurrent`包中有两个实现：`ConcurrentHashMap`和`ConcurrentSkipListMap`。
- en: The `ConcurrentHashMap` class *supports full concurrency of retrievals and high
    concurrency for updates* (from Javadoc). It is a thread-safe version of `java.util.HashMap`
    and is analogous to `java.util.Hashtable` in this respect. In fact, the `ConcurrentHashMap` class meets
    the requirements of the same functional specification as `java.util.Hashtable`,
    although its implementation is *somewhat different in synchronization details *(from
    Javadoc).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap`类*支持完全的检索并发性和高并发更新*（来自Javadoc）。它是`java.util.HashMap`的线程安全版本，在这方面与`java.util.Hashtable`类似。实际上，`ConcurrentHashMap`类满足与`java.util.Hashtable`相同的函数规范，尽管其实现细节在同步方面*有所不同*（来自Javadoc）。'
- en: 'Unlike `java.util.HashMap` and `java.util.Hashtable`, `ConcurrentHashMap` supports,
    according its JavaDoc, *a set of sequential and parallel bulk operations that,
    unlike most Stream methods, are designed to be safely, and often sensibly, applied
    even with maps that are being concurrently updated by other threads*:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 与`java.util.HashMap`和`java.util.Hashtable`不同，`ConcurrentHashMap`根据JavaDoc，*支持一系列顺序和并行批量操作，与大多数Stream方法不同，即使是在其他线程并发更新映射的情况下，也可以安全地、通常是有意义地应用*：
- en: '`forEach()`: This performs a given action on each element'
  id: totrans-228
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach()`: 这个方法对每个元素执行给定的操作'
- en: '`search()`: This returns the first available non-null result of applying a
    given function to each element'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search()`: 这个方法返回将给定函数应用于每个元素后的第一个非空结果'
- en: '`reduce()`: This accumulates each element (there are five overloaded versions)'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce()`: 这个方法累积每个元素（有五种重载版本）'
- en: These bulk operations accept a `parallelismThreshold` argument that allows deferring
    parallelization until the map size reaches the specified threshold. Naturally,
    when the threshold is set to `Long.MAX_VALUE`, there will be no parallelism whatsoever.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这些批量操作接受一个`parallelismThreshold`参数，允许在映射大小达到指定的阈值之前延迟并行化。自然地，当阈值设置为`Long.MAX_VALUE`时，将没有任何并行化。
- en: There are many other methods in the class API, so refer to its Javadoc for an
    overview.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 类API中还有许多其他方法，因此请参阅其Javadoc以获取概述。
- en: Unlike `java.util.HashMap` (and similar to `java.util.Hashtable`), neither `ConcurrentHashMap` nor
    `ConcurrentSkipListMap` allow null to be used as a key or value.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与`java.util.HashMap`（类似于`java.util.Hashtable`）不同，`ConcurrentHashMap`和`ConcurrentSkipListMap`都不允许使用null作为键或值。
- en: The second implementation of `Map`--the `ConcurrentSkipListSet` class--is based,
    as we mentioned before, on the `ConcurrentSkipListMap` class, so all the limitations of
    the `ConcurrentSkipListSet` class we just described apply to the `ConcurrentSkipListMap` class
    too. The `ConcurrentSkipListSet` class is practically a thread-safe version of
    `java.util.TreeMap`. `SkipList` is a sorted data structure that allows fast search
    concurrently. All the elements are sorted based on their natural sorting order
    of keys. The `NavigableSet` functionality we demonstrated for the `ConcurrentSkipListSet` class is
    present in the `ConcurrentSkipListMap` class too. For many other methods in the
    class API, refer to its Javadoc.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`的第二个实现——`ConcurrentSkipListSet`类——基于我们之前提到的`ConcurrentSkipListMap`类，因此我们刚才描述的`ConcurrentSkipListSet`类的所有限制也适用于`ConcurrentSkipListMap`类。`ConcurrentSkipListSet`类实际上是一个线程安全的`java.util.TreeMap`版本。`SkipList`是一种排序数据结构，允许并发快速搜索。所有元素都是根据其键的自然排序顺序排序的。我们在`ConcurrentSkipListSet`类中演示的`NavigableSet`功能也存在于`ConcurrentSkipListMap`类中。对于类API中的许多其他方法，请参阅其Javadoc。'
- en: 'Now let''s demonstrate the difference in the behavior in response to concurrency
    between the `java.util.HashMap`, `ConcurrentHashMap`, and `ConcurrentSkipListMap` classes.
    First, we will write the method that generates a test `Map` object:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们演示 `java.util.HashMap`、`ConcurrentHashMap` 和 `ConcurrentSkipListMap` 类在响应并发行为方面的差异。首先，我们将编写生成测试
    `Map` 对象的方法：
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here is the code that adds an element to a `Map` object concurrently:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是向 `Map` 对象并发添加元素的代码：
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Run this for all three implementations of `Map`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `Map` 的三种实现都运行此代码：
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we do this, we get an output for `HashMap` for the first key only:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，我们只会得到 `HashMap` 的第一个键的输出：
- en: '![](img/d1868213-4bf8-4a75-bf12-b337f0f42c05.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1868213-4bf8-4a75-bf12-b337f0f42c05.png)'
- en: 'We also get an output for `ConcurrentHashMap` and `ConcurrentSkipListMap` for
    all the keys, including the newly added ones. Here is the last section of the `ConcurrentHashMap` output:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还得到了 `ConcurrentHashMap` 和 `ConcurrentSkipListMap` 的输出，包括新添加的键。以下是 `ConcurrentHashMap`
    输出的最后部分：
- en: '![](img/3add6164-1a06-46e4-8a2c-f158894894bc.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3add6164-1a06-46e4-8a2c-f158894894bc.png)'
- en: 'As mentioned already, the appearance of `ConcurrentModificationException` is
    not guaranteed. Now we see that the moment it is thrown (if at all) is the moment
    when the code discovers that the modification has taken place. In the case of
    our example, it happened on the next iteration. Another point worth noticing is
    that the current set of keys changes even as we sort of isolate the set in a separate
    variable:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`ConcurrentModificationException` 的出现并不保证。现在我们看到（如果有的话），它被抛出的时刻（如果有的话）是代码发现修改发生的时刻。在我们的例子中，它发生在下一次迭代时。另一个值得注意的点是，即使我们在一个单独的变量中某种程度上隔离了集合，当前的键集也会发生变化：
- en: '[PRE42]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This reminds us not to dismiss the changes propagated through the objects via
    their references.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这提醒我们不要忽视通过对象的引用传播的变化。
- en: 'To save the book space and your time, we will not show the code for concurrent
    removal and just summarize the results. As expected, `HashMap` throws exception `ConcurrentModificationException`
    when an element is removed in any of the following ways. Here''s the first way:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省书籍空间和您的宝贵时间，我们将不展示并发删除的代码，而是仅总结结果。正如预期的那样，当以以下任何一种方式删除元素时，`HashMap` 会抛出
    `ConcurrentModificationException` 异常。以下是第一种方法：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here is the second way:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是第二种方法：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'It allows concurrent removal via `Iterator` in two ways. Here''s the first
    way:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许通过 `Iterator` 以两种方式并发删除。以下是第一种方法：
- en: '[PRE45]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And here is the second way:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是第二种方法：
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here''s the third way:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是第三种方法：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: By contrast, the two concurrent `Map` implementations allow any of the above
    ways of removal concurrently.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，这两个并发的 `Map` 实现允许并发执行上述任何一种删除方式。
- en: 'Similar behavior is also exhibited by all the concurrent implementations of
    the `Queue` interface: `LinkedTransferQueue`, `LinkedBlockingQueue`, `LinkedBlockingDequeue`,
    `ArrayBlockingQueue`, `PriorityBlockingQueue`, `DelayQueue`, `SynchronousQueue`,
    `ConcurrentLinkedQueue`, and `ConcurrentLinkedDequeue`, all in the `java.util.concurrent`
    package. But to demonstrate all of them would require a separate volume, so we
    leave it up to you to browse the Javadoc and provide an example of `ArrayBlockingQueue`
    only. The queue will be represented by the `QueueElement` class:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `Queue` 接口的并发实现也表现出类似的行为：`LinkedTransferQueue`、`LinkedBlockingQueue`、`LinkedBlockingDequeue`、`ArrayBlockingQueue`、`PriorityBlockingQueue`、`DelayQueue`、`SynchronousQueue`、`ConcurrentLinkedQueue`
    和 `ConcurrentLinkedDequeue`，所有这些都在 `java.util.concurrent` 包中。但要演示所有这些就需要另一本书，所以我们留给您去浏览
    Javadoc，并提供 `ArrayBlockingQueue` 的一个示例。队列将由 `QueueElement` 类表示：
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The queue producer will be as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 队列生产者将如下所示：
- en: '[PRE49]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following will be the queue consumer:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的将是队列消费者：
- en: '[PRE50]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Run the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码：
- en: '[PRE51]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Its results may look like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 其结果可能看起来像这样：
- en: '![](img/774a9db0-6d17-4aa2-b1fd-174c3f946db3.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/774a9db0-6d17-4aa2-b1fd-174c3f946db3.png)'
- en: How it works...
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Before we select which collections to use, read the Javadoc and see whether
    the limitations of the collection are acceptable for your application.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们选择要使用的集合之前，阅读 Javadoc 并查看集合的限制是否适合您的应用程序。
- en: For example, as per the Javadoc, the `CopyOnWriteArrayList` class *is ordinarily
    too costly, but may be more efficient than alternatives when traversal operations
    vastly outnumber mutations, and is useful when you cannot or don't want to synchronize
    traversals, yet need to preclude interference among concurrent threads.* Use it
    when you do not need to add new elements at different positions and do not require
    sorting. Otherwise, use `ConcurrentSkipListSet`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，根据 Javadoc，`CopyOnWriteArrayList`类*通常成本较高，但在遍历操作远多于突变时可能比替代方案更有效，当无法或不想同步遍历，但需要防止并发线程之间的干扰时很有用。当不需要在不同位置添加新元素且不需要排序时，请使用它。否则，使用`ConcurrentSkipListSet`。
- en: The `ConcurrentSkipListSet` and `ConcurrentSkipListMap` classes, as per the
    Javadoc, *provide expected average log(n) time cost for the contains, add, and
    remove operations and their variants.* *Ascending ordered views and their iterators
    are faster than descending ones.* Use them when you need to iterate quickly through
    the elements in a certain order and prefer sorting by default.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Javadoc，`ConcurrentSkipListSet`和`ConcurrentSkipListMap`类*提供预期的平均对数(n)时间成本，用于包含、添加和删除操作及其变体。升序视图及其迭代器比降序视图更快。当需要快速迭代特定顺序的元素并默认排序时，请使用它们。
- en: Use `ConcurrentHashMap` when the concurrency requirements are very demanding
    and you need to allow locking on the write operation but do not need to lock the
    element.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当并发需求非常严格，并且需要在写操作上允许加锁但不需要锁定元素时，请使用`ConcurrentHashMap`。
- en: '`ConcurrentLinkedQueque` and `ConcurrentLinkedDeque` are an appropriate choice
    when many threads share access to a common collection. `ConcurrentLinkedQueque`
    employs an efficient non-blocking algorithm.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentLinkedQueque`和`ConcurrentLinkedDeque`是当许多线程共享对公共集合的访问时的一个合适选择。`ConcurrentLinkedQueque`采用一个高效的非阻塞算法。'
- en: '`PriorityBlockingQueue` is a better choice when natural order is acceptable
    and you need fast adding of elements to the tail and fast removing of elements
    from the head of the queue. Blocking means that the queue waits to become non-empty
    when retrieving an element and waits for space to become available in the queue
    when storing an element.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当自然顺序可接受且需要快速向队列尾部添加元素和从队列头部快速删除元素时，`PriorityBlockingQueue`是一个更好的选择。阻塞意味着在检索元素时队列等待变为非空，在存储元素时等待队列中有空间可用。
- en: '`ArrayBlockingQueue`, `LinkedBlockingQueue`, and `LinkedBlockingDeque` have
    a fixed size (bounded). The other queues are unbounded.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayBlockingQueue`、`LinkedBlockingQueue`和`LinkedBlockingDeque`具有固定大小（有界）。其他队列是无界的。'
- en: Use these and similar characteristics and recommendations as the guidelines
    but execute comprehensive testing and performance measuring before and after implementing
    your functionality.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些和类似的特点及建议作为指导方针，但在实现功能前后进行全面的测试和性能测量。
- en: See also
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes in this chapter:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章以下菜谱：
- en: Using the executor service to execute async tasks
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用执行器服务执行异步任务
- en: Using fork/join to implement divide-and-conquer
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分治法实现fork/join
- en: Using flow to implement the publish-subscribe pattern
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流实现发布-订阅模式
- en: Using the executor service to execute async tasks
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用执行器服务执行异步任务
- en: In this recipe, you will learn how to use `ExecutorService` to implement controllable
    thread execution.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何使用`ExecutorService`来实现可控的线程执行。
- en: Getting ready
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In an earlier recipe, we demonstrated how to create and execute threads using
    the `Thread` class directly. It is an acceptable mechanism for a small number
    of threads that run and produce results predictably quickly. For big-scale applications
    with longer running threads with complex logic (which might keep them alive for
    an unpredictably long time) and/or a number of threads growing unpredictably too,
    a simple create-and-run-until-exit approach might result in an `OutOfMemory` error
    or require a complex customized system of threads' status maintenance and management.
    For such cases, `ExecutorService` and related classes of the `java.util.concurrent`
    package provide an out-of-the-box solution that relieves a programmer of the need
    to write and maintain a lot of infrastructural code.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们展示了如何直接使用 `Thread` 类创建和执行线程。对于少量运行并快速产生可预测结果的线程来说，这是一个可接受的机制。对于具有较长时间运行线程、复杂逻辑（可能使它们存活时间不可预测地长）以及线程数量不可预测地增长的大规模应用程序，简单的创建和运行直到退出的方法可能会导致
    `OutOfMemory` 错误或需要复杂的自定义线程状态维护和管理系统。对于此类情况，`ExecutorService` 和 `java.util.concurrent`
    包中的相关类提供了一种现成的解决方案，可以减轻程序员编写和维护大量基础设施代码的需要。
- en: At the foundation of the Executor Framework lies an `Executor` interface that
    has only one `void execute(Runnable command)` method that executes the given command
    at some time in the future.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器框架的基础是一个 `Executor` 接口，它只有一个 `void execute(Runnable command)` 方法，该方法将在未来的某个时间执行给定的命令。
- en: 'Its subinterface `ExecutorService` adds methods that allow you to manage the
    executor:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 其子接口 `ExecutorService` 添加了允许你管理执行器的方法：
- en: The `invokeAny()`, `invokeAll()`, and `awaitTermination()` methods and `submit()` allow
    you to define how the threads will be executed and if they are expected to return
    some values or not
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokeAny()`、`invokeAll()`、`awaitTermination()` 方法以及 `submit()` 允许你定义线程的执行方式以及它们是否预期返回某些值。'
- en: The `shutdown()` and `shutdownNow()` methods allow you to shut down the executor
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown()` 和 `shutdownNow()` 方法允许你关闭执行器。'
- en: The `isShutdown()` and `isTerminated()` methods provide the status of the executor
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isShutdown()` 和 `isTerminated()` 方法提供了执行器状态。'
- en: 'The objects of `ExecutorService` can be created with the static factory methods
    of the `java.util.concurrent.Executors` class:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `java.util.concurrent.Executors` 类的静态工厂方法创建 `ExecutorService` 对象：
- en: '`newSingleThreadExecutor()` - This creates an `Executor` method that uses a
    single worker thread operating off an unbounded queue. It has an overloaded version
    with `ThreadFactory` as a parameter.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newSingleThreadExecutor()` - 这创建了一个使用单个工作线程并操作无界队列的 `Executor` 方法。它有一个带有 `ThreadFactory`
    参数的重载版本。'
- en: '`newCachedThreadPool()` - This creates a thread pool that creates new threads
    as needed, but reuses previously constructed threads when they are available. It
    has an overloaded version with `ThreadFactory` as a parameter.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newCachedThreadPool()` - 这将创建一个线程池，根据需要创建新线程，但在可用时重用先前构建的线程。它有一个带有 `ThreadFactory`
    参数的重载版本。'
- en: '`newFixedThreadPool(int nThreads)` - This creates a thread pool that reuses
    a fixed number of threads operating off a shared unbounded queue. It has an overloaded
    version with `ThreadFactory` as a parameter.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newFixedThreadPool(int nThreads)` - 这将创建一个线程池，它重用固定数量的线程，这些线程在一个共享的无界队列上操作。它有一个带有
    `ThreadFactory` 参数的重载版本。'
- en: The `ThreadFactory` implementation allows you to override the process of creating
    new threads, enabling applications to use special thread subclasses, priorities,
    and so on. A demonstration of its usage is outside the scope of this book.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadFactory` 实现允许你覆盖创建新线程的过程，使应用程序能够使用特殊的线程子类、优先级等。其使用示例超出了本书的范围。'
- en: How to do it...
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'One important aspect of the behavior of the `Executor` interface you need to
    remember is that once created, it keeps running (waiting for new tasks to execute)
    until the Java process is stopped. So, if you would like to free memory, the `Executor` interface
    has to be stopped explicitly. If not shut down, forgotten executors will create
    a memory leak. Here is one possible way to make sure no executor is left behind:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要记住 `Executor` 接口行为的一个重要方面是，一旦创建，它就会继续运行（等待执行新任务），直到 Java 进程停止。因此，如果你想释放内存，必须显式停止
    `Executor` 接口。如果不关闭，被遗忘的执行器将导致内存泄漏。以下是一个确保没有执行器被遗留的方法：
- en: '[PRE52]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You can pass a worker (an implementation of either the `Runnable` or `Callable` functional
    interface) for execution to `ExecutorService` in a variety of ways, which we will
    see shortly. In this example, we executed two threads: one using the `execute()`
    method and another using the `submit()` method. Both methods accept `Runnable`
    or `Callable`, but we used only `Runnable` in this example. The `submit()` method returns
    `Future`, which represents the result of an asynchronous computation.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过多种方式将工作者（`Runnable` 或 `Callable` 函数式接口的实现）传递给 `ExecutorService` 以进行执行，我们将在稍后看到。在这个例子中，我们执行了两个线程：一个使用
    `execute()` 方法，另一个使用 `submit()` 方法。两种方法都接受 `Runnable` 或 `Callable`，但在这个例子中我们只使用了
    `Runnable`。`submit()` 方法返回 `Future`，它表示异步计算的结果。
- en: The `shutdown()` method initiates an orderly shutdown of the previously submitted
    tasks and prevents any new task from being accepted. This method does not wait
    for the task to complete the execution. The `awaitTermination()` method does that.
    But after `shutdownDelaySec`, it stops blocking and the code flow gets into `finally`
    block, where the `isTerminated()` method returns `true` if all the tasks are completed
    following the shutdown. In this example, we have two tasks executed in two different
    statements, but note that other methods of `ExecutorService` accept a collection
    of tasks.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`shutdown()` 方法启动先前提交任务的有序关闭，并阻止接受任何新任务。此方法不会等待任务完成执行。`awaitTermination()`
    方法会这样做。但是，在 `shutdownDelaySec` 之后，它停止阻塞，代码流程进入 `finally` 块，其中 `isTerminated()`
    方法在所有任务在关闭后完成时返回 `true`。在这个例子中，我们执行了两个不同的语句中的两个任务，但请注意，`ExecutorService` 的其他方法接受任务集合。'
- en: In such a case, when the service is shutting down, we iterate over the collection
    of `Future` objects. We call each task and cancel it if it is not completed yet,
    possibly doing something else that had to be done before canceling the task. How
    much time to wait (value of `shutdownDelaySec`) has to be tested for each application
    and the possible running tasks.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当服务正在关闭时，我们遍历 `Future` 对象的集合。我们调用每个任务，如果它尚未完成，则取消它，可能还会执行在取消任务之前必须执行的其他操作。等待时间（`shutdownDelaySec`
    的值）必须为每个应用程序和可能的运行任务进行测试。
- en: 'Finally, the `shutdownNow()` method says this: *attempts to stop all actively
    executing tasks, halts the processing of waiting tasks, and returns a list of
    the tasks that were awaiting execution* (according to the Javadoc).'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`shutdownNow()` 方法表示：*尝试停止所有正在执行的任务，停止等待任务的执行，并返回等待执行的任务列表*（根据 Javadoc）。
- en: 'Now we can collect and assess the results. In a real application, we typically
    do not want to shut down a service often. We just check the status of the tasks
    and collect results of those that return true from the `isDone()` method. In the
    above code example, we just show how to make sure that when we do stop the service,
    we do it in a controlled manner, without leaving behind any runaway process. If
    we run that code example, we will get the following:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以收集和评估结果。在实际应用中，我们通常不希望频繁地关闭服务。我们只是检查任务的状况，并收集从 `isDone()` 方法返回 true 的那些任务的结果。在上面的代码示例中，我们只是展示了当我们确实停止服务时，我们如何确保以一种受控的方式停止，而不留下任何失控的进程。如果我们运行这个代码示例，我们将得到以下结果：
- en: '![](img/c6dd14bc-8a2a-4216-933b-efdb49cacd86.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c6dd14bc-8a2a-4216-933b-efdb49cacd86.png)'
- en: 'Generalize the preceding code and create a method that shuts down a service
    and the task that has returned `Future`:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的代码泛化，创建一个关闭服务和已返回 `Future` 的任务的方法：
- en: '[PRE53]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Enhance the example by making the `Runnable` (using lambda expression) sleep
    for some time (simulating useful work to be done):'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过让 `Runnable`（使用 lambda 表达式）睡眠一段时间（模拟要执行的有用工作）来增强示例：
- en: '[PRE54]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Notice the two parameters: `shutdownDelaySec` (that defines how long the service
    will wait without allowing new tasks to be submitted before moving on and shutting
    itself down, eventually) and `threadSleepSec` (that defines how long the worker
    is sleeping, indicating that the simulating process is doing its job).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 注意两个参数：`shutdownDelaySec`（定义服务在继续并最终关闭自身之前将等待多长时间，不允许提交新任务）和 `threadSleepSec`（定义工作线程将睡眠多长时间，表示模拟的过程正在执行其工作）。
- en: 'Run the new code for different implementations of `ExecutorService` and values
    of `shutdownDelaySec` and `threadSleepSec`:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为不同的 `ExecutorService` 实现和 `shutdownDelaySec`、`threadSleepSec` 的值运行新代码：
- en: '[PRE55]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This is how the output may look like (it might be slightly different on your
    computer, depending on the exact timing of the events controlled by the operating
    system):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是输出可能的样子（它可能因操作系统控制的事件的确切时间而略有不同）：
- en: '![](img/72c92273-0613-457e-ac41-ee268941a01e.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72c92273-0613-457e-ac41-ee268941a01e.png)'
- en: 'Analyze the results. In the first example, we find no surprise because of the
    following line:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析结果。在第一个例子中，我们没有发现任何惊喜，因为以下行：
- en: '[PRE56]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It is blocking for three seconds, whereas each worker works for one second only.
    So it is enough time for each worker to complete its work even for a single-thread
    executor.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 它阻塞了三秒钟，而每个工作者只需工作一秒钟。所以对于单线程执行器来说，这已经足够每个工作者完成其工作了。
- en: 'Let''s make the service wait for one second only:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让服务只等待一秒钟：
- en: '![](img/fe87a199-b14e-47ba-9aeb-912d3429af43.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe87a199-b14e-47ba-9aeb-912d3429af43.png)'
- en: When you do this, you will notice that none of the tasks will be completed.
    In this case, worker `One` was interrupted (see the last line of the output),
    while task `Two` was canceled.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做时，你会发现没有任何任务会被完成。在这种情况下，工作者`One`被中断（见输出的最后一行），而任务`Two`被取消。
- en: 'Let''s make the service wait for three seconds:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让服务等待三秒钟：
- en: '![](img/a1106c9b-f169-4c22-858b-ec93a86baad1.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1106c9b-f169-4c22-858b-ec93a86baad1.png)'
- en: Now we see that worker `One` was able to complete its task, while worker `Two`
    was interrupted.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们看到工作者`One`能够完成其任务，而工作者`Two`被中断了。
- en: 'The `ExecutorService` interface produced by `newCachedThreadPool()` or `newFixedThreadPool()`
    performs similarly on a one-core computer. The only significant difference is
    that if the `shutdownDelaySec` value is equal to the `threadSleepSec` value, then
    they both allow you to complete the threads:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 由`newCachedThreadPool()`或`newFixedThreadPool()`生成的`ExecutorService`接口在一个核心计算机上表现相似。唯一的显著区别是，如果`shutdownDelaySec`值等于`threadSleepSec`值，那么它们都允许你完成线程：
- en: '![](img/4d7286f3-51a5-494d-a668-8e30fc334dac.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d7286f3-51a5-494d-a668-8e30fc334dac.png)'
- en: This was the result of using `newCachedThreadPool()`. The output of the example
    using `newFixedThreadPool()` looks exactly the same on a one-core computer.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`newCachedThreadPool()`的结果。在一个核心计算机上，使用`newFixedThreadPool()`的示例输出看起来完全一样。
- en: 'Use the `Future` object as a returned value when you need more control over
    the task, not just submit one and wait. There is another method called `submit()`
    in the `ExecutorService` interface that allows you to not only return a `Future`
    object, but also include the result that is passed to the method as a second parameter
    in the return object. Let''s check out an example of this:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你需要对任务有更多控制时，使用`Future`对象作为返回值，而不仅仅是提交一个并等待。`ExecutorService`接口中还有一个名为`submit()`的方法，它允许你不仅返回一个`Future`对象，还可以将作为方法第二个参数传递的结果包含在返回对象中。让我们看看这个例子：
- en: '[PRE57]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The value of `result` is `42`. This method can be helpful when you have submitted
    many workers (`nWorkers`) and need to know which one is completed:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`result`的值是`42`。这个方法在你提交了许多工作者（`nWorkers`）并需要知道哪个完成了时可能很有用：'
- en: '[PRE58]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Well, the catch is that `future.get()` is a blocking method. This is why we
    use a version of the `get()` method that allows us to set the `delaySec` timeout.
    Otherwise, `get()` blocks the iteration.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，问题是`future.get()`是一个阻塞方法。这就是为什么我们使用一个允许我们设置`delaySec`超时的`get()`方法版本。否则，`get()`会阻塞迭代。
- en: How it works...
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s move a step closer to real-life code and create a class that implements
    `Callable` and allows you to return a result from a worker as an object of the `Result` class:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更接近现实代码，创建一个实现`Callable`并允许你将工作者的结果作为`Result`类对象的类：
- en: '[PRE59]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: An actual numeric result is returned by the `getResult()` method. Here we also
    included the name of the worker and how long the thread is expected to sleep (to
    work) just for convenience and to better illustrate the output.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`getResult()`方法返回一个实际的数值结果。在这里，我们也包括了工作者的名称和线程预期休眠（工作）的时间，只是为了方便和更好地说明输出。'
- en: 'The worker itself is going to be an instance of the `CallableWorkerImpl` class:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者本身将是`CallableWorkerImpl`类的一个实例：
- en: '[PRE60]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here, the number `42` is an actual numeric result, which a worker supposedly
    calculated (while sleeping). The class  `CallableWorkerImpl` implemented interface `CallableWorker` :'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，数字`42`是一个实际的数值结果，一个工作者在睡眠时可能计算出的结果。`CallableWorkerImpl`类实现了`CallableWorker`接口：
- en: '[PRE61]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We had to make the methods default and return some data (they will be overridden
    by the class implementation anyway) to preserve its `functional interface` status.
    Otherwise, we would not be able to use it in lambda expressions.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不将这些方法设为默认并返回一些数据（它们将由类实现覆盖）以保留其`functional interface`状态。否则，我们就无法在lambda表达式中使用它。
- en: 'We will also create a factory that will generate a list of workers:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个工厂，该工厂将生成工作者列表：
- en: '[PRE62]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now we can use all these new classes and methods to demonstrate the `invokeAll()` method:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用所有这些新类和方法来演示`invokeAll()`方法：
- en: '[PRE63]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `printResults()` method outputs the results received from the workers:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`printResults()`方法输出从工作者那里接收到的结果：'
- en: '[PRE64]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To get the results, again we use a version of the `get()` method with timeout
    settings. Run the following code:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取结果，我们再次使用具有超时设置的`get()`方法版本。运行以下代码：
- en: '[PRE65]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Its output will be as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 其输出将如下所示：
- en: '![](img/be8e4318-8490-4fd0-8660-970c74b8dd60.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/be8e4318-8490-4fd0-8660-970c74b8dd60.png)'
- en: It's probably worth reminding that the three workers were created with sleep
    time 1, 2, and 3 seconds correspondingly, while the waiting time before the service
    shuts down is one second. This is why all the workers were canceled.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 可能值得提醒的是，三个工作者分别以1秒、2秒和3秒的睡眠时间创建，而服务关闭前的等待时间是1秒。这就是为什么所有工作者都被取消的原因。
- en: 'Now if we set the waiting time to six seconds, the output of the single-thread
    executor will be as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们把等待时间设置为六秒，单线程执行器的输出将如下所示：
- en: '![](img/f39a119a-87b0-47ec-a95f-fac460d3e347.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f39a119a-87b0-47ec-a95f-fac460d3e347.png)'
- en: Naturally, if we increase the waiting time again, all the workers would be able
    to complete their tasks.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，如果我们再次增加等待时间，所有工作者都将能够完成他们的任务。
- en: 'The `ExecutorService` interface produced by `newCachedThreadPool()` or `newFixedThreadPool()`
    performs much better even on a one-core computer:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 由`newCachedThreadPool()`或`newFixedThreadPool()`生成的`ExecutorService`接口，即使在单核计算机上也能表现得更好：
- en: '![](img/ed6d36e5-fbdc-439c-8d77-ba7cbc5d60ce.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ed6d36e5-fbdc-439c-8d77-ba7cbc5d60ce.png)'
- en: As you can see, all the threads were able to complete even with three seconds
    of waiting time.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有线程即使在等待了三秒钟之后也能完成任务。
- en: 'As an alternative, instead of setting a timeout during the service shutdown,
    you can possibly set it on the overloaded version of the `invokeAll()` method:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种替代方案，你可以在服务关闭期间而不是设置超时，可能设置在`invokeAll()`方法的重载版本上：
- en: '[PRE66]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'There is one particular aspect of the `invokeAll()` method''s behavior that
    often gets overlooked and causes surprises for first-time users: it returns only
    after all the tasks are complete (either normally or by throwing an exception). Read
    the Javadoc and experiment until you recognize that this behavior is acceptable
    for your application.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokeAll()`方法的一个特定行为常常被忽视，并给初次用户带来惊喜：它只有在所有任务都完成（无论是正常完成还是通过抛出异常）之后才返回。请阅读Javadoc并实验，直到你认识到这种行为对你的应用程序是可接受的。'
- en: 'By contrast, the `invokeAny()` method blocks only until at least one task is
    *completed successfully (without throwing an exception), if any do. Upon normal
    or exceptional return, tasks that have not completed are canceled* (according to
    Javadoc). Here is an example of the code that does this:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`invokeAny()`方法只阻塞到至少有一个任务成功完成（没有抛出异常），如果有任何任务的话。在正常或异常返回时，未完成的任务将被取消（根据Javadoc）。以下是一个实现此功能的代码示例：
- en: '[PRE67]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: You can experiment with it, setting different values for the waiting time (`shutdownDelaySec`)
    and sleep time for threads until you are comfortable with how this method behaves.
    As you can see, we have reused the `shutdownAndCancelTasks()` method by passing
    an empty list of `Future` objects since we do not have them in this case.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试设置不同的等待时间（`shutdownDelaySec`）和线程的睡眠时间，直到你对这个方法的行为感到满意。如您所见，我们通过传递一个空的`Future`对象列表来重用了`shutdownAndCancelTasks()`方法，因为我们在这个情况下没有这些对象。
- en: There's more...
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are two more static factory methods in the `Executors` class that create
    instances of `ExecutorService`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Executors`类中还有两个更多的静态工厂方法，用于创建`ExecutorService`的实例：
- en: '`newWorkStealingPool()`: This creates a work-stealing thread pool using the
    number of available processors as its target parallelism level. It has an overloaded
    version with a parallelism level as a parameter.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newWorkStealingPool()`: 这将创建一个使用可用处理器数量作为其目标并行级别的线程池。它有一个带有并行级别参数的重载版本。'
- en: '`unconfigurableExecutorService(ExecutorService executor)`: This returns an
    object that delegates all the defined `ExecutorService` methods to the given executor,
    except for those methods that might otherwise be accessible using casts.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unconfigurableExecutorService(ExecutorService executor)`: 这返回一个对象，将所有定义的 `ExecutorService`
    方法委托给给定的执行器，但不包括那些可能通过类型转换访问的方法。'
- en: Also, a subinterface of the `ExecutorService` interface, called `ScheduledExecutorService`,
    enhances the API with the capability to schedule a thread execution in future
    and/or their periodic execution.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`ExecutorService` 接口的一个子接口，称为 `ScheduledExecutorService`，通过提供在将来调度线程执行和/或其周期性执行的能力来增强
    API。
- en: 'The objects of `ScheduledExecutorService` can be created using the static factory
    methods of the `java.util.concurrent.Executors` class too:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `java.util.concurrent.Executors` 类的静态工厂方法创建 `ScheduledExecutorService`
    对象：
- en: '`newSingleThreadScheduledExecutor()`: This creates a single-threaded executor
    that can schedule commands to run after a given delay or to execute them periodically.
    It has an overloaded version with `ThreadFactory` as a parameter.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newSingleThreadScheduledExecutor()`: 这创建一个单线程执行器，可以调度在给定延迟后运行或周期性执行的命令。它有一个带有
    `ThreadFactory` 参数的重载版本。'
- en: '`newScheduledThreadPool(int corePoolSize)`: This creates a thread pool that
    can schedule commands to run after a given delay or to execute them periodically.
    It has an overloaded version with `ThreadFactory` as a parameter.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newScheduledThreadPool(int corePoolSize)`: 这创建一个线程池，可以调度在给定延迟后运行或周期性执行的命令。它有一个带有
    `ThreadFactory` 参数的重载版本。'
- en: '`unconfigurableScheduledExecutorService( ScheduledExecutorService executor
    )`: This returns an object that delegates all the defined `ScheduledExecutorService`
    methods to the given executor, but not any other methods that might otherwise
    be accessible using casts.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unconfigurableScheduledExecutorService(ScheduledExecutorService executor)`:
    这返回一个对象，将所有定义的 `ScheduledExecutorService` 方法委托给给定的执行器，但不包括那些可能通过类型转换访问的其他方法。'
- en: The `Executors` class also has several overloaded methods that accept, execute,
    and return `Callable` (which, by contrast with `Runnable`, contains the result).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executors` 类也有几个重载方法，可以接受、执行并返回 `Callable`（与 `Runnable` 相比，它包含结果）。'
- en: 'The `java.util.concurrent` package also includes classes that implement `ExecutorService`:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent` 包还包括实现 `ExecutorService` 的类：'
- en: '**The ThreadPoolExecutor class**: This executes each submitted task using one
    of the several pooled threads, normally configured using the `Executors` factory
    methods.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ThreadPoolExecutor 类**：这个类使用几个池化线程中的任何一个来执行每个提交的任务，通常使用 `Executors` 工厂方法配置。'
- en: '**The ScheduledThreadPoolExecutor**** class**: This extends the `ThreadPoolExecutor`
    class and implements the `ScheduledExecutorService` interface.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ScheduledThreadPoolExecutor 类**：这个类扩展了 `ThreadPoolExecutor` 类并实现了 `ScheduledExecutorService`
    接口。'
- en: '**The ForkJoinPool class**: This manages the execution of workers (`ForkJoinTask`
    processes) using a work-stealing algorithm. We will discuss it in the next recipe.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ForkJoinPool 类**：这个类使用工作窃取算法管理工作者的执行（`ForkJoinTask` 进程）。我们将在下一个食谱中讨论它。'
- en: Instances of these classes can be created via class constructors that accept
    more parameters, including the queue that holds the results, for providing more
    refined thread pool management.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类的实例可以通过接受更多参数的类构造函数创建，包括用于存储结果的队列，以提供更精细的线程池管理。
- en: See also
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes in this chapter:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章以下食谱：
- en: Using fork/join to implement divide-and-conquer
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 fork/join 实现分而治之
- en: Using flow to implement the publish-subscribe pattern
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流程实现发布-订阅模式
- en: Using fork/join to implement divide-and-conquer
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 fork/join 实现分而治之
- en: In this recipe, you will learn how to use the fork/join framework for the divide-and-conquer
    computation pattern.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你将学习如何使用 fork/join 框架来实现分而治之计算模式。
- en: Getting ready
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As mentioned in the previous recipe, the `ForkJoinPool` class is an implementation
    of the `ExecutorService` interface that manages the execution of workers--`ForkJoinTask`
    processes--using the work-stealing algorithm. It takes advantage of multiple processors,
    if available, and works best on tasks that can be broken down into smaller tasks
    recursively, which is also called a *divide-and-conquer* strategy.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个食谱中提到的，`ForkJoinPool` 类是 `ExecutorService` 接口的一个实现，它使用工作窃取算法管理工作者的执行--`ForkJoinTask`
    进程。它利用可用的多个处理器，并在可以递归分解为更小任务的任务上表现最佳，这也就是所谓的 *分而治之* 策略。
- en: Each thread in the pool has a dedicated double-ended queue (deque) that stores
    tasks, and the thread picks up the next task (from the head of the queue) as soon
    as the current task is completed. When another thread finishes executing all the
    tasks in its queue, it can take a task (steal it) from the tail of a non-empty
    queue of another thread.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 池中的每个线程都有一个专用的双端队列（deque），用于存储任务，线程在完成当前任务后立即从队列头部获取下一个任务。当另一个线程完成其队列中的所有任务时，它可以从另一个非空队列的尾部窃取一个任务。
- en: As with any `ExecutorService` implementation, the fork/join framework distributes
    tasks to worker threads in a thread pool. This framework is distinct because it
    uses a work-stealing algorithm. Worker threads that run out of tasks can steal
    tasks from other threads that are still busy.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何`ExecutorService`实现一样，fork/join框架将任务分配给线程池中的工作线程。这个框架的独特之处在于它使用了一个工作窃取算法。当工作线程耗尽任务时，可以从仍然忙碌的其他线程那里窃取任务。
- en: Such a design balances the load and allows an efficient use of the resources.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的设计平衡了负载，并允许高效地使用资源。
- en: 'For demonstration purposes, we are going to use the API created in [Chapter
    3](488da544-ff73-4ef7-9d57-00b67479defd.xhtml), *Modular Programming*: the `TrafficUnit`,
    `SpeedModel`, and `Vehicle` interfaces and the `TrafficUnitWrapper`, `FactoryTraffic`,
    `FactoryVehicle`, and `FactorySpeedModel` classes. We will also rely on the streams
    and stream pipelines described in [Chapter 3](488da544-ff73-4ef7-9d57-00b67479defd.xhtml),
    *Modular Programming*.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将使用在[第3章](488da544-ff73-4ef7-9d57-00b67479defd.xhtml)中创建的API，*模块化编程*：`TrafficUnit`、`SpeedModel`和`Vehicle`接口以及`TrafficUnitWrapper`、`FactoryTraffic`、`FactoryVehicle`和`FactorySpeedModel`类。我们还将依赖[第3章](488da544-ff73-4ef7-9d57-00b67479defd.xhtml)中描述的流和流管道，*模块化编程*。
- en: 'Just to refresh your memory, here is the `TrafficUnitWrapper` class:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 为了刷新你的记忆，以下是`TrafficUnitWrapper`类：
- en: '[PRE68]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We will also slightly modify the existing API interface and make it a bit more
    compact by introducing a new `DateLocation` class:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将稍微修改现有的API接口，通过引入一个新的`DateLocation`类使其更加紧凑：
- en: '[PRE69]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It will also allow you to hide the details and help you see the important aspects
    of this recipe.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将允许你隐藏细节，并帮助你看到这个菜谱的重要方面。
- en: How to do it...
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: All computations are encapsulated inside a subclass of one of the two subclasses
    (`RecursiveAction` or `RecursiveTask<T>`) of the abstract `ForkJoinTask` class.
    You can extend either `RecursiveAction` (and implement the `void compute()` method)
    or `RecursiveTask<T>` (and implement the `T compute()` method). As you may have
    probably noticed, you can choose to extend the `RecursiveAction` class for tasks
    that do not return any value, and extend `RecursiveTask<T>` when you need your
    tasks to return a value. In our demo, we are going to use the latter because it
    is slightly more complex.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 所有计算都被封装在`ForkJoinTask`类的两个子类（`RecursiveAction`或`RecursiveTask<T>`）之一的子类中。你可以扩展`RecursiveAction`（并实现`void
    compute()`方法）或`RecursiveTask<T>`（并实现`T compute()`方法）。正如你可能已经注意到的，你可以选择扩展`RecursiveAction`类来处理不返回任何值的任务，当你需要任务返回值时扩展`RecursiveTask<T>`。在我们的演示中，我们将使用后者，因为它稍微复杂一些。
- en: 'Let''s say we would like to calculate the average speed of traffic in a certain
    location on a certain date and time and driving conditions (all these parameters
    are defined by the property `DateLocation` object). Other parameters will be as
    follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要计算在特定日期和时间以及驾驶条件下（所有这些参数都由`DateLocation`对象定义）某个地点的交通平均速度。其他参数如下：
- en: '`timeSec`: The number of seconds during which the vehicles have a chance to
    accelerate after stopping at the traffic light'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeSec`：车辆在停止在交通灯后有机会加速的秒数'
- en: '`trafficUnitsNumber`: The number of vehicles to include in the average speed
    calculation'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trafficUnitsNumber`：用于平均速度计算的车辆数量'
- en: 'Naturally, the more vehicles included in the calculations, the better the prediction.
    But as this number increases, the number of calculations increases too. This gives
    rise to the need to break down the number of vehicles into smaller groups and
    compute the average speed of each group in parallel with the others. Yet, there
    is a certain minimal number of calculations that is not worth splitting between
    two threads. Here''s what Javadoc has to say about it: *As a very rough rule of
    thumb, a task should perform more than 100 and less than 10000 basic computational
    steps, and should avoid indefinite looping. If tasks are too big, then parallelism
    cannot improve throughput. If too small, then memory and internal task maintenance
    overhead may overwhelm processing.* Yet, as always, the final answer about the
    best minimal number of calculations without splitting will come from testing.
    This is why we recommend to pass it as a parameter. We will call this parameter
    `threshold`. Notice that it also serves as a criterium for exiting from the recursion.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，包含在计算中的车辆越多，预测就越好。但随着这个数字的增加，计算的数量也会增加。这产生了将车辆数量分解成更小组并与其他组并行计算每个组平均速度的需要。然而，存在一个计算的最小数量，不值得在两个线程之间分割。以下是
    Javadoc 对此的说明：*作为一个非常粗略的经验法则，一个任务应该执行超过 100 次和少于 10000 次基本计算步骤，并应避免无限循环。如果任务太大，那么并行化不能提高吞吐量。如果太小，那么内存和内部任务维护开销可能会压倒处理能力。*然而，像往常一样，关于最佳最小计算数量而不分割的最终答案将来自测试。这就是我们建议将其作为参数传递的原因。我们将把这个参数命名为
    `threshold`。请注意，它也作为退出递归的标准。
- en: 'We will call our class (task) `AverageSpeed` and extend `RecursiveTask<Double>`
    because we would like to have as a result of the average speed value of the `double`
    type:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的类（任务）命名为 `AverageSpeed` 并扩展 `RecursiveTask<Double>`，因为我们希望平均速度的结果是 `double`
    类型的值：
- en: '[PRE70]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Before we finish writing the code for the `compute()` method, let''s write
    the code that will execute this task. There are several ways to do this. We can
    use `fork()` and `join()`, for example:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成 `compute()` 方法的代码编写之前，让我们编写将执行此任务的代码。有几种方法可以做到这一点。例如，我们可以使用 `fork()` 和
    `join()`：
- en: '[PRE71]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This technique provided the name for the framework. The `fork()` method, according
    to Javadoc, a*rranges to asynchronously execute this task in the pool the current
    task is running in, if applicable, or using the ForkJoinPool.commonPool() if not
    in ForkJoinPool().* In our case, we did not use any pool yet, so `fork()` is going
    to use `ForkJoinPool.commonPool()` by default. It places the task in the queue
    of a thread in the pool. The `join()` method returns the result of the computation
    when it is done.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术为框架提供了名字。根据 Javadoc，`fork()` 方法负责在当前任务运行的池中异步执行此任务（如果适用），或者在不在 ForkJoinPool
    的情况下使用 ForkJoinPool.commonPool()。在我们的案例中，我们还没有使用任何池，所以 `fork()` 默认将使用 `ForkJoinPool.commonPool()`。它将任务放入池中一个线程的队列中。`join()`
    方法在任务完成后返回计算结果。
- en: 'The `createTask()` method contains the following:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`createTask()` 方法包含以下内容：'
- en: '[PRE72]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Notice the values of the `trafficUnitsNumber` and `threshold` parameters. This
    will be important for analyzing the results.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `trafficUnitsNumber` 和 `threshold` 参数的值。这对于分析结果将非常重要。
- en: 'Another way to accomplish this is to use either the `execute()` or `submit()` method--each
    providing the same functionality--for the execution of the task. The result of
    the execution can be retrieved by the `join()` method (the same as in the previous
    example):'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此任务的另一种方法是使用 `execute()` 或 `submit()` 方法（每个都提供相同的功能）来执行任务。执行的结果可以通过 `join()`
    方法检索（与上一个例子相同）：
- en: '[PRE73]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The last method we are going to review is `invoke()`, which is equivalent to
    calling the `fork()` method followed by the `join()` method:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要回顾的最后一种方法是 `invoke()`，它等同于先调用 `fork()` 方法，然后调用 `join()` 方法：
- en: '[PRE74]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Naturally, this is the most popular way to start the divide-and-conquer process.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这是启动分而治之过程最受欢迎的方式。
- en: 'Now let''s get back to the `compute()` method and see how it can be implemented.
    First, let''s implement the `if` block (that calculates the average speed of less
    than `threshold` vehicles). We will use the technique and code we described in
    [Chapter 3](488da544-ff73-4ef7-9d57-00b67479defd.xhtml), *Modular Programming*:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 `compute()` 方法，看看它是如何实现的。首先，让我们实现 `if` 块（计算小于 `threshold` 辆车的平均速度）。我们将使用我们在
    [第 3 章](488da544-ff73-4ef7-9d57-00b67479defd.xhtml)，*模块化编程* 中描述的技术和代码：
- en: '[PRE75]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We get the `trafficUnitsNumber` of the vehicles from `FactoryTraffic`, and we
    create an object of `TrafficUnitWrapper` for each emitted element and call the `setSpeedModel()`
    method on it (by passing in the newly generated `SpeedModel` object, based on
    the emitted `TrafficUnit` object). Then we calculate the speed, get an average
    of all the speeds in the stream, and get the result as `double` from the `Optional`
    object (the return type of the `average()` operation). We then print out the result
    and round to get a more presentable format.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`FactoryTraffic`获取车辆的`trafficUnitsNumber`，并为每个发出的元素创建一个`TrafficUnitWrapper`对象，并在其上调用`setSpeedModel()`方法（通过传递基于新生成的`SpeedModel`对象，该对象基于发出的`TrafficUnit`对象）。然后我们计算速度，获取流中所有速度的平均值，并将结果作为`double`从`Optional`对象（`average()`操作的返回类型）中获取。然后我们打印出结果，并四舍五入以获得更易读的格式。
- en: It is also possible to achieve the same result using a traditional `for` loop.
    But, as mentioned before, it seems that Java follows the general trend of more
    fluent and stream-like style, geared towards processing a large amount of data.
    So, we recommend you get used to it.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，也可以使用传统的`for`循环来实现相同的结果。但是，如前所述，Java似乎遵循更流畅和流式风格的通用趋势，旨在处理大量数据。因此，我们建议你习惯这种方式。
- en: In [Chapter 15](823213ae-b820-450c-abb8-8a98a70caf70.xhtml), *Testing*, you
    will see another version of the same functionality that allows better unit testing
    of each step in isolation, which again supports the view that unit testing, along
    with writing code, helps you make your code more testable and decreases the need
    for rewriting it later.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15章](823213ae-b820-450c-abb8-8a98a70caf70.xhtml)“测试”中，你会看到相同功能的另一个版本，它允许对每个步骤进行更好的单元测试，这再次支持了单元测试，连同编写代码一样，可以帮助你使代码更易于测试，并减少以后重写代码的需求。
- en: 'Now, let''s review the options of the `else` block implementation. The first
    few lines are always going to be the same:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下`else`块实现的选项。前几行总是相同的：
- en: '[PRE76]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We divide the `trafficUnitsNumber` number by two (we do not worry about possible
    loss of one unit in the case of an average across a big set) and create two tasks.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`trafficUnitsNumber`数量除以二（在处理大集合的平均值时，我们不担心可能丢失一个单位），并创建两个任务。
- en: 'The following--the actual task execution code--can be written in several different
    ways. Here is the first possible solution, which is familiar to us already, that
    comes to mind:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 以下——实际的任务执行代码——可以以几种不同的方式编写。以下是第一个可能的解决方案，这是我们首先想到的，也是我们熟悉的：
- en: '[PRE77]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Run the following code:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码：
- en: '[PRE78]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'If we do this, we will see the same output (but with different speed values)
    three times:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，我们将看到相同的输出（但速度值不同），总共三次：
- en: '![](img/c694c38c-ce64-4682-baa3-7b2b12c613d6.png)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c694c38c-ce64-4682-baa3-7b2b12c613d6.png)'
- en: You see how the original task of calculating average speed over 1,001 units
    (vehicles) was first divided by two several times until the number of one group
    (62) fell under the threshold of 100\. Then, an average speed of the last two
    groups was calculated and combined (joined) with the results of other groups.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，原始任务是在1,001个单位（车辆）上计算平均速度，首先被分成几组，直到一组（62）的数量低于100的阈值。然后，计算最后两组的平均速度，并将其与其他组的结果合并（连接）。
- en: 'Another way to implement an `else` block of the `compute()` method could be
    as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 实现计算方法`compute()`的`else`块还有另一种方式，如下所示：
- en: '[PRE79]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Here''s how the result will look:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/4df2d4d0-0ef5-47a3-9838-ae440af6c6e9.png)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4df2d4d0-0ef5-47a3-9838-ae440af6c6e9.png)'
- en: You can see how, in this case, the `compute()` method (of the second task) was
    called recursively many times until it reached the threshold by the number of
    elements, then its results were joined with the results of the call to the `fork()`
    and `join()` methods of the first task.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在这种情况下，计算方法（第二个任务）被递归调用多次，直到通过元素数量达到阈值，然后将其结果与第一个任务的`fork()`和`join()`方法调用的结果合并。
- en: 'As mentioned before, all this complexity can be replaced by a call to the `invoke()` method:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，所有这些复杂性都可以通过调用`invoke()`方法来替换：
- en: '[PRE80]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'It produces a result similar to the one produced by calling `fork()` and `join()`
    on each of the tasks:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 它产生的结果与对每个任务调用`fork()`和`join()`产生的结果相似：
- en: '![](img/f9ffedad-2fd0-431f-9624-e4de7fec800b.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9ffedad-2fd0-431f-9624-e4de7fec800b.png)'
- en: 'Yet, there is an even better way to implement an `else` block of the `compute()` method:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有更好的方法来实现计算方法`compute()`的`else`块：
- en: '[PRE81]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If this looks complex to you, just notice that it is just a stream-like way
    to iterate over the results of `invokeAll()`:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来很复杂，只需注意这只是一个类似于流的方式来遍历 `invokeAll()` 的结果：
- en: '[PRE82]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'It is also to iterate over the results of calling `join()` on each of the returned
    tasks (and combining the results into average). The advantage is that we yield
    to the framework to decide how to optimize the load distribution. The result is
    as follows:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为了遍历对每个返回的任务调用 `join()` 的结果（并将结果合并为平均值）。其优势在于我们让框架决定如何优化负载分配。结果如下：
- en: '![](img/e65ae659-3593-4eb7-a719-f536471c7d09.png)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e65ae659-3593-4eb7-a719-f536471c7d09.png)'
- en: You can see it differs from any of the preceding results and can change depending
    on the availability and load of the CPUs on your computer.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到它与前面的任何结果都不同，并且可能根据你计算机上 CPU 的可用性和负载而变化。
- en: Using flow to implement the publish-subscribe pattern
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流实现发布-订阅模式
- en: In this recipe, you will learn about the new publish-subscribe capability introduced
    in Java 9.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将了解 Java 9 中引入的新发布-订阅功能。
- en: Getting ready
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Among many other features, Java 9 introduced these four interfaces in the `java.util.concurrent.Flow` class:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多其他特性中，Java 9 在 `java.util.concurrent.Flow` 类中引入了这四个接口：
- en: '[PRE83]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: With this, Java stepped into the world of reactive programming--programming
    with the asynchronous processing of data streams.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，Java 步入了响应式编程的世界——使用数据流的异步处理进行编程。
- en: We discussed streams in [Chapter 3](488da544-ff73-4ef7-9d57-00b67479defd.xhtml),
    *Modular Programming* and pointed out that they are not data structures, as they
    do not keep data in memory. The stream pipeline does nothing until an element
    is emitted. Such a model allows minimal resource allocation and uses resources
    only as needed. The application behaves *in response* to the appearance of the
    data it reacts to, thus the name.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 3 章](488da544-ff73-4ef7-9d57-00b67479defd.xhtml) *模块化编程* 中讨论了流，并指出它们不是数据结构，因为它们不在内存中保留数据。流管道在发出元素之前不做任何事情。这种模型允许最小化资源分配，并且仅在需要时使用资源。应用程序对它所响应的数据的出现做出反应，因此得名。
- en: In a publish-subscribe pattern, the main two actors are a `Publisher` and a
    `Subscriber`. `Publisher` streams data (publishes), and `Subscriber` listens to
    data (subscribes).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布-订阅模式中，主要有两个角色：`Publisher` 和 `Subscriber`。`Publisher` 流式传输数据（发布），而 `Subscriber`
    监听数据（订阅）。
- en: 'The `Flow.Publisher<T>` interface is a functional interface. It only has one
    abstract method:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow.Publisher<T>` 接口是一个函数式接口。它只有一个抽象方法：'
- en: '[PRE84]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: According to the Javadoc, this method *adds the given Flow.Subscriber<T> if
    possible. If already subscribed, or the attempt to subscribe fails, the onError()
    method of theFlow.Subscriber<T> is invoked with an IllegalStateException. Otherwise,
    the onSubscribe() method of theFlow.Subscriber<T> is invoked with a new Flow.Subscription.
    Subscribers may enable receiving items by invoking the request() method of thisFlow.Subscription
    and may unsubscribe by invoking its cancel() method.*
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Javadoc，此方法如果可能的话会添加给定的 Flow.Subscriber<T>。如果已经订阅，或者尝试订阅失败，则调用 Flow.Subscriber<T>
    的 onError() 方法并传入 IllegalStateException。否则，调用 Flow.Subscriber<T> 的 onSubscribe()
    方法并传入新的 Flow.Subscription。订阅者可以通过调用此 Flow.Subscription 的 request() 方法来启用接收项目，也可以通过调用其
    cancel() 方法来取消订阅。
- en: 'The `Flow.Subscriber<T>` interface has four methods; some of them were mentioned
    just now:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow.Subscriber<T>` 接口有四个方法；其中一些刚才已经提到了：'
- en: '`void onSubscribe(Flow.Subscription subscription)` is invoked prior to invoking
    any other `Subscriber` methods for the given `Subscription`'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void onSubscribe(Flow.Subscription subscription)` 在调用给定 `Subscription` 的任何其他
    `Subscriber` 方法之前被调用'
- en: '`void onError(Throwable throwable)` is invoked upon an unrecoverable error
    encountered by a `Publisher` or `Subscription`, after which no other `Subscriber`
    methods are invoked by the `Subscription`'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void onError(Throwable throwable)` 在 `Publisher` 或 `Subscription` 遇到不可恢复的错误后调用，之后不再通过
    `Subscription` 调用任何其他 `Subscriber` 方法'
- en: '`void onNext(T item)` is invoked with the `Subscription`''s next item'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void onNext(T item)` 使用 `Subscription` 的下一个项目调用'
- en: '`void onComplete()`: This method is invoked when it is known that no additional
    `Subscriber` method invocations will occur for a `Subscription`'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void onComplete()`：当知道不会为 `Subscription` 调用任何额外的 `Subscriber` 方法时，调用此方法'
- en: 'The `Flow.Subscription` interface has two methods:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow.Subscription` 接口有两个方法：'
- en: '`void cancel()`: This method causes the `Subscriber` to (eventually) stop receiving
    messages'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void cancel()`：此方法导致 `Subscriber` （最终）停止接收消息'
- en: '`void request(long n)`: This method adds the given n number of items to the
    current unfulfilled demand for this subscription'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void request(long n)`: 此方法将给定的n个项目添加到当前未满足的订阅需求'
- en: The `Flow.Processor<T,R>` interface is outside the scope of this book.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow.Processor<T,R>`接口超出了本书的范围。'
- en: How to do it...
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To save some time and space, instead of creating our own implementation of
    the `Flow.Publisher<T>` interface, we can use the `SubmissionPublisher<T>` class from
    the `java.util.concurrent` package. But, we will create our own implementation
    of the `Flow.Subscriber<T>` interface:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省一些时间和空间，我们不必创建自己的`Flow.Publisher<T>`接口实现，我们可以使用`java.util.concurrent`包中的`SubmissionPublisher<T>`类。但是，我们将创建自己的`Flow.Subscriber<T>`接口实现：
- en: '[PRE85]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We will also implement the `Flow.Subscription` interface:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将实现`Flow.Subscription`接口：
- en: '[PRE86]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As you can see, we just followed Javadoc recommendations and expect the `onSubscribe()`
    method of a subscriber to be called when the subscriber is added to a publisher.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们只是遵循了Javadoc推荐，并期望当订阅者被添加到发布者时，会调用订阅者的`onSubscribe()`方法。
- en: Another detail to notice is that the `SubmissionPublisher<T>` class has the `submit(T
    item)` method that, according to Javadoc, *publishes the given item to each current
    subscriber by asynchronously invoking its onNext() method, blocking uninterruptibly
    while resources for any subscriber are unavailable*. This way, the `SubmissionPublisher<T>`
    class submits items to the current subscribers until it is closed. This allows
    item generators to act as reactive-streams publishers.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的细节是，`SubmissionPublisher<T>`类有一个`submit(T item)`方法，根据Javadoc，该方法*通过异步调用其onNext()方法将给定项发布到每个当前订阅者，在任何订阅者的资源不可用时不中断地阻塞*。这样，`SubmissionPublisher<T>`类将项目提交给当前订阅者，直到它被关闭。这允许项目生成器充当反应式流发布者。
- en: 'To demonstrate this, let''s create several subscribers and subscriptions using
    the `demoSubscribe()` method:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们使用`demoSubscribe()`方法创建几个订阅者和订阅：
- en: '[PRE87]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Then use them in the following code:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在以下代码中使用它们：
- en: '[PRE88]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The preceding code creates three subscribers, connected to the same publisher
    with a dedicated subscription. The last line generates a stream of numbers 1,
    2, 3, and 4 and submits each of them to the publisher. We expect that every subscriber
    will get each of the generated numbers as the parameter of the `onNext()` method.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了三个订阅者，它们通过专用订阅连接到同一个发布者。最后一行生成数字流1, 2, 3和4，并将每个数字提交给发布者。我们预计每个订阅者都将通过`onNext()`方法的参数接收到每个生成的数字。
- en: 'In the `finally` block, we included the code you are already familiar with
    from the previous recipe:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在`finally`块中，我们包含了您从之前的菜谱中已经熟悉的代码：
- en: '[PRE89]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'If we run the preceding code, the output may look like the following:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，输出可能看起来像以下这样：
- en: '![](img/df995979-dce0-4fad-b7ea-95cbbf1ecab3.png)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/df995979-dce0-4fad-b7ea-95cbbf1ecab3.png)'
- en: As you can see, because of asynchronous processing, the control gets to the
    `finally` block very quickly and waits for 1 sec before shutting down the service.
    This period of waiting is enough for the items to be generated and passed to the
    subscribers. We also confirmed that every generated item was sent to each of the
    subscribers. The three `null` values were generated every time the `onSubscribe()`
    method of each of the subscribers is called.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，由于异步处理，控制流很快到达`finally`块，并在关闭服务之前等待1秒。这个等待期足以让项目被生成并传递给订阅者。我们还确认每个生成的项目都被发送到每个订阅者。每当每个订阅者的`onSubscribe()`方法被调用时，都会生成三个`null`值。
- en: It is reasonable to expect that in future Java releases, there will be more
    support added for reactive (asynchronous and non-blocking) functionality.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 有理由预期在未来的Java版本中，将增加更多对反应式（异步和非阻塞）功能的支持。
