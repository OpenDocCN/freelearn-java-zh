- en: Chapter 2. Core Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 核心概念
- en: 'This chapter introduces the core concepts of Camel. These concepts are the
    key basis of all functionalities provided by Camel. We will use them in the next
    chapters. As we have seen in the previous chapter, Camel is an integration framework.
    This means that it provides everything to implement your mediation logic: messaging,
    routing, transformation, and connectivity.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Camel的核心概念。这些概念是Camel提供所有功能的关键基础。我们将在下一章中使用它们。正如我们在上一章中看到的，Camel是一个集成框架。这意味着它提供了实现您的中介逻辑所需的一切：消息传递、路由、转换和连接性。
- en: 'We will look at the following concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨以下概念：
- en: Messages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息
- en: Exchanges
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换
- en: Camel contexts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Camel上下文
- en: Messages
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息
- en: Messages transport the data between the different parts of the mediation logic.
    Your mediation logic will define the flow of messages between different nodes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 消息在中介逻辑的不同部分之间传输数据。您的中介逻辑将定义不同节点之间消息的流动。
- en: A message flows in one direction, from a sender to a receiver. It's not possible
    to use the same message to answer the sender, we will have to use another message.
    A message is described in the `org.apache.camel.Message` interface.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 消息单向流动，从发送者到接收者。不可能使用同一个消息来回答发送者，我们不得不使用另一个消息。消息由`org.apache.camel.Message`接口描述。
- en: The javadoc is available at [http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/Message.html](http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/Message.html).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: javadoc可在[http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/Message.html](http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/Message.html)找到。
- en: 'A message contains the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个消息包含以下内容：
- en: 'ID: A message ID of type `String`. Camel creates an ID for you. This ID identifies
    the message and can be used for correlation or storage. For instance, we will
    see that the message ID is used in the idempotent consumer pattern to identify
    the message in a store.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ID：一个类型为`String`的消息ID。Camel为您创建一个ID。此ID标识消息，可用于关联或存储。例如，我们将看到消息ID在幂等消费者模式中用于在存储中标识消息。
- en: 'Header: A set of headers, allowing you to store any kind of data associated
    with a message. The headers are stored as `org.apache.camel.util.CaseInsensitiveMap`
    by default. The `CaseInsensitiveMap` ([http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/util/CaseInsensitiveMap.html](http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/util/CaseInsensitiveMap.html))
    extends `HashMap<String,Object>`. This means you can store any kinds of objects
    (including very large objects) in the header. To access the map use a `String`
    key, which is case insensitive. The lifetime of the headers is the same as the
    message (as the headers are part of the message itself). The purpose of the headers
    is to add hints about the content encoding, authentication information, and so
    on. As we will see in the next chapters, Camel itself uses and populates the headers
    for its own needs and configurations.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题：一组标题，允许您存储与消息相关联的任何类型的数据。默认情况下，标题存储为`org.apache.camel.util.CaseInsensitiveMap`。`CaseInsensitiveMap`([http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/util/CaseInsensitiveMap.html](http://camel.apache.org/maven/camel-2.13.0/camel-core/apidocs/org/apache/camel/util/CaseInsensitiveMap.html))扩展了`HashMap<String,Object>`。这意味着您可以在标题中存储任何类型的对象（包括非常大的对象）。要访问该映射，请使用一个`String`键，它是不区分大小写的。标题的寿命与消息相同（因为标题本身就是消息的一部分）。标题的目的是添加有关内容编码、认证信息等内容的信息。正如我们将在下一章中看到的，Camel本身会使用并填充标题以满足其自身的需求和配置。
- en: 'Attachment: A set of attachments is mostly to match the requirements of some
    protocols and components: WebService component (to provide SOAP Message Transmission
    Optimization Mechanism (MTOM) support) or the e-mail component (to provide support
    for e-mail attachments). The attachments are only used by some dedicated components,
    they are not as heavily used as the headers. The attachments are stored in the
    message as `Map<String,DataHandler>`. An attachment name is a `String`, which
    is case sensitive. An attachment is stored using `DataHandler` providing support
    of MIME type and consistent access to the data.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附件：一组附件主要用于满足某些协议和组件的需求：WebService组件（提供SOAP消息传输优化机制（MTOM）支持）或电子邮件组件（提供对电子邮件附件的支持）。附件仅由一些专用组件使用，它们不像标题那样被广泛使用。附件以`Map<String,DataHandler>`的形式存储在消息中。附件名称是一个`String`，它是区分大小写的。附件使用`DataHandler`存储，它提供对MIME类型和数据的统一访问。
- en: 'Fault flag: A fault flag Boolean that allows you to distinguish whether the
    message is a normal message or a faulted message. It allows some components or
    patterns to treat the message in a different way. For instance, instead of a SOAP
    Response, a message may contain a SOAP Fault. In that case, we have to inform
    the component that a message containing a SOAP Fault is not a normal message.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障标志：一个允许您区分消息是正常消息还是故障消息的布尔值。它允许某些组件或模式以不同的方式处理消息。例如，消息可能包含一个SOAP错误，而不是SOAP响应。在这种情况下，我们必须通知组件，包含SOAP错误的消息不是正常消息。
- en: 'Body: The body is the actual payload of the message. The body is stored as
    an `Object` in the message, allowing you to store any kind of data. In [Chapter
    1](ch01.html "Chapter 1. Key Features"), *Key Features* we saw that one of the
    Camel key features is to be payload-agnostic. The fact that the body is directly
    an `Object` is the implementation of the payload-agnostic feature.![Messages](img/3151EN_02_01.jpg)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主体：主体是消息的实际有效负载。主体存储为消息中的`Object`，允许您存储任何类型的数据。在[第1章](ch01.html "第1章。关键特性")中，我们看到了Camel的一个关键特性是负载无关性。主体直接是`Object`的事实是负载无关性特性的实现。![消息](img/3151EN_02_01.jpg)
- en: Exchange
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Exchange
- en: Camel doesn't transport a message directly. The main reason is that a message
    flows only in one direction. When dealing with messaging, there are many Message
    Exchange Patterns (MEP) that we can use.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 骆驼不直接传输消息。主要原因是一个消息只能单向流动。在处理消息时，我们可以使用许多消息交换模式（MEP）。
- en: 'Depending on the use cases, we can send a message without expecting any return
    from the destination: this pattern is named event message and uses InOnlyMEP.
    For instance, when you read a file from the filesystem, you just process the file
    content, without returning anything to the endpoint that read the file. In that
    case, the component responsible for reading the filesystem will define an InOnlyMEP.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用例，我们可以发送消息而不期望从目的地得到任何返回：这种模式被称为事件消息，并使用InOnlyMEP。例如，当您从文件系统中读取文件时，您只需处理文件内容，而不向读取文件的端点返回任何内容。在这种情况下，负责读取文件系统的组件将定义一个InOnlyMEP。
- en: 'On the other hand, you may want to implement a request reply pattern: a response
    message should be returned to the sender of the request message, and so it uses
    an InOutMEP. For instance, you receive a SOAP Request from a WebService component,
    so you should return a SOAP Response (or SOAP Fault) to the message sender.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，您可能想实现一个请求回复模式：响应消息应该返回给请求消息的发送者，因此它使用InOutMEP。例如，您从WebService组件接收一个SOAP请求，因此您应该向消息发送者返回一个SOAP响应（或SOAP错误）。
- en: 'In Camel, MEP are described in the `org.apache.camel.ExchangePattern` enumeration
    ([http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/ExchangePattern.html](http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/ExchangePattern.html)).
    We can see that Camel supports the following MEP:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Camel中，MEP在`org.apache.camel.ExchangePattern`枚举中描述（[http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/ExchangePattern.html](http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/ExchangePattern.html)）。我们可以看到Camel支持以下MEP：
- en: InOnly
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: InOnly
- en: InOptionalOut
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: InOptionalOut
- en: InOut
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: InOut
- en: OutIn
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OutIn
- en: OutOptionalIn
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OutOptionalIn
- en: RobustInOnly
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RobustInOnly
- en: RobustOutOnly
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RobustOutOnly
- en: 'As a message flows in only one direction, in order to support the different
    MEPs, we need two messages:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于消息只在一个方向上流动，为了支持不同的MEP，我们需要两个消息：
- en: The first message is mandatory as it's the `in` message
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一条消息是强制性的，因为它是`in`消息
- en: The second message is optional (depending on the MEP) as it's the `out` message
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二条消息是可选的（取决于MEP），因为它是`out`消息
- en: 'That''s why Camel **wraps** the messages into an Exchange object: the actual
    object transported is the Exchange, acting as a messages container with all meta-data
    required for the routing logic.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Camel将消息包装到一个交换对象中：实际传输的对象是交换，它作为一个包含所有路由逻辑所需元数据的消息容器。
- en: This Exchange object is used for the complete mediation process execution.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此交换对象用于完整的介调过程执行。
- en: The `org.apache.camel.Exchange` interface describes an exchange.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.apache.camel.Exchange`接口描述了一个交换。'
- en: 'Basically, an exchange contains the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，一个交换包含以下内容：
- en: 'Exchange ID: An exchange ID as a `String`. This is a unique identifier for
    the exchange. Camel creates it for you.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换ID：一个作为`String`的交换ID。这是交换的唯一标识符。Camel会为您创建它。
- en: 'MEP: The Message Exchange Pattern (MEP) defines the exchange pattern.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MEP：消息交换模式（MEP）定义了交换模式。
- en: 'Exception: The `Exception` is used by the error handler, as we will see later.
    It stores the current cause of an exchange failure. If an error occurs at any
    time during routing, it will be set in this exception field.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常：`Exception`由错误处理器使用，正如我们稍后将要看到的。它存储交换失败的当前原因。如果在路由过程中任何时候发生错误，它将在异常字段中设置。
- en: 'Properties: The properties is a `Map<String, Object>` and may look like message
    headers. The main difference is their lifetime: the properties exist during the
    whole exchange execution, whereas the headers are limited to the message duration
    (and a message can change a lot during routing, so during the exchange execution).
    Camel itself may add some properties for some use cases.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性：属性是一个`Map<String, Object>`，可能看起来像消息头。主要区别是它们的生命周期：属性在整个交换执行期间存在，而头信息仅限于消息的持续时间（并且消息在路由过程中可能会发生变化，因此在交换执行期间）。Camel本身可能为某些用例添加一些属性。
- en: Finally, we have the `in` and `out` messages.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有`in`和`out`消息。
- en: 'In Message: The `in` message is mandatory and always set. It''s the only message
    populated in the exchange with InOnlyMEP.'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入消息：`in`消息是必需的，并且总是被设置。它是唯一在交换中使用InOnlyMEP填充的消息。
- en: 'Out Message: The `out` message is optional and is only used with InOutMEP.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出消息：`out`消息是可选的，并且仅与InOutMEP一起使用。
- en: With InOutMEP, at the end of the processing of the exchange, the `out` message
    will be used and returned to the mediation beginner (the first endpoint of the
    routing who created the exchange).
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用InOutMEP，在交换处理结束时，将使用并返回`out`消息到中介开始者（创建交换的路由的第一个端点）。
- en: '![Exchange](img/3151EN_02_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Exchange](img/3151EN_02_02.jpg)'
- en: Camel context
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Camel上下文
- en: The Camel context is the runtime system and the loading container of all resources
    required for the execution of the routing. It keeps everything together to allow
    the user to execute the routing logic. When the context starts, it also starts
    various components and endpoints, and activates the routing rules.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Camel上下文是路由执行所需的所有资源的运行时系统和加载容器。它将所有内容组合在一起，使用户能够执行路由逻辑。当上下文启动时，它也会启动各种组件和端点，并激活路由规则。
- en: The Camel context is described by the `org.apache.camel.CamelContext` interface
    ([http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/CamelContext.html](http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/CamelContext.html)).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Camel上下文由`org.apache.camel.CamelContext`接口描述 ([http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/CamelContext.html](http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/CamelContext.html))。
- en: '![Camel context](img/3151EN_02_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![Camel context](img/3151EN_02_03.jpg)'
- en: 'A Camel context contains the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Camel上下文包含以下内容：
- en: The components and endpoints used in the routing (see later for the details
    about components and endpoints)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由中使用的组件和端点（稍后详细介绍组件和端点）
- en: The type converters used to transform a message of one type to another
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于将一种类型的消息转换为另一种类型的类型转换器
- en: The data formats used to define the format of a message body
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于定义消息体格式的数据格式
- en: The registry where Camel will look for the beans used in the routing
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Camel将查找用于路由的bean的注册表
- en: The languages describing expressions and predicates used in the routing by a
    language (xpath, xquery, PHP, and so on)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述路由中使用的表达式和谓词的语言（如xpath、xquery、PHP等）
- en: The routes definition itself allowing you to design your mediation logic
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由定义本身，允许您设计您的中介逻辑
- en: Most of these resources are automatically loaded by Camel for you; most of the
    time, as an end user, you specify the routes definitions. However, we will see
    in the next chapters that we can tweak the Camel context.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些资源中的大部分都是由Camel自动为您加载的；大多数情况下，作为最终用户，您指定路由定义。然而，我们将在下一章中看到，我们可以调整Camel上下文。
- en: A Camel context also has its own life cycle. As it's the runtime system of your
    routing, you have a control on this life cycle.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Camel上下文也有自己的生命周期。作为你的路由的运行时系统，你可以控制这个生命周期。
- en: A Camel context can be started, loading all resources needed and activating
    the routing logic.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Camel上下文可以被启动，加载所需的所有资源并激活路由逻辑。
- en: '![Camel context](img/3151EN_02_04.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![Camel context](img/3151EN_02_04.jpg)'
- en: 'Once started, a context can be stopped: it''s a cold stop. This means that
    all routes, components, endpoints, and other resources loaded by this context
    will be stopped, and all internal cache, metrics, and states will be lost.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，上下文可以被停止：这是一个冷启动。这意味着所有由该上下文加载的路由、组件、端点和其它资源都将停止，并且所有内部缓存、指标和状态都将丢失。
- en: 'Instead of stopped, from the started state, a context can be suspended. Suspend
    stops the routing of the messages, but keeps context resources loaded and the
    internal data (metrics, cache, states, and so on). That''s why a suspended context
    can return to the started state very quickly using resume: it just resumes the
    processing of the messages.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是停止，从启动状态，上下文可以被挂起。挂起停止消息的路由，但保持上下文资源加载和内部数据（指标、缓存、状态等）。这就是为什么挂起的上下文可以非常快速地使用恢复回到启动状态：它只是恢复了消息的处理。
- en: The end users are supposed to use only suspend and resume operations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最终用户应仅使用挂起和恢复操作。
- en: 'To restart a context, you can do the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要重启上下文，你可以执行以下操作：
- en: A hot restart using suspend operation first, and resume operation after. It's
    a fast restart, keeping all the internal data of the context.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先使用挂起操作进行热重启，然后进行恢复操作。这是一个快速重启，保持上下文的所有内部数据。
- en: A cold restart using the stop operation first, and the start operation later.
    In that case, all internal data (cache, states, and metrics) is lost.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用停止操作首先进行冷重启，然后进行启动操作。在这种情况下，所有内部数据（缓存、状态和指标）都会丢失。
- en: Both stop and resume operations will ensure that all inflight messages (messages
    currently in process) are completely processed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 停止和恢复操作都将确保所有正在处理的交换（当前正在处理的消息）被完全处理。
- en: Stopping or suspending a context will stop or suspend all the routing defined
    in this context. In order to guarantee a graceful and reliable shutdown of your
    routing, you can define a shutdown strategy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 停止或挂起上下文将停止或挂起在此上下文中定义的所有路由。为了确保路由的优雅和可靠关闭，你可以定义一个关闭策略。
- en: A shutdown strategy is described using the `org.apache.camel.spi.ShutdownStrategy`
    interface.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭策略是通过`org.apache.camel.spi.ShutdownStrategy`接口来描述的。
- en: Camel provides the `org.apache.camel.impl.DefaultShutdownStrategy` interface.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Camel提供了`org.apache.camel.impl.DefaultShutdownStrategy`接口。
- en: 'This default shutdown strategy works in two phases:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此默认关闭策略分为两个阶段：
- en: First, it does a graceful shutdown, by suspending or stopping all consumer (the
    first endpoint that creates the exchanges), and waiting for the completion of
    all inflight messages.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它通过挂起或停止所有消费者（第一个创建交换的端点）并等待所有未完成消息的完成来进行优雅关闭。
- en: After a timeout (5 minutes by default), if there are still some inflight messages,
    the strategy kills the exchanges, forcing a suspend or stop.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在超时（默认为5分钟）后，如果仍有未完成的交换，策略将终止交换，强制挂起或停止。
- en: We will see in the next chapters how to create and use our own shutdown strategy.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中看到如何创建和使用自己的关闭策略。
- en: Processor
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器
- en: A processor is a node in the routing which is able to use, create, or modify
    an incoming exchange. During routing, the exchanges flow from one processor to
    another. This means all Enterprise Integration Patterns (EIP) are implemented
    using processors in Camel. The exchanges get in and out of a processor by using
    components and endpoints, as we will see later in this chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器是路由中的一个节点，能够使用、创建或修改传入的交换。在路由过程中，交换从一台处理器流向另一台处理器。这意味着所有企业集成模式（EIP）都是通过Camel中的处理器实现的。交换通过使用组件和端点进入和离开处理器，正如我们将在本章后面看到的。
- en: 'A processor is described using the `org.apache.camel.Processor` interface.
    To create your own processor, you just have to implement the `Processor` interface
    and override the `process()` method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器是通过`org.apache.camel.Processor`接口来描述的。要创建自己的处理器，你只需实现`Processor`接口并重写`process()`方法：
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support
    ) and register to have the files e-mailed directly to you.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有Packt出版物的账户中下载示例代码文件[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给你。
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Thanks to the `Exchange` argument of the `process()` method, you have complete
    access to the exchange: in and out messages, properties, and so on.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`process()`方法的`Exchange`参数，你可以完全访问交换：输入和输出消息、属性等。
- en: The `exchange.getIn()` gets the `in` message of the current exchange. As we
    want to get the body of this message, we use the `getBody()` method. This method
    accepts a type argument, casting the body in the destination class (a string in
    our example).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`exchange.getIn()`获取当前交换的`in`消息。由于我们想要获取此消息的主体，我们使用`getBody()`方法。此方法接受一个类型参数，将主体转换为目的地类（在我们的例子中是一个字符串）。'
- en: Routes
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: 'The Camel route is the routing definition. It''s a graph of processors. The
    routes (routing definition) are loaded in the Camel context. The execution and
    flow of the exchange in a route is performed by the routing engine. The routes
    are used to decouple clients from servers, and producers from consumers: an exchange
    consumer doesn''t know where the exchange comes from, and on the other hand an
    exchange producer doesn''t know the destination of the exchange. Thanks to that,
    it provides a flexible way to add extra processing or change the routing with
    limited impact on the logic.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Camel路由是路由定义。它是一个处理器图。路由（路由定义）在Camel上下文中加载。路由中交换的执行和流程由路由引擎执行。路由用于解耦客户端和服务器，以及生产者和消费者：一个交换消费者不知道交换来自哪里，另一方面，一个交换生产者不知道交换的目的地。正因为如此，它提供了一种灵活的方式来添加额外的处理或更改路由，对逻辑的影响最小。
- en: Each route has a unique identifier that you can specify (or Camel will create
    one for you). This identifier is used to easily find the route, especially when
    you want to log, debug, monitor, or manage a route (start or stop).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每个路由都有一个唯一的标识符，您可以指定（或者Camel会为您创建一个）。这个标识符用于轻松找到路由，尤其是在您想要记录、调试、监控或管理路由（启动或停止）时。
- en: 'A route has exactly one input source (the input endpoint). A route has a life
    cycle similar to the Camel context with the same states: started, stopped, and
    suspended. To Camel, a context controls the life cycle of the routes that it contains.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个路由恰好有一个输入源（输入端点）。一个路由有一个类似于Camel上下文的生命周期，具有相同的状态：启动、停止和挂起。对Camel来说，上下文控制其包含的路由的生命周期。
- en: Channels
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通道
- en: In every Camel route, there is a channel that sits between each processor in
    the route graph. It's responsible for the routing of an Exchange to the next Processor
    in the graph. The channel acts as a controller that monitors and controls the
    routing at runtime. It allows Camel to enrich the route with interceptors. For
    instance, the Camel tracer or the error handling are functionalities implemented
    using an interceptor on the channel.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个Camel路由中，都有一个通道位于路由图中的每个处理器之间。它负责将交换路由到图中的下一个处理器。通道充当控制器，在运行时监控和控制路由。它允许Camel通过通道上的拦截器丰富路由。例如，Camel跟踪器或错误处理都是使用通道上的拦截器实现的函数。
- en: The channel is described by the `org.apache.camel.Channel` interface. You can
    configure your own interceptor on the channels by describing it in Camel context.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通道由`org.apache.camel.Channel`接口描述。您可以通过在Camel上下文中描述它来在通道上配置自己的拦截器。
- en: 'Camel supports three kinds of interceptors on the channels:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Camel支持在通道上使用三种类型的拦截器：
- en: 'Global interceptors: This intercepts all exchanges on the channels'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局拦截器：这拦截了通道上的所有交换
- en: 'Interceptors on the incoming exchanges: This has limited the scope of the interceptor
    only on the first channel (the one just after the first endpoint)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在传入交换上的拦截器：这限制了拦截器的范围仅限于第一个通道（第一个端点之后的那个）
- en: 'Interceptors on the exchanges going to one specific endpoint: This limits the
    interceptor to the channel just before a given endpoint'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前往特定端点的交换上的拦截器：这限制了拦截器仅限于给定端点之前的通道
- en: Domain Specific Languages (DSL)
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域特定语言（DSL）
- en: Using the Camel API directly would need you to write a lot of plumbing code.
    You will need to create all the objects and load a lot of objects into different
    ones.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用Camel API将需要您编写大量的管道代码。您需要创建所有对象并将许多对象加载到不同的对象中。
- en: Therefore, the direct usage of API would be very time consuming. Moreover, as
    a flexible and easy-to-use integration framework, Camel doesn't have to force
    the use of one language (Java) to write the routing logic. Users may not be familiar
    with Java and might prefer to write their routing logic using another language.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，直接使用API将非常耗时。此外，作为一个灵活且易于使用的集成框架，Camel不需要强制使用一种语言（Java）来编写路由逻辑。用户可能不熟悉Java，可能更喜欢使用其他语言来编写他们的路由逻辑。
- en: 'That''s why Camel provides a set of languages to directly write the routes:
    the Camel Domain Specific Languages (DSL).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，Camel提供了一套语言，可以直接编写路由：Camel领域特定语言（DSL）。
- en: Using a DSL, the user directly writes their routes and describes the Camel context
    using a DSL. Camel will load and interpret the DSL to create and instantiate all
    the objects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DSL，用户可以直接编写他们的路由，并使用 DSL 描述 Camel 上下文。Camel 将加载并解释 DSL 以创建和实例化所有对象。
- en: The DSL is used to wire processors and endpoints together to define and form
    routes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: DSL 用于将处理器和端点连接起来，以定义和形成路由。
- en: 'Using a DSL, you mostly define the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DSL，您主要定义以下内容：
- en: The Camel context containing the routing rule base and resources
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含路由规则库和资源的 Camel 上下文
- en: The routes definition
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由定义
- en: 'Camel supports the following DSL:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Camel 支持以下 DSL：
- en: Java DSL, allowing you to define the routes using a fluent Java API
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java DSL，允许您使用流畅的 Java API 定义路由
- en: Spring XML, allowing you to define the routes using XML and the Spring framework
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring XML，允许您使用 XML 和 Spring 框架定义路由
- en: Blueprint XML is similar to Spring XML but uses OSGi Blueprint instead of the
    Spring framework
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blueprint XML 与 Spring XML 类似，但使用 OSGi Blueprint 而不是 Spring 框架
- en: REST DSL, allowing you to define the routes using a REST style API (in Java
    or XML)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST DSL，允许您使用 REST 风格的 API（在 Java 或 XML 中）定义路由
- en: Groovy DSL, allowing you to define the routes using the Groovy language
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Groovy DSL，允许您使用 Groovy 语言定义路由
- en: Scala DSL, allowing you to define the routes using the Scala language
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala DSL，允许您使用 Scala 语言定义路由
- en: Annotation DSL, allowing you to define the routes directly using annotations
    on Beans
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解 DSL，允许您直接使用 Bean 上的注解定义路由
- en: The following routes are exactly the same, but written using two different DSLs.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下路由完全相同，但使用了两种不同的 DSL 编写。
- en: 'Using Java DSL:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Java DSL：
- en: '[PRE1]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using Spring or Blueprint DSL:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Spring 或 Blueprint DSL：
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Component, endpoint, producer, and consumer
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件、端点、生产者和消费者
- en: 'The components are the main extension points in Camel. We don''t directly use
    a component in a route, we define an endpoint from the component. This means a
    component acts as a factory for endpoints as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是 Camel 的主要扩展点。我们不在路由中直接使用组件，而是从组件中定义一个端点。这意味着组件充当端点的工厂，如下所示：
- en: First, you load the component in the Camel context
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，您在 Camel 上下文中加载组件
- en: Then, in the route definition, you define an endpoint on a component loaded
    in the Camel context
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在路由定义中，你定义了一个在 Camel 上下文中加载的组件上的端点
- en: You can explicitly instantiate a component and load it in the Camel context
    (using code), or Camel will try to create and load the component (discover) for
    you based on the endpoint definition.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以显式实例化一个组件并将其加载到 Camel 上下文中（使用代码），或者 Camel 将根据端点定义尝试为您创建和加载组件（发现）。
- en: Camel provides about 100 components (file, ftp, http, CXF, JMS, and so on) as
    you can see at [http://camel.apache.org/components.html](http://camel.apache.org/components.html).
    You can create your own component, as we will see in the next chapters.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Camel 提供了大约 100 个组件（文件、ftp、http、CXF、JMS 等），如[http://camel.apache.org/components.html](http://camel.apache.org/components.html)所示。您可以根据下一章的内容创建自己的组件。
- en: Using a component, we create the endpoints. An endpoint represents the end of
    a channel through which an external system can send or receive messages. It allows
    your Camel route to communicate with the environment.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件，我们创建端点。端点代表外部系统可以通过其发送或接收消息的通道的末端。它允许您的 Camel 路由与外部环境进行通信。
- en: '![Component, endpoint, producer, and consumer](img/3151EN_02_05.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![组件、端点、生产者和消费者](img/3151EN_02_05.jpg)'
- en: 'Depending on the location in the route, an endpoint can act as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 根据路由中的位置，端点可以如下操作：
- en: A producer receives a Camel Exchange, transforms it into an external message
    and communicates (sends the message) to the external system (environment)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产者接收 Camel 交换，将其转换为外部消息，并与外部系统（环境）进行通信（发送消息）
- en: A consumer receives a message from an external system (environment), wraps it
    as a Camel Exchange, and sends to the route
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者从外部系统（环境）接收消息，将其包装为 Camel 交换，并发送到路由
- en: 'We identify two kinds of consumers:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们识别两种类型的消费者：
- en: Event Driven Consumers who will listen for incoming messages and create a Camel
    exchange at this time. For instance, consumer endpoints using the CXF component
    will **react** when they receive a SOAP Request.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动的消费者将监听传入的消息，并在此时创建一个 Camel 交换。例如，使用 CXF 组件的消费者端点在接收到 SOAP 请求时会**响应**。
- en: Polling Consumers who periodically check for new resources and create a Camel
    exchange at this time. For instance, consumer endpoints using the File component
    will periodically poll the filesystem and create a Camel exchange for the new
    files.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮询消费者定期检查新资源，并在此时创建 Camel 交换。例如，使用文件组件的消费者端点将定期轮询文件系统，并为新文件创建 Camel 交换。
- en: 'The endpoints are described using a URI in the following format:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 端点使用以下格式的URI进行描述：
- en: '[PRE3]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For instance, we can define an endpoint of the file component using the following
    code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用以下代码定义文件组件的端点：
- en: '[PRE4]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At runtime, Camel will look up an endpoint based on the URI, check whether the
    component defined as prefix is in the Camel context (eventually load it, if it's
    not there), and use this component to actually create the endpoint.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，Camel 将根据 URI 查找端点，检查作为前缀定义的组件是否在 Camel 上下文中（如果不在，最终加载它），并使用此组件实际创建端点。
- en: Data format
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据格式
- en: Camel supports a pluggable data format allowing you to marshall and unmarshall
    the messages.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Camel 支持可插拔的数据格式，允许您 marshalling 和 unmarshalling 消息。
- en: 'For instance, if you receive an XML message from an endpoint, you can:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您从一个端点接收 XML 消息，您可以：
- en: Directly manipulate and transport the XML message in the route
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接在路由中操作和传输XML消息
- en: Translate the XML to a POJO using JAXB, for instance, JAXB is a data format
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JAXB 将 XML 转换为 POJO，例如，JAXB 是一种数据格式
- en: Unmarshalling allows you to use a data format to convert from a raw format (XML
    in the previous example) into a Java object. On the other hand, when you send
    an exchange to an endpoint, you can marshall the transported object into another
    format. You specify where you want to unmarshall or marshall and the data format
    to use.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 解析允许您使用数据格式将原始格式（如前例中的XML）转换为Java对象。另一方面，当您向端点发送交换时，您可以 marshalling 传输的对象到另一种格式。您指定要解解析或
    marshalling 的位置以及要使用的数据格式。
- en: 'For instance, you can consume an XML message from a JMS queue, unmarshall using
    JAXB, and send the resulting object to another JMS queue:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以从 JMS 队列中消费 XML 消息，使用 JAXB 解析，然后将结果对象发送到另一个 JMS 队列：
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can also unmarshall files containing a serialized object, and then marshall
    using JAXB to send the resulting XML message to a JMS queue:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以解析包含序列化对象的文件，然后使用 JAXB marshalling，将结果 XML 消息发送到 JMS 队列：
- en: '[PRE6]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Camel provides a lot of ready-to-use data formats:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Camel 提供了许多现成的数据格式：
- en: For JVM native serialization marshalling, you can use the serialization or Stringdata
    formats
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 JVM 原生序列化 marshalling，您可以使用序列化或 Stringdata 格式
- en: For object marshalling, you can use Avro, JSON, or Protobuf data formats
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于对象 marshalling，您可以使用 Avro、JSON 或 Protobuf 数据格式
- en: For XML data formats (marshalling and unmarshalling), you can use JAXB, XmlBeans,
    XStream, JiBX, or Castor libraries
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 XML 数据格式（marshalling 和 unmarshalling），您可以使用 JAXB、XmlBeans、XStream、JiBX 或
    Castor 库
- en: For XML or WebService marshalling, you can use the SOAP data format
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 XML 或 WebService marshalling，您可以使用 SOAP 数据格式
- en: For XML or JSON marshalling, you can use the XmlJson data format
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 XML 或 JSON marshalling，您可以使用 XmlJson 数据格式
- en: For flat data structure marshalling (CSV, DelimitedLength, and so on), you can
    use BeanIO, Bindy, CSV, EDI, or Flatpack data formats
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于平面数据结构 marshalling（CSV、DelimitedLength 等），您可以使用 BeanIO、Bindy、CSV、EDI 或 Flatpack
    数据格式
- en: For compression marshalling, you can use GZip or Zip data formats
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于压缩 marshalling，您可以使用 GZip 或 Zip 数据格式
- en: For security marshalling, you can use PGP, Crypto, or XML Sec data formats
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于安全 marshalling，您可以使用 PGP、Crypto 或 XML Sec 数据格式
- en: For other marshalling, you can use Base64, RSS, TidyMarkup (with HTML, for instance),
    or Syslog data formats
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于其他 marshalling，您可以使用 Base64、RSS、TidyMarkup（例如，带有 HTML）或 Syslog 数据格式
- en: You can also create your own data format, providing the custom marshalling and
    unmarshalling mechanism.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以创建自己的数据格式，提供自定义的 marshalling 和 unmarshalling 机制。
- en: Type converter
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换器
- en: Even without a data format, when you route a message from one endpoint to another,
    it's common to convert the body of the message from one type to another. For instance,
    in an exchange created by a file endpoint, the body of the in message will be
    an InputStream. Depending on the target endpoint or processor, we may want to
    convert this InputStream to a String.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有数据格式，当您从一个端点路由消息到另一个端点时，通常需要将消息体从一种类型转换为另一种类型。例如，在一个由文件端点创建的交换中，输入消息的体将是一个
    InputStream。根据目标端点或处理器，我们可能需要将这个 InputStream 转换为 String。
- en: When you use the `getBody()` method on a message, you can specify the expected
    type. Camel will use a type converter to try to convert the actual body of the
    message into the specified type.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在消息上使用 `getBody()` 方法时，您可以指定期望的类型。Camel 将使用类型转换器尝试将消息的实际体转换为指定的类型。
- en: 'For instance, in a processor, if you do the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个处理器中，如果您执行以下操作：
- en: '[PRE7]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Camel will try to convert the body of the in message into a DOM document. A
    type converter is defined by the `org.apache.camel.TypeConverter` interface. The
    type converters are loaded into the Camel context, in a type converter's registry.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Camel 将尝试将输入消息的体转换为 DOM 文档。类型转换器由 `org.apache.camel.TypeConverter` 接口定义。类型转换器被加载到
    Camel 上下文中，在类型转换器注册表中。
- en: 'The type converter''s registry contains the type converter with the supported
    types. In this registry, for each type converter, we have:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换器注册表包含支持类型的类型转换器。在这个注册表中，对于每个类型转换器，我们都有：
- en: The **source** type
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源**类型'
- en: The **destination** type
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**类型'
- en: The actual type converter instance
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际类型转换器实例
- en: 'For instance, we can add our own type converter in the Camel context as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在 Camel 上下文中添加自己的类型转换器，如下所示：
- en: '[PRE8]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see that the source type is `MyOrder`, the destination type is `String`,
    and to convert from a type `MyOrder` to `String`, I will use the `MyOrderTypeConverter()`
    method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到源类型是 `MyOrder`，目标类型是 `String`，要将类型 `MyOrder` 转换为 `String`，我将使用 `MyOrderTypeConverter()`
    方法。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We can see that even if the Camel core is light, the provided features are rich
    and it provides all the basics to extend Camel to match your needs.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，即使 Camel 核心很轻，提供的功能却很丰富，它提供了所有基本功能以扩展 Camel 来满足您的需求。
- en: This chapter is an introduction to the Camel core concepts. It allows you to
    easily understand the next chapters, where we will get into the details of Camel.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这章是 Camel 核心概念的介绍。它使您能够轻松理解下一章，我们将深入探讨 Camel 的细节。
