- en: Spring for Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于微服务的 Spring
- en: I don't know many Java developers who have never touched Spring Framework. Actually,
    it consists of so many projects and can be used with many other frameworks that
    sooner or later you will be forced to try it. Although experiences with Spring
    Boot are rather less common, it has quickly gained a lot of popularity. In comparison
    with Spring Framework, Spring Boot is a relatively new solution. Its actual version
    is 2, instead of 5 for Spring Framework. What was the purpose of its creation?
    What is the difference between a running application with Spring Boot instead
    of the standard Spring Framework way?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道很多 Java 开发者都接触过 Spring Framework。实际上，它由许多项目组成，可以与许多其他框架一起使用，所以迟早你都会被迫尝试它。尽管与
    Spring Boot 的接触经验相对较少，但它已经迅速获得了大量流行。与 Spring Framework 相比，Spring Boot 是一个相对较新的解决方案。它的实际版本是
    2，而不是 Spring Framework 的 5。它的创建目的是什么？与标准 Spring Framework 方式相比，使用 Spring Boot
    运行应用程序有什么区别？
- en: 'Topics we will cover in this chapter include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题包括：
- en: Using starters in order to enable additional features for the project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用启动器启用项目中的额外功能
- en: Using Spring Web library for implementing services that expose REST API methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Web 库实现暴露 REST API 方法的服务
- en: Customizing service configuration using properties and YAML files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性和YAML文件自定义服务配置
- en: Documenting and providing the specification for exposed REST endpoints
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为暴露的 REST 端点提供文档和规范
- en: Configuring health checks and monitoring features
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置健康检查和监控功能
- en: Using Spring Boot profiles to adapt the application to run in different modes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Boot 配置文件使应用程序适应不同模式运行
- en: Using ORM features for interacting with embedded and remote NoSQL databases
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ORM 功能与嵌入式和远程 NoSQL 数据库进行交互
- en: Introducing Spring Boot
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Spring Boot
- en: Spring Boot is dedicated to running standalone Spring applications, the same
    as simple Java applications, with the `java -jar` command. The basic thing that
    makes Spring Boot different than standard Spring configuration is simplicity.
    This simplicity is closely related to the first important term we need to know
    about, which is a starter. A **starter** is an artifact that can be included in
    the project dependencies. It does nothing more than provide a set of dependencies
    to other artifacts that have to be included in your application in order to achieve
    the desired functionality. A package delivered in that way is ready for use, which
    means that we don't have to configure anything to make it work. And that brings
    us to the second important term related to Spring Boot, auto-configuration. All
    artifacts included by the starters have default settings set, which can be easily
    overridden using properties or other types of starters. For example, if you include
    `spring-boot-starter-web` in your application dependencies it embeds a default
    web container and starts it on the default port during application startup. Looking
    forward, the default web container in Spring Boot is Tomcat, which starts on port `8080`.
    We can easily change this port by declaring the specified field in the application
    properties file and even change the web container by including `spring-boot-starter-jetty`
    or `spring-boot-starter-undertow` in our project dependencies.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 专为独立运行 Spring 应用程序而设计，与简单的 Java 应用程序一样，可通过 `java -jar` 命令运行。使 Spring
    Boot 与标准 Spring 配置不同的基本要素就是简单。这种简单与我们需要了解的第一个重要术语紧密相关，那就是“启动器”（starter）。“启动器”是一个可以包含在项目依赖中的工件。它所做的就是为其他必须包含在你应用程序中的工件提供一套依赖项，以实现所需的功能。以这种方式提供的包已准备好使用，这意味着我们不需要配置任何内容使其工作。这让我们想到了与
    Spring Boot 相关的第二个重要术语——自动配置。所有通过启动器包含的工件都设置了默认设置，这些设置可以通过属性或其他类型的启动器轻松覆盖。例如，如果你在你的应用程序依赖中包含了
    `spring-boot-starter-web`，它将在应用程序启动时嵌入默认的 Web 容器并在默认端口上启动它。展望未来，Spring Boot 中的默认
    Web 容器是 Tomcat，它在端口 `8080` 上启动。我们可以通过在应用程序属性文件中声明指定的字段轻松更改此端口，甚至可以通过在项目依赖中包含 `spring-boot-starter-jetty`
    或 `spring-boot-starter-undertow` 来更改 Web 容器。
- en: 'Let me say a few words more about starters. Their official naming pattern is
    `spring-boot-starter-*`, where `*` is the particular type of starter. There are
    plenty of starters available within Spring Boot, but I would like to give you
    a short briefing on the most popular of them, which have also been used in the
    examples provided in the following chapters of this book:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我再来说一下启动器。它们的官方命名模式是`spring-boot-starter-*`，其中`*`是启动器的特定类型。在Spring Boot中有许多启动器可用，但我想要给你简单介绍一下其中最受欢迎的几个，这些也在这本书的后续章节中提供了示例：
- en: '| **Name** | **Description** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** |'
- en: '| `spring-boot-starter` | Core starter, including auto-configuration support,
    logging, and YAML. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter` | 核心启动器，包括自动配置支持、日志和YAML。|'
- en: '| `spring-boot-starter-web` | Allows us to build web applications, including
    RESTful and Spring MVC. Uses Tomcat as the default embedded container. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-web` | 允许我们构建Web应用程序，包括RESTful和Spring MVC。使用Tomcat作为默认的嵌入式容器。|'
- en: '| `spring-boot-starter-jetty` | Includes Jetty in the project and sets it as
    the default embedded servlet container. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-jetty` | 在项目中包含Jetty，并将其设置为默认的嵌入式servlet容器。|'
- en: '| `spring-boot-starter-undertow` | Includes Undertow in the project and sets
    it as the default embedded servlet container. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-undertow` | 在项目中包含Undertow，并将其设置为默认的嵌入式servlet容器。|'
- en: '| `spring-boot-starter-tomcat` | Includes Tomcat as the embedded servlet container.
    The default servlet container starter used by `spring-boot-starter-web`. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-tomcat` | 包含Tomcat作为嵌入式servlet容器。`spring-boot-starter-web`默认使用的servlet容器启动器。|'
- en: '| `spring-boot-starter-actuator` | Includes Spring Boot Actuator in the project,
    which provides features for monitoring and managing applications. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-actuator` | 包含Spring Boot Actuator，为应用程序提供监控和管理功能。|'
- en: '| `spring-boot-starter-jdbc` | Includes Spring JBDC with the Tomcat connection
    pool. The driver for the specific database should be provided by yourself. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-jdbc` | 包含Spring JBDC和Tomcat连接池。特定数据库的驱动应由您自己提供。|'
- en: '| `spring-boot-starter-data-jpa` | Includes all artifacts needed for interaction
    with relational databases using JPA/Hibernate. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-data-jpa` | 包含用于与关系型数据库使用JPA/Hibernate交互的所有工件。|'
- en: '| `spring-boot-starter-data-mongodb` | Includes all artifacts needed for interaction
    with MongoDB and initializing a client connection to Mongo on localhost.   |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-data-mongodb` | 包含与MongoDB交互所需的所有工件，并在本地主机上初始化Mongo客户端连接。|'
- en: '| `spring-boot-starter-security` | Includes Spring Security in the project
    and enables basic security for applications by default. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-security` | 将Spring Security包含在项目中，默认启用应用程序的基本安全性。|'
- en: '| `spring-boot-starter-test` | Allows the creation of unit tests using such
    libraries as JUnit, Hamcrest, and Mockito. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-test` | 允许使用如JUnit、Hamcrest和Mockito等库创建单元测试。|'
- en: '| `spring-boot-starter-amqp` | Includes Spring AMQP to the project and starts
    RabbitMQ as the default AMQP broker. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-amqp` | 将Spring AMQP包含在项目中，并作为默认的AMQP经纪人启动RabbitMQ。|'
- en: If you are interested in the full list of available starters, refer to the Spring
    Boot specification. Now, let's get back to the main differences between Spring
    Boot and standard configuration with Spring Framework. Like I mentioned before
    we can include `spring-boot-starter-web`, which embeds a web container into our
    application. With standard Spring configuration, we do not embed a web container
    into the application, but deploy it as a WAR file on the web container. This is
    a key difference and one of the most important reasons that Spring Boot is used
    for creating applications deployed inside microservice architecture. One of the
    main features of microservices is independence from other microservices. In this
    case, it is clear that they should not share common resources, such as databases
    or web containers. Deploying many WAR files on one web container is an anti-pattern
    for microservices. Spring Boot is, therefore, the obvious choice.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对可用的启动器完整列表感兴趣，请参考Spring Boot规范。现在，让我们回到Spring Boot与Spring Framework标准配置之间的主要区别。正如我之前提到的，我们可以包含`spring-boot-starter-web`，它将Web容器嵌入到我们的应用程序中。使用标准的Spring配置，我们不会将Web容器嵌入应用程序中，而是将其作为WAR文件部署在Web容器上。这是Spring
    Boot用于创建部署在微服务架构中的应用程序的重要原因之一。微服务的一个主要特性是与其它微服务的独立性。在这种情况下，很明显，它们不应该共享常见的资源，如数据库或Web容器。在一个Web容器上部署许多WAR文件是微服务的反模式。因此，Spring
    Boot是明显的选择。
- en: 'Personally, I have used Spring Boot while developing many applications, not
    only when working in a microservice environment. If you try it instead of standard
    Spring Framework configuration, you will not want to go back. In support of that
    conclusion you can find an interesting diagram that illustrates the popularity
    of Java frameworks repositories on GitHub: [http://redmonk.com/fryan/files/2017/06/java-tier1-relbar-20170622-logo.png](http://redmonk.com/fryan/files/2017/06/java-tier1-relbar-20170622-logo.png).
    Let''s take a closer look at how to develop applications with Spring Boot.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我在开发许多应用程序时使用了Spring Boot，不仅是在微服务环境中工作。如果你尝试用它代替标准的Spring Framework配置，你将不希望回到过去。支持这个结论，你可以在GitHub上找到一个有趣的图表，展示了Java框架仓库的流行度：[http://redmonk.com/fryan/files/2017/06/java-tier1-relbar-20170622-logo.png](http://redmonk.com/fryan/files/2017/06/java-tier1-relbar-20170622-logo.png)。让我们仔细看看如何使用Spring
    Boot开发应用程序。
- en: Developing applications with Spring Boot
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Boot开发应用程序
- en: 'The recommended way to enable Spring Boot in your project is by using a dependency
    management system. Here, you can see a short snippet of how to include appropriate
    artifacts in your Maven and Gradle projects. Here is a sample fragment from the
    Maven `pom.xml`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中启用Spring Boot的推荐方式是使用一个依赖管理系统。在这里，你可以看到一个简短的片段，展示了如何在你的Maven和Gradle项目中包含适当的工件。以下是Maven
    `pom.xml`的一个示例片段：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With Gradle, we do not need to define parent dependency. Here''s a fragment
    from `build.gradle`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Gradle，我们不需要定义父级依赖。以下是`build.gradle`的一个片段：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When using Maven, it is not necessary to inherit from the `spring-boot-starter-parent`
    POM. Alternatively, we can use the dependency management mechanism:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Maven时，继承`spring-boot-starter-parent` POM并不是必要的。另外，我们可以使用依赖管理机制：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, all we need is to create the main application class and annotate it with `@SpringBootApplication`,
    which is an equivalent to three other annotations used together—`@Configuration`,
    `@EnableAutoConfiguration`, and `@ComponentScan`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要的只是创建一个主应用程序类并给它加上`@SpringBootApplication`注解，这个注解相当于其他三个注解的组合——`@Configuration`、`@EnableAutoConfiguration`和`@ComponentScan`：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we have the main class declared and `spring-boot-starter-web` included,
    we only need to run our first application. If you use a development IDE, such
    as Eclipse or IntelliJ, you should just run your main class. Otherwise, the application
    has to be built and run like a standard Java application with the `java -jar`
    command. First, we should provide the configuration that is responsible for packaging
    all dependencies into an executable JAR (sometimes called **fat JARs**) during
    application build. This action would be performed by `spring-boot-maven-plugin`
    if it is defined in the Maven `pom.xml`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们声明了主类并包括了`spring-boot-starter-web`，我们只需要运行我们的第一个应用程序。如果你使用一个开发IDE，比如Eclipse或IntelliJ，你应该直接运行你的主类。否则，应用程序必须像标准的Java应用程序一样使用`java
    -jar`命令进行构建和运行。首先，我们应该提供负责在应用程序构建过程中将所有依赖项打包成可执行JAR（有时被称为**胖JAR**）的配置。如果定义在Maven
    `pom.xml`中，这个操作将由`spring-boot-maven-plugin`执行：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The sample application does nothing more than start a Spring context on the
    Tomcat container, which is available on port `8080`. The fat JAR is about 14 MB
    in size. You can easily, using an IDE, check out which libraries are included
    in the project. These are all basic Spring libraries, such as `spring-core`, `spring-aop`, `spring-context`;
    Spring Boot; Tomcat embedded; libraries for logging including Logback, Log4j,
    and Slf4j; and Jackson libraries used for JSON serialization or deserialization.
    A good idea is to set the default Java version for the project. You can easily
    set it up in `pom.xml` by declaring the `java.version` property:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序所做的不仅仅是启动在Tomcat容器上的Spring上下文，该容器在端口`8080`上可用。胖JAR的大小约为14 MB。你可以很容易地，使用IDE，查看项目中包含了哪些库。这些都是基本的Spring库，如`spring-core`、`spring-aop`、`spring-context`；Spring
    Boot；Tomcat嵌入式；包括Logback、Log4j和Slf4j在内的日志库；以及用于JSON序列化或反序列化的Jackson库。一个好的建议是为项目设置默认的Java版本。你可以在`pom.xml`中很容易地设置它，通过声明`java.version`属性：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can change the default web container just by adding a new dependency, for
    example, to the Jetty server:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加一个新的依赖项来更改默认的Web容器，例如，使用Jetty服务器：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Customizing configuration files
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制配置文件
- en: 'It''s one thing to have the ability to create applications quickly and without
    a huge volume of work, but no less important is the ability to easily customize
    and override default settings. Spring Boot comes in handy and provides mechanisms
    that enable configuration management. The simplest way to do that is using configuration
    files, which are appended to the application fat JAR. Spring Boot automatically
    detects configuration files whose name start with the `application` prefix. Supported
    file types are `.properties` and `.yml`. Therefore, we can create configuration
    files, such as `application.properties` or `application.yml`, and even including
    profile-specific files such as, `application-prod.properties` or `application-dev.yml`.
    Moreover, we can use OS environment variables and command-line arguments to externalize
    configuration. When using properties or YAML files, they should be placed in one
    of the following locations:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 快速且不需要大量工作来创建应用程序的能力固然重要，但同样重要的是能够轻松自定义和覆盖默认设置的能力。Spring Boot应运而生，并提供了实现配置管理的机制。实现这一点的最简单方法是使用配置文件，这些文件附加到应用程序的胖JAR中。Spring
    Boot会自动检测以`application`前缀开头的配置文件。支持的文件类型是`.properties`和`.yml`。因此，我们可以创建如`application.properties`或`application.yml`的配置文件，甚至包括特定于配置文件后缀的文件，如`application-prod.properties`或`application-dev.yml`。此外，我们还可以使用操作系统环境变量和命令行参数来外部化配置。当使用属性文件或YAML文件时，它们应该放置在以下位置之一：
- en: A `/config` subdirectory of the current application directory
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前应用程序目录的`/config`子目录
- en: The current application directory
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前应用程序目录
- en: A classpath `/config` package (for example, inside your JAR)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类路径上的`/config`包（例如，在你的JAR文件中）
- en: The classpath root
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类路径根目录
- en: 'If you would like to give a specific name to your configuration file, other
    than application or `application-{profile}`, you need to provide a `spring.config.name`
    environment property during startup. You can also use the `spring.config.location`
    property, which contains a comma-separated list of directory locations or file
    paths:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想给你的配置文件指定一个特定的名字，除了`application`或者`application-{profile}`之外，你需要在启动时提供一个`spring.config.name`环境属性。你也可以使用`spring.config.location`属性，它包含一个由逗号分隔的目录位置或文件路径列表：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Inside configuration files, we can define two types of properties. First, there
    is a group of common, predefined Spring Boot properties consumed by the underlying
    classes mostly from the `spring-boot-autoconfigure` library. We can also define
    our own custom configuration properties, which are then injected into the application
    using the `@Value` or `@ConfigurationProperties` annotations.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置文件内部，我们可以定义两种类型的属性。首先是一组通用的、预定义的Spring Boot属性，这些属性通常由底层的类从`spring-boot-autoconfigure`库中消费。我们也可以定义我们自己的自定义配置属性，然后使用`@Value`或`@ConfigurationProperties`注解将它们注入到应用程序中。
- en: 'Let''s begin with the predefined properties. The full list of supported by
    the Spring Boot project is available in their documentation in *Appendix A**,* in
    the *Common application properties* section. Most of them are specific to certain
    Spring modules, such as databases, web servers, security, and some other solutions,
    but there is also a group of core properties. Personally, I prefer using YAML
    instead of properties files because it is easily readable by humans, but the decision
    is yours. Most commonly, I override such properties as application name, which
    is used for service discovery and distributed configuration management; web server
    port; logging; or database connection settings. Usually, `application.yml` file
    is placed in the `src/main/resources` directory, which is then located in the
    JAR root directory after the Maven build. Here''s a sample configuration file,
    which overrides default server port, application name, and logging properties:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来看看预定义的属性。Spring Boot项目支持的全部属性在其文档中的*附录A*，*通用应用程序属性*部分中列出。其中大部分是特定于某些Spring模块的，如数据库、网络服务器、安全和一些其他解决方案，但也有一组核心属性。我个人更喜欢使用YAML而不是属性文件，因为它可以很容易地被人类阅读，但最终决定权在你。通常，我会覆盖如应用程序名称、用于服务发现和分布式配置管理的网络服务器端口、日志记录或数据库连接设置等属性。通常，`application.yml`文件放在`src/main/resources`目录中，在Maven构建后，该目录位于JAR根目录中。这是一个覆盖默认服务器端口、应用程序名称和日志记录属性的示例配置文件：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The one really cool thing here is that you don't have to define any other external
    configuration files, for example, `log4j.xml` or `logback.xml`, for logging configuration.
    In the previous fragment, you can see that I changed the default log level for
    `org.springframework.web` to `DEBUG` and log patterns, and created a log file, `app.log`,
    placed in the current application directory. Now, the default application name
    is `first-service` and the default HTTP port is `2222`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里真正酷的一点是，你不需要定义任何其他外部配置文件，例如`log4j.xml`或`logback.xml`，用于日志配置。在前一部分，你可以看到我将`org.springframework.web`的默认日志级别更改为`DEBUG`，并修改了日志模式，创建了一个日志文件`app.log`，放在当前应用程序目录中。现在，默认的应用程序名是`first-service`，默认的HTTP端口是`2222`。
- en: 'Our custom configuration settings should also be placed in the same properties
    or YAML files. Here''s a sample `application.yml` with custom properties:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义配置设置也应该放在相同的属性或YAML文件中。以下是带有自定义属性的一个`application.yml`样本：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A simple property can be injected using the `@Value` annotation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`@Value`注解注入一个简单的属性：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There is also the ability to inject more complex configuration properties using
    the `@ConfigurationProperties` annotation. The list of values defined in the `my.servers`
    property inside the YAML file was injected to the target bean of type `java.util.List`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`@ConfigurationProperties`注解注入更复杂的配置属性。YAML文件中`my.servers`属性定义的值被注入到目标bean类型`java.util.List`中：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So far, we have managed to create a simple application that does nothing more
    than start Spring on a web container such as Tomcat or Jetty. In this part of
    the chapter, I wanted to show you how simple it is to start application development
    using Spring Boot. Apart from that, I have described how to customize configuration
    using YAML or properties files. For those people who prefer clicking to typing,
    I recommend the Spring Initializr website ([https://start.spring.io/](https://start.spring.io/)),
    where you can generate the project stub based on options you choose. In the simple
    site view, you can choose build tools (Maven/Gradle), language (Java/Kotlin/Groovy),
    and Spring Boot version. Then, you should provide all necessary dependencies using
    the search engine following the Search for dependencies label. I included `spring-boot-starter-web`,
    which is just labeled as `Web` on Spring Initializr as you see in the following
    screenshot. After clicking on Generate project, the ZIP file with the generated
    source code gets downloaded onto your computer. You might also be interested in
    knowing that by clicking Switch to the full version, you are able to see almost
    all available Spring Boot and Spring Cloud libraries, which can be included in
    the generated project:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功创建了一个简单的应用程序，它所做的只是在一个诸如Tomcat或Jetty的web容器上启动Spring。在本章的这部分，我想向您展示使用Spring
    Boot开始应用程序开发是多么简单。除此之外，我还描述了如何使用YAML或属性文件自定义配置。对于那些喜欢点击而不是打字的人来说，我推荐使用Spring Initializr网站([https://start.spring.io/](https://start.spring.io/)），你可以在该网站上根据你选择的选项生成项目骨架。在简单视图中，你可以选择构建工具（Maven/Gradle）、语言（Java/Kotlin/Groovy）和Spring
    Boot版本。然后，你应该使用搜索引擎根据“搜索依赖项”标签提供所有必要的依赖项。我在其中包含了`spring-boot-starter-web`，正如你在下面的截图中看到的，在Spring
    Initializr上它只被标记为`Web`。点击“生成项目”后，生成的源代码的ZIP文件会被下载到你的电脑上。你可能还想知道，通过点击“切换到完整版本”，你可以看到Spring
    Boot和Spring Cloud几乎所有的库，这些库可以包含在生成的项目中：
- en: '![](img/557eaa38-1948-4896-88cf-48587b8e60d8.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/557eaa38-1948-4896-88cf-48587b8e60d8.png)'
- en: I think that, since we have been going over the basics about building projects
    using Spring Boot, this is the right time to add some new features to our sample
    application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为，既然我们已经复习了使用Spring Boot构建项目的基础知识，现在为我们的示例应用程序添加一些新功能正是时候。
- en: Creating RESTful Web Services
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建RESTful Web服务
- en: 'As a first step, let''s create RESTful Web Services exposing some data to the
    calling clients. As mentioned before, the Jackson library, which is responsible
    for the serialization and deserialization of JSON messages, is automatically included
    in our classpath together with `spring-boot-starter-web`. Thanks to that, we don''t
    have to do anything more than declare a model class, which is then returned or
    taken as a parameter by REST methods. Here''s our sample model class, `Person`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，让我们创建一些面向调用客户端的RESTful Web服务。正如前面提到的，负责JSON消息序列化和反序列化的Jackson库，已经自动包含在我们的类路径中，与`spring-boot-starter-web`一起。因此，我们除了声明一个模型类之外，不需要做更多的操作，该模型类随后由REST方法返回或作为参数接收。以下是我们的示例模型类`Person`：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Spring Web provides some annotations for creating RESTful Web Services. The
    first of them is the `@RestController` annotation, which should be set on your
    controller bean class that is responsible for handling incoming HTTP requests.
    There is also the `@RequestMapping` annotation, which is usually used for mapping
    controller methods to HTTP. As you see in the following code fragment, it can
    be used on the whole controller class to set the request path for all methods
    inside it. We can use more specific annotations for the concrete HTTP methods
    such as `@GetMapping` or `@PostMapping`.  `@GetMapping` is the same as `@RequestMapping`
    with the parameter `method=RequestMethod.GET`. Two other commonly used annotations
    are `@RequestParam` and `@RequestBody`. The first binds path and query params
    to objects; the second maps input JSON to objects using the Jackson library:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Web提供了一些用于创建RESTful Web服务的注解。首先是`@RestController`注解，它应该设置在你负责处理传入HTTP请求的控制器bean类上。还有`@RequestMapping`注解，通常用于将控制器方法映射到HTTP。正如你在下面的代码片段中所看到的，它可以用在整个控制器类上，为其中的所有方法设置请求路径。我们可以使用更具体的注解为具体的HTTP方法
    such as `@GetMapping`或`@PostMapping`。`@GetMapping`与`@RequestMapping`参数`method=RequestMethod.GET`相同。另外两个常用的注解是`@RequestParam`和`@RequestBody`。第一个将路径和查询参数绑定到对象；第二个使用Jackson库将输入JSON映射到对象：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To be compatible with REST API standards, we should handle `PUT` and `DELETE`
    methods. After their implementation, our service performs all CRUD operations:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与REST API标准兼容，我们应该处理`PUT`和`DELETE`方法。在它们的实现之后，我们的服务执行所有的CRUD操作：
- en: '| **Method** | **Path** | **Description** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **路径** | **描述** |'
- en: '| `GET` | `/person` | Returns all existing persons |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/person` | 返回所有现有的人员 |'
- en: '| `GET` | `/person/{id}` | Returns person with the given *id* |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/person/{id}` | 返回给定*id*的人员 |'
- en: '| `POST` | `/person` | Adds new person |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/person` | 添加新人员 |'
- en: '| `PUT` | `/person` | Updates existing person |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `/person` | 更新现有人员 |'
- en: '| `DELETE` | `/person/{id}` | Removes person from list using given *id* |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `/person/{id}` | 使用给定的*id*从列表中删除人员 |'
- en: 'Here''s a fragment of a sample `@RestController` implementation with the `DELETE`
    and `PUT` methods:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是带有`DELETE`和`PUT`方法的示例`@RestController`实现的片段：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The controller code is really simple. It stores all data in the local `java.util.List`,
    which is obviously not a good programming practice. However, treat that as a simplification
    adopted for the purposes of the basic example. In the section *Integrating application
    with database*, in this chapter, I'll cover more advanced sample application that
    integrates with the NoSQL database.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器代码非常简单。它将所有数据存储在本地`java.util.List`中，这显然不是一种好的编程实践。然而，将此视为为了基本示例而采用的简化。在本章的*将应用程序与数据库集成*部分，我将介绍一个更高级的示例应用程序，该应用程序集成了NoSQL数据库。
- en: Probably some of you have experience with SOAP Web Services. If we had created
    a similar service using SOAP instead of REST, we would provide a WSDL file for
    the client with all service definitions described. Unfortunately, REST doesn't
    support such standard notation as WSDL. In the initial stage of RESTful Web Services,
    it was said that **Web Application Description Language** (**WADL**) would perform
    that role. But the reality is that many providers, including Spring Web, do not
    generate WADL files after application startup. Why am I mentioning this? Well,
    we have already finished our first microservice, which exposes some REST operations
    over HTTP. You have probably run this microservice from your IDE or using the `java
    -jar` command after building the fat JAR. If you didn't change the configuration
    properties inside the `application.yml` file, or did not set the `-Dport` option
    while running the application, it is available under `http://localhost:2222`.
    In order to enable others to call our API, we have two choices. We can share a
    document describing its usage or mechanisms for automatic API client generation.
    Or both of them. That's where Swagger comes in.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有些同学有使用 SOAP Web 服务的经验。如果我们用 SOAP 而不是 REST 创建了一个类似的的服务，我们将为客户端提供一个 WSDL 文件，其中包含所有服务定义。不幸的是，REST
    不支持像 WSDL 这样的标准表示法。在 RESTful Web 服务的初期阶段，人们曾说过 **Web 应用程序描述语言**（**WADL**）将承担这一角色。但现实情况是，包括
    Spring Web 在内的许多提供者，在应用程序启动后并不会生成 WADL 文件。我为什么要提到这些呢？嗯，我们已经完成了我们的第一个微服务，它通过 HTTP
    暴露了一些 REST 操作。你可能在使用这个微服务时，在 IDE 中运行它，或者使用 `java -jar` 命令在构建完胖 JAR 之后运行它。如果你没有修改
    `application.yml` 文件中的配置属性，或者在运行应用程序时没有设置 `-Dport` 选项，那么它将在 `http://localhost:2222`
    上运行。为了使其他人调用我们的 API，我们有两个选择。我们可以分享一份描述其使用或自动生成 API 客户端机制的文档。或者两者都有。Swagger 就在这时介入了。
- en: API Documentation
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 文档
- en: Swagger is the most popular tool for designing, building, and documenting RESTful
    APIs. It has been created by SmartBear, the designers of a very popular tool for
    SOAP Web Services, SoapUI. I think that might be sufficient recommendation for
    those who have long experience with SOAP. Anyway, with Swagger, we can design
    APIs using notation and then generate source code from it, or the other way around,
    where we start with the source code and then generate a Swagger file. With Spring
    Boot, we use the second option.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swagger** 是设计、构建和文档化 RESTful API 的最受欢迎的工具。它是由 SoapUI（一个非常流行的 SOAP Web 服务工具）的设计者
    SmartBear 创建的。我认为这对于那些有丰富 SOAP 经验的人来说已经足够推荐了。无论如何，使用 Swagger，我们可以使用表示法设计 API 然后从它生成源代码，或者反过来，我们从源代码开始然后生成一个
    Swagger 文件。与 Spring Boot 一起，我们使用后一种方法。'
- en: Using Swagger 2 together with Spring Boot
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Swagger 2 与 Spring Boot 一起
- en: 'The integration between Spring Boot and Swagger 2 is realized by the Springfox
    project. It examines application at runtime to infer API semantics based on Spring
    configurations, class structure, and Java annotations. To use Swagger in conjunction
    with Spring, we need to add the following two dependencies to the Maven `pom.xml` and
    annotate the main application class with `@EnableSwagger2`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Boot** 与 **Swagger 2** 的集成是由 Springfox 项目实现的。它在运行时检查应用程序，以推断基于 Spring
    配置、类结构和 Java 注解的 API 语义。为了将 Swagger 与 Spring 结合使用，我们需要在 Maven `pom.xml` 中添加以下两个依赖，并用
    `@EnableSwagger2` 注解主应用类：'
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The API documentation will be automatically generated from the source code
    by the Swagger library during application startup. The process is controlled by
    the `Docket` bean, which is also declared in the main class. A nice idea might
    be to get the API version from the Maven `pom.xml` file. We can get it by including
    the `maven-model` library in the classpath and using the `MavenXpp3Reader` class.
    We also set some other properties, such as title, author, and description using
    the `apiInfo` method. By default, Swagger generates documentation for all REST
    services, including those created by Spring Boot. We would like to limit this
    documentation only to our `@RestController` located inside the `pl.piomin.services.boot.controller`
    package:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: API 文档将在应用程序启动时由 Swagger 库从源代码自动生成。这个过程由 `Docket` bean 控制，它也声明在主类中。一个好主意可能是从
    Maven `pom.xml` 文件中获取 API 版本。我们可以通过在类路径中包含 `maven-model` 库并使用 `MavenXpp3Reader`
    类来实现。我们还使用 `apiInfo` 方法设置一些其他属性，如标题、作者和描述。默认情况下，Swagger 为所有 REST 服务生成文档，包括由 Spring
    Boot 创建的服务。我们想要限制此文档只包含位于 `pl.piomin.services.boot.controller` 包内的 `@RestController`：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Testing API with Swagger UI
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Swagger UI 测试 API
- en: 'An API documentation dashboard is available at `http://localhost:2222/swagger-ui.html`
    after application startup. This is a more user-friendly version of the Swagger
    JSON definition file, which is also automatically generated and available at `http://localhost:2222/v2/api-docs`.
    That file can be imported by any other REST tools, for example, SoapUI:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序启动后，在`http://localhost:2222/swagger-ui.html`上提供了API文档仪表板。这是Swagger JSON定义文件的更用户友好的版本，也是自动生成的，并在`http://localhost:2222/v2/api-docs`上可用。该文件可以被其他REST工具导入，例如SoapUI：
- en: '![](img/596d9d1a-0019-43dd-b4c8-62222a248ba9.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/596d9d1a-0019-43dd-b4c8-62222a248ba9.png)'
- en: 'If you prefer SoapUI instead of Swagger UI, you can easily import the Swagger
    definition file by selecting Project | Import Swagger. Then, you need to provide
    a file address, as you can see in this screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢SoapUI而不是Swagger UI，你可以通过选择项目|导入Swagger来轻松导入Swagger定义文件。然后，你需要提供一个文件地址，正如你在这张截图中所看到的：
- en: '![](img/8cc43aa0-54b2-4fe5-b60f-3ac8f70ef909.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cc43aa0-54b2-4fe5-b60f-3ac8f70ef909.png)'
- en: 'Personally, I prefer Swagger UI. You can expand every API method to see their
    details. Every operation can be tested by providing the required parameters or
    JSON input, and clicking the Try it out! button. Here''s a screenshot illustrating
    sending a `POST /person` test request:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我更喜欢Swagger UI。你可以展开每个API方法以查看它们的详细信息。每个操作都可以通过提供所需的参数或JSON输入，并点击“尝试一下！”按钮来进行测试。这里有一张截图，展示了发送一个`POST
    /person`测试请求的情况：
- en: '![](img/05eff4f3-d1c5-46ab-86b2-5d61833a77c6.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05eff4f3-d1c5-46ab-86b2-5d61833a77c6.png)'
- en: 'Here''s the response screen:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是响应屏幕：
- en: '![](img/edd90841-af55-443e-b42c-53ed834daf17.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/edd90841-af55-443e-b42c-53ed834daf17.png)'
- en: Spring Boot Actuator features
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot Actuator功能
- en: 'Just creating the working application and sharing standardized API documentation
    is not everything, especially if we are talking about microservices, where there
    are plenty of independent entities structuring one managed environment. The next
    important thing that needs to be mentioned is monitoring and gathering metrics
    from applications. In that aspect, Spring Boot also comes through. Project Spring
    Boot Actuator provides a number of built-in endpoints, which allow us to monitor
    and interact with the application. To enable it in our project, we should include
    `spring-boot-starter-actuator` in the dependencies. Here''s a list of the most
    important Actuator endpoints:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅创建工作应用程序并分享标准的API文档是不够的，特别是当我们谈论微服务时，那里有很多独立的实体结构成一个受管理的环境。接下来需要提到的重要事情是监控和收集应用程序的度量信息。在这方面，Spring
    Boot也提供了支持。Spring Boot项目提供了许多内置端点，允许我们监控并与应用程序互动。为了在我们的项目中启用它，我们应该在依赖项中包含`spring-boot-starter-actuator`。以下是最重要的Actuator端点列表：
- en: '| **Path** | **Description** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **路径** | **描述** |'
- en: '| `/beans` | Displays a full list of all the Spring beans initialized in the
    application. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `/beans` | 显示应用程序中初始化的所有Spring bean的完整列表。 |'
- en: '| `/env` | Exposes properties from Spring’s Configurable Environment, which
    means, for example, OS environment variables and properties from configuration
    files. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `/env` | 暴露Spring的Configurable Environment中的属性，这意味着例如操作系统环境变量和配置文件中的属性。 |'
- en: '| `/health` | Shows application health information. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `/health` | 显示应用程序的健康信息。 |'
- en: '| `/info` | Displays arbitrary application information. It can be taken, for
    example, from the `build-info.properties` or `git.properties` files. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `/info` | 显示任意应用程序信息。它可以从例如`build-info.properties`或`git.properties`文件中获取。
    |'
- en: '| `/loggers` | Shows and modifies the configuration of loggers in the application.
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `/loggers` | 显示并修改应用程序中的日志记录器配置。 |'
- en: '| `/metrics` | Shows metrics information for the current application, such
    as memory usage, number of running threads, or REST method response time. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `/metrics` | 显示当前应用程序的度量信息，例如内存使用情况、运行线程数或REST方法响应时间。 |'
- en: '| `/trace` | Displays trace information (by default the last 100 HTTP requests).
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `/trace` | 显示跟踪信息（默认显示最后100个HTTP请求）。 |'
- en: 'Endpoints can be easily customized using Spring configuration properties. For
    example, we can disable one of the enabled by default endpoints. By default, all
    endpoints except for `shutdown` are enabled. Most of these endpoints are secured.
    If you would like to call them from your web browser, you should provide security
    credentials in the request header or disable security for the whole project. To
    do the latter, you have to include the following statement in your `application.yml`
    file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring配置属性，端点可以很容易地进行自定义。例如，我们可以禁用默认启用的端点中的一个。默认情况下，除了`shutdown`之外的所有端点都是启用的。其中大多数端点都是受保护的。如果你想要从网页浏览器中调用它们，你应在请求头中提供安全凭据，或者为整个项目禁用安全功能。要实现后者，你需要在你的`application.yml`文件中包含以下语句：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Application information
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序信息
- en: 'The full list of endpoints available for the project is visible in application
    logs during startup. After disabling security, you can test all of them in your
    web browser. It''s interesting that the `/info` endpoint does not provide any
    information by default. If you would like to change this, you might use one of
    the three available auto-configured `InfoContributor` beans or write your own.
    The first of them, `EnvironmentInfoContributor`, exposes environment keys in the
    endpoint. The second, `GitInfoContributor`, detects the `git.properties` file
    in the classpath and then displays all necessary information about commits, such
    as branch name or commit ID. The last one, named `BuildInfoContributor`, gathers
    information from the `META-INF/build-info.properties` file and also displays it
    in the endpoint. These two properties files for Git and build information can
    be automatically generated during application build. To achieve this, you should
    include `git-commit-id-plugin` in your `pom.xml` and customize `spring-boot-maven-plugin`
    to generate `build-info.properties` in the way visible in this code fragment:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 项目可用的端点完整列表在应用程序启动时的日志中可见。在禁用安全功能后，你可以在网页浏览器中测试它们全部。有趣的是，`/info`端点默认不提供任何信息。如果你想要改变这一点，你可以使用其中三个可用的自动配置`InfoContributor`
    bean中的一个，或者编写你自己的。第一个，`EnvironmentInfoContributor`，在端点中暴露环境键。第二个，`GitInfoContributor`，在类路径中检测`git.properties`文件，然后显示关于提交的所有必要信息，如分支名称或提交ID。最后一个，名为`BuildInfoContributor`，从`META-INF/build-info.properties`文件中收集信息，并在端点中也显示它。这两个用于Git和构建信息的属性文件可以在应用程序构建过程中自动生成。为了实现这一点，你应该在你的`pom.xml`中包含`git-commit-id-plugin`，并自定义`spring-boot-maven-plugin`以生成`build-info.properties`，如本代码片段中所见：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the `build-info.properties` file available, your `/info` would be a little
    different than before:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有了可用的`build-info.properties`文件，你的`/info`将和之前有点不同：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Health information
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康信息
- en: 'As with the `/info` endpoint, there are also some auto-configured indicators
    for the `/health` endpoint. We can monitor the status of disk usage, mail service,
    JMS, data sources, and NoSQL databases, such as MongoDB or Cassandra. If you check
    out that endpoint from our sample application, you only get the information about
    disk usage. Let''s add MongoDB to the project to test one of the available health
    indicators, `MongoHealthIndicator`. MongoDB is not a random selection. It will
    be useful for us in the future for a more advanced example of the `Person` microservice.
    To enable MongoDB use, we need to add the following dependencies to `pom.xml`.
    The `de.flapdoodle.embed.mongo` artifact is responsible for starting the embedded
    database instance during application startup:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与`/info`端点一样，`/health`端点也有一些自动配置的指标。我们可以监控磁盘使用情况、邮件服务、JMS、数据源以及NoSQL数据库（如MongoDB或Cassandra）的状态。如果你从我们的示例应用程序中检查该端点，你只能得到关于磁盘使用情况的信息。让我们在项目中添加MongoDB来测试其中一个可用的健康指标，`MongoHealthIndicator`。MongoDB并非随机选择。它在未来对于`Person`微服务的更高级示例中将很有用。为了启用MongoDB，我们需要在`pom.xml`中添加以下依赖项。`de.flapdoodle.embed.mongo`构件在应用程序启动期间负责启动嵌入式数据库实例：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, the `/health` endpoint returns information about disk usage and MongoDB
    status:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`/health`端点返回了关于磁盘使用情况和MongoDB状态的信息：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, we can see the power of Spring Boot auto-configuration. We
    didn't have to do anything more than include two dependencies to the project to
    enable embedded MongoDB. Its status has been automatically added to the `/health`
    endpoint. It also has a ready-to-use client connection to Mongo, which can be
    further used by the repository bean.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到Spring Boot自动配置的力量。我们只需要将两个依赖项添加到项目中，就可以启用嵌入式MongoDB。其状态已自动添加到`/health`端点。它还有一个对Mongo
    ready-to-use的客户端连接，这可以被进一步用于仓库bean。
- en: Metrics
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指标
- en: 'As we usually say, there is no such thing as a free lunch. Development is fast
    and easy, but after including some additional libraries in the project, the fat
    JAR file now has about 30 MB. Using one of the auto-configured actuator endpoints, `/metrics`,
    we can easily check out our microservice heap and non-heap memory usage. After
    sending some test requests, heap usage was about 140 MB and non-heap was 65 MB.
    Total memory usage for the application was about 320 MB. Of course, these values
    can be reduced a little even just by using the `-Xmx` parameter during startup
    with the `java -jar` command. However, we should not reduce this limit too much
    if we care about reliable working in production mode. Apart from memory usage,
    the `/metrics` endpoint displays information about the number of loaded classes,
    the number of active threads, the average duration of each API method, and a lot
    more. Here''s a fragment of the endpoint response for our sample microservice:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们通常所说的，没有免费的午餐。发展既快又容易，但在项目中包含一些额外的库后，庞大的JAR文件现在大约有30 MB。使用自动配置的actuator端点之一，`/metrics`，我们可以轻松查看微服务的堆内存和非堆内存使用情况。发送一些测试请求后，堆内存使用大约为140
    MB，非堆内存为65 MB。应用程序的总内存使用量约为320 MB。当然，即使只是使用`java -jar`命令启动时使用`-Xmx`参数，这些值也可以稍微降低。然而，如果我们关心在生产模式下的可靠工作，就不应该将此限制降低太多。除了内存使用情况外，`/metrics`端点还显示了加载的类数量、活动线程数、每个API方法的平均持续时间等信息。以下是我们示例微服务端点响应的一个片段：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There is the possibility to create our own custom metrics. Spring Boot Actuator
    provides two classes in case we would like to do that—`CounterService` and `GaugeService`.
    `CounterService`, as its name indicates, exposes methods for value incrementation,
    decrementation, and reset. By contrast, `GaugeService` is intended to just submit
    the current value. Default metrics for the API method calling statistics are a
    little imperfect because they are based only on the invoking path. There is no
    distinguishing between method types if they are available  on the same path. In
    our sample endpoint, this applies to `GET /person`, `POST /person`, and `PUT /person`.
    Anyway, I created the `PersonCounterService` bean, which counts the number of
    `add` and `delete` method calls:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能创建我们自己的自定义指标。Spring Boot Actuator提供了两个类，以便我们这样做——`CounterService`和`GaugeService`。正如其名称所暗示的，`CounterService`暴露了增加值、减少值和重置值的方法。相比之下，`GaugeService`旨在仅提交当前值。默认的API方法调用统计数据有点不完美，因为它们仅基于调用路径。如果它们在同一路径上可用，则无法区分方法类型。在我们的示例端点中，这适用于`GET
    /person`、`POST /person`和`PUT /person`。无论如何，我创建了`PersonCounterService` bean，用于计算`add`和`delete`方法调用的数量：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This bean needs to be injected into our REST controller bean, and the methods
    incrementing the counter value can be invoked when a person is added or removed:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个bean需要被注入到我们的REST控制器bean中，当一个人被添加或删除时，可以调用增加计数值的方法：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, if you display application metrics again, you will see the following two
    new fields in the JSON response:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你再次显示应用程序指标，你将在JSON响应中看到以下两个新字段：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: All metrics generated by the Spring Boot application may be exported from the
    in-memory buffers to a place where they can be analyzed and displayed. We can
    store them, for example, in Redis, Open TSDB, Statsd, or even InfluxDB.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所有由Spring Boot应用程序生成的指标都可以从内存缓冲区导出到一个可以分析和显示的地方。例如，我们可以将它们存储在Redis、Open TSDB、Statsd或甚至InfluxDB中。
- en: I think that's about all the details about built-in monitor endpoints I wanted
    to give you. I had designated a relatively large amount of space to such topics
    as documentation, metrics, and health checks, but in my opinion, these are the
    important aspects of microservice development and maintenance. Developers often
    do not care if these mechanisms are well implemented, but others often see our
    application just through the prism of those metrics, health checks and application's
    logs quality. Spring Boot provides such an implementation out of the box, and
    therefore developers do not have to spend much time enabling them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为关于内置监控端点的细节差不多就这些了。我为此类主题如文档、指标和健康检查分配了相对较多的空间，但在我看来，这些都是微服务开发和维护的重要方面。开发者通常不在乎这些机制是否实现得很好，但其他人通常只是通过这些指标、健康检查和应用程序日志的质量来看我们的应用程序。Spring
    Boot提供了这样的实现，因此开发者不必花太多时间来启用它们。
- en: Developer tools
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发者工具
- en: 'Spring Boot offers some other useful tools for developers. The really cool
    thing for me is that the application is automatically restarted whenever files
    on the project classpath change. If you use Eclipse as your IDE, the only thing
    you have to do to enable it is to add the `spring-boot-devtools` dependency to
    the Maven `pom.xml`. Then, try to change something in one of your classes and
    save it. The application automatically restarts, and it takes much less than stopping
    and starting in the standard way. When I start our sample application, it takes
    about 9 seconds, and automatic restart takes only 3 seconds:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 为开发者提供了其他一些有用的工具。对我来说真正酷的是，项目类路径上的文件发生变化时，应用程序会自动重新启动。如果你使用 Eclipse
    作为你的 IDE，要启用它，你只需要在 Maven 的 `pom.xml` 中添加 `spring-boot-devtools` 依赖。然后，尝试更改你其中一个类中的某个东西并保存它。应用程序会自动重新启动，而且所用时间远比标准方式停止和启动要少。当我启动我们的示例应用程序时，大约需要
    9 秒钟，而自动重启只需要 3 秒：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can exclude some resources if there is no need to trigger a restart when
    they are changed. By default, any file available on the classpath that points
    to a folder will be monitored for changes, even static assets or view templates,
    which do not need restarting. For example, if they are placed in the static folder,
    you can exclude them by adding the following property to the `application.yml`
    configuration file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要在更改时触发重启，我们可以排除一些资源。默认情况下，类路径上可用的任何指向文件夹的文件都将被监控以检测更改，即使是静态资产或视图模板，也不需要重新启动。例如，如果它们放在静态文件夹中，你可以在
    `application.yml` 配置文件中添加以下属性来排除它们：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Integrating application with database
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用程序与数据库集成
- en: You can find more interesting features described in the Spring Boot specification.
    I would like to spend more time describing other cool functionalities provided
    by that framework, but we should not go too far away from the main topic—Spring
    for microservices. As you may recall, through including embedded MongoDB in the
    project, I promised you a more advanced microservice example. Before starting
    to work on it, let's go back for a moment to the current version of our application.
    Its source code is available on my public GitHub account. Clone the following
    Git repository to your local machine: [https://github.com/piomin/sample-spring-boot-web.git](https://github.com/piomin/sample-spring-boot-web.git).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Spring Boot 规范中找到更多有趣的特性。我想花更多时间描述该框架提供的其他酷功能，但我们不应该偏离主题太远——Spring 用于微服务。正如你可能记得的，通过在项目中包含嵌入式
    MongoDB，我答应给你一个更高级的微服务示例。在开始处理它之前，让我们回到我们应用程序的当前版本。它的源代码可以在我的公共 GitHub 账户上找到。将以下
    Git 仓库克隆到你的本地机器：[https://github.com/piomin/sample-spring-boot-web.git](https://github.com/piomin/sample-spring-boot-web.git)。
- en: Building a sample application
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个示例应用程序
- en: 'The basic example is available in the `master` branch. The more advanced sample,
    with embedded MongoDB, is committed to the `mongo` branch. In case you would like
    to try running more advanced sample, you need to switch to that branch using `git
    checkout mongo`. Now, we need to perform some changes in the model class to enable
    object mapping to MongoDB. The model class has to be annotated with `@Document`
    and the primary key field with `@Id`. I also changed the ID field type from `Long`
    to `String` because MongoDB generates primary keys in UUID format, for example, `59d63385206b6d14b854a45c`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 基本示例可以在 `master` 分支中找到。带有嵌入式 MongoDB 的更高级示例提交到了 `mongo` 分支。如果你想尝试运行更高级的示例，你需要使用
    `git checkout mongo` 切换到那个分支。现在，我们需要在模型类中进行一些更改，以启用对 MongoDB 的对象映射。模型类必须用 `@Document`
    注解，主键字段用 `@Id` 注解。我还将 ID 字段类型从 `Long` 改为 `String`，因为 MongoDB 使用 UUID 格式的的主键，例如
    `59d63385206b6d14b854a45c`：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next step is to create a repository interface that extends `MongoRepository`.
    MongoRepository provides basic methods for searching and storing data, such as `findAll`,
    `findOne`, `save`, and `delete`. Spring Data has a very smart mechanism for performing
    queries using repository objects. We don''t have to implement queries by ourselves,
    but only define an interface method with the right name. The method name should
    have the prefix `findBy` and then the searched field name. It may end with a standard
    search keyword suffix, such as `GreaterThan`, `LassThan`, `Between`, `Like`, and
    many more. A MongoDB query is automatically generated by Spring Data classes based
    on the full method name. The same keywords may be used in conjunction with `delete…By`
    or `remove…By` to create remove queries. In the `PersonRepository` interface,
    I decided to define two find methods. The first of them, `findByLastName`, selects
    all `Person` entities with the given `lastName` value. The second, `findByAgeGreaterThan`,
    is designed to retrieve all `Person` entities with an age greater than a given
    value:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个扩展了`MongoRepository`的仓库接口。MongoRepository为搜索和存储数据提供了基本方法，如`findAll`、`findOne`、`save`和`delete`。Spring
    Data有一个非常智能的机制，利用仓库对象执行查询。我们不需要自己实现查询，只需定义一个命名正确的接口方法。该方法名应具有`findBy`前缀和搜索字段名。它可能以一个标准的搜索关键字后缀结束，如`GreaterThan`、`LessThan`、`Between`、`Like`等。基于完整的方法名，Spring
    Data类会自动生成MongoDB查询。相同的关键词可以与`delete…By`或`remove…By`结合使用，以创建删除查询。在`PersonRepository`接口中，我决定定义两个查找方法。第一个，`findByLastName`，选择所有给定`lastName`值的`Person`实体。第二个，`findByAgeGreaterThan`，旨在检索所有年龄大于给定值的`Person`实体：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The repository should be injected into the REST controller class. Then, we
    can finally call all the required CRUD methods provided by `PersonRepository`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库应该被注入到REST控制器类中。然后，我们终于可以调用`PersonRepository`提供的所有必需的CRUD方法：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We have also added two API methods for custom find operations from the `PersonRepository`
    bean:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了两个从`PersonRepository` bean自定义查找操作的API方法：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That's all that had to be done. Our microservice that exposes basic API methods
    implementing CRUD operations on an embedded Mongo database is ready to launch.
    You have probably noticed that it didn't require us to create a lot of source
    code. Implementation of any interaction with databases, whether relational or
    NoSQL, using Spring Data is fast and relatively easy. Anyway, there is still one
    more challenge facing us. An embedded database is a good choice, but only in development
    mode or for unit testing, not in production. If you have to run your microservice
    in production mode, you would probably launch one standalone instance or some
    instances of Mongo deployed as a sharded cluster, and connect the application
    to them. For our example purposes, I'll run a single instance of MongoDB using
    Docker.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这就做完了所有的事情。我们的微服务已经准备好启动，它暴露了实现对嵌入式Mongo数据库进行CRUD操作的基本API方法。你可能已经注意到，它并没有要求我们创建大量的源代码。使用Spring
    Data实现与数据库的任何交互，无论是关系型还是NoSQL，都是快速和相对简单的。无论如何，我们面前还有一个挑战。嵌入式数据库是一个不错的选择，但只适用于开发模式或单元测试，而不是生产模式。如果你必须在生产模式下运行你的微服务，你可能会启动一个独立的MongoDB实例或一些作为分片集群部署的MongoDB实例，并将应用程序连接到它们。对于我们的示例目的，我将使用Docker运行MongoDB的一个实例。
- en: If you are not familiar with Docker, you can always just install Mongo on your
    local or remote machine. For more information about Docker, you can also refer
    to [Chapter 14](0756243e-39c9-4696-8d79-4175e7cf4c48.xhtml), *Docker Support*
    where I will give you a short briefing about it. There, you will find all you
    need to begin, for example, how to install it on Windows and use basic commands.
    I will also use Docker in the examples implemented for the purposes of the next
    chapters and topics, so I think it would be useful if you have basic knowledge
    about it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉Docker，你总是可以只在你的本地或远程机器上安装Mongo。关于Docker的更多信息，你也可以参考[第14章](0756243e-39c9-4696-8d79-4175e7cf4c48.xhtml)、*Docker支持*，在那里我会给你一个简短的介绍。那里有你开始所需的一切，例如如何在Windows上安装它和使用基本命令。我还将使用Docker在为下一章节和主题实现示例中，所以我认为如果你有基本的了解它会很有用。
- en: Running the application
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'Let''s start MongoDB using the Docker `run` command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Docker `run`命令启动MongoDB：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Something that may be useful for us is the Mongo database client. Using this,
    it is possible to create a new database and add some users with credentials. If
    you have Docker installed on Windows, the default virtual machine address is `192.168.99.100`.
    The Mongo container has port `27017` exposed as a result of setting the `-p` parameter
    inside the `run` command. Well, in fact, we do not have to create the database
    because, when we provide the name while defining the client connection, it will
    automatically be created if it doesn''t exist:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们可能有用的一件事是 Mongo 数据库客户端。使用这个客户端，可以创建一个新的数据库并添加一些带有凭据的用户。如果您在 Windows 上安装了
    Docker，默认虚拟机地址是`192.168.99.100`。由于在`run`命令内部设置了`-p`参数，Mongo 容器暴露了端口`27017`。实际上，我们不必创建数据库，因为当我们定义客户端连接时提供数据库名称，如果它不存在，它将自动创建：
- en: '![](img/6028efdc-ae01-4769-87ff-30e34816bae8.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6028efdc-ae01-4769-87ff-30e34816bae8.png)'
- en: 'Next, we should create a user for the application with sufficient authority:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该为应用程序创建一个具有足够权限的用户：
- en: '![](img/37885b34-9466-4902-89cd-0d23223f6eef.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37885b34-9466-4902-89cd-0d23223f6eef.png)'
- en: 'Finally, we should set the Mongo database connection settings and credentials
    in the `application.yml` configuration file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该在`application.yml`配置文件中设置 Mongo 数据库连接设置和凭据：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Spring Boot has good support for multi-profile configuration. A YAML file can
    be separated into a sequence of documents using `*---*` lines, and each section
    of the document is parsed independently to a flattened map. The preceding example
    does exactly the same as a separated configuration file with `application-production.yml`.
    If you run the application without any additional options, it uses the default
    settings, which have no profile name set. If you would like to run it using production
    properties, you should set the VM argument `spring.profiles.active`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 很好地支持多配置文件。YAML 文件可以通过使用`*---*`行分隔成一系列文档，每个文档部分独立解析为一个扁平化的映射。前面的示例与使用`application-production.yml`的分离配置文件完全一样。如果您没有使用任何其他选项运行应用程序，它将使用默认设置，这些设置没有设置配置文件名称。如果您希望使用生产属性运行它，您应该设置
    VM 参数`spring.profiles.active`：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'That''s not all. Now, the application with the active production profile failed
    to start because it tried to initialize the `embeddedMongoServer` bean. As you
    might already know, almost all of the additional solutions have auto configuration
    set in Spring Boot. It is no different in this case. We need to exclude the `EmbeddedMongoAutoConfiguration` class from
    auto configuration in the production profile:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不算完。现在，带有活动生产配置文件的应用程序无法启动，因为它尝试初始化`embeddedMongoServer`bean。正如您可能已经知道的，Spring
    Boot 中几乎所有的附加解决方案都设置了自动配置。这个例子也不例外。我们需要在生产配置文件中排除`EmbeddedMongoAutoConfiguration`类：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We might as well use the configuration class to exclude that artifact:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用配置类来排除该工件：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Of course, we could have used a more elegant solution, such as Maven profiles,
    and excluded the whole `de.flapdoodle.embed.mongo` artifact from the target build
    package. The presented solution is just one of several possibilities to solve
    the problem, but it shows the auto configuration and profile mechanisms in Spring
    Boot. Now, you can run our sample application and perform some tests using, for
    example, Swagger UI. You can also connect to the database using the Mongo client
    and check out the changes in the database. Here''s our sample project''s final
    file structure:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们本可以使用更优雅的解决方案，比如 Maven 配置文件，并从目标构建包中排除整个`de.flapdoodle.embed.mongo`工件。所示解决方案只是解决该问题的几种可能性之一，但它展示了
    Spring Boot 中的自动配置和配置文件机制。现在，您可以运行我们的示例应用程序并使用例如 Swagger UI 进行一些测试。您还可以使用 Mongo
    客户端连接到数据库并查看数据库中的更改。以下是我们的示例项目的最终文件结构：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The example application is complete. These are all Spring Boot features I would
    like to show you in this chapter. I have focused on those that are especially
    useful for creating REST-based services.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序完成了。这些都是我本章想要展示给你的 Spring Boot 功能。我主要关注那些特别适用于创建基于 REST 的服务的功能。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: I have guided you through the process of single-microservice development, from
    a really basic example to a more advanced, production-ready Spring Boot application.
    I have described how to use starters to enable additional features for the project; use
    the Spring Web library to implement services that expose REST API methods; and
    then we moved on to customizing the service configuration using properties and
    YAML files. We also saw how to document and provide specifications for exposed
    REST endpoints. Next, we configured health checks and monitoring features. We
    used Spring Boot profiles to adapt the application to run in different modes and,
    finally, we used ORM features for interacting with embedded and remote NoSQL databases.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经引导你经历了单微服务开发的过程，从一个非常基础的例子到一个更高级的、生产就绪的Spring Boot应用。我描述了如何使用启动器（starters）为项目启用附加特性；使用Spring
    Web库来实现暴露REST API方法的服务；然后我们转向使用属性和YAML文件自定义服务配置。我们还看到了如何文档化和提供暴露REST端点的规格说明。接下来，我们配置了健康检查和监控特性。我们使用了Spring
    Boot配置文件（profiles）使应用能够以不同的模式运行，最后，我们使用了对象关系映射（ORM）特性来与内嵌和远程的NoSQL数据库进行交互。
- en: It's not an accident that I have not mentioned anything about Spring Cloud in
    this chapter. You just can't start using Spring Cloud projects without basic knowledge
    and experience in working with Spring Boot. Spring Cloud provides many different
    features that allow you to place your service inside a full microservice-based
    ecosystem. We will be discussing these functionalities one by one in the following
    chapters.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有在这一章中提到Spring Cloud绝非偶然。你没有基本的Spring Boot知识和经验，是无法开始使用Spring Cloud项目的。Spring
    Cloud提供了许多不同的特性，让你可以将你的服务放置在一个完整的基于微服务的生态系统中。我们将在接下来的章节中逐一讨论这些功能。
