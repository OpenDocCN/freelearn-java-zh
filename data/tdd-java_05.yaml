- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Writing Our First Test
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的第一个测试
- en: It’s time for us to dive in and write our first TDD unit test in this chapter.
    To help us do this, we will learn about a simple template that helps us organize
    each test into a logical, readable piece of code. Along the way, we will learn
    some key principles we can use to make our tests effective. We will see how writing
    the test first forces us to make decisions about the design of our code and its
    ease of use, before needing to think about implementation details.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候我们深入本章，编写我们的第一个TDD单元测试了。为了帮助我们做到这一点，我们将学习一个简单的模板，帮助我们将每个测试组织成逻辑清晰、易于阅读的代码片段。在这个过程中，我们将学习一些我们可以用来使我们的测试有效的关键原则。我们将看到编写测试是如何迫使我们做出关于代码设计和其易用性的决策，在需要考虑实现细节之前。
- en: After some examples covering those techniques, we will make a start on our Wordz
    application, writing a test first before adding production code to make that test
    pass. We will use the popular Java unit testing libraries JUnit5 and AssertJ to
    help us write easy-to-read tests.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些介绍这些技术的例子之后，我们将开始我们的Wordz应用程序，编写一个测试，然后再添加生产代码以使该测试通过。我们将使用流行的Java单元测试库JUnit5和AssertJ来帮助我们编写易于阅读的测试。
- en: 'In this chapter, we will cover the following main principles behind writing
    effective unit tests:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖编写有效单元测试背后的以下主要原则：
- en: 'Starting TDD: **Arrange-Act-Assert**'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始TDD：**安排-行动-断言**
- en: Defining a good test
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个好的测试
- en: Catching common errors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获常见错误
- en: Asserting exceptions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言异常
- en: Only testing public methods
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只测试公共方法
- en: Learning from our tests
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从我们的测试中学习
- en: Beginning Wordz – our first test
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始Wordz – 我们的第一个测试
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The final code in this chapter can be found at [https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter05](https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter05).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最终代码可以在[https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter05](https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter05)找到。
- en: 'Starting TDD: Arrange-Act-Assert'
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始TDD：安排-行动-断言
- en: Unit tests are nothing mysterious. They’re just code, executable code written
    in the same language that you write your application in. Each unit test forms
    the first use of the code you want to write. It calls the code just as it will
    be called in the real application. The test executes that code, captures all the
    outputs that we care about, and checks that they are what we expected them to
    be. Because the test uses our code in the exact same way that the real application
    will, we get instant feedback on how easy or difficult our code is to use. This
    might sound obvious, and it is, but it is a powerful tool to help us write clean
    and correct code. Let’s take a look at an example of a unit test and learn how
    to define its structure.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试并不神秘。它们只是代码，是用你编写应用程序的相同语言编写的可执行代码。每个单元测试都是你想要编写的代码的第一个使用。它以与实际应用程序相同的方式调用代码。测试执行该代码，捕获我们关心的所有输出，并检查它们是否是我们预期的。因为测试以与实际应用程序完全相同的方式使用我们的代码，所以我们能够立即获得关于我们的代码使用难易程度的反馈。这听起来可能很显然，确实如此，但它是一个强大的工具，可以帮助我们编写干净和正确的代码。让我们看看一个单元测试的例子，并学习如何定义其结构。
- en: Defining the test structure
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义测试结构
- en: It’s always helpful to have templates to follow when we do things and unit tests
    are no exception. Based on commercial work done on the Chrysler Comprehensive
    Compensation Project, TDD inventor Kent Beck found that unit tests had certain
    features in common. This became summarized as a recommended structure for test
    code, called **Arrange-Act-Assert** or **AAA**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们做事情时，遵循模板总是有帮助的，单元测试也不例外。基于在Chrysler Comprehensive Compensation Project上进行的商业工作，TDD的发明者Kent
    Beck发现单元测试有某些共同特征。这被总结为测试代码的推荐结构，称为**安排-行动-断言**或**AAA**。
- en: The original definition of AAA
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: AAA的原始定义
- en: 'The original description of AAA can be found here, in the C2 wiki: [http://wiki.c2.com/?ArrangeActAssert](http://wiki.c2.com/?ArrangeActAssert).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: AAA的原始描述可以在C2 wiki中找到：[http://wiki.c2.com/?ArrangeActAssert](http://wiki.c2.com/?ArrangeActAssert)。
- en: 'To explain what each section does, let’s walk through a completed unit test
    for a piece of code where we want to ensure that a username is displayed in lowercase:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释每个部分的作用，让我们通过一个完成的单元测试来了解一个代码片段，我们想要确保用户名以小写形式显示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first thing to notice is the class name for our test: `UsernameTest`. This
    is the first piece of storytelling for readers of our code. We are describing
    the behavioral area we are testing, in this case, usernames. All our tests, and
    indeed all our code, should follow this storytelling approach: what do we want
    the readers of our code to understand? We want them to clearly see what the problem
    that we are solving is and how the code that solves it should be used. We want
    to demonstrate to them that the code works correctly.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是我们的测试类名：`UsernameTest`。这是我们代码读者故事讲述的第一部分。我们描述了我们要测试的行为区域，在这种情况下，是用户名。我们所有的测试，实际上是我们所有的代码，都应该遵循这种故事讲述方法：我们希望代码的读者理解什么？我们希望他们清楚地看到我们正在解决的问题以及解决该问题的代码应该如何使用。我们希望向他们展示代码是正确工作的。
- en: The unit test itself is the `convertsToLowerCase()` method. Again, the name
    describes what we expect to happen. When the code runs successfully, the username
    will be converted to lowercase. The names are intentionally simple, clear, and
    descriptive. This method has the `@Test` annotation from the **JUnit5** test framework.
    The annotation tells JUnit that this is a test that it can run for us.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试本身是`convertsToLowerCase()`方法。再次强调，方法名描述了我们期望发生的事情。当代码成功运行时，用户名将被转换为小写。这些名称故意设计得简单、清晰且具有描述性。此方法具有来自**JUnit5**测试框架的`@Test`注解。该注解告诉JUnit这是一个它可以为我们运行的测试。
- en: Inside the `@Test` method, we can see our *Arrange-Act-Assert* structure. We
    first *arrange* for our code to be able to run. This involves creating any objects
    required, supplying any configuration needed, and connecting any dependent objects
    and functions. Sometimes, we do not need this step, for example, if we are testing
    a simple standalone function. In our example code, the *Arrange* step is the line
    that creates the `username` object and supplies a name to the constructor. It
    then stores that object ready to use in the local `username` variable. It is the
    first line of the `var username = new Username("SirJakington35179");` test method
    body.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@Test`方法内部，我们可以看到我们的*Arrange-Act-Assert*结构。我们首先*安排*让我们的代码能够运行。这涉及到创建所需的任何对象，提供所需的任何配置，以及连接任何依赖的对象和函数。有时，我们可能不需要这一步，例如，如果我们正在测试一个简单的独立函数。在我们的示例代码中，*Arrange*步骤是创建`username`对象并将名称提供给构造函数的行。然后它将对象存储在局部`username`变量中，以便使用。这是`var
    username = new Username("SirJakington35179");`测试方法体的第一行。
- en: The *Act* step follows. This is the part where we cause our code under test
    to act – we run that code. This is always a call to the code under test, supplying
    any necessary parameters, and arranging to capture the results. In the example,
    the `String actual = username.asLowerCase();` line is the *Act* step. We call
    the `asLowerCase()` method on our `username` object. It takes no parameters and
    returns a simple `String` object containing the lowercase text `sirjakington35179`
    as a result.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是*Act*步骤。这是我们让被测试代码执行的部分——我们运行这段代码。这始终是对被测试代码的调用，提供任何必要的参数，并安排捕获结果。在示例中，`String
    actual = username.asLowerCase();`行是*Act*步骤。我们调用`username`对象的`asLowerCase()`方法。它不接受任何参数，并返回一个包含小写文本`sirjakington35179`的简单`String`对象作为结果。
- en: Completing our test is the final *Assert* step. The `assertThat(actual).isEqualTo("sirjakington35179");`
    line is our *Assert* step here. It uses the `assertThat()` method and the `isEqualTo()`
    method from the `AssertJ` fluent assertions library. Its job is to check whether
    the result we returned from the *Act* step matches our expectations or not. Here,
    we are testing whether all the uppercase letters in the original name have been
    converted to lowercase.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 完成我们的测试是最后的*Assert*步骤。`assertThat(actual).isEqualTo("sirjakington35179");`行是我们的*Assert*步骤。它使用了来自`AssertJ`流畅断言库的`assertThat()`方法和`isEqualTo()`方法。它的任务是检查从*Act*步骤返回的结果是否与我们的期望相符。在这里，我们正在测试原始名称中的所有大写字母是否已转换为小写。
- en: Unit tests like this are easy to write, easy to read, and they run very quickly.
    Many such tests can run in under 1 second.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的单元测试易于编写、易于阅读，并且运行非常快。许多这样的测试可以在1秒内完成。
- en: 'The `JUnit` library is the industry-standard unit test framework for Java.
    It provides us with a means to annotate Java methods as unit tests, lets us run
    all our tests, and visually displays the results, as shown here in the *IntelliJ*
    IDE window:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`JUnit`库是Java行业的标准单元测试框架。它为我们提供了一种将Java方法标注为单元测试的手段，允许我们运行所有测试，并在如图所示的*IntelliJ*
    IDE窗口中直观地显示结果：'
- en: '![Figure 5.1 – Output from the JUnit test runner](img/Figure_5.1_B18384.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – JUnit测试运行器的输出](img/Figure_5.1_B18384.jpg)'
- en: Figure 5.1 – Output from the JUnit test runner
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – JUnit测试运行器的输出
- en: 'We see here that the unit test failed. The test expected the result to be the
    `sirjakington35179` text string but instead, we received `null`. Using TDD, we
    would complete just enough code to make that test pass:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到单元测试失败了。测试期望结果是`sirjakington35179`文本字符串，但相反，我们收到了`null`。使用TDD，我们会完成足够的代码来使那个测试通过：
- en: '![Figure 5.2 – A JUnit test pass](img/Figure_5.2_B18384.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – JUnit测试通过](img/Figure_5.2_B18384.jpg)'
- en: Figure 5.2 – A JUnit test pass
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – JUnit测试通过
- en: We can see that our change to the production code has made this test pass. It
    has *gone green*, to use the popular term. Tests that fail are described as red
    tests and those that pass are green. This is based on the colors shown in popular
    IDEs, which are based on traffic signals in turn. Seeing all these short iterations
    of red tests turning to green is surprisingly satisfying, as well as building
    confidence in our work. The tests help us focus on the design of our code by forcing
    us to work backward from outcomes. Let’s look at what this means.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们对生产代码的更改使得这个测试通过了。它已经“变绿”了，用流行的术语来说。失败的测试被称为红色测试，而通过的测试则是绿色。这是基于在流行的IDE中显示的颜色，这些颜色又基于交通信号灯。看到所有这些红色测试的短迭代变为绿色，令人惊讶地令人满意，同时也增强了我们对工作的信心。这些测试通过迫使我们从结果倒推来工作，帮助我们专注于代码的设计。让我们看看这意味着什么。
- en: Working backward from outcomes
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从结果倒推
- en: One thing we notice right away is just how unimportant the actual code that
    makes this test pass is. Everything in this test is about defining the expectations
    of that code. We are setting boundaries around *why* our code is useful and *what*
    we expect it to do. We are not constraining *how* it does it in any way. We are
    taking an *outside-in* view of code. Any implementation that makes our test pass
    is acceptable.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立刻注意到，使这个测试通过的实际代码并不重要。这个测试中的每一件事都是关于定义代码的期望。我们正在设定代码为什么有用以及我们期望它做什么的边界。我们没有以任何方式约束它是如何做到的。我们正在从外部视角看待代码。任何使我们的测试通过的实现都是可接受的。
- en: This seems to be a transition point in learning to use TDD. Many of us learned
    to program by writing implementations first. We thought about how the code would
    work. We went deep into the algorithms and data structures behind a specific implementation.
    Then, as a last thought, we wrapped it all up in some kind of callable interface.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是在学习使用TDD过程中的一个转折点。我们中的许多人通过首先编写实现来学习编程。我们思考代码将如何工作。我们深入研究了特定实现背后的算法和数据结构。然后，作为一个最后的想法，我们将所有这些包裹在一个可调用的接口中。
- en: TDD turns this on its head. We intentionally design our callable interface first,
    as this is what the users of that code will see. We use the test to precisely
    describe how the code will be set up, how it will be called, and what we can expect
    it to do for us. Once we get used to doing this outside-in design first, TDD follows
    very naturally and improves our workflow efficiency in several important ways.
    Let’s review what these improvements are.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: TDD将这一过程颠倒过来。我们故意首先设计可调用接口，因为这是代码的用户将看到的内容。我们使用测试来精确地描述代码将如何设置，如何调用，以及我们可以期望它为我们做什么。一旦我们习惯了这种从外向内的设计，TDD就会非常自然地跟随，并在几个重要方面提高我们的工作流程效率。让我们回顾一下这些改进是什么。
- en: Increasing workflow efficiency
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高工作流程效率
- en: 'Unit tests like these increase our efficiency as developers in several ways.
    The most obvious is that the code we write has passed a test: we know it works.
    We are not waiting around for a manual QA process to find a defect and then raise
    a bug report for rework in the future. We find and fix bugs *now*, before ever
    releasing them into the main source trunk, let alone to users. We have documented
    our intentions for our colleagues. If anyone wants to know how our `Username`
    class works, it is right there in the test – how you create the object, which
    methods you can call, and what we expect the outcomes to be.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的单元测试以几种方式提高了我们的开发效率。最明显的是，我们写的代码已经通过了一个测试：我们知道它是有效的。我们不必等待手动QA过程来发现缺陷，然后为将来的重工作出错误报告。我们现在就发现并修复了错误，在将它们发布到主源分支之前，更不用说用户了。我们已经为我们的同事记录了我们的意图。如果有人想知道我们的`Username`类是如何工作的，它就在测试中——如何创建对象，你可以调用哪些方法，以及我们期望的结果是什么。
- en: Unit tests give us a way to run code in isolation. We are no longer forced to
    rebuild a whole application, run it, set up test data entries in our database,
    log in to the user interface, navigate to the correct screen, and then visually
    inspect the output of our code. We run the test. That’s it. This allows us to
    execute code that is not yet fully integrated into our application’s main trunk.
    This speeds up our work. We can get started more quickly, spend more time on developing
    the code at hand, and spend less time on cumbersome manual testing and deployment
    processes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试为我们提供了一种在隔离状态下运行代码的方法。我们不再被迫重新构建整个应用程序，运行它，在我们的数据库中设置测试数据条目，登录用户界面，导航到正确的屏幕，然后视觉检查我们代码的输出。我们运行测试。就是这样。这允许我们执行尚未完全集成到应用程序主分支中的代码。这加快了我们的工作。我们可以更快地开始，花更多的时间开发手头的代码，并且花更少的时间在繁琐的手动测试和部署流程上。
- en: A further benefit is that this act of design improves the modularity of our
    code. By designing code that can be tested in small pieces, we remind ourselves
    to write code that can execute in small pieces. That has been the basic approach
    to design since the 1960s and remains as effective today as it ever was.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好处是，这种设计行为提高了我们代码的模块化。通过设计可以分小块测试的代码，我们提醒自己编写可以分小块执行的代码。这自1960年代以来一直是基本的设计方法，并且至今仍然像以前一样有效。
- en: This section has covered the standard structure that we use to organize every
    unit test but it doesn’t guarantee that we will write a good test. To achieve
    this, each test needs to have particular properties. The **FIRST** principles
    describe the properties of a good test. Let’s learn how to apply these next.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本节已经介绍了我们用来组织每个单元测试的标准结构，但这并不保证我们会编写一个好的测试。为了实现这一点，每个测试都需要具有特定的属性。**FIRST**原则描述了良好测试的特性。让我们学习如何应用这些原则。
- en: Defining a good test
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义良好的测试
- en: Like all code, unit test code can be written in better or worse ways. We’ve
    seen how AAA helps us structure a test correctly and how accurate, descriptive
    names tell the story of what we intend our code to do. The most useful tests also
    follow the FIRST principles and use one assert per test.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有代码一样，单元测试代码可以写得更好或更差。我们已经看到AAA如何帮助我们正确地构建测试结构，以及准确、描述性的名称如何讲述我们代码意图的故事。最有用的测试也遵循FIRST原则，并且每个测试使用一个断言。
- en: Applying the FIRST principles
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用FIRST原则
- en: 'These are a set of five principles that make tests more effective:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一组五个原则，使测试更加有效：
- en: Fast
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速
- en: Isolated
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离
- en: Repeatable
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重复
- en: Self-verifying
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自验证
- en: Timely
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 及时
- en: Unit tests need to be **fast**, just as our earlier example was. This is especially
    important for test-first TDD, as we want that immediate feedback while we explore
    our design and implementation. If we run a unit test, and it takes even as little
    as 15 seconds to complete, we will soon stop running tests as often. We will degenerate
    into writing big chunks of production code without tests so that we spend less
    time waiting for slow tests to finish. This is the exact opposite of what we want
    from TDD, so we work hard to keep tests fast. We need unit tests to run in 2 seconds
    or less, ideally milliseconds. Even two seconds is really quite a high number.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试需要**快速**，就像我们之前的例子一样。这对于测试驱动开发（TDD）尤为重要，因为我们希望在探索设计和实现时立即获得反馈。如果我们运行一个单元测试，即使只需要15秒来完成，我们很快就会停止频繁地运行测试。我们会退化到编写大块的生产代码而不进行测试，以便我们花更少的时间等待缓慢的测试完成。这与我们想要的TDD正好相反，所以我们努力保持测试快速。我们需要单元测试在2秒或更短时间内运行，理想情况下是毫秒级。即使是两秒也是一个相当高的数字。
- en: Tests need to be **isolated** from one another. This means that we can pick
    any test or any combination of tests and run them in any order we like and always
    get the same result. One test must not depend on another test having been run
    before it. This is often a symptom of failing to write fast tests, so we compensate
    by caching results or arranging step setups. This is a mistake, as it slows down
    development, especially for our colleagues. The reason is that we don’t know the
    special order in which the tests must run. When we run any test on its own, and
    if it has not been properly isolated, it will fail as a false negative. That test
    no longer tells us anything about our code under test. It only tells us that we
    have not run some other test before it, without telling us which test that might
    be. Isolation is critical to a healthy TDD workflow.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 测试需要彼此**隔离**。这意味着我们可以选择任何测试或任何测试组合，以任何顺序运行它们，并始终得到相同的结果。一个测试不应依赖于另一个测试在其之前运行。这通常是不写快速测试的迹象，因此我们通过缓存结果或安排步骤设置来补偿。这是一个错误，因为它会减慢开发速度，尤其是对我们同事的影响。原因是我们不知道测试必须运行的特定顺序。当我们单独运行任何测试时，如果它没有得到适当的隔离，它将作为假阴性而失败。这个测试不再告诉我们关于我们正在测试的代码的任何信息。它只告诉我们我们之前没有运行某个测试，但没有告诉我们可能是哪个测试。隔离对于健康的TDD工作流程至关重要。
- en: '**Repeatable** tests are vital to TDD. Whenever we run a test with the same
    production code, that test must always return the same pass or fail result. This
    might sound obvious but care needs to be taken to achieve this. Think about a
    test that checks a function that returns a random number between 1 and 10\. If
    we assert that the number seven is returned, this test will only pass occasionally,
    even if we have correctly coded the function. In this regard, three popular sources
    of misery are tests involving the database, tests against time, and tests through
    the user interface. We will explore techniques to handle these situations in [*Chapter
    8*](B18384_08.xhtml#_idTextAnchor149), *Test Doubles –Stubs* *and Mocks*.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**可重复**的测试对于TDD至关重要。无论何时我们用相同的生产代码运行测试，该测试都必须始终返回相同的通过或失败结果。这听起来可能很显然，但需要小心才能实现这一点。考虑一个检查返回1到10之间随机数的函数的测试。如果我们断言返回数字7，这个测试只会偶尔通过，即使我们正确地编写了函数。在这方面，三个常见的痛苦来源是涉及数据库的测试、针对时间的测试以及通过用户界面的测试。我们将在[*第8章*](B18384_08.xhtml#_idTextAnchor149)中探讨处理这些情况的技术，*测试替身——存根*和*模拟*。'
- en: All tests must be **self-verifying**. This means we need executable code to
    run and check whether the outputs are as expected. *This step must be automated*.
    We must not leave this check to manual inspection, perhaps by writing the output
    to a console and having a human check it against a test plan. Unit tests derive
    huge value from being automated. The computer checks the production code, freeing
    us from the tedium of following a test plan, the slowness of human activities,
    and the likelihood of human error.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都必须是**自验证的**。这意味着我们需要可执行的代码来运行并检查输出是否符合预期。*这一步骤必须自动化*。我们绝对不能将这一检查留给人工检查，比如将输出写入控制台，然后由人工对照测试计划进行检查。单元测试通过自动化获得了巨大的价值。计算机检查生产代码，使我们免于遵循测试计划的繁琐，避免了人工活动的缓慢，以及人为错误的可能性。
- en: '**Timely** tests are tests written at just the right time to be most useful.
    The ideal time to write a test is just before writing the code that makes that
    test pass. It’s not unusual to see teams use less beneficial approaches. The worst
    one, of course, is to never write any unit tests and rely on manual QA to find
    bugs. With this approach, we get none of the design feedback available. The other
    extreme is to have an analyst write every test for the component – or even the
    whole system – upfront, leaving the coding as a mechanical exercise. This also
    fails to learn from design feedback. It can also result in overspecified tests
    that *lock in* poor design and implementation choices. Many teams start by writing
    some code and then go on to write a unit test, thereby missing out on an opportunity
    for early design feedback. It can also lead to untested code and faulty edge case
    handling.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**及时**的测试是在最合适的时间编写的测试，以便发挥最大的作用。编写测试的理想时间是在编写使测试通过的代码之前。看到团队使用不那么有益的方法并不罕见。当然，最糟糕的方法是根本不编写任何单元测试，而依赖人工质量保证来发现错误。采用这种方法，我们无法获得任何设计反馈。另一种极端是让分析师提前为组件编写每个测试——或者甚至为整个系统编写测试——然后将编码作为一项机械练习。这也无法从设计反馈中学习。它还可能导致过度指定的测试，这些测试*锁定*了不良的设计和实现选择。许多团队开始编写一些代码，然后继续编写单元测试，从而错失了早期设计反馈的机会。这也可能导致未测试的代码和错误的边缘情况处理。'
- en: We’ve seen how the FIRST principles help us focus on crafting a good test. Another
    important principle is not to try to test too much all at once. If we do, the
    test becomes very difficult to understand. A simple solution to this is to write
    a single assert per test, which we will cover next.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到FIRST原则如何帮助我们专注于编写一个好的测试。另一个重要的原则是不要试图一次性测试太多。如果我们这样做，测试就会变得非常难以理解。一个简单的解决方案是每个测试用例写一个断言，我们将在下一节中介绍。
- en: Using one assert per test
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个测试用例使用一个断言
- en: Tests provide the most useful feedback when they are short and specific. They
    act as a microscope working on the code, each test highlighting one small aspect
    of our code. The best way to ensure this happens is by writing one assertion per
    test. This prevents us from tackling too much in one test. This focuses on the
    error messages we get during test failures and helps us control the complexity
    of our code. It forces us to break things down a little further.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试用例简短且具体时，它们提供的反馈最有用。它们就像显微镜一样作用于代码，每个测试用例突出显示我们代码的一个小方面。确保这一点发生的最佳方式是每个测试用例写一个断言。这防止我们在一个测试中处理太多内容。这专注于我们在测试失败期间收到的错误消息，并帮助我们控制代码的复杂性。这迫使我们进一步分解问题。
- en: Deciding on the scope of a unit test
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定单元测试的范围
- en: Another common misunderstanding is what a *unit* means in a unit test. The unit
    refers to the test isolation itself – each test can be considered a standalone
    unit. As a result, the size of the code under test can vary a lot, as long as
    that test can run in isolation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的误解是单元测试中的*单元*的含义。单元指的是测试隔离本身——每个测试都可以被视为一个独立的单元。因此，被测试代码的大小可以有很大的变化，只要这个测试可以独立运行。
- en: Thinking of the test itself as the unit unifies several popular opinions about
    what the scope of a unit test should be. Often, it is said that the unit is the
    smallest piece of testable code – a function, method, class, or package. All of
    these are valid options. Another common argument is that a unit test should be
    a class test – one unit test class per production code class, with one unit test
    method per production method. While common, this isn’t usually the best approach.
    It unnecessarily couples the structure of the test to the structure of the implementation,
    making the code *harder* to change in the future, not easier.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将测试本身视为单元统一了关于单元测试范围应该是什么的几个流行观点。通常，人们会说单元是最小的可测试代码块——一个函数、方法、类或包。所有这些都是有效选项。另一个常见的论点是单元测试应该是一个类测试——每个生产代码类一个单元测试类，每个生产方法一个单元测试方法。虽然这是一种常见的方法，但这通常不是最佳方法。它不必要地将测试的结构与实现的结构耦合在一起，使得代码在未来更难更改，而不是更容易。
- en: The ideal goal of a unit test is to cover one *externally visible behavior*.
    This applies at several different scales in the code base. We can unit test an
    entire user story across multiple packages of classes, provided we can avoid manipulating
    external systems such as a database or the user interface. We’ll look into techniques
    for doing that in [*Chapter 9*](B18384_09.xhtml#_idTextAnchor179), *Hexagonal
    Architecture – Decoupling External Systems*. We often also use unit tests that
    are *closer* to the details of the code, testing only the public methods of a
    single class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的理想目标是覆盖一个*外部可见的行为*。这在代码库的几个不同尺度上适用。如果我们能避免操作外部系统，如数据库或用户界面，我们可以对整个用户故事进行单元测试，跨越多个类包。我们将在[*第9章*](B18384_09.xhtml#_idTextAnchor179)中探讨如何做到这一点，*六边形架构——解耦外部系统*。我们通常还使用更接近代码细节的单元测试，只测试单个类的公共方法。
- en: 'Once we have written our test based on the design that we would like our code
    to have, we can concentrate on the more obvious aspect of testing: verifying that
    our code is correct.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们根据我们希望代码拥有的设计编写了测试，我们就可以专注于测试的更明显方面：验证我们的代码是否正确。
- en: Catching common errors
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕捉常见错误
- en: 'The traditional view of testing is of it as a process to check that code works
    as it is intended to work. Unit tests excel at this and automate the process of
    running the code with known inputs and checking for expected outputs. As we are
    human, all of us make mistakes from time to time as we write code and some of
    these can have significant impacts. There are several common simple mistakes we
    can make and unit tests excel at catching them all. The most likely errors are
    the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的传统观点是将其视为一个检查代码按预期工作的过程。单元测试在这方面表现卓越，并自动执行使用已知输入运行代码并检查预期输出的过程。由于我们都是人类，我们在编写代码时有时会犯错误，其中一些可能会产生重大影响。我们可以犯的几个常见简单错误，单元测试在捕捉这些错误方面表现卓越。最可能出现的错误如下：
- en: Off-by-one errors
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏移量错误
- en: Inverted conditional logic
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逆条件逻辑
- en: Missing conditions
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少条件
- en: Uninitialized data
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未初始化的数据
- en: The wrong algorithm
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误的算法
- en: Broken equality checks
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破坏的相等性检查
- en: 'As an example, going back to our earlier test for a lowercase username, suppose
    we decided not to implement this using the `String` built-in `.toLowerCase()`
    method, but instead tried to roll our own loop code, like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，回到我们之前对小写用户名的测试，假设我们决定不使用`String`内置的`.toLowerCase()`方法来实现，而是尝试编写自己的循环代码，如下所示：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We would see right away that this code isn’t correct. The test fails, as shown
    in the following figure:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会立即发现这段代码是不正确的。测试失败，如下面的图所示：
- en: '![Figure 5.3 – A common coding error](img/Figure_5.3_B18384.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 常见的编码错误](img/Figure_5.3_B18384.jpg)'
- en: Figure 5.3 – A common coding error
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 常见的编码错误
- en: The first error in this code is a simple off-by-one error – the first letter
    is missing from the output. That points to an error in initializing our loop index
    but there are other errors in this code as well. This test reveals two defects.
    Further tests would reveal two more. Can you see what they are by visual inspection
    alone? How much more time and effort is it to analyze code like this in our heads,
    rather than using automated tests?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的第一个错误是一个简单的“偏移量错误” – 输出中缺少第一个字母。这指向了初始化循环索引时的错误，但这段代码中还有其他错误。这个测试揭示了两个缺陷。进一步的测试将揭示另外两个。你能仅通过视觉检查就看出它们是什么吗？与使用自动化测试相比，分析这样的代码在头脑中需要更多的时间和努力吗？
- en: Asserting exceptions
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言异常
- en: 'One area where unit tests excel is in testing error handling code. As an example
    of testing *exception throwing*, let’s add a business requirement that our usernames
    must be at least four characters long. We think about the design we want and decide
    to throw a custom exception if the name is too short. We decide to represent this
    custom exception as `class InvalidNameException`. Here’s what the test looks like,
    using AssertJ:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试在测试错误处理代码方面表现出色。作为测试**异常抛出**的例子，让我们添加一个业务需求，即我们的用户名必须至少有四个字符长。我们考虑我们想要的设计，并决定如果名字太短就抛出一个自定义异常。我们决定将这个自定义异常表示为`class
    InvalidNameException`。以下是使用AssertJ的测试示例：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can consider adding another test specifically aimed at proving that a name
    of four characters is accepted and no exception is thrown:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑添加另一个测试，专门用来证明四个字符的名字被接受且没有抛出异常：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Alternatively, we may simply decide that this explicit test is not needed. We
    may cover it implicitly with other tests. It is a good practice to add both tests
    to make our intentions clear.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可能简单地决定这个显式测试是不必要的。我们可能通过其他测试隐式地覆盖它。添加这两个测试是一个好习惯，可以使我们的意图更加明确。
- en: The test names are fairly general, starting with either `rejects` or `accepts`.
    They describe the outcome that the code is being tested for. This allows us to
    change our minds about the error handling mechanics later, perhaps switching to
    something other than exceptions to signal the error.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 测试名称相当通用，以`rejects`或`accepts`开头。它们描述了代码正在测试的输出结果。这允许我们稍后改变主意，关于错误处理机制，可能切换到其他方式来表示错误。
- en: Unit tests can catch common programming errors and verify error handling logic.
    Let’s look at a major principle of writing our unit tests to give us maximum flexibility
    when implementing our methods.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以捕捉常见的编程错误并验证错误处理逻辑。让我们看看编写单元测试的一个主要原则，以便我们在实现方法时具有最大的灵活性。
- en: Only testing public methods
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只测试公共方法
- en: TDD is all about testing the behaviors of components, not their implementations.
    As we have seen in our test in the previous section, having a test for the behavior
    we want enables us to choose any implementation that will do the job. We focus
    on what’s important – *what* a component does – not on the less important details
    – *how* it does it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: TDD（测试驱动开发）的全部内容是测试组件的行为，而不是它们的实现。正如我们在上一节中的测试所看到的，有一个针对我们想要的行为的测试使我们能够选择任何能够完成工作的实现。我们关注的是重要的部分
    – 组件**做什么** – 而不是不那么重要的细节 – **它是如何做到的**。
- en: Inside a test, this appears as calling public methods or functions on public
    classes and packages. The public methods are the behaviors we choose to expose
    to the wider application. Any private data or supporting code in classes, methods,
    or functions remain hidden.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试内部，这表现为调用公共类和包的公共方法或函数。公共方法是我们在更广泛的应用中选择的公开行为。类、方法或函数中的任何私有数据或辅助代码都保持隐藏。
- en: A common mistake that developers make when learning TDD is that they make things
    public just to simplify testing. Resist the temptation. A typical mistake here
    is to take a private data field and expose it for testing using a public getter
    method. This weakens the encapsulation of that class. It is now more likely that
    the getter will be misused. Future developers may add methods to other classes
    that really belong in this one. The design of our production code is important.
    Fortunately, there is a simple way of preserving encapsulation without compromising
    testing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者在学习TDD时常见的错误是，他们为了简化测试而将事物公开。抵制这种诱惑。这里的典型错误是将私有数据字段公开，以便使用公共getter方法进行测试。这削弱了该类的封装性。现在更有可能getter会被误用。未来的开发者可能会向其他类添加真正属于这个类的方法。我们的生产代码的设计很重要。幸运的是，有一种简单的方法可以保持封装性，而不会损害测试。
- en: Preserving encapsulation
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持封装性
- en: If we feel we need to add getters to all our private data so that the test can
    check that each one is as expected, it is often better to treat this as a **value
    object**. A value object is an object that lacks identity. Any two value objects
    that contain the same data are considered to be equal. Using value objects, we
    can make another object containing the same private data and then test that the
    two objects are equal.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们觉得需要为所有私有数据添加getter，以便测试可以检查每个数据是否符合预期，那么通常将此视为**值对象**会更好。值对象是一个没有身份的对象。任何包含相同数据的两个值对象都被认为是相等的。使用值对象，我们可以创建另一个包含相同私有数据的对象，然后测试这两个对象是否相等。
- en: 'In Java, this requires us to code a custom `equals()` method for our class.
    If we do this, we should also code a `hashcode()` method, as the two go hand in
    hand. Any implementation that works will do. I recommend using the `Apache commons3`
    library, which uses Java reflection capabilities to do this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，这要求我们为我们自己的类编写一个自定义的`equals()`方法。如果我们这样做，我们也应该编写一个`hashcode()`方法，因为这两个方法是相辅相成的。任何有效的实现都可以。我建议使用`Apache
    commons3`库，它使用Java反射功能来完成这项工作：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can find out more about these library methods at [https://commons.apache.org/proper/commons-lang/](https://commons.apache.org/proper/commons-lang/).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://commons.apache.org/proper/commons-lang/](https://commons.apache.org/proper/commons-lang/)了解更多关于这些库方法的信息。
- en: Simply adding those two methods (and the `Apache commons3` library) to our class
    means that we can keep all our data fields private and still check that all the
    fields have the expected data in them. We simply create a new object with all
    the expected fields, then assert that it is equal to the object we are testing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地将这两种方法（以及`Apache commons3`库）添加到我们的类中，意味着我们可以保持所有数据字段私有，同时仍然检查所有字段是否包含预期的数据。我们只需创建一个新的对象，包含所有预期的字段，然后断言它与我们正在测试的对象相等。
- en: As we write each test, we are using the code under test for the first time.
    This allows us to learn a lot about how easy our code is to use, allowing us to
    make changes if we need to.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写每个测试时，我们正在首次使用被测试的代码。这使我们能够了解很多关于我们的代码如何易于使用的信息，如果需要，我们可以进行更改。
- en: Learning from our tests
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从我们的测试中学习
- en: Our tests are a rich source of feedback on our design. As we make decisions,
    we write them as test code. Seeing this code – the first usage of our production
    code – brings into sharp focus how good our proposed design is. When our design
    isn’t good, the AAA sections of our test will reveal those design issues as code
    smells in the test. Let’s try to understand in detail how each of these can help
    identify a faulty design.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试是我们设计反馈的丰富来源。当我们做出决策时，我们将它们编写为测试代码。看到这些代码——我们生产代码的第一次使用——将我们提出的设计的优劣清晰地聚焦起来。当我们的设计不好时，测试中的AAA部分将揭示这些设计问题作为代码异味。让我们详细尝试理解这些如何帮助识别有缺陷的设计。
- en: A messy Arrange step
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个混乱的Arrange步骤
- en: If the code in our Arrange step is messy, our object may be difficult to create
    and configure. It may need too many parameters in a constructor or too many optional
    parameters left as `null` in the test. It may be that the object needs too many
    dependencies injected, indicating that it has too many responsibilities or it
    might need too many primitive data parameters to pass in a lot of configuration
    items. These are signals that the way we create our object might benefit from
    a redesign.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的Arrange步骤中的代码很混乱，我们的对象可能难以创建和配置。它可能需要在构造函数中包含太多参数，或者在测试中留下太多可选参数为`null`。可能的情况是，对象需要注入太多依赖项，这表明它有太多的职责，或者它可能需要太多的原始数据参数来传递大量的配置项。这些都是我们创建对象的方式可能需要重新设计的信号。
- en: A messy Act step
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个混乱的Act步骤
- en: Calling the main part of the code in the Act step is usually straightforward
    but it can reveal some basic design errors. For example, we might have unclear
    parameters that we pass in, signatures such as a list of `Boolean` or `String`
    objects. It is very hard to know what each one means. We could redesign this by
    wrapping those difficult parameters in an easy-to-understand new class, called
    a **configuration object**. Another possible problem is if the Act step requires
    multiple calls to be made in a specific order. That is error-prone. It is easy
    to call them in the wrong order or forget one of the calls. We could redesign
    to use a single method that wraps all of this detail.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在行为（Act）步骤中调用代码的主要部分通常很简单，但它可以揭示一些基本的设计错误。例如，我们可能有不清晰的参数，比如传递给列表的`Boolean`或`String`对象。很难知道每个参数的含义。我们可以通过将这些难以理解的参数包装在一个易于理解的新类中来重新设计，这个新类被称为**配置对象**。另一个可能的问题是，如果行为步骤需要按特定顺序进行多次调用，那么这是容易出错的。很容易按错误的顺序调用它们或忘记其中一个调用。我们可以重新设计，使用一个包含所有这些细节的单个方法。
- en: A messy Assert step
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混乱的断言（Assert）步骤
- en: The Assert step will reveal whether the results of our code are difficult to
    use. Problem areas might include having to call accessors in a specific order
    or perhaps returning some conventional code smells, such as an array of results
    where every index has a different meaning. We can redesign to use safer constructs
    in either case.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 断言步骤将揭示我们的代码结果是否难以使用。问题区域可能包括必须按特定顺序调用访问器，或者可能返回一些传统的代码异味，例如结果数组，其中每个索引都有不同的含义。在两种情况下，我们都可以重新设计，使用更安全的结构。
- en: In each of these cases, one of the sections of code in our unit test looks wrong
    – it has a code smell. That is because the design of the code we are testing has
    the same code smell. This is what is meant by unit tests giving fast feedback
    on design. They are the first user of the code we are writing, so we can identify
    problem areas early on.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况中，我们的单元测试中的一个代码部分看起来是错误的 – 它有一个代码异味。这是因为我们正在测试的代码的设计有相同的代码异味。这就是单元测试对设计提供快速反馈的含义。它们是我们所写代码的第一个用户，因此我们可以早期识别问题区域。
- en: We now have all the techniques we need to start writing our first test for our
    example application. Let’s make a start.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了开始编写我们示例应用程序的第一个测试所需的所有技术。让我们开始吧。
- en: Limitations of unit tests
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试的局限性
- en: One very important idea is that an automated test can only prove the presence
    of a defect, not the absence. What this means is that if we think of a boundary
    condition, write a test for that, and the test fails, we know we have a defect
    in our logic. However, if all our tests pass, that *does not and cannot* mean
    our code is free of defects. It only means that our code is free of all the defects
    that we have thought to test for. There simply is no magic solution that can ensure
    our code is defect-free. TDD gives us a significant boost in that direction but
    we must never claim our code is defect-free just because all our tests pass. This
    is simply untrue.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常重要的观点是，自动化测试只能证明缺陷的存在，而不能证明缺陷的不存在。这意味着，如果我们考虑一个边界条件，为它编写一个测试，并且测试失败，我们知道我们的逻辑中有一个缺陷。然而，如果所有测试都通过，这*并不也不能*意味着我们的代码没有缺陷。它只意味着我们的代码没有我们考虑测试的所有缺陷。根本不存在任何魔法解决方案可以确保我们的代码没有缺陷。TDD在这方面给我们带来了很大的帮助，但我们绝不能仅仅因为所有测试都通过就声称我们的代码没有缺陷。这根本不是真的。
- en: One important consequence of this is that our QA engineering colleagues remain
    as important as they ever were, although we now help them start from an easier
    standing point. We can deliver TDD-tested code to our manual QA colleagues, and
    they can be assured that many defects have been prevented and proven to be absent.
    This means that they can start work on manual exploratory testing, finding all
    the things we never thought to test. Working together, we can use their defect
    reports to write further unit tests to rectify what they find. The contribution
    of QA engineers remains vital, even with TDD. We need all the help our team can
    get in our efforts to write high-quality software.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个重要后果是，我们的质量保证（QA）工程同事的重要性与以往一样，尽管我们现在帮助他们从一个更容易的起点开始。我们可以向我们的手动QA同事提供TDD测试过的代码，并确保许多缺陷已被预防并证明不存在。这意味着他们可以开始进行手动探索性测试，找出我们从未想过要测试的所有事情。共同努力，我们可以利用他们的缺陷报告来编写进一步的单元测试，以纠正他们发现的问题。即使有TDD，QA工程师的贡献仍然至关重要。我们需要我们团队所能提供的所有帮助，以努力编写高质量的软件。
- en: Code coverage – an often-meaningless metric
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码覆盖率 – 一个经常没有意义的指标
- en: Code coverage is a measure of how many lines of code have been executed in a
    given run. It is measured by instrumenting the code and this is something that
    a code coverage tool will do for us. It is often used in conjunction with unit
    testing to measure how many lines of code were executed while running the test
    suite.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是衡量在给定运行中执行了多少行代码的指标。它是通过代码插装来衡量的，这是代码覆盖率工具为我们做的事情。它通常与单元测试结合使用，以衡量在运行测试套件时执行了多少行代码。
- en: In theory, you can see how this might mean that missing tests can be discovered
    in a scientific way. If we see that a line of code was not run, we must have a
    missing test somewhere. That is both true and helpful but the converse is not
    true. Suppose we get 100% code coverage during our test run. Does that mean the
    software is now completely tested and correct? No.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，你可以看到这可能会意味着可以通过科学的方式发现缺失的测试。如果我们看到有一行代码没有被运行，那么我们肯定在某个地方遗漏了一个测试。这是真的，也是有帮助的，但反过来则不然。假设我们在测试运行期间获得了100%的代码覆盖率。这意味着软件现在已经完全测试并正确无误了吗？不。
- en: Consider having a single test for an `if (x < 2)` statement. We can write a
    test that will cause this line to execute and be included in code coverage reports.
    However, a single test is not enough to cover all the possibilities of behavior.
    The conditional statement might have the wrong operator – less than instead of
    less than or equal to. It might have the incorrect limit of 2 when it should be
    20\. Any single test cannot fully explore the combinations of behavior in that
    statement. We can have code coverage tell us that the line has been run and that
    our single test passed but we can still have several logic errors remaining. We
    can have 100% code coverage and still have missing tests.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑对`if (x < 2)`语句有一个单独的测试。我们可以编写一个测试，使这一行执行并包含在代码覆盖率报告中。然而，一个单独的测试不足以覆盖所有可能的行为。条件语句可能使用了错误的运算符——小于而不是小于等于。它可能使用了不正确的限制值2，而应该是20。任何单个测试都无法完全探索该语句中行为的所有组合。我们可以让代码覆盖率告诉我们这一行已经运行，并且我们的单个测试通过了，但我们仍然可能存在几个逻辑错误。我们可以有100%的代码覆盖率，但仍然有缺失的测试。
- en: Writing the wrong tests
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写错误的测试
- en: Time for a short personal story about how my best attempt at TDD went spectacularly
    wrong. In a mobile application that calculated personal tax reports, there was
    a particular yes/no checkbox in the app to indicate whether you had a student
    loan or not, since this affects the tax you pay. It had six consequences in our
    application and I thoroughly TDD tested each one, carefully writing my tests first.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 来讲一个关于我的最佳TDD尝试如何彻底失败的个人故事。在一个计算个人税务报告的移动应用程序中，有一个特定的是/否复选框来指示你是否有过学生贷款，因为这将影响你支付的税款。在我们的应用程序中有六个后果，我彻底进行了TDD测试，并仔细编写了我的测试。
- en: Sadly, I had misread the user story. I had inverted every single test. Where
    the checkbox should apply the relevant tax, it now did not apply it, and vice
    versa.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，我误解了用户故事。我把每一个测试都颠倒了。原本复选框应该应用相关税款的，现在它没有应用，反之亦然。
- en: This was thankfully picked up by our QA engineer. Her only comment was that
    she could find absolutely no workaround in the system for this defect. We concluded
    that TDD had done an excellent job of making the code do what I wanted it to do
    but I had done a rather less excellent job of figuring out what that should be.
    At least it was a very quick fix and retest.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们的质量保证工程师注意到了这个问题。她唯一的评论是她在这个系统中找不到任何针对这个缺陷的解决方案。我们得出结论，TDD在使代码做我想让它做的事情方面做得很好，但我没有很好地弄清楚那应该是什么。至少这是一个非常快速的修复和重新测试。
- en: Beginning Wordz
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始编写Wordz
- en: Let’s apply these ideas to our Wordz application. We’re going to start with
    a class that will contain the core of our application logic, one that represents
    a word to guess and that can work out the score for a guess.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些想法应用到我们的Wordz应用程序中。我们将从一个包含应用程序核心逻辑的类开始，这个类代表一个要猜测的单词，并且可以计算出猜测的得分。
- en: 'We begin by creating a unit test class and this immediately puts us into software
    design mode: what should we call the test? We’ll go with `WordTest`, as that outlines
    the area we want to cover – the word to be guessed.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个单元测试类，这立即让我们进入了软件设计模式：我们应该怎么命名这个测试？我们将选择`WordTest`，因为这概述了我们想要覆盖的区域——要猜测的单词。
- en: Typical Java project structures are divided into packages. The production code
    lives under `src/main/java` and the test code is located under `src/test/java`.
    This structure describes how production and test code are equally important parts
    of the source code, while giving us a way to compile and deploy only the production
    code. We always ship test code with the production code when we are dealing with
    source code, but for deployed executables, we only omit the tests. We will also
    follow the basic Java package convention of having a unique name for our company
    or project at the top level. This helps avoid clashes with library code. We’ll
    call ours `com.wordz`, named after the application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 Java 项目结构分为包。生产代码位于 `src/main/java` 下，测试代码位于 `src/test/java` 下。这种结构描述了生产代码和测试代码是源代码中同等重要的部分，同时为我们提供了一个编译和部署仅生产代码的方法。当我们处理源代码时，我们总是将测试代码与生产代码一起发送，但对于部署的可执行文件，我们只省略测试。我们还将遵循基本的
    Java 包约定，在顶级为我们的公司或项目命名一个唯一名称。这有助于避免与库代码冲突。我们将命名为 `com.wordz`，以应用名称命名。
- en: 'The next design step is to decide which behavior to drive out and test first.
    We always want a simple version of a happy path, something that will help drive
    out the normal logic that will most commonly execute. We can cover edge cases
    and error conditions later. To begin with, let’s write a test that will return
    the score for a single letter that is incorrect:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个设计步骤是决定首先驱动和测试哪种行为。我们总是想要一个简单的快乐路径版本，这有助于驱动出最常执行的正常逻辑。我们可以稍后覆盖边缘情况和错误条件。首先，让我们编写一个测试，它将返回一个不正确的单个字母的分数：
- en: 'Write the following code to begin our test:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码以开始我们的测试：
- en: '[PRE5]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The name of the test gives us an overview of what the test is doing.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的名称为我们提供了对测试正在做什么的概述。
- en: 'To start our design, we decide to use a class called `Word` to represent our
    word. We also decide to supply the word to guess as a constructor parameter to
    our object instance of class `Word` we want to create. We code these design decisions
    into the test:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了开始我们的设计，我们决定使用一个名为 `Word` 的类来表示我们的单词。我们还决定将猜测的单词作为构造函数参数提供给我们要创建的 `Word` 类的对象实例。我们将这些设计决策编码到测试中：
- en: '[PRE10]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We use autocomplete at this point to create a new `Word` class in its own file.
    Double-check in `src/main folder tree` and not `src/test`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此阶段，我们使用自动完成功能在单独的文件中创建一个新的 `Word` 类。请确保在 `src/main` 文件夹树中，而不是 `src/test`：
- en: '![Figure 5.4 – Creating a class dialog](img/Figure_5.4_B18384.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 创建类对话框](img/Figure_5.4_B18384.jpg)'
- en: Figure 5.4 – Creating a class dialog
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 创建类对话框
- en: Click **OK** to create the file in the source tree inside the right package.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **OK** 在源树中的正确包内创建文件。
- en: 'Now, we rename the `Word` constructor parameter:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将 `Word` 构造函数参数重命名：
- en: '[PRE14]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we return to the test. We capture the new object as a local variable
    so that we can test it:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们回到测试。我们将新对象作为一个局部变量捕获，以便我们可以对其进行测试：
- en: '[PRE19]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The next design step is to think of a way to pass a guess into the `Word` class
    and return a score.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个设计步骤是考虑一种方法，将猜测传递给 `Word` 类并返回一个分数。
- en: 'Passing the guess in is an easy decision – we’ll use a method that we’ll call
    `guess()`. We can code these decisions into the test:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将猜测传递进去是一个简单的决定——我们将使用一个我们称之为 `guess()` 的方法。我们可以将这些决策编码到测试中：
- en: '[PRE23]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Use autocomplete to add the `guess()` method to the `Word` class:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自动完成功能将 `guess()` 方法添加到 `Word` 类中：
- en: '![Figure 5.5 – Creating the Word class](img/Figure_5.5_B18384.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 创建 Word 类](img/Figure_5.5_B18384.jpg)'
- en: Figure 5.5 – Creating the Word class
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 创建 Word 类
- en: 'Click *Enter* to add the method, then change the parameter name to a descriptive
    name:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 *Enter* 添加方法，然后将参数名称更改为一个描述性的名称：
- en: '[PRE28]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, let’s add a way to get the resulting score from that guess. Start with
    the test:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一种方法来获取该猜测的结果分数。从以下测试开始：
- en: '[PRE30]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Then, we need a little think about what to return from the production code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要稍微思考一下从生产代码中返回什么。
- en: We probably want an object of some sort. This object must represent the score
    from that guess. Because our current user story is about the scores for a five-letter
    word and the details of each letter, we must return one of *exactly right*, *right
    letter*, *wrong place*, or *letter* *not present*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要一个某种对象。这个对象必须代表从那个猜测中得到的分数。因为我们的当前用户故事是关于五字母词的分数和每个字母的细节，我们必须返回 *完全正确*、*正确字母*、*错误位置*
    或 *字母不存在* 之一。
- en: 'There are several ways to do this and now is the time to stop and think about
    them. Here are some viable approaches:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以做到这一点，现在是时候停下来思考它们了。以下是一些可行的方案：
- en: A class with five getters, each one returning an `enum`.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有五个获取器的类，每个获取器返回一个枚举。
- en: A `record` type with the same getters.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有相同获取器的`record`类型
- en: A class with an `iterator` method, which iterates over five `enum` constants.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有`iterator`方法的类，该方法遍历五个枚举常量。
- en: A class with an `iterator` method that returns one interface for each letter
    score. The scoring code would implement a concrete class for each type of score.
    This would be a purely object-oriented way of adding a *callback* for each possible
    outcome.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有`iterator`方法的类，该方法为每个字母得分返回一个接口。评分代码将为每种得分类型实现一个具体类。这将是一种纯面向对象的方式，为每个可能的输出添加一个*回调*。
- en: A class that iterated over results for each letter and you passed in a `Java
    8 lambda` function for each of the outcomes. The correct one would be called as
    a callback for each letter.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类，它遍历每个字母的结果，并为每个结果传递一个`Java 8 lambda`函数。正确的结果会被作为每个字母的回调调用。
- en: That’s already a lot of design options. The key part of TDD is that we are considering
    this *now* before we write any production code. To help us decide, let’s sketch
    out what the calling code will look like. We need to consider plausible extensions
    to the code – will we need more or fewer than five letters in a word? Would the
    scoring rules ever change? Should we care about any of those things *right now*?
    Would the people reading this code in the future more easily grasp any one of
    these ideas than the others? TDD gives us fast feedback on our design decisions
    and that forces us to take a design workout right now.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经有很多设计选项了。TDD的关键部分是我们现在在编写任何生产代码之前考虑这一点。为了帮助我们做出决定，让我们勾勒出调用代码的样子。我们需要考虑代码的合理扩展——我们是否需要一个单词中多于或少于五个字母？评分规则会改变吗？我们是否应该现在就关心这些事情？未来的读者是否更容易理解这些想法中的任何一个而不是其他？TDD为我们提供了关于设计决策的快速反馈，这迫使我们现在就进行设计锻炼。
- en: One overriding decision is that we will not return the colors that each letter
    should have. That will be a UI code decision. For this core domain logic, we will
    return only the fact that the letter is *correct*, in the *wrong position*, or
    *not present*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一个主要的决策是我们不会返回每个字母应该有的颜色。这将是一个UI代码决策。对于这个核心领域逻辑，我们将只返回字母是*正确*、*位置错误*或*不存在*的事实。
- en: 'It’s easy enough with TDD to sketch out the calling code because it *is* the
    test code itself. After about 15 minutes of pondering what to do, here are the
    three design decisions we will use in this code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TDD轻松勾勒出调用代码，因为*它本身就是测试代码本身*。在思考了大约15分钟要做什么之后，以下是我们在代码中使用的三个设计决策：
- en: Supporting a variable number of letters in a word
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持单词中可变数量的字母
- en: Representing the score using a simple enum of `INCORRECT`, `PART_CORRECT`, or
    `CORRECT`
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简单的枚举`INCORRECT`、`PART_CORRECT`或`CORRECT`来表示得分
- en: Accessing each score by its position in the word, zero-based
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过单词中的位置访问每个得分，基于零开始
- en: 'These decisions support the `score` object will make up for that. Let’s move
    on to the design:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这些决策支持`score`对象将弥补这一点。让我们继续到设计：
- en: 'Capture these decisions in the test:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试中捕捉这些决策：
- en: '[PRE35]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can see how this test has locked in those design decisions about how we will
    use our objects. It says *nothing at all* about how we will implement those methods
    internally. *This is critical to effective TDD*. We have also captured and documented
    all the design decisions in this test. Creating an **executable specification**
    such as this is an important benefit of TDD.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个测试如何锁定我们如何使用对象的设计决策。它*根本不提*我们将如何实现这些方法。*这是TDD有效性的关键*。我们还在这个测试中捕捉并记录了所有的设计决策。创建这样的**可执行规范**是TDD的一个重要好处。
- en: Now, run this test. Watch it fail. This is a surprisingly important step.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行这个测试。观察它失败。这是一个令人惊讶的重要步骤。
- en: We might think at first that we only ever want to see passing tests. This is
    not totally true. Part of the work in TDD is having confidence that your tests
    are working. Seeing a test fail when we know we have not written the code to make
    it pass yet gives us confidence that our test is probably checking the right things.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会认为我们只想看到通过测试。这并不完全正确。TDD的一部分工作是有信心你的测试是有效的。当我们知道我们还没有编写代码让它通过时，看到测试失败会让我们有信心我们的测试可能检查了正确的事情。
- en: 'Let’s make that test pass, by adding code to `class Word`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过向`class Word`添加代码来使那个测试通过：
- en: '[PRE42]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, create `class Score`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建`class Score`：
- en: '[PRE51]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Again, we used IDE shortcuts to do most of the work in writing that code for
    us. The test passes:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用了IDE快捷键来完成大部分代码编写工作。测试通过了：
- en: '![Figure 5.6 – A test passing in IntelliJ](img/Figure_5.6_B18384.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – IntelliJ 中的测试通过](img/Figure_5.6_B18384.jpg)'
- en: Figure 5.6 – A test passing in IntelliJ
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – IntelliJ 中的测试通过
- en: We can see that the test passed and that it took 0.139 seconds to run. That
    certainly beats any manual test.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到测试通过了，并且它运行了 0.139 秒。这当然比任何手动测试都要好。
- en: We also have a repeatable test, which we can run for the remainder of the project
    life cycle. The time saving compared to manual testing will add up every time
    we run the test suite.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个可重复的测试，我们可以在项目的剩余生命周期中运行它。与手动测试相比，每次运行测试套件都能节省时间。
- en: You will notice that although the test passes, the code seems like it is cheating.
    The test only ever expects `Letter.INCORRECT` and the code is hardcoded to always
    return that. It clearly could never possibly work for any other values! This is
    expected at this stage. Our first test has set out a rough design for the interface
    of our code. It has not yet begun to drive out the full implementation. We will
    do that with our subsequent tests. This process is called *triangulation*, where
    we rely on adding tests to drive out the missing implementation details. By doing
    this, all our code is covered by tests. We get 100% *meaningful* code coverage
    for free. More importantly, it breaks our work down into smaller chunks, creates
    progress with frequent deliverables, and can lead to some interesting solutions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，尽管测试通过了，但代码看起来像是在作弊。测试只期望 `Letter.INCORRECT`，而代码是硬编码为总是返回那个值。显然，它永远不可能对任何其他值有效！在这个阶段这是预期的。我们的第一个测试已经为我们的代码接口制定了一个初步的设计。它还没有开始驱动完整的实现。我们将通过后续的测试来完成这一点。这个过程被称为
    *三角测量法*，其中我们依赖于添加测试来驱动出缺失的实现细节。通过这样做，我们的所有代码都被测试覆盖了。我们免费获得了 100% *有意义的* 代码覆盖率。更重要的是，它将我们的工作分解成更小的块，通过频繁的可交付成果创造进展，并可能导致一些有趣的解决方案。
- en: Another thing to notice is that our one test led us to create two classes, covered
    by that one test. This is highly recommended. Remember that our unit test covers
    a behavior, not any specific implementation of that behavior.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意是，我们的一个测试引导我们创建了两个类，这些类都由这个测试覆盖。这是非常推荐的。记住，我们的单元测试覆盖的是一个行为，而不是该行为的任何特定实现。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We’ve taken our first steps into TDD and learned about the AAA structure of
    each test. We’ve seen how it is possible to design our software and write our
    test before our production code and get cleaner, more modular designs as a result.
    We learned what makes for a good test and learned some common techniques used
    to catch common programming errors and test code that throws exceptions.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经迈出了 TDD 的第一步，并了解了每个测试的 AAA 结构。我们看到了如何在编写生产代码之前设计我们的软件和编写测试，并因此得到更干净、更模块化的设计。我们学习了什么是一个好的测试，并了解了一些常用的技术，用于捕捉常见的编程错误和测试抛出异常的代码。
- en: It is important to understand the flow of using AAA sections inside our FIRST
    tests, as this gives us a template we can reliably follow. It is also important
    to understand the flow of design ideas, as used in the previous Wordz example.
    Writing our tests is literally taking the design decisions we make and capturing
    them in unit test code. This provides fast feedback on how clean our design is,
    as well as providing an executable specification for future readers of our code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 理解在 FIRST 测试中使用 AAA 部分的流程非常重要，因为这为我们提供了一个我们可以可靠遵循的模板。同样重要的是理解设计想法的流程，正如在之前的
    Wordz 示例中所使用的那样。编写我们的测试实际上是将我们做出的设计决策捕捉到单元测试代码中。这为我们提供了关于设计是否干净的快速反馈，同时也为未来阅读我们代码的人提供了一个可执行的规范。
- en: In the next chapter, we will add tests and drive out a complete implementation
    for our word-scoring object. We will see how TDD has a rhythm that drives work
    forward. We will use the **Red, Green, Refactor** approach to keep refining our
    code and keep both code and tests clean without overengineering them.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将添加测试，并为我们的单词评分对象驱动出一个完整的实现。我们将看到 TDD 如何推动工作前进。我们将使用 **红、绿、重构** 方法来不断改进我们的代码，并保持代码和测试的清洁，而不会过度设计。
- en: Questions and answers
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题与答案
- en: How do we know what test to write if we have no code to test?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们没有代码可以测试，我们如何知道要编写什么测试？
- en: We reframe this thinking. Tests help us design a small section of code upfront.
    We decide what interface we want for this code and then capture these decisions
    in the AAA steps of a unit test. We write just enough code to make the test compile,
    and then just enough to make the test run and fail. At this point, we have an
    executable specification for our code to guide us as we go on to write the production
    code.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重新审视这种思考方式。测试帮助我们提前设计一小段代码。我们决定我们想要这个代码的接口，然后通过单元测试的 AAA 步骤来捕捉这些决策。我们只编写足够的代码来使测试编译，然后只编写足够的代码来使测试运行并失败。在这个时候，我们有一个可执行的规范来指导我们编写生产代码。
- en: Must we stick to one test class per production class?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须坚持每个生产类对应一个测试类吗？
- en: No, and this is a common misunderstanding when using unit tests. The goal of
    each test is to specify and run a behavior. This behavior will be implemented
    in some way using code – functions, classes, objects, library calls, and the like
    – but this test in no way constrains how the behavior is implemented. Some unit
    tests test only one function. Some have one test per public method per class.
    Others, like in our worked example, give rise to more than one class to satisfy
    the test.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这是使用单元测试时常见的误解。每个测试的目标是指定和运行一个行为。这个行为将以某种方式通过代码实现——函数、类、对象、库调用等——但这个测试在没有任何方式约束行为是如何实现的。一些单元测试只测试一个函数。一些类每个公共方法都有一个测试。其他，就像我们在工作示例中看到的那样，会产生多个类来满足测试。
- en: Do we always use the AAA structure?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们总是使用 AAA 结构吗？
- en: It’s a useful recommendation to start out that way but we sometimes find that
    we can omit or collapse a step and improve the readability of a test. We might
    omit the Arrange step, if we had nothing to create for, say, a static method.
    We may collapse the Act step into the Assert step for a simple method call to
    make the test more readable. We can factor our common Arrange step code into a
    *JUnit* `@BeforeEach` annotate method.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式开始是一个有用的建议，但我们有时发现我们可以省略或合并一个步骤，从而提高测试的可读性。如果我们没有为静态方法创建任何内容，我们可能会省略 Arrange
    步骤。我们可能将 Act 步骤合并到 Assert 步骤中，以简化方法调用，使测试更易读。我们可以将常见的 Arrange 步骤代码提取到一个 *JUnit*
    `@BeforeEach` 注解方法中。
- en: Are tests throwaway code?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试是废弃代码吗？
- en: No. They are treated with the same importance and care as production code. The
    test code is kept clean just as the production code is kept clean. The readability
    of our test code is paramount. We must be able to skim-read a test and quickly
    see why it exists and what it does. The test code is not deployed in production
    but that does not make it any less important.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 不。它们被赋予了与生产代码相同的重要性和关注。测试代码的整洁度就像生产代码的整洁度一样。我们测试代码的可读性至关重要。我们必须能够快速浏览测试并迅速了解其存在的原因和作用。测试代码不会在生产环境中部署，但这并不意味着它不那么重要。
