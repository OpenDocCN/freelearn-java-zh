- en: Microservice Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务模式
- en: In this chapter, we will learn about what microservices patterns are. We will
    also compare these with the monolithic patterns, looking at the advantages and
    drawbacks of a microservices-based application, as well as learn when to use microservices.
    Furthermore, we will also demonstrate how to switch from a traditional monolithic
    application to a microservices application, using implementation examples throughout. We
    will then look at the design patterns used to compose the microservices. After
    reading this chapter, you will be able to identify the parts of an application
    code that are eligible to be microservices, and you will also know how to implement
    a microservices-pattern-based application using Java EE 8.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习微服务模式是什么。我们还将将这些模式与单体模式进行比较，探讨基于微服务的应用程序的优势和缺点，以及学习何时使用微服务。此外，我们还将通过实例演示如何从传统的单体应用程序切换到微服务应用程序，并使用实现示例。然后，我们将探讨用于组合微服务的模式。阅读本章后，您将能够识别出应用程序代码中哪些部分适合作为微服务，并且您还将了解如何使用Java
    EE 8实现基于微服务模式的程序。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Explaining microservices patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释微服务模式
- en: Explaining how microservices architecture works
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释微服务架构是如何工作的
- en: Explaining when to use microservices architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释何时使用微服务架构
- en: Advantages and drawbacks of a microservices-based application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于微服务的应用程序的优势和缺点
- en: Microservices architecture patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构模式
- en: Implementing microservices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施微服务
- en: Explaining microservices patterns
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释微服务模式
- en: Many years ago, I had the opportunity to work as a system architect and developer
    on an administrative–financial system. This involved the use of modules, such
    as accounts receivable and accounts payable, inventory control, purchasing, payroll,
    accounting, and so on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 多年前，我有机会在一个行政-财务系统上担任系统架构师和开发者。这涉及到使用诸如应收账款、应付账款、库存控制、采购、工资、会计等模块。
- en: The whole system was composed of several modules, and the delivery of the system
    was constructed in a modular way too. At the end of the application development,
    we had a large, integrated system with many dependencies between the modules.
    It was obvious that the system should be integrated, and we knew that very well.
    However, this integration was made with many dependencies and a strong coupling
    between modules. Sometime later, we also discovered that the dependencies and
    strong coupling were unnecessary.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 整个系统由几个模块组成，系统的交付也是以模块化的方式构建的。在应用程序开发结束时，我们得到了一个庞大、集成的系统，模块之间存在许多依赖关系。显然，系统应该集成，我们也非常清楚这一点。然而，这种集成是通过许多依赖关系和模块之间的强耦合实现的。后来，我们还发现这些依赖关系和强耦合是不必要的。
- en: We faced a lot of problems in maintaining the application (such as difficulty
    in implementing new frameworks and excessive bureaucracy), including the fact
    that whenever there was a need to include a functionality that originated from
    a requirement, we had to find the part of the code that was responsible for the
    problem, make the change, test it, and make a redeployment of the entire application.
    In addition to this, other related issues sometimes appeared, such as using a
    third-party library or framework to implement this new functionality. There was
    a bit of bureaucracy to that too. In short, a lot of time was spent on changing
    the application, and this only got worse as the application became larger.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在维护应用程序时，我们遇到了许多问题（如实施新框架的困难以及过度官僚主义），包括每当需要包含来自需求的功能时，我们必须找到负责问题的代码部分，进行更改，测试，然后重新部署整个应用程序。除此之外，有时还会出现其他相关问题，例如使用第三方库或框架来实现这个新功能。在这方面也有一些官僚主义。简而言之，我们花费了大量时间来更改应用程序，而且随着应用程序的增大，这个问题变得更加严重。
- en: After the system was ready, we wondered what it would be like if each module
    had its own life—that is, if each module behaved as a mini-application, so that
    it could be deployed without impacting the other modules. Furthermore, if each
    module could be developed practically in parallel, and there was minimum coupling
    required, then that would be very beneficial to the development and maintenance
    of the application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 系统准备就绪后，我们想知道如果每个模块都有自己的生命——也就是说，如果每个模块都像是一个小程序，那么它就可以独立部署，而不会影响其他模块。此外，如果每个模块可以实际并行开发，并且需要最小的耦合，那么这对应用程序的开发和维护将非常有益。
- en: Bringing it back to the present day, we noticed that among the several characteristics
    that are most often desired for the components of a system, we can highlight low
    coupling, which guarantees parallel development and much better maintenance.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 回到当今时代，我们注意到，在系统组件最常期望的几个特性中，我们可以突出低耦合，这保证了并行开发和更好的维护。
- en: There is an architecture pattern called *microservices architecture* that partitions
    the application into several small services that have specific functions or responsibilities
    with very low coupling between these services, and which provides very good features,
    such as excellent evolutionary maintenance.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一种名为*微服务架构*的架构模式，它将应用程序划分为几个具有特定功能或职责的小型服务，这些服务之间的耦合度非常低，并且提供了非常好的特性，例如卓越的演进维护。
- en: When it comes to an architecture that is based on microservices, it is much
    easier to implement each of the modules of the administrative–financial application
    as mini-applications. An accounts payable module, for example, would need its
    front end, and would depend on the combination of some microservices (such as
    a service that provides the constant accounts, another that provides the variable
    accounts, another that provides the payroll, and so on) in order to work.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到基于微服务的架构时，将行政-财务应用程序的每个模块作为微型应用程序来实现要容易得多。例如，应付账款模块需要其前端，并且需要依赖于一些微服务的组合（例如，提供固定账户的服务，提供变动账户的服务，提供工资单的服务等等）才能工作。
- en: Of course, there are advantages and drawbacks to the microservices-based approach,
    and we should look closely at an application to determine whether it is worth
    using this architecture. The architecture based on microservices acts as a counterpoint
    to the traditional monolithic architecture in which the modules are much more
    coupled. So to discuss the architecture of microservices and establish a better
    definition of what microservices are, we must talk about monolithic architecture.
    This is exactly what we will do next.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，基于微服务的方法既有优点也有缺点，我们应该仔细查看应用程序，以确定是否值得使用这种架构。基于微服务的架构作为传统单体架构的对立面，其中模块的耦合度要高得多。因此，为了讨论微服务架构并更好地定义微服务是什么，我们必须谈论单体架构。这正是我们接下来要做的。
- en: Here is a brief comparison between microservices and SOA. Some people like to
    refer to microservices architecture as a lightweight SOA. Both architectures aim
    to break a monolithic scenario to increase scalability and maintenance. However,
    while SOA is enterprise-oriented, where applications can speak more easily, microservices
    are small, integrated services that form one or more business functionalities.
    This is the main difference—microservices are the result of the functional decomposition
    of a monolithic application into small, smart, and loosely coupled (such as SOA)
    components with well-defined responsibilities and easy maintenance.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对微服务和SOA之间的一种简要比较。有些人喜欢将微服务架构称为轻量级的SOA。这两种架构的目标都是打破单体场景，以增加可扩展性和维护性。然而，虽然SOA是面向企业的，其中应用程序可以更容易地进行通信，但微服务是由形成一个或多个业务功能的小型、集成服务组成的。这是主要区别——微服务是将单体应用程序分解成小型、智能且松散耦合（如SOA）的组件，这些组件具有明确的职责和易于维护的结果。
- en: Inside a monolithic application
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在单体应用程序内部
- en: A typical application contains a presentation layer, which is the client side
    of the application, a persistence layer or database, and an intermediary layer,
    which is the server side of the application and contains the business logic. The
    layer that interests us is the intermediary layer. This receives the requests
    from the client layer, performs some business logic, accesses the database if
    necessary (executing queries and updates), and provides the result to the client
    layer.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 典型应用程序包含一个表示层，即应用程序的客户端，一个持久层或数据库，以及一个中介层，即应用程序的服务器端，包含业务逻辑。我们感兴趣的层是中介层。它接收来自客户端层的请求，执行一些业务逻辑，如果需要则访问数据库（执行查询和更新），并将结果提供给客户端层。
- en: This server-side layer generally consists of several modules or services. Although
    the application has a modular architecture, the application is deployed and packaged
    as a monolithic block. Modules represented by classes and files are contained
    in packaging files (EAR, WAR). These files are deployed together and belong to
    the same deployment. Most Java-based applications are packaged in a single `.war`
    or `.ear` file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层服务器端通常由几个模块或服务组成。尽管应用程序具有模块化架构，但应用程序的部署和打包却作为一个单体块。由类和文件表示的模块包含在打包文件（EAR、WAR）中。这些文件一起部署，属于同一个部署。大多数基于Java的应用程序都打包在一个单独的`.war`或`.ear`文件中。
- en: 'The following diagram shows an example of an academic–financial system in a
    college:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了大学中一个学术-财务系统的示例：
- en: '![](img/3be57cdf-3210-4813-837b-ca04056c6012.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3be57cdf-3210-4813-837b-ca04056c6012.png)'
- en: 'The various modules of the application are deployed to a single file on the
    **Application Server**. Generally, the application runs in a single process:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的各个模块被部署到**应用服务器**上的单个文件。通常，应用程序在一个单独的进程中运行：
- en: '![](img/62b64fd4-034f-49ee-b55a-2c9d32ee4075.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/62b64fd4-034f-49ee-b55a-2c9d32ee4075.png)'
- en: For simple applications with a limited number of business tasks, the monolithic
    way of doing things such as coding (there is usually only one language for server-side
    coding, and there is a unique data persistence technology), testing, and deploying
    is also fairly simple. However, some serious problems appear as the application
    begins to grow in complexity and the microservices will also be used to solve
    these problems. Later in this chapter, we will have a specific section showing
    the advantages and drawbacks of microservices architecture.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有有限业务任务的简单应用程序，如编码（服务器端编码通常只有一种语言，并且有独特的数据持久化技术）、测试和部署的单体方式也相当简单。然而，随着应用程序复杂性的增加，微服务也将被用来解决这些问题。在本章的后面部分，我们将有一个专门的部分展示微服务架构的优点和缺点。
- en: 'Here are some of these problems:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些这些问题：
- en: Difficulty in implementing new features and fixing bugs
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现新功能和修复错误困难
- en: Long application startup time
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长时间应用程序启动时间
- en: Inefficient continuous deployment
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低效的持续部署
- en: Low reliability
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠性低
- en: Difficulty using new frameworks and technologies
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新框架和技术困难
- en: Difficulty in implementing new features and fixing bugs
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现新功能和修复错误困难
- en: Over the years, the application grows and more lines of code are added to preexisting
    codes. Even when approaching the code with caution using the best object-oriented
    practices and patterns (low coupling and code reuse), the number of classes and
    libraries tends to grow. Maintenance becomes much more difficult. Common problems
    may arise, such as an increase in the responsibilities of some classes. This issue
    is more critical because the development team always changes. The code becomes
    more difficult to understand and some required changes can be made incorrectly.
    As a consequence of this, we have a delay in implementation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，应用程序不断增长，更多的代码行被添加到现有代码中。即使使用最佳面向对象实践和模式（低耦合和代码重用）谨慎地接近代码，类和库的数量也往往会增加。维护变得更加困难。常见问题可能包括某些类的责任增加。这个问题更加关键，因为开发团队总是变化的。代码变得更加难以理解，一些必要的更改可能会被错误地执行。因此，我们会有实施延迟。
- en: Long application startup time
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长时间应用程序启动时间
- en: As an application gets bigger (more classes, libs, and files), its initialization
    slows down, and the developer will take a lot of time to start up the application.
    Doing this several times a day greatly increases development time, so this is
    another factor that impacts the maintenance of the application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序变大（更多类、库和文件），其初始化速度会减慢，开发者启动应用程序将花费大量时间。每天这样做几次会大大增加开发时间，因此这也是影响应用程序维护的另一个因素。
- en: Inefficient continuous deployment
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低效的持续部署
- en: For each required change in the application, you need to deploy it in its entirety.
    Continuous deployment is very difficult because every time a part of the code
    is changed, the entire application must be deployed. Of course, in a test environment,
    you can group multiple changes together and make a single deployment. However,
    this is still inefficient as it requires all implementations to be completed.
    This scenario becomes worse for applications that require a deployment to be in
    production several times a day.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用中每个必需的更改，您需要将其全部部署。持续部署非常困难，因为每次代码的一部分被更改时，整个应用都必须重新部署。当然，在测试环境中，您可以一起分组多个更改并执行单一部署。然而，这仍然效率低下，因为它要求所有实现都已完成。对于每天需要多次部署到生产环境的应用，这种情况变得更糟。
- en: Low reliability
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低可靠性
- en: The modules of a monolithic application usually run in the same process. Any
    error or bug in a module (such as a memory leak) impacts the entire process and,
    consequently, the entire application. Even if an application is executed with
    several nodes of the clustering system, and even if there are several instances
    of the application, the problem can be propagated by the other instances of the
    application if the error is due to the code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用的模块通常在同一个进程中运行。模块中的任何错误或缺陷（如内存泄漏）都会影响整个进程，进而影响整个应用。即使应用在集群系统的多个节点上执行，即使有多个应用实例，如果错误是由于代码引起的，问题也可能通过其他应用实例传播。
- en: Difficulty using new frameworks and technologies
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新框架和技术时的困难
- en: In a large monolithic application with thousands and thousands of lines of written code,
    replacing a framework or even including new features is difficult because it will
    require changes in many parts of the application. Sometimes we should rewrite
    almost all of the code; situations like this are very common. The quality of the
    product does not improve, and the effort to maintain this quality gets much higher
    because the development team does not have enough time to introduce the new framework.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个拥有成千上万行代码的大型单体应用中，替换框架或添加新功能都是困难的，因为这需要应用多个部分的更改。有时我们几乎需要重写所有代码；这种情况非常常见。产品的质量并没有提高，而维持这种质量所需的努力却大大增加，因为开发团队没有足够的时间引入新的框架。
- en: The scale cube
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规模立方体
- en: '*The Art of Scalability* by Martin L. Abbott and Michael T. Fisher presents
    a three-dimensional scalability model called the scale cube. See the following
    diagram for more details:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*《可扩展性艺术》* 由马丁·L·艾博特和迈克尔·T·费舍尔所著，提出了一个称为“规模立方体”的三维可扩展性模型。更多详情请参见以下图表：'
- en: '![](img/859f2c4f-d115-455f-9098-74995155afdc.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图表](img/859f2c4f-d115-455f-9098-74995155afdc.png)'
- en: 'This model shows that we can scale an application in three different ways,
    which are listed as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型表明我们可以以三种不同的方式扩展应用，如下所示：
- en: '***X-*axis scaling:** This is the most common model, and proposes the execution
    of multiple clones of an application under the supervision of a load balancer.
    This type of scalability is also called **horizontal scalability**, where the
    solution for meeting the demand is the addition of more servers.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***X-轴扩展：*** 这是最常见的模型，它建议在负载均衡器的监督下执行多个应用副本。这种可扩展性也称为**水平扩展**，其中满足需求的解决方案是添加更多服务器。'
- en: '***Z-*axis scaling:** This is similar to *X*-axisscaling (multiple instances
    running the same code), but in this case, each server takes responsibility for
    a part of the data. This type of scalability uses the concept of sharding, most
    commonly in the database.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Z-轴扩展：*** 这与X轴扩展（运行相同代码的多个实例）类似，但在此情况下，每个服务器负责一部分数据。这种可扩展性使用了分片的概念，最常见于数据库。'
- en: '***Y-*axis scaling:** This has the strategy of decomposing the application
    in different services. The architecture of microservices is an example of *Y*-axis
    scaling. Using this scalability approach, a monolithic application is decomposed
    into a set of services. Each service is responsible for a set of related functionalities.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Y-轴扩展：*** 这具有将应用分解为不同服务的策略。微服务架构是Y轴扩展的一个例子。使用这种可扩展性方法，单体应用被分解为一组服务。每个服务负责一组相关的功能。'
- en: What microservices actually are
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际上的微服务是什么
- en: We can define microservices architecture as a way to develop an application
    using a set of small, low-coupling, independent, and deployable services. Each
    microservice is very well-defined, meaning that each microservice is responsible
    for a single task that is well-defined.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将微服务架构定义为使用一系列小型、低耦合、独立且可部署的服务来开发应用程序的方法。每个微服务都定义得非常明确，这意味着每个微服务都负责一个定义良好的单一任务。
- en: So, microservices are small components that perform a specific job and may be
    used to benefit a business. Therefore, when developing an application under the
    architecture of microservices, we must break this same application into small
    components that are the microservices. As well as the other characteristics that
    we will see later, microservices can be changed and deployed without degrading
    the application itself.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，微服务是执行特定任务的小型组件，可能被用来为商业带来利益。因此，当在微服务架构下开发应用程序时，我们必须将这个应用程序分解成相同的微服务组件。以及我们将在后面看到的其他特征，微服务可以在不降低应用程序本身质量的情况下进行更改和部署。
- en: Microservices are not a silver bullet
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务并非万能的解决方案
- en: Like any technological solution, there are advantages and drawbacks to microservices,
    which will be explored later in this chapter. If microservices are applied well,
    then they will increase the reliability and scalability of an application that
    grows in complexity. However, the very nature of microservices can bring problems
    when they are poorly implemented.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 任何技术解决方案都有其优点和缺点，微服务也不例外，这些将在本章后面进行探讨。如果微服务应用得当，那么它们将提高复杂增长的应用程序的可靠性和可伸缩性。然而，微服务的本质在实施不当时可能会带来问题。
- en: The strong independence of microservices means that they can be created using
    different languages, and can communicate using different protocols and APIs. In
    addition, an application may contain numerous microservices that are used for
    the benefit of the business. The plurality and quantity of the microservices make
    the control of these same microservices quite complex. Some extra care and energy
    should be taken in the implementation of an application based on microservices
    architecture.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的强独立性意味着它们可以使用不同的语言创建，并且可以使用不同的协议和API进行通信。此外，一个应用程序可能包含许多用于商业利益的微服务。微服务的多样性和数量使得对这些相同微服务的控制相当复杂。在基于微服务架构的应用程序实现中，应该格外小心并投入额外的精力。
- en: Explaining how microservices architecture works
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释微服务架构是如何工作的
- en: Although there is still no formal model to follow when implementing microservices
    architecture, we can highlight some common characteristics. We can also verify
    good practices when developing microservices.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在实施微服务架构时还没有一个正式的模型可以遵循，但我们仍然可以强调一些共同的特征。我们还可以在开发微服务时验证良好的实践。
- en: 'With one or more related functionalities, a microservice is a small portion
    of the application that is used to benefit the business. From this definition
    of microservices, we will now look at each of the following common characteristics
    of microservices in detail:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 具有一个或多个相关功能，微服务是应用程序中用于商业利益的小部分。从这个微服务的定义出发，我们现在将详细探讨以下微服务的常见特征：
- en: The application is decomposed into smaller components
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序被分解成更小的组件
- en: Multitask teams
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多任务团队
- en: Product focus
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品焦点
- en: Simpler and smarter processing.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单而智能的处理。
- en: Decentralized governance of libraries and APIs
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库和API的去中心化管理
- en: Single responsibility principle
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: Fault tolerance
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容错性
- en: Evolutionary systems
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进化系统
- en: Decentralized data
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去中心化数据
- en: The application is decomposed into smaller components
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序被分解成更小的组件
- en: While developing an application based on microservices architecture, we should
    consider breaking the application into smaller components that will be changed
    and deployed separately (as opposed to a monolithic application that must be fully
    deployed with every change of code). However, splitting an application into small
    services that act independently requires a longer development time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发基于微服务架构的应用程序时，我们应该考虑将应用程序分解成更小的组件，这些组件将分别进行更改和部署（与每次代码更改都必须完全部署的单一应用程序相反）。然而，将应用程序分解成独立操作的小型服务需要更长的时间来开发。
- en: 'The following diagram shows the access of the client of an application to a
    business component:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了应用程序客户端对业务组件的访问：
- en: '![](img/799b5bef-8c91-4a3c-af2b-e6feea7000c4.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/799b5bef-8c91-4a3c-af2b-e6feea7000c4.png)'
- en: 'The following diagram shows the same client accessing the same functionality
    via microservices:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了相同的客户端通过微服务访问相同的功能：
- en: '![](img/106c1994-3abe-45a5-99ff-863d6d9d79c8.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/106c1994-3abe-45a5-99ff-863d6d9d79c8.png)'
- en: 'Because microservices are small and independent, they can cause problems with
    accessing more complex services. These problems are described as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务小且独立，它们可能导致访问更复杂服务的问题。这些问题如下所述：
- en: '**Calls to several microservices to meet a functionality**: Generally, clients
    need services or functionalities that involve calls to several microservices. For
    example, in an academic–financial management system, a client who wants rich detail
    on the history of a college student may have to access many microservices. So, making
    multiple calls to various microservices reduces network performance, and this
    is critical when there is a mobile client.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用多个微服务以实现功能**：通常，客户端需要的服务或功能可能涉及对多个微服务的调用。例如，在一个学术-财务管理系统中，一个想要了解大学生历史详细信息的客户端可能需要访问许多微服务。因此，对各种微服务进行多次调用会降低网络性能，这在存在移动客户端的情况下尤为重要。'
- en: '**Microservices can use different protocols**: Because microservices are independent,
    they may require different protocols to be accessed, such as REST, WebSocket,
    and so on. In other words, there is no uniformity of protocol for accessing microservices,
    and we can imagine how time-consuming it would be to have to communicate with
    each of these microservices.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务可以使用不同的协议**：由于微服务是独立的，它们可能需要不同的协议来访问，例如REST、WebSocket等。换句话说，访问微服务的协议并不统一，我们可以想象，如果需要与每个微服务进行通信，这将多么耗时。'
- en: '**Different types of clients**: There are different types of clients, such
    as mobile clients and desktop clients. Each of these clients also has different
    needs. The amount of information offered to a mobile client is generally less
    rich than that offered for a desktop client. Another important issue is that network
    performance is different for these different types of client. A mobile network
    is slower than a local network.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不同类型的客户端**：存在不同类型的客户端，例如移动客户端和桌面客户端。这些客户端各自也有不同的需求。提供给移动客户端的信息量通常比桌面客户端少。另一个重要问题是，不同类型的客户端的网络性能不同。移动网络比本地网络慢。'
- en: 'In the following diagram, we can see an example of a set of functionalities
    that are found in a system and their respective calls to the various microservices
    of the application:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，我们可以看到一个系统中存在的一组功能及其对应用程序中各个微服务的相应调用：
- en: '![](img/8cde92e1-8972-4cc2-9d7f-4c92707806b9.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8cde92e1-8972-4cc2-9d7f-4c92707806b9.png)'
- en: The price to pay for decomposing an application into a set of microservices
    is quite clear. Controlling the various calls to microservices is a complex task,
    and there is still the question of having a single database. In these cases, transaction
    control becomes more complex.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序分解成一组微服务的代价是相当明显的。控制对微服务的各种调用是一项复杂的任务，而且仍然存在单一数据库的问题。在这些情况下，事务控制变得更加复杂。
- en: To meet this set of problems, there is a solution called the API gateway that
    establishes a type of frontend for the clients of the application based on microservices.
    The API gateway interposes between clients and microservices. Sometimes, the request
    is just a call to a microservice, but in other cases, the API gateway functions
    as a coarse granulation layer that receives the request to a service and makes
    several calls to microservices.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这一系列问题，存在一个名为API网关的解决方案，它为基于微服务的应用程序客户端建立了一种前端。API网关位于客户端和微服务之间。有时，请求只是对微服务的调用，但在其他情况下，API网关充当一个粗粒度层，接收对服务的请求并对多个微服务进行调用。
- en: 'We can see this in the following diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下图中看到这一点：
- en: '![](img/2623eee3-a700-40bd-8100-c6850b72f430.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2623eee3-a700-40bd-8100-c6850b72f430.png)'
- en: Access to the various microservices from the client application works in the
    same way as if we were using an API. The **API Gateway** is in charge of accessing
    the different microservices and worrying about the different protocols used for
    this access. However, depending on the type of client application (whether it
    is a mobile app or a browser application, for instance), a certain system functionality
    may be different. For example, if we are in a mobile application, the amount of
    information that would be consulted in accessing the student's history would be
    less than a browser application would access (either because the presentation
    screens are different or because of performance issues in accessing the various
    microservices). Taking this problem into account, besides being an interface layer
    for microservice calls, the API gateway can still offer a specific API for each
    type of client.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序访问各种微服务的方式与使用API时相同。**API网关**负责访问不同的微服务，并关注用于此访问的不同协议。然而，根据客户端应用程序的类型（例如，是移动应用还是浏览器应用），某些系统功能可能不同。例如，如果我们在一个移动应用中，访问学生历史记录时需要查询的信息量将少于浏览器应用访问的信息量（要么是因为展示屏幕不同，要么是因为访问各种微服务时的性能问题）。考虑到这个问题，除了作为微服务调用的接口层之外，API网关还可以为每种类型的客户端提供特定的API。
- en: 'So, a client mobile would access a mobile API, while a web client or a browser
    would access a web API. We can see this in the following diagram:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，移动客户端会访问移动API，而Web客户端或浏览器会访问Web API。我们可以在以下图中看到这一点：
- en: '![](img/871ac169-b065-4e3e-8341-06e5f81c2cfb.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/871ac169-b065-4e3e-8341-06e5f81c2cfb.png)'
- en: In short, the **API Gateway** works as a general translator. So, the client
    focuses on the business and not on the translation for the requests or the answers.
    In addition, the client can make one call instead of several calls (if the functionality
    requires numerous microservices), which effectively improves network performance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，**API网关**充当通用翻译器的角色。因此，客户端专注于业务，而不是请求或响应的翻译。此外，客户端可以一次性调用（如果功能需要多个微服务），这有效地提高了网络性能。
- en: Multitask teams
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多任务团队
- en: In a monolithic application, there are specialized teams in each part of the
    application—a database team, a team that develops in the backend (Java), and a
    design team.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体应用中，每个应用部分都有专门的团队——数据库团队、后端（Java）开发团队和设计团队。
- en: In a microservice-based application, there is a multitask team, which is responsible
    for all parts of the microservice. Consequently, the team must be a generalist.
    But we know that even for a monolithic application, the developer often works
    as a full stack developer, and has the task of developing all parts of the application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于微服务的应用中，有一个多任务团队，负责微服务的所有部分。因此，该团队必须是全能的。但我们知道，即使是对于单体应用，开发者通常也作为全栈开发者工作，负责开发应用的所有部分。
- en: Product focus
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品导向
- en: 'In a monolithic application, the focus is always the application project, and
    the code is usually delivered to the application customer. However, in a microservices-based
    application, the focus is always on the product. The team that is responsible
    for the microservice can change and evolve the product without the typical delays
    experienced in a monolithic application. The product belongs to the development
    team that is responsible for the microservice, as shown in the following diagram:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体应用中，焦点始终是应用项目，代码通常交付给应用客户。然而，在基于微服务的应用中，焦点始终是产品。负责微服务的团队可以改变和演进产品，而不会像在单体应用中那样经历典型的延迟。产品属于负责微服务的开发团队，如下面的图所示：
- en: '![](img/7f03d386-d564-4ae1-92ca-04346ceda145.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f03d386-d564-4ae1-92ca-04346ceda145.png)'
- en: Simpler and smarter processing
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化且智能的处理
- en: Microservices perform specialized and intelligent tasks through an extremely
    practical operation—there is a request, something is processed, and a response
    is returned to the microservice client.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通过极其实用的操作执行专业和智能的任务——有一个请求，处理某些内容，并将响应返回给微服务客户端。
- en: Decentralized governance of libraries and APIs
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图书馆和API的去中心化治理
- en: Microservices are used and called in one or more points of an application, or
    they are used by various applications. Furthermore, we must keep in mind the independent
    nature of microservices. As a result, there is a natural encouragement for the
    decentralization and governance of APIs and libraries. This means that microservice
    developers should use the tools that they think are necessary for microservice
    development, as long as the interface with the client does not change.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务被用于一个或多个应用程序的点，或者被各种应用程序使用。此外，我们必须牢记微服务的独立性。因此，对API和库的去中心化和治理有自然的促进作用。这意味着微服务开发者应该使用他们认为对微服务开发必要的工具，只要客户端的接口不改变。
- en: Single responsibility principle
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: A microservice should always have a small set of responsibilities. This definition
    is based on a principle called the single responsibility principle, which states
    that *a class must have only one reason to change*. In other words, a class with
    more than one motive to change would have more responsibilities, and would not
    be cohesive. This would create problems, such as high coupling between the responsibilities
    of a class, difficulty in reusing code, and difficult maintenance.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该始终具有一组小的职责。这个定义基于一个称为单一职责原则的原则，该原则指出“一个类必须只有一个改变的理由”。换句话说，具有多个改变动机的类会有更多的职责，并且不会具有内聚性。这会导致问题，例如类职责之间的高耦合性、代码重用困难以及维护困难。
- en: 'A class that had methods that are responsible for calculation, as well as methods
    for formatting the result, would be an example of a class with little cohesion.
    Let''s look at the following example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有负责计算的方法以及格式化结果的方法的类，将是一个具有很少内聚性的类的例子。让我们看看以下示例：
- en: '[PRE0]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first method (`calculateCotation`) is directly related to the business domain
    and the others (`generatePDF` and `generateXLS`) are related to the presentation
    of the calculated values.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法（`calculateCotation`）与业务领域直接相关，而其他方法（`generatePDF`和`generateXLS`）与计算值的展示相关。
- en: 'The SRP principle is part of a set of five principles called SOLID principles,
    which were popularized by Robert Cecil Martin (colloquially known as Uncle Bob)
    after the publication of his book *Agile Software Development: Principles, Patterns,
    and Practices*. In fact, these five principles are a subset of several principles
    reported in the book. The SOLID principles are principles of object-oriented programming,
    a paradigm whose purpose is to keep code more organized and easy to read. We can
    make an association between the word "solid" and the expression "solid code".
    Each of the five letters of the acronym SOLID is an initial of a principle:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP）是被称为SOLID原则的五个原则之一，这些原则由罗伯特·塞西尔·马丁（俗称Uncle Bob）在其著作《敏捷软件开发：原则、模式和最佳实践》出版后普及。实际上，这五个原则是书中报告的几个原则的子集。SOLID原则是面向对象编程的原则，其目的是使代码更加有序和易于阅读。我们可以将“solid”这个词与“solid
    code”这个表达联系起来。SOLID这个缩写的每个字母都是原则的首字母：
- en: '**S**ingle responsibility principle (SRP)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**S**ingle responsibility principle（SRP）'
- en: '** O**pen closed principle (OCP)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**O**pen closed原则（OCP）'
- en: '** L**iskov substitution principle (LSP)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**L**iskov替换原则（LSP）'
- en: '** I**nterface segregation principle (ISP)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '** I**nterface segregation principle（ISP）'
- en: '** D**ependency inversion principle (DIP)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '** D**ependency inversion principle（DIP）'
- en: Fault tolerance
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容错
- en: Because an application is now decomposed into multiple microservices, there
    is a greater chance of failure because one or more microservices can and probably
    will fail.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序现在分解为多个微服务，因此失败的可能性更大，因为一个或多个微服务可能会失败，甚至很可能失败。
- en: Implementing a microservice-based application should take this into account.
    A microservice is implemented in such a way that it has a small impact in the
    case of failure and there is a recovery as soon as possible. As a result, the
    microservices-based application must be developed with fault tolerance as its
    goal. Of course, such an implementation increases the complexity of development.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 实现基于微服务的应用程序时应考虑这一点。微服务以这种方式实现，即失败时影响很小，并且可以尽快恢复。因此，基于微服务的应用程序必须以容错为目标进行开发。当然，这样的实现增加了开发的复杂性。
- en: The recovery task is facilitated because of the nature of the microservice.
    Because it is a small service, it can be created or initialized quickly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务的性质，恢复任务得到了简化。因为它是一个小服务，所以它可以快速创建或初始化。
- en: Evolutionary systems
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进化系统
- en: A microservices-based architecture is ideal for systems that have increased
    requirements and functionality over time. Systems that have a significant increase
    in business need services that can be reused. They also need a clear separation
    between their responsibilities, which are offered precisely by microservices.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 基于微服务的架构非常适合随着时间的推移而增加要求和功能的系统。那些业务需求显著增加的系统需要可重用的服务。他们还需要职责的清晰分离，这正是微服务提供的。
- en: Decentralized data
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分散式数据
- en: Each microservice has its own database—that is, each microservice has its own
    way of managing data, instead of a single, centralized database for the entire
    application, or even for the whole company. This means that, depending on the
    services, the databases may be quite different. We can have a relational database
    (or more than one), we can have NoSQL of several types as a documentary database,
    a graph database, or other kinds of database.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务都有自己的数据库——也就是说，每个微服务都有自己管理数据的方式，而不是整个应用程序或整个公司的单一、集中式数据库。这意味着，根据服务类型，数据库可能相当不同。我们可以有一个关系型数据库（或多个），我们可以有几种类型的NoSQL作为文档数据库、图数据库或其他类型的数据库。
- en: Explaining when to use microservices architecture
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释何时使用微服务架构
- en: 'Taking into account the characteristics of an application based on the architecture
    of microservices, we can establish some criteria of when to use microservices architecture,
    as shown in the following bullet list:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑基于微服务架构的应用程序特性，我们可以确定何时使用微服务架构的一些标准，如下面的项目符号列表所示：
- en: When a system grows in its amount of requirements and functionalities, meaning
    that it has evolved quickly. In this case, the system begins to mix the responsibilities
    between its modules.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个系统的需求和功能增加时，这意味着它已经迅速发展。在这种情况下，系统开始在其模块之间混合职责。
- en: When we need to reuse services.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要重用服务时。
- en: When the centralization of the APIs begins to block the evolution of the system.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当API的集中化开始阻碍系统的演变时。
- en: When there is a need for new features, APIs, libraries, and frameworks, and
    we do not want to rewrite all of the software for this.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要新功能、API、库和框架时，我们不想为此重写所有软件。
- en: Imagine that we have a sensational and innovative business model, and we must
    quickly make an application available for customers to enjoy this business. The
    adoption of a monolithic model, in principle, would make the application develop
    quickly, with quick tests and deployments as well. At this point, we might not
    have to think about the evolution of the system—we now want to think about the
    company's financial goal. Unfortunately, immediate profit may obscure the development
    of software that could offer greater profits in the future.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们有一个令人震惊且创新的商业模式，我们必须迅速为客户提供应用程序，让他们享受这项业务。原则上，采用单体模型会使应用程序开发迅速，测试和部署也很快。在这个阶段，我们可能不需要考虑系统的演变——我们现在想考虑公司的财务目标。不幸的是，立即的利润可能会掩盖未来可能带来更大利润的软件发展。
- en: 'There are two conflicting issues:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个相互冲突的问题：
- en: Delivering the product quickly so you can reach customers, capitalize the company,
    and think about the evolutionary scale of the product later, running the risk
    of creating software with poor maintenance
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速交付产品，以便您能够接触客户、利用公司，并在以后考虑产品的演变规模，冒着创建维护不良软件的风险
- en: Once we have identified the criteria for using a microservices strategy, spending
    more time developing the application based on microservices
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们确定了使用微服务策略的标准，我们将在基于微服务的应用程序开发上花费更多时间
- en: 'At this point, both the architecture and project management teams should have
    some questions in mind:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，架构和项目管理团队都应该有一些问题在心中：
- en: Will the application evolve?
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序是否会演变？
- en: Does the team multitask?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队是否多任务处理？
- en: How will much development time initially be spent on a microservices product
    compared to a monolithic product?
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与单体产品相比，在微服务产品上最初将花费多少开发时间？
- en: How to decompose an application into microservices
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何将应用程序分解为微服务
- en: We have two possibilities for decomposing an application—Either there is a monolithic
    application and we want to decompose it into microservices, or the application
    does not exist and we want to use the microservices strategy to create it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种分解应用程序的方法——要么有一个单体应用程序，我们想要将其分解为微服务，要么应用程序不存在，我们想要使用微服务策略来创建它。
- en: In the case of existing monolithic applications, it is always possible to establish
    an intermediate stage, starting with a monolithic system to create a hybrid architecture,
    for example. At this intermediate stage, there may not be an immediate need or
    sufficient time to change the entire monolithic application and replace it with
    another one based on microservices architecture. For example, we have the critical
    issue of the single database.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有单体应用的情况下，总是有可能建立一个中间阶段，从单体系统开始创建混合架构，例如。在这个中间阶段，可能没有立即的需求或足够的时间来改变整个单体应用，并用基于微服务架构的另一个应用来替换它。例如，我们面临单数据库的关键问题。
- en: 'There is not really a definite model for decomposition, but we can perform
    some tasks that may help:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上并没有一个确定的分解模型，但我们可以执行一些可能有所帮助的任务：
- en: Identifying microservices
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别微服务
- en: Taking care of the process of extracting application modules that are candidates
    for microservices
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意提取适合微服务的应用模块的过程
- en: Establishing a hexagonal model for the application
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用建立六边形模型
- en: Identifying microservices
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别微服务
- en: Microservices can be very varied. There are technical microservices that are
    used throughout the application and that meet nonfunctional requirements, and there
    are microservices that are related to the application business application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以非常多样。有技术微服务，它们在整个应用中使用并满足非功能性需求，还有与业务应用相关的微服务。
- en: 'We can use two approaches in order to create business microservices—using business
    capabilities or use cases:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用两种方法来创建业务微服务——使用业务能力或用例：
- en: '**Business capabilities:** This indicates the ability to generate value for
    the business application. The decomposition is small and each service would have
    a larger scope. For example, in an application that manages a college, we can
    have the following business capabilities such as Professor Management Service,
    Student Management Service, Course Management Service, Student Financial Management Service, College
    Events Service.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务能力**：这表示为业务应用生成价值的能力。分解较小，每个服务都会有更大的范围。例如，在一个管理大学的系统中，我们可以有以下业务能力，如教授管理服务、学生管理服务、课程管理服务、学生财务管理服务、大学活动服务。'
- en: '**Use case:** We can perform a decomposition in services based on the use cases.
    In this case, the decomposition is large. For example, a college might have a
    Student Enrolment Service, Payment of Monthly Fee Service, Test Review Service,
    and a Student''s Academic Situation Service.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：我们可以根据用例对服务进行分解。在这种情况下，分解较大。例如，一所大学可能有学生注册服务、月费支付服务、考试评审服务以及学生的学术状况服务。'
- en: Taking care of the process of extracting application modules that are candidates
    for microservices
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注意提取适合微服务的应用模块的过程
- en: 'Here, we must extract the application components or modules with well-defined
    interfaces. These modules would be eligible to become microservices. Looking at
    these module interfaces, we have to try to find out which of the following two
    situations is the case:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须提取具有良好定义接口的应用组件或模块。这些模块有资格成为微服务。查看这些模块接口，我们必须试图找出以下两种情况中的哪一种：
- en: The modules are independent, meaning that the services are well-defined and
    have few responsibilities. Here, we must take care not to generate monolithic
    modules.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块是独立的，这意味着服务定义良好且责任较少。在这里，我们必须注意不要生成单体模块。
- en: The modules are reusable. Some clear examples of modules that can be reused
    would be modules with more technical tasks that are used throughout all of the
    application, such as a print service, an email service, a storage service, a document
    download service, and so on. Modules with a higher business content—such as a
    ticket payment service, a credit card payment service, and so on—can also be reused.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块是可重用的。一些可以重用的模块的明显例子是那些在应用中用于所有技术任务的模块，如打印服务、电子邮件服务、存储服务、文档下载服务等。具有更高业务内容的模块——如票务支付服务、信用卡支付服务等——也可以重用。
- en: 'Let''s look at the example shown in the following diagram:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图表所示的示例：
- en: '![](img/11e28fe2-ca88-48da-bbd3-4b5d7beedd46.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/11e28fe2-ca88-48da-bbd3-4b5d7beedd46.png)'
- en: When creating technical microservices, we must be careful not to carry a functionality
    of the business along with it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建技术微服务时，我们必须小心不要将其中的业务功能一起携带。
- en: Once this first approach is made, we still have a monolithic block that represents
    the core business. We can perform a decomposition of this block based on business
    capabilities or use case, and we can also discover new business modules with well-defined
    interfaces. We can then have modules such as a **Student Status Service**, **Professor
    Service**, **College Event Service**, and **Financial Student Service**. In addition,
    we can have microservices of the business with finer granularity, such as a **Ticket
    Payment Service**.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦采取这种第一种方法，我们仍然有一个代表核心业务的单体块。我们可以根据业务能力或用例对这个块进行分解，也可以发现具有明确定义接口的新业务模块。然后我们可以有如**学生状态服务**、**教授服务**、**学院活动服务**和**财务学生服务**等模块。此外，我们还可以有更细粒度的业务微服务，如**票务支付服务**。
- en: 'Let''s look at the following diagram:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的图：
- en: '![](img/66164aec-c17a-4d22-8a54-ae93eed2650a.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66164aec-c17a-4d22-8a54-ae93eed2650a.png)'
- en: Similarly, business-connected microservices must not carry the responsibilities
    of other microservice candidate modules. This means that we have to see the size
    of each microservice, and this is related to their own responsibilities. The microservice
    should have few responsibilities, characterizing a cohesive service (we always
    have to remember the SRP principle). One way to avoid dependent services is to
    remember the independent nature of microservices. If there are two microservices
    that need to be deployed together, or one does not exist without the other, then
    these services should most likely only be one service.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，业务相关的微服务不应承担其他微服务候选模块的责任。这意味着我们必须看到每个微服务的大小，这与它们自己的责任相关。微服务应该承担较少的责任，体现为一个内聚的服务（我们始终要记住单一职责原则）。避免依赖服务的一种方法是要记住微服务的独立性。如果有两个微服务需要一起部署，或者一个没有另一个就无法存在，那么这些服务很可能只有一个服务。
- en: Another way to obtain this decomposition is to design our application in the
    hexagonal model, which we will see in the following section.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 获取这种分解的另一种方法是设计我们的应用程序为六边形模型，我们将在下一节中看到。
- en: Establishing a hexagonal model for the application
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为应用程序建立六边形模型
- en: 'A typical application keeps its various functional modules together. Generally,
    this typical application has a hexagonal structure or architecture (we will see
    a better definition of the hexagonal architecture later) with the core business
    in the center of the structure. The core business contains all the management
    of the services offered by the application. There are also links with the various
    components external to this core, such as messaging services, database, client
    machines, and so on. These connections with the external world have specific adapters
    and protocols, such as a database adapter, REST API, Web API, Messaging API, WebSocket
    protocol, and so on, as shown in the following diagram:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 典型应用将它的各种功能模块保持在一起。通常，这种典型应用具有六边形结构或架构（我们将在后面看到六边形架构的更好定义），核心业务位于结构中心。核心业务包含应用提供的所有服务的管理。还有与核心外部各种组件的链接，如消息服务、数据库、客户端机器等。这些与外部世界的连接具有特定的适配器和协议，如数据库适配器、REST
    API、Web API、消息API、WebSocket协议等，如下面的图所示：
- en: '![](img/f7884783-f603-46d2-88aa-3d033c5599d1.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7884783-f603-46d2-88aa-3d033c5599d1.png)'
- en: The idea behind the hexagonal model is to isolate the application's core domain
    from access to technical infrastructures, such as the database, message queue,
    storage, and so on. As previously stated, once the core domain is isolated, we
    can analyze it more deeply and try to extract the services connected to the business.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形模型背后的思想是将应用程序的核心领域从对技术基础设施的访问中隔离出来，例如数据库、消息队列、存储等。正如之前所述，一旦核心领域被隔离，我们就可以更深入地分析它，并尝试提取与业务相关的服务。
- en: Advantages and drawbacks of a microservices-based application
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于微服务的应用的优缺点
- en: Like any other technology, there are advantages and disadvantages in using microservices-based
    architecture. Several problems may appear during the implementation of microservices,
    but the advantages can overcome the complexity encountered during development.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他技术一样，使用基于微服务的架构既有优点也有缺点。在微服务的实施过程中可能会出现一些问题，但优点可以克服开发过程中遇到的复杂性。
- en: 'The following are the advantages of the microservices architecture:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的优势如下：
- en: Small multitask team.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型多任务团队。
- en: Services can be written in different languages. This is a positive point because
    depending on the service, a specific language may provide more tools than another
    in obtaining the functionality served by the service.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务可以用不同的语言编写。这是一个优点，因为根据服务，一种特定的语言可能比另一种语言提供更多获取服务所提供功能性的工具。
- en: The deployment is faster and integration is performed more automatically. Changes
    of requirements mean only the deployment of the related microservice.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署更快，集成更自动化。需求变更意味着只需部署相关的微服务。
- en: The latest libraries, frameworks, and technologies can be quickly used.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最新的库、框架和技术可以快速使用。
- en: Greater fault tolerance.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高的容错性。
- en: The microservice is related to the product and not to the project. The developer
    has more freedom and thus can develop the service more quickly.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务与产品相关，而不是与项目相关。开发者有更多的自由，因此可以更快地开发服务。
- en: The knowledge of microservices is transmitted more quickly to the development
    team. Consequently, the necessary changes and maintenance of the code are made
    more quickly.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的知识可以更快地传递给开发团队。因此，必要的代码更改和维护可以更快地进行。
- en: 'The following are the drawbacks of the microservices architecture:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些微服务架构的缺点：
- en: The independence of microservices can bring complexity because the services
    can have different protocols for both communication and data.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的独立性可能带来复杂性，因为服务在通信和数据方面可能采用不同的协议。
- en: The increase of microservices makes the control and management of these services
    more complicated. For example, In order to maintain fault tolerance, there must
    be more programming effort.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的增加使得对这些服务的控制和管理工作更加复杂。例如，为了保持容错性，必须投入更多的编程工作。
- en: As well as the problem of services with different protocols, the communication
    between the services is also more complex because some application functionalities
    may involve calls to several microservices, worsening network traffic. The developer,
    in these cases, should use tools and strategies such as the API gateway.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了不同协议的服务问题外，由于某些应用功能可能涉及对多个微服务的调用，这加剧了网络流量，因此服务之间的通信也更加复杂。在这些情况下，开发者应使用API网关等工具和策略。
- en: Transaction control is a complicating factor, especially when migrating from
    monolithic systems to an architecture based on microservices—for example, in situations
    in which a particular functionality or use case needs several microservices.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务控制是一个复杂因素，尤其是在从单体系统迁移到基于微服务的架构时——例如，在特定功能或用例需要多个微服务的情况下。
- en: Each microservice runs in a single process, which means increasing memory consumption.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务都在单个进程中运行，这意味着增加内存消耗。
- en: Tests are more difficult to perform because the application is distributed across
    microservices.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于应用程序分布在微服务中，测试变得更加困难。
- en: Microservices architecture patterns
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构模式
- en: So far, we have seen that microservices architecture is based on the functional
    decomposition that produces independent, self-sufficient services that may have
    different ways of communicating with the outside world using well-defined interfaces.
    This favors low coupling and well-defined functions, allowing high cohesion (well-defined
    responsibilities with a reduced number of functions).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '到目前为止，我们已经看到微服务架构基于功能分解，产生了独立、自给自足的服务，这些服务可能以不同的方式使用定义良好的接口与外界通信。这有利于低耦合和定义良好的功能，允许高内聚（定义良好的责任和较少的功能）。 '
- en: Although the services act independently, the purpose of these services is to
    create an application—that is, a set of business-related functionalities.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管服务独立运作，但这些服务的目的是创建一个应用程序——即一组与业务相关的功能。
- en: 'Based on these characteristics, we can extract some patterns that can be used
    for the implementation of the microservices architecture. Here are some of these
    patterns:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些特性，我们可以提取一些可用于微服务架构实现的模式。以下是一些这些模式：
- en: Aggregator pattern
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合模式
- en: Proxy pattern
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理模式
- en: Chained pattern
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链模式
- en: Branch pattern
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支模式
- en: Asynchronous messaging pattern
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步消息模式
- en: Aggregator pattern
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合模式
- en: 'As the name itself suggests, this pattern establishes the existence or creation
    of a somewhat more complex service that invokes the functions of more internal
    services. Consequently, this aggregating microservice acts as an intermediary
    service that is a composition of other microservices, in the sense that it calls
    the microservices, obtains the individual responses from each microservice, and
    applies the necessary business rule, returning the final response to the client. Let''s
    look at the following diagram:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，此模式建立了存在或创建一个相对更复杂的服务，该服务调用更多内部服务的功能。因此，此聚合微服务充当一个中介服务，是其他微服务的组合，从意义上讲，它调用微服务，从每个微服务获取单个响应，并应用必要的业务规则，将最终响应返回给客户端。让我们看一下以下图示：
- en: '![](img/c7298a5f-3d9f-4276-bab5-0fd124ab5577.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7298a5f-3d9f-4276-bab5-0fd124ab5577.png)'
- en: This diagram appears to show that a few parts of the solutions are repeated,
    which characterizes the existence of a design pattern. We can make a comparison
    with a microservice that acts as a business facade, calling specific microservices
    to perform a more complex functionality on an application business level. On a
    larger scale, this same aggregator microservice may act as a microservice individual that
    is called by another aggregator microservice at a higher level. It is clear that
    having great knowledge of the application's business rules is vital.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此图似乎表明解决方案的某些部分被重复，这表明存在设计模式。我们可以将此与充当业务外观的微服务进行比较，该服务调用特定的微服务以在应用业务层面执行更复杂的功能。在更大规模上，此聚合器微服务可能作为被更高层级的聚合器微服务调用的微服务个体。显然，对应用业务规则有深入了解至关重要。
- en: Proxy pattern
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理模式
- en: This pattern is a variation of the aggregator pattern, but with one important
    difference. There is no data collection for all the internal microservices, meaning
    that there is no aggregation. The proxy pattern directs the call to a specific
    microservice and the analysis of the request is what determines which microservice
    should be called (a typical behavior of a proxy pattern).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式是聚合器模式的一种变体，但有一个重要区别。对于所有内部微服务没有数据收集，这意味着没有聚合。代理模式将调用指向特定的微服务，请求的分析决定了应该调用哪个微服务（这是代理模式典型的行为）。
- en: 'However, there may be some benefit in the implementation of this proxy. Immediately
    before the response is returned to the client, there may be a transformation of
    this response to the format expected by the requesting client. Remember that different
    clients (including web browsers, mobile devices, and so on) can make the request. Let''s
    look at the following diagram:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实现此代理的过程中可能有一些好处。在将响应返回给客户端之前，可能会有将此响应转换为请求客户端期望的格式的转换。记住，不同的客户端（包括网络浏览器、移动设备等）都可以发起请求。让我们看一下以下图示：
- en: '![](img/926052e2-307e-4fda-831a-a2400c6604f7.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/926052e2-307e-4fda-831a-a2400c6604f7.png)'
- en: We can now see why an API gateway is clearly based on aggregator and proxy patterns.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以明白为什么API网关明显基于聚合器和代理模式。
- en: Chained pattern
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接模式
- en: The purpose of the chained pattern is to present a more consistent and definitive
    final response to the client using a chain of services that communicate sequentially.
    In this way, **Service A** that acts as a first service in the chain communicate
    with **Service B**. **Service B** communicates with **Service C**, and so on.
    The calls are synchronous and the client remains locked until the final response
    returns from **Service A** to the client.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 连接模式的目的在于通过一系列按顺序通信的服务，向客户端提供一个更一致和明确的最终响应。这样，作为链中第一个服务的**服务A**与**服务B**通信。**服务B**与**服务C**通信，依此类推。调用是同步的，客户端在最终响应从**服务A**返回到客户端之前保持锁定状态。
- en: It is important to note here that the requests that arrive at the chain services
    may be different. In this way, the request sent from **Service A** to **Service
    B** may be very different from the request sent from **Service B** to **Service
    C**, and so on. In the same way, the response of the services may also be different.
    The response from **Service C** to **Service B** may be different from the response
    from **Service B** to **Service A**.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意的是，到达链式服务的请求可能不同。因此，从**服务A**发送到**服务B**的请求可能与从**服务B**发送到**服务C**的请求非常不同，依此类推。同样，服务的响应也可能不同。从**服务C**到**服务B**的响应可能与从**服务B**到**服务A**的响应不同。
- en: 'Let''s look at the following diagram:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下图示：
- en: '![](img/bbfeb09a-9a91-4be8-b976-bc725f6b5280.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图表](img/bbfeb09a-9a91-4be8-b976-bc725f6b5280.png)'
- en: A practical example of this implementation is the generation of data for the
    printing of bank slips. Let's suppose that a bank provides two soap web services.
    One for registering the bank bill data in the bank and the other for getting the
    bank bill data registered with the bank. Our application contains two defined
    microservices—**Service A**, which registers the bank bill data in the data bank
    (that is, it calls the first registration web service); and **Service B**, which
    gets the definitive bank bill data, such as the code bar (meaning that it calls
    the second query web service), and returns the data for the bank bill generation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现的实际例子是生成用于打印银行支票的数据。假设一家银行提供了两个SOAP网络服务。一个是用于在银行注册银行支票数据的，另一个是用于获取已注册在银行的银行支票数据。我们的应用程序包含两个定义好的微服务——**服务A**，它将银行支票数据注册到数据银行（即，它调用第一个注册网络服务）；以及**服务B**，它获取最终的银行支票数据，如条形码（意味着它调用第二个查询网络服务），并返回用于银行支票生成的数据。
- en: A client application informs the bank data of a user to **Service**** A**. **Service
    A** is responsible for registering with the banking institution and, with the
    return of this registration, **Service A** makes a request to **Service B**. **Service
    B** then gets the definitive data for the generation of the bank bill. **Service
    B** passes this data to **Service A**, and it can then apply some transformation
    to that data and return it to the client.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序通知**服务A**用户的银行数据。**服务A**负责与金融机构注册，并在注册返回后，**服务A**向**服务B**发出请求。**服务B**随后获取用于生成银行支票的最终数据。**服务B**将此数据传递给**服务A**，然后它可以对该数据进行一些转换，并将其返回给客户端。
- en: This same example can be implemented using the aggregator pattern. However,
    whenever a sequential order of steps is required to produce a final response,
    we can think of the chain pattern as a solution.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的例子可以使用聚合器模式实现。然而，每当需要按顺序执行步骤以生成最终响应时，我们可以将链模式视为解决方案。
- en: Branch pattern
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支模式
- en: 'The branch pattern works as an extension of the aggregator pattern and can
    call different service chains in parallel. In the branch pattern implementation
    example, a first service, called **Service A**, is called by the client and can
    act as an aggregator, calling service chains to compose the response. Alternatively,
    based on the request, a specific service chain is called, thereby acting as a
    proxy pattern. Let''s look at the following diagram:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 分支模式作为聚合器模式的扩展，可以并行调用不同的服务链。在分支模式实现示例中，一个称为**服务A**的初始服务被客户端调用，并可以作为聚合器，调用服务链来组合响应。或者，根据请求，调用特定的服务链，从而充当代理模式。让我们看看以下图表：
- en: '![](img/4891478c-fe9f-4e96-974b-d9e3cc9870bb.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图表](img/4891478c-fe9f-4e96-974b-d9e3cc9870bb.png)'
- en: In fact, the main difference between the chain pattern and the branch pattern
    is the calling of different microservice chains. However, if we make an abstraction,
    and consider each chain as an individual microservice, in essence, we will have
    an aggregator or a proxy pattern.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，链模式与分支模式之间的主要区别在于调用不同的微服务链。然而，如果我们进行抽象，并将每个链视为一个独立的微服务，本质上，我们将有一个聚合器或代理模式。
- en: Asynchronous pattern
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步模式
- en: 'When we think of microservices in practical terms, we immediately think of
    microservices implemented using the REST protocol. However, microservices based
    on a REST pattern are synchronous and therefore blocking. Sometimes, we need microservices
    that can be called asynchronously. The asynchronous mechanism is developed with
    techniques that are specific to each application (message queue, sending asynchronous
    events, and so on). Let''s look at the following diagram:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从实际的角度考虑微服务时，我们立刻会想到使用REST协议实现的微服务。然而，基于REST模式的微服务是同步的，因此是阻塞的。有时，我们需要可以异步调用的微服务。异步机制是通过针对每个应用程序特定的技术（消息队列、发送异步事件等）开发的。让我们看看以下图表：
- en: '![](img/ce831d37-99a1-4052-aa9a-d713ea877f37.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图表](img/ce831d37-99a1-4052-aa9a-d713ea877f37.png)'
- en: '**Service A** receives the request from the client and calls **Service B**
    in a synchronous manner. However, **Service B** depends on **Service C** and calls
    it asynchronously through a message queue, for example. **Service C** reads the
    message from the queue, does the required logical processing, and also returns
    a response to **Service B** using the queue mechanism. (We should always keep
    in mind the independence of the services that are being called.)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务A** 从客户端接收请求并以同步方式调用**服务B**。然而，**服务B**依赖于**服务C**，并通过消息队列异步调用它，例如。**服务C**从队列中读取消息，进行必要的逻辑处理，并使用队列机制向**服务B**返回响应。（我们应始终牢记被调用服务的独立性。）'
- en: A way of communicating between **Service B** and **Service C** could be that
    **Service B** sends a request message to a `QRequest` queue and listens for a
    response from a `QReply` queue. **Service C** then reads the request message from
    the `QRequest` queue, performs the necessary processing, and sends a response
    to the `QReply` queue. **Service B** reads the response message from the `QReply` queue,
    applies a transformation or adds some other information, and then sends the response
    to **Service A**. It is clear that the specific details of this implementation
    should be taken into account, such as waiting for **Service C** to time out.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务B** 和 **服务C** 之间的一种通信方式是**服务B**向`QRequest`队列发送请求消息，并监听来自`QReply`队列的响应。然后**服务C**从`QRequest`队列中读取请求消息，执行必要的处理，并将响应发送到`QReply`队列。**服务B**从`QReply`队列中读取响应消息，应用转换或添加其他信息，然后将响应发送给**服务A**。很明显，应该考虑具体实现的细节，例如等待**服务C**超时。'
- en: Implementing microservices
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现微服务
- en: The idea behind the implementation of microservices in our example is to implement
    a microservice that provides the bank data for a client to generate a payment
    slip. The data returned will be the barcode of the payment slip.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例中微服务实现的思路是实现一个微服务，为客户端提供银行数据以生成支付凭证。返回的数据将是支付凭证的条形码。
- en: 'The bank provides two SOAP web services, one to register the payment slip with
    the bank and one to provide the data for generating the payment slip that was
    already registered. As a result, we will make two microservices, one for registering
    the payment slip data and another for the query of the payment slip that was already
    registered. Each of these microservices will call the related web service. Next,
    we will construct a third, more complex microservice that will add two calls:
    a call to the registration microservice and another to retrieve what was registered.
    Let''s look at the following diagram:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 银行提供两个SOAP网络服务，一个用于将支付凭证注册到银行，另一个用于提供已注册的支付凭证生成数据。因此，我们将创建两个微服务，一个用于注册支付凭证数据，另一个用于查询已注册的支付凭证。 这些微服务中的每一个都将调用相关的网络服务。接下来，我们将构建一个更复杂的第三个微服务，它将添加两个调用：一个调用注册微服务，另一个调用检索已注册的内容。让我们看看以下图表：
- en: '![](img/260e087a-54a7-43c8-abe8-a4926fbc13e0.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/260e087a-54a7-43c8-abe8-a4926fbc13e0.png)'
- en: We could, in fact, make a microservice chain here; however, we opted for the
    aggregator pattern because we assume that multiple payment slips may have been
    previously batch-registered.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们在这里可以创建一个微服务链；然而，我们选择了聚合器模式，因为我们假设可能有多个支付凭证已经被批量注册。
- en: We will make three classes—one for each microservice. Each microservice will
    be implemented as a REST resource. To make the code simpler, we use only one request
    class and only one response class for the two microservices; the registering and
    querying microservices.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建三个类——每个微服务一个。每个微服务都将实现为一个REST资源。为了使代码更简单，我们为注册和查询微服务只使用一个请求类和一个响应类。 为了简化代码，我们只使用一个请求类和一个响应类来处理这两个微服务；注册和查询微服务。
- en: 'The payment slip registering class is as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 支付凭证注册类如下：
- en: '[PRE1]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the payment slip query class:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为支付凭证查询类：
- en: '[PRE2]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the aggregator class:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为聚合器类：
- en: '[PRE3]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Any client can then call this aggregator microservice in order to obtain the
    barcode and other information to generate the payment slip.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 任何客户端都可以调用这个聚合器微服务以获取条形码和其他信息，从而生成支付凭证。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In almost every section of this book, we have shown that, besides being solutions
    to recurrent problems, patterns aim at the reuse of and low coupling between application
    components. Following this principle, the decomposition of an application into
    small independent parts that perform intelligent and specific tasks allows this
    application to evolve in a natural and organized way. These small parts with specific
    tasks are called microservices, and the method of developing a system based on
    the decomposition of the application into these small parts is called microservices
    architecture.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的几乎每个部分，我们都表明，除了是常见问题的解决方案外，模式还旨在实现应用组件的重用和低耦合。遵循这一原则，将应用分解成执行智能和特定任务的小独立部分，使该应用能够以自然和有序的方式进化。这些执行特定任务的小部分被称为微服务，而基于将应用分解成这些小部分来开发系统的方法被称为微服务架构。
- en: However, like any technology, there are pros and cons to this. Developing an
    application and thinking about the control of the various microservices is a complex
    task, but once the microservices are well defined, the application is able to
    evolve much better than a monolithic application. In this way, the maintenance
    of the application is done more quickly, with the addition of new functionalities
    and the updating of the current functionalities.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，像任何技术一样，这种技术也有其优缺点。开发应用并考虑各种微服务的控制是一个复杂任务，但一旦微服务定义得很好，应用就能比单体应用更好地进化。这样，应用的维护就更快，新功能的添加和现有功能的更新也更快。
- en: The inclusion of new frameworks, APIs, and libraries is done much more quickly
    thanks to the decentralization of microservices. Teaching microservices to future
    development teams is also faster and easier, and deployment is also faster because
    there is no need to redeploy the entire application because of a change in one
    part of the application. We also looked at a mechanism called an API gateway.
    The API gateway establishes a type of frontend for the various clients of the
    application based on microservices, translating the clients' calls to the microservices.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务的去中心化，新框架、API和库的引入速度大大加快。教给未来的开发团队微服务也更快、更简单，部署也更快，因为不需要因为应用某一部分的改变而重新部署整个应用。我们还研究了名为API网关的机制。API网关根据微服务为应用的各种客户端建立了一种前端，将客户端的调用转换为对微服务的调用。
- en: Finally, in this chapter, we looked at some of the main design patterns that
    are used in the development of the microservices architecture, such as the aggregator
    pattern, the proxy pattern, and the chained pattern.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这一章中，我们探讨了在微服务架构开发中使用的某些主要设计模式，例如聚合器模式、代理模式和链式模式。
- en: The next chapter, [Chapter 8](91a5c7ea-6a16-4af1-b89a-0f918d4feb4e.xhtml), *Cloud-Native
    Application Patterns*, will address the cloud-native application pattern. Here,
    we'll look at a cloud application, as well as some of the key patterns that must
    be followed when developing an application in the cloud.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章，[第8章](91a5c7ea-6a16-4af1-b89a-0f918d4feb4e.xhtml)，*云原生应用模式*，将讨论云原生应用模式。在这里，我们将研究云应用，以及开发云应用时必须遵循的一些关键模式。
