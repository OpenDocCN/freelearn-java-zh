- en: '*Chapter 8*: Multithreading and Concurrent Processing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第八章*：多线程与并发处理'
- en: In this chapter, we will discuss ways to increase Java application performance
    by using workers (threads) that process data concurrently. We will explain the
    concept of Java threads and demonstrate their usage. We will also talk about the
    difference between parallel and concurrent processing and how to avoid unpredictable
    results caused by the concurrent modification of a shared resource.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论通过使用并发处理数据的工作者（线程）来提高Java应用程序性能的方法。我们将解释Java线程的概念并演示其用法。我们还将讨论并行处理与并发处理之间的区别以及如何避免由共享资源的并发修改引起的不可预测的结果。
- en: After finishing this chapter, you will be able to write code for multithreaded
    processing—creating and executing threads and using a pool of threads in parallel
    and concurrent cases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将能够编写多线程处理的代码——创建和执行线程，并在并行和并发情况下使用线程池。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Thread versus process
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程与进程
- en: User thread versus daemon
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户线程与守护线程
- en: Extending the `Thread` class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展`Thread`类
- en: Implementing the `Runnable` interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`Runnable`接口
- en: Extending `Thread` versus implementing `Runnable`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展`Thread`类与实现`Runnable`接口
- en: Using a pool of threads
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程池
- en: Getting results from a thread
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从线程获取结果
- en: Parallel versus concurrent processing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行处理与并发处理
- en: Concurrent modification of the same resource
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一资源的并发修改
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行本章提供的代码示例，您需要以下内容：
- en: A computer with a Microsoft Windows, Apple macOS, or Linux operating system
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台装有Microsoft Windows、Apple macOS或Linux操作系统的计算机
- en: Java **Standard Edition** (**SE**) version 17 or later
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java **标准版**（**SE**）17或更高版本
- en: An **integrated development environment** (**IDE**) or your preferred code editor
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**集成开发环境**（**IDE**）或您偏好的代码编辑器
- en: Instructions on how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Java 17*. Files with code examples for this chapter are available on GitHub in
    the [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    repository, in the `examples/src/main/java/com/packt/learnjava/ch08_threads` folder.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B18388_01_ePub.xhtml#_idTextAnchor015)“Java 17入门”中提供了如何设置Java SE和IntelliJ
    IDEA编辑器的说明。本章的代码示例文件可在GitHub的[https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)仓库中的`examples/src/main/java/com/packt/learnjava/ch08_threads`文件夹找到。
- en: Thread versus process
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程与进程
- en: Java has two units of execution—a process and a thread. A `java.lang.ProcessBuilder`.
    But since the multi-process case is outside the scope of this book, we will focus
    on the second unit of execution—that is, a **thread**, which is similar to a process
    but less isolated from other threads and requires fewer resources for execution.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Java有两个执行单元——进程和线程。一个`java.lang.ProcessBuilder`。但由于多进程案例超出了本书的范围，我们将关注第二个执行单元——即线程，它类似于进程，但与其他线程的隔离性较低，执行所需的资源也更少。
- en: 'A process can have many threads running and at least one thread called the
    **main thread**—the one that starts the application—which we use in every example.
    Threads can share resources, including memory and open files, which allows for
    better efficiency, but this comes at a price: a higher risk of unintended mutual
    interference, and even blocking of the execution. That is where programming skills
    and an understanding of concurrency techniques are required.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程可以运行多个线程，并且至少有一个称为**主线程**的线程——启动应用程序的那个线程——我们在每个示例中都使用它。线程可以共享资源，包括内存和打开的文件，这可以提高效率，但这也带来了代价：更高的意外互斥风险，甚至可能阻塞执行。这就是需要编程技能和对并发技术理解的地方。
- en: User thread versus daemon
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户线程与守护线程
- en: There is a particular kind of thread called a daemon.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊的线程称为守护线程。
- en: Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The word *daemon* has an ancient Greek origin, meaning a divinity or supernatural
    being of nature between gods and humans and an inner or attendant spirit or inspiring
    force.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 词语*守护线程*起源于古希腊，意为介于神与人之间的自然神祇或超自然存在，以及内在或伴随的精神或灵感之源。
- en: 'In computer science, the term *daemon* has more mundane usage and is applied
    to *a computer program that runs as a background process, rather than being under
    the direct control of an interactive user*. That is why there are the following
    two types of threads in Java:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，术语*守护*有更普通的用法，它被应用于*作为后台进程运行的计算机程序，而不是在交互式用户的直接控制之下*。这就是为什么Java中有以下两种类型的线程：
- en: User thread (default) initiated by an application (the main thread is one such
    example)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由应用程序启动的用户线程（默认）（主线程就是一个例子）
- en: Daemon thread that works in the background in support of user-thread activity
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在支持用户线程活动时在后台工作的守护线程
- en: That is why all daemon threads exit immediately after the last user thread exits
    or are terminated by the JVM after an unhandled exception.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，所有守护线程在最后一个用户线程退出后立即退出，或者在未处理的异常后由JVM终止。
- en: Extending the Thread class
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Thread类
- en: 'One way to create a thread is to extend the `java.lang.Thread` class and override
    its `run()` method. Here’s an example of this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建线程的一种方式是扩展`java.lang.Thread`类并重写其`run()`方法。以下是一个这样的示例：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If the `run()` method is not overridden, the thread does nothing. In our example,
    the thread prints its name and other properties every second, as long as the parameter
    is not equal to the `"exit"` string; otherwise, it exits.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有重写`run()`方法，线程将不执行任何操作。在我们的例子中，只要参数不等于`"exit"`字符串，线程就会每秒打印其名称和其他属性；否则，它将退出。
- en: 'The `pauseOneSecond()` method looks like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`pauseOneSecond()`方法看起来是这样的：'
- en: '[PRE22]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can now use the `MyThread` class to run two threads—one user thread and
    one daemon thread, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`MyThread`类运行两个线程——一个用户线程和一个守护线程，如下所示：
- en: '[PRE29]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, the main thread creates two other threads, pauses for one second,
    sets the `exit` parameter on the user thread, pauses another second, and finally
    exits (the `main()` method completes its execution).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，主线程创建了两个其他线程，暂停一秒，将用户线程的`exit`参数设置，再暂停一秒，最后退出（`main()`方法完成其执行）。
- en: 'If we run the preceding code, we’ll see something like this (the `id` thread
    may be different in different operating systems):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，我们会看到类似这样的结果（`id`线程在不同的操作系统上可能不同）：
- en: '![](img/B18388_Figure_8.1.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_8.1.jpg)'
- en: The preceding screenshot shows that the daemon thread exits automatically as
    soon as the last user thread (the main thread, in our example) exits.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示，守护线程在最后一个用户线程（在我们的例子中是主线程）退出后自动退出。
- en: Implementing the Runnable interface
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Runnable接口
- en: 'The second way to create a thread is to use a class that implements `java.lang.Runnable`.
    Here is an example of such a class that has almost exactly the same functionality
    as the `MyThread` class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 创建线程的第二种方式是使用实现`java.lang.Runnable`的类。以下是一个这样的类的示例，其功能几乎与`MyThread`类完全相同：
- en: '[PRE40]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The difference is that there is no `isDaemon()`, `getId()`, or any other out-of-the-box
    method. The `MyRunnable` class can be any class that implements the `Runnable`
    interface, so we cannot print whether the thread is a daemon or not. We have added
    the `name` property so that we can identify the thread.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于没有`isDaemon()`、`getId()`或任何其他现成方法。`MyRunnable`类可以是实现`Runnable`接口的任何类，因此我们无法打印线程是否是守护线程。我们添加了`name`属性，以便我们可以识别线程。
- en: 'We can use the `MyRunnable` class to create threads similar to how we have
    used the `MyThread` class, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`MyRunnable`类创建与使用`MyThread`类类似线程，如下所示：
- en: '[PRE58]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The following screenshot proves that the behavior of the `MyRunnable` class
    is similar to the behavior of the `MyThread` class:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图证明`MyRunnable`类的行为与`MyThread`类的行为相似：
- en: '![](img/B18388_Figure_8.2.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_8.2.jpg)'
- en: The daemon thread (named `Two`) exits after the last user thread exits—exactly
    how it happened with the `MyThread` class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 守护线程（命名为`Two`）在最后一个用户线程退出后退出——这与`MyThread`类发生的情况完全相同。
- en: Extending Thread versus implementing Runnable
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展线程与实现Runnable
- en: Implementation of `Runnable` has the advantage (and in some cases, the only
    possible option) of allowing the implementation to extend another class. It is
    particularly helpful when you would like to add thread-like behavior to an existing
    class. Implementing `Runnable` allows more flexibility in usage, but otherwise,
    there is no difference in functionality compared to the extending of the `Thread`
    class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `Runnable` 有优点（在某些情况下，是唯一可能的选择），即允许实现扩展另一个类。当你想要向现有类添加类似线程的行为时，这尤其有帮助。实现
    `Runnable` 可以在使用上提供更多灵活性，但与其他扩展 `Thread` 类的功能相比，在功能上没有差异。
- en: The `Thread` class has several constructors that allow setting the thread name
    and the group it belongs to. Grouping of threads helps to manage them in the case
    of many threads running in parallel. The `Thread` class has also several methods
    that provide information about the thread’s status and its properties and allows
    us to control its behavior.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread` 类有几个构造函数，允许设置线程名称和它所属的组。线程的分组有助于在多个线程并行运行时管理它们。`Thread` 类也有几个方法，可以提供有关线程状态及其属性的信息，并允许我们控制其行为。'
- en: As you have seen, the thread’s **identifier** (**ID**) is generated automatically.
    It cannot be changed but can be reused after the thread is terminated. Several
    threads, on the other hand, can be set with the same name.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，线程的 **标识符**（**ID**）是自动生成的。它不能更改，但在线程终止后可以重用。另一方面，可以设置几个线程具有相同的名称。
- en: The execution priority can also be set programmatically with a value between
    `Thread.MIN_PRIORITY` and `Thread.MAX_PRIORITY`. The smaller the value, the more
    time the thread is allowed to run, which means it has a higher priority. If not
    set, the priority value defaults to `Thread.NORM_PRIORITY`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 执行优先级也可以通过在 `Thread.MIN_PRIORITY` 和 `Thread.MAX_PRIORITY` 之间的值来程序化设置。值越小，线程被允许运行的时间越长，这意味着它具有更高的优先级。如果没有设置，优先级值默认为
    `Thread.NORM_PRIORITY`。
- en: 'The state of a thread can have one of the following values:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的状态可以有以下之一：
- en: '`NEW`: When a thread has not yet started'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NEW`: 当一个线程尚未启动'
- en: '`RUNNABLE`: When a thread is being executed'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUNNABLE`: 当一个线程正在执行'
- en: '`BLOCKED`: When a thread is blocked and is waiting for a monitor lock'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BLOCKED`: 当一个线程被阻塞并正在等待监视器锁'
- en: '`WAITING`: When a thread is waiting indefinitely for another thread to perform
    a particular action'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WAITING`: 当一个线程正在无限期地等待另一个线程执行特定动作'
- en: '`TIMED_WAITING`: When a thread is waiting for another thread to perform an
    action for up to a specified waiting time'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMED_WAITING`: 当一个线程正在等待另一个线程执行动作，最长等待指定的时间'
- en: '`TERMINATED`: When a thread has exited'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TERMINATED`: 当一个线程已退出'
- en: Threads—and any objects, for that matter—can also *talk to each other* using
    the `wait()`, `notify()`, and `notifyAll()` methods of the `java.lang.Object`
    base class, but this aspect of threads’ behavior is outside the scope of this
    book.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 线程——以及任何对象——也可以使用 `java.lang.Object` 基类中的 `wait()`、`notify()` 和 `notifyAll()`
    方法相互“交谈”，但线程行为的这一方面超出了本书的范围。
- en: Using a pool of threads
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程池
- en: Each thread requires resources—the **central processing unit** (**CPU**) and
    **memory**. This means the number of threads must be controlled, and one way to
    do that is to create a fixed number of them—a pool. Besides, creating an object
    incurs an overhead that may be significant for some applications.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都需要资源——**中央处理单元**（**CPU**）和**内存**。这意味着必须控制线程的数量，而创建固定数量的线程是一种方法。此外，创建对象会产生开销，这可能在某些应用程序中是显著的。
- en: In this section, we will look into the `Executor` interfaces and their implementations
    provided in the `java.util.concurrent` package. They encapsulate thread management
    and minimize the time an application developer spends on writing code related
    to threads’ life cycles.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 `Executor` 接口及其在 `java.util.concurrent` 包中提供的实现。它们封装了线程管理，并最小化了应用程序开发者编写与线程生命周期相关的代码所需的时间。
- en: 'There are three `Executor` interfaces defined in the `java.util.concurrent`
    package, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `java.util.concurrent` 包中定义了三个 `Executor` 接口，如下所示：
- en: 'The base `Executor` interface: This has only one `void execute(Runnable r)`
    method in it.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础 `Executor` 接口：它只包含一个 `void execute(Runnable r)` 方法。
- en: 'The `ExecutorService` interface: This extends `Executor` and adds four groups
    of methods that manage the life cycle of worker threads and of the executor itself,
    as follows:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutorService` 接口：它扩展了 `Executor` 并添加了四个管理工作线程和执行器本身生命周期的方法组，如下所示：'
- en: '`submit()` methods, which place a `Runnable` or `Callable` object in the queue
    for the execution (`Callable` allows the worker thread to return a value) and
    return an object of the `Future` interface, which can be used to access the value
    returned by the `Callable` object and to manage the status of the worker thread'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`submit()` 方法，它将 `Runnable` 或 `Callable` 对象放入执行队列中，并返回 `Future` 接口的对象，可以用来访问
    `Callable` 对象返回的值以及管理工作线程的状态'
- en: '`invokeAll()` methods, which place a collection of objects of the `Callable` interface in
    a queue for execution, which then returns a `List` interface of `Future` objects
    when all worker threads are complete (there is also an overloaded `invokeAll()` method
    with a timeout)'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokeAll()` 方法，它将 `Callable` 接口的对象集合放入执行队列中，当所有工作线程完成时（也存在一个带有超时的重载 `invokeAll()`
    方法）'
- en: '`invokeAny()` methods, which place a collection of interface `Callable` objects in
    the queue for the execution and return one `Future` object of any of the worker
    threads, which has completed (there is also an overloaded `invokeAny()` method
    with a timeout)'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokeAny()` 方法，它将 `Callable` 接口的对象集合放入执行队列中，并返回任何完成工作线程的 `Future` 对象（也存在一个带有超时的重载
    `invokeAny()` 方法）'
- en: 'Methods that manage worker threads’ status and the service itself, as follows:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理工作线程状态和服务的以下方法：
- en: '`shutdown()`: Prevents new worker threads from being submitted to the service.'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown()`：防止将新的工作线程提交到服务中。'
- en: '`shutdownNow()`: Interrupts each worker thread that is not completed. A worker
    thread should be written so that it checks its own status periodically (using `Thread.currentThread().isInterrupted()`,
    for example) and gracefully shuts down on its own; otherwise, it will continue
    running even after `shutdownNow()` was called.'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdownNow()`：中断所有未完成的工作线程。工作线程应该被编写成定期检查自己的状态（例如使用 `Thread.currentThread().isInterrupted()`），并在其自身优雅地关闭；否则，即使在调用
    `shutdownNow()` 之后，它也会继续运行。'
- en: '`isShutdown()`: Checks whether the shutdown of the executor was initiated.'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isShutdown()`：检查执行器的关闭是否已启动。'
- en: '`awaitTermination(long timeout, TimeUnit timeUnit)`: Waits until all worker
    threads have completed execution after a shutdown request, or a timeout occurs,
    or the current thread is interrupted, whichever happens first.'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awaitTermination(long timeout, TimeUnit timeUnit)`：在关闭请求后等待所有工作线程完成执行，或者发生超时，或者当前线程被中断，以先发生者为准。'
- en: '`isTerminated()`: Checks whether all the worker threads have completed after
    the shutdown was initiated. It never returns `true` unless either `shutdown()` or `shutdownNow()` was
    called first.'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isTerminated()`：检查在启动关闭后所有工作线程是否已完成。除非首先调用 `shutdown()` 或 `shutdownNow()`，否则它永远不会返回
    `true`。'
- en: 'The `ScheduledExecutorService` interface: This extends `ExecutorService` and
    adds methods that allow scheduling of the execution (one-time and periodic) of
    worker threads'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScheduledExecutorService` 接口：它扩展了 `ExecutorService` 并添加了允许调度工作线程执行（一次性或周期性）的方法'
- en: 'A pool-based implementation of `ExecutorService` can be created using the `java.util.concurrent.ThreadPoolExecutor`
    or `java.util.concurrent.ScheduledThreadPoolExecutor` class. There is also a `java.util.concurrent.Executors`
    factory class that covers most practical cases. So, before writing custom code
    for worker threads’ pool creation, we highly recommend looking into using the
    following factory methods of the `java.util.concurrent.Executors` class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `java.util.concurrent.ThreadPoolExecutor` 或 `java.util.concurrent.ScheduledThreadPoolExecutor`
    类创建基于池的 `ExecutorService` 实现。还有一个 `java.util.concurrent.Executors` 工厂类，它涵盖了大多数实际案例。因此，在为工作线程池创建编写自定义代码之前，我们强烈建议查看
    `java.util.concurrent.Executors` 类的以下工厂方法：
- en: '`newCachedThreadPool()`: Creates a thread pool that adds a new thread as needed,
    unless there is an idle thread created before; threads that have been idle for
    60 seconds are removed from the pool'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newCachedThreadPool()`：创建一个线程池，根据需要添加新线程，除非在之前创建了一个空闲线程；空闲了 60 秒的线程将从池中移除'
- en: '`newSingleThreadExecutor()`: Creates an `ExecutorService` (pool) instance that
    executes worker threads sequentially'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newSingleThreadExecutor()`：创建一个执行工作线程的 `ExecutorService`（池）实例，这些工作线程是顺序执行的'
- en: '`newSingleThreadScheduledExecutor()`: Creates a single-threaded executor that
    can be scheduled to run after a given delay, or to execute periodically'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newSingleThreadScheduledExecutor()`：创建一个单线程执行器，可以调度在给定延迟后运行，或周期性地执行'
- en: '`newFixedThreadPool(int nThreads)`: Creates a thread pool that reuses a fixed
    number of worker threads; if a new task is submitted when all the worker threads
    are still executing, it will be placed into the queue until a worker thread is
    available'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newFixedThreadPool(int nThreads)`: 创建一个重用固定数量工作线程的线程池；如果当所有工作线程仍在执行时提交新任务，它将被放置在队列中，直到有工作线程可用'
- en: '`newScheduledThreadPool(int nThreads)`: Creates a thread pool of a fixed size
    that can be scheduled to run after a given delay, or to execute periodically'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newScheduledThreadPool(int nThreads)`: 创建一个固定大小的线程池，可以安排在给定延迟后运行，或者定期执行'
- en: '`newWorkStealingThreadPool(int nThreads)`: Creates a thread pool that uses
    the *work-stealing* algorithm used by `ForkJoinPool`, which is particularly useful
    in case the worker threads generate other threads, such as in a recursive algorithm;
    it also adapts to the specified number of CPUs, which you may set higher or lower
    than the actual CPU count on your computer'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newWorkStealingThreadPool(int nThreads)`: 创建一个使用`ForkJoinPool`中使用的*工作窃取*算法的线程池，这在工作线程生成其他线程的情况下特别有用，例如在递归算法中；它还可以适应指定的CPU数量，你可以将其设置为高于或低于你计算机上的实际CPU数量'
- en: Work-Stealing Algorithm
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 工作窃取算法
- en: A work-stealing algorithm allows threads that have finished their assigned tasks
    to help other tasks that are still busy with their assignments. As an example,
    see the description of fork/join implementation in the official Oracle Java documentation ([https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html](https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html)).
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 工作窃取算法允许完成分配任务的线程帮助其他仍在执行任务的作业。例如，请参阅官方Oracle Java文档中关于fork/join实现的描述（[https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html](https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html)）。
- en: 'Each of these methods has an overloaded version that allows passing in `ThreadFactory`
    that is used to create a new thread when needed. Let’s see how it all works in
    a code sample. First, we run another version of the `MyRunnable` class, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法都有重载版本，允许传递`ThreadFactory`，当需要时用于创建新线程。让我们通过一个代码示例看看它是如何工作的。首先，我们运行`MyRunnable`类的另一个版本，如下所示：
- en: '[PRE71]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: We cannot use the `parameter` property anymore to tell the thread to stop executing
    because the thread life cycle is now going to be controlled by the `ExecutorService`
    interface, and the way it does it is by calling the `interrupt()` thread method.
    Also, notice that the thread we created has an infinite loop, so it will never
    stop executing until forced to (by calling the `interrupt()` method).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能再使用`parameter`属性来告诉线程停止执行，因为线程的生命周期现在将由`ExecutorService`接口控制，它通过调用`interrupt()`线程方法来实现。此外，请注意，我们创建的线程有一个无限循环，所以它将永远不会停止执行，除非被强制停止（通过调用`interrupt()`方法）。
- en: 'Let’s write code that does the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写执行以下操作的代码：
- en: Creates a pool of three threads
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含三个线程的池
- en: Makes sure the pool does not accept more threads
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保池不接受更多线程
- en: Waits for a fixed time to let all threads finish what they’re doing
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待固定时间，让所有线程完成它们正在做的事情
- en: Stops (interrupts) threads that did not finish what they were doing
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止（中断）未完成任务的线程
- en: Exits
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出
- en: 'The following code performs all the actions described in the preceding list:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码执行了前面列表中描述的所有操作：
- en: '[PRE91]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The attempt to add another thread to the pool after `pool.shutdown()` is called
    generates `java.util.concurrent.RejectedExecutionException`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`pool.shutdown()`之后尝试向池中添加另一个线程会生成`java.util.concurrent.RejectedExecutionException`异常。
- en: 'The execution of the preceding code produces the following results:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的执行产生以下结果：
- en: '![](img/B18388_Figure_8.3.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_8.3.jpg)'
- en: Notice the `Thread.currentThread().isInterrupted()=false` message in the preceding
    screenshot. The thread was interrupted. We know this because the thread got an
    `InterruptedException` message. Why, then, does the `isInterrupted()` method return
    `false`? This happens because the thread state was cleared immediately after receiving
    the interrupt message. We’re mentioning it now because it is a source of some
    programmer mistakes. For example, if the main thread watches the `MyRunnable`
    thread and calls `isInterrupted()` on it, the return value is going to be `false`,
    which may be misleading after the thread was interrupted.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前一个屏幕截图中的`Thread.currentThread().isInterrupted()=false`信息。线程被中断了。我们知道这一点是因为线程收到了`InterruptedException`消息。那么，为什么`isInterrupted()`方法返回`false`呢？这是因为线程状态在收到中断消息后立即被清除。我们现在提到这一点，因为它是一些程序员错误的来源。例如，如果主线程监视`MyRunnable`线程并在其上调用`isInterrupted()`，返回值将是`false`，这在线程被中断后可能会产生误导。
- en: 'So, in the case where another thread may be monitoring the `MyRunnable` thread,
    the implementation of `MyRunnable` has to be changed to this. Note in the following
    code snippet how the `interrupt()` method is called in the `catch` block:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在另一个线程可能正在监控`MyRunnable`线程的情况下，`MyRunnable`的实现必须更改为如下。注意以下代码片段中在`catch`块中如何调用`interrupt()`方法：
- en: '[PRE131]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Now, if we run this thread using the same `ExecutorService` pool again, this
    will be the result:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次使用相同的`ExecutorService`线程池运行此线程，这将得到以下结果：
- en: '![](img/B18388_Figure_8.4.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4](img/B18388_Figure_8.4.jpg)'
- en: As you can see, the value returned by the `isInterrupted()` method is now `true`
    and corresponds to what has happened. To be fair, in many applications, once a
    thread is interrupted, its status is not checked again. But setting the correct
    state is a good practice, especially in those cases where you are not the author
    of the higher-level code that creates a particular thread.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`isInterrupted()`方法返回的值现在是`true`，这与所发生的情况相对应。公平地说，在许多应用中，一旦线程被中断，其状态就不会再次检查。但设置正确的状态是一种良好的实践，尤其是在那些你并非创建特定线程的更高级代码的作者的案例中。
- en: In our example, we have used a cached thread pool that creates a new thread
    as needed or, if available, reuses the thread already used, but which completed
    its job and returned to the pool for a new assignment. We did not worry about
    too many threads created because our demonstration application had three worker
    threads at the most and they were quite short-lived.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用了一个缓存线程池，该线程池根据需要创建新线程，或者如果可用，则重用已经使用的线程，但这些线程已经完成了任务并返回到线程池以进行新的分配。我们不必担心创建过多的线程，因为我们的演示应用最多只有三个工作线程，而且它们的生命周期相当短。
- en: But in the case where an application does not have a fixed limit of worker threads
    it might need or there is no good way to predict how much memory a thread may
    take or how long it can execute, setting a ceiling on the worker thread count
    prevents an unexpected degradation of the application performance, running out
    of memory, or depletion of any other resources the worker threads use. If the
    thread behavior is extremely unpredictable, a single thread pool might be the
    only solution, with the option of using a custom thread-pool executor. But in
    the majority of cases, a fixed-size thread-pool executor is a good practical compromise
    between the application needs and the code complexity (earlier in this section,
    we listed all possible pool types created by the `Executors` factory class).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 但在应用没有固定的工作线程数量限制，或者没有好的方法来预测线程可能占用多少内存或可以执行多长时间的情况下，对工作线程数量设置上限可以防止应用性能意外下降、内存耗尽或任何其他工作线程使用的资源耗尽。如果线程行为极其不可预测，单个线程池可能是唯一的解决方案，可以选择使用自定义线程池执行器。但在大多数情况下，固定大小的线程池执行器是在应用需求和代码复杂性之间的一种良好的实用折衷方案（在本节前面，我们列出了由`Executors`工厂类创建的所有可能的池类型）。
- en: Setting the size of the pool too low may deprive the application of the chance
    to utilize the available resources effectively. So, before selecting the pool
    size, it is advisable to spend some time monitoring the application, with the
    goal of identifying the idiosyncrasy of the application behavior. In fact, the
    *deploy-monitor-adjust* cycle has to be repeated throughout the application’s
    life cycle in order to accommodate and take advantage of changes that happened
    in the code or the executing environment.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 将池的大小设置得太低可能会剥夺应用程序有效利用可用资源的机会。因此，在选择池大小之前，建议花些时间监控应用程序，目标是识别应用程序行为的特殊性。实际上，*部署-监控-调整*周期必须在整个应用程序的生命周期中重复进行，以便适应并利用代码或执行环境中发生的变化。
- en: 'The first characteristic you take into account is the number of CPUs in your
    system, so the thread pool size can be at least as big as the CPU count. Then,
    you can monitor the application and see how much time each thread engages the
    CPU for and how much time it uses other resources (such as **input/output** (**I/O**)
    operations). If the time spent not using the CPU is comparable with the total
    executing time of the thread, then you can increase the pool size by the following
    ratio: the time the CPU was not used divided by the total executing time, but
    that is in the case where another resource (disk or database) is not a subject
    of contention between threads. If the latter is the case, then you can use that
    resource instead of the CPU as the delineating factor.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先考虑的第一个特征是您系统中的CPU数量，因此线程池的大小至少应该与CPU数量一样大。然后，您可以监控应用程序，看看每个线程占用CPU的时间有多长，以及它使用其他资源（如**输入/输出**（**I/O**）操作）的时间有多长。如果未使用CPU的时间与线程的总执行时间相当，那么您可以按以下比例增加池大小：未使用CPU的时间除以总执行时间，但这是在另一个资源（磁盘或数据库）不是线程之间争用对象的情况下。如果后者是情况，那么您可以使用该资源而不是CPU作为划分因素。
- en: Assuming the worker threads of your application are not too big or take too
    long executing, and belong to the mainstream population of the typical working
    threads that complete their job in a reasonably short period of time, you can
    increase the pool size by adding the (rounded-up) ratio of the desired response
    time and the time a thread uses the CPU or another most contentious resource.
    This means that, with the same desired response time, the less a thread uses the
    CPU or another concurrently accessed resource, the bigger the pool size should
    be. If the contentious resource has its own ability to improve concurrent access
    (such as a connection pool in a database), consider utilizing that feature first.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的应用程序的工作线程不太大或执行时间不太长，并且属于典型工作线程的主流群体，这些工作线程在合理短的时间内完成工作，您可以通过添加（向上取整）所需响应时间与线程使用CPU或另一个最争用资源的时间的比例来增加池大小。这意味着，在相同的所需响应时间下，线程使用CPU或另一个并发访问的资源越少，池大小就应该越大。如果争用资源具有提高并发访问能力的能力（例如数据库中的连接池），请首先考虑利用该功能。
- en: If the required number of threads running at the same time changes at runtime
    in different circumstances, you can make the pool size dynamic and create a new
    pool with a new size (shutting down the old pool after all its threads have completed).
    The recalculation of the size of a new pool might also be necessary after you
    add or remove the available resources. You can use `Runtime.getRuntime().availableProcessors()`
    to programmatically adjust the pool size based on the current count of the available
    CPUs, for example.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行时不同情况下同时运行的线程数量发生变化，您可以使池大小动态，并创建一个新的池，具有新的大小（在所有线程完成后关闭旧池）。在添加或删除可用资源后，重新计算新池的大小也可能是必要的。您可以使用`Runtime.getRuntime().availableProcessors()`根据当前可用的CPU数量编程调整池大小，例如。
- en: If none of the ready-to-use thread pool executor implementations that come with
    the `java.util.concurrent.ThreadPoolExecutor` class first. It has several overloaded
    constructors.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`java.util.concurrent.ThreadPoolExecutor`类提供的任何现成的线程池执行器实现都不适用。它有几个重载的构造函数。
- en: 'To give you an idea of its capabilities, here is the constructor with the biggest
    number of options:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解其功能，这里有一个具有最多选项的构造函数：
- en: '[PRE151]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'These are the parameters of the preceding constructor:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是前一个构造函数的参数：
- en: '`corePoolSize` is the number of threads to keep in the pool, even if they are
    idle, unless the `allowCoreThreadTimeOut(boolean value)` method is called with
    a `true` value.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`corePoolSize`是池中要保留的线程数，即使它们是空闲的，除非调用`allowCoreThreadTimeOut(boolean value)`方法并传入`true`值。'
- en: '`maximumPoolSize` is the maximum number of threads to allow in the pool.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maximumPoolSize`是允许在池中的最大线程数。'
- en: '`keepAliveTime`: When the number of threads is greater than the core, this
    is the maximum time that excess idle threads will wait for new tasks before terminating.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keepAliveTime`：当线程数量大于核心线程数时，这是超出空闲线程等待新任务的最大时间，然后终止。'
- en: '`unit` is the time unit for the `keepAliveTime` argument.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unit`是`keepAliveTime`参数的时间单位。'
- en: '`workQueue` is the queue to use for holding tasks before they are executed;
    this queue will hold only `Runnable` objects submitted by the `execute()` method.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workQueue`是用于在执行之前持有任务的队列；这个队列将只持有通过`execute()`方法提交的`Runnable`对象。'
- en: '`threadFactory` is the factory to use when the executor creates a new thread.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threadFactory`是当执行器创建新线程时使用的工厂。'
- en: '`handler` is the handler to use when the execution is blocked because the thread
    bounds and queue capacities are reached.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handler`是在线程因为达到线程界限和队列容量而阻塞时使用的处理器。'
- en: Each of the previous constructor parameters except `workQueue` can also be set
    via the corresponding setter after an object of the `ThreadPoolExecutor` class
    has been created, thus allowing more flexibility and dynamic adjustment of existing
    pool characteristics.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`workQueue`之外，之前的所有构造参数也可以在创建`ThreadPoolExecutor`类的对象之后通过相应的setter设置，从而允许更灵活和动态调整现有池的特性。
- en: Getting results from a thread
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从线程获取结果
- en: In our examples so far, we have used the `execute()` method of the `ExecutorService`
    interface to start a thread. In fact, this method comes from the `Executor` base
    interface. Meanwhile, the `ExecutorService` interface has other methods (listed
    in the previous *Using a pool of threads* section) that can start threads and
    get back the results of thread execution.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们使用了`ExecutorService`接口的`execute()`方法来启动一个线程。实际上，这个方法来自`Executor`基接口。同时，`ExecutorService`接口还有其他方法（在之前的*使用线程池*部分列出），可以启动线程并获取线程执行的返回结果。
- en: 'The object that brings back the result of thread execution is of type `Future`—an
    interface that has the following methods:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 返回线程执行结果的对象是`Future`类型——一个具有以下方法的接口：
- en: '`V get()`: Blocks until the thread finishes; returns the result (*if available*)'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V get()`：阻塞直到线程完成；返回结果（如果可用）'
- en: '`V get(long timeout, TimeUnit unit)`: Blocks until the thread finishes or the
    provided timeout is up; returns the result (if available)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V get(long timeout, TimeUnit unit)`：阻塞直到线程完成或提供的超时时间到达；返回结果（如果可用）'
- en: '`boolean isDone()`: Returns `true` if the thread has finished'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isDone()`：如果线程已完成，则返回`true`'
- en: '`boolean cancel(boolean mayInterruptIfRunning)`: Tries to cancel the execution
    of the thread; returns `true` if successful; returns `false` also in the case
    the thread had finished normally by the time the method was called'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean cancel(boolean mayInterruptIfRunning)`：尝试取消线程的执行；如果成功，则返回`true`；如果线程在调用该方法时已经正常完成，则也返回`false`'
- en: '`boolean isCancelled()`: Returns `true` if the thread execution was canceled
    before it had finished normally'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isCancelled()`：如果线程在正常完成之前被取消，则返回`true`'
- en: 'The *if available* remark in the description of the `get()` method means that
    the result is not always available in principle, even when the `get()` method
    without parameters is called. It all depends on the method used to produce the
    `Future` object. Here is a list of all methods of `ExecutorService` that return
    a `Future` object(s):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`方法的描述中的*可用*说明意味着结果原则上并不总是可用，即使调用不带参数的`get()`方法也是如此。这完全取决于产生`Future`对象的方法。以下是返回`Future`对象（s）的所有`ExecutorService`方法的列表：'
- en: '`Future<?> submit(Runnable task)`: Submits the thread (task) for execution;
    returns a `Future` object representing the task; the `get()` method of the returned
    `Future` object returns `null`. For example, let’s use the `MyRunnable` class
    that works only for 100 milliseconds, as follows:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Future<?> submit(Runnable task)`：提交线程（任务）以供执行；返回一个表示任务的`Future`对象；返回的`Future`对象的`get()`方法返回`null`。例如，让我们使用只工作100毫秒的`MyRunnable`类，如下所示：'
- en: '[PRE158]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'And based on the code examples of the previous section, let’s create a method
    that shuts down the pool and terminates all the threads, if necessary, as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 基于上一节的代码示例，让我们创建一个方法来关闭线程池并终止所有线程，如果需要的话，如下所示：
- en: '[PRE159]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'We will use the preceding `shutdownAndTerminate()` method in a `finally` block
    to make sure no running threads were left behind. Here is the code we are going
    to execute:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `finally` 块中使用前面的 `shutdownAndTerminate()` 方法来确保没有留下正在运行的线程。以下是我们要执行的代码：
- en: '[PRE160]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'You can see the output of this code in the following screenshot:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下屏幕截图中看到此代码的输出：
- en: '![](img/B18388_Figure_8.5.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_8.5.jpg)'
- en: As expected, the `get()` method of the `Future` object returns `null` because
    the `run()` method of `Runnable` does not return anything. All we can get back
    from the returned `Future` object is the information that the task was completed,
    or not.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`Future` 对象的 `get()` 方法返回 `null`，因为 `Runnable` 的 `run()` 方法不返回任何内容。我们可以从返回的
    `Future` 对象中获取的唯一信息是任务是否完成。
- en: '`Future<T> submit(Runnable task, T result)`: Submits the thread (task) for
    execution; returns a `Future` object representing the task with the provided `result`
    in it; for example, we will use the following class as the result:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Future<T> submit(Runnable task, T result)`: 提交线程（任务）以执行；返回一个包含提供 `result`
    的 `Future` 对象表示的任务；例如，我们将使用以下类作为结果：'
- en: '[PRE161]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'The following code snippet demonstrates how the default result is returned
    by the `Future` object returned by the `submit()` method:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了 `submit()` 方法返回的 `Future` 对象如何返回默认结果：
- en: '[PRE162]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'If we execute the preceding code, the output is going to look like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行前面的代码，输出将如下所示：
- en: '![](img/B18388_Figure_8.6.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_8.6.jpg)'
- en: As expected, the `get()` method of `Future` returns the object passed in as
    a parameter.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`Future` 对象的 `get()` 方法返回作为参数传递的对象。
- en: '`Future<T> submit(Callable<T> task)`: Submits the thread (task) for execution;
    returns a `Future` object representing the task with the result produced and returned
    by the `V call()` method of the `Callable` interface, which is the only `Callable`
    method the interface has. Here’s an example of this:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Future<T> submit(Callable<T> task)`: 提交线程（任务）以执行；返回一个表示任务的 `Future` 对象，该任务由
    `Callable` 接口的 `V call()` 方法产生的结果和返回值，这是接口唯一的 `Callable` 方法。以下是一个示例：'
- en: '[PRE163]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The result of the preceding code looks like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果如下所示：
- en: '![](img/B18388_Figure_8.7.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_8.7.jpg)'
- en: 'As you can see, the `get()` method of the `Future` object returns the value
    produced by the `call()` method of the `MyCallable` class:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Future` 对象的 `get()` 方法返回 `MyCallable` 类的 `call()` 方法产生的值：
- en: '`List<Future<T>> invokeAll(Collection<Callable<T>> tasks)`: Executes all `Callable`
    tasks of the provided collection; returns a list of `Future` objects with the
    results produced by the executed `Callable` objects'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<Future<T>> invokeAll(Collection<Callable<T>> tasks)`: 执行提供的集合中的所有 `Callable`
    任务；返回一个包含由执行 `Callable` 对象产生的结果的 `Future` 对象列表'
- en: '`List<Future<T>> invokeAll(Collection<Callable<T>>`: Executes all `Callable`
    tasks of the provided collection; returns a list of `Future` objects with the
    results produced by the executed `Callable` objects or the timeout expires, whichever
    happens first'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<Future<T>> invokeAll(Collection<Callable<T>>`: 执行提供的集合中的所有 `Callable`
    任务；返回一个包含由执行 `Callable` 对象产生的结果的 `Future` 对象列表，或者在超时到期之前发生，以先到者为准。'
- en: '`T invokeAny(Collection<Callable<T>> tasks)`: Executes all `Callable` tasks
    of the provided collection; returns the result of one that has completed successfully
    (meaning, without throwing an exception), if any do'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T invokeAny(Collection<Callable<T>> tasks)`: 执行提供的集合中的所有 `Callable` 任务；如果有的话，返回成功完成（意味着，没有抛出异常）的任务的结果'
- en: '`T invokeAny(Collection<Callable<T>> tasks, long timeout, TimeUnit unit)`:
    Executes all `Callable` tasks of the provided collection; returns the result of
    one that has completed successfully (meaning, without throwing an exception),
    if such is available before the provided timeout expires'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T invokeAny(Collection<Callable<T>> tasks, long timeout, TimeUnit unit)`:
    执行提供的集合中的所有 `Callable` 任务；如果有的话，在提供的超时时间到期之前返回成功完成（意味着，没有抛出异常）的任务的结果'
- en: As you can see, there are many ways to get results from a thread. The method
    you choose depends on the particular needs of your application.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，从线程中获取结果有许多方法。您选择的方法取决于您应用程序的具体需求。
- en: Parallel versus concurrent processing
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行与并发处理
- en: When we hear about working threads executing at the same time, we automatically
    assume that they literally do what they are programmed to do in parallel. Only
    after we look under the hood of such a system do we realize that such parallel
    processing is possible only when the threads are each executed by a different
    CPU; otherwise, they time-share the same processing power. We perceive them working
    at the same time only because the time slots they use are very short—a fraction
    of the time units we use in our everyday life. When threads share the same resource,
    in computer science, we say they do it *concurrently*.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们听说工作线程同时执行时，我们自然会假设它们确实并行地执行了它们被编程要做的事情。只有当我们深入查看这样一个系统的内部时，我们才会意识到这种并行处理只有在每个线程由不同的CPU执行时才可能；否则，它们将共享相同的处理能力。我们之所以认为它们同时工作，只是因为它们使用的时间段非常短——是我们日常生活中所用时间单位的一小部分。在计算机科学中，当线程共享同一资源时，我们说它们是**并发**地做的。
- en: Concurrent modification of the same resource
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同一资源的并发修改
- en: Two or more threads modifying the same value while other threads read it is
    the most general description of one of the problems of concurrent access. Subtler
    problems include **thread interference** and **memory consistency** errors, both
    of which produce unexpected results in seemingly benign fragments of code. In
    this section, we are going to demonstrate such cases and ways to avoid them.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 两个或更多线程修改同一值，而其他线程读取它，这是并发访问问题之一的最一般描述。更微妙的问题包括**线程干扰**和**内存一致性**错误，这两种错误都会在看似良性的代码片段中产生意外结果。在本节中，我们将展示这些案例以及避免它们的方法。
- en: 'At first glance, the solution seems quite straightforward: allow only one thread
    at a time to modify/access the resource, and that’s it. But if access takes a
    long time, it creates a bottleneck that might eliminate the advantage of having
    many threads working in parallel. Or, if one thread blocks access to one resource
    while waiting for access to another resource and the second thread blocks access
    to a second resource while waiting for access to the first one, it creates a problem
    called a **deadlock**. These are two very simple examples of possible challenges
    a programmer may encounter while using multiple threads.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，解决方案似乎非常直接：只允许一次只有一个线程修改/访问资源，就是这样。但如果访问时间过长，它可能会产生瓶颈，从而消除多线程并行工作的优势。或者，如果一个线程在等待访问另一个资源时阻塞了对一个资源的访问，而第二个线程在等待访问第一个资源时阻塞了对第二个资源的访问，它将产生一个称为**死锁**的问题。这些都是程序员在使用多个线程时可能遇到的两个非常简单的挑战示例。
- en: 'First, we’ll reproduce a problem caused by the concurrent modification of the
    same value. Let’s create a `Calculator` interface, as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将重现由同一值的并发修改引起的问题。让我们创建一个`Calculator`接口，如下所示：
- en: '[PRE164]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'We will use the `getDescription()` method to capture the description of the
    implementation. Here is the first implementation:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`getDescription()`方法来捕获实现的描述。以下是第一个实现：
- en: '[PRE168]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: As you can see, the `calculate()` method assigns a new value to the `prop` property,
    then does something else (we simulate it by calling the `sleep()` method), and
    then calculates the square root of the value assigned to the `prop` property.
    The `"Without synchronization"` description depicts the fact that the value of
    the `prop` property is changing every time the `calculate()` method is called—without
    any coordination or **synchronization**, as it is called in the case of coordination
    between threads when they concurrently modify the same resource.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`calculate()`方法将新值赋给`prop`属性，然后做其他事情（我们通过调用`sleep()`方法来模拟它），然后计算赋给`prop`属性的值的平方根。`"Without
    synchronization"`描述描绘了每次调用`calculate()`方法时`prop`属性的值都会改变的事实——没有任何协调或**同步**，正如在线程并发修改同一资源时的协调所称呼的那样。
- en: We are now going to share this object between two threads, which means that
    the `prop` property is going to be updated and used concurrently. So, some kind
    of thread synchronization around the `prop` property is necessary, but we have
    decided that our first implementation does not do it.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在这个对象之间共享两个线程，这意味着`prop`属性将被并发更新和使用。因此，围绕`prop`属性的某种线程同步是必要的，但我们已经决定我们的第一个实现不这样做。
- en: 'Here is the method we are going to use while executing every `Calculator` implementation
    we are going to create:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将要使用的方法，在执行我们将要创建的每个`Calculator`实现时：
- en: '[PRE184]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'As you can see, the preceding method does the following:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面的方法执行以下操作：
- en: Prints a description of the passed-in `Calculator` implementation.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印传入的`Calculator`实现的描述。
- en: Creates a fixed-size pool for two threads.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为两个线程创建一个固定大小的线程池。
- en: 'Creates a list of two `Callable` tasks—objects of the following `MyCallable`
    class:'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含两个`Callable`任务的列表——以下`MyCallable`类的对象：
- en: '[PRE210]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: A list of tasks is passed into the `invokeAll()` method of the pool, where each
    of the tasks is executed by invoking the `call()` method; each `call()` method
    applies the `calculate()` method of the passed-in `Calculator` object to every
    one of the 19 numbers from 1 to 20 and sums up the results. The resulting sum
    is returned inside the `Result` object, along with the name of the `MyCallable`
    object.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任务列表传递给线程池的`invokeAll()`方法，其中每个任务通过调用`call()`方法执行；每个`call()`方法将传入的`Calculator`对象的`calculate()`方法应用于从1到20的所有19个数字，并将结果相加。结果总和在`Result`对象中返回，并附带`MyCallable`对象的名字。
- en: Each `Result` object is eventually returned inside a `Future` object.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个`Result`对象最终都包含在一个`Future`对象中。
- en: The `invokeAllCallables()` method then iterates over the list of `Future` objects
    and checks whether each of their tasks has been completed. When a task is completed,
    the result is added to `List<Result> results`.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后`invokeAllCallables()`方法遍历`Future`对象列表，并检查每个任务是否已完成。当任务完成时，结果被添加到`List<Result>
    results`中。
- en: After all tasks are completed, the `invokeAllCallables()` method then prints
    all elements of `List<Result> results` and terminates the pool.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有任务完成后，`invokeallCallables()`方法将打印`List<Result> results`的所有元素，并终止线程池。
- en: 'Here is the result we got from one of our runs of `invokeAllCallables(new CalculatorNoSync())`:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们从`invokeAllCallables(new CalculatorNoSync())`的一次运行中得到的成果：
- en: '![](img/B18388_Figure_8.8.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_8.8.jpg)'
- en: The actual numbers are slightly different every time we run the preceding code,
    but the result of the `One` task never equals the result of the `Two` task. That
    is because, in the period between setting the value of the `prop` field and returning
    its square root in the `calculate()` method, the other thread managed to assign
    a different value to `prop`. This is a case of thread interference.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行前面的代码时，实际数字都会略有不同，但`One`任务的结果永远不会等于`Two`任务的结果。这是因为，在设置`prop`字段值和`calculate()`方法中返回其平方根之间，其他线程设法将不同的值赋给`prop`。这是一个线程干扰的例子。
- en: There are several ways to address this problem. We start with an atomic variable
    as a way to achieve thread-safe concurrent access to a property. Then, we will
    also demonstrate two methods of thread synchronization.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决这个问题。我们从一个原子变量开始，作为实现线程安全并发访问属性的一种方式。然后，我们还将演示两种线程同步方法。
- en: Atomic variable
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子变量
- en: An `prop` value should not be used if it has been changed by another thread.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`prop`值已被其他线程更改，则不应使用它。
- en: 'The `java.util.concurrent.atomic` package has a dozen classes that support
    this logic: `AtomicBoolean`, `AtomicInteger`, `AtomicReference`, and `AtomicIntegerArray`,
    to name a few. Each of these classes has many methods that can be used for different
    synchronization needs. Check the online **application programming interface**
    (**API**) documentation for each of these classes ([https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/atomic/package-summary.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/atomic/package-summary.html)).
    For the demonstration, we will use only two methods present in all of them, as
    outlined here:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.atomic`包有十几个类支持这种逻辑：`AtomicBoolean`、`AtomicInteger`、`AtomicReference`和`AtomicIntegerArray`等。这些类中的每一个都有许多可用于不同同步需求的方法。请检查每个类的在线**应用程序编程接口**（**API**）文档（[https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/atomic/package-summary.html](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/atomic/package-summary.html)）。为了演示，我们将只使用其中所有类都存在的两个方法，如下所述：'
- en: '`V get()`: Returns the current value'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V get()`: 返回当前值'
- en: '`boolean compareAndSet(V expectedValue, V newValue)`: Sets the value to `newValue`
    if the current value equals via the (`==`) operator the `expectedValue` value;
    returns `true` if successful or `false` if the actual value was not equal to the
    expected value'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean compareAndSet(V expectedValue, V newValue)`: 如果当前值通过`==`运算符等于`expectedValue`值，则将值设置为`newValue`；如果成功则返回`true`，如果实际值不等于预期值则返回`false`'
- en: 'Here is how the `AtomicReference` class can be used to solve the problem of
    thread interference while accessing the `prop` property of the `Calculator` object
    concurrently using these two methods:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用`AtomicReference`类来解决这个问题，即在使用这两种方法同时访问`Calculator`对象的`prop`属性时，解决线程干扰问题：
- en: '[PRE211]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'As you can see, the preceding code makes sure that the `currentValue` value
    of the `prop` property does not change while the thread was sleeping. Here is
    a screenshot of messages produced when we run `invokeAllCallables(new CalculatorAtomicRef())`:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面的代码确保在线程睡眠期间`prop`属性的`currentValue`值不会改变。以下是当我们运行`invokeAllCallables(new
    CalculatorAtomicRef())`时产生的消息截图：
- en: '![](img/B18388_Figure_8.9.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_8.9.jpg)'
- en: Now, the results produced by the threads are the same.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，线程产生的结果相同。
- en: 'The following classes of the `java.util.concurrent` package provide synchronization
    support too:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent`包中的以下类也提供了同步支持：'
- en: '`Semaphore`: Restricts the number of threads that can access a resource'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Semaphore`：限制可以访问资源的线程数量'
- en: '`CountDownLatch`: Allows one or more threads to wait until a set of operations
    being performed in other threads are completed'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CountDownLatch`：允许一个或多个线程等待，直到其他线程中正在执行的一组操作完成'
- en: '`CyclicBarrier`: Allows sets of threads to wait for each other to reach a common
    barrier point'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CyclicBarrier`：允许一组线程等待其他线程到达共同的屏障点'
- en: '`Phaser`: Provides a more flexible form of barrier that may be used to control
    phased computation among multiple threads'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Phaser`：提供了一种更灵活的屏障形式，可用于控制多个线程之间的分阶段计算'
- en: '`Exchanger`: Allows two threads to exchange objects at a rendezvous point and
    is useful in several pipeline designs'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchanger`：允许两个线程在会合点交换对象，并在多个管道设计中非常有用'
- en: Synchronized method
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步方法
- en: 'Another way to solve the problem is to use a synchronized method. Here is another
    implementation of the `Calculator` interface that uses this method of solving
    thread interference:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的另一种方法是使用同步方法。下面是`Calculator`接口的另一种实现，它使用这种方法来解决线程干扰问题：
- en: '[PRE233]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'We have just added the `synchronized` keyword in front of the `calculate()`
    method. Now, if we run `invokeAllCallables(new CalculatorSyncMethod())`, the results
    of both threads are always going to be the same, as we can see here:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在`calculate()`方法前添加了`synchronized`关键字。现在，如果我们运行`invokeAllCallables(new CalculatorSyncMethod())`，两个线程的结果总是相同的，正如我们在这里看到的：
- en: '![](img/B18388_Figure_8.10.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_8.10.jpg)'
- en: This is because another thread cannot enter the synchronized method until the
    current thread (the one that has entered the method already) has exited it. This
    is probably the simplest solution, but this approach may cause performance degradation
    if the method takes a long time to execute. In such cases, a synchronized block
    can be used, which only wraps several lines of code in an atomic operation.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为另一个线程无法进入同步方法，直到当前线程（已经进入方法的那个线程）退出它。这可能是最简单的解决方案，但如果方法执行时间较长，这种方法可能会导致性能下降。在这种情况下，可以使用同步块，它只将几行代码封装在一个原子操作中。
- en: Synchronized block
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步块
- en: 'Here is an example of a synchronized block used to solve the problem of thread
    interference:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用同步块解决线程干扰问题的示例：
- en: '[PRE252]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: As you can see, the synchronized block acquires a lock on the `this` object,
    which is shared by both threads, and releases it only after the threads exit the
    block. In our demonstration code, the block covers all the code of the method,
    so there is no difference in performance. But imagine there is more code in the
    method (we commented the location as `there may be some other code here`). If
    that is the case, the synchronized section of the code is smaller, thus having
    fewer chances to become a bottleneck.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，同步块获取了`this`对象的锁，该锁由两个线程共享，并且仅在线程退出块后释放。在我们的演示代码中，该块覆盖了方法的所有代码，因此性能上没有差异。但想象一下，方法中还有更多的代码（我们在注释中标记了位置为`there
    may be some other code here`）。如果是这样，代码的同步部分较小，因此成为瓶颈的机会更少。
- en: 'If we run `invokeAllCallables(new CalculatorSyncBlock())`, the results look
    like this:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`invokeAllCallables(new CalculatorSyncBlock())`，结果看起来像这样：
- en: '![](img/B18388_Figure_8.11.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_8.11.jpg)'
- en: As you can see, the results are exactly the same as in the previous two examples.
    Different types of locks for different needs and with different behavior are assembled
    in the `java.util.concurrent.locks` package.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，结果与前面两个例子完全相同。不同类型的锁针对不同的需求，并且具有不同的行为，都被组装在`java.util.concurrent.locks`包中。
- en: Each object in Java inherits the `wait()`, `notify()`, and `notifyAll()` methods
    from the base object. These methods can also be used to control threads’ behavior
    and their access to the locks.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的每个对象都从基对象继承了`wait()`、`notify()`和`notifyAll()`方法。这些方法也可以用来控制线程的行为以及它们对锁的访问。
- en: Concurrent collections
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发集合
- en: 'Another way to address concurrency is to use a thread-safe collection from
    the `java.util.concurrent` package. Before you select which collection to use,
    read the *Javadoc* documentation ([https://docs.oracle.com/en/java/javase/17/docs/api/index.html](https://docs.oracle.com/en/java/javase/17/docs/api/index.html))
    to see whether the limitations of the collection are acceptable for your application.
    Here is a list of these collections and some recommendations:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 解决并发问题的另一种方法是使用`java.util.concurrent`包中的线程安全集合。在选择使用哪个集合之前，请阅读*Javadoc*文档([https://docs.oracle.com/en/java/javase/17/docs/api/index.html](https://docs.oracle.com/en/java/javase/17/docs/api/index.html))，以查看集合的限制是否适合您的应用程序。以下是一些这些集合的列表和一些推荐：
- en: '`ConcurrentHashMap<K,V>`: Supports full concurrency of retrievals and high-expected
    concurrency for updates; use it when the concurrency requirements are very demanding
    and you need to allow locking on the write operation but do not need to lock the
    element.'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap<K,V>`：支持完全并发检索和高预期的更新并发性；当并发需求非常严格且您需要允许在写入操作上锁定但不需要锁定元素时使用它。'
- en: '`ConcurrentLinkedQueue<E>`: A thread-safe queue based on linked nodes; employs
    an efficient non-blocking algorithm.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentLinkedQueue<E>`：基于链表的线程安全队列；采用高效的非阻塞算法。'
- en: '`ConcurrentLinkedDeque<E>`: A concurrent queue based on linked nodes; both
    `ConcurrentLinkedQueque` and `ConcurrentLinkedDeque` are an appropriate choice
    when many threads share access to a common collection.'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentLinkedDeque<E>`：基于链表的并发队列；当许多线程共享对公共集合的访问时，`ConcurrentLinkedQueque`和`ConcurrentLinkedDeque`都是合适的选择。'
- en: '`ConcurrentSkipListMap<K,V>`: A concurrent `ConcurrentNavigableMap` interface
    implementation.'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentSkipListMap<K,V>`：并发`ConcurrentNavigableMap`接口实现。'
- en: '`ConcurrentSkipListSet<E>`: A concurrent `NavigableSet` implementation based
    on the `ConcurrentSkipListMap` class. The `ConcurrentSkipListSet` and `ConcurrentSkipListMap`
    classes, as per the *Javadoc* documentation, “*provide expected average log(n)
    time cost for the contains, add, and remove operations and their variants. Ascending
    ordered views and their iterators are faster than descending ones*.” Use them
    when you need to iterate quickly through elements in a certain order.'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentSkipListSet<E>`：基于`ConcurrentSkipListMap`类的并发`NavigableSet`实现。根据*Javadoc*文档，`ConcurrentSkipListSet`和`ConcurrentSkipListMap`类“*提供预期的平均对数(n)时间成本，对于包含、添加和删除操作及其变体。升序视图及其迭代器比降序视图更快*。”当您需要快速按特定顺序遍历元素时使用它们。'
- en: '`CopyOnWriteArrayList<E>`: A thread-safe variant of `ArrayList` in which all
    mutative operations (add, set, and so on) are implemented by making a fresh copy
    of the underlying array. As per the *Javadoc* documentation, the `CopyOnWriteArrayList`
    class “*is ordinarily too costly, but may be more efficient than alternatives
    when traversal operations vastly outnumber mutations, and is useful when you cannot
    or don''t want to synchronize traversals, yet need to preclude interference among
    concurrent threads*.” Use it when you do not need to add new elements at different
    positions and do not require sorting; otherwise, use `ConcurrentSkipListSet`.'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CopyOnWriteArrayList<E>`：`ArrayList`的线程安全变体，其中所有可变操作（添加、设置等）都是通过创建底层数组的全新副本来实现的。根据*Javadoc*文档，`CopyOnWriteArrayList`类“*通常成本较高，但在遍历操作远多于突变时可能比其他替代方案更有效，当您无法或不想同步遍历，但仍需要防止并发线程之间的干扰时很有用*。”当您不需要在不同位置添加新元素且不需要排序时使用它；否则，使用`ConcurrentSkipListSet`。'
- en: '`CopyOnWriteArraySet<E>`: A set that uses an internal `CopyOnWriteArrayList`
    class for all of its operations.'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CopyOnWriteArraySet<E>`：使用内部`CopyOnWriteArrayList`类执行所有操作的集合。'
- en: '`PriorityBlockingQueue`: This is a better choice when a natural order is acceptable
    and you need fast adding of elements to the tail and fast removing of elements
    from the head of the queue. **Blocking** means that the queue waits to become
    non-empty when retrieving an element and waits for space to become available in
    the queue when storing an element.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PriorityBlockingQueue`：当可以接受自然顺序且需要快速向队列尾部添加元素和快速从队列头部移除元素时，这是一个更好的选择。**阻塞**意味着在检索元素时队列等待变为非空，在存储元素时等待队列中有空间可用。'
- en: '`ArrayBlockingQueue`, `LinkedBlockingQueue`, and `LinkedBlockingDeque` have
    a fixed size (bounded); other queues are unbounded.'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayBlockingQueue`、`LinkedBlockingQueue`和`LinkedBlockingDeque`具有固定大小（有界）；其他队列是无界的。'
- en: 'Use these and similar characteristics and recommendations as per the guidelines,
    but execute comprehensive testing and performance-measuring before and after implementing
    your functionality. To demonstrate some of these collections’ capabilities, let’s
    use `CopyOnWriteArrayList<E>`. First, let’s look in the following code snippet
    at how `ArrayList` behaves when we try to modify it concurrently:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 根据指南使用这些和类似的特点和建议，但在实现功能前后进行全面的测试和性能测量。为了展示这些集合的一些功能，让我们使用`CopyOnWriteArrayList<E>`。首先，让我们看一下以下代码片段中`ArrayList`在尝试并发修改时的行为：
- en: '[PRE273]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: As expected, the attempt to modify a list while iterating on it generates an
    exception, and the list remains unmodified.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，在迭代列表的同时尝试修改它会产生异常，并且列表保持未修改状态。
- en: 'Now, let’s use `CopyOnWriteArrayList<E>` in the same circumstances, as follows:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在相同的情况下使用`CopyOnWriteArrayList<E>`，如下所示：
- en: '[PRE284]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: 'The output this code produces looks like this:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码产生的输出看起来像这样：
- en: '![](img/B18388_Figure_8.12.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_8.12.jpg)'
- en: As you can see, the list was modified without an exception, but not the currently
    iterated copy. That is the behavior you can use if needed.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，列表被修改而没有异常，但不是当前迭代的副本。这就是您如果需要可以使用的操作行为。
- en: Addressing memory consistency errors
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决内存一致性错误
- en: Memory consistency errors can have many forms and causes in a multithreaded
    environment. They are well discussed in the *Javadoc* documentation of the `java.util.concurrent`
    package. Here, we will mention only the most common case, which is caused by a
    lack of visibility.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程环境中，内存一致性错误可能具有许多形式和原因。它们在`java.util.concurrent`包的*Javadoc*文档中有很好的讨论。在这里，我们只提到最常见的情况，即由可见性不足引起。
- en: When one thread changes a property value, the other might not see the change
    immediately, and you cannot use the `synchronized` keyword for a primitive type.
    In such a situation, consider using the `volatile` keyword for the property, as
    this guarantees its read/write visibility between different threads.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个线程更改属性值时，另一个线程可能不会立即看到更改，并且不能为原始类型使用`synchronized`关键字。在这种情况下，考虑使用`volatile`关键字来指定属性，因为这保证了它在不同线程之间的读写可见性。
- en: Concurrency problems are not easy to solve, which is why it is not surprising
    that more and more developers are now taking a more radical approach. Instead
    of managing an object state, they prefer processing data in a set of stateless
    operations. We will see examples of such code in [*Chapter 13*](B18388_13_ePub.xhtml#_idTextAnchor281),
    *Functional Programming*, and [*Chapter 14*](B18388_14_ePub.xhtml#_idTextAnchor296),
    *Java Standard Streams*. It seems that Java and many modern languages and computer
    systems are evolving in this direction.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 并发问题不容易解决，这也是为什么越来越多的开发者现在采取更激进的方法并不令人惊讶。他们不是管理对象状态，而是更喜欢在一系列无状态操作中处理数据。我们将在[*第13章*](B18388_13_ePub.xhtml#_idTextAnchor281)“函数式编程”和[*第14章*](B18388_14_ePub.xhtml#_idTextAnchor296)“Java标准流”中看到此类代码的示例。看起来Java和许多现代语言以及计算机系统都在这个方向上发展。
- en: Summary
  id: totrans-514
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked about multithreaded processing, ways to organize
    it, and avoiding unpredictable results caused by concurrent modification of the
    shared resource. We have shown you how to create threads and execute them using
    pools of threads. We have also demonstrated how results can be extracted from
    the threads that have completed successfully and discussed the difference between
    parallel and concurrent processing.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了多线程处理、组织它的方法以及避免由共享资源的并发修改引起的不可预测的结果。我们向您展示了如何创建线程并使用线程池来执行它们。我们还演示了如何从成功完成的线程中提取结果，并讨论了并行处理和并发处理之间的区别。
- en: In the next chapter, we will provide you with a deeper understanding of JVM
    and its structure and processes, and we’ll discuss in detail the garbage-collection
    process that keeps memory from being overflown. By the end of the chapter, you
    will know what constitutes Java application execution, Java processes inside JVM,
    garbage collection, and how JVM works in general.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为您提供对JVM及其结构和过程的更深入理解，并将详细讨论防止内存溢出的垃圾回收过程。到本章结束时，您将了解构成Java应用程序执行、JVM内部的Java进程、垃圾回收以及JVM一般工作原理的内容。
- en: Quiz
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 习题
- en: 'Select all correct statements:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: A JVM process can have main threads.
  id: totrans-519
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM进程可以有主线程。
- en: The main thread is the main process.
  id: totrans-520
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主线程是主进程。
- en: A process can launch another process.
  id: totrans-521
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个进程可以启动另一个进程。
- en: A thread may launch another thread.
  id: totrans-522
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个线程可以启动另一个线程。
- en: 'Select all correct statements:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: A daemon is a user thread.
  id: totrans-524
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 守护线程是一个用户线程。
- en: A daemon thread exits after the first user thread completes.
  id: totrans-525
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 守护线程在第一个用户线程完成后退出。
- en: A daemon thread exits after the last user thread completes.
  id: totrans-526
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 守护线程在最后一个用户线程完成后退出。
- en: The main thread is a user thread.
  id: totrans-527
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主线程是一个用户线程。
- en: 'Select all correct statements:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: All threads have `java.lang.Thread` as a base class.
  id: totrans-529
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有线程都以`java.lang.Thread`为基类。
- en: All threads extend `java.lang.Thread`.
  id: totrans-530
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有线程都扩展自`java.lang.Thread`。
- en: All threads implement `java.lang.Thread`.
  id: totrans-531
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有线程都实现了`java.lang.Thread`。
- en: A daemon thread does not extend `java.lang.Thread`.
  id: totrans-532
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 守护线程不扩展自`java.lang.Thread`。
- en: 'Select all correct statements:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: Any class can implement the `Runnable` interface.
  id: totrans-534
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何类都可以实现`Runnable`接口。
- en: The `Runnable` interface implementation is a thread.
  id: totrans-535
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Runnable`接口的实现是一个线程。'
- en: The `Runnable` interface implementation is used by a thread.
  id: totrans-536
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Runnable`接口的实现被线程使用。'
- en: The `Runnable` interface has only one method.
  id: totrans-537
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Runnable`接口只有一个方法。'
- en: 'Select all correct statements:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: A thread name has to be unique.
  id: totrans-539
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程名称必须是唯一的。
- en: A thread ID is generated automatically.
  id: totrans-540
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程ID是自动生成的。
- en: A thread name can be set.
  id: totrans-541
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以设置线程名称。
- en: A thread priority can be set.
  id: totrans-542
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以设置线程优先级。
- en: 'Select all correct statements:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: A thread pool executes threads.
  id: totrans-544
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程池执行线程。
- en: A thread pool reuses threads.
  id: totrans-545
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程池会重用线程。
- en: Some thread pools can have a fixed count of threads.
  id: totrans-546
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些线程池可以有固定数量的线程。
- en: Some thread pools can have an unlimited count of threads.
  id: totrans-547
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些线程池可以有无限数量的线程。
- en: 'Select all correct statements:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: A `Future` object is the only way to get the result from a thread.
  id: totrans-549
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从线程获取结果的方法只有`Future`对象。
- en: A `Callable` object is the only way to get the result from a thread.
  id: totrans-550
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从线程获取结果的唯一方法是`Callable`对象。
- en: A `Callable` object allows us to get the result from a thread.
  id: totrans-551
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Callable`对象允许我们从线程获取结果。'
- en: A `Future` object represents a thread.
  id: totrans-552
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Future`对象代表一个线程。'
- en: 'Select all correct statements:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: Concurrent processing can be done in parallel.
  id: totrans-554
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并发处理可以在并行中进行。
- en: Parallel processing is possible only with several CPUs or cores available on
    the computer.
  id: totrans-555
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有当计算机上有多个CPU或核心时，才可能进行并行处理。
- en: Parallel processing is concurrent processing.
  id: totrans-556
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并行处理是并发处理。
- en: Without multiple CPUs, concurrent processing is impossible.
  id: totrans-557
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有多个CPU，并发处理是不可能的。
- en: 'Select all correct statements:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: Concurrent modification always leads to incorrect results.
  id: totrans-559
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并发修改总是导致结果不正确。
- en: An atomic variable protects a property from concurrent modification.
  id: totrans-560
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原子变量可以保护属性免受并发修改。
- en: An atomic variable protects a property from thread interference.
  id: totrans-561
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原子变量可以保护属性免受线程干扰。
- en: An atomic variable is the only way to protect a property from concurrent modification.
  id: totrans-562
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原子变量是保护属性免受并发修改的唯一方式。
- en: 'Select all correct statements:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: The `synchronized` method is the best way to avoid thread interference.
  id: totrans-564
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`synchronized`方法是避免线程干扰的最佳方式。'
- en: The `synchronized` keyword can be applied to any method.
  id: totrans-565
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`synchronized`关键字可以应用于任何方法。'
- en: The `synchronized` method can create a processing bottleneck.
  id: totrans-566
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`synchronized`方法可以创建处理瓶颈。'
- en: The `synchronized` method is easy to implement.
  id: totrans-567
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`synchronized`方法易于实现。'
- en: 'Select all correct statements:'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: A `synchronized` block makes sense only when it is smaller than the method.
  id: totrans-569
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有当`synchronized`块小于方法时才有意义。
- en: A `synchronized` block requires a shared lock.
  id: totrans-570
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`synchronized`块需要一个共享锁。'
- en: Every Java object can provide a lock.
  id: totrans-571
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个Java对象都可以提供一个锁。
- en: A `synchronized` block is the best way to avoid thread interference.
  id: totrans-572
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`synchronized`块是避免线程干扰的最佳方式。'
- en: 'Select all correct statements:'
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: Using a concurrent collection is preferred over using a non-concurrent one.
  id: totrans-574
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用并发集合比使用非并发集合更受欢迎。
- en: Using a concurrent collection incurs some overhead.
  id: totrans-575
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用并发集合会带来一些开销。
- en: Not every concurrent collection fits every concurrent processing scenario.
  id: totrans-576
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并非每个并发集合都适合每个并发处理场景。
- en: We can create a concurrent collection by calling the `Collections.makeConcurrent()`
    method.
  id: totrans-577
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过调用`Collections.makeConcurrent()`方法来创建并发集合。
- en: 'Select all correct statements:'
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: The only way to avoid a memory consistency error is to declare the `volatile`
    variable.
  id: totrans-579
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 避免内存一致性错误的唯一方法是声明`volatile`变量。
- en: Using the `volatile` keyword guarantees visibility of the value change across
    all threads.
  id: totrans-580
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`volatile`关键字可以保证所有线程都能看到值的变化。
- en: One way to avoid concurrency is to avoid any state management.
  id: totrans-581
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 避免并发的一种方法是不进行任何状态管理。
- en: Stateless utility methods cannot have concurrency issues.
  id: totrans-582
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无状态工具方法不会有并发问题。
