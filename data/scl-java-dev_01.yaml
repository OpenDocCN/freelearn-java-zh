- en: Chapter 1. Programming Interactively within Your Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 在您的项目中交互式编程
- en: Moving away from a well established and mature language such as Java requires
    some pretty good reasons. Before pragmatically trying out some of the apparent
    differences between Java and Scala in order to get acquainted with the Scala syntax,
    we are going to clarify what makes Scala so attractive.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 离开一个成熟且稳定的语言，如Java，需要一些相当充分的理由。在尝试了解Scala语法之前，我们先要明确Scala之所以吸引人的原因。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The advantages of using Scala for Java projects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scala进行Java项目的好处
- en: Getting familiar with the syntax of the language through a crash course following
    an interactive session, including case classes, operations on collections, and
    a glimpse of some useful features such as options, tuples, maps, pattern matching,
    and string interpolation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过交互式会话后的快速课程熟悉语言语法，包括案例类、集合操作，以及一些有用的功能，如选项、元组、映射、模式匹配和字符串插值
- en: Advantages of using Scala for Java projects
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Scala进行Java项目的好处
- en: The order of appearance and importance that we propose here only reflects our
    personal experience since every project and group of programmers usually have
    their own agenda when it comes to priorities.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里提出的出现顺序和重要性仅反映我们个人的经验，因为每个项目和程序员团队在优先级方面通常都有自己的议程。
- en: More concise and expressive
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更简洁、更易于表达
- en: 'The ultimate reason why you should adopt Scala is readability: code that is
    similar to plain English will make it easier for anyone (including yourself) to
    understand, maintain, and refactor it. Scala is unique in that it unifies the
    object-oriented side that Java has in order to make code modular with the power
    of functional languages to express transformations concisely. To illustrate how
    to achieve conciseness by the introduction of anonymous functions (also called
    **lambdas**) into the language, take a look at the following line of code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该采用Scala的最终原因是可读性：类似于普通英语的代码将使任何人（包括你自己）更容易理解、维护和重构它。Scala的独特之处在于它统一了Java具有的面向对象方面，以便使代码模块化，并利用函数式语言的强大功能来简洁地表达转换。为了说明如何通过在语言中引入匿名函数（也称为**lambda**）来实现简洁性，请看以下代码行：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As a Java programmer, the line might look awkward at first since it does not
    follow the usual pattern of invoking method signatures on classes. A possible
    Java translation of the previous code could be as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java程序员来说，一开始可能会觉得这行代码看起来有些不自然，因为它不符合在类上调用方法签名的一般模式。之前代码可能的Java翻译如下：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all books by Packt Publishing that
    you have purchased from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Packt Publishing的账户下载您购买的所有书籍的示例代码文件。[http://www.packtpub.com](http://www.packtpub.com)。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)，并注册以直接将文件通过电子邮件发送给您。
- en: 'We first create a `List` with five integers, then create an empty `List` that
    will hold the result of the filtering and then loop over the elements of the `List`
    to retain only the ones that match the `if` predicate (`element < 4`) and finally
    print out the result. Even if this is straightforward to write, it requires a
    few lines of code, whereas the Scala line could just be read like the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个包含五个整数的`List`，然后创建一个空的`List`，它将保存过滤的结果，然后遍历`List`中的元素，只保留符合`if`谓词（`element
    < 4`）的元素，最后打印出结果。即使这写起来很简单，但也需要几行代码，而Scala的代码可以像下面这样阅读：
- en: '"From the given `List`, filter each element such that this element is lower
    than `4`".'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: “从给定的`List`中过滤每个元素，使得该元素小于`4`”。
- en: The fact that the code becomes really concise but expressive makes it easier
    for the programmer to comprehend at once a difficult or lengthy algorithm.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 代码变得非常简洁且易于表达，这使得程序员能够立即理解一个复杂或冗长的算法。
- en: Increased productivity
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高生产力
- en: Having a compiler that performs a lot of type checking and works as a personal
    assistant, is in our opinion, a significant advantage over languages that check
    types dynamically at runtime, and the fact that Java is a statically-typed language
    is probably one of the main reasons that made it so popular in the first place.
    The Scala compiler belongs to this category as well and goes even further by finding
    out many of the types automatically, often relieving the programmer from specifying
    these types explicitly in the code. Moreover, the compiler in your IDE gives instant
    feedback, and therefore, increases your productivity.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个执行大量类型检查并充当个人助手的编译器，据我们看来，这是相对于在运行时动态检查类型的语言的一个显著优势，而Java作为静态类型语言，可能是它最初如此受欢迎的主要原因之一。Scala编译器也属于这一类，并且更进一步，它能够自动找出许多类型，通常可以减轻程序员在代码中明确指定这些类型的负担。此外，你IDE中的编译器可以提供即时反馈，因此提高了你的生产力。
- en: Natural evolution from Java
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自然地从Java进化而来
- en: Scala integrates seamlessly with Java, which is a very attractive feature, to
    avoid reinventing the wheel. You can start running Scala today in a production
    environment. Large corporations such as Twitter, LinkedIn, or Foursquare (to name
    a few) have done that on large-scale deployments for many years now, followed
    recently by other big players such as Intel or Amazon. Scala compiles to Java
    bytecode, which means that performance will be comparable. Most of the code that
    you are running while executing Scala programs is probably Java code, the major
    difference being what programmers see and the advanced type checking while compiling
    code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Scala与Java无缝集成，这是一个非常吸引人的特性，可以避免重新发明轮子。你今天就可以在生产环境中开始运行Scala。像Twitter、LinkedIn或Foursquare（仅举几个例子）这样的大型企业已经在过去很多年里进行了大规模部署，最近还有像Intel或Amazon这样的巨头也加入了进来。Scala编译成Java字节码，这意味着性能将相当。当你执行Scala程序时，你运行的大多数代码可能是Java代码，主要区别在于程序员看到的内容以及编译代码时的先进类型检查。
- en: Better fit for asynchronous and concurrent code
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更适合异步和并发代码
- en: To achieve better performance and handle more load, modern Java frameworks and
    libraries for web development are now tackling difficult problems that are tied
    to multi-core architectures and the integration with unpredictable external systems.
    Scala's incentive to use immutable data structures and functional programming
    constructs as well as its support for parallel collections has a better chance
    to succeed in writing concurrent code that will behave correctly. Moreover, Scala's
    superior type system and macro support enable DSLs for trivially safe asynchronous
    constructs, for example, composable futures and asynchronous language extensions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现更好的性能和处理更多的负载，现代Java Web开发框架和库现在正在解决与多核架构和与不可预测的外部系统集成相关的一些难题。Scala使用不可变数据结构和函数式编程结构以及其对并行集合的支持，更有可能成功编写出表现正确的并发代码。此外，Scala优越的类型系统和宏支持使得可以编写出安全异步结构，例如可组合的异步和异步语言扩展。
- en: In summary, Scala is the only language that has it all. It is statically typed,
    runs on the JVM and is totally Java compatible, is both object-oriented and functional,
    and is not verbose, thereby leading to better productivity, less maintenance,
    and therefore more fun.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Scala是唯一一个拥有所有这些特性的语言。它是静态类型的，在JVM上运行，并且完全兼容Java，既面向对象又函数式，而且不啰嗦，因此提高了生产力，减少了维护，因此更有趣。
- en: If you are now getting impatient to start experimenting with the promising features
    of Scala that were briefly described previously, this is a good time to open a
    browser, access the Typesafe page URL at [http://www.typesafe.com/platform/getstarted](http://www.typesafe.com/platform/getstarted),
    and download the Typesafe Activator.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在迫不及待地想要开始尝试之前简要描述的Scala的诱人特性，现在是打开浏览器、访问Typesafe页面URL [http://www.typesafe.com/platform/getstarted](http://www.typesafe.com/platform/getstarted)
    并下载Typesafe Activator的好时机。
- en: The intent of the rest of the chapter is to incrementally introduce some of
    the basic concepts of Scala by typing commands in an interactive shell and get
    direct feedback from the compiler. This method of learning by experimentation
    should feel like a breath of fresh air and has already proven to be a very effective
    way of learning the syntax and useful constructs of the language. While Scala
    continues to evolve at École Polytechnique Fédérale de Lausanne (EPFL), many large
    and small corporations are now taking advantage of the features of the Typesafe
    platform.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余部分的目的是通过在交互式 shell 中输入命令，逐步介绍 Scala 的一些基本概念，并直接从编译器获得反馈。这种通过实验学习的方法应该像一股清新的空气，并且已经被证明是一种非常有效的学习语言语法和有用结构的方法。虽然
    Scala 在洛桑联邦理工学院（EPFL）持续发展，但现在许多大公司和中小企业都在利用 Typesafe 平台的功能。
- en: As stated on their website, the Typesafe Activator is "a local web and command-line
    tool that helps developers get started with the Typesafe platform". We will cover
    the Activator in more detail in a later chapter dedicated to programming tools,
    but for now, we will only take the shortest path in getting up and running and
    get familiar with some of the syntax of the language.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如同他们网站所述，Typesafe Activator 是“一个本地的网页和命令行工具，帮助开发者开始使用 Typesafe 平台”。我们将在后续的章节中更详细地介绍
    Activator，但在此阶段，我们只需走最短的路来启动并运行，熟悉一些语言的语法。
- en: You should now be able to extract the downloaded zip archive to your system
    in a directory of your choice.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够将下载的 zip 压缩文件解压到你的系统中的任意目录。
- en: 'Locate the activator script within the extracted archive and either right-click
    on it and select **Open** if you are running Windows or enter the following command
    in a terminal window if you are on Linux/Mac:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在解压的存档中找到 activator 脚本，如果你正在运行 Windows，则右键单击它并选择 **打开**；如果你在 Linux/Mac 上，则在终端窗口中输入以下命令：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In both cases, this will start the Activator UI in a browser window.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，这将在浏览器窗口中启动 Activator UI。
- en: In the **New application** section of the HTML page of the Activator, click
    on the `[Basics] Hello-Scala!` template.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Activator 的 HTML 页面的 **新应用程序** 部分中，点击 `[基础] Hello-Scala!` 模板。
- en: 'Notice the **Location** field of the HTML form in the following screenshot.
    It indicates where your project will be created:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下截图中的 HTML 表单的 **位置** 字段。它指示了你的项目将被创建的位置：
- en: '![Better fit for asynchronous and concurrent code](img/3637OS_01_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![更适合异步和并发代码](img/3637OS_01_01.jpg)'
- en: At present, you don't need to pay too much attention to all of the things that
    happen in the background nor to the generated structure of the project. Out of
    curiosity, you may click on the **Code view & Open in IDE** tab and then on the
    **Run** tab to execute this Hello World Scala project, which should print, well,
    **"Hello, world !"**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你不需要过多关注后台发生的事情，也不需要关注项目生成的结构。出于好奇，你可以点击 **代码视图 & 在 IDE 中打开** 选项卡，然后点击 **运行**
    选项卡来执行这个 Hello World Scala 项目，它应该会打印出 **"Hello, world !"**。
- en: 'Start a terminal window and navigate to the root directory of the *hello-scala*
    project that we just created, by entering the following command on the command
    line (assuming our project is under `C:\Users\Thomas\hello-scala`):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个终端窗口，并通过在命令行中输入以下命令导航到我们刚刚创建的 *hello-scala* 项目的根目录（假设我们的项目位于 `C:\Users\Thomas\hello-scala`）：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command will start the Scala interpreter, also known as Scala **REPL**
    (**Read-Eval-Print-Loop**), a simple command-line tool to program interactively.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将启动 Scala 解释器，也称为 Scala **REPL**（**读取-评估-打印-循环**），这是一个简单的交互式命令行工具。
- en: Learning Scala through the REPL
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 REPL 学习 Scala
- en: As a Java developer, an REPL may be new to you since there is no such thing
    for the Java language. It used to refer to the Lisp language interactive environment,
    and today, equivalent tools are available for many programming languages such
    as JavaScript, Clojure, Ruby, and Scala. It consists of a command-line shell where
    you can enter one or more expressions rather than complete files and get immediate
    feedback by evaluating the result. The REPL is a fantastic tool that helps us
    to learn all the Scala syntax because it compiles and executes every statement
    that you write using the full power of the compiler. In such an interactive environment,
    you get instant feedback on every line of code you write.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Java开发者，REPL可能对你来说是新的，因为Java语言没有这样的东西。它曾经指的是Lisp语言的交互式环境，而今天，许多编程语言如JavaScript、Clojure、Ruby和Scala都有等效的工具。它由一个命令行shell组成，你可以输入一个或多个表达式，而不是完整的文件，并通过评估结果立即获得反馈。REPL是一个极好的工具，它帮助我们学习所有的Scala语法，因为它使用编译器的全部力量编译和执行你写的每个语句。在这样的交互式环境中，你会在你写的每一行代码上获得即时反馈。
- en: If you are new to Scala, we recommend that you carefully follow this REPL session
    as it will give you a lot of useful knowledge for programming with Scala.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触Scala，我们建议你仔细跟随这个REPL会话，因为它会给你很多关于用Scala编程的有用知识。
- en: Let's dive into some of the most apparent differences between Java and Scala
    in order to get acquainted with the Scala syntax.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨Java和Scala之间的一些最明显的差异，以便熟悉Scala语法。
- en: Declaring val/var variables
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明val/var变量
- en: 'In Java, you would declare a new variable by putting in order its type, followed
    by the name, and then the optional value:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，你会通过先放类型，然后是名称，最后是可选值来声明一个新变量：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In Scala, the order of declaring the variable name and type is inverted, with
    the name appearing before its type. Let''s enter the following line into the REPL:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，变量名和类型的声明顺序是颠倒的，类型出现在变量名之前。让我们将以下行输入到REPL中：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inverting the order of declaring the variables, type, and name as compared
    to Java might at first seem a strange idea if you want to make it as easy as possible
    for a Java developer to grab the Scala syntax. However, it makes sense for several
    reasons:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java相比，将变量、类型和名称的声明顺序颠倒可能看起来是一个奇怪的想法，如果你想让Java开发者尽可能容易地掌握Scala语法。然而，出于几个原因，这样做是有意义的：
- en: 'The Scala compiler, in this case, is able to deduct the type automatically.
    You could (and probably should, for conciseness) omit this type by entering the
    equivalent but shorter line of code instead:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，Scala编译器能够自动推断类型。你可以（并且可能应该，为了简洁）通过输入等效但更短的代码行来省略这个类型：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the most basic illustration of what is called **Type Inference**, and
    you will see that the Scala compiler will try to deduct types whenever it can.
    If we had omitted this optional type but followed the Java syntax, the parsing
    done by the compiler would have been more difficult to implement.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是最基本的**类型推断**的示例，你会看到Scala编译器会尽可能尝试推断类型。如果我们省略了这个可选的类型，但遵循Java语法，编译器所做的解析将更难实现。
- en: In our opinion, it is more important to know a variable name than its type in
    order to understand the flow of a program (and therefore make it appear first);
    for instance, if you deal with a variable representing a **social security number**
    (**ssn**), we think the term ssn is more valuable than knowing if it is represented
    as a string or an integer or any other type.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们看来，了解变量名比了解其类型更重要，以便理解程序的流程（因此将其放在前面）；例如，如果你处理一个代表**社会保障号码**（**ssn**）的变量，我们认为术语ssn比知道它是否表示为字符串、整数或其他类型更有价值。
- en: 'You probably noticed the `val` variable in front of the declaration; it means
    that we explicitly declare the variable as immutable. We can try to modify it
    as shown in the following code snippet:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到了声明前的`val`变量；这意味着我们明确地将变量声明为不可变的。我们可以尝试像以下代码片段中那样修改它：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code will not only give you a clear explanation of what was wrong
    but also the exact place where the parser did not agree (notice the `^` character
    precisely showing where the error lies in the line).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码不仅会清楚地解释出了什么问题，还会精确地指出解析器不同意的地方（注意`^`字符精确地显示了错误所在行）。
- en: 'If we want to create a mutable variable instead, we should declare it with
    `var` as shown in the following code snippet:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想创建一个可变变量，我们应该像以下代码片段中那样用`var`声明它：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In summary, you cannot change `yourPast` but you can change `yourFuture`!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，您不能更改`yourPast`，但您可以更改`yourFuture`！
- en: The semicolon at the end of the lines is optional in Scala; a small but pleasant
    feature of the language.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，行尾的分号是可选的；这是该语言的一个小而令人愉悦的特性。
- en: 'Let''s move on to an important difference. In Java, you have primitive types
    such as `int`, `char`, or `boolean` (eight in total), as well as operators to
    manipulate data such as `+` or `>`. In Scala, there are only classes and objects,
    making Scala more "object-oriented" than Java in some way. For instance, enter
    the following value into the REPL:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨一个重要的区别。在Java中，您有诸如`int`、`char`或`boolean`（总共八个）这样的原始类型，以及诸如`+`或`>`这样的操作符来操作数据。在Scala中，只有类和对象，这使得Scala在某些方面比Java更“面向对象”。例如，将以下值输入到REPL中：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By default, the compiler created an immutable `Int` (integer) variable with
    the `res1` name (that is, result 1) in case you need to reuse it later on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，编译器创建了一个名为`res1`的不可变`Int`（整数）变量（即结果1），以防您稍后需要重用它。
- en: 'Now, enter the following line in REPL:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在REPL中输入以下行：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code resembles the usage of an operator (as in Java) but is in
    fact the invocation of a method named `+` called on object `3` with the input
    parameter `2`, equivalent to the slightly less clear statement:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码类似于操作符的使用（如在Java中），但实际上是调用名为`+`的方法，该方法在对象`3`上调用，输入参数为`2`，相当于稍微不太清晰的语句：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Syntactic sugar (that is, syntax designed to make things easier to read or express)
    was added here by removing the necessity to specify the parenthesis. This also
    means that we can now implement similar methods on our own defined types to express
    code elegantly. For example, we can express the addition of two `Money` objects
    of different currencies (note that the `Money` type does not exist in the default
    Scala library) by simply stating `Money(10,"EUR") + Money(15,"USD")`. Let's try
    to do that in the REPL.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过删除指定括号的必要性，这里添加了语法糖（即设计来使事物更容易阅读或表达的语言）。这也意味着我们现在可以在自己定义的类型上实现类似的方法，以优雅地表达代码。例如，我们可以通过简单地声明`Money(10,"EUR")
    + Money(15,"USD")`来表达两种不同货币的`Money`对象的相加（注意，`Money`类型在默认的Scala库中不存在）。让我们在REPL中尝试这样做。
- en: Defining classes
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义类
- en: 'First, we can define a new class `Money` that has a constructor parameter named
    `amount` of type `Int` as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以定义一个新的名为`Money`的类，它有一个名为`amount`的构造函数参数，类型为`Int`，如下所示：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Scala has a special syntax for declaring constructor parameters that will be
    explored in more depth later.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Scala有一种特殊的语法来声明构造函数参数，这将在稍后更深入地探讨。
- en: 'Now, we can create a `Money` instance as shown in the following code snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个`Money`实例，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You get back an object with its displayed reference. The REPL provides you
    with **TAB completion**, so type `notMuch.` and hit the *Tab* key:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到一个带有其显示引用的对象。REPL为您提供了**TAB完成**功能，因此键入`notMuch.`然后按*Tab*键：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By using the preceding autocompletion, you will get suggestions of the available
    methods for that class, as you will get with most Java IDEs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用前面的自动完成，您将得到该类可用方法的建议，就像您在大多数Java IDE中会得到的那样。
- en: 'As shown previously, you can construct new instances of `Money` by invoking
    the constructor, but you do not have access to the `amount` variable since it
    is not a field. To make it a field of the `Money` class, you have to add a ''`val`''
    or ''`var`'' declaration in front of it, as shown in the following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您可以通过调用构造函数来构建新的`Money`实例，但由于它不是一个字段，您无法访问`amount`变量。要将其作为`Money`类的字段，您必须在它前面添加一个`'val'`或`'var'`声明，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This time, instead of again typing the line that created an instance, we will
    use the up arrow (the shortcut to display previous expressions: the history of
    the console) and navigate to it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不会再次输入创建实例的行，而是将使用上箭头（显示先前表达式的快捷键：控制台的历史记录）并导航到它：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *Tab* key can be pressed at any time in the REPL and provides autocompletion.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL中，您可以在任何时候按下*Tab*键，并提供自动完成功能。
- en: 'Invoking autocompletion on this new instance will display the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新实例上调用自动完成将显示以下内容：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So, we can simply read the value of the getter for this `amount` field by referring
    to it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以简单地通过引用它来读取这个`amount`字段的`getter`值：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly, if we had declared the amount to be a `var` variable instead of
    `val`, we would also have access to the `setter` method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们将金额声明为`var`变量而不是`val`，我们也将能够访问`setter`方法：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `setter` method is invoked when we use the following code snippet:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用以下代码片段时，将调用`setter`方法：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Explaining case classes
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释`case`类
- en: 'As Java developers, we are accustomed to the JavaBean style domain classes
    that not only include fields with getters and setters but also constructors as
    well as `hashCode`, `equals`, and `toString` methods, as shown in the following
    code snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Java开发者，我们习惯于JavaBean风格的领域类，这些类不仅包括具有getter和setter的字段，还包括构造函数以及`hashCode`、`equals`和`toString`方法，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Achieving this in Scala is very straightforward and only requires the addition
    of the `case` word in front of the class declaration:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中实现这一点非常简单，只需在类声明前添加`case`关键字即可：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have just defined a class `Money` with two immutable fields named `amount`
    and `currency` with default values.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义了一个名为`Money`的类，它有两个不可变的字段`amount`和`currency`，并具有默认值。
- en: Without going too much into the details of the `case` classes, we can say that
    in addition to the preceding features of a traditional JavaBean style domain class,
    they have a powerful mechanism for pattern matching. The `case` word is analogous
    to the `switch` statement in Java, though it is more flexible, as we will see
    later on. The `case` classes contain additional features among which one is a
    factory method to create instances (no need to use the `new` keyword to create
    one).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入探讨`case`类的细节，我们可以说，除了传统JavaBean风格领域类的先前特性外，它们还具有强大的模式匹配机制。`case`关键字与Java中的`switch`语句类似，尽管它更加灵活，正如我们稍后将看到的。`case`类包含一些附加功能，其中之一是工厂方法来创建实例（无需使用`new`关键字来创建实例）。
- en: 'By default, the fields declared in Scala classes are public, unlike Java, where
    they have a package-private scope, defined between private and protected. We could
    have written `case class Money(private val amount: Int, private val currency:
    String)` to make them private instead, or used `var` instead of `val` to make
    the fields mutable.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，Scala类中声明的字段是公开的，与Java不同，Java中的字段具有包私有作用域，定义在`private`和`protected`之间。我们可以将`case
    class Money(private val amount: Int, private val currency: String)`写成私有，或者使用`var`代替`val`来使字段可变。'
- en: 'The shortest way to create an instance of `Money` is very straightforward:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Money`实例的最简单方法非常直接：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the previous instance declaration, since only one parameter is given instead
    of two, the compiler matched it against the first declared field, that is, `amount`.
    Since the value `15` is of the same type as `amount` (that is, `Integer`), the
    compiler was able to populate the instance with this amount, using the default
    value `"USD"` as the currency.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的实例声明中，由于只提供了一个参数而不是两个，编译器将其与第一个声明的字段匹配，即`amount`。由于值`15`与`amount`（即`Integer`）类型相同，编译器能够使用默认值`"USD"`作为货币填充实例。
- en: 'Unlike the `amount` variable, invoking the `Money` constructor with the sole
    currency parameter will fail, as seen in the following statement:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与`amount`变量不同，仅使用货币参数调用`Money`构造函数将失败，如下面的语句所示：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code does not work because the compiler could not guess which
    parameter we were referring to, and therefore tried to match them in order of
    declaration. To be able to use the default value for `amount` with the given `"EUR"`
    string, we need to include the parameter name explicitly, as shown in the following
    code snippet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码无法工作，因为编译器无法猜测我们指的是哪个参数，因此尝试按声明顺序匹配它们。为了能够使用给定的`"EUR"`字符串的默认值`amount`，我们需要显式包含参数名称，如下面的代码片段所示：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We could therefore also mark all parameters explicitly, which can be recommended
    when there are many parameters as shown in the following code snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们还可以显式标记所有参数，这在参数很多时是推荐的，如下面的代码片段所示：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'An additional useful method when constructing instances is the `copy` method,
    which creates a new instance out of the original and eventually replaces given
    parameters:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建实例时，还有一个非常有用的方法，即`copy`方法，它从原始实例创建一个新的实例，并最终替换给定的参数：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can use the `copy` method with explicitly named parameters, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用具有显式命名参数的`copy`方法，如下所示：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `copy` method can be very useful when writing test fixtures, in particular,
    when the mockup instances to be initialized have constructors with many fields
    that are similar.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写测试用例时，`copy`方法非常有用，特别是在初始化具有许多相似字段的模拟实例时。
- en: Let's move on by creating an `addition` operation of our `Money` class. For
    simplicity, we will pretend for a moment that we only deal with amounts of the
    same currency, the default USD.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，通过创建我们的 `Money` 类的 `addition` 操作来继续。为了简单起见，我们暂时假设我们只处理相同货币的金额，即默认的 USD。
- en: 'In Java, we would probably add such a method with the following signature and
    simple content:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，我们可能会用以下签名和简单内容来添加这样的方法：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In Scala, we use the `def` keyword to define a class method or a function.
    In the REPL, we can have multiline expressions. The following `case` class declaration,
    containing the implementation of a summing method `+` is an example of such features:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，我们使用 `def` 关键字来定义类方法或函数。在 REPL 中，我们可以有多行表达式。以下 `case` 类声明，包含求和方法 `+`
    的实现，是这种特性的一个示例：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that we can use `+` as a method name. We have also included the return
    type `Money` in the signature declaration, which is only optional since the type
    inference of Scala will deduct it, but including it explicitly is a good documentation
    practice for public methods (and methods are public by default if no other scope
    is specified). Moreover, in Scala, since the `return` word at the end of the method
    is optional, the last statement is always the one that is returned to the caller
    of the method. Furthermore, it is generally considered a good practice to omit
    the `return` keyword since it is not mandatory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以使用 `+` 作为方法名。我们还在签名声明中包含了返回类型 `Money`，这虽然是可选的，因为 Scala 的类型推断会推导出它，但明确包含它是公共方法（默认情况下，如果没有指定其他作用域，方法都是公共的）的良好文档实践。此外，在
    Scala 中，由于方法末尾的 `return` 关键字是可选的，所以总是最后一个语句返回给方法的调用者。此外，通常认为省略 `return` 关键字是一个好的实践，因为它不是强制的。
- en: 'We can now write the addition of two `Money` instances with the following simple
    expression:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用以下简单的表达式来编写两个 `Money` 实例的相加操作：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Things start becoming exciting once we start manipulating collections of objects,
    and the functional programming part of Scala helps very much for that matter.
    Since generics are part of the language (Java 5 onwards), Java can, for example,
    iterate over a list of integers by writing the following code snippet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始操作对象的集合，事情就会变得有趣起来，Scala 的函数式编程部分在这方面非常有帮助。由于泛型是语言的一部分（从 Java 5 开始），Java
    可以通过编写以下代码片段来遍历整数列表：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding code produces the following output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生以下输出：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In Scala, the declaration of a list can be written as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中，列表的声明可以写成如下形式：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Scala collections systematically distinguish between immutable and mutable collections,
    but encourage immutability by constructing immutable collections by default. They
    simulate additions, updates, or removals by returning new collections from such
    operations instead of modifying them.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 集合系统地区分不可变和可变集合，但通过默认构造不可变集合来鼓励不可变性。它们通过返回新集合而不是修改现有集合来模拟添加、更新或删除操作。
- en: 'One way to print out the numbers is that we can follow Java''s imperative style
    of programming and iterate over the collection by creating a `for` loop:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 打印数字的一种方法是我们可以遵循 Java 的命令式编程风格，通过创建一个 `for` 循环来遍历集合：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Another way to write the code in Scala (as well as many other languages on
    the JVM, such as Groovy, JRuby, or Jython) involves a more functional style, using
    lambda expressions (sometimes referred to as closures). In brief, lambdas are
    just functions that you can pass around as parameters. These functions take input
    parameters (in our case, the `n` integer) and return the last statement/line of
    their body. They are in the following form:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala 中编写代码的另一种方式（以及 JVM 上的许多其他语言，如 Groovy、JRuby 或 Jython）涉及更函数式的方法，使用 lambda
    表达式（有时称为闭包）。简而言之，lambda 只是你可以传递作为参数的函数。这些函数接受输入参数（在我们的例子中，是 `n` 整数）并返回其主体中的最后一个语句/行。它们具有以下形式：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A typical example of lambda to iterate over the elements of the `numbers` list
    we have defined earlier, is given as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 lambda 示例，用于遍历我们之前定义的 `numbers` 列表中的元素，如下所示：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In that case, the body consists of only one statement (`println...`), and therefore
    returns `Unit`, that is, an empty result roughly equivalent to `void` in Java,
    except that `void` does not return anything.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，主体只包含一个语句（`println...`），因此返回 `Unit`，即一个空的结果，大致相当于 Java 中的 `void`，但 `void`
    不返回任何内容。
- en: As the time of writing this book, lambda expressions in Java are around the
    corner and will be introduced very soon as part of the JDK8 release, adopting
    a Scala-like style. Some of the functional constructs will therefore soon be available
    to Java developers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Java中的lambda表达式即将到来，并将很快作为JDK8发布的一部分被引入，采用类似Scala的风格。因此，一些函数式构造将很快对Java开发者可用。
- en: 'It should become possible to write our tiny example in the following way:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 应该可以以以下方式编写我们的小型示例：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As we stated previously, Scala collections are, by default, immutable. This
    is a very important aspect for making them behave as expected when dealing with
    multiprocessor architectures. One unique feature of the Scala collections compared
    to Java is that they include support for running operations in parallel.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所述，Scala集合默认是不可变的。这对于在多处理器架构中处理它们时按预期行为非常重要。与Java相比，Scala集合的一个独特特性是它们包括对并行运行操作的支持。
- en: Operations on collections
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合操作
- en: In this section, we are going to illustrate how the manipulation of collections
    in Scala can be expressed in a concise and expressive way.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何在Scala中以简洁和表达性的方式表达集合操作。
- en: Transforming collections containing primitive types
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换包含原始类型的集合
- en: 'The REPL is a great tool to try out the powerful operations that we can apply
    to the collection elements. Let''s go back to our interpreter prompt:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: REPL是一个伟大的工具，可以尝试我们对集合元素可以应用的有力操作。让我们回到我们的解释器提示符：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `drop` method indicates that we get rid of the first two elements of the
    list, and the `take` method indicates that we keep only three elements from the
    result obtained after the `drop` method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`drop`方法表示我们移除列表的前两个元素，而`take`方法表示我们只保留`drop`方法得到的结果中的前三个元素。'
- en: 'This last command is interesting for two reasons:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的命令有两个有趣的原因：
- en: Since every method call is evaluated to an expression, we can chain several
    method calls at once (here, `take` is invoked on the result of `drop`)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每个方法调用都会被评估为一个表达式，我们可以同时链式调用多个方法（这里，`take`是在`drop`的结果上调用的）。
- en: As already stated before, the syntactic sugar added to the Scala syntax makes
    it equivalent to write `numbers drop 2` instead of the more traditional Java `numbers.drop(2)`
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，添加到Scala语法的语法糖使得我们可以用`numbers drop 2`来代替更传统的Java写法`numbers.drop(2)`。
- en: 'Another way of writing elements in a given list is by using the `::` method,
    generally referred to in Scala documentation as the "cons operator". This alternative
    syntax looks like the following expression:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定列表中编写元素的另一种方式是使用`::`方法，在Scala文档中通常被称为“cons运算符”。这种替代语法看起来如下所示：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you are wondering why there is a `Nil` value at the end of this expression,
    this is because there is a simple rule in Scala that says that a method whose
    last character is `:` (that is, a colon) is applied on its right side rather than
    the left side (such a method is called as right-associative). So, the evaluation
    of `6 :: Nil` is not equivalent to `6.::(Nil)` in that case, but rather `Nil.::(6)`.
    We can exhibit that into the REPL as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你想知道为什么这个表达式的末尾有一个`Nil`值，这是因为Scala中有一个简单的规则，即如果一个方法的最后一个字符是`:`（即冒号），则该方法应用于其右侧而不是左侧（这样的方法称为右结合）。因此，`6
    :: Nil`的评估在这种情况下并不等同于`6.::(Nil)`，而是`Nil.::(6)`。我们可以在REPL中展示如下：'
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The evaluation of `5 :: 6 :: Nil` is therefore done by applying the `::` method
    on the `simpleList` that we saw earlier, which is `List(6)`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`5 :: 6 :: Nil`的评估是通过在之前看到的`simpleList`上应用`::`方法来完成的，该方法是`List(6)`：'
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this case, `5` was appended before `6`. Repeating this operation several
    times will give you the final `List(1,2,3,4,5,6)`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`5`被添加到`6`之前。重复此操作几次将得到最终的`List(1,2,3,4,5,6)`。
- en: 'This convenient way of expressing lists is not just for simple values such
    as integers but can be applied to any type. Moreover, we can concatenate two `List`
    instances by using the `:::` method in a similar way:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方便的表达列表的方式不仅适用于简单的值，如整数，而且可以应用于任何类型。此外，我们可以通过使用`:::`方法以类似的方式连接两个`List`实例：
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can even mix elements of various types in the same `List`, for example,
    integers and Booleans, as shown in the following code snippet:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在同一个`List`中混合各种类型的元素，例如整数和布尔值，如下面的代码片段所示：
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'However, as you probably noticed, the result type `AnyVal` chosen by the compiler
    in that case is the first common type between integers and Booleans encountered
    in their hierarchy. For instance, retrieving only the Boolean element (at index
    two in the list) will return an element of type `AnyVal` rather than a `Boolean`
    value:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你可能注意到的，编译器在那个情况下选择的`AnyVal`结果类型是整数和布尔值在它们的层次结构中遇到的第一个公共类型。例如，仅检索布尔元素（在列表中的索引为二）将返回`AnyVal`类型的元素，而不是布尔值：
- en: '[PRE45]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, if we put an element of type `String` within the list as well, we will
    get a different common type:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们把一个`String`类型的元素也放入列表中，我们将得到一个不同的公共类型：
- en: '[PRE46]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The reason for that can be directly visualized by looking at the hierarchy
    of Scala types. Classes representing primitive types such as `Int`, `Byte`, `Boolean`,
    or `Char` belong to value types of `scala.AnyVal,` whereas `String`, `Vector`,
    `List`, or `Set` belong to reference types of `scala.AnyRef`, both being subclasses
    of the common type `Any`, as shown in the following diagram:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过查看Scala类型的层次结构来直接可视化。表示原始类型（如`Int`、`Byte`、`Boolean`或`Char`）的类属于`scala.AnyVal`的值类型，而`String`、`Vector`、`List`或`Set`属于`scala.AnyRef`的引用类型，两者都是通用类型`Any`的子类，如下面的图所示：
- en: '![Transforming collections containing primitive types](img/3637_01_02.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![包含原始类型集合的转换](img/3637_01_02.jpg)'
- en: The full hierarchy of Scala types is given in the official Scala documentation
    at [http://docs.scala-lang.org/tutorials/tour/unified-types.html](http://docs.scala-lang.org/tutorials/tour/unified-types.html).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Scala类型的完整层次结构可以在官方Scala文档中找到，网址为[http://docs.scala-lang.org/tutorials/tour/unified-types.html](http://docs.scala-lang.org/tutorials/tour/unified-types.html)。
- en: Collections of more complex objects
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更复杂的对象集合
- en: 'Let''s manipulate objects that are more complex than integers. We can, for
    instance, create some collections of `Money` instances that we made earlier and
    experiment with them:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们操作比整数更复杂的对象。例如，我们可以创建一些我们之前创建的`Money`实例的集合，并实验它们：
- en: '[PRE47]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Filter and partition
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤和分区
- en: 'Filtering elements of a collection is one of the most common operations and
    can be written as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤集合中的元素是最常见的操作之一，可以写成以下形式：
- en: '[PRE48]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The parameter given to the `filter` method is a function that takes a `Money`
    item as the input and returns a `Boolean` value (that is, a predicate), which
    is the result of evaluating `money.currency=="EUR"`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`filter`方法的参数是一个函数，它接受一个`Money`项作为输入并返回一个`Boolean`值（即谓词），这是评估`money.currency=="EUR"`的结果。
- en: 'The `filter` method iterates over the collection items and applies the function
    to each element, keeping only the elements for which the function returns `True`.
    Lambda expressions are also referred to as **anonymous functions** because we
    could give any name we want to the input argument, for example, `x` instead of
    the `money` used previously, and still get the same output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`方法遍历集合项并对每个元素应用函数，只保留函数返回`True`的元素。Lambda表达式也被称为**匿名函数**，因为我们可以为输入参数赋予任何我们想要的名称，例如，用`x`代替之前使用的`money`，仍然得到相同的输出：'
- en: '[PRE49]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'A slightly shorter way of writing this one-liner can be done using an `_` sign,
    a character that one encounters often when reading Scala code and that might seem
    awkward for a Java developer at first sight. It simply means "that thing", or
    "the current element". It can be thought of as the blank space or gap used to
    fill paper-based inquiries or passport registration forms, in the olden days.
    Other languages that deal with anonymous functions reserve other keywords, such
    as `it` in Groovy, or `self` in Python. The previous lambda example can be rewritten
    with the short underscore notation as the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 写这个单行语句的一个稍微简短的方法是使用一个`_`符号，这是在阅读Scala代码时经常遇到的一个字符，对于Java开发者来说可能一开始看起来有些不自然。它简单地意味着“那个东西”，或者“当前元素”。它可以被视为过去用来填充纸质调查或护照登记表格的空白空间或间隙。其他处理匿名函数的语言保留其他关键字，例如Groovy中的`it`或Python中的`self`。之前的lambda示例可以用简短的下划线符号重写如下：
- en: '[PRE50]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A `filterNot` method also exists to keep elements for which the evaluation
    of the function returns `False`. Moreover, a `partition` method is available to
    combine both the `filter` and `filterNot` methods into one single call that returns
    two collections, one evaluating to `True` and the other to its complement, as
    shown in the following code snippet:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在一个`filterNot`方法，用于保留函数评估返回`False`的元素。此外，还有一个`partition`方法可以将`filter`和`filterNot`方法组合成一个单一调用，返回两个集合，一个评估为`True`，另一个为其补集，如下面的代码片段所示：
- en: '[PRE51]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Dealing with tuples
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理元组
- en: 'Notice the return type of the partition result, `(List[Money],List[Money])`.
    Scala supports the concept of tuples. The preceding parenthesis notation denotes
    a `Tuple` type, which is a part of the standard Scala library and useful to manipulate
    several elements at once without having to create a more complex type for encapsulating
    them. In our case, `allAmounts` is a `Tuple2` pair containing two lists of `Money`.
    To access only one of the two collections, we just need to type the following
    expressions:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到分区结果的返回类型，`(List[Money],List[Money])`。Scala支持元组的概念。前面的括号表示法表示一个`Tuple`类型，它是Scala标准库的一部分，并且对于同时操作多个元素非常有用，而无需创建更复杂的类型来封装它们。在我们的例子中，`allAmounts`是一个包含两个`Money`列表的`Tuple2`对。要访问这两个集合中的任意一个，我们只需输入以下表达式：
- en: '[PRE52]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'A cleaner and more natural syntax to achieve this as a one-liner, is the one
    that expresses the `partition` method without referring to `._1` and `._2`, as
    shown in the following code snippet:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要以一行代码的形式实现这一点，并且更加简洁和自然，可以使用不引用`._1`和`._2`的`partition`方法，如下代码片段所示：
- en: '[PRE53]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This time, as a result, we get two variables, `euros` and `everythingButEuros`,
    which we can reuse individually:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，作为结果，我们得到了两个变量，`euros`和`everythingButEuros`，我们可以分别重用它们：
- en: '[PRE54]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Introducing Map
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引入Map
- en: 'Another elegant usage of tuples is related to the definition of a `Map` collection,
    another structure that is part of the Scala collections. Similar to Java, the
    `Map` collection stores key-value pairs. In Java, a trivial `HashMap` definition
    that populates and retrieves elements of a `Map` collection with a couple of values
    can be written with a few lines of code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的另一种优雅用法与`Map`集合的定义有关，`Map`集合是Scala集合的一部分。类似于Java，`Map`集合存储键值对。在Java中，一个简单的`HashMap`定义，用几行代码填充和检索`Map`集合的元素，可以写成如下：
- en: '[PRE55]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Since no amount of GBP currency has been inserted into the `Map` collection,
    running this sample will return a `null` value for the `Pounds` variable:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有将GBP货币的金额插入到`Map`集合中，运行此示例将为`Pounds`变量返回一个`null`值：
- en: '[PRE56]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Populating a `Map` collection in Scala can be elegantly written as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中填充`Map`集合可以优雅地写成如下形式：
- en: '[PRE57]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `"USD" -> 10` expression is a convenient way of specifying a key-value
    pair and is equivalent to the definition of a `Tuple2[String,Integer]` object
    in this case, as illustrated directly in the REPL (which could infer the type
    automatically):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`"USD" -> 10`表达式是一种方便的方式来指定键值对，在这种情况下，它与在REPL中直接定义的`Tuple2[String,Integer]`对象等价（REPL可以直接推断类型）：'
- en: '[PRE58]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The process of adding and retrieving an element is very straightforward:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 添加和检索元素的过程非常直接：
- en: '[PRE59]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'However, accessing an element that is not included in the `Map` collection
    will throw an exception, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，访问`Map`集合中未包含的元素将抛出异常，如下所示：
- en: '[PRE60]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Introducing the Option construct
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引入Option构造
- en: 'A safer way to retrieve an element from the `Map` collection that was introduced
    in the previous section is to invoke its `.get()` method, which will instead return
    an object of type `Option`, a feature that is not currently available in Java.
    Basically, an `Option` type wraps a value into an object that can either return
    the type `None` if the value is null, or `Some(value)` otherwise. Let''s enter
    this in the REPL:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一节中引入的`Map`集合中安全地检索元素的一种方法是通过调用其`.get()`方法，这将返回一个类型为`Option`的对象，而Java目前还没有这个特性。基本上，`Option`类型将一个值封装到一个对象中，如果该值为null，则返回`None`类型，否则返回`Some(value)`。让我们在REPL中输入以下内容：
- en: '[PRE61]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: A glimpse at pattern matching
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式匹配的简要介绍
- en: 'Avoiding the throwing of an exception makes it convenient to continue handling
    the flow of an algorithm as an evaluated expression. It not only gives the programmer
    the freedom of sophisticated chaining of the `Option` values without having to
    check for the existence of a value, but also enables one to handle the two different
    cases via **pattern matching**:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 避免抛出异常使得将算法的流程作为一个评估表达式继续处理变得方便。这不仅给程序员提供了在无需检查值是否存在的情况下，对`Option`值进行复杂链式操作的自由，而且还使得可以通过**模式匹配**来处理两种不同的情形：
- en: '[PRE62]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Pattern matching is an essential and powerful feature of the Scala language.
    We will look at more examples of it later on.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是Scala语言的一个基本且强大的特性。我们稍后会看到更多关于它的例子。
- en: The `filter` and `partition` methods were just two examples of the so-called
    "higher-order" functions on lists, since they operate on containers of collection
    types (such as lists, sets, and so on) rather than the types themselves.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`和`partition`方法只是列表上所谓的“高阶函数”的两个例子，因为它们操作的是集合类型的容器（如列表、集合等），而不是类型本身。'
- en: The map method
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`map`方法'
- en: 'Among the collections'' methods that cannot be overlooked lies the `map` method
    (not to be confused with the `Map` object). Basically, it applies a function to
    every element of a collection, but instead of returning `Unit` for the `foreach`
    method, it returns a collection of a similar container type (for example, a `List`
    will return a `List` of the same size) that contains the result of transforming
    each element through the function. A very simple example is shown in the following
    code snippet:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合的方法中，不能忽视的是`map`方法（不要与`Map`对象混淆）。基本上，它将一个函数应用于集合的每个元素，但与`foreach`方法返回`Unit`不同，它返回一个类似容器类型的集合（例如，一个`List`将返回一个大小相同的`List`），其中包含通过函数转换每个元素的结果。以下是一个简单的示例代码片段：
- en: '[PRE63]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In Scala, you may define standalone functions as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，你可以如下定义独立的函数：
- en: '[PRE64]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We have declared an `increment` function that takes an `Int` value as the input
    (denoted by `x`) and returns another `Int` value (`x+1`).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经声明了一个`increment`函数，它接受一个`Int`类型的输入值（用`x`表示）并返回另一个`Int`类型的值（`x+1`）。
- en: 'The previous `List` transformation can be rewritten slightly in a different
    manner as shown in the following code snippet:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的`List`转换可以稍微以不同的方式重写，如下面的代码片段所示：
- en: '[PRE65]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Using a bit of syntactic sugar, the `.` sign in the method call, as well as
    the parenthesis on the function parameter can be omitted for readability, which
    leads to the following concise one-liner:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一点语法糖，方法调用中的`.`符号以及函数参数上的括号可以省略以提高可读性，这导致以下简洁的一行代码：
- en: '[PRE66]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Going back to our initial list of the `Money` amounts, we can, for example,
    transform them into strings as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们最初的`Money`金额列表，例如，我们可以将它们转换为字符串如下：
- en: '[PRE67]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Looking at String Interpolation
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 看一下字符串插值
- en: 'In Java, concatenating strings using a `+` operator, as we did in the previous
    line, is a very common operation. In Scala, a more elegant and efficient way to
    deal with the presentation of strings is a feature named **String Interpolation**.
    Available since Scala Version 2.10, the new syntax involves prepending a `s` character
    to the string literal as shown in the following code snippet:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，使用`+`运算符连接字符串，就像我们在上一行所做的那样，是一个非常常见的操作。在Scala中，处理字符串表示的一种更优雅且高效的方法是名为**字符串插值**的功能。自Scala版本2.10起，新的语法涉及在字符串字面量前添加一个`s`字符，如下面的代码片段所示：
- en: '[PRE68]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Any variable in scope can be processed and embedded in a string. Formatting
    can even be more precise by using an `f` interpolator instead of `s`. In that
    case, the syntax follows the same style as that of the `printf` method of other
    languages, where, for instance, `%4d` means a four-digit formatting or `%12.2f`
    means a floating point notation with exactly twelve digits before the comma and
    two afterwards:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域内的任何变量都可以被处理并嵌入到字符串中。使用`f`插值器而不是`s`可以更精确地进行格式化。在这种情况下，语法遵循与其他语言中`printf`方法相同的风格，例如，`%4d`表示四位数的格式化，`%12.2f`表示小数点前有十二位数字，后有两位数字的浮点数表示法：
- en: '[PRE69]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Moreover, the String Interpolation syntax enables us to embed the full evaluation
    of an expression, that is, a full block of code performing a calculation. The
    following is an example, where we want to display the value of our `many` variable
    twice:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，字符串插值语法使我们能够嵌入表达式的完整评估，即执行计算的完整代码块。以下是一个示例，其中我们想显示`many`变量的值两次：
- en: '[PRE70]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The preceding block of code obeys the same rules as any method or function evaluation,
    meaning that the last statement in the block is the result. Although here we have
    a very simple computation, it is perfectly valid to include a multiline algorithm
    if needed.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块遵循与任何方法或函数评估相同的规则，这意味着该块中的最后一个语句是结果。尽管这里我们有一个非常简单的计算，但如果需要，也可以包含多行算法。
- en: 'Knowing the interpolation syntax, we can rewrite our previous `amounts` as
    follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 了解插值语法后，我们可以将之前的`amounts`重写如下：
- en: '[PRE71]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The groupBy method
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`groupBy`方法'
- en: 'Another convenient operation is the `groupBy` method that transforms a collection
    into a `Map` collection:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方便的操作是`groupBy`方法，它将一个集合转换为一个`Map`类型的集合：
- en: '[PRE72]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The foldLeft method
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`foldLeft`方法'
- en: 'One last method that we would like to introduce here is the `foldLeft` method,
    which propagates some state from one element to the next. For instance, to sum
    elements in a list, you need to accumulate them and keep track of the intermediate
    counter from one element to the next:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里想介绍的最后一种方法是`foldLeft`方法，它将一些状态从一个元素传播到下一个元素。例如，为了对列表中的元素进行求和，你需要累积它们并跟踪从元素到元素的中间计数器：
- en: '[PRE73]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The value `0` given as the first argument to `foldLeft` is the initial value
    (which means `total=0` when applying the function for the first `List` element).
    The `(total,element)` notation represents a `Tuple2` pair. Note, however, that
    for summation, the Scala API provides a `sum` method, so the last statement could
    have been written as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 给定给`foldLeft`的第一个参数的值`0`是初始值（这意味着在应用函数的第一个`List`元素时`total=0`）。`(total,element)`表示一个`Tuple2`对。然而，请注意，对于求和，Scala
    API提供了一个`sum`方法，因此最后的语句可以写成如下所示：
- en: '[PRE74]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This interactive chapter that introduced some of the commonly used operations
    on objects and collections was only a glimpse to demonstrate some of the expressiveness
    and powerful constructs of Scala.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这章交互式章节介绍了对象和集合的一些常用操作，这只是为了展示Scala的一些表达性和强大的构造。
- en: In the next chapter, we are going to increasingly blend Scala with an existing
    standard Java web application. Since there are so many ways by which one can create
    a standard web application, combining some of the many frameworks and database
    technologies available, irrespective of whether they involve Spring, Hibernate,
    JPA, SQL, or NoSQL, we will take the straightforward path of some of the well-established
    JavaEE tutorials.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将越来越多地将Scala与现有的标准Java Web应用程序相结合。由于有这么多创建标准Web应用程序的方法，结合许多可用的框架和数据库技术，无论它们是否涉及Spring、Hibernate、JPA、SQL还是NoSQL，我们将采取一些已建立的JavaEE教程的简单路径。
