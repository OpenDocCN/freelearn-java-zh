- en: Software Architecture Dimensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件架构维度
- en: In the previous chapter, you learned that a software's architecture is made
    up of a team's shared knowledge when building a product or service, as well as
    other important aspects surrounding this concept. An architect's job is to share
    this knowledge with the entire team. Even when a team doesn't have somebody assigned
    to the specific role of the architect, individuals often end up becoming responsible
    for the system's architecture.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您了解到软件架构是团队在构建产品或服务时的共享知识，以及围绕这一概念的其他重要方面。架构师的工作是与整个团队分享这些知识。即使团队没有专门的架构师，个人通常最终会成为系统架构的负责人。
- en: In this chapter, we will review software architecture dimensions and how they
    influence our applications. We will also introduce a model for documenting software
    architectures and making the process of sharing and understanding an architecture
    less difficult for teams. Ultimately, this will allow them to understand the bigger
    picture of software architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将审查软件架构维度以及它们如何影响我们的应用程序。我们还将介绍一种用于记录软件架构并使团队更容易共享和理解架构的模型。最终，这将使他们能够理解软件架构的整体情况。
- en: 'This chapter will cover the following topics and subtopics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题和子主题：
- en: 'Software architecture dimensions:'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件架构维度：
- en: Business dimension
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务维度
- en: Data dimension
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据维度
- en: Technical dimension
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术维度
- en: Operations dimension
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作维度
- en: 'The C4 model:'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C4模型：
- en: Context diagram
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文图
- en: Container diagram
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器图
- en: Components diagram
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件图
- en: Class diagram
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类图
- en: Dimensions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维度
- en: 'According to Google, the word *dimension* has a few meanings. Let''s use the
    following definition, which fits into the context that we will discuss in this
    section:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据谷歌的说法，“维度”一词有几个含义。让我们使用以下定义，它适用于我们将在本节讨论的上下文中：
- en: '"An aspect or feature of a situation, problem, or thing."'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: “情况、问题或事物的一个方面或特征。”
- en: Starting with this definition, we will consider dimensions as the aspects or
    features that will influence and guide the software architectures that we build.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个定义开始，我们将把维度视为影响和指导我们构建的软件架构的方面或特征。
- en: In the previous chapter, we talked about the importance of understanding the
    business domain when crafting our solutions. Of course, this knowledge is not
    enough when it comes to generating a system that is able to address all business
    needs. You will also need to think about the mechanisms for supporting these solutions
    from a technical viewpoint, without forgetting the business requirements. As technical
    people, we need to provide a solution that can evolve with the passage of time,
    in order to accomplish new business needs and efficiently achieve goals.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们谈到了在制定解决方案时理解业务领域的重要性。当然，当生成能够满足所有业务需求的系统时，这种知识是不够的。您还需要考虑从技术角度支持这些解决方案的机制，同时不要忘记业务需求。作为技术人员，我们需要提供一个能够随着时间推移而发展的解决方案，以满足新的业务需求并有效实现目标。
- en: 'The following list is comprised of the most common dimensions in the process
    of crafting a software architecture:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包括在制定软件架构过程中最常见的维度：
- en: Business
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务
- en: Data
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据
- en: Technical
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术
- en: Operations
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作
- en: Depending on the context of the solution that you are working on, you can add
    some extra points to this list. These four dimensions are highly connected when
    you are looking at a product from a technical viewpoint, and they should be understood
    by the whole team in charge of the system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您正在处理的解决方案的上下文，您可以向此列表添加一些额外的要点。当您从技术角度查看产品时，这四个维度在很大程度上是相互关联的，并且应该被负责系统的整个团队理解。
- en: The business dimension
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务维度
- en: 'This is the most crucial aspect to consider when we are building software,
    and that''s why the software industry has been inventing new ways to collect requirements.
    Within this dimension, two relevant activities should be accomplished efficiently,
    as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们构建软件时最关键的方面，这就是为什么软件行业一直在发明新的方法来收集需求。在这个维度内，应该有效地完成两项相关活动，如下所示：
- en: Managing user requirements and gaining a clear idea about the domain model of
    the business
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理用户需求并清晰了解业务领域模型
- en: Identifying and tracking business metrics
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别和跟踪业务指标
- en: Managing user requirements
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理用户需求
- en: Some years ago, we used to write use cases, which have been renamed as **user
    stories** in the last few years. However, the names are not the key to success
    here, and it makes no difference whether you are using old-fashioned methods (such
    as the **Ration Unified Process** (**RUP**) or the most cutting-edge frameworks
    (such as Scrum) to build your projects. Understanding the domain of the business
    and owning a product will allow teams to develop successful projects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，我们习惯于编写用例，最近几年已经改名为“用户故事”。然而，这里的关键并不在于名称，无论您使用老式方法（如Ration Unified Process（RUP））还是最前沿的框架（如Scrum）来构建项目，都没有关系。了解业务领域并拥有产品将使团队能够开发成功的项目。
- en: As you probably know, RUP is a software development framework that defines a
    set of phases and has a tremendous amount of documentation associated with each
    stage. The idea here is to determine what artifacts to generate at each stage.
    This task is tedious, and teams have often ended up defining a large quantity
    of useless and time-consuming documentation, without providing any added value
    to the product. As an alternative to creating documentation, we will discuss the
    C4 model later in this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道，RUP是一个软件开发框架，定义了一系列阶段，并且每个阶段都有大量的文档。这里的想法是确定在每个阶段生成什么样的文档。这项任务很繁琐，团队经常会定义大量无用且耗时的文档，而没有为产品提供任何附加值。作为创建文档的替代方案，我们将在本章后面讨论C4模型。
- en: Over time, many books have been written to explain how to manage user requirements.
    Two of these include *Writing Effective Use Cases* by Alistair Cockburn and *User
    Stories Applied* by Mike Cohn. These books are the most relevant, and you should
    consider reading them and making them a part of your library, in order to use
    them as a reference source whenever necessary.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，已经有很多书籍介绍了如何管理用户需求。其中两本是Alistair Cockburn的《编写有效的用例》和Mike Cohn的《用户故事应用》。这些书是最相关的，您应该考虑阅读并将它们作为您的图书馆的一部分，以便在必要时用作参考来源。
- en: An efficient process for gathering user requirements should be a part of the
    vision and the goals that the project should accomplish. Having brainstorming
    meetings with as many people involved in the project as possible is beneficial
    for allowing the team in charge of the software implementation to distinguish
    between the **Minimum Viable Product** (**MVP**) and the desired and expendable
    features that will be implemented as part of a new release once the MVP version
    has been accomplished.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 高效地收集用户需求的过程应该是项目愿景和目标的一部分。与尽可能多参与项目的人进行头脑风暴会有利于让负责软件实施的团队区分“最小可行产品”（MVP）和期望的可有可无的功能，这些功能将作为新版本的一部分在MVP版本完成后实施。
- en: Understanding the MVP for the software under construction is paramount; it should
    give you the minimum features possible to satisfy the user requirements. Once
    these features are identified, it is also necessary to define the acceptance criteria
    for them. The products built from here will be used as the base for retrieving
    feedback from the business people (in order to correct any misconceptions) and
    also to add new features (in order to grow the solution).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 了解正在构建的软件的MVP至关重要；它应该为您提供满足用户需求的最少功能。一旦确定了这些功能，还需要为其定义验收标准。从这里构建的产品将用作从业务人员那里获取反馈（以纠正任何误解）的基础，并且还将用于添加新功能（以扩展解决方案）。
- en: Today, we also count on bug tracking systems to write user requirements as tickets
    with different classifications, such as bugs, user stories, and spikes, among
    others. These tickets are used to gain a better understanding of how long a feature
    takes to be implemented, and how many bugs are involved in it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们还依靠缺陷跟踪系统将用户需求编写为具有不同分类的工单，例如缺陷、用户故事和突发事件等。这些工单用于更好地了解实施一个功能需要多长时间，以及涉及多少缺陷。
- en: Dealing with business requirements in this way gives us useful information that
    can be analyzed later, in order to improve the performance of a team, as well
    as the way it is organized. There are a bunch of explanations of how to manage
    tickets, but if you want a better idea of the principles of bug tracking, I encourage
    you to read a useful article written by Yegor Bugayenko, which is available at [http://www.yegor256.com/2014/11/24/principles-of-bug-tracking.html](http://www.yegor256.com/2014/11/24/principles-of-bug-tracking.html).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式处理业务需求为我们提供了有用的信息，可以在以后进行分析，以改进团队的绩效以及其组织方式。有很多关于如何管理工单的解释，但如果您想更好地了解缺陷跟踪的原则，我鼓励您阅读Yegor
    Bugayenko撰写的一篇有用的文章，该文章可在[http://www.yegor256.com/2014/11/24/principles-of-bug-tracking.html](http://www.yegor256.com/2014/11/24/principles-of-bug-tracking.html)上找到。
- en: Identifying and tracking business metrics
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别和跟踪业务指标
- en: Once the business requirements have been collected, another part of the business
    dimension emerges, including a way to identify the essential metrics around the
    business problems that you're solving. These metrics should be determined and
    expressed concerning the business domain, in order to understand how well an application
    addresses the business requirements that it was designed for.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 收集了业务需求之后，业务维度的另一部分出现了，其中包括一种识别解决的业务问题周围的基本指标的方法。这些指标应该根据业务领域确定并表达，以便了解应用程序如何满足其设计的业务需求。
- en: Let's revisit an example that we used in the previous chapter. Suppose that
    the bank is currently using the post office to send monthly bank statements to
    its clients. In this case, you know a priori, how much money it costs, and the
    tasks involved in accomplishing the goal. In addition, you even know how many
    clients you have and how much paper should be printed, according to specific dates.
    After the implementation of your system, you will want to know that all of your
    clients are receiving their bank statements. Consequently, you will want to implement
    a mechanism to identify how many bank statements are being sent by the application,
    and which notification channels are preferred. This information will be used in
    the near future, in order to identify new business opportunities, discover when
    the system has problems, and monitor the ROI of the application. After all, the
    implementation of a system is guided by a business's needs, and you have to verify
    that those needs are met.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视前一章中使用的一个例子。假设银行目前正在使用邮局向客户发送每月的银行对账单。在这种情况下，您预先知道成本和实现目标所涉及的任务。此外，您甚至知道您有多少客户以及根据特定日期应该打印多少纸张。在系统实施后，您将希望知道所有客户是否都收到了他们的银行对账单。因此，您将希望实施一种机制来识别应用程序发送了多少银行对账单，以及哪种通知渠道更受欢迎。这些信息将在不久的将来用于识别新的商机，发现系统存在问题的时间，并监控应用程序的投资回报率。毕竟，系统的实施是由企业需求引导的，您必须验证这些需求是否得到满足。
- en: Once the application is in production, an excellent technique for assessing
    the business health of your application in the wild is to build bots. These bots
    exercise your application as a regular user; you'll want to at least create bots
    around the most important functionalities of your application. If not, how will
    you know if your application is working?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序投入生产，评估应用程序在实际环境中的业务健康状况的一个绝佳技术是构建机器人。这些机器人会像普通用户一样使用您的应用程序；您至少应该围绕应用程序最重要的功能创建机器人。否则，您如何知道您的应用程序是否正常工作呢？
- en: This goal can be achieved by executing scheduled checks that will send you notifications
    with the obtained results. This simple technique will give you confidence that
    the application is working as expected, and is providing a service to your clients—who
    are the purpose of the system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行定期检查来实现这个目标，这些检查将向您发送通知并提供获得的结果。这种简单的技术将让您确信应用程序正在按预期工作，并为您的客户提供服务——他们是系统的目的。
- en: The data dimension
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据维度
- en: Data is considered one of the most critical assets of any business, and that
    is why you have to invest a considerable amount of time in figuring out the best
    approach for dealing with it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 数据被认为是任何业务中最关键的资产之一，这就是为什么你必须投入大量时间来找出处理它的最佳方法。
- en: 'Nowadays, we have many options when it comes to choosing our approach to data.
    In the last few years, many kinds of databases and data storage have been created,
    including the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，在选择我们的数据处理方法时，我们有很多选择。在过去几年里，许多种数据库和数据存储已经被创建，包括以下内容：
- en: File cloud storage
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件云存储
- en: Relational databases
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系数据库
- en: Document-oriented databases
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向文档的数据库
- en: Real-time databases
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时数据库
- en: Graph databases
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图数据库
- en: In-memory databases
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存数据库
- en: Your choice should depend on the problem that you're solving, and not on the
    option used by influential online companies, such as Facebook, Google, and Amazon.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你的选择应该取决于你要解决的问题，而不是取决于像Facebook、Google和Amazon这样有影响力的在线公司所使用的选项。
- en: Remember that different business requirements require different methods of approach.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，不同的业务需求需要不同的方法。
- en: You may now be wondering what kind of data storage you should choose*.* The
    most common answer to that question is that it depends on the context.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能想知道应该选择什么样的数据存储。对这个问题最常见的答案是，这取决于上下文。
- en: 'However, a dependence on the context may not be the ideal answer here, as it
    does not provide you with much guidance. With this in mind, the best advice that
    can be given is to try to make as many analogies as you can, in order to figure
    out the best data storage method for you. One consideration to bear in mind is
    this: don''t get scared because of the eventual consistency inherent in NoSQL
    databases. I have seen a lot of people get rid of this kind of database for that
    reason. You have to understand that eventual consistency is not a technical concern
    at all, but a business one. Let me explain why.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，依赖于上下文可能不是理想的答案，因为它并没有提供太多指导。考虑到这一点，可以给出的最佳建议是尽量多地进行类比，以找出最佳的数据存储方法。要记住的一点是：不要因为NoSQL数据库固有的最终一致性而感到害怕。我见过很多人因为这个原因而放弃这种类型的数据库。你必须明白，最终一致性根本不是技术问题，而是业务问题。让我解释一下为什么。
- en: 'Considering the example presented in [Chapter 1](21088489-d3dd-4c4d-8969-ac7ec0844132.xhtml),
    *Software Architecture Today*, assume that you have been tasked with implementing
    a new feature in a system with the following description:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[第1章](21088489-d3dd-4c4d-8969-ac7ec0844132.xhtml)中提到的例子，《今日软件架构》，假设你被要求在一个具有以下描述的系统中实现一个新功能：
- en: '"We noticed that the notification channels do not always work as expected,
    and we decided to use an alternative channel when this happens. For example, if
    the user has configured the email as the preferred channel, then the SMS channel
    should be used if it fails. On the other hand, if the user has configured SMS
    as the preferred notification channel, the email notification should be used as
    an alternative if it fails."'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们注意到通知渠道并不总是按预期工作，所以我们决定在这种情况下使用备用渠道。例如，如果用户将电子邮件配置为首选渠道，那么如果失败，应该使用短信渠道。另一方面，如果用户将短信配置为首选通知渠道，那么如果失败，应该使用电子邮件通知作为备用。"'
- en: 'Notice that this requirement doesn''t follow the standard user story format:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个要求不符合标准的用户故事格式：
- en: '"As a < type of user >, I want < a goal > so that < reason >..."'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '"作为<用户类型>，我希望<目标>，以便<原因>..."'
- en: However, the requirements are easy to understand and implement for the team
    in charge of working on them. For that reason, I mentioned earlier that even if
    you're still working with use cases or user stories, the matter of business requirements
    is the most important aspect.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于负责处理它们的团队来说，这些要求很容易理解和实现。因此，我之前提到，即使你仍在处理用例或用户故事，业务需求也是最重要的方面。
- en: An example of where eventual consistency is not a big deal is with the ordering
    of Facebook posts, in which each post is timestamped. Here, when a person adds
    a comment to a post, they think that they are seeing the last comment above theirs,
    but a few seconds later, they see that other comments did, indeed, get added before
    their comment. When this happens, it can be confusing. However, not imposing atomicity
    requirements on the comment order allows Facebook to scale the database globally,
    covering millions of posts per second. In contrast, it is important that a money
    transferring transaction require atomic transactions, in order to maintain consistency
    and avoid fraud or wasting money.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不需要最终一致性的例子是Facebook帖子的排序，其中每个帖子都有时间戳。在这里，当一个人给帖子添加评论时，他们认为他们看到的是他们上面的最后一条评论，但几秒钟后，他们会看到其他评论确实在他们的评论之前添加了。当这种情况发生时，可能会令人困惑。然而，不对评论顺序施加原子性要求允许Facebook全球扩展数据库，每秒覆盖数百万帖子。相比之下，对于转账交易，需要原子事务以保持一致性，避免欺诈或浪费金钱。
- en: In summary, you first have to understand the business requirement that you want
    to accomplish, make as many analogies as you can with the options available on
    the market, and then, make your choice from those options. Once your decision
    has been made, it's always worth counting on frameworks that will allow you to
    interact with the data storage of your choice. Fortunately, Spring Data supports
    a bunch of data storage options. We will discuss the benefits of using this Spring
    project in the next chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，你首先必须了解你想要完成的业务需求，尽可能多地将其与市场上可用的选项进行类比，然后从这些选项中做出选择。一旦你做出了决定，就值得依靠框架来让你与你选择的数据存储进行交互。幸运的是，Spring
    Data支持大量的数据存储选项。我们将在下一章讨论使用这个Spring项目的好处。
- en: The technical dimension
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术维度
- en: 'This dimension involves deeply exploring technical details. Let''s discuss
    some useful questions that you will have to answer in order to accomplish this
    goal, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这一维度涉及深入探讨技术细节。让我们讨论一些有用的问题，你将不得不回答以实现这个目标，如下：
- en: What style of software architecture should I choose?
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该选择什么样的软件架构风格？
- en: Currently, there are many options for this. Subsequent chapters of this book
    will explain many of them in detail, and you'll probably find your answers there.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有很多选择。本书的后续章节将详细解释其中的许多选择，你可能会在那里找到答案。
- en: What programming language is right for my application?
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪种编程语言适合我的应用程序？
- en: Many programming languages in the market promise to be the best. For that reason,
    you have to avoid choosing one just because it's the newest or the latest one.
    Instead, you must choose a widely known one that suits you.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有许多编程语言承诺是最好的。因此，你必须避免仅仅因为它是最新的或最新的而选择一个。相反，你必须选择一个广为人知的适合你的。
- en: The possibility of counting on a vast ecosystem of tooling is always essential,
    and should be part of your decision. Another part of your decision should be how
    difficult it is to find people to work with. It is unlikely that you will want
    to build your software using a programming language that not many people are familiar
    with. After all, you'll want to create an application that will live for a long
    time, and this implies that many people will be involved in writing code to make
    it evolve over time.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 依靠庞大的工具生态系统始终是必要的，并且应该成为你决策的一部分。你决策的另一部分应该是找到合作伙伴的难度。你不太可能想要使用不太熟悉的编程语言来构建你的软件。毕竟，你希望创建一个长期存在的应用程序，这意味着许多人将参与编写代码，使其随着时间的推移而发展。
- en: Since this book is intended to be focused on the Spring platform, I'll be discussing
    the benefits of using Java and the **Java Virtual Machine** (**JVM**).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这本书的重点是Spring平台，我将讨论使用Java和Java虚拟机（JVM）的好处。
- en: We all know that Java is a widely supported programming language that has been
    used to build tons of enterprise applications; this fact gives us the confidence
    to say that it's mature enough to write almost any kind of enterprise software.
    On the other hand, the JVM is built on the premise of *write once, run anywhere.*
    This is important, because a significant part of enterprise applications are currently
    running on Linux servers; however, this doesn't mean that you need to force your
    team to use Linux. Instead, they can keep using their preferred OS, since the
    JVM can run on Windows, Linux, and Mac.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道Java是一种得到广泛支持的编程语言，已经被用来构建大量的企业应用程序；这个事实让我们有信心说它已经足够成熟，可以编写几乎任何类型的企业软件。另一方面，JVM建立在“一次编写，到处运行”的前提下。这一点很重要，因为目前有相当一部分企业应用程序正在Linux服务器上运行；然而，这并不意味着你需要强迫你的团队使用Linux。相反，他们可以继续使用他们喜欢的操作系统，因为JVM可以在Windows、Linux和Mac上运行。
- en: Over the last few years, many programming languages have been written and widely
    adopted to solve different kinds of problems. Many of them run on JVMs, such as
    Scala, Groovy, Kotlin, and Jython, because of the benefits that this offers. All
    of the compiled code of these programming languages check into bytecode, which
    can interact with Java code, introducing a new world of opportunities. It's always
    a good idea to give new programming languages a try, to see how they work in different
    scenarios, and to accomplish different demands. For example, Groovy is a friendly
    programming language that is simple and easy to use. In subsequent chapters, we
    will develop some example applications using different programming languages that
    run on the JVM. These examples will help you to embrace Groovy as a part of your
    toolbox.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，许多编程语言已经被编写并广泛采用来解决不同类型的问题。其中许多运行在JVM上，比如Scala、Groovy、Kotlin和Jython，因为这样做带来的好处。所有这些编程语言的编译代码都转换成了字节码，可以与Java代码互动，引入了新的机会。尝试新的编程语言总是一个好主意，看看它们在不同的场景中如何工作，以及如何满足不同的需求。例如，Groovy是一种友好的编程语言，简单易用。在接下来的章节中，我们将使用在JVM上运行的不同编程语言开发一些示例应用程序。这些示例将帮助你将Groovy作为你的工具箱的一部分。
- en: What framework is right for me?
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪种框架适合我？
- en: 'Even when a massive list of frameworks crowds the Java world, we encourage
    you to use Spring, not only because this book is about it, but because it offers
    the following benefits:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 即使Java世界拥有大量的框架，我们仍然鼓励你使用Spring，不仅因为这本书是关于它的，而且因为它提供了以下好处：
- en: Many of the programming languages listed previously are supported
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多之前列出的编程语言都得到了支持
- en: Spring offers the chance to build almost any kind of application that you want
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring提供了几乎任何类型的应用程序构建的机会
- en: The learning curve is not a big deal
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习曲线不是什么大问题
- en: It has great support for unit and integration testing
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对单元测试和集成测试有很好的支持
- en: Spring projects make it possible to grow your solution (we will discuss these
    in the next chapter)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring项目使你的解决方案能够成长（我们将在下一章讨论这些）
- en: It has excellent integration with the IDE of your choice
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与你选择的IDE的集成非常出色
- en: It has a great community
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个伟大的社区
- en: Tons of resources to learn about Spring are available on the internet
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在互联网上有大量关于Spring的学习资源
- en: It provides for smooth integration with the most common Java frameworks, such
    as Hibernate, iBatis, Atomikos, Vaadin, and Thymeleaf
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了与最常见的 Java 框架（如 Hibernate、iBatis、Atomikos、Vaadin 和 Thymeleaf）的平滑集成
- en: If this list is not enough for you, feel free to type "*why should I use Spring*"
    into Google; you will get a pleasant surprise, and will have the confidence to
    use the Spring framework.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个列表对您来说还不够，随时在 Google 中输入“*为什么我应该使用 Spring*”，您会得到一个惊喜，并且会有信心使用 Spring 框架。
- en: The operations dimension
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运营维度
- en: This dimension refers to mapping your architecture components to servers. These
    servers can live on-premise or in the cloud. The cloud has been becoming increasingly
    important over the past few years, and now, we can say that it's almost vital
    for every single business to count on services on the cloud.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个维度指的是将您的架构组件映射到服务器上。这些服务器可以在本地或云上运行。在过去几年中，云计算变得越来越重要，现在，我们可以说，对于每个企业来说，依赖云上的服务几乎是必不可少的。
- en: The mapping of your software architecture components will depend on what they
    do and how the interaction occurs among your components.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您的软件架构组件的映射将取决于它们的功能以及组件之间的交互方式。
- en: How to deploy an application
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何部署应用程序
- en: 'This point is crucial because deploying a Rest API is not the same as deploying
    a distributed database or a big monolith application. In order to have a better
    understanding of the best approach for deploying a component, you will need to
    research the products supporting it. This can be quite simple; for example, by
    deploying a Spring Boot application that can run like a conventional Java application
    using the following widely-known command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点非常重要，因为部署 Rest API 不同于部署分布式数据库或大型单体应用程序。为了更好地了解部署组件的最佳方法，您需要研究支持它的产品。这可能非常简单；例如，通过部署一个可以像常规
    Java 应用程序一样运行的 Spring Boot 应用程序，使用以下广为人知的命令：
- en: '[PRE0]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, in other cases, some products offer the chance to be deployed as clusters,
    where you will need to consider all of the options available and what your needs
    are. Depending on how in-demand your software is, you will need to have fewer
    or more nodes serving your users' demands. As you have probably noticed, even
    this dimension is derived from the business.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在其他情况下，一些产品提供了作为集群部署的机会，您需要考虑所有可用的选项以及您的需求。根据您的软件需求有多高，您将需要有更少或更多的节点来满足用户的需求。您可能已经注意到，即使这个维度也是从业务中衍生出来的。
- en: How interaction occurs among your components
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的组件之间的交互如何发生
- en: Let's imagine that we have a regular web application persisting information
    in a database. This web application is deployed in server A, and the database
    is deployed in server B. Common sense leads us to realize that the latency won't
    be the same, whether both servers are located in the same or different data centers.
    Another consideration is, of course, where the end users are located. Today, the
    cloud offers the chance to choose where you want to deploy your components, depending
    on your needs, which is helpful when it comes to providing a better user experience.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们有一个常规的 Web 应用程序，将信息保存在数据库中。这个 Web 应用程序部署在服务器 A 上，数据库部署在服务器 B 上。常识告诉我们，无论这两台服务器位于同一个数据中心还是不同的数据中心，延迟都不会相同。另一个考虑因素当然是最终用户的位置。如今，云计算提供了选择在哪里部署组件的机会，这取决于您的需求，这在提供更好的用户体验时非常有帮助。
- en: Dealing with infrastructure
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理基础设施
- en: Once these points have been considered, another aspect to bear in mind is how
    to manage the infrastructure.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑了这些因素之后，需要考虑的另一个方面是如何管理基础设施。
- en: 'We all know that provisioning new servers is always a headache when we need
    to start from scratch because we will need to install the OS and all of the required
    tooling to make our application work. Some of these require specific files, directories,
    environmental variables, and other artifacts in order to work, which makes this
    process even more complicated. Fortunately, the Infrastructure as Code approach,
    discussed in the following section, will help us reduce the effort of provisioning
    new servers, and will give us other benefits, such as the following points:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道，当我们需要从头开始启动新服务器时，总是一件头疼的事，因为我们需要安装操作系统和所有必需的工具，使我们的应用程序正常工作。其中一些需要特定的文件、目录、环境变量和其他工件才能正常工作，这使得这个过程变得更加复杂。幸运的是，下一节讨论的基础设施即代码方法将帮助我们减少新服务器的配置工作量，并为我们带来其他好处，例如以下几点：
- en: Understanding the infrastructure
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解基础设施
- en: Versioning
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制
- en: Testing
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Understanding the infrastructure
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解基础设施
- en: 'Files are used to store the required configuration and steps needed to provision
    a server in the form of executable scripts. When a new adjustment to an existing
    server is necessary, the idea is to make these changes using the script files,
    instead of directly on the server. This will allow us to get the following benefits:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 文件用于存储所需的配置和步骤，以可执行脚本的形式来配置服务器。当需要对现有服务器进行新的调整时，想法是使用脚本文件进行这些更改，而不是直接在服务器上进行。这将使我们获得以下好处：
- en: Immutable servers
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变服务器
- en: Easy application of changes
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松应用更改
- en: Having more than one identical server
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有多个相同的服务器
- en: Rebuilding a new server from scratch very quickly, without errors
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速从头开始重建新服务器，无错误
- en: Moreover, technical people will be able to read and understand these scripts,
    allowing for an increase of shared understanding around the process of provisioning
    new infrastructure, which is excellent.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，技术人员将能够阅读和理解这些脚本，从而增加对新基础设施配置过程的共享理解，这是非常好的。
- en: Versioning
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制
- en: Keeping the written scripts versioned using a **Version Control System** (**VCS**)
    will allow us to track changes in the script files; this is helpful for increasing
    the audibility of the written code that is being used to shape your infrastructure.
    During the versioning process, builds can (and should) be triggered to validate
    the written code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**版本控制系统**（VCS）对编写的脚本进行版本控制将使我们能够跟踪脚本文件的更改；这有助于增加正在用于塑造你的基础设施的编写代码的可审计性。在版本控制过程中，可以（也应该）触发构建来验证编写的代码。
- en: Another benefit of versioning is that you can revert changes when needed. Imagine
    that you are writing code to make upgrades to your servers; if an issue is introduced
    during this process, you can always make a rollback and keep using the last stable
    version while the problem is solved.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制的另一个好处是在需要时可以回滚更改。想象一下，你正在编写代码来升级你的服务器；如果在这个过程中引入了问题，你总是可以进行回滚，并继续使用上一个稳定版本，直到问题解决。
- en: Testing
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: There is no way of knowing whether something is working as expected if it has
    not been tested. Treating the Infrastructure as Code offers us the ability to
    test the code used to accomplish this goal, to validate and be sure that it works
    as expected. Otherwise, you will need to do these validations manually, and think
    about the debugging process involved at this level to identify where the errors
    are. Even when you could have Infrastructure as Code without testing, it's highly
    recommended to run tests on the scripts that have been created.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有经过测试，就无法知道某个东西是否按预期工作。将基础设施视为代码使我们能够测试用于实现此目标的代码，以验证并确保其按预期工作。否则，你将需要手动进行这些验证，并考虑在此级别涉及的调试过程，以确定错误的位置。即使你可以在没有测试的情况下拥有基础设施作为代码，也强烈建议对已创建的脚本运行测试。
- en: Embracing the Infrastructure as Code approach will help us to take full advantage
    of computers and systems, in order to make the process less tedious for us, and
    people should only be working in front of a data center when an issue occurs.
    This will also help you to keep your infrastructure up to date in a quick and
    easy manner. If you want an in-depth understanding of how to embrace this approach
    effectively, I encourage you to read the *Infrastructure as Code* book by Kief
    Morris.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 采用基础设施作为代码的方法将帮助我们充分利用计算机和系统，以使这个过程对我们来说变得不那么繁琐，人们应该只在出现问题时才在数据中心前工作。这也将帮助你以一种快速简便的方式保持你的基础设施更新。如果你想深入了解如何有效地采用这种方法，我鼓励你阅读Kief
    Morris的《基础设施作为代码》一书。
- en: Cloud versus on-premise
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云与本地
- en: The choice between using servers on the cloud and using them on-premise is a
    big decision, governed by the restrictions and needs of your business. For security
    reasons, some companies are restricted to use on-premise infrastructures, which
    is probably due to a misconception about how security is managed in the cloud.
    Regardless, this restriction invalidates any attempt to move the infrastructure
    to the cloud.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用云上服务器和使用本地服务器之间做出选择是一个重大决定，受到你的业务的限制和需求的影响。出于安全原因，一些公司受限于使用本地基础设施，这可能是因为对云安全管理方式的误解。无论如何，这种限制都使得任何将基础设施迁移到云上的尝试都变得无效。
- en: On the other hand, if you have the chance to choose between these two options,
    I encourage you to use the cloud. It offers many benefits, such as pay as you
    go, which will allow you to save a significant amount of money during the first
    releases of your application. Some services charge you a few cents per hour, depending
    on what you need and the licensing model of the software that you use. For example,
    using free and proprietary software is not the same as using a server with Windows
    or Linux. In the same way, it is not the same as using an RDBMS, such as MariaDB
    or Oracle.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你有机会在这两个选项之间进行选择，我鼓励你使用云。它提供了许多好处，比如按需付费，这将使你在应用程序首次发布期间节省大量资金。一些服务根据你的需求和所使用软件的许可模式，每小时收取几美分的费用。例如，使用免费和专有软件与使用带有Windows或Linux的服务器是不同的。同样，使用关系型数据库管理系统（RDBMS），如MariaDB或Oracle，也是不同的。
- en: Even when you made the choice to use the cloud, there are a few considerations
    that you need to bear in mind in order to choose the right cloud provider for
    you, according to the set of features required. Some cloud providers, like AWS,
    provide a bunch of services for computing, storage, management tools, analytics,
    and so on, while others, like Heroku, offer a lower quantity of features that
    are good enough, depending on your demands. It isn't a good idea to choose a provider
    just because it gives you more services, because this also implies a higher cost.
    Even when the number of services provided by different vendors is similar, the
    simplicity of the process of deploying an application using the providers mentioned
    earlier is significant.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你选择使用云，你也需要考虑一些因素，以便根据所需的功能选择适合你的云服务提供商。一些云服务提供商，如AWS，提供了大量的计算、存储、管理工具、分析等服务，而其他一些，如Heroku，提供了足够的功能，取决于你的需求。选择一个提供商仅仅因为它提供更多服务并不是一个好主意，因为这也意味着更高的成本。即使不同供应商提供的服务数量相似，使用前面提到的供应商部署应用程序的过程的简单性也是显著的。
- en: Deploying your application
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署你的应用程序
- en: There is no point in writing code that won't be brought to production. Regardless
    of whether you deploy your application to the cloud or in your on-premise environment,
    you can use some techniques and tools to automate the deployment process. This
    will help you to reduce the amount of effort required.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 编写不会被投入生产的代码是没有意义的。无论你是将应用程序部署到云上还是在本地环境中，你都可以使用一些技术和工具来自动化部署过程。这将帮助你减少所需的工作量。
- en: During the deployment process of a software system some years ago, the whole
    team writing the application had to sit with the operations team, just in case
    something went wrong. Consequently, the deployment date used to be scary for both
    technical and business people involved in the project. Fortunately, this has changed.
    Let's review how this change occurred.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在几年前的软件系统部署过程中，整个应用程序编写团队不得不与运营团队一起坐在一起，以防万一出了问题。因此，部署日期过去对于项目中涉及的技术和业务人员来说都是可怕的。幸运的是，这种情况已经改变了。让我们回顾一下这种变化是如何发生的。
- en: 'Automation is a must when we are entering this field. There are many CI tools
    available for creating pipelines that will help you to automate deployments. The
    most widely used of these are Jenkins, Travis CI, Go CD, Codeship, and Bamboo,
    among others. With the help of these tools, you can create a pipeline that often
    involves the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入这个领域时，自动化是必须的。有许多CI工具可用于创建流水线，这将帮助您自动化部署。其中最广泛使用的是Jenkins、Travis CI、Go
    CD、Codeship和Bamboo等。借助这些工具，您可以创建一个通常包括以下内容的流水线：
- en: Downloading the source code
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载源代码
- en: Compiling the code
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码
- en: Running a defined set of tests
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一组定义的测试
- en: Deploying the code
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署代码
- en: 'The main step is the third one, which involves different sorts of tests, such
    as those listed here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 主要步骤是第三步，涉及不同类型的测试，比如这里列出的测试：
- en: Unit tests
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration tests
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: Functional tests
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试
- en: Performance tests
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测试
- en: The more tests you include as a part of your application, the more confidence
    you'll gain. This is the only way to get rid of the fear caused by deployment.
    After all, if your tests verify that the functionality is working as expected,
    there is no reason to be worried about the deployment.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在应用程序中包含更多的测试，你将获得更多的信心。这是摆脱部署恐惧的唯一途径。毕竟，如果你的测试验证功能按预期工作，就没有理由担心部署。
- en: These CI tools also include support for sending notifications about the pipelines,
    generating metrics around the code, executing configuration scripts, and completing
    some other steps inherent to deployment. These pipelines are often triggered by
    commits, and they can also be scheduled.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些CI工具还包括支持发送有关流水线的通知，生成围绕代码的指标，执行配置脚本，并完成一些与部署相关的其他步骤。这些流水线通常由提交触发，也可以被调度。
- en: The adoption of a CI tool is the first step toward automating and managing your
    deployments in a better way. At this point, you will want to adopt practices like
    Continuous Integration, Continuous Delivery, and DevOps, which we will explain
    in depth in [Chapter 11](81e880b2-2345-4231-b7d5-d558f3c55955.xhtml), *DevOps
    and Release Management*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 采用CI工具是朝着更好地自动化和管理部署的第一步。在这一点上，你将希望采用持续集成、持续交付和DevOps等实践，我们将在[第11章](81e880b2-2345-4231-b7d5-d558f3c55955.xhtml)中深入解释，*DevOps和发布管理*。
- en: The C4 model
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C4模型
- en: In general, if something is not visible, it won't provide the desired effect.
    Even the most advanced software, produced with the most cutting-edge technology,
    is entirely useless if the team that works on it is unable to understand it. All
    of the efforts applied by the team will be a waste of time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果某事物不可见，它就不会产生期望的效果。即使是使用最尖端技术生产的最先进软件，如果工作在其上的团队无法理解它，那么它就是完全无用的。团队所付出的所有努力都将是浪费时间。
- en: Simply designing a software architecture isn't enough. It has to be shared with
    the whole team in a way that allows them to use it correctly when fulfilling their
    activities. The documentation made by the architects speaks for them today, when
    they should be doing things other than answering a hundred questions about software
    architecture, and it speaks for them tomorrow when they have left the project
    and someone else is in charge of its evolution and maintenance.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅设计软件架构是不够的。它必须以一种允许整个团队正确使用它的方式与整个团队共享。架构师制作的文档今天代表了他们，当他们应该做其他事情而不是回答关于软件架构的一百个问题时，它代表了他们，明天当他们离开项目，其他人负责其演进和维护时，它也代表了他们。
- en: The second principle of the agile manifesto ([http://agilemanifesto.org](http://agilemanifesto.org))
    is that *"teams should value working software over comprehensive documentation."*
    This is often interpreted incorrectly by people believing that no documentation
    should be produced at all. Instead, the idea behind this principle is to encourage
    teams to only produce valuable documentation, and that's precisely what the C4
    model looks for.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷宣言的第二个原则([http://agilemanifesto.org](http://agilemanifesto.org))是“团队应该重视可工作的软件，而不是全面的文档。”这经常被人们错误地解释为不应该产生任何文档。相反，这个原则背后的想法是鼓励团队只产生有价值的文档，这正是C4模型所寻求的。
- en: 'This model provides an easy way to communicate the design of the system to
    the whole team. It starts from a high-level viewpoint, and it can be used to delve
    into the smallest details of the software that is (or will be) produced. This
    model proposes four diagrams, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型提供了一种向整个团队传达系统设计的简单方法。它从高层视角开始，并可以用来深入到（或将要）生产的软件的最小细节。这个模型提出了四个图表，如下：
- en: Context diagram
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文图
- en: Container diagram
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器图
- en: Components diagram
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件图
- en: Class diagram
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类图
- en: Context diagram
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文图
- en: The context diagram provides the big picture of the users and the other software
    systems that it interacts with. All technical elements should be avoided in order
    to keep it simple and easy to understand. A context diagram should be straightforward
    enough to be understood by non-technical people.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文图提供了用户和其他软件系统的整体情况，以及它所互动的情况。为了保持简单易懂，所有技术元素都应该避免。上下文图应该足够简单，以便非技术人员能够理解。
- en: 'The following shows a diagram contextualized for the example proposed in [Chapter
    1](21088489-d3dd-4c4d-8969-ac7ec0844132.xhtml), *Software Architecture Today*:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了一个为[第1章](21088489-d3dd-4c4d-8969-ac7ec0844132.xhtml)中提出的示例进行上下文化的图表，*今日软件架构*：
- en: '![](img/f9f07d90-6234-4717-8ece-91c6d7a0f6b5.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9f07d90-6234-4717-8ece-91c6d7a0f6b5.png)'
- en: Context diagram
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文图
- en: Container diagram
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器图
- en: 'Containers are units that are in charge of hosting code or data. Consequently,
    this diagram shows the containers involved in the application, providing high-level
    details about how they interact with each other, as well as some other technical
    details to illustrate how the system works. Let''s look at this diagram as it
    applies to our example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是负责承载代码或数据的单元。因此，这个图表展示了应用中涉及的容器，提供了它们如何相互交互的高层细节，以及一些其他技术细节来说明系统的工作原理。让我们看看这个图表如何适用于我们的例子：
- en: '![](img/97eb6c40-48dc-421f-8af1-944c89457b3a.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97eb6c40-48dc-421f-8af1-944c89457b3a.jpg)'
- en: Container diagram
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 容器图
- en: Components diagram
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件图
- en: 'The idea behind this diagram is to show you how a container is shaped by components
    and the interactions among them. The components diagram for our example is as
    follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表的理念是展示容器是如何由组件和它们之间的交互所塑造的。我们例子的组件图如下：
- en: '![](img/68a82b05-a0b8-4057-8590-d0241b11fb8d.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68a82b05-a0b8-4057-8590-d0241b11fb8d.png)'
- en: Components diagram
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 组件图
- en: Class diagram
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类图
- en: Since the main idea behind the C4 model is to remove unnecessary diagrams, the
    class diagram should be avoided, and should only be used when it's vital to illustrate
    specific details of an application. This diagram is intended for technical people,
    and it can be used when there is an element of your application that people should
    pay close attention to; it can also be used to clarify some specific parts in
    the code that might cause confusion.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C4模型的主要理念是去除不必要的图表，类图应该被避免，只有在必要时才应该用于说明应用程序的具体细节。这个图表是为技术人员设计的，当应用程序中有一些元素需要人们密切关注时可以使用它；它也可以用于澄清可能导致混淆的代码中的特定部分。
- en: 'Although this diagram is not necessary for our example, we will show it for
    illustrative purposes:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个图表对我们的例子来说并不必要，但我们将展示它以作说明用途：
- en: '![](img/1ec2b9eb-4079-400a-a4b4-00b7927cf7f0.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ec2b9eb-4079-400a-a4b4-00b7927cf7f0.jpg)'
- en: Class diagram
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 类图
- en: As you may have noticed, the four diagrams that we have presented are not difficult
    to create, and they are helpful when it comes to acquiring a better understanding
    of a system. Even when they are simple, it's always a good idea to review these
    diagrams from time to time to ensure that they are updated. Outdated documentation
    can lead to misconceptions, instead of improving the understanding of the system.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，我们提出的这四个图表并不难创建，而且在获得对系统更好理解时是有帮助的。即使它们很简单，定期审查这些图表以确保它们是最新的总是一个好主意。过时的文档可能导致误解，而不是改善对系统的理解。
- en: Feel free to avoid creating any diagrams that you do not find helpful. Investing
    time in building unnecessary artifacts is something that you should avoid.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请随意避免创建任何你认为不必要的图表。投入时间建立不必要的工件是应该避免的事情。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the four main dimensions associated with software
    architecture and looked at how they affect the way we build our applications.
    We also reviewed the C4 model that's used to document system architectures, using
    a lean approach that helps us to avoid wasting time in creating unnecessary documentation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了与软件架构相关的四个主要维度，并看了它们如何影响我们构建应用程序的方式。我们还回顾了用于记录系统架构的C4模型，使用了一种精简的方法，帮助我们避免浪费时间创建不必要的文档。
- en: In the next chapter, we will review Spring Projects and how they can be used
    to create applications that satisfy different business demands.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾Spring项目以及它们如何用于创建满足不同业务需求的应用程序。
